- en: 文と式
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文と式
- en: 原文：[https://jsprimer.net/basic/statement-expression/](https://jsprimer.net/basic/statement-expression/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://jsprimer.net/basic/statement-expression/](https://jsprimer.net/basic/statement-expression/)
- en: 本格的に基本文法について学ぶ前に、JavaScriptというプログラミング言語がどのような要素からできているかを見ていきましょう。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本格的に基本文法について学ぶ前に、JavaScriptというプログラミング言語がどのような要素からできているかを見ていきましょう。
- en: JavaScriptは、**文**（Statement）と**式**（Expression）から構成されています。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScriptは、**文**（Statement）と**式**（Expression）から構成されています。
- en: '[](#expression)*式*'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#expression)*式*'
- en: '***式**（Expression）を簡潔に述べると、値を生成し、変数に代入できるものを言います。'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '***式**（Expression）を簡潔に述べると、値を生成し、変数に代入できるものを言います。'
- en: '`42`のようなリテラルや`foo`といった変数、関数呼び出しが式です。 また、`1 + 1`のような式と演算子の組み合わせも式と呼びます。'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`42`のようなリテラルや`foo`といった変数、関数呼び出しが式です。 また、`1 + 1`のような式と演算子の組み合わせも式と呼びます。'
- en: 式の特徴として、式を評価すると結果の値を得ることができます。 この結果の値を**評価値**と呼びます。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 式の特徴として、式を評価すると結果の値を得ることができます。 この結果の値を**評価値**と呼びます。
- en: 評価した結果を変数に代入できるものは**式**であるという理解で問題ありません。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 評価した結果を変数に代入できるものは**式**であるという理解で問題ありません。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[](#statement)*文*'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#statement)*文*'
- en: '***文**（Statement）を簡潔に述べると、処理する1ステップが1つの文と言えます。 JavaScriptでは、文の末尾にセミコロン(`;`)を置くことで文と文に区切りをつけます。'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '***文**（Statement）を簡潔に述べると、処理する1ステップが1つの文と言えます。 JavaScriptでは、文の末尾にセミコロン(`;`)を置くことで文と文に区切りをつけます。'
- en: ソースコードとして書かれた文を上から処理していくことで、プログラムが実行されます。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ソースコードとして書かれた文を上から処理していくことで、プログラムが実行されます。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: たとえば、if文やfor文などが**文**と呼ばれるものです。 次のように、文の処理の一部として式を含むことがあります。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: たとえば、if文やfor文などが**文**と呼ばれるものです。 次のように、文の処理の一部として式を含むことがあります。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 一方、if文などは文であり式にはなれません。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一方、if文などは文であり式にはなれません。
- en: '**式**ではないため、if文を変数へ代入することはできません。 次のようなコードは構文として問題があるため、構文エラー（`SyntaxError`）となります。'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**式**ではないため、if文を変数へ代入することはできません。 次のようなコードは構文として問題があるため、構文エラー（`SyntaxError`）となります。'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[](#expression-statement)*式文*'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#expression-statement)*式文*'
- en: '*一方で、**式**（Expression）は**文**（Statement）になれます。文となった式のことを**式文**と呼びます。 基本的に文が書ける場所には式を書けます。'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*一方で、**式**（Expression）は**文**（Statement）になれます。文となった式のことを**式文**と呼びます。 基本的に文が書ける場所には式を書けます。'
- en: その際に、**式文**（Expression statement）は文の一種であるため、セミコロンで文を区切っています。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: その際に、**式文**（Expression statement）は文の一種であるため、セミコロンで文を区切っています。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 式は文になれますが、先ほどのif文のように文は式になれません。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 式は文になれますが、先ほどのif文のように文は式になれ���せん。
- en: '[](#block-statement)*ブロック文*'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#block-statement)*ブロック文*'
- en: '*次のような、文を`{`と`}`で囲んだ部分を**ブロック**と言います。 ブロックには、複数の**文**が書けます。'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*次のような、文を`{`と`}`で囲んだ部分を**ブロック**と言います。 ブロックには、複数の**文**が書けます。'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ブロック文は単独でも書けますが、基本的にはif文やfor文など他の構文と組み合わせて書くことがほとんどです。 次のコードでは、if文とブロック文を組み合わせることで、if文の処理内容に複数の文を書いています。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ブロック文は単独でも書けますが、基本的にはif文やfor文など他の構文と組み合わせて書くことがほとんどです。 次のコードでは、if文とブロック文を組み合わせることで、if文の処理内容に複数の文を書いています。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 文の末尾にはセミコロンをつけるとしていましたが、 例外として**ブロックで終わる文**の末尾には、セミコロンが不要となっています。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 文の末尾にはセミコロンをつけるとしていましたが、 例外として**ブロックで終わる文**の末尾には、セミコロンが不要となっています。
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[](#isolate-block-statement)*[コラム] 単独のブロック文の活用*'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#isolate-block-statement)*[コラム] 単独のブロック文の活用*'
- en: '*アプリケーションのソースコードにif文などと組み合わせない単独のブロック文を書くことはほとんどありません。 しかし、REPLで同じコードの一部を変更して実行を繰り返している場合には、単独のブロック文が役に立つ機会もあります。'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*アプリケーションのソースコードにif文などと組み合わせない単独のブロック文を書くことはほとんどありません。 しかし、REPLで同じコードの一部を変更して実行を繰り返している場合には、単独のブロック文が役に立つ機会もあります。'
- en: REPLでは、次のように同じ変数名を再定義すると、構文エラーが発生します（詳細は「[変数と宣言](../variables/)」の章の「[`var`の問題](../variables/#var-issues)」を参照）。
    そのため、同じコードを再び実行するには、ブラウザでページをリロードして変数定義をリセットしないといけませんでした。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REPLでは、次のように同じ変数名を再定義すると、構文エラーが発生します（詳細は「[変数と宣言](../variables/)」の章の「[`var`の問題](../variables/#var-issues)」を参照）。
    そのため、同じコードを再び実行するには、ブラウザでページをリロードして変数定義をリセットしないといけませんでした。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: この問題は単独のブロック文で変数定義を囲むことで回避できます。 ブロック文（`{}`）の中でletやconstを用いて変数を定義しても、そのブロック文の外には影響しません。
    そのため、次のようにブロック文で囲んでおけば、同じ変数名を定義しても構文エラー（`SyntaxError`）にはなりません。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: この問題は単独のブロック文で変数定義を囲むことで回避できます。 ブロック文（`{}`）の中でletやconstを用いて変数を定義しても、そのブロック文の外には影響しません。
    そのため、次のようにブロック文で囲んでおけば、同じ変数名を定義しても構文エラー（`SyntaxError`）にはなりません。
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: これは、ブロックスコープという仕組みによるものですが、詳しい仕組みについては「[関数とスコープ](../function-scope/)」の章で解説します。
    今は、ブロック文を使うとREPLでの試行錯誤がしやすいということだけ知っていれば問題ありません。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: これは、ブロックスコープという仕組みによるものですが、詳しい仕組みについては「[関数とスコープ](../function-scope/)」の章で解説します。
    今は、ブロック文を使うとREPLでの試行錯誤がしやすいということだけ知っていれば問題ありません。
- en: '[](#function-statement-and-function-expression)*関数宣言（文）と関数式*'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#function-statement-and-function-expression)*関数宣言（文）と関数式*'
- en: '*「[関数と宣言](../function-declaration/)」の章において、関数を定義する方法を学びました。 functionキーワードから文を開始する**関数宣言**と、変数へ**関数式**を代入する方法があります。'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*「[関数と宣言](../function-declaration/)」の章において、関数を定義する方法を学びました。 functionキーワードから文を開始する**関数宣言**と、変数へ**関数式**を代入する方法があります。'
- en: 関数宣言（文）と関数式は、どちらも`function`というキーワードを利用しています。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 関数宣言（文）と関数式は、どちらも`function`というキーワードを利用しています。
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: この文と式の違いを見ると、関数宣言文にはセミコロンがなく、関数式にはセミコロンがあります。 このような違いがなぜ生まれるのかは、ここまでの内容から説明できます。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: この文と式の違いを見ると、関数宣言文にはセミコロンがなく、関数式にはセミコロンがあります。 このような違いがなぜ生まれるのかは、ここまでの内容から説明できます。
- en: 関数宣言（文）で定義した`learn`関数には、セミコロンがありません。 これは、**ブロックで終わる文**にはセミコロンが不要であるためです。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 関数宣言（文）で定義した`learn`関数には、セミコロンがありません。 これは、**ブロックで終わる文**にはセミコロンが不要であるためです。
- en: 一方、関数式を`read`変数へ代入したものには、セミコロンがあります。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一方、関数式を`read`変数へ代入したものには、セミコロンがあります。
- en: 「ブロックで終わる関数であるためセミコロンが不要なのでは？」と思うかもしれません。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 「ブロックで終わる関数であるためセミコロンが不要なのでは？」と思うかもしれません。
- en: しかし、この無名関数は**式**であり、この処理は変数を宣言する文の一部であることがわかります。 つまり、次のように置き換えても同じと言えるため、末尾にセミコロンが必要となります。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: しかし、この無名関数は**式**であり、この処理は変数を宣言する文の一部であることがわかります。 つまり、次のように置き換えても同じと言えるため、末尾にセミコロンが必要となります。
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[](#statement-expression-summary)*まとめ*'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#statement-expression-summary)*まとめ*'
- en: '*この章では次のことについて学びました。'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*この章では次のことについて学びました。'
- en: JavaScriptは**文**（Statement）と**式**（Expression）から構成される
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScriptは**文**（Statement）と**式**（Expression）から構成される
- en: 文は式になれない
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文は式になれない
- en: 式は文になれる（**式文**）
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 式は文になれる（**式文**）
- en: 文の末尾にはセミコロンをつける
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文の末尾にはセミコロンをつける
- en: ブロックで終わる文は例外的にセミコロンをつけなくてよい
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ブロックで終わる文は例外的にセミコロンをつけなくてよい
- en: JavaScriptには、特殊なルールに基づき、セミコロンがない文も行末に自動でセミコロンが挿入されるという仕組みがあります。 しかし、この仕組みは構文を正しく解析できない場合に、セミコロンを足すという挙動を持っています。
    これにより、意図しない挙動を生むことがあります。そのため、必ず**文**の末尾にはセミコロンを書くようにします。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScriptには、特殊なルールに基づき、セミコロンがない文も行末に自動でセミコロンが挿入されるという仕組みがあります。 しかし、この仕組みは構文を正しく解析できない場合に、セミコロンを足すという挙動を持っています。
    これにより、意図しない挙動を生むことがあります。そのため、必ず**文**の末尾にはセミコロンを書くようにします。
- en: エディターやIDEの中にはセミコロンの入力の補助をしてくれるものや、[ESLint](https://eslint.org/ "ESLint - Pluggable
    JavaScript linter")などのLintツールを使うことで、 セミコロンが必要なのかをチェックできます。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: エディターやIDEの中にはセミコロンの入力の補助をしてくれるものや、[ESLint](https://eslint.org/ "ESLint - Pluggable
    JavaScript linter")などのLintツールを使うことで、 セミコロンが必要なのかをチェックできます。
- en: セミコロンが必要か見分けるにはある程度慣れが必要ですが、ツールを使って静的にチェックできます。 そのため、ツールなどの支援を受けて経験的に慣れていくこともよい方法と言えます。*******
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: セミコロンが必要か見分けるにはある程度慣れが必要ですが、ツールを使って静的にチェックできます。 そのため、ツールなどの支援を受けて経験的に慣れていくこともよい方法と言えます。*******
