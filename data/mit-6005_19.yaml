- en: 'Reading 19: Concurrency'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 19：并发性
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 免受错误影响 | 易于理解 | 为变化做好准备 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确，未来也正确。 | 与未来的程序员清晰沟通，包括未来的自己。 | 设计以适应变化而无需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: The message passing and shared memory models of concurrency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递和共享内存并发模型
- en: Concurrent processes and threads, and time slicing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发进程和线程，以及时间片
- en: The danger of race conditions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争条件的危险
- en: Concurrency
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发性
- en: '*Concurrency* means multiple computations are happening at the same time. Concurrency
    is everywhere in modern programming, whether we like it or not:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发* 意味着多个计算同时进行。并发在现代编程中随处可见，无论我们是否喜欢：'
- en: Multiple computers in a network
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络中的多台计算机
- en: Multiple applications running on one computer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一台计算机上运行的多个应用程序
- en: Multiple processors in a computer (today, often multiple processor cores on
    a single chip)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机中的多个处理器（今天，通常是单个芯片上的多个处理器核心）
- en: 'In fact, concurrency is essential in modern programming:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，并发在现代编程中是必不可少的：
- en: Web sites must handle multiple simultaneous users.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站必须处理多个同时在线的用户。
- en: Mobile apps need to do some of their processing on servers (“in the cloud”).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用程序需要在服务器上进行一些处理（“在云端”）。
- en: Graphical user interfaces almost always require background work that does not
    interrupt the user. For example, Eclipse compiles your Java code while you’re
    still editing it.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形用户界面几乎总是需要在不打扰用户的情况下进行后台工作。例如，Eclipse 在您编辑代码时编译您的 Java 代码。
- en: Being able to program with concurrency will still be important in the future.
    Processor clock speeds are no longer increasing. Instead, we’re getting more cores
    with each new generation of chips. So in the future, in order to get a computation
    to run faster, we’ll have to split up a computation into concurrent pieces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 未来仍然能够使用并发编程将是重要的。处理器时钟速度不再增加。相反，每一代新芯片都会获得更多的核心。因此，在未来，为了使计算运行更快，我们将不得不将计算分割成并发片段。
- en: Two Models for Concurrent Programming
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两种并发编程模型
- en: 'There are two common models for concurrent programming: *shared memory* and
    *message passing*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程有两种常见模型：*共享内存* 和 *消息传递*。
- en: '![shared memory](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![共享内存](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory.png)'
- en: '**Shared memory.** In the shared memory model of concurrency, concurrent modules
    interact by reading and writing shared objects in memory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享内存。** 在共享内存并发模型中，并发模块通过读取和写入内存中的共享对象进行交互。'
- en: 'Examples of the shared-memory model:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存模型的示例：
- en: A and B might be two processors (or processor cores) in the same computer, sharing
    the same physical memory.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是同一台计算机中的两个处理器（或处理器核心），共享相同的物理内存。
- en: A and B might be two programs running on the same computer, sharing a common
    filesystem with files they can read and write.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是在同一台计算机上运行的两个程序，共享一个可以读写文件的公共文件系统。
- en: A and B might be two threads in the same Java program (we’ll explain what a
    thread is below), sharing the same Java objects.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是同一个 Java 程序中的两个线程（我们将在下面解释什么是线程），共享相同的 Java 对象。
- en: '![message passing](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![消息传递](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing.png)'
- en: '**Message passing.** In the message-passing model, concurrent modules interact
    by sending messages to each other through a communication channel. Modules send
    off messages, and incoming messages to each module are queued up for handling.
    Examples include:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息传递。** 在消息传递模型中，并发模块通过通过通信通道向彼此发送消息来进行交互。模块发送消息，每个模块的传入消息都会排队等待处理。示例包括：'
- en: A and B might be two computers in a network, communicating by network connections.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是通过网络连接进行通信的网络中的两台计算机。
- en: A and B might be a web browser and a web server – A opens a connection to B
    and asks for a web page, and B sends the web page data back to A.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是一个网络浏览器和一个网络服务器 - A 打开到 B 的连接并请求一个网页，B 将网页数据发送回 A。
- en: A and B might be an instant messaging client and server.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是即时通讯客户端和服务器。
- en: A and B might be two programs running on the same computer whose input and output
    have been connected by a pipe, like `ls | grep` typed into a command prompt.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是在同一台计算机上运行的两个程序，它们的输入和输出已经通过管道连接起来，就像在命令提示符中键入 `ls | grep` 一样。
- en: Processes, Threads, Time-slicing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程、线程、时间片分配
- en: 'The message-passing and shared-memory models are about how concurrent modules
    communicate. The concurrent modules themselves come in two different kinds: processes
    and threads.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递和共享内存模型涉及并发模块之间的通信方式。并发模块本身有两种不同的类型：进程和线程。
- en: '**Process**. A process is an instance of a running program that is *isolated*
    from other processes on the same machine. In particular, it has its own private
    section of the machine’s memory.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程**。进程是在同一台机器上与其他进程*隔离*的运行程序的实例。特别地，它拥有自己的机器内存的私有部分。'
- en: The process abstraction is a *virtual computer*. It makes the program feel like
    it has the entire machine to itself – like a fresh computer has been created,
    with fresh memory, just to run that program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 进程抽象是一个*虚拟计算机*。它使得程序感觉就像它拥有整个机器一样——就像一个全新的计算机被创建出来，拥有全新的内存，只是为了运行那个程序。
- en: Just like computers connected across a network, processes normally share no
    memory between them. A process can’t access another process’s memory or objects
    at all. Sharing memory between processes is *possible* on most operating systems,
    but it needs special effort. By contrast, a new process is automatically ready
    for message passing, because it is created with standard input & output streams,
    which are the `System.out` and `System.in` streams you’ve used in Java.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像通过网络连接的计算机一样，进程通常之间不共享内存。一个进程无法访问另一个进程的内存或对象。在大多数操作系统上，进程之间共享内存是*可能的*，但需要特殊的努力。相比之下，新进程自动准备好进行消息传递，因为它是用标准输入和输出流创建的，这些流就是您在Java中使用的`System.out`和`System.in`流。
- en: '**Thread**. A thread is a locus of control inside a running program. Think
    of it as a place in the program that is being run, plus the stack of method calls
    that led to that place (so the thread can go back up the stack when it reaches
    `return` statements).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**。线程是程序内正在运行的控制流。可以将其视为程序中正在运行的位置，以及导致该位置的方法调用堆栈（因此当线程达到`return`语句时，它可以回溯到堆栈的上层）。'
- en: Just as a process represents a virtual computer, the thread abstraction represents
    a *virtual processor*. Making a new thread simulates making a fresh processor
    inside the virtual computer represented by the process. This new virtual processor
    runs the same program and shares the same memory as other threads in the process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像进程代表着一个虚拟计算机一样，线程抽象表示着一个*虚拟处理器*。创建一个新线程模拟了在进程所代表的虚拟计算机内创建一个全新的处理器。这个新的虚拟处理器运行着与进程中其他线程相同的程序，并共享着相同的内存。
- en: Threads are automatically ready for shared memory, because threads share all
    the memory in the process. It takes special effort to get “thread-local” memory
    that’s private to a single thread. It’s also necessary to set up message-passing
    explicitly, by creating and using queue data structures. We’ll talk about how
    to do that in a future reading.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 线程自动准备好共享内存，因为线程共享进程中的所有内存。需要特殊的努力才能获得“线程本地”内存，即对单个线程私有的内存。还需要明确地设置消息传递，通过创建和使用队列数据结构来进行。我们将在以后的阅读中讨论如何做到这一点。
- en: '![time-slicing](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/time-slicing.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![时间片分配](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/time-slicing.png)'
- en: How can I have many concurrent threads with only one or two processors in my
    computer? When there are more threads than processors, concurrency is simulated
    by **time slicing**, which means that the processor switches between threads.
    The figure on the right shows how three threads T1, T2, and T3 might be time-sliced
    on a machine that has only two actual processors. In the figure, time proceeds
    downward, so at first one processor is running thread T1 and the other is running
    thread T2, and then the second processor switches to run thread T3\. Thread T2
    simply pauses, until its next time slice on the same processor or another processor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在我的计算机上只有一个或两个处理器的情况下拥有许多并发线程？当线程数量多于处理器时，通过**时间片分配**来模拟并发，这意味着处理器在线程之间切换。右图显示了在只有两个实际处理器的计算机上如何对三个线程T1、T2和T3进行时间片切片。在图中，时间向下进行，因此一开始一个处理器正在运行线程T1，另一个处理器正在运行线程T2，然后第二个处理器切换到运行线程T3。线程T2只是暂停，直到它在同一处理器或另一个处理器上的下一个时间片。
- en: On most systems, time slicing happens unpredictably and nondeterministically,
    meaning that a thread may be paused or resumed at any time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统上，时间片切换是不可预测和不确定的，这意味着线程可以随时暂停或恢复。
- en: 'In the Java Tutorials, read:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 教程中阅读：
- en: '**[Processes & Threads](http://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html)**
    (just 1 page)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[进程和线程](http://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html)**（只有
    1 页）'
- en: '**[Defining and Starting a Thread](http://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html)**
    (just 1 page)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[定义和启动线程](http://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html)**（只有
    1 页）'
- en: The second Java Tutorials reading shows two ways to create a thread.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 Java 教程的阅读展示了创建线程的两种方式。
- en: Never use their second way (subclassing `Thread`).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要使用他们的第二种方式（子类化 `Thread`）。
- en: Always implement the [`Runnable`](http://docs.oracle.com/javase/8/docs/api/?java/lang/Runnable.html)
    interface and use the `new Thread(..)` constructor.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是实现 [`Runnable`](http://docs.oracle.com/javase/8/docs/api/?java/lang/Runnable.html)
    接口，并使用 `new Thread(..)` 构造函数。
- en: 'Their example declares a named class that implements `Runnable`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的例子声明了一个实现 `Runnable` 的命名类：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A very common idiom is starting a thread with an [anonymous](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)
    `Runnable`, which eliminates the named class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的习惯是用一个[匿名](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)
    `Runnable` 启动一个线程，这消除了命名类：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Read: [using an anonymous `Runnable` to start a thread](anonymous-runnable/)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读：[使用匿名 `Runnable` 启动线程](anonymous-runnable/)
- en: reading exercises
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Processes and threads 1
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程 1
- en: When you run a Java program (for example, using the Run button in Eclipse),
    how many processors, processes, and threads are created at first?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个 Java 程序（例如，在 Eclipse 中使用“运行”按钮）时，最初会创建多少个处理器、进程和线程？
- en: 'Processors:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器：
- en: <select class="form-control"><option>no processors</option>,<option>one processor</option>,<option>one
    processor for each class in the program</option></select>(missing answer)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>没有处理器</option>,<option>一个处理器</option>,<option>程序中的每个类一个处理器</option></select>（缺少答案）
- en: 'Processes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 进程：
- en: <select class="form-control"><option>no processes</option>,<option>one process</option>,<option>one
    process for each class in the program</option></select>(missing answer)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>没有进程</option>,<option>一个进程</option>,<option>程序中的每个类一个进程</option></select>（缺少答案）
- en: 'Threads:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 线程：
- en: <select class="form-control"><option>no threads</option>,<option>one thread</option>,<option>one
    thread for each class in the program</option></select>(missing answer)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>没有线程</option>,<option>一个线程</option>,<option>程序中的每个类一个线程</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Processes and threads 2
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程 2
- en: 'Suppose we run `main` in this program, which contains bugs:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在这个包含错误的程序中运行 `main`：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How many new `Thread` objects are created?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少个新的 `Thread` 对象被创建？
- en: (missing answer)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: How many new threads are run?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少个新线程被运行？
- en: (missing answer)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: What is the maximum number of threads that might be running at the same time?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可能同时运行的最大线程数是多少？
- en: (missing answer)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Processes and threads 3
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程 3
- en: 'Suppose we run `main` in this program, which demonstrates two common bugs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在这个展示了两个常见错误的程序中运行 `main`：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How many new `Thread` objects are created?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少个新的 `Thread` 对象被创建？
- en: (missing answer)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: How many new threads are run?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少个新线程被运行？
- en: (missing answer)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Shared Memory Example
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享内存示例
- en: Let’s look at an example of a shared memory system. The point of this example
    is to show that concurrent programming is hard, because it can have subtle bugs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个共享内存系统的例子。这个例子的重点是展示并发编程很难，因为它可能有微妙的错误。
- en: '![shared memory model for bank accounts](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory-bank-account.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![银行账户的共享内存模型](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory-bank-account.png)'
- en: Imagine that a bank has cash machines that use a shared memory model, so all
    the cash machines can read and write the same account objects in memory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个银行有使用共享内存模型的取款机，因此所有取款机都可以读取和写入内存中相同的账户对象。
- en: 'To illustrate what can go wrong, let’s simplify the bank down to a single account,
    with a dollar balance stored in the `balance` variable, and two operations `deposit`
    and `withdraw` that simply add or remove a dollar:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可能出现的问题，让我们简化银行为一个单一账户，其中存储在 `balance` 变量中的一美元余额，并且有两个操作 `deposit` 和 `withdraw`，它们只是简单地添加或移除一美元：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Customers use the cash machines to do transactions like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 客户使用取款机进行如下交易：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this simple example, every transaction is just a one dollar deposit followed
    by a one-dollar withdrawal, so it should leave the balance in the account unchanged.
    Throughout the day, each cash machine in our network is processing a sequence
    of deposit/withdraw transactions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，每笔交易只是一个一美元存款，然后是一美元取款，所以它应该不会改变账户余额。在一天中，我们网络中的每台取款机都在处理一系列存款/取款交易。
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So at the end of the day, regardless of how many cash machines were running,
    or how many transactions we processed, we should expect the account balance to
    still be 0.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论一天结束时有多少台取款机在运行，或者我们处理了多少笔交易，我们应该期望账户余额仍然是0。
- en: But if we run this code, we discover frequently that the balance at the end
    of the day is *not* 0\. If more than one `cashMachine()` call is running at the
    same time – say, on separate processors in the same computer – then `balance`
    may not be zero at the end of the day. Why not?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们运行这段代码，我们会经常发现一天结束时余额*不是*0。如果多个 `cashMachine()` 调用同时运行 - 比如，在同一台计算机的不同处理器上
    - 那么 `balance` 在一天结束时可能不为零。为什么呢？
- en: Interleaving
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交错
- en: 'Here’s one thing that can happen. Suppose two cash machines, A and B, are both
    working on a deposit at the same time. Here’s how the `deposit()` step typically
    breaks down into low-level processor instructions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能发生的一种情况。假设两台取款机 A 和 B 同时在进行存款操作。这是 `deposit()` 步骤通常分解为低级处理器指令的方式：
- en: '| get balance (balance=0) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 获取余额 (余额=0) |'
- en: '| add 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 加 1 |'
- en: '| write back the result (balance=1) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 写回结果（余额=1） |'
- en: 'When A and B are running concurrently, these low-level instructions interleave
    with each other (some might even be simultaneous in some sense, but let’s just
    worry about interleaving for now):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当 A 和 B 同时运行时，这些低级指令会相互交错（在某种意义上甚至可能同时进行，但现在让我们只关注交错）：
- en: '| A | B |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| A | B |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A get balance (balance=0) |  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| A 获取余额 (余额=0) |  |'
- en: '| A add 1 |  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| A 加 1 |  |'
- en: '| A write back the result (balance=1) |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| A 写回结果（余额=1） |  |'
- en: '|  | B get balance (balance=1) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  | B 获取余额 (余额=1) |'
- en: '|  | B add 1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  | B 加 1 |'
- en: '|  | B write back the result (balance=2) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  | B 写回结果（余额=2） |'
- en: 'This interleaving is fine – we end up with balance 2, so both A and B successfully
    put in a dollar. But what if the interleaving looked like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交错是可以接受的 - 我们最终得到了余额2，因此 A 和 B 都成功存入了一美元。但如果交错看起来像这样呢：
- en: '| A | B |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| A | B |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A get balance (balance=0) |  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| A 获取余额 (余额=0) |  |'
- en: '|  | B get balance (balance=0) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  | B 获取余额 (余额=0) |'
- en: '| A add 1 |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| A 加 1 |  |'
- en: '|  | B add 1 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | B 加 1 |'
- en: '| A write back the result (balance=1) |  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| A 写回结果（余额=1） |  |'
- en: '|  | B write back the result (balance=1) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  | B 写回结果（余额=1） |'
- en: The balance is now 1 – A’s dollar was lost! A and B both read the balance at
    the same time, computed separate final balances, and then raced to store back
    the new balance – which failed to take the other’s deposit into account.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在余额是1 - A 的一美元丢失了！A 和 B 同时读取余额，计算出各自的最终余额，然后争先存储新余额 - 但未考虑对方的存款。
- en: Race Condition
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞争条件
- en: This is an example of a **race condition**. A race condition means that the
    correctness of the program (the satisfaction of postconditions and invariants)
    depends on the relative timing of events in concurrent computations A and B. When
    this happens, we say “A is in a race with B.”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**竞争条件**的例子。竞争条件意味着程序的正确性（后置条件和不变量的满足）取决于并发计算 A 和 B 中事件的相对时间。当这种情况发生时，我们说“A
    与 B 在竞争中”。
- en: Some interleavings of events may be OK, in the sense that they are consistent
    with what a single, nonconcurrent process would produce, but other interleavings
    produce wrong answers – violating postconditions or invariants.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件的交错可能是可以接受的，因为它们与单个、非并发进程产生的结果一致，但其他交错会产生错误答案 - 违反后置条件或不变量。
- en: Tweaking the Code Won’t Help
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整代码不会有帮助
- en: 'All these versions of the bank-account code exhibit the same race condition:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些版本的银行账户代码都表现出相同的竞争条件：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can’t tell just from looking at Java code how the processor is going to
    execute it. You can’t tell what the indivisible operations – the atomic operations
    – will be. It isn’t atomic just because it’s one line of Java. It doesn’t touch
    balance only once just because the balance identifier occurs only once in the
    line. The Java compiler, and in fact the processor itself, makes no commitments
    about what low-level operations it will generate from your code. In fact, a typical
    modern Java compiler produces exactly the same code for all three of these versions!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过查看Java代码，你无法确定处理器将如何执行它。你无法确定不可分割的操作 - 原子操作 - 将是什么。它不是原子的，仅仅因为它是一行Java。它不仅仅因为余额标识符只在一行中出现一次，就仅仅触及balance一次。Java编译器，事实上，处理器本身，对于它将从你的代码中生成的低级操作不作任何承诺。事实上，典型的现代Java编译器对这三个版本的代码产生的代码完全相同！
- en: The key lesson is that you can’t tell by looking at an expression whether it
    will be safe from race conditions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关键教训是，仅仅通过查看表达式，你无法确定它是否能够安全地免受竞态条件的影响。
- en: 'Read: **[Thread Interference](http://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html)**
    (just 1 page)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读：**[线程干扰](http://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html)**（仅1页）
- en: Reordering
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新排序
- en: It’s even worse than that, in fact. The race condition on the bank account balance
    can be explained in terms of different interleavings of sequential operations
    on different processors. But in fact, when you’re using multiple variables and
    multiple processors, you can’t even count on changes to those variables appearing
    in the same order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，情况甚至比那更糟。银行账户余额上的竞态条件可以解释为在不同处理器上对不同顺序的顺序操作进行了交错。但实际上，当您使用多个变量和多个处理器时，您甚至不能指望对这些变量的更改以相同的顺序出现。
- en: 'Here’s an example. Note that it uses a loop that continuously checks for a
    concurrent condition; this is called [busy waiting](https://en.wikipedia.org/wiki/Busy_waiting)
    and it is not a good pattern. In this case, the code is also broken:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子。请注意，它使用一个循环不断检查并发条件；这被称为[忙等待](https://en.wikipedia.org/wiki/Busy_waiting)，这不是一个好的模式。在这种情况下，代码也是错误的：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have two methods that are being run in different threads. `computeAnswer`
    does a long calculation, finally coming up with the answer 42, which it puts in
    the answer variable. Then it sets the `ready` variable to true, in order to signal
    to the method running in the other thread, `useAnswer`, that the answer is ready
    for it to use. Looking at the code, `answer` is set before `ready` is set, so
    once `useAnswer` sees `ready` as true, then it seems reasonable that it can assume
    that the `answer` will be 42, right? Not so.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种在不同线程中运行的方法。`computeAnswer`进行长时间计算，最终得出答案为42，并将其放入答案变量中。然后，它将`ready`变量设置为true，以向在另一个线程中运行的方法`useAnswer`发出信号，表明答案已准备好供其使用。查看代码，`answer`在`ready`设置之前设置，因此一旦`useAnswer`看到`ready`为true，那么假设`answer`将为42似乎是合理的，对吗？不是这样的。
- en: 'The problem is that modern compilers and processors do a lot of things to make
    the code fast. One of those things is making temporary copies of variables like
    answer and ready in faster storage (registers or caches on a processor), and working
    with them temporarily before eventually storing them back to their official location
    in memory. The storeback may occur in a different order than the variables were
    manipulated in your code. Here’s what might be going on under the covers (but
    expressed in Java syntax to make it clear). The processor is effectively creating
    two temporary variables, `tmpr` and `tmpa`, to manipulate the fields `ready` and
    `answer`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于现代编译器和处理器会对代码进行很多优化以提高速度。其中一项操作是在更快的存储器（处理器上的寄存器或高速缓存）中制作answer和ready等变量的临时副本，并在最终将它们存储回它们在内存中的官方位置之前暂时使用它们。存储可能以与在代码中操作变量的顺序不同的顺序发生。下面是可能在幕后进行的操作（但以Java语法表达，以便清晰表达）。处理器实际上正在创建两个临时变量，`tmpr`和`tmpa`，来操作字段`ready`和`answer`：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: reading exercises
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Interleaving 1
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 交错1
- en: 'Here’s the buggy code from our earlier exercise where two new threads are started:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前练习中的有错误的代码，其中启动了两个新线程：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Which of the following are possible outputs from this program:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些是此程序可能的输出：
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Interleaving 2
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 交错2
- en: 'Here’s the buggy code from our earlier exercise where no new threads are started:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前练习中的有错误的代码，其中没有启动新线程：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Which of the following are possible outputs from this program:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的可能输出是以下哪些：
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: （答案丢失）（答案丢失）（答案丢失）（答案丢失）
- en: (missing explanation)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: （解释丢失）
- en: Race conditions 1
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件1
- en: 'Consider the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Suppose `methodA` and `methodB` run **sequentially**, i.e. first one and then
    the other. What is the final value of `x`?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`methodA`和`methodB`**顺序**运行，即先一个再另一个。 `x`的最终值是多少？
- en: (missing answer)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: （答案丢失）
- en: (missing explanation)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: （解释丢失）
- en: Race conditions 2
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件2
- en: Now suppose `methodA` and `methodB` run **concurrently**, so that their instructions
    might interleave arbitrarily. Which of the following are possible final values
    of `x`?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设`methodA`和`methodB`**并发**运行，因此它们的指令可能会任意交错。 下面哪些是`x`的可能最终值？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: （答案丢失）（答案丢失）（答案丢失）（答案丢失）（答案丢失）（答案丢失）（答案丢失）
- en: (missing explanation)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: （解释丢失）
- en: Message Passing Example
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息传递示例
- en: '![message passing bank account example](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing-bank-account.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![消息传递银行账户示例](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing-bank-account.png)'
- en: Now let’s look at the message-passing approach to our bank account example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的银行帐户示例的消息传递方法。
- en: Now not only are the cash machine modules, but the accounts are modules, too.
    Modules interact by sending messages to each other. Incoming requests are placed
    in a queue to be handled one at a time. The sender doesn’t stop working while
    waiting for an answer to its request. It handles more requests from its own queue.
    The reply to its request eventually comes back as another message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不仅现金机模块，而且帐户也是模块。 模块通过向彼此发送消息进行交互。 输入的请求被放置在队列中以便逐个处理。 发送方在等待答案时不会停止工作。 它处理来自自己队列的更多请求。
    对其请求的回复最终会作为另一条消息返回。
- en: 'Unfortunately, message passing doesn’t eliminate the possibility of race conditions.
    Suppose each account supports `get-balance` and `withdraw` operations, with corresponding
    messages. Two users, at cash machines A and B, are both trying to withdraw a dollar
    from the same account. They check the balance first to make sure they never withdraw
    more than the account holds, because overdrafts trigger big bank penalties:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，消息传递并不能消除竞争条件的可能性。 假设每个帐户都支持`get-balance`和`withdraw`操作，具有相应的消息。 两个用户，在A和B的现金机上，都试图从同一个帐户中取出一美元。
    他们首先检查余额，以确保他们从未取出超过帐户持有的金额，因为透支会触发大额银行罚款：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The problem is again interleaving, but this time interleaving of the *messages*
    sent to the bank account, rather than the *instructions* executed by A and B.
    If the account starts with a dollar in it, then what interleaving of messages
    will fool A and B into thinking they can both withdraw a dollar, thereby overdrawing
    the account?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 问题再次是交错，但这次是银行账户发送的*消息*的交错，而不是A和B执行的*指令*。 如果账户一开始有一美元，那么什么消息的交错会愚弄A和B以为他们都可以取出一美元，从而透支账户？
- en: One lesson here is that you need to carefully choose the operations of a message-passing
    model. `withdraw-if-sufficient-funds` would be a better operation than just `withdraw`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个教训是你需要仔细选择消息传递模型的操作。 `withdraw-if-sufficient-funds`比仅`withdraw`更好。
- en: Concurrency is Hard to Test and Debug
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发测试和调试很困难
- en: If we haven’t persuaded you that concurrency is tricky, here’s the worst of
    it. It’s very hard to discover race conditions using testing. And even once a
    test has found a bug, it may be very hard to localize it to the part of the program
    causing it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有说服您并发是棘手的，那么这是最糟糕的情况。 使用测试很难发现竞争条件。 即使一次测试找到了一个错误，要将其定位到导致错误的程序部分也可能非常困难。
- en: Concurrency bugs exhibit very poor reproducibility. It’s hard to make them happen
    the same way twice. Interleaving of instructions or messages depends on the relative
    timing of events that are strongly influenced by the environment. Delays can be
    caused by other running programs, other network traffic, operating system scheduling
    decisions, variations in processor clock speed, etc. Each time you run a program
    containing a race condition, you may get different behavior.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 并发错误表现出非常差的可再现性。 很难使它们以相同的方式发生两次。 指令或消息的交错取决于事件的相对时间，这些事件受环境的强烈影响。 延迟可能是由其他运行中的程序，其他网络流量，操作系统调度决策，处理器时钟速度的变化等引起的。
    每次运行包含竞争条件的程序时，您可能会获得不同的行为。
- en: These kinds of bugs are *heisenbugs*, which are nondeterministic and hard to
    reproduce, as opposed to a *bohrbug*, which shows up repeatedly whenever you look
    at it. Almost all bugs in sequential programming are bohrbugs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的错误是*海森堡错误*，它们是不确定性的，难以复现，与*玻尔错误*相对，后者每次查看时都会出现。几乎所有的顺序编程中的错误都是玻尔错误。
- en: 'A heisenbug may even disappear when you try to look at it with `println` or
    `debugger`! The reason is that printing and debugging are so much slower than
    other operations, often 100-1000x slower, that they dramatically change the timing
    of operations, and the interleaving. So inserting a simple print statement into
    the cashMachine():'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至当你尝试用`println`或`debugger`查看时，海森堡错误可能会消失！原因是打印和调试比其他操作慢得多，通常慢100-1000倍，它们会显著改变操作的时间和交错。因此，在cashMachine()中插入一个简单的打印语句：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: …and suddenly the balance is always 0, as desired, and the bug appears to disappear.
    But it’s only masked, not truly fixed. A change in timing somewhere else in the
    program may suddenly make the bug come back.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: …突然之间，余额总是0，正如所期望的那样，错误似乎消失了。但这只是掩盖了，而不是真正修复了。程序中其他地方的时间变化可能会突然使错误再次出现。
- en: Concurrency is hard to get right. Part of the point of this reading is to scare
    you a bit. Over the next several readings, we’ll see principled ways to design
    concurrent programs so that they are safer from these kinds of bugs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 并发很难做到正确。阅读的一部分目的是让你有点害怕。在接下来的几篇阅读中，我们将看到设计并发程序的原则性方法，使其更安全，避免这些类型的错误。
- en: reading exercises
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Testing concurrency
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并发性
- en: You’re running a JUnit test suite (for code written by somebody else), and some
    of the tests are failing. You add `System.out.println` statements to the one method
    called by all the failing test cases, in order to display some of its local variables,
    and the test cases suddenly start passing. Which of the following are likely reasons
    for this?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在运行一个Junit测试套件（由其他人编写的代码），一些测试失败了。你在所有失败测试用例中调用的一个方法中添加了`System.out.println`语句，以显示一些局部变量，结果测试用例突然通过了。以下哪些是可能的原因？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Concurrency: multiple computations running simultaneously'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发：多个计算同时运行
- en: Shared-memory & message-passing paradigms
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存和消息传递范式
- en: Processes & threads
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程和线程
- en: Process is like a virtual computer; thread is like a virtual processor
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程就像一个虚拟计算机；线程就像一个虚拟处理器
- en: Race conditions
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争条件
- en: When correctness of result (postconditions and invariants) depends on the relative
    timing of events
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当结果的正确性（后置条件和不变性）取决于事件的相对时间
- en: These ideas connect to our three key properties of good software mostly in bad
    ways. Concurrency is necessary but it causes serious problems for correctness.
    We’ll work on fixing those problems in the next few readings.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法与我们的好软件三个关键属性大多以不好的方式连接。并发是必要的，但它会给正确性带来严重问题。我们将在接下来的几篇阅读中努力解决这些问题。
- en: '**Safe from bugs.** Concurrency bugs are some of the hardest bugs to find and
    fix, and require careful design to avoid.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误困扰。** 并发错误是最难找到和修复的错误之一，需要仔细设计以避免。'
- en: '**Easy to understand.** Predicting how concurrent code might interleave with
    other concurrent code is very hard for programmers to do. It’s best to design
    your code in such a way that programmers don’t have to think about interleaving
    at all.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解。** 预测并发代码如何与其他并发代码交错对程序员来说非常困难。最好设计你的代码，使程序员根本不必考虑交错。'
- en: '**Ready for change.** Not particularly relevant here.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为变化做好准备。** 在这里并不特别相关。'
