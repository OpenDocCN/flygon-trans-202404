- en: Commentary on 'Roman Numerals Kata with Commentary'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"Roman Numerals Kata with Commentary"的评论'
- en: Commentary on 'Roman Numerals Kata with Commentary'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"Roman Numerals Kata with Commentary"的评论'
- en: I recently watched a video called ["Roman Numerals Kata with Commentary"](http://blog.coreyhaines.com/2012/12/roman-numerals-kata-with-commentary.html).
    In it, Corey Haines demonstrates how to implement the [Arabic to Roman Numerals
    Kata](http://codingdojo.org/cgi-bin/wiki.pl?KataRomanNumerals) in Ruby using a
    TDD approach.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近观看了一个名为["Roman Numerals Kata with Commentary"](http://blog.coreyhaines.com/2012/12/roman-numerals-kata-with-commentary.html)的视频。在其中，Corey
    Haines演示了如何使用TDD方法在Ruby中实现[阿拉伯数字到罗马数字 Kata](http://codingdojo.org/cgi-bin/wiki.pl?KataRomanNumerals)。
- en: '*This video annoyed me intensely.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个视频让我感到非常愤怒。*'
- en: I mean no disrespect to Corey Haines' programming skills, and many people seem
    to have found the video useful, but I just found it exasperating.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是对Corey Haines的编程技能表示不敬，许多人似乎发现这个视频很有用，但我只是觉得它令人沮丧。
- en: I thought that in this post I'd try to explain why I got annoyed, and to present
    my alternative approach to problems like this.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这篇文章中尝试解释为什么我感到恼火，并提出我解决这类问题的另一种方法。
- en: Where are the requirements?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求在哪里？
- en: '*"Few programmers write even a rough sketch of what their programs will do
    before they start coding. Most programmers regard anything that doesn''t generate
    code to be a waste of time."*'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"很少有程序员在开始编写代码之前会大致勾勒出他们的程序将要做什么。大多数程序员认为任何不产生代码的事情都是浪费时间。"*'
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Leslie Lamport, ["Why We Should Build Software Like We Build Houses"](http://www.wired.com/opinion/2013/01/code-bugs-programming-why-we-need-specs/)*'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Leslie Lamport，《["为什么我们应该像建房子一样构建软件"](http://www.wired.com/opinion/2013/01/code-bugs-programming-why-we-need-specs/)》
- en: In standard TDD fashion, the video starts with implementing a initial failing
    case (handling zero), then making that work, then adding a test case for handling
    "1", then making that work, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的TDD方式，视频从实现一个初始失败的用例（处理零）开始，然后使其工作，然后添加一个处理"1"的测试用例，然后使其工作，依此类推。
- en: This was the first thing that irritated me -- diving into code without really
    understanding the requirements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是让我感到恼火的第一件事--在真正理解需求之前就着手编码。
- en: A [programming kata](http://en.wikipedia.org/wiki/Kata_(programming\)) is so
    called because the goal is to practice your skills as a developer. But for me,
    coding skills are just one aspect of a being a software developer, and not always
    the most important.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[编程 Kata](http://en.wikipedia.org/wiki/Kata_(programming\))之所以被这样称呼，是因为其目标是作为开发人员练习技能。但对我来说，编码技能只是作为软件开发人员的一个方面，而不总是最重要的。'
- en: If there is anything that needs practicing by most developers, it is listening
    to and understanding the needs of the customer (a.k.a. requirements). We should
    never forget that our goal is to deliver value, not just to write code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大多数开发人员需要练习的一件事情，那就是倾听并理解客户的需求（即所谓的需求）。我们永远不应忘记我们的目标是提供价值，而不仅仅是编写代码。
- en: In this case, even though there is a [wiki page](http://codingdojo.org/cgi-bin/wiki.pl?KataRomanNumerals)
    for the kata, the requirements are still somewhat fuzzy, and so I view this as
    an excellent opportunity to drill down into them, and maybe learn something new.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使有一个[维基页面](http://codingdojo.org/cgi-bin/wiki.pl?KataRomanNumerals)介绍了
    kata，但需求仍然有些模糊，所以我认为这是一个很好的机会来深入研究它们，也许能学到一些新东西。
- en: Becoming a domain expert
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成为领域专家
- en: In fact, I believe that going as deep as possible into the requirements has
    some important benefits.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我相信尽可能深入了解需求具有一些重要的好处。
- en: '**It''s fun**. It''s fun to really understand a new domain. I like to learn
    new things -- it is one of the perks of being a developer.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**这很有趣**。真正理解一个新领域是很有趣的。我喜欢学习新事物--这是作为开发人员的一大好处。'
- en: It's not just me. Dan North tells of how much fun he had working very closely
    with domain experts in his ["accelerating agile"](http://vimeo.com/68215534) presentation.
    Part of that team's success was that the developers studied the domain (trading)
    right along with the traders themselves, so that communication was easy and confusion
    minimized.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是我。Dan North在他的["加速敏捷"](http://vimeo.com/68215534)演讲中讲述了他与领域专家密切合作时有多么愉快的经历。团队成功的一部分是开发人员与交易员一起学习领域（交易），以便沟通轻松，混乱最小化。
- en: '**Good design**. I do believe that in order to produce good software you have
    to become reasonably expert in the domain you are attempting to model. This is
    the thesis behind Domain Driven Design, of course, but also is a key component
    of an Agile process: the "on site customer" who works very closely with the developers
    at all stages.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**好的设计**。我相信，要想设计出好的软件，你必须对你试图建模的领域有相当的专业知识。这当然是领域驱动设计的论点，同时也是敏捷过程的一个关键组成部分：与开发人员在各个阶段密切合作的
    "现场客户"。'
- en: And almost always, understanding the requirements properly will lead you into
    the right* way to implement a solution. No amount of shallow iterations will make
    up for a lack of deep insight.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是，正确理解需求将引导你找到正确的*实现解决方案的方法。再多的浅层迭代也弥补不了对深刻洞察的缺乏。
- en: '[* Of course there is not really a "right" way, but there are plenty of wrong
    ways. So here I just mean not horribly complicated and unmaintainable.]'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[* 当然，没有真正的 "正确" 方法，但错误的方法却有很多。所以这里我只是指不要非常复杂和难以维护的方式。]'
- en: '**Good tests**. You can''t create good tests without understanding the requirements.
    A process like BDD makes this explicit; the requirements are written in such a
    way that they actually *become* the tests.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**好的测试**。你不能在不理解需求的情况下创建好的测试。像 BDD 这样的过程使这一点变得明确；需求被书写成一种方式，以至于它们实际上*变成*了测试。'
- en: Understanding Roman numerals
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解罗马数字
- en: '*"During an inception, when we are most ignorant about most aspects of the
    project, the best use we can possibly make of the time available is to attempt
    to identify and reduce our ignorance across all the axes we can think of."* --
    *Dan North, ["Deliberate Discovery"](http://dannorth.net/2010/08/30/introducing-deliberate-discovery/)*'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"在一个启动期间，当我们对项目的大多数方面都一无所知时，我们能够充分利用可用的时间的最佳方式就是试图识别并减少我们在所有可以想到的轴上的无知。"*
    -- *丹·诺斯，《刻意发现》(http://dannorth.net/2010/08/30/introducing-deliberate-discovery/)*'
- en: So, how does this apply to the Roman Numerals Kata? Should we seriously become
    domain experts before we write a line of code?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这如何应用到罗马数字 kata 呢？我们在写代码之前真的应该认真成为领域专家吗？
- en: I would say yes!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我会说是的！
- en: I know it is a trivial problem, and it seems like overkill, but then again,
    this is a kata, so you should be practising all the steps carefully and mindfully.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这是一个琐碎的问题，看起来有点大材小用，但毕竟这是一个 kata，所以你应该认真和谨慎地练习所有步骤。
- en: So, what can we find out about Roman numerals?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能从罗马数字中找到什么？
- en: First, a little [background reading from a reliable source](http://en.wikipedia.org/wiki/Roman_numerals)
    shows that they probably originated from something similar to [tally marks](http://en.wikipedia.org/wiki/Tally_marks).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一点来自可靠来源的[背景阅读](http://en.wikipedia.org/wiki/Roman_numerals)表明它们可能起源于类似[记数符号](http://en.wikipedia.org/wiki/Tally_marks)的东西。
- en: '![Tally marks](200px-Tally_marks.svg.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![计数符号](200px-Tally_marks.svg.png)'
- en: This explains the simple strokes for "I" to "IIII" and then the different symbol
    for "V".
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了从 "I" 到 "IIII" 的简单笔画，然后是 "V" 的不同符号。
- en: As it evolved, symbols were added for ten and fifty, one hundred and five hundred,
    and so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着发展，十和五十、一百和五百等符号被添加进来。
- en: This system of counting with ones and fives can be seen in the design of the
    [abacus](http://en.wikipedia.org/wiki/Roman_abacus), old and new.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用一和五计数的系统可以在[算盘](http://en.wikipedia.org/wiki/Roman_abacus)的设计中看到，无论是古代还是现代。
- en: '![Roman Abacus](RomanAbacusRecon.jpg) ![Modern abacus](320px-Sharp-abacus-japan.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![罗马算盘](RomanAbacusRecon.jpg) ![现代算盘](320px-Sharp-abacus-japan.jpg)'
- en: In fact, this system even has a name which I'd never heard of -- ["bi-quinary
    coded decimal"](http://en.wikipedia.org/wiki/Bi-quinary_coded_decimal). Isn't
    that fun? I shall now attempt to drop that phrase into casual conversation wherever
    possible. (And by the way, the little stones used as counters are called "calculi",
    whence the name for the bane of high school students everywhere.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种系统甚至有一个我从未听说过的名字——["二进制编码十进制"](http://en.wikipedia.org/wiki/Bi-quinary_coded_decimal)。这不是很有趣吗？我现在将尽可能在随意谈话中加入这个短语。（顺便说一句，用作计数器的小石头被称为
    "calculi"，这也就是高中生们的噩梦之名的来源。）
- en: Much later, in the 13th century, certain abbreviations were added -- substituting
    "IV" for "IIII" and "IX" for "VIIII". This [subtractive notation](http://en.wikipedia.org/wiki/Subtractive_notation)
    means that the order of the symbols becomes important, something that is not required
    for a pure tally-based system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 更晚些时候，在13世纪，一些缩写被添加进来——用 "IV" 替换 "IIII"，用 "IX" 替换 "VIIII"。这种[减法记数法](http://en.wikipedia.org/wiki/Subtractive_notation)意味着符号的顺序变得重要，这在一个纯粹基于记数的系统中是不需要的。
- en: These new requirements show us that nothing has changed in the development biz...
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的需求告诉我们，在开发行业中没有什么改变...
- en: '*Pope: "We need to add subtractive notation ASAP -- the Arabs are beating us
    on features."'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*教皇："我们需要尽快添加减法记法——阿拉伯人在功能上领先我们。"*'
- en: 'You: "But it''s not backwards compatible, sir. It''s a breaking change!"'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你："但是这不是向后兼容的，先生。这是一个破坏性的变化！"
- en: 'Pope: "Tough. I need it by next week."*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 教皇："坚持。下周我需要它。"*
- en: So now that we know all about Roman numerals, do we have enough information
    to create the requirements?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经全面了解了罗马数字，我们有足够的信息来创建需求了吗？
- en: Alas, no. As we investigate further, it becomes clear that there is a lot of
    inconsistency. There is no ISO or ANSI standard for Roman numerals!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，不是。随着我们进一步调查，很明显存在许多不一致之处。罗马数字没有 ISO 或 ANSI 标准！
- en: This is not unusual of course. A fuzziness around requirements affects most
    software projects. Indeed, part of our job as a developer is to help clarify things
    and eliminate ambiguity. So, let's create some requirements based on what we know
    so far.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然这并不罕见。需求的模糊性影响了大多数软件项目。实际上，作为开发者，我们的工作之一就是帮助澄清事情并消除歧义。所以，让我们根据我们目前所知创建一些需求。
- en: The requirements for this kata
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这个习题的需求
- en: '*"Programmers are not to be measured by their ingenuity and their logic but
    by the completeness of their case analysis."* -- *Alan Perlis, [Epigrams](http://www.cs.yale.edu/quotes.html)*'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"程序员的衡量标准不是看他们的机智和逻辑，而是看他们的案例分析的完整性。"* —— *艾伦·佩利斯，[格言](http://www.cs.yale.edu/quotes.html)*'
- en: I think we would all agree that having unambiguous and testable requirements
    is a critical step towards having a successful project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们都会同意，拥有明确且可测试的需求是成功项目的关键步骤。
- en: Now when I talk about "requirements", I'm not talking about a 200 page document
    that takes six months to write. I'm just talking about a few bullet points that
    take 5 or 10 minutes to write down.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我谈到"需求"时，我指的不是一个需要花六个月时间编写的 200 页文档。我只是在谈论几个要点，写下来只需 5 到 10 分钟。
- en: But... it is important to have them. Thinking carefully before coding is an
    essential skill that needs to be practiced, and so I would recommend doing this
    step as part of the discipline for any code kata.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但是……拥有它们是很重要的。在编码之前仔细思考是需要练习的一项基本技能，因此我建议将这一步作为任何代码习题的一部分。
- en: 'So here are the requirements as I see them:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是我看到的需求：
- en: The output will be generated by tallying 1, 5, 10, 50, 100, 500, and 1000, using
    the symbols "I", "V", "X", "L", "C", "D" and "M" respectively.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出将通过统计 1、5、10、50、100、500 和 1000，使用符号 "I"、"V"、"X"、"L"、"C"、"D" 和 "M" 来生成。
- en: 'The symbols must be written in descending order: "M" before "D" before "C"
    before "L", etc.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号必须按降序编写："M" 在 "D" 之前，在 "C" 之前，在 "L" 之前，等等。
- en: Using the tallying logic, it's clear that we can only have up to four repetitions
    of "I", "X", "C" and "M". And only one "V", "L" or "D". Any more than that and
    the multiple tally marks are abbreviated to the next "higher" tally mark.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计数逻辑，很明显我们只能有最多四个 "I"、"X"、"C" 和 "M" 的重复。只能有一个 "V"、"L" 或 "D"。如果超过这个数量，多个计数标记会被缩写为下一个
    "更高" 的计数标记。
- en: 'Finally, we have the six (optional) substitution rules: "IIII"=>"IV", "VIIII"=>"IX",
    "XXXX"=>"XL", "LXXXX"=>"XC", "CCCC"=>"CD", "DCCCC"=>"CM". These are exceptions
    to the descending order rule.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有六个（可选的）替代规则："IIII"=>"IV"，"VIIII"=>"IX"，"XXXX"=>"XL"，"LXXXX"=>"XC"，"CCCC"=>"CD"，"DCCCC"=>"CM"。这些是按降序规则的例外情况。
- en: There's one other very important requirement that isn't on this list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个非常重要的需求没有列在这个列表中。
- en: What is the range of valid inputs?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效输入的范围是多少？
- en: If we don't explicitly document this, we could easily assume that all integers
    are valid, including zero and negative numbers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不明确地记录这一点，我们很容易假设所有整数都是有效的，包括零和负数。
- en: And what about large numbers, in the millions or billions? Are they allowed?
    Probably not.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么对于数百万或数十亿的大数字呢？允许吗？可能不会。
- en: So let's be explicit and say that the valid input ranges from 0 to 4000\. Then
    what should happen if the input is not valid? Return an empty string? Throw an
    exception?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们明确地说，有效的输入范围是从 0 到 4000。那么如果输入无效会发生什么？返回一个空字符串？抛出异常？
- en: 'In a functional programming language like F#, the most common approach is to
    return an `Option` type, or to return a Success/Failure `Choice` type. Let''s
    just use an `Option`, so to finish off the requirements, we have:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 F# 这样的函数式编程语言中，最常见的方法是返回一个`Option`类型，或者返回一个成功/失败的`Choice`类型。让我们只使用`Option`，这样完成需求，我们有：
- en: The Arabic number 0 is mapped to the empty string.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿拉伯数字0映射为空字符串。
- en: If the input is < 0 or > 4000 return `None` otherwise return `Some(roman)`,
    where `roman` is the Arabic number converted to Roman numerals as described above.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入 < 0 或 > 4000，则返回`None`，否则返回`Some(roman)`，其中`roman`是上述阿拉伯数字转换为罗马数字的结果。
- en: So to sum up this step, we have read about Roman numerals, learned a few fun
    things, and come up with some clear requirements for the next stage. The whole
    thing took only 5-10 mins. In my opinion, that was time well spent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结这一步，我们已经了解了罗马数字，学到了一些有趣的东西，并为下一阶段提出了一些明确的需求。整个过程只花了5-10分钟。在我看来，这是值得花时间的。
- en: Writing the tests
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试
- en: '*"Unit tests have been compared with shining a flashlight into a dark room
    in search of a monster. Shine the light into the room and then into all the scary
    corners. It doesn''t mean the room is monster free --- just that the monster isn''t
    standing where you''ve shined your flashlight."*'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"单元测试被比作在黑暗的房间里用手电筒寻找怪物。把光照进房间，然后照亮所有可怕的角落。这并不意��着房间是没有怪物的 --- 只是怪物不站在你照亮手电筒的地方。"*'
- en: Now that we have the requirements, we can start writing the tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了需求，我们可以开始编写测试了。
- en: In the original video, the tests were developed incrementally, starting with
    0, then 1, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始视频中，测试是逐步开发的，从0开始，然后是1，依此类推。
- en: Personally, I think that there are a number of problems with that approach.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我认为这种方法存在许多问题。
- en: First, as we should know, a major goal of TDD is not testing but *design*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如我们应该知道的那样，TDD的一个主要目标不是测试，而是*设计*。
- en: But this micro, incremental approach to design does not seem to me to lead to
    a particularly good end result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种微观、渐进式的设计方法在我看来并不能带来特别好的最终结果。
- en: For example, in the video, there is a big jump in the implementation complexity
    from testing the "I" case to testing the "II" case. But the rationale is a bit
    hard to understand, and to me it smacks a little of sleight-of-hand, of someone
    who already knows the answer, rather than naturally evolving from the previous
    case.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在视频中，从测试“I”案例到测试“II”案例的实现复杂性有很大的跳跃。但其理由有点难以理解，对我来说有点像戏法，像是已经知道答案的人，而不是自然地从前一个案例演变而来。
- en: Unfortunately, I have seen this happen a lot with a strict TDD approach. You
    might be cruising along nicely and then bump into a huge road block which forces
    a huge rethink and refactoring.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我经常看到这种情况发生在严格的TDD方法中。你可能一路顺风顺水，然后遇到一个巨大的障碍，迫使你进行巨大的重新思考和重构。
- en: A strict TDD'er using Uncle Bob's ["Transformation Priority Premise"](http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html)
    approach would say that that is fine and good, and part of the process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个严格的TDD者使用Bob大叔的["转换优先原则"](http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html)方法会说这是好的，是过程的一部分。
- en: Personally, I'd rather start with the trickiest requirements first, and front-load
    the risk rather than leaving it till the end.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我宁愿从最棘手的需求开始，前置风险，而不是留到最后再处理。
- en: Second, I don't like testing individual cases. I'd prefer that my tests cover
    *all* inputs. This is not always feasible, but when you can do it, as in this
    case, I think you should.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我不喜欢测试单个案例。我更希望我的测试覆盖*所有*输入。这并非总是可行，但在这种情况下可以做到，我认为你应该这样做。
- en: Two tests compared
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较两个测试
- en: To demonstrate what I mean, let's compare the test suite developed in the video
    with a more general requirements-based test.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我的意思，让我们将视频中开发的测试套件与更通用的基于需求的测试进行比较。
- en: 'The test suite developed in the video checks only the obvious inputs, plus
    the case 3497 "for good measure". Here''s the Ruby code ported to F#:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 视频中开发的测试套件仅检查明显的输入，再加上案例3497“以防万一”。以下是将Ruby代码移植到F#的代码：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this set of inputs, how confident are we that the code meets the requirements?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这组输入，我们对代码是否符合要求有多大的信心？
- en: In a simple case like this, I might be reasonably confident, but this approach
    to testing worries me because of the use of "magic" test inputs that are undocumented.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样简单的情况下，我可能会相当自信，但这种测试方法让我担忧，因为使用了未记录的“魔术”测试输入。
- en: For example, why was 3497 plucked out of nowhere? Because (a) it is bigger than
    a thousand and (b) it has some 4's and 9's in it. But the reason it was picked
    is not documented in the test code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为什么会突然出现3497？因为（a）它比一千大，（b）它里面有一些4和9。但选择它的原因在测试代码中没有记录。
- en: Furthermore, if we compare this test suite with the requirements, we can see
    that the second and third requirements are not explicitly tested for at all. True,
    the test with 3497 implicitly checks the ordering requirement ("M" before "C"
    before "X"), but that is never made explicit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们将这个测试套件与需求进行比较，我们会发现第二和第三个需求根本没有得到明确测试。确实，具有3497的测试隐含地检查了排序需求（"M"在"C"之前在"X"之前），但这从未被明确表达。
- en: 'Now compare that test with this one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将该测试与这个进行比较：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This test checks the requirement that you can only have four repetitions of
    "I".
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查了只能有四个"I"重复的需求。
- en: Unlike the one in the TDD video, this test case covers *all possible inputs*,
    not just one. If it passes, I will have complete confidence that the code meets
    this particular requirement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与TDD视频中的一个不同，这个测试用例涵盖了*所有可能的输入*，而不仅仅是一个。如果通过了，我将完全相信代码符合这个特定的需求。
- en: Property-based testing
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于属性的测试
- en: If you are not familiar with this approach to testing, it is called *"property-based
    testing"*. You define a "property" that must be true in general, and then you
    generate as many inputs as possible in order to find cases where the property
    is not true.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这种测试方法不熟悉，它被称为*“基于属性的测试”*。你定义一个必须在一般情况下为真的“属性”，然后尽可能多地生成输入，以找到属性不为真的情况。
- en: In this case, we can test all 4000 inputs. In general though, our problems have
    a much larger range of possible inputs, so we generally just test on some representative
    sample of the inputs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以测试所有4000个输入。但一般情况下，我们的问题可能有更大范围的可能输入，所以我们通常只对一些代表性样本进行测试。
- en: Most property-based testing tools are modelled after [Haskell's QuickCheck](http://en.wikipedia.org/wiki/QuickCheck),
    which is a tool that automatically generates "interesting" inputs for you, in
    order to find edge cases as quickly as possible. These inputs would include things
    like nulls, negative numbers, empty lists, strings with non-ascii characters in
    them, and so on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于属性的测试工具都是模仿[Haskell的QuickCheck](http://en.wikipedia.org/wiki/QuickCheck)而设计的，这是一个可以自动生成“有趣”输入的工具，以便尽快找到边界情况。这些输入可能包括空值、负数、空列表、包含非ASCII字符的字符串等。
- en: An equivalent to QuickCheck is available for most languages now, including [FsCheck](https://github.com/fsharp/FsCheck)
    for F#.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数语言都有类似QuickCheck的工具，包括[FsCheck](https://github.com/fsharp/FsCheck)用于F#。
- en: The advantage of property-based testing is that it forces you to think about
    the requirements in general terms, rather than as lots of special cases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试的优势在于它迫使你以一般术语思考需求，而不是作为许多特殊情况。
- en: That is, rather than a test that says `the input "4" maps to "IV"`, we have
    a more general test that says `any input with 4 in the units place has "IV" as
    the last two characters`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，与其有一个测试说`输入"4"映射到"IV"`，我们有一个更一般的测试说`任何个位数为4的输入最后两个字符为"IV"`。
- en: Implementing a property-based test
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现基于属性的测试
- en: To switch to property-based testing for the requirement above, I would refactor
    the code so that (a) I create a function that defines a property and then (b)
    I check that property against a range of inputs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要将上述需求转换为基于属性的测试，我会重构代码，使得（a）我创建一个定义属性的函数，然后（b）检查该属性是否符合一系列输入。
- en: 'Here''s the refactored code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重构后的代码：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Or for example, let's say that I want to test the substitution rule for 40 =>
    "XL".
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者举个例子，假设我想测试40 => "XL"的替换规则。
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I'm not going to go into property-based testing any more here, but I think you
    can see the benefits over hand-crafted cases with magic inputs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里再深入讨论基于属性的测试，但我认为你可以看到与手工制作带有魔术输入的案例相比的好处。
- en: '*The [code for this post](https://gist.github.com/swlaschin/8409306) has a
    full property-based test suite.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*这篇文章的[代码](https://gist.github.com/swlaschin/8409306)有一个完整的基于属性的测试套件。*'
- en: Requirements Driven Design?
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求驱动设计？
- en: At this point, we can start on the implementation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以开始实现。
- en: Unlike the TDD video, I'd rather build the implementation by iterating on the
    *requirements*, not on the *test cases*. I need a catchy phrase for this, so I'll
    call it Requirements Driven Design?. Watch out for a Requirements Driven Design
    Manifesto coming soon.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与TDD视频不同，我更愿意根据*需求*进行迭代构建实现，而不是*测试用例*。我需要一个响亮的短语来描述这一点，所以我将其称为需求驱动设计？敬请期待即将推出的需求驱动设计宣言。
- en: And rather than implementing code that handles individual inputs one by one,
    I prefer my implementations to cover as many input cases as possible -- preferably
    all of them. As each new requirement is added the implementation is modified or
    refined, using the tests to ensure that it still meets the requirements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是实现处理每个单独输入的代码，我更喜欢我的实现尽可能地涵盖尽可能多的输入情况--最好是所有的情况。随着每个新需求的添加，实现都会被修改或完善，使用测试来确保它仍然满足需求。
- en: But isn't this exactly TDD as demonstrated in the video?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但这难道不正是视频中演示的TDD吗？
- en: No, I don't think so. The TDD demonstration was *test-driven*, but not *requirements
    driven*. Mapping 1 to "I" and 2 to "II" are tests, but are not true requirements
    in my view. A good requirement is based on insight into the domain. Just testing
    that 2 maps to "II" does not provide that insight.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我不这么认为。TDD演示是*测试驱动的*，但不是*需求驱动的*。将1映射到"I"，2映射到"II"是测试，但在我看来并不是真正的需求。一个好的需求是基于对领域的洞察力。只是测试2映射到"II"并不能提供那种洞察力。
- en: A very simple implementation
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个非常简单的实现
- en: After criticizing someone else's implementation, time for me to put up or shut
    up.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在批评别人的实现之后，是时候我自己站出来了。
- en: So, what is the simplest implementation I can think of that would work?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我能想到的最简单的实现是什么？
- en: How about just converting our arabic number to tally marks? 1 becomes "I", 2
    becomes "II", and so on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将我们的阿拉伯数字转换成记号，如何？1变成"I"，2变成"II"，以此类推。
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here it is in action:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的运行方式：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code actually meets the first and second requirements already, and for
    all inputs!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上已经满足了第一个和第二个需求，而且对于所有的输入都是如此！
- en: Of course, having 4000 tally marks is not very helpful, which is no doubt why
    the Romans started abbreviating them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，拥有4000个记号并不是很有帮助，这毫无疑问是罗马人开始缩写它们的原因。
- en: This is where insight into the domain comes in. If we understand that the tally
    marks are being abbreviated, we can emulate that in our code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是领域洞察力发挥作用的地方。如果我们理解到记号是被缩写的，我们就可以在我们的代码中模拟出来。
- en: So let's convert all runs of five tally marks into a "V".
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们将所有的五个记号的运行转换成一个"V"。
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But now we can have runs of "V"s. Two "V"s need to be collapsed into an "X".
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们可以有一系列的"V"。两个"V"需要被合并成一个"X"。
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I think you get the idea. We can go on adding abbreviations...
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你明白了。我们可以继续添加缩写...
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And now we're done. We've met the first three requirements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了。我们已经满足了前三个需求。
- en: If we want to add the optional abbreviations for the fours and nines, we can
    do that at the end, after all the tally marks have been accumulated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加四和九的可选缩写，我们可以在累积了所有的记号之后再添加。
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is what I like about this approach:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我喜欢这种方法的原因：
- en: It is derived from understanding the domain model (tally marks) rather than
    jumping right into a recursive design.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是从对领域模型（记号）的理解中派生出来的，而不是直接跳入递归设计。
- en: As a result, the implementation follows the requirements very closely. In fact
    it basically writes itself.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，实现非常紧密地遵循需求。事实上，它基本上是自动写出来的。
- en: By following this step-by-step approach, someone else would have high confidence
    in the code being correct just by examining the code. There is no recursion or
    special tricks that would confuse anyone.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过遵循这种逐步的方法，其他人只需检查代码就能对其正确性有很高的信心。没有递归或特殊技巧会让任何人困惑。
- en: The implementation generates output for all inputs at all times. In the intermediate
    stages, when it doesn't meet all the requirements, it at least generates output
    (e.g. 10 mapped to "VV") that tells us what we need to do next.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现会为所有的输入在任何时候生成输出。在中间阶段，当它不能满足所有的需求时，它至少会生成输出（比如10映射到"VV"），告诉我们下一步需要做什么。
- en: Yes, this might not be the most efficient code, creating strings with 4000 "I"s
    in them! And of course, a more efficient approach would subtract the large tallies
    ("M", then "D", then "C") straight from the input, leading to the recursive solution
    demonstrated in the TDD video.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这可能不是最有效率的代码，创建了包含4000个"I"的字符串！当然，更有效率的方法会直接从输入中减去大的记号("M"，然后是"D"，然后是"C")，导致了TDD视频中演示的递归解决方案。
- en: But on the other hand, this implementation might well be efficient enough. The
    requirements don't say anything about performance constraints -- YAGNI anyone?
    -- so I'm tempted to leave it at this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一方面，这种实现可能是足够高效的。需求没有提到性能约束--YAGNI，对吧？--所以我倾向于就此结束。
- en: A bi-quinary coded decimal implementation
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个二进制编码的十进制实现
- en: I can't resist another implementation, just so that I can use the word "bi-quinary"
    again.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法抵挡另一种实现，只是因为我可以再次使用"双五进制"这个词。
- en: The implementation will again be based on our understanding of the domain, in
    this case, the Roman abacus.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现再次基于我们对领域的理解，本例中是罗马算盘。
- en: In the abacus, each row or wire represents a decimal place, just as our common
    Arabic notation does. But the number in that place can be encoded by two different
    symbols, depending on the number.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在算盘中，每行或每根线代表一个十进位，就像我们常见的阿拉伯符号一样。但该位置上的数字可以用两个不同的符号编码，取决于数字。
- en: 'Some examples:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子：
- en: 1 in the tens place is encoded by "X"
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十位上的1被编码为"X"
- en: 2 in the tens place is encoded by "XX"
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十位上的2被编码为"XX"
- en: 5 in the tens place is encoded by "L"
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十位上的5被编码为"L"
- en: 6 in the tens place is encoded by "LX"
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十位上的6被编码为"LX"
- en: and so on.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: This leads directly to an algorithm based on converting the beads on the abacus
    into a string representation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接导致一种基于将算盘上的珠子转换为字符串表示的算法。
- en: Split the input number into units, tens, hundreds and thousands. These represent
    each row or wire on the abacus.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入数字拆分为单位、十位、百位和千位。这些代表算盘上的每一行或线。
- en: Encode the digit for each place into a string using the "bi-quinary" representation
    and the appropriate symbols for that place.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用"双五进制"表示法和适当的符号将每个位置的数字编码成字符串。
- en: Concat the representations for each place together to make single output string.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个位置的表示连接在一起，形成单个输出字符串。
- en: 'Here''s an implementation that is a direct translation of that algorithm:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个直接翻译该算法的实现：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that the above code does not produce the abbreviations for the four and
    nine cases. We can easily modify it to do this though. We just need to pass in
    the symbol for ten, and tweak the mapping for the 4 and 9 case, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码未生成四和九的缩写。但我们可以轻松修改它来做到这一点。我们只需要传入十的符号，并调整4和9情况的映射，如下所示：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, both these implementations are very straightforward and easy to verify.
    There are no subtle edge cases lurking in the code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这两个实现非常简单直接，易于验证。代码中没有潜在的微妙边界情况。
- en: Review
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习
- en: I started off this post being annoyed at a TDD demonstration. Let me review
    the reasons why I was annoyed, and how my approach differs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始写这篇文章时对TDD演示感到恼火。让我回顾一下我为什么感到恼火以及我的方法与众不同的原因。
- en: '**Requirements**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求**'
- en: The TDD demonstration video did not make any attempt to document the requirements
    at all. I would say that this a dangerous thing to do, especially if you are learning.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: TDD演示视频根本没有尝试记录任何需求。我认为这是一个危险的做法，特别是如果你正在学习。
- en: I would prefer that before you start coding you *always* make an effort to be
    explicit about what you are trying to do.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编码之前，我希望你*始终*努力明确你要做什么。
- en: With only a tiny bit of effort I came up with some explicit requirements that
    I could use for verification later.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 只需稍加努力，我就能提出一些明确的需求，以便以后进行验证。
- en: I also explicitly documented the range of valid inputs -- something that was
    unfortunately lacking in the TDD demonstration.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我还明确记录了有效输入范围--这是TDD演示中不幸缺少的内容。
- en: '**Understanding the domain**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解领域**'
- en: Even if the requirements have been made explicit for you, I think that it is
    always worthwhile spending time to *really* understand the domain you are working
    in.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 即使需求已经为您明确，我认为花时间*真正*了解您所在的领域也是值得的。
- en: In this case, understanding that Roman numerals were a tally-based system helped
    with the design later. (Plus I learned what "bi-quinary" means and got to use
    it in this post!)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，了解罗马数字是一种记账制度有助于后来的设计。（此外，我了解了什么是"双五进制"，并在这篇文章中使用了它！）
- en: '**Unit tests**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: The unit tests in the TDD demonstration were built one single case at a time.
    First zero, then one, and so on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: TDD演示中的单元测试是逐个案例构建的。首先是零，然后是一，依此类推。
- en: As I note above, I feel very uncomfortable with this approach because (a) I
    don't think it leads to a good design and (b) the single cases don't cover all
    possible inputs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我上面所指出的，我对这种方法感到非常不舒服，因为（a）我认为它不会导致良好的设计，（b）单个情况并不涵盖所有可能的输入。
- en: I would strongly recommend that you write tests that map *directly* to the requirements.
    If the requirements are any good, this will mean that the tests cover many inputs
    at once, so you can then test as many inputs as you can.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你编写直接映射到需求的测试。如果需求很好，这意味着测试一次覆盖多个输入，这样你就可以测试尽可能多的输入。
- en: Ideally, you would use a property-based testing tool like QuickCheck. Not only
    does it make this approach much easier to implement, but it forces you to identify
    what the properties of your design should be, which in turn helps you clarify
    any fuzzy requirements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该使用QuickCheck等基于属性的测试工具。这不仅使这种方法更容易实现，而且迫使您确定设计的属性应该是什么，从而帮助您澄清任何模糊的需求。
- en: '**Implementation**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现**'
- en: Finally, I described two implementations, both completely different from the
    recursive one demonstrated in the TDD video.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我描述了两种实现，都与TDD视频中演示的递归实现完全不同。
- en: Both designs were derived directly from an understanding of the domain. The
    first from using tally marks, and the second from using an abacus.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种设计都直接源自对领域的理解。第一种是使用记分符，第二种是使用算盘。
- en: To my mind, both of these designs were also easier to understand -- no recursion!
    -- and thus easier to have confidence in.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这两种设计也更容易理解 -- 没有递归！ -- 因此更容易让人信任。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '*(Added based on comments I made below.)*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*(根据我在下面发表的评论添加。)*'
- en: Let me be clear that I have absolutely no problem with TDD. And I don't have
    a problem with katas either.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我明确一点，我对TDD绝对没有问题。我对卡塔也没有问题。
- en: 'But here''s my concern about these kinds of "dive-in" demos, namely that novices
    and learners might unintentionally learn the following (implicit) lessons:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我对这种“深入”演示的担忧在于，新手和学习者可能会无意中学到以下（隐含的）教训：
- en: It is OK to accept requirements as given without asking questions.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受给定的需求而不提问是可以的。
- en: It is OK to work without a clear idea of the goal.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有清晰目标的情况下工作是可以的。
- en: It is OK to start coding immediately.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即开始编码是可以的。
- en: It is OK to create tests that are extremely specific (e.g. with magic numbers).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建极其具体的测试是可以的（例如使用魔法数字）。
- en: It is OK to consider only the happy path.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只考虑顺利路径是可以的。
- en: It is OK to do micro refactoring without looking at the bigger picture.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在不考虑整体情况的情况下进行微重构是可以的。
- en: 'Personally, I think that if you are *practicing* to be a *professional* developer,
    you should:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我认为如果你正在*练习*成为*专业*开发人员，你应该：
- en: Practice asking for as much information as possible before you start coding.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始编码之前尽可能多地询问信息是可以的。
- en: Practice writing requirements (from unclear input) in such a way that they can
    be tested.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习以一种可以被测试的方式编写需求（从不清晰的输入中）。
- en: Practice thinking (analyzing and designing) rather than immediately coding.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习思考（分析和设计）而不是立即编码。
- en: Practice creating general tests rather than specific ones.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习创建通用测试而不是特定的测试。
- en: Practice thinking about and handling bad inputs, corner cases, and errors.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习思考和处理坏输入、边界情况和错误。
- en: Practice major refactoring (rather than micro refactoring) so as to develop
    an intuition about where the [shearing layers](http://jonjagger.blogspot.co.uk/2009/10/how-buildings-learn-chapter-2-shearing.html)
    should be.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习进行重大重构（而不是微重构），以便培养对[剪切层](http://jonjagger.blogspot.co.uk/2009/10/how-buildings-learn-chapter-2-shearing.html)应该在何处的直觉。
- en: These principles are all completely compatible with TDD (or at least [the "London"
    school of TDD](http://codemanship.co.uk/parlezuml/blog/?postid=987)) and programming
    katas. There is no conflict, and I cannot see why they would be controversial.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则与TDD（或至少[“伦敦”TDD学派](http://codemanship.co.uk/parlezuml/blog/?postid=987)）和编程卡塔完全兼容。没有冲突，我看不出为什么它们会引起争议。
- en: What do you think?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你认为呢？
- en: I'm sure many of you will disagree with this post. I'm up for a (civilized)
    debate. Please leave comments below or on Reddit.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你们中的许多人会对这篇文章持不同意见。我愿意进行（文明的）辩论。请在下方或Reddit留言。
- en: If you'd like to see the complete code for this post, it is available as a [gist
    here](https://gist.github.com/swlaschin/8409306). The gist also includes full
    property-based tests for both implementations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看本文的完整代码，可以在[gist here](https://gist.github.com/swlaschin/8409306)中找到。该gist还包括两种实现的完整基于属性的测试。
