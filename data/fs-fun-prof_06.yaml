- en: Troubleshooting F#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排除 F# 故障
- en: As the saying goes, "if it compiles, it's correct", but it can be extremely
    frustrating just trying to get the code to compile at all! So this page is devoted
    to helping you troubleshoot your F# code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说，“如果能编译通过，就是正确的”，但只是试图让代码编译通过就可以非常令人沮丧！因此，本页致力于帮助您排除 F# 代码的故障。
- en: I will first present some general advice on troubleshooting and some of the
    most common errors that beginners make. After that, I will describe each of the
    common error messages in detail, and give examples of how they can occur and how
    to correct them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将提供一些关于排错的一般建议以及初学者常犯的一些常见错误。之后，我将详细描述每个常见错误消息，并给出它们发生的示例以及如何更正它们的示例。
- en: '[(Jump to the error numbers)](#NumericErrors)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[(跳转至错误编号)](#NumericErrors)'
- en: General guidelines for troubleshooting
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排除故障的一般指南
- en: By far the most important thing you can do is to take the time and effort to
    understand exactly how F# works, especially the core concepts involving functions
    and the type system. So please read and reread the series ["thinking functionally"](thinking-functionally.html)
    and ["understanding F# types"](understanding-fsharp-types.html), play with the
    examples, and get comfortable with the ideas before you try to start doing serious
    coding. If you don't understand how functions and types work, then the compiler
    errors will not make any sense.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你能做的最重要的事情就是花时间和精力来了解 F# 是如何工作的，特别是涉及到函数和类型系统的核心概念。因此，请阅读并反复阅读系列文章["思考函数式"](thinking-functionally.html)和["理解
    F# 类型"](understanding-fsharp-types.html)，玩弄其中的示例，并在尝试进行严肃编码之前对这些概念感到自在。如果你不理解函数和类型是如何工作的，那么编译器报错将毫无意义。
- en: If you are coming from an imperative language such as C#, you may have developed
    some bad habits by relying on the debugger to find and fix incorrect code. In
    F#, you will probably not get that far, because the compiler is so much stricter
    in many ways. And of course, there is no tool to "debug" the compiler and step
    through its processing. The best tool for debugging compiler errors is your brain,
    and F# forces you to use it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从像 C# 这样的命令式语言过来的，你可能已经养成了一些坏习惯，依赖调试器来找出和修复不正确的代码。在 F# 中，你可能根本不会走得那么远，因为编译器在许多方面要严格得多。当然，没有工具可以“调试”编译器并逐步跟踪其处理过程。排错编译器错误的最好工具就是你的大脑，而
    F# 强制你使用它！
- en: Nevertheless, there are a number of extremely common errors that beginners make,
    and I will quickly go through them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，初学者常常会犯一些极为常见的错误，我将快速地讲解一下它们。
- en: Don't use parentheses when calling a function
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在调用函数时不要使用括号
- en: In F#, whitespace is the standard separator for function parameters. You will
    rarely need to use parentheses, and in particular, do not use parentheses when
    calling a function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，空白是函数参数的标准分隔符。你很少需要使用括号，尤其是在调用函数时不要使用括号。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don't mix up tuples with multiple parameters
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要混淆多参数元组
- en: If it has a comma, it is a tuple. And a tuple is one object not two. So you
    will get errors about passing the wrong type of parameter, or too few parameters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有逗号，那么它就是一个元组。而元组是一个对象而不是两个。因此你会收到关于传递了错误类型的参数或者太少参数的错误。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The compiler treats `(1,2)` as a generic tuple, which it attempts to pass to
    "`addTwoParams`". Then it complains that the first parameter of `addTwoParams`
    is an int, and we're trying to pass a tuple.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将`(1,2)`视为一个通用的元组，试图将其传递给“`addTwoParams`”。然后它抱怨`addTwoParams`的第一个参数是一个整数，而我们尝试传递一个元组。
- en: If you attempt to pass *two* arguments to a function expecting *one* tuple,
    you will get another obscure error.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试向期望一个元组的函数传递*两个*参数，你会得到另一个难以理解的错误。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Watch out for too few or too many arguments
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意参数过少或过多
- en: The F# compiler will not complain if you pass too few arguments to a function
    (in fact "partial application" is an important feature), but if you don't understand
    what is going on, you will often get strange "type mismatch" errors later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向函数传递的参数太少，F# 编译器不会抱怨（事实上，“部分应用”是一个重要特性），但如果你不明白发生了什么，你往往会在后来遇到奇怪的“类型不匹配”错误。
- en: Similarly the error for having too many arguments is typically "This value is
    not a function" rather than a more straightforward error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果参数过多的错误通常是“此值不是函数”，而不是更直接的错误。
- en: The "printf" family of functions is very strict in this respect. The argument
    count must be exact.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “printf”系列函数在这方面非常严格。参数数量必须完全匹配。
- en: This is a very important topic ? it is critical that you understand how partial
    application works. See the series ["thinking functionally"](thinking-functionally.html)
    for a more detailed discussion.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的主题，你必须了解偏函数的工作原理。请参阅系列文章["函数式思维"](thinking-functionally.html)以获取更详细的讨论。
- en: Use semicolons for list separators
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用分号作为列表分隔符
- en: In the few places where F# needs an explicit separator character, such as lists
    and records, the semicolon is used. Commas are never used. (Like a broken record,
    I will remind you that commas are for tuples).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 需要显式分隔符字符的少数地方，如列表和记录中，使用分号。逗号从不使用。（像一个损坏的记录，我会提醒你逗号是用于元组的）。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don't use ! for not or != for not-equal
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要使用 ! 代表 not 或 != 代表不等于
- en: 'The exclamation point symbol is not the "NOT" operator. It is the deferencing
    operator for mutable references. If you use it by mistake, you will get the following
    error:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 感叹号符号不是“NOT”运算符。它是可变引用的解引用运算符。如果你误用了它，你将会得到以下错误：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The correct construction is to use the "not" keyword. Think SQL or VB syntax
    rather than C syntax.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的构造是使用“not”关键字。考虑 SQL 或 VB 语法而不是 C 语法。
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And for "not equal", use "<>", again like SQL or VB.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“不等于”，使用“<>”，再次像 SQL 或 VB 一样。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Don't use = for assignment
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要使用 = 进行赋值
- en: If you are using mutable values, the assignment operation is written "`<-`".
    If you use the equals symbol you might not even get an error, just an unexpected
    result.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是可变值，赋值操作写为“`<-`”。如果你使用等号符号，你可能甚至不会得到错误，只会得到一个意外的结果。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Watch out for hidden tab characters
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意隐藏的制表符
- en: The indenting rules are very straightforward, and it is easy to get the hang
    of them. But you are not allowed to use tabs, only spaces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进规则非常简单，很容易掌握。但你不被允许使用制表符，只能使用空格。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Be sure to set your editor to convert tabs to spaces. And watch out if you are
    pasting code in from elsewhere. If you do run into persistent problems with a
    bit of code, try removing the whitespace and re-adding it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将编辑器设置为将制表符转换为空格。如果你从其他地方粘贴代码，请注意。如果你遇到代码的持续问题，请尝试移除空白并重新添加。
- en: Don't mistake simple values for function values
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要将简单值误认为函数值
- en: If you are trying to create a function pointer or delegate, watch out that you
    don't accidentally create a simple value that has already been evaluated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图创建一个函数指针或委托，请注意不要意外地创建一个已经评估过的简单值。
- en: If you want a parameterless function that you can reuse, you will need to explicitly
    pass a unit parameter, or define it as a lambda.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个可以重复使用的无参数函数，你需要显式传递一个 unit 参数，或者将其定义为 lambda。
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See the series ["thinking functionally"](thinking-functionally.html) for more
    discussion of parameterless functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 查看系列文章["函数式思维"](thinking-functionally.html)以获取更多关于无参数函数的讨论。
- en: Tips for troubleshooting "not enough information" errors
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除“信息不足”错误的提示
- en: The F# compiler is currently a one-pass left-to-right compiler, and so type
    information later in the program is unavailable to the compiler if it hasn't been
    parsed yet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: F# 编译器目前是一种从左到右的单通道编译器，因此如果尚未解析，则编译器无法使用程序中较晚的类型信息。
- en: 'A number of errors can be caused by this, such as ["FS0072: Lookup on object
    of indeterminate type"](#FS0072) and ["FS0041: A unique overload for could not
    be determined"](#FS0041). The suggested fixes for each of these specific cases
    are described below, but there are some general principles that can help if the
    compiler is complaining about missing types or not enough information. These guidelines
    are:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '一些错误可能是由此引起的，比如["FS0072: 对不明确类型的对象进行查找"](#FS0072)和["FS0041: 无法确定唯一的重载"](#FS0041)。对于每个具体情况的建议修复方法将在下面描述，但如果编译器抱怨缺少类型或信息不足，一些一般原则可能有所帮助。这些指导原则包括：'
- en: Define things before they are used (this includes making sure the files are
    compiled in the right order)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用前定义事物（这包括确保文件按正确顺序编译）
- en: Put the things that have "known types" earlier than things that have "unknown
    types". In particular, you might be able reorder pipes and similar chained functions
    so that the typed objects come first.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将具有“已知类型”的事物放在具有“未知类型”的事物之前。特别是，你可以重新排序管道和类似的链式函数，使得类型化对象首先出现。
- en: Annotate as needed. One common trick is to add annotations until everything
    works, and then take them away one by one until you have the minimum needed.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要添加注释。一个常见的技巧是添加注释，直到一切都正常工作，然后逐个删除直到你只保留最少的注释。
- en: Do try to avoid annotating if possible. Not only is it not aesthetically pleasing,
    but it makes the code more brittle. It is a lot easier to change types if there
    are no explicit dependencies on them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，请尽量避免添加注释。不仅美观性不佳，而且会使代码更加脆弱。如果没有对它们的显式依赖，更改类型会更容易。
- en: F# compiler errors
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F#编译器错误
- en: A listing of common errors, ordered by error number
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 常见错误列表，按错误编号排序
- en: Here is a list of the major errors that seem to me worth documenting. I have
    not documented any errors that are self explanatory, only those that seem obscure
    to beginners.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我认为值得记录的主要错误列表。我没有记录任何不言自明的错误，只有那些对初学者来说似乎模糊的错误。
- en: I will continue to add to the list in the future, and I welcome any suggestions
    for additions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在未来继续添加到列表中，并欢迎任何关于添加内容的建议。
- en: '[FS0001: The type ''X'' does not match the type ''Y''](#FS0001)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0001: 类型''X''与类型''Y''不匹配](#FS0001)'
- en: '[FS0003: This value is not a function and cannot be applied](#FS0003)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0003: 此值不是函数，无法应用](#FS0003)'
- en: '[FS0008: This runtime coercion or type test involves an indeterminate type](#FS0008)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0008: 此运行时强制转换或类型测试涉及不确定类型](#FS0008)'
- en: '[FS0010: Unexpected identifier in binding](#FS0010a)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0010: 绑定中出现意外标识符](#FS0010a)'
- en: '[FS0010: Incomplete structured construct](#FS0010b)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0010: 不完整的结构构造](#FS0010b)'
- en: '[FS0013: The static coercion from type X to Y involves an indeterminate type](#FS0013)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0013: 从类型X到Y的静态强制转换涉及不确定类型](#FS0013)'
- en: '[FS0020: This expression should have type ''unit''](#FS0020)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0020: 此表达式应为''unit''类型](#FS0020)'
- en: '[FS0030: Value restriction](#FS0030)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0030: 值约束](#FS0030)'
- en: '[FS0035: This construct is deprecated](#FS0035)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0035: 此构造已被弃用](#FS0035)'
- en: '[FS0039: The field, constructor or member X is not defined](#FS0039)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0039: 字段、构造函数或成员X未定义](#FS0039)'
- en: '[FS0041: A unique overload for could not be determined](#FS0041)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0041: 无法确定的唯一重载](#FS0041)'
- en: '[FS0049: Uppercase variable identifiers should not generally be used in patterns](#FS0049)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0049: 一般情况下不应在模式中使用大写变量标识符](#FS0049)'
- en: '[FS0072: Lookup on object of indeterminate type](#FS0072)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0072: 对不确定类型的对象进行查找](#FS0072)'
- en: '[FS0588: Block following this ''let'' is unfinished](#FS0588)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FS0588: ''let''后面的块未完成](#FS0588)'
- en: 'FS0001: The type ''X'' does not match the type ''Y'''
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'FS0001: 类型''X''与类型''Y''不匹配'
- en: This is probably the most common error you will run into. It can manifest itself
    in a wide variety of contexts, so I have grouped the most common problems together
    with examples and fixes. Do pay attention to the error message, as it is normally
    quite explicit about what the problem is.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你遇到的最常见的错误。它可以在各种情况下表现出来，所以我将最常见的问题与示例和修复方法分组在一起。请注意错误消息，因为它通常对问题是非常明确的。
- en: '| Error message | Possible causes |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 错误消息 | 可能的原因 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The type ''float'' does not match the type ''int'' | [A. Can''t mix floats
    and ints](#FS0001A) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 类型''float''与类型''int''不匹配 | [A. 不能混合使用浮点数和整数](#FS0001A) |'
- en: '| The type ''int'' does not support any operators named ''DivideByInt'' | [A.
    Can''t mix floats and ints.](#FS0001A) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 类型''int''不支持任何名为''DivideByInt''的运算符 | [A. 不能混合使用浮点数和整数。](#FS0001A) |'
- en: '| The type ''X'' is not compatible with any of the types | [B. Using the wrong
    numeric type.](#FS0001B) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 类型''X''与任何类型不兼容 | [B. 使用了错误的数值类型。](#FS0001B) |'
- en: '| This type (function type) does not match the type (simple type). Note: function
    types have a arrow in them, like `''a -> ''b`. | [C. Passing too many arguments
    to a function.](#FS0001C) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 此类型（函数类型）与类型（简单类型）不匹配。注意：函数类型中有箭头，如`''a -> ''b`。 | [C. 向函数传递了太多参数。](#FS0001C)
    |'
- en: '| This expression was expected to have (function type) but here has (simple
    type) | [C. Passing too many arguments to a function.](#FS0001C) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 此表达式预期为（函数类型），但这里有（简单类型） | [C. 向函数传递了太多参数。](#FS0001C) |'
- en: '| This expression was expected to have (N part function) but here has (N-1
    part function) | [C. Passing too many arguments to a function.](#FS0001C) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 此表达式预期为（N部分函数），但这里有（N-1部分函数） | [C. 向函数传递了太多参数。](#FS0001C) |'
- en: '| This expression was expected to have (simple type) but here has (function
    type) | [D. Passing too few arguments to a function.](#FS0001D) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 此表达式预期为（简单类型），但这里有（函数类型） | [D. 向函数传递了太少参数。](#FS0001D) |'
- en: '| This expression was expected to have (type) but here has (other type) | [E.
    Straightforward type mismatch.](#FS0001E) [F. Inconsistent returns in branches
    or matches.](#FS0001F)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '| 此表达式预期为（类型），但这里有（其他类型） | [E. 直接的类型不匹配。](#FS0001E) [F. 分支或匹配中的返回不一致。](#FS0001F)'
- en: '[G. Watch out for type inference effects buried in a function.](#FS0001G)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[G. 当心隐藏在函数中的类型推断效应。](#FS0001G)'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Type mismatch. Expecting a (simple type) but given a (tuple type). Note:
    tuple types have a star in them, like `''a * ''b`. | [H. Have you used a comma
    instead of space or semicolon?](#FS0001H) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 类型不匹配。期望一个（简单类型），但给出了一个（元组类型）。注意：元组类型中包含星号，如`''a * ''b`。 | [H. 你是不是用逗号代替了空格或分号？](#FS0001H)
    |'
- en: '| Type mismatch. Expecting a (tuple type) but given a (different tuple type).
    | [I. Tuples must be the same type to be compared.](#FS0001I) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 类型不匹配。期望一个（元组类型），但给出了一个（不同的元组类型）。 | [I. 元组必须是相同类型才能进行比较。](#FS0001I) |'
- en: '| This expression was expected to have type ''a ref but here has type X | [J.
    Don''t use ! as the "not" operator.](#FS0001J) |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 预期此表达式类型为''a ref，但此处实际类型为X | [J. 不要将!用作“非”运算符。](#FS0001J) |'
- en: '| The type (type) does not match the type (other type) | [K. Operator precedence
    (especially functions and pipes).](#FS0001K) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 类型（type）与类型（other type）不匹配 | [K. 操作符优先级（特别是函数和管道）。](#FS0001K) |'
- en: '| This expression was expected to have type (monadic type) but here has type
    ''b * ''c | [L. let! error in computation expressions.](#FS0001L) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 预期此表达式类型为（monadic type），但此处实际类型为''b * ''c | [L. 在计算表达式中出现let!错误。](#FS0001L)
    |'
- en: A. Can't mix ints and floats
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A. 不能混合整数和浮点数
- en: 'Unlike C# and most imperative languages, ints and floats cannot be mixed in
    expressions. You will get a type error if you attempt this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#和大多数命令式语言不同，整数和浮点数不能在表达式中混合使用。如果你尝试这样做，你会得到一个类型错误：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The fix is to cast the int into a `float` first:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是先将整数转换为`float`：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This issue can also manifest itself in library functions and other places. For
    example, you cannot do "`average`" on a list of ints.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题也会在库函数和其他地方显现出来。例如，你不能对一个整数列表执行“`average`”。
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You must cast each int to a float first, as shown below:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须首先将每个整数转换为浮点数，如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: B. Using the wrong numeric type
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B. 使用错误的数字类型
- en: You will get a "not compatible" error when a numeric cast failed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当数值转换失败时，你会得到一个“不兼容”错误。
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: One possible fix is to cast it if appropriate.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的修复方法是在适当的时候进行转换。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: C. Passing too many arguments to a function
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C. 向函数传递的参数过多
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The clue is in the error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 线索就在错误中。
- en: The fix is to remove one of the arguments!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是删除其中一个参数！
- en: Similar errors are caused by passing too many arguments to `printf`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的错误是由于向`printf`传递了太多的参数。
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: D. Passing too few arguments to a function
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D. 向函数传递的参数过少
- en: If you do not pass enough arguments to a function, you will get a partial application.
    When you later use it, you get an error because it is not a simple type.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向函数传递的参数不足，将会得到一个部分应用。当你之后使用它时，会因为它不是一个简单类型而导致错误。
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is particularly common for some .NET library functions that expect a unit
    parameter, such as `ReadLine` above.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些.NET库函数，特别常见的错误是它们期望一个unit参数，比如上面的`ReadLine`。
- en: The fix is to pass the correct number of parameters. Check the type of the result
    value to make sure that it is indeed a simple type. In the `ReadLine` case, the
    fix is to pass a `()` argument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是传递正确数量的参数。检查结果值的类型，确保它确实是一个简单类型。在`ReadLine`的情况下，修复方法是传递一个`()`参数。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: E. Straightforward type mismatch
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E. 类型不匹配
- en: The simplest case is that you have the wrong type, or you are using the wrong
    type in a print format string.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是你使用了错误的类型，或者在打印格式字符串中使用了错误的类型。
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: F. Inconsistent return types in branches or matches
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F. 分支或匹配中返回类型不一致
- en: A common mistake is that if you have a branch or match expression, then every
    branch MUST return the same type. If not, you will get a type error.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是，如果你有一个分支或匹配表达式，那么每个分支必须返回相同的类型。如果不是，则会得到类型错误。
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Obviously, the straightforward fix is to make each branch return the same type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最直接的修复方法是使每个分支返回相同的类型。
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember that if an "else" branch is missing, it is assumed to return unit,
    so the "true" branch must also return unit.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果“else”分支丢失，就假设它返回unit，因此“true”分支也必须返回unit。
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If both branches cannot return the same type, you may need to create a new union
    type that can contain both types.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个分支无法返回相同的类型，你可能需要创建一个新的联合类型，可以包含两种类型。
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: G. Watch out for type inference effects buried in a function
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: G. 当心隐藏在函数中的类型推断效应
- en: A function may cause an unexpected type inference that ripples around your code.
    For example, in the following, the innocent print format string accidentally causes
    `doSomething` to expect a string.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能会导致意外的类型推断在你的代码中波及。例如，在以下代码中，无辜的打印格式字符串意外地导致`doSomething`期望一个字符串。
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The fix is to check the function signatures and drill down until you find the
    guilty party. Also, use the most generic types possible, and avoid type annotations
    if possible.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是检查函数签名并一直深入到找到有问题的代码为止。此外，尽可能使用最通用的类型，并尽量避免类型注解。
- en: H. Have you used a comma instead of space or semicolon?
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: H. 您是否使用逗号而不是空格或分号？
- en: 'If you are new to F#, you might accidentally use a comma instead of spaces
    to separate function arguments:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是F#的新手，可能会不小心使用逗号而不是空格来分隔函数参数：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The fix is: don''t use a comma!'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是：不要使用逗号！
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One area where commas *are* used is when calling .NET library functions. These
    all take tuples as arguments, so the comma form is correct. In fact, these calls
    look just the same as they would from C#:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用.NET库函数时，逗号是被使用的一个领域。所有这些都将元组作为参数，因此逗号形式是正确的。实际上，这些调用看起来与从C#进行的调用完全相同：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I. Tuples must be the same type to be compared or pattern matched
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I. 元组必须是相同类型才能进行比较或模式匹配
- en: 'Tuples with different types cannot be compared. Trying to compare a tuple of
    type `int * int`, with a tuple of type `int * string` results in an error:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不同类型的元组无法进行比较。尝试将类型为`int * int`的元组与类型为`int * string`的元组进行比较会导致错误：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And the length must be the same:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 并且长度必须相同：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can get the same issue when pattern matching tuples during binding:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定期间模式匹配元组时，可能会出现相同的问题：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: J. Don't use ! as the "not" operator
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: J. 不要使用!作为“非”运算符
- en: If you use `!` as a "not" operator, you will get a type error mentioning the
    word "ref".
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`！`作为“非”运算符，您将收到一个包含“ref”一词的类型错误。
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The fix is to use the "not" keyword instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是使用“not”关键字。
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: K. Operator precedence (especially functions and pipes)
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: K. 运算符优先级（特别是函数和管道）
- en: 'If you mix up operator precedence, you may get type errors. Generally, function
    application is highest precedence compared to other operators, so you get an error
    in the case below:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果混淆了运算符优先级，可能会出现类型错误。通常，与其他运算符相比，函数应用优先级最高，因此在下面的情况下会出现错误：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The fix is to use parentheses.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是使用括号。
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Conversely, the pipe operator is low precedence compared to other operators.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，管道运算符与其他运算符相比优先级较低。
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Again, the fix is to use parentheses.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，修复方法是使用括号。
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: L. let! error in computation expressions (monads)
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: L. 在计算表达式（单子）中出现let!错误
- en: 'Here is a simple computation expression:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的计算表达式：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: However, if you try to use it, you get an error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您尝试使用它，将会收到错误。
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The reason is that "`Bind`" expects a tuple `(wrapper,func)`, not two parameters.
    (Check the signature for bind in the F# documentation).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是“`Bind`”期望元组`（wrapper，func）`，而不是两个参数。（检查F#文档中bind的签名）。
- en: The fix is to change the bind function to accept a tuple as its (single) parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是将绑定函数更改为接受元组作为其（唯一）参数。
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'FS0003: This value is not a function and cannot be applied'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0003：此值不是函数，无法应用
- en: This error typically occurs when passing too many arguments to a function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当向函数传递过多参数时，通常会发生此错误。
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It can also occur when you do operator overloading, but the operators cannot
    be used as prefix or infix.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进行运算符重载但运算符不能用作前缀或中缀时，也可能会发生这种情况。
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'FS0008: This runtime coercion or type test involves an indeterminate type'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0008：此运行时强制转换或类型测试涉及不确定类型
- en: You will often see this when attempting to use "`:?`" operator to match on a
    type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用“`:?`”运算符对类型进行匹配时，您经常会看到这种情况。
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The message tells you the problem: "runtime type tests are not allowed on some
    types".'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 消息告诉您问题：“某些类型不允许在运行时进行类型测试”。
- en: 'The answer is to "box" the value which forces it into a reference type, and
    then you can type check it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是将值“盒装”，强制其成为引用类型，然后您可以对其进行类型检查：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'FS0010: Unexpected identifier in binding'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0010：绑定中意外的标识符
- en: Typically caused by breaking the "offside" rule for aligning expressions in
    a block.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常是由于违反块中表达式对齐的“远离”规则而引起的。
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The fix is to align the code correctly!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是正确对齐代码！
- en: 'See also [FS0588: Block following this ''let'' is unfinished](#FS0588) for
    another issue caused by alignment.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见[FS0588：跟随此“let”的块未完成](#FS0588)以了解另一个由对齐引起的问题。
- en: 'FS0010: Incomplete structured construct'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0010：结构不完整的结构体
- en: 'Often occurs if you are missing parentheses from a class constructor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从类构造函数中省略了括号，则经常会发生这种情况：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Can also occur if you forgot to put parentheses around an operator:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记将运算符括在括号中，也会发生这种情况：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Can also occur if you are missing one side of an infix operator:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您缺少中缀运算符的一侧，也会发生这种情况：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Can also occur if you attempt to send a namespace definition to F# interactive.
    The interactive console does not allow namespaces.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试将命名空间定义发送到 F# 交互式，则也可能会发生。交互式控制台不允许命名空间。
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'FS0013: The static coercion from type X to Y involves an indeterminate type'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0013：从类型 X 到 Y 的静态强制转换涉及不定类型
- en: This is generally caused by implic
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是由 implic 导致的
- en: 'FS0020: This expression should have type ''unit'''
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0020：此表达式应具有类型'unit'
- en: 'This error is commonly found in two situations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误通常出现在两种情况下：
- en: Expressions that are not the last expression in the block
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是块中的最后一个表达式
- en: Using wrong assignment operator
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误的赋值运算符
- en: FS0020 with expressions that are not the last expression in the block
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FS0020，表达式不是块中的最后一个表达式
- en: Only the last expression in a block can return a value. All others must return
    unit. So this typically occurs when you have a function in a place that is not
    the last function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 块中只有最后一个表达式可以返回一个值。所有其他表达式必须返回单位。因此，当您在不是最后一个函数的位置有一个函数时，通常会发生这种情况。
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The easy fix is use `ignore`. But ask yourself why you are using a function
    and then throwing away the answer ? it might be a bug.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方法是使用`ignore`。但问问自己为什么要使用一个函数然后丢弃答案？可能是一个 bug。
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This also occurs if you think you writing C# and you accidentally use semicolons
    to separate expressions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以为自己在写 C#，然后不小心使用分号分隔表达式，这种情况也会发生：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: FS0020 with assignment
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FS0020 与赋值
- en: Another variant of this error occurs when assigning to a property.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当分配给属性时，另一种变体的此错误会发生。
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With this error, chances are you have confused the assignment operator "`<-`"
    for mutable values, with the equality comparison operator "`=`".
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现这个错误，你很有可能把用于可变值的赋值运算符“`<-`”与相等比较运算符“`=`”混淆了。
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The fix is to use the proper assignment operator.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是使用正确的赋值运算符。
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'FS0030: Value restriction'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0030：值限制
- en: This is related to F#'s automatic generalization to generic types whenever possible.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 F# 的自动泛化到通用类型有关，只要可能的话。
- en: 'For example, given :'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: F#'s type inference will cleverly figure out the generic types.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的类型推断将巧妙地找出通用类型。
- en: '[PRE58]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'However in some cases, the F# compiler feels that the code is ambiguous, and,
    even though it looks like it is guessing the type correctly, it needs you to be
    more specific:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，F# 编译器感觉到代码是模糊的，即使看起来它猜对了类型，它也需要你更具体：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Almost always this will be caused by trying to define a partially applied function,
    and almost always, the easiest fix is to explicitly add the missing parameter:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是因为尝试定义部分应用的函数而导致这种情况，并且几乎总是最简单的解决方法是显式添加缺失的参数：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For more details see the MSDN article on ["automatic generalization"](http://msdn.microsoft.com/en-us/library/dd233183%28v=VS.100%29.aspx).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情请参阅关于["自动泛化"](http://msdn.microsoft.com/en-us/library/dd233183%28v=VS.100%29.aspx)的
    MSDN 文章。
- en: 'FS0035: This construct is deprecated'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0035：此构造已弃用
- en: F# syntax has been cleaned up over the last few years, so if you are using examples
    from an older F# book or webpage, you may run into this. See the MSDN documentation
    for the correct syntax.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，F# 语法已经得到了清理，所以如果你使用的是旧版 F# 书籍或网页上的例子，你可能会遇到这个问题。查看 MSDN 文档以获取正确的语法。
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'FS0039: The field, constructor or member X is not defined'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0039：字段、构造函数或成员 X 未定义
- en: 'This error is commonly found in four situations:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误通常在四种情况下发生：
- en: The obvious case where something really isn't defined! And make sure that you
    don't have a typo or case mismatch either.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然的情况是某些东西确实没有定义！并确保你没有拼写错误或大小写不匹配。
- en: Interfaces
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Recursion
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Extension methods
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法
- en: FS0039 with interfaces
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FS0039，接口
- en: In F# all interfaces are "explicit" implementations rather than "implicit".
    (Read the C# documentation on ["explicit interface implementation"](http://msdn.microsoft.com/en-us/library/aa288461%28v=vs.71%29.aspx)
    for an explanation of the difference).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，所有接口都是“显式”实现而不是“隐式”的。（阅读关于["显式接口实现"](http://msdn.microsoft.com/en-us/library/aa288461%28v=vs.71%29.aspx)的
    C# 文档以了解区别的解释）。
- en: The key point is that when a interface member is explicitly implemented, it
    cannot be accessed through a normal class instance, but only through an instance
    of the interface, so you have to cast to the interface type by using the `:>`
    operator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是当接口成员被显式实现时，它不能通过普通类实例访问，而只能通过接口实例访问，所以你必须使用`:> `运算符进行类型转换。
- en: 'Here''s an example of a class that implements an interface:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个实现接口的类的示例：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This doesn''t work:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这不起作用：
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The fix is to cast the object to the interface, as below:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是将对象转换为接口，如下所示：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: FS0039 with recursion
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有递归的FS0039
- en: 'Here''s a standard Fibonacci implementation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的斐波那契实现：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Unfortunately, this will not compile:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这将无法编译：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The reason is that when the compiler sees 'fib' in the body, it doesn't know
    about the function because it hasn't finished compiling it yet!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是当编译器在主体中看到'fib'时，它不知道该函数，因为它尚未完成编译！
- en: The fix is to use the "`rec`" keyword.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是使用“`rec`”关键字。
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that this only applies to "`let`" functions. Member functions do not need
    this, because the scope rules are slightly different.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这仅适用于“`let`”函数。成员函数不需要这样做，因为作用域规则略有不同。
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: FS0039 with extension methods
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有扩展方法的FS0039
- en: If you have defined an extension method, you won't be able to use it unless
    the module is in scope.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义了扩展方法，除非模块在范围内，否则无法使用它。
- en: 'Here''s a simple extension to demonstrate:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的扩展示例：
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you try to use it the extension, you get the FS0039 error:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试使用扩展，将会出现FS0039错误：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The fix is just to open the `IntExtensions` module.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法只是打开`IntExtensions`模块。
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'FS0041: A unique overload for could not be determined'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0041：无法确定唯一的重载
- en: 'This can be caused when calling a .NET library function that has multiple overloads:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用具有多个重载的.NET库函数时可能会导致这种情况：
- en: '[PRE72]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'There a number of ways to fix this. One way is to use an explicit type annotation:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。一种方法是使用显式类型注释：
- en: '[PRE73]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can sometimes use a named parameter to avoid the type annotation:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可以使用命名参数来避免类型注释：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Or you can try to create intermediate objects that help the type inference,
    again without needing type annotations:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以尝试创建帮助类型推断的中间对象，而无需使用类型注释：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'FS0049: Uppercase variable identifiers should not generally be used in patterns'
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0049：模式中通常不应使用大写变量标识符
- en: When pattern matching, be aware of a subtle difference between the pure F# union
    types which consist of a tag only, and a .NET Enum type.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式匹配时，请注意纯F#联合类型和仅由标签组成的.NET枚举类型之间的微妙差异。
- en: 'Pure F# union type:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 纯F#联合类型：
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'But with .NET enums you must fully qualify them:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于.NET枚举，您必须完全限定它们：
- en: '[PRE77]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The fixed version:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 修复版本：
- en: '[PRE78]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'FS0072: Lookup on object of indeterminate type'
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0072：在不确定类型的对象上查找
- en: This occurs when "dotting into" an object whose type is unknown.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当“点”进入一个未知类型的对象时会发生这种情况。
- en: 'Consider the following example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE79]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The compiler does not know what type "x" is, and therefore does not know if
    "`Length`" is a valid method.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不知道“x”的类型，因此不知道“`Length`”是否是有效的方法。
- en: 'There a number of ways to fix this. The crudest way is to provide an explicit
    type annotation:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。最简单的方法是提供显式类型注释：
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In some cases though, judicious rearrangement of the code can help. For example,
    the example below looks like it should work. It's obvious to a human that the
    `List.map` function is being applied to a list of strings, so why does `x.Length`
    cause an error?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，对代码进行谨慎的重新排列可能有所帮助。例如，下面的示例看起来应该可以工作。对于人类来说，`List.map`函数应用于字符串列表是显而易见的，那么为什么`x.Length`会导致错误呢？
- en: '[PRE81]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The reason is that the F# compiler is currently a one-pass compiler, and so
    type information present later in the program cannot be used if it hasn't been
    parsed yet.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是F#编译器目前是一种单通道编译器，因此如果尚未解析，则无法使用程序后面存在的类型信息。
- en: 'Yes, you can always explicitly annotate:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，您总是可以明确注释：
- en: '[PRE82]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: But another, more elegant way that will often fix the problem is to rearrange
    things so the known types come first, and the compiler can digest them before
    it moves to the next clause.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一种更优雅的方法通常可以解决问题，即重新排列已知类型优先，编译器可以在移动到下一个子句之前消化它们。
- en: '[PRE83]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It's good practice to avoid explicit type annotations, so this approach is best,
    if it is feasible.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免显式类型注释，因此如果可行，这种方法是最好的。
- en: 'FS0588: Block following this ''let'' is unfinished'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FS0588：此“let”后面的块未完成
- en: Caused by outdenting an expression in a block, and thus breaking the "offside
    rule".
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在块中取消缩进表达式，从而违反“离边规则”而引起的。
- en: '[PRE84]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The fix is to align the code correctly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 修复的方法是正确对齐代码。
- en: 'See also [FS0010: Unexpected identifier in binding](#FS0010a) for another issue
    caused by alignment.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[FS0010：绑定中的意外标识符](#FS0010a)以了解由对齐引起的另一个问题。
