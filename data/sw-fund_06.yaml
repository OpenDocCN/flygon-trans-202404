- en: TacticsMore Basic Tactics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略更基本的策略
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Export Poly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要导出 Poly。
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Theorem silly1 : ∀(n m o p : nat),'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 silly1：∀(n m o p : nat)，'
- en: n = m  →
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: n = m →
- en: '[n;o] = [n;p] →'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[n;o] = [n;p] →'
- en: '[n;o] = [m;p].'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[n;o] = [m;p]。'
- en: Proof.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n m o p eq[1] eq[2].
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: intros n m o p eq[1] eq[2]。
- en: rewrite ← eq[1].
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← eq[1]。
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: apply eq[2]. Qed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 eq[2]。Qed。
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Theorem silly2 : ∀(n m o p : nat),'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 silly2：∀(n m o p : nat)，'
- en: n = m  →
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: n = m →
- en: '(∀(q r : nat), q = r → [q;o] = [r;p]) →'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '(∀(q r : nat), q = r → [q;o] = [r;p]) →'
- en: '[n;o] = [m;p].'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[n;o] = [m;p]。'
- en: Proof.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n m o p eq[1] eq[2].
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: intros n m o p eq[1] eq[2]。
- en: apply eq[2]. apply eq[1]. Qed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 eq[2]。应用 eq[1]。Qed。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Theorem silly2a : ∀(n m : nat),'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 silly2a：∀(n m : nat)，'
- en: (n,n) = (m,m)  →
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (n,n) = (m,m) →
- en: '(∀(q r : nat), (q,q) = (r,r) → [q] = [r]) →'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '(∀(q r : nat), (q,q) = (r,r) → [q] = [r]) →'
- en: '[n] = [m].'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[n] = [m]。'
- en: Proof.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n m eq[1] eq[2].
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: intros n m eq[1] eq[2]。
- en: apply eq[2]. apply eq[1]. Qed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 eq[2]。应用 eq[1]。Qed。
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Theorem silly_ex :'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 silly_ex：
- en: (∀n, evenb n = true → oddb (S n) = true) →
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n, evenb n = true → oddb (S n) = true) →
- en: evenb 3 = true →
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: evenb 3 = true →
- en: oddb 4 = true.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: oddb 4 = true。
- en: Proof.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处 *) 已承认。
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Theorem silly3_firsttry : ∀(n : nat),'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 silly3_firsttry：∀(n : nat)，'
- en: true = beq_nat n 5  →
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: true = beq_nat n 5 →
- en: beq_nat (S (S n)) 7 = true.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: beq_nat (S (S n)) 7 = true。
- en: Proof.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n H.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: intros n H。
- en: simpl.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: symmetry.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对称性。
- en: simpl. (* (This simpl is optional, since apply will perform             simplification first, if needed.) *)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。(* （这个简化是可选的，因为如果需要，apply 将执行             简化。*)
- en: apply H. Qed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 H。Qed。
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Theorem rev_exercise1 : ∀(l l'' : list nat),'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rev_exercise1：∀(l l'' : list nat)，'
- en: l = rev l' →
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: l = rev l' →
- en: l' = rev l.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: l' = rev l。
- en: Proof.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处 *) 已承认。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The apply ... with ... Tactic
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用... with... 策略
- en: The following silly example uses two rewrites in a row to
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下愚蠢的例子使用两次重写来
- en: get from [a,b] to [e,f].
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 [a,b] 到 [e,f]。
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since this is a common pattern, we might like to pull it out
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这是一个常见模式，我们可能想将其提取出来
- en: as a lemma recording, once and for all, the fact that equality is
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一个引理记录，一劳永逸地记录相等性是
- en: transitive.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传递性。
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we should be able to use trans_eq to prove the above
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们应该能够使用 trans_eq 来证明上述
- en: example.  However, to do this we need a slight refinement of the
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例子。然而，为了做到这一点，我们需要对
- en: apply tactic.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用策略。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we simply tell Coq apply trans_eq at this point, it can
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们简单地告诉 Coq 在这一点上应用 trans_eq，它可以
- en: tell (by matching the goal against the conclusion of the lemma)
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉（通过将目标与引理的结论进行匹配）
- en: that it should instantiate X with [nat], n with [a,b], and
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该实例化 X 为 [nat]，n 为 [a,b]，和
- en: o with [e,f].  However, the matching process doesn't determine
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: o with [e,f]。然而，匹配过程并不确定
- en: 'an instantiation for m: we have to supply one explicitly by'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: m 的实例化：我们必须明确提供一个
- en: adding with (m:=[c,d]) to the invocation of apply.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加 with (m:=[c,d]) 到 apply 的调用。
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Actually, we usually don't have to include the name m in
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，我们通常不必在
- en: the with clause; Coq is often smart enough to figure out which
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: with 子句；Coq 通常足够聪明，可以弄清楚哪个
- en: 'instantiation we''re giving. We could instead write: apply trans_eq with [c;d].'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们给出的实例化。我们可以改为：应用 trans_eq with [c;d]。
- en: 'Exercise: 3 stars, optional (apply_with_exercise)'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3 星，可选（apply_with_exercise）
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ☐
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inductive nat : Type :=
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 nat：Type :=
- en: '| O : nat'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '| O : nat'
- en: '| S : nat → nat.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '| S : nat → nat。'
- en: It is obvious from this definition that every number has one of
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个定义很明显，每个数字都有一个
- en: 'two forms: either it is the constructor O or it is built by'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两种形式：要么是构造子 O，要么是通过
- en: applying the constructor S to another number.  But there is more
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将构造子 S 应用于另一个数字。但还有更多
- en: 'here than meets the eye: implicit in the definition (and in our'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里比眼睛看到的更多：在定义中（以及在我们的
- en: informal understanding of how datatype declarations work in other
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对其他数据类型声明的工作原理有一个非正式的理解
- en: 'programming languages) are two more facts:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编程语言）还有两个事实：
- en: The constructor S is *injective*. That is, if S n = S m, it must be the case
    that n = m.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造子 S 是*单射*的。也就是说，如果 S n = S m，则必须是 n = m。
- en: The constructors O and S are *disjoint*. That is, O is not equal to S n for
    any n.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造子 O 和 S 是*不相交*的。也就是说，对于任何 n，O 都不等于 S n。
- en: 'Similar principles apply to all inductively defined types: all'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似的原则适用于所有归纳定义的类型：所有
- en: constructors are injective, and the values built from distinct
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造子是单射的，并且从不同的值构建的值
- en: constructors are never equal.  For lists, the cons constructor
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造子从不相等。对于列表，cons 构造子
- en: is injective and nil is different from every non-empty list.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是单射的，nil 与每个非空列表都不同。
- en: For booleans, true and false are different.  (Since neither
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于布尔值，true 和 false 是不同的。（因为 true 和 false 都不
- en: true nor false take any arguments, their injectivity is not
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: true 也不接受任何参数，它们的单射性不是
- en: interesting.)  And so on.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有趣的。）等等。
- en: Coq provides a tactic called inversion that allows us to
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq提供了一个称为inversion的策略，允许我们
- en: exploit these principles in proofs. To see how to use it, let's
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 利用这些原则进行证明。为了看如何使用它，让我们
- en: 'show explicitly that the S constructor is injective:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确显示S构造函数是单射的：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By writing inversion H at this point, we are asking Coq to
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在这一点写入inversion H，我们要求Coq
- en: generate all equations that it can infer from H as additional
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成它可以从H推断出的所有方程作为额外的
- en: hypotheses, replacing variables in the goal as it goes. In the
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设，替换目标中的变量。在
- en: 'present example, this amounts to adding a new hypothesis H[1] : n = m and replacing
    n by m in the goal.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在的例子，这相当于添加一个新的假设H[1]：n = m并将n替换为m在目标中。
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here's a more interesting example that shows how multiple
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一个更有趣的例子，展示了如何多个
- en: equations can be derived at once.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方程可以一次推导出来。
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can name the equations that inversion generates with an
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以用一个名字命名反演生成的方程
- en: 'as ... clause:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如...子句：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Exercise: 1 star (inversion_ex[3])'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（inversion_ex[3]）
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ☐
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: When used on a hypothesis involving an equality between
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用于涉及等式的假设时
- en: '*different* constructors (e.g., S n = O), inversion solves the'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*不同*构造函数（例如，S n = O），反演解决了'
- en: 'goal immediately.  Consider the following proof:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 立即目标。考虑以下证明：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can proceed by case analysis on n. The first case is
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过对n进行案例分析来继续。第一种情况是
- en: trivial.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 琐碎的。
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, the second one doesn''t look so simple: assuming'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，第二个看起来并不那么简单：假设
- en: beq_nat 0 (S n') = true, we must show S n' = 0, but the latter
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: beq_nat 0（S n'）= true，我们必须展示S n' = 0，但后者
- en: clearly contradictory!  The way forward lies in the assumption.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明显矛盾！前进的道路在于假设。
- en: 'After simplifying the goal state, we see that beq_nat 0 (S n'') = true has
    become false = true:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简化目标状态后，我们看到beq_nat 0（S n'）= true已变为false = true：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we use inversion on this hypothesis, Coq notices that
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们在这个假设上使用inversion，Coq会注意到
- en: the subgoal we are working on is impossible, and therefore removes
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在处理的子目标是不可能的，因此移除
- en: it from further consideration.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从进一步考虑中删除它。
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is an instance of a logical principle known as the *principle of explosion*,
    which asserts that a contradictory hypothesis
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个逻辑原理的实例，被称为*爆炸原理*，它断言一个矛盾的假设
- en: entails anything, even false things!
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 意味着任何事情，甚至是虚假的事情！
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you find the principle of explosion confusing, remember
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你觉得爆炸原理令人困惑，请记住
- en: that these proofs are not actually showing that the conclusion of
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些证明实际上并没有显示结论
- en: the statement holds.  Rather, they are arguing that, if the
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 陈述成立。他们认为，如果
- en: nonsensical situation described by the premise did somehow arise,
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前提描述的荒谬情况确实发生了，
- en: then the nonsensical conclusion would follow.  We'll explore the
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么荒谬的结论就会得出。我们将探讨
- en: principle of explosion of more detail in the next chapter.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更详细的爆炸原理原则将在下一章中介绍。
- en: 'Exercise: 1 star (inversion_ex[6])'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（inversion_ex[6]）
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ☐
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: To summarize this discussion, suppose H is a hypothesis in the
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结一下，假设H是一个假设
- en: context or a previously proven lemma of the form
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上下文或形式为的先前证明的引理
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Theorem f_equal : ∀(A B : Type) (f: A → B) (x y: A),'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 定理f_equal：∀（A B：Type）（f：A→B）（x y：A），
- en: x = y → f x = f y.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: x = y → f x = f y。
- en: Proof. intros A B f x y eq. rewrite eq. reflexivity. Qed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。intros A B f x y eq. rewrite eq. reflexivity. Qed.
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Theorem S_inj : ∀(n m : nat) (b : bool),'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 定理S_inj：∀（n m：nat）（b：bool），
- en: beq_nat (S n) (S m) = b  →
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: beq_nat（S n）（S m）= b  →
- en: beq_nat n m = b.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: beq_nat n m = b。
- en: Proof.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n m b H. simpl in H. apply H. Qed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: intros n m b H。在H中简化。应用H。Qed。
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Theorem silly3'' : ∀(n : nat),'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 定理silly3'：∀（n：nat），
- en: (beq_nat n 5 = true → beq_nat (S (S n)) 7 = true) →
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: （beq_nat n 5 = true → beq_nat（S（S n））7 = true）→
- en: true = beq_nat n 5  →
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: true = beq_nat n 5  →
- en: true = beq_nat (S (S n)) 7.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: true = beq_nat（S（S n））7。
- en: Proof.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n eq H.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: intros n eq H.
- en: symmetry in H. apply eq in H. symmetry in H.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: H中的对称性。在H中应用eq。在H中对称。
- en: apply H. Qed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应用H。Qed.
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Theorem plus_n_n_injective : ∀n m,'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 定理plus_n_n_injective：∀n m，
- en: n + n = m + m →
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: n + n = m + m →
- en: n = m.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: n = m。
- en: Proof.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n. induction n as [| n'].
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: intros n. induction n as [| n'].
- en: (* FILL IN HERE *) Admitted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处 *) Admitted.
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Varying the Induction Hypothesis
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变化归纳假设
- en: Sometimes it is important to control the exact form of the
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时重要的是控制
- en: induction hypothesis when carrying out inductive proofs in Coq.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Coq中进行归纳证明时使用归纳假设。
- en: In particular, we need to be careful about which of the
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是，我们需要小心选择哪个
- en: assumptions we move (using intros) from the goal to the context
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们移动的假设的确切形式（使用intros）从目标到上下文
- en: before invoking the induction tactic.  For example, suppose
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用归纳策略之前。例如，假设
- en: we want to show that the double function is injective — i.e.,
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想要证明 double 函数是单射 — 即，
- en: 'that it maps different arguments to different results:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将不同的参数映射到不同的结果：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: intros n. induction n.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n。对 n 进行归纳。
- en: all is well.  But if we begin it with
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一切顺利。但是如果我们以此开始
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Theorem double_injective_FAILED : ∀n m,'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 double_injective_FAILED：∀n m，
- en: double n = double m →
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: double n = double m →
- en: n = m.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: n = m。
- en: Proof.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n m. induction n as [| n'].
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n m。对 n 进行归纳。
- en: '- (* n = O *) simpl. intros eq. destruct m as [| m''].'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* n = O *) 简化。引入 eq。将 m 分解为 [| m'']。'
- en: + (* m = O *) reflexivity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: + (* m = O *) 反射。
- en: + (* m = S m' *) inversion eq.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: + (* m = S m' *) 反演 eq。
- en: '- (* n = S n'' *) intros eq. destruct m as [| m''].'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* n = S n'' *) 引入 eq。将 m 分解为 [| m'']。'
- en: + (* m = O *) inversion eq.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: + (* m = O *) 反演 eq。
- en: + (* m = S m' *) apply f_equal.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: + (* m = S m' *) 应用 f_equal。
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Abort.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Theorem double_injective : ∀n m,'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 double_injective：∀n m，
- en: double n = double m →
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: double n = double m →
- en: n = m.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: n = m。
- en: Proof.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n. induction n as [| n'].
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n。对 n 进行归纳，分为 [| n']。
- en: '- (* n = O *) simpl. intros m eq. destruct m as [| m''].'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* n = O *) 简化。引入 m eq。将 m 分解为 [| m'']。'
- en: + (* m = O *) reflexivity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: + (* m = O *) 反射。
- en: + (* m = S m' *) inversion eq.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: + (* m = S m' *) 反演 eq。
- en: '- (* n = S n'' *) simpl.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* n = S n'' *) 简化。'
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: intros m eq.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 m eq。
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: destruct m as [| m'].
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将 m 分解为 [| m']。
- en: + (* m = O *) simpl.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: + (* m = O *) 简化。
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: inversion eq.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 eq。
- en: + (* m = S m' *)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: + (* m = S m' *)
- en: apply f_equal.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 f_equal。
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: apply IHn'. inversion eq. reflexivity. Qed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHn'。反演 eq。反射。完成。
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Theorem beq_nat_true : ∀n m,'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 beq_nat_true：∀n m，
- en: beq_nat n m = true → n = m.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: beq_nat n m = true → n = m。
- en: Proof.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*) 放弃。
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: (* FILL IN HERE *)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*) 放弃。
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Theorem double_injective_take2_FAILED : ∀n m,'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 double_injective_take2_FAILED：∀n m，
- en: double n = double m →
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: double n = double m →
- en: n = m.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: n = m。
- en: Proof.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n m. induction m as [| m'].
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n m。对 m 进行归纳，分为 [| m']。
- en: '- (* m = O *) simpl. intros eq. destruct n as [| n''].'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* m = O *) 简化。引入 eq。将 n 分解为 [| n'']。'
- en: + (* n = O *) reflexivity.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: + (* n = O *) 反射。
- en: + (* n = S n' *) inversion eq.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: + (* n = S n' *) 反演 eq。
- en: '- (* m = S m'' *) intros eq. destruct n as [| n''].'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* m = S m'' *) 引入 eq。将 n 分解为 [| n'']。'
- en: + (* n = O *) inversion eq.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: + (* n = O *) 反演 eq。
- en: + (* n = S n' *) apply f_equal.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: + (* n = S n' *) 应用 f_equal。
- en: (* Stuck again here, just like before. *)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (* 再次卡在这里，就像之前一样。*)
- en: Abort.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Theorem double_injective_take2 : ∀n m,'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 double_injective_take2：∀n m，
- en: double n = double m →
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: double n = double m →
- en: n = m.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: n = m。
- en: Proof.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n m.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n m。
- en: (* n and m are both in the context *)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (* n 和 m 都在上下文中*)
- en: generalize dependent n.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 推广 n。
- en: (* Now n is back in the goal and we can do induction on      m and get a sufficiently general IH. *)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: (* 现在 n 回到目标中，我们可以对 m 进行归纳，得到��个足够通用的 IH。*)
- en: induction m as [| m'].
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对 m 进行归纳，分为 [| m']。
- en: '- (* m = O *) simpl. intros n eq. destruct n as [| n''].'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* m = O *) 简化。引入 n eq。将 n 分解为 [| n'']。'
- en: + (* n = O *) reflexivity.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: + (* n = O *) 反射。
- en: + (* n = S n' *) inversion eq.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: + (* n = S n' *) 反演 eq。
- en: '- (* m = S m'' *) intros n eq. destruct n as [| n''].'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* m = S m'' *) 引入 n eq。将 n 分解为 [| n'']。'
- en: + (* n = O *) inversion eq.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: + (* n = O *) 反演 eq。
- en: + (* n = S n' *) apply f_equal.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: + (* n = S n' *) 应用 f_equal。
- en: apply IHm'. inversion eq. reflexivity. Qed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHm'。反演 eq。反射。完成。
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Theorem beq_id_true : ∀x y,'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 beq_id_true：∀x y，
- en: beq_id x y = true → x = y.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: beq_id x y = true → x = y。
- en: Proof.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros [m] [n]. simpl. intros H.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 [m] [n]。简化。引入 H。
- en: 'assert (H'' : m = n). { apply beq_nat_true. apply H. }'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '断言 (H'' : m = n)。{ 应用 beq_nat_true。应用 H。 }'
- en: rewrite H'. reflexivity.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 H'。反射。
- en: Qed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Theorem nth_error_after_last: ∀(n : nat) (X : Type) (l : list X),'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 nth_error_after_last：∀(n : nat) (X : Type) (l : list X)，'
- en: length l = n →
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 长度 l = n →
- en: nth_error l n = None.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: nth_error l n = None。
- en: Proof.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*) 放弃。
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Unfolding Definitions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开定义
- en: It sometimes happens that we need to manually unfold a Definition
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时我们需要手动展开一个定义
- en: so that we can manipulate its right-hand side.  For example, if we
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以便我们可以操作其右侧。例如，如果我们
- en: define...
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义...
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '... and try to prove a simple fact about square...'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '... 并尝试证明关于 square 的一个简单事实...'
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '... we get stuck: simpl doesn''t simplify anything at this point,'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '... 我们卡住了：此时简化不会简化任何内容，'
- en: and since we haven't proved any other facts about square, there
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们还没有证明关于 square 的其他事实，
- en: is nothing we can apply or rewrite with.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有我们可以应用或重写的内容。
- en: To make progress, we can manually unfold the definition of
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了取得进展，我们可以手动展开
- en: 'square:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 平方：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we have plenty to work with: both sides of the equality are'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有很多可以使用的内容：等式的两边都是
- en: expressions involving multiplication, and we have lots of facts
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 涉及乘法的表达式，我们有很多事实
- en: about multiplication at our disposal.  In particular, we know that
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于乘法的。特别是，我们知道
- en: it is commutative and associative, and from these facts it is not
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是可交换和可结合的，从这些事实中我们知道
- en: hard to finish the proof.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很难完成证明。
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, a deeper discussion of unfolding and simplification
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，对展开和简化进行更深入的讨论
- en: is in order.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是必要的。
- en: You may already have observed that tactics like simpl,
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到像 simpl 这样的策略，
- en: reflexivity, and apply will often unfold the definitions of
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反射，apply 通常会展开
- en: functions automatically when this allows them to make progress.  For
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当函数自动执行时，如果这使它们取得进展。对于
- en: example, if we define foo m to be the constant 5...
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果我们将 foo m 定义为常数 5...
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: then the simpl in the following proof (or the reflexivity, if
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在以下证明中简化（或者反射，如果
- en: we omit the simpl) will unfold foo m to (fun x ⇒ 5) m and
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们省略 simpl）将 foo m 展开为 (fun x ⇒ 5) m 和
- en: then further simplify this expression to just 5.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后进一步简化这个表达式为只有 5。
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: However, this automatic unfolding is rather conservative.  For
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这种自动展开相当保守。对于
- en: example, if we define a slightly more complicated function
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果我们定义一个稍微复杂的函数
- en: involving a pattern match...
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 涉及模式匹配的...
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '...then the analogous proof will get stuck:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...那么类似的证明将会陷入困境：'
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The reason that simpl doesn't make progress here is that it
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simpl 在这里无法取得进展的原因是
- en: notices that, after tentatively unfolding bar m, it is left with
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到，在暂时展开 bar m 后，它留下了
- en: a match whose scrutinee, m, is a variable, so the match cannot
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个匹配项的被检验者，m，是一个变量，所以匹配不能
- en: be simplified further.  (It is not smart enough to notice that the
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不能进一步简化。（它不够聪明，无法注意到这一点
- en: two branches of the match are identical.)  So it gives up on
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 匹配的两个分支是相同的。）因此，它放弃了
- en: unfolding bar m and leaves it alone.  Similarly, tentatively
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展开 bar m 并将其保持不变。同样地，暂时
- en: unfolding bar (m+1) leaves a match whose scrutinee is a
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展开 bar (m+1) 留下一个匹配项，其案例分析的被检验者是一个
- en: function application (that, itself, cannot be simplified, even
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数应用（它本身无法简化，甚至
- en: after unfolding the definition of +), so simpl leaves it
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在展开 + 的定义后，所以 simpl 将其留下
- en: alone.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单独。
- en: At this point, there are two ways to make progress.  One is to use
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，有两种方法可以取得进展。一种是使用
- en: destruct m to break the proof into two cases, each focusing on a
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: destruct m 将证明分成两种情况，每种情况都专注于一个
- en: more concrete choice of m (O vs S _).  In each case, the
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更具体的 m 的选择（O vs S _）。在每种情况下，这个
- en: match inside of bar can now make progress, and the proof is
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: bar 中的匹配现在可以取得进展，证明也是
- en: easy to complete.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成起来很容易。
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This approach works, but it depends on our recognizing that the
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法有效，但它取决于我们认识到
- en: match hidden inside bar is what was preventing us from making
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: bar 中隐藏的匹配项是阻止我们取得进展的原因
- en: progress.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进展。
- en: A more straightforward way to make progress is to explicitly tell
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更直接的方法是明确告诉
- en: Coq to unfold bar.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 展开 bar。
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now it is apparent that we are stuck on the match expressions on
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在很明显我们卡在匹配表达式上。
- en: both sides of the =, and we can use destruct to finish the
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等号的两边，我们可以使用 destruct 完成
- en: proof without thinking too hard.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在不费力地思考的情况下完成证明。
- en: '[PRE57]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using destruct on Compound Expressions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 destruct 处理复合表达式
- en: We have seen many examples where destruct is used to
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经看到许多示例，其中 destruct 被用来
- en: perform case analysis of the value of some variable.  But
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行某个变量的值的案例分析。但是
- en: sometimes we need to reason by cases on the result of some
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时我们需要根据某些结果的情况进行推理
- en: '*expression*.  We can also do this with destruct.'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*表达式*。我们也可以用 destruct 来做这个。'
- en: 'Here are some examples:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: '[PRE58]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After unfolding sillyfun in the above proof, we find that
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述证明中展开 sillyfun 后，我们发现
- en: we are stuck on if (beq_nat n 3) then ... else ....  But either
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们卡在 if (beq_nat n 3) then ... else .... 上。但是任一
- en: n is equal to 3 or it isn't, so we can use destruct (beq_nat n 3) to let us
    reason about the two cases.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: n 等于 3 或者不等于 3，所以我们可以使用 destruct (beq_nat n 3) 来让我们推理这两种情况。
- en: In general, the destruct tactic can be used to perform case
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一般来说，destruct 策略可用于执行案例
- en: analysis of the results of arbitrary computations.  If e is an
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对任意计算结果进行分析。如果 e 是一个
- en: expression whose type is some inductively defined type T, then,
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其类型为归纳定义的类型 T 的表达式，那么
- en: for each constructor c of T, destruct e generates a subgoal
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 T 的每个构造函数 c，destruct e 生成一个子目标
- en: in which all occurrences of e (in the goal and in the context)
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有 e 的出现（在目标和上下文中）
- en: are replaced by c.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被 c 替换。
- en: 'Exercise: 3 stars, optional (combine_split)'
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3 星，可选（combine_split）
- en: '[PRE59]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ☐
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: However, destructing compound expressions requires a bit of
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，对复合表达式进行 destruct 需要一点
- en: care, as such destructs can sometimes erase information we need
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要小心，因为这样的 destruct 有时会擦除我们需要的信息
- en: to complete a proof.  For example, suppose we define a function sillyfun1 like
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成证明。例如，假设我们定义一个类似 sillyfun1 的函数
- en: 'this:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样：
- en: '[PRE60]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now suppose that we want to convince Coq of the (rather
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在假设我们想说服Coq（相当
- en: obvious) fact that sillyfun1 n yields true only when n is
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显而易见）的事实，即sillyfun1 n仅在n为真时产生
- en: odd.  By analogy with the proofs we did with sillyfun above, it
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 奇数。类比我们在上面与sillyfun一起做的证明，它
- en: 'is natural to start the proof like this:'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自然地开始证明如下：
- en: '[PRE61]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We get stuck at this point because the context does not
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这一点上陷入困境，因为上下文不
- en: contain enough information to prove the goal!  The problem is that
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含足够的信息来证明目标！问题在于
- en: the substitution performed by destruct is too brutal — it threw
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: destruct执行的替换太过激烈 — 它抛出了
- en: away every occurrence of beq_nat n 3, but we need to keep some
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消除每个出现的beq_nat n 3，但我们需要保留一些
- en: memory of this expression and how it was destructed, because we
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个表达式及其如何被破坏的记忆，因为我们
- en: need to be able to reason that, since beq_nat n 3 = true in this
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要能够推断，因为在这种情况下beq_nat n 3 = true
- en: branch of the case analysis, it must be that n = 3, from which
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 案例分析的分支，必须是n = 3，从中
- en: it follows that n is odd.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随后n为奇数。
- en: What we would really like is to substitute away all existing
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们真正想要的是替换掉所有现有的
- en: occurences of beq_nat n 3, but at the same time add an equation
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出现的beq_nat n 3，但同时添加一个方程
- en: 'to the context that records which case we are in.  The eqn:'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记录我们处于哪种情况的上下文。等式：
- en: qualifier allows us to introduce such an equation, giving it a
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 限定符允许我们引入这样一个方程，给它一个
- en: name that we choose.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们选择的名称。
- en: '[PRE62]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Exercise: 2 stars (destruct_eqn_practice)'
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星（destruct_eqn_practice）
- en: '[PRE63]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ☐
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE64]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Additional Exercises
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加练习
- en: 'Exercise: 3 stars (beq_nat_sym)'
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星（beq_nat_sym）
- en: '[PRE65]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ☐
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, advancedM? (beq_nat_sym_informal)'
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，高级M？（beq_nat_sym_informal）
- en: Give an informal proof of this lemma that corresponds to your
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给出与您对应的此引理的非正式证明
- en: 'formal proof above:'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述形式化证明：
- en: 'Theorem: For any nats n m, beq_nat n m = beq_nat m n.'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理：对于任何nats n m，beq_nat n m = beq_nat m n。
- en: 'Proof:'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明：
- en: (* FILL IN HERE *)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: （*在这里填写*）
- en: ☐
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, optional (beq_nat_trans)'
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，可选（beq_nat_trans）
- en: '[PRE66]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ☐
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, advancedM (split_combine)'
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，高级M（split_combine）
- en: We proved, in an exercise above, that for all lists of pairs,
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在上面的一个练习中证明了，对于所有的成对列表，
- en: combine is the inverse of split.  How would you formalize the
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: combine是split的逆。您如何形式化
- en: statement that split is the inverse of combine?  When is this
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明split是combine的逆？这是什么时候
- en: property true?
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性为真？
- en: Complete the definition of split_combine_statement below with a
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用下面的split_combine_statement完成定义
- en: property that states that split is the inverse of
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明split是的逆。
- en: combine. Then, prove that the property holds. (Be sure to leave
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: combine。然后，证明该属性成立。（确保留下
- en: your induction hypothesis general by not doing intros on more
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过不在更多的intros上进行使您的归纳假设更一般
- en: 'things than necessary.  Hint: what property do you need of l[1]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 比必要的更多的事情。提示：你需要l[1]的什么属性
- en: and l[2] for split combine l[1] l[2] = (l[1],l[2]) to be true?)
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和l[2]用于split combine l[1] l[2] = (l[1],l[2])是否为真?)
- en: '[PRE67]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ☐
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, advanced (filter_exercise)'
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，高级（filter_exercise）
- en: This one is a bit challenging.  Pay attention to the form of your
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个有点具有挑战性。注意您的形式
- en: induction hypothesis.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 归纳假设。
- en: '[PRE68]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ☐
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 4 stars, advanced, recommended (forall_exists_challenge)'
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：4星，高级，推荐（forall_exists_challenge）
- en: Define two recursive Fixpoints, forallb and existsb.  The
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义两个递归Fixpoints，forallb和existsb。该
- en: first checks whether every element in a list satisfies a given
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先检查列表中的每个元素是否满足给定的
- en: 'predicate:'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断言：
- en: '[PRE69]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: existsb (beq_nat 5) [0;2;3;6] = false
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: existsb (beq_nat 5) [0;2;3;6] = false
- en: existsb (andb true) [true;true;false] = true
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: existsb (andb true) [true;true;false] = true
- en: existsb oddb [1;0;0;0;0;3] = true
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: existsb oddb [1;0;0;0;0;3] = true
- en: existsb evenb [] = false
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: existsb evenb [] = false
- en: Next, define a *nonrecursive* version of existsb — call it
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，定义*非递归*版本的existsb — 称之为
- en: existsb' — using forallb and negb.
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: existsb' — 使用forallb和negb。
- en: Finally, prove a theorem existsb_existsb' stating that
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，证明一个定理existsb_existsb'，陈述
- en: existsb' and existsb have the same behavior.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: existsb'和existsb具有相同的行为。
- en: '[PRE70]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ☐
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE71]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
