- en: NormNormalization of STLC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STLC 的 NormNormalization
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (* Chapter written and maintained by Andrew Tolmach *)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: （由 Andrew Tolmach 撰写和维护的章节）
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (* FILL IN HERE *)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *)
- en: '[PRE2]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Language
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言
- en: We begin by repeating the relevant language definition, which is
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先重复相关的语言定义，即
- en: similar to those in the [MoreStlc](MoreStlc.html) chapter, plus supporting
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似于[MoreStlc](MoreStlc.html) 章节中的内容，还支持
- en: results including type preservation and step determinism.  (We
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包括类型保持和步骤确定性的结果。 （我们
- en: won't need progress.)  You may just wish to skip down to the
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不需���进展。）您可能只希望跳到
- en: Normalization section...
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规范化部分...
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Require Import Coq.Lists.List.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 Coq.Lists.List。
- en: Import ListNotations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 ListNotations。
- en: Require Import Maps.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 Maps。
- en: Require Import Smallstep.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 Smallstep。
- en: Hint Constructors multi.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 Constructors multi。
- en: 'Inductive ty : Type :='
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 ty：类型 :=
- en: '| TBool : ty'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '| TBool : 类型'
- en: '| TArrow : ty → ty → ty'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '| TArrow : 类型 → 类型 → 类型'
- en: '| TProd  : ty → ty → ty'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '| TProd  : 类型 → 类型 → 类型'
- en: .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: 'Inductive tm : Type :='
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 tm：类型 :=
- en: (* pure STLC *)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: (* 纯 STLC *)
- en: '| tvar : id → tm'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '| tvar : id → 项'
- en: '| tapp : tm → tm → tm'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '| tapp : 项 → 项 → 项'
- en: '| tabs : id → ty → tm → tm'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '| tabs : id → 类型 → 项 → 项'
- en: (* pairs *)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (* 对 *)
- en: '| tpair : tm → tm → tm'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '| tpair : 项 → 项 → 项'
- en: '| tfst : tm → tm'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '| tfst : 项 → 项'
- en: '| tsnd : tm → tm'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '| tsnd : 项 → 项'
- en: (* booleans *)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: (* 布尔值 *)
- en: '| ttrue : tm'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '| ttrue : 项'
- en: '| tfalse : tm'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '| tfalse : 项'
- en: '| tif : tm → tm → tm → tm.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '| tif : 项 → 项 → 项 → 项。'
- en: (* i.e., if t[0] then t[1] else t[2] *)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: (* 即，如果 t[0] then t[1] else t[2] *)
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Fixpoint subst (x:id) (s:tm) (t:tm) : tm :='
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 递归替换（x:id）（s:tm）（t:tm）：tm :=
- en: match t with
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 t 与
- en: '| tvar y ⇒ if beq_id x y then s else t'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '| tvar y ⇒ 如果 beq_id x y then s else t'
- en: '| tabs y T t[1] ⇒'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '| tabs y T t[1] ⇒'
- en: tabs y T (if beq_id x y then t[1] else (subst x s t[1]))
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: tabs y T（如果 beq_id x y then t[1] else（subst x s t[1]））
- en: '| tapp t[1] t[2] ⇒ tapp (subst x s t[1]) (subst x s t[2])'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '| tapp t[1] t[2] ⇒ tapp (subst x s t[1]) (subst x s t[2])'
- en: '| tpair t[1] t[2] ⇒ tpair (subst x s t[1]) (subst x s t[2])'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '| tpair t[1] t[2] ⇒ tpair（subst x s t[1]）（subst x s t[2]）'
- en: '| tfst t[1] ⇒ tfst (subst x s t[1])'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '| tfst t[1] ⇒ tfst（subst x s t[1]）'
- en: '| tsnd t[1] ⇒ tsnd (subst x s t[1])'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '| tsnd t[1] ⇒ tsnd（subst x s t[1]）'
- en: '| ttrue ⇒ ttrue'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| ttrue ⇒ ttrue'
- en: '| tfalse ⇒ tfalse'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '| tfalse ⇒ tfalse'
- en: '| tif t[0] t[1] t[2] ⇒'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '| tif t[0] t[1] t[2] ⇒'
- en: tif (subst x s t[0]) (subst x s t[1]) (subst x s t[2])
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: tif（subst x s t[0]）（subst x s t[1]）（subst x s t[2]）
- en: end.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: Notation "'[' x ':=' s ']' t" := (subst x s t) (at level 20).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "'[' x ':=' s ']' t" := (subst x s t) (在 20 级)。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inductive value : tm → Prop :='
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳值：tm → Prop :=
- en: '| v_abs : ∀x T[11] t[12],'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '| v_abs : ∀x T[11] t[12],'
- en: value (tabs x T[11] t[12])
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 值（tabs x T[11] t[12]）
- en: '| v_pair : ∀v[1] v[2],'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '| v_pair : ∀v[1] v[2],'
- en: value v[1] →
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[1] →
- en: value v[2] →
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[2] →
- en: value (tpair v[1] v[2])
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值（tpair v[1] v[2]）
- en: '| v_true : value ttrue'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '| v_true : value ttrue'
- en: '| v_false : value tfalse'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '| v_false : value tfalse'
- en: .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: Hint Constructors value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 Constructors value。
- en: Reserved Notation "t1 '⇒' t2" (at level 40).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 保留记号 "t1 '⇒' t2"（在 40 级）。
- en: 'Inductive step : tm → tm → Prop :='
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳步骤：tm → tm → Prop :=
- en: '| ST_AppAbs : ∀x T[11] t[12] v[2],'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_AppAbs : ∀x T[11] t[12] v[2],'
- en: value v[2] →
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[2] →
- en: (tapp (tabs x T[11] t[12]) v[2]) ⇒ [x:=v[2]]t[12]
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: (tapp (tabs x T[11] t[12]) v[2]) ⇒ [x:=v[2]]t[12]
- en: '| ST_App1 : ∀t[1] t[1]'' t[2],'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_App1 : ∀t[1] t[1]'' t[2],'
- en: t[1] ⇒ t[1]' →
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] ⇒ t[1]' →
- en: (tapp t[1] t[2]) ⇒ (tapp t[1]' t[2])
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: （tapp t[1] t[2]）⇒（tapp t[1]' t[2]）
- en: '| ST_App2 : ∀v[1] t[2] t[2]'','
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_App2 : ∀v[1] t[2] t[2]'','
- en: value v[1] →
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[1] →
- en: t[2] ⇒ t[2]' →
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: t[2] ⇒ t[2]' →
- en: (tapp v[1] t[2]) ⇒ (tapp v[1] t[2]')
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: （tapp v[1] t[2]）⇒（tapp v[1] t[2]'）
- en: (* pairs *)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (* 对 *)
- en: '| ST_Pair1 : ∀t[1] t[1]'' t[2],'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Pair1 : ∀t[1] t[1]'' t[2],'
- en: t[1] ⇒ t[1]' →
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] ⇒ t[1]' →
- en: (tpair t[1] t[2]) ⇒ (tpair t[1]' t[2])
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: （tpair t[1] t[2]）⇒（tpair t[1]' t[2]）
- en: '| ST_Pair2 : ∀v[1] t[2] t[2]'','
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Pair2 : ∀v[1] t[2] t[2]'','
- en: value v[1] →
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[1] →
- en: t[2] ⇒ t[2]' →
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: t[2] ⇒ t[2]' →
- en: (tpair v[1] t[2]) ⇒ (tpair v[1] t[2]')
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （tpair v[1] t[2]）⇒（tpair v[1] t[2]'）
- en: '| ST_Fst : ∀t[1] t[1]'','
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Fst : ∀t[1] t[1]'','
- en: t[1] ⇒ t[1]' →
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] ⇒ t[1]' →
- en: (tfst t[1]) ⇒ (tfst t[1]')
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: （tfst t[1]）⇒（tfst t[1]'）
- en: '| ST_FstPair : ∀v[1] v[2],'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_FstPair : ∀v[1] v[2],'
- en: value v[1] →
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[1] →
- en: value v[2] →
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[2] →
- en: (tfst (tpair v[1] v[2])) ⇒ v[1]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (tfst（tpair v[1] v[2]）) ⇒ v[1]
- en: '| ST_Snd : ∀t[1] t[1]'','
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Snd : ∀t[1] t[1]'','
- en: t[1] ⇒ t[1]' →
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] ⇒ t[1]' →
- en: (tsnd t[1]) ⇒ (tsnd t[1]')
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: （tsnd t[1]）⇒（tsnd t[1]'）
- en: '| ST_SndPair : ∀v[1] v[2],'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_SndPair : ∀v[1] v[2],'
- en: value v[1] →
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[1] →
- en: value v[2] →
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[2] →
- en: (tsnd (tpair v[1] v[2])) ⇒ v[2]
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: （tsnd（tpair v[1] v[2]））⇒ v[2]
- en: (* booleans *)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (* 布尔值 *)
- en: '| ST_IfTrue : ∀t[1] t[2],'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_IfTrue : ∀t[1] t[2],'
- en: (tif ttrue t[1] t[2]) ⇒ t[1]
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: （tif ttrue t[1] t[2]）⇒ t[1]
- en: '| ST_IfFalse : ∀t[1] t[2],'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_IfFalse : ∀t[1] t[2],'
- en: (tif tfalse t[1] t[2]) ⇒ t[2]
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (tif tfalse t[1] t[2]) ⇒ t[2]
- en: '| ST_If : ∀t[0] t[0]'' t[1] t[2],'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_If : ∀t[0] t[0]'' t[1] t[2],'
- en: t[0] ⇒ t[0]' →
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: t[0] ⇒ t[0]' →
- en: (tif t[0] t[1] t[2]) ⇒ (tif t[0]' t[1] t[2])
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (tif t[0] t[1] t[2]) ⇒ (tif t[0]' t[1] t[2])
- en: where "t1 '⇒' t2" := (step t[1] t[2]).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 "t1 '⇒' t2" := (step t[1] t[2])。
- en: Notation multistep := (multi step).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 multistep := (multi step)。
- en: Notation "t1 '⇒*' t2" := (multistep t[1] t[2]) (at level 40).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "t1 '⇒*' t2" := (multistep t[1] t[2]) (在 40 级)。
- en: Hint Constructors step.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 Constructors step。
- en: Notation step_normal_form := (normal_form step).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 step_normal_form := (normal_form step)。
- en: 'Lemma value__normal : ∀t, value t → step_normal_form t.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 value__normal : ∀t, value t → step_normal_form t。'
- en: Proof with eauto.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros t H; induction H; intros [t' ST]; inversion ST...
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: intros t H; induction H; intros [t' ST]; inversion ST...
- en: Qed.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Definition context := partial_map ty.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 定义上下文 := partial_map ty.
- en: 'Inductive has_type : context → tm → ty → Prop :='
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive has_type : context → tm → ty → Prop :='
- en: (* Typing rules for proper terms *)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (* proper terms的类型规则*)
- en: '| T_Var : ∀Γ x T,'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_Var : ∀Γ x T,'
- en: Γ x = Some T →
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Γ x = Some T →
- en: has_type Γ (tvar x) T
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ (tvar x) T
- en: '| T_Abs : ∀Γ x T[11] T[12] t[12],'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_Abs : ∀Γ x T[11] T[12] t[12],'
- en: has_type (update Γ x T[11]) t[12] T[12] →
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: has_type (update Γ x T[11]) t[12] T[12] →
- en: has_type Γ (tabs x T[11] t[12]) (TArrow T[11] T[12])
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ (tabs x T[11] t[12]) (TArrow T[11] T[12])
- en: '| T_App : ∀T[1] T[2] Γ t[1] t[2],'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_App : ∀T[1] T[2] Γ t[1] t[2],'
- en: has_type Γ t[1] (TArrow T[1] T[2]) →
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t[1] (TArrow T[1] T[2]) →
- en: has_type Γ t[2] T[1] →
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t[2] T[1] →
- en: has_type Γ (tapp t[1] t[2]) T[2]
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ (tapp t[1] t[2]) T[2]
- en: (* pairs *)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: (* pairs *)
- en: '| T_Pair : ∀Γ t[1] t[2] T[1] T[2],'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_Pair : ∀Γ t[1] t[2] T[1] T[2],'
- en: has_type Γ t[1] T[1] →
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t[1] T[1] →
- en: has_type Γ t[2] T[2] →
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t[2] T[2] →
- en: has_type Γ (tpair t[1] t[2]) (TProd T[1] T[2])
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ (tpair t[1] t[2]) (TProd T[1] T[2])
- en: '| T_Fst : ∀Γ t T[1] T[2],'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_Fst : ∀Γ t T[1] T[2],'
- en: has_type Γ t (TProd T[1] T[2]) →
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t (TProd T[1] T[2]) →
- en: has_type Γ (tfst t) T[1]
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ (tfst t) T[1]
- en: '| T_Snd : ∀Γ t T[1] T[2],'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_Snd : ∀Γ t T[1] T[2],'
- en: has_type Γ t (TProd T[1] T[2]) →
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t (TProd T[1] T[2]) →
- en: has_type Γ (tsnd t) T[2]
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ (tsnd t) T[2]
- en: (* booleans *)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: (* booleans *)
- en: '| T_True : ∀Γ,'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_True : ∀Γ,'
- en: has_type Γ ttrue TBool
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ ttrue TBool
- en: '| T_False : ∀Γ,'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_False : ∀Γ,'
- en: has_type Γ tfalse TBool
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ tfalse TBool
- en: '| T_If : ∀Γ t[0] t[1] t[2] T,'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '| T_If : ∀Γ t[0] t[1] t[2] T,'
- en: has_type Γ t[0] TBool →
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t[0] TBool →
- en: has_type Γ t[1] T →
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t[1] T →
- en: has_type Γ t[2] T →
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t[2] T →
- en: has_type Γ (tif t[0] t[1] t[2]) T
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ (tif t[0] t[1] t[2]) T
- en: .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: Hint Constructors has_type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Hint Constructors has_type.
- en: Hint Extern 2 (has_type _ (tapp _ _) _) ⇒ eapply T_App; auto.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Hint Extern 2 (has_type _ (tapp _ _) _) ⇒ eapply T_App; auto.
- en: Hint Extern 2 (_ = _) ⇒ compute; reflexivity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Hint Extern 2 (_ = _) ⇒ compute; reflexivity.
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inductive appears_free_in : id → tm → Prop :='
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive appears_free_in : id → tm → Prop :='
- en: '| afi_var : ∀x,'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_var : ∀x,'
- en: appears_free_in x (tvar x)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tvar x)
- en: '| afi_app1 : ∀x t[1] t[2],'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_app1 : ∀x t[1] t[2],'
- en: appears_free_in x t[1] → appears_free_in x (tapp t[1] t[2])
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[1] → appears_free_in x (tapp t[1] t[2])
- en: '| afi_app2 : ∀x t[1] t[2],'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_app2 : ∀x t[1] t[2],'
- en: appears_free_in x t[2] → appears_free_in x (tapp t[1] t[2])
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[2] → appears_free_in x (tapp t[1] t[2])
- en: '| afi_abs : ∀x y T[11] t[12],'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_abs : ∀x y T[11] t[12],'
- en: y ≠ x  →
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: y ≠ x  →
- en: appears_free_in x t[12] →
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[12] →
- en: appears_free_in x (tabs y T[11] t[12])
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tabs y T[11] t[12])
- en: (* pairs *)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: (* pairs *)
- en: '| afi_pair1 : ∀x t[1] t[2],'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_pair1 : ∀x t[1] t[2],'
- en: appears_free_in x t[1] →
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[1] →
- en: appears_free_in x (tpair t[1] t[2])
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tpair t[1] t[2])
- en: '| afi_pair2 : ∀x t[1] t[2],'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_pair2 : ∀x t[1] t[2],'
- en: appears_free_in x t[2] →
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[2] →
- en: appears_free_in x (tpair t[1] t[2])
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tpair t[1] t[2])
- en: '| afi_fst : ∀x t,'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_fst : ∀x t,'
- en: appears_free_in x t →
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t →
- en: appears_free_in x (tfst t)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tfst t)
- en: '| afi_snd : ∀x t,'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_snd : ∀x t,'
- en: appears_free_in x t →
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t →
- en: appears_free_in x (tsnd t)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tsnd t)
- en: (* booleans *)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: (* booleans *)
- en: '| afi_if[0] : ∀x t[0] t[1] t[2],'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_if[0] : ∀x t[0] t[1] t[2],'
- en: appears_free_in x t[0] →
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[0] →
- en: appears_free_in x (tif t[0] t[1] t[2])
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tif t[0] t[1] t[2])
- en: '| afi_if[1] : ∀x t[0] t[1] t[2],'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_if[1] : ∀x t[0] t[1] t[2],'
- en: appears_free_in x t[1] →
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[1] →
- en: appears_free_in x (tif t[0] t[1] t[2])
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tif t[0] t[1] t[2])
- en: '| afi_if[2] : ∀x t[0] t[1] t[2],'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_if[2] : ∀x t[0] t[1] t[2],'
- en: appears_free_in x t[2] →
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[2] →
- en: appears_free_in x (tif t[0] t[1] t[2])
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tif t[0] t[1] t[2])
- en: .
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: Hint Constructors appears_free_in.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Hint Constructors appears_free_in.
- en: Definition closed (t:tm) :=
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 定义闭合（t:tm） :=
- en: ∀x, ¬ appears_free_in x t.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ∀x, ¬ appears_free_in x t.
- en: 'Lemma context_invariance : ∀Γ Γ'' t S,'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma context_invariance : ∀Γ Γ'' t S,'
- en: has_type Γ t S  →
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t S  →
- en: (∀x, appears_free_in x t → Γ x = Γ' x)  →
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: (∀x, appears_free_in x t → Γ x = Γ' x)  →
- en: has_type Γ' t S.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ' t S.
- en: Proof with eauto.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros. generalize dependent Γ'.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: intros. generalize dependent Γ'.
- en: induction H;
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: induction H;
- en: intros Γ' Heqv...
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: intros Γ' Heqv...
- en: '- (* T_Var *)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Var *)'
- en: apply [T_Var](Norm.html#T_Var)... rewrite ← Heqv...
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Var](Norm.html#T_Var)... rewrite ← Heqv...
- en: '- (* T_Abs *)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: apply [T_Abs](Norm.html#T_Abs)... apply IHhas_type. intros y Hafi.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Abs](Norm.html#T_Abs)... apply IHhas_type. intros y Hafi.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). destruct
    ([beq_idP](Maps.html#beq_idP) x y)...
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). destruct
    ([beq_idP](Maps.html#beq_idP) x y)...
- en: '- (* T_Pair *)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Pair *)'
- en: apply [T_Pair](Norm.html#T_Pair)...
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Pair](Norm.html#T_Pair)...
- en: '- (* T_If *)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_If *)'
- en: eapply [T_If](Norm.html#T_If)...
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_If](Norm.html#T_If)...
- en: Qed.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma free_in_context : ∀x t T Γ,'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma free_in_context : ∀x t T Γ,'
- en: appears_free_in x t →
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t →
- en: has_type Γ t T →
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ t T →
- en: ∃T', Γ x = Some T'.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ∃T', Γ x = Some T'.
- en: Proof with eauto.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros x t T Γ Hafi Htyp.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: intros x t T Γ Hafi Htyp.
- en: induction Htyp; inversion Hafi; subst...
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: induction Htyp; inversion Hafi; subst...
- en: '- (* T_Abs *)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: destruct IHHtyp as [T' Hctx]... ∃T'.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHtyp as [T' Hctx]... ∃T'.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
- en: Qed.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Corollary typable_empty__closed : ∀t T,'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'Corollary typable_empty__closed : ∀t T,'
- en: has_type empty t T  →
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: has_type empty t T  →
- en: closed t.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: closed t.
- en: Proof.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof.
- en: intros. unfold [closed](Norm.html#closed). intros x H[1].
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: intros. unfold [closed](Norm.html#closed). intros x H[1].
- en: destruct ([free_in_context](Norm.html#free_in_context) _ _ _ _ H[1] H) as [T'
    C].
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([free_in_context](Norm.html#free_in_context) _ _ _ _ H[1] H) as [T'
    C].
- en: inversion C. Qed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: inversion C. Qed.
- en: '[PRE8]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
- en: has_type (update Γ x U) t S  →
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: has_type (update Γ x U) t S  →
- en: has_type empty v U   →
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: has_type empty v U   →
- en: has_type Γ ([x:=v]t) S.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: has_type Γ ([x:=v]t) S.
- en: Proof with eauto.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: (* Theorem: If Gamma,x:U |- t : S and empty |- v : U, then      Gamma |- (x:=vt) S. *)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (* 定理：如果 Gamma,x:U |- t : S 且 empty |- v : U，则 Gamma |- (x:=vt) S。 *)
- en: intros Γ x U v t S Htypt Htypv.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: intros Γ x U v t S Htypt Htypv.
- en: generalize dependent Γ. generalize dependent S.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: generalize dependent Γ. generalize dependent S.
- en: (* Proof: By induction on the term t.  Most cases follow directly      from the IH, with the exception of tvar and tabs.
         The former aren't automatic because we must reason about how the      variables interact. *)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: (* 证明：通过 对 项 t 进行 归纳。 大多数 情况 直接 遵循 IH，除了 tvar 和 tabs。 前者 不是 自动 的，因为 我们 必须 推理 变量 如何 相互 作用。 *)
- en: induction t;
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: induction t;
- en: intros S Γ Htypt; simpl; inversion Htypt; subst...
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: intros S Γ Htypt; simpl; inversion Htypt; subst...
- en: '- (* tvar *)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tvar *)'
- en: simpl. rename i into y.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: simpl. rename i into y.
- en: '(* If t = y, we know that          empty ⊢ v : U and          Γ,x:U ⊢ y : S
           and, by inversion, update Γ x U y = Some S.  We want to        show that Γ
    ⊢ [x:=v]y : S.        There are two cases to consider: either x=y or x≠y. *)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 t = y，则 我们 知道 empty ⊢ v : U 且 Γ,x:U ⊢ y : S 并且，通过 反演，update Γ x U y =
    Some S。 我们 想要 展示 Γ ⊢ [x:=v]y : S。 有 两种 情况 要考虑：要么 x=y 要么 x≠y。 *)'
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in H[1].
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in H[1].
- en: destruct ([beq_idP](Maps.html#beq_idP) x y).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x y).
- en: + (* x=y *)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x=y *)
- en: '(* If x = y, then we know that U = S, and that [x:=v]y = v.        So what we really must show is that if empty
    ⊢ v : U then        Γ ⊢ v : U.  We have already proven a more general version
           of this theorem, called context invariance. *)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x = y，则 我们 知道 U = S，且 [x:=v]y = v。 所以 我们 真正 需要 展示 的 是 如果 empty ⊢ v :
    U 则 Γ ⊢ v : U。 我们 已经 证明 了 一个 更 一般 的 定理，称为��上下文 不变性。 *)'
- en: subst.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: subst.
- en: inversion H[1]; subst. clear H[1].
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H[1]; subst. clear H[1].
- en: eapply [context_invariance](Norm.html#context_invariance)...
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [context_invariance](Norm.html#context_invariance)...
- en: intros x Hcontra.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: intros x Hcontra.
- en: destruct ([free_in_context](Norm.html#free_in_context) _ _ S [empty](Maps.html#empty)
    Hcontra) as [T' HT']...
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([free_in_context](Norm.html#free_in_context) _ _ S [empty](Maps.html#empty)
    Hcontra) as [T' HT']...
- en: inversion HT'.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: inversion HT'.
- en: + (* x<>y *)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x<>y *)
- en: '(* If x ≠ y, then Γ y = Some S and the substitution has no          effect.  We can show that Γ
    ⊢ y : S by T_Var. *)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x ≠ y，则 Γ y = Some S 且 替换 没有 效果。 我们 可以 通过 T_Var 展示 Γ ⊢ y : S。 *)'
- en: apply [T_Var](Norm.html#T_Var)...
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Var](Norm.html#T_Var)...
- en: '- (* tabs *)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tabs *)'
- en: rename i into y. rename t into T[11].
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: rename i into y. rename t into T[11].
- en: '(* If t = tabs y T[11] t[0], then we know that          Γ,x:U ⊢ tabs y T[11]
    t[0] : T[11]→T[12]          Γ,x:U,y:T[11] ⊢ t[0] : T[12]          empty ⊢ v :
    U        As our IH, we know that forall S Gamma,          Γ,x:U ⊢ t[0] : S → Γ
    ⊢ [x:=v]t[0] S.        We can calculate that          x:=vt = tabs y T[11] (if beq_id x y then t[0] else x:=vt[0])
           And we must show that Γ ⊢ [x:=v]t : T[11]→T[12].  We know        we will do so using T_Abs, so it remains to be shown that:
             Γ,y:T[11] ⊢ if beq_id x y then t[0] else [x:=v]t[0] : T[12]        We consider two cases: x
    = y and x ≠ y.     *)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 t = tabs y T[11] t[0]，则 我们 知道 Γ,x:U ⊢ tabs y T[11] t[0] : T[11]→T[12] Γ,x:U,y:T[11]
    ⊢ t[0] : T[12] empty ⊢ v : U 根据 我们 的 IH，我们 知道 对于 所有 S Gamma， Γ,x:U ⊢ t[0] : S
    → Γ ⊢ [x:=v]t[0] S 我们 可以 计算 x:=vt = tabs y T[11] (if beq_id x y then t[0] else
    x:=vt[0]) 并且 我们 必须 展示 Γ ⊢ [x:=v]t : T[11]→T[12]。 我们 知道 我们 将 使用 T_Abs 来 做 到 这一点，所以 仍然 需要 展示： Γ,y:T[11]
    ⊢ if beq_id x y then t[0] else [x:=v]t[0] : T[12] 我们 考虑 两种 情况：x = y 和 x ≠ y。 *)'
- en: apply [T_Abs](Norm.html#T_Abs)...
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Abs](Norm.html#T_Abs)...
- en: destruct ([beq_idP](Maps.html#beq_idP) x y).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x y).
- en: + (* x=y *)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x=y *)
- en: '(* If x = y, then the substitution has no effect.  Context        invariance shows that Γ,y:U,y:T[11] and Γ,y:T[11] are
           equivalent.  Since the former context shows that t[0] : T[12], so        does the latter. *)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x = y，则替换没有影响。上下文不变性表明 Γ,y:U,y:T[11] 和 Γ,y:T[11] 是等价的。由于前者上下文表明 t[0]
    : T[12]，所以后者也是。*)'
- en: eapply [context_invariance](Norm.html#context_invariance)...
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [context_invariance](Norm.html#context_invariance)...
- en: subst.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。
- en: intros x Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对 x Hafi 进行引入。展开 [update](Maps.html#update)，[t_update](Maps.html#t_update)。
- en: destruct ([beq_id](Maps.html#beq_id) y x)...
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 分情况讨论 ([beq_id](Maps.html#beq_id) y x)...
- en: + (* x<>y *)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x<>y *)
- en: '(* If x ≠ y, then the IH and context invariance allow us to show that          Γ,x:U,y:T[11]
    ⊢ t[0] : T[12]       =>          Γ,y:T[11],x:U ⊢ t[0] : T[12]       =>          Γ,y:T[11]
    ⊢ [x:=v]t[0] : T[12] *)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x ≠ y，则 IH 和上下文不变性允许我们展示          Γ,x:U,y:T[11] ⊢ t[0] : T[12]       =>
             Γ,y:T[11],x:U ⊢ t[0] : T[12]       =>          Γ,y:T[11] ⊢ [x:=v]t[0]
    : T[12] *)'
- en: apply IHt. eapply [context_invariance](Norm.html#context_invariance)...
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHt。应用 [context_invariance](Norm.html#context_invariance)...
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对 z Hafi 进行引入。展开 [update](Maps.html#update)，[t_update](Maps.html#t_update)。
- en: destruct ([beq_idP](Maps.html#beq_idP) y z)...
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 分情况讨论 ([beq_idP](Maps.html#beq_idP) y z)...
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。重写 [false_beq_id](Maps.html#false_beq_id)...
- en: Qed.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证毕。
- en: 'Theorem preservation : ∀t t'' T,'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 定理保持性质：∀t t' T，
- en: has_type empty t T  →
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有类型 empty t T →
- en: t ⇒ t'  →
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: t ⇒ t' →
- en: has_type empty t' T.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有类型 empty t' T。
- en: Proof with eauto.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明与 eauto。
- en: intros t t' T HT.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 t t' T HT。
- en: '(* Theorem: If empty ⊢ t : T and t ⇒ t'', then empty ⊢ t'' : T. *)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 定理：如果 empty ⊢ t : T 并且 t ⇒ t''，那么 empty ⊢ t'' : T。*)'
- en: remember (@[empty](Maps.html#empty) [ty](Norm.html#ty)) as Γ. generalize dependent
    HeqGamma.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 (@[empty](Maps.html#empty) [ty](Norm.html#ty)) 为 Γ。推广 HeqGamma。
- en: generalize dependent t'.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 推广 t'。
- en: (* Proof: By induction on the given typing derivation.  Many cases are      contradictory (T_Var, T_Abs).  We show just the interesting ones. *)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: (* 证明：对给定的类型推导进行归纳。许多情况是矛盾的（T_Var，T_Abs）。我们只展示有趣的情况。*)
- en: induction HT;
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HT 进行归纳；
- en: intros t' HeqGamma HE; subst; inversion HE; subst...
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 t' HeqGamma HE；替换；反演 HE；替换...
- en: '- (* T_App *)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: (* If the last rule used was T_App, then t = t[1] t[2], and three rules        could have been used to show t
    ⇒ t': ST_App1, ST_App2, and        ST_AppAbs. In the first two cases, the result follows directly from
           the IH. *)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果最后使用的规则是 T_App，则 t = t[1] t[2]，并且有三个规则可以用来展示 t ⇒ t'：ST_App1，ST_App2 和 ST_AppAbs。在前两种情况下，结果直接从
    IH 得出。*)
- en: inversion HE; subst...
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HE；替换...
- en: + (* ST_AppAbs *)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: + (* ST_AppAbs *)
- en: '(* For the third case, suppose            t[1] = tabs x T[11] t[12]          and
               t[2] = v[2].          We must show that empty ⊢ [x:=v[2]]t[12] : T[2].
             We know by assumption that              empty ⊢ tabs x T[11] t[12] :
    T[1]→T[2]          and by inversion              x:T[1] ⊢ t[12] : T[2]          We have already proven that substitution_preserves_typing and
                 empty ⊢ v[2] : T[1]          by assumption, so we are done. *)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 对于第三种情况，假设            t[1] = tabs x T[11] t[12]          且            t[2]
    = v[2]。          我们必须证明 empty ⊢ [x:=v[2]]t[12] : T[2]。          根据假设我们知道              empty
    ⊢ tabs x T[11] t[12] : T[1]→T[2]          并且根据反演              x:T[1] ⊢ t[12] :
    T[2]          我们已经证明了替换保持类型和              empty ⊢ v[2] : T[1]          所以我们完成了。*)'
- en: apply [substitution_preserves_typing](Norm.html#substitution_preserves_typing)
    with T[1]...
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [substitution_preserves_typing](Norm.html#substitution_preserves_typing)
    with T[1]...
- en: inversion HT[1]...
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HT[1]...
- en: '- (* T_Fst *)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Fst *)'
- en: inversion HT...
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HT...
- en: '- (* T_Snd *)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Snd *)'
- en: inversion HT...
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HT...
- en: Qed.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证毕。
- en: '[PRE9]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lemma step_deterministic :'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 引理步骤唯一性：
- en: deterministic step.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一性步骤。
- en: Proof with eauto.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明与 eauto。
- en: unfold [deterministic](Smallstep.html#deterministic).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [deterministic](Smallstep.html#deterministic)。
- en: intros t t' t'' E[1] E[2].
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t t' t'' E[1] E[2]。
- en: generalize dependent t''.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 推广 t''。
- en: induction E[1]; intros t'' E[2]; inversion E[2]; subst; clear E[2]...
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对 E[1] 进行归纳；引入 t'' E[2]；反演 E[2]；替换；清除 E[2]...
- en: (* ST_AppAbs *)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_AppAbs *)
- en: '- inversion H[3].'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反演 H[3]。'
- en: '- exfalso; apply [value__normal](Norm.html#value__normal) in H...'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反证法；在 H 中应用 [value__normal](Norm.html#value__normal)...'
- en: (* ST_App1 *)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_App1 *)
- en: '- inversion E[1].'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反演 E[1]。'
- en: '-  f_equal...'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '- 相等...'
- en: '- exfalso; apply [value__normal](Norm.html#value__normal) in H[1]...'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反证法；在 H[1] 中应用 [value__normal](Norm.html#value__normal)...'
- en: (* ST_App2 *)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_App2 *)
- en: '- exfalso; apply [value__normal](Norm.html#value__normal) in H[3]...'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反证法；在 H[3] 中应用 [value__normal](Norm.html#value__normal)...'
- en: '- exfalso; apply [value__normal](Norm.html#value__normal) in H...'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反证法；在 H 中应用 [value__normal](Norm.html#value__normal)...'
- en: '- f_equal...'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '- 相等...'
- en: (* ST_Pair1 *)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_Pair1 *)
- en: '- f_equal...'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '- 相等...'
- en: '- exfalso; apply [value__normal](Norm.html#value__normal) in H[1]...'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '- 矛盾；应用 [value__normal](Norm.html#value__normal) 到 H[1]...'
- en: (* ST_Pair2 *)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_Pair2 *)
- en: '- exfalso; apply [value__normal](Norm.html#value__normal) in H...'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '- 矛盾；应用 [value__normal](Norm.html#value__normal) 到 H...'
- en: '- f_equal...'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '- 相等...'
- en: (* ST_Fst *)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_Fst *)
- en: '- f_equal...'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '- 相等...'
- en: '- exfalso.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '- 矛盾。'
- en: inversion E[1]; subst.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 E[1]；替换。
- en: + apply [value__normal](Norm.html#value__normal) in H[0]...
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [value__normal](Norm.html#value__normal) 到 H[0]...
- en: + apply [value__normal](Norm.html#value__normal) in H[1]...
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [value__normal](Norm.html#value__normal) 到 H[1]...
- en: (* ST_FstPair *)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_FstPair *)
- en: '- exfalso.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '- 矛盾。'
- en: inversion H[2]; subst.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 H[2]；替换。
- en: + apply [value__normal](Norm.html#value__normal) in H...
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [value__normal](Norm.html#value__normal) 到 H...
- en: + apply [value__normal](Norm.html#value__normal) in H[0]...
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [value__normal](Norm.html#value__normal) 到 H[0]...
- en: (* ST_Snd *)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_Snd *)
- en: '- f_equal...'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '- 相等...'
- en: '- exfalso.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '- 矛盾。'
- en: inversion E[1]; subst.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 E[1]；替换。
- en: + apply [value__normal](Norm.html#value__normal) in H[0]...
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [value__normal](Norm.html#value__normal) 到 H[0]...
- en: + apply [value__normal](Norm.html#value__normal) in H[1]...
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [value__normal](Norm.html#value__normal) 到 H[1]...
- en: (* ST_SndPair *)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_SndPair *)
- en: '- exfalso.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '- 矛盾。'
- en: inversion H[2]; subst.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 H[2]；替换。
- en: + apply [value__normal](Norm.html#value__normal) in H...
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [value__normal](Norm.html#value__normal) 到 H...
- en: + apply [value__normal](Norm.html#value__normal) in H[0]...
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [value__normal](Norm.html#value__normal) 到 H[0]...
- en: '- (* ST_IfTrue *)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* ST_IfTrue *)'
- en: inversion H[3].
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 H[3]。
- en: '- (* ST_IfFalse *)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* ST_IfFalse *)'
- en: inversion H[3].
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 H[3]。
- en: (* ST_If *)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: (* ST_If *)
- en: '- inversion E[1].'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反转 E[1]。'
- en: '- inversion E[1].'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反转 E[1]。'
- en: '- f_equal...'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '- 相等...'
- en: Qed.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE10]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Definition halts  (t:tm) : Prop :=  ∃t'', t ⇒* t'' ∧  value t''.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 定义终止（t:tm）：Prop :=  ∃t'，t ⇒* t' ∧  value t'。
- en: '[PRE11]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lemma value_halts : ∀v, value v → halts v.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 value_halts : ∀v, value v → v 终止。'
- en: Proof.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros v H. unfold [halts](Norm.html#halts).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: intros v H. 展开 [halts](Norm.html#halts)。
- en: ∃v. split.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ∃v. 分割。
- en: apply [multi_refl](Smallstep.html#multi_refl).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [multi_refl](Smallstep.html#multi_refl)。
- en: assumption.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 假设。
- en: Qed.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE12]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Inductive R : ty → tm → Prop :=
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 R : ty → tm → Prop :=
- en: '| R_bool : ∀b t, has_type empty t TBool →'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '| R_bool : ∀b t，has_type empty t TBool →'
- en: halts t →
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: t 终止 →
- en: R TBool t
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: R TBool t
- en: '| R_arrow : ∀T[1] T[2] t, has_type empty t (TArrow T[1] T[2]) →'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '| R_arrow : ∀T[1] T[2] t，has_type empty t (TArrow T[1] T[2]) →'
- en: halts t →
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: t 终止 →
- en: (∀s, R T[1] s → R T[2] (tapp t s)) →
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: (∀s，R T[1] s → R T[2] (tapp t s)) →
- en: R (TArrow T[1] T[2]) t.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: R (TArrow T[1] T[2]) t。
- en: Unfortunately, Coq rejects this definition because it violates the
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，Coq 拒绝这个定义，因为它违反了
- en: '*strict positivity requirement* for inductive definitions, which says'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*严格的正性要求*对于归纳定义，它说'
- en: that the type being defined must not occur to the left of an arrow in
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被定义的类型不能出现在箭头的左边
- en: the type of a constructor argument. Here, it is the third argument to
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数参数的类型。在这里，它是第三个参数
- en: R_arrow, namely (∀ s, R T[1] s → R TS (tapp t s)), and
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R_arrow，即 (∀ s, R T[1] s → R TS (tapp t s))，以及
- en: specifically the R T[1] s part, that violates this rule.  (The
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具体来说，R T[1] s 部分，这违反了这个规则。（该
- en: outermost arrows separating the constructor arguments don't count when
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最外层的箭头分隔构造函数参数不计算
- en: applying this rule; otherwise we could never have genuinely inductive
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用此规则；否则我们永远无法真正归纳
- en: properties at all!)  The reason for the rule is that types defined
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何性质！）规则的原因是，定义的类型
- en: with non-positive recursion can be used to build non-terminating
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与非正递归一起可用于构建非终止
- en: functions, which as we know would be a disaster for Coq's logical
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数，正如我们所知，这对于 Coq 的逻辑
- en: soundness. Even though the relation we want in this case might be
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正当性。即使在这种情况下我们想要的关系可能是
- en: perfectly innocent, Coq still rejects it because it fails the
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完全无辜，Coq 仍然拒绝它，因为它违反了
- en: positivity test.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正性测试。
- en: Fortunately, it turns out that we *can* define R using a
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 幸运的是，事实证明我们*可以*使用
- en: 'Fixpoint:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Fixpoint：
- en: '[PRE13]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As immediate consequences of this definition, we have that every
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为这个定义的直接结果，我们有每个
- en: element of every set R_T halts in a value and is closed with type
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个集合 R_T 的元素在一个值中终止��且具有类型
- en: 't :'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t：
- en: '[PRE14]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we proceed to show the main result, which is that every
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们继续展示主要结果，即每个
- en: well-typed term of type T is an element of R_T.  Together with
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型为 T 的良型项是 R_T 的元素。连同
- en: R_halts, that will show that every well-typed term halts in a
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R 终止，这将展示每个良型项在
- en: value.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: value。
- en: '[PRE15]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lemma step_preserves_halting : ∀t t'', (t ⇒ t'') → (halts t ↔ halts t'').'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 step_preserves_halting : ∀t t''，(t ⇒ t'') → (t 终止 ↔ t'' 终止)。'
- en: Proof.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros t t' ST. unfold [halts](Norm.html#halts).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: intros t t' ST. 展开 [halts](Norm.html#halts).
- en: split.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 分割。
- en: '- (* -> *)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* -> *)'
- en: intros [t'' [STM V]].
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: intros [t'' [STM V]]。
- en: inversion STM; subst.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 STM；替换。
- en: exfalso. apply [value__normal](Norm.html#value__normal) in V. unfold [normal_form](Smallstep.html#normal_form)
    in V. apply V. ∃t'. auto.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 矛盾。应用[value__normal](Norm.html#value__normal)中的 V。在 V 中展开[normal_form](Smallstep.html#normal_form)。应用
    V。∃t'。自动。
- en: rewrite ([step_deterministic](Norm.html#step_deterministic) _ _ _ ST H). ∃t''.
    split; assumption.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 重写([step_deterministic](Norm.html#step_deterministic) _ _ _ ST H)。∃t''。分裂；假设。
- en: '- (* <- *)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* <- *)'
- en: intros [t'0 [STM V]].
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: intros [t'0 [STM V]]。
- en: ∃t'0. split; eauto.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ∃t'0。分裂；自动。
- en: Qed.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE16]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lemma step_preserves_R : ∀T t t'', (t ⇒ t'') → R T t → R T t''.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 step_preserves_R : ∀T t t''，(t ⇒ t'') → R T t → R T t''。'
- en: Proof.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: induction T;  intros t t' E Rt; unfold [R](Norm.html#R); fold [R](Norm.html#R);
    unfold [R](Norm.html#R) in Rt; fold [R](Norm.html#R) in Rt;
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 对 T 进行归纳；intros t t' E Rt；展开[R](Norm.html#R)；折叠[R](Norm.html#R)；在 Rt 中展开[R](Norm.html#R)；在
    Rt 中折叠[R](Norm.html#R)；
- en: destruct Rt as [typable_empty_t [halts_t RRt]].
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Rt 分解为[typable_empty_t [halts_t RRt]]。
- en: (* TBool *)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: (* TBool *)
- en: split. eapply [preservation](Norm.html#preservation); eauto.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 分裂。应用[preservation](Norm.html#preservation)；自动。
- en: split. apply ([step_preserves_halting](Norm.html#step_preserves_halting) _ _
    E); eauto.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 分裂。应用([step_preserves_halting](Norm.html#step_preserves_halting) _ _ E)；自动。
- en: auto.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: (* TArrow *)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: (* TArrow *)
- en: split. eapply [preservation](Norm.html#preservation); eauto.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 分裂。应用[preservation](Norm.html#preservation)；自动。
- en: split. apply ([step_preserves_halting](Norm.html#step_preserves_halting) _ _
    E); eauto.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 分裂。应用([step_preserves_halting](Norm.html#step_preserves_halting) _ _ E)；自动。
- en: intros.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: intros。
- en: eapply IHT2.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHT2。
- en: apply [ST_App1](Norm.html#ST_App1). apply E.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[ST_App1](Norm.html#ST_App1)。应用 E。
- en: apply RRt; auto.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 RRt；自动。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处 *) 已留空。
- en: '[PRE17]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lemma multistep_preserves_R : ∀T t t'','
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 multistep_preserves_R : ∀T t t''，'
- en: (t ⇒* t') → R T t → R T t'.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: (t ⇒* t') → R T t → R T t'。
- en: Proof.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros T t t' STM; induction STM; intros.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: intros T t t' STM；对 STM 进行归纳；intros。
- en: assumption.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 假设。
- en: apply IHSTM. eapply [step_preserves_R](Norm.html#step_preserves_R). apply H.
    assumption.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHSTM。应用[step_preserves_R](Norm.html#step_preserves_R)。应用 H。假设。
- en: Qed.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE18]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lemma step_preserves_R'' : ∀T t t'','
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 step_preserves_R'' : ∀T t t''，'
- en: has_type empty t T → (t ⇒ t') → R T t' → R T t.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: has_type empty t T → (t ⇒ t') → R T t' → R T t。
- en: Proof.
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处 *) 已留空。
- en: 'Lemma multistep_preserves_R'' : ∀T t t'','
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 multistep_preserves_R'' : ∀T t t''，'
- en: has_type empty t T → (t ⇒* t') → R T t' → R T t.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: has_type empty t T → (t ⇒* t') → R T t' → R T t。
- en: Proof.
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros T t t' HT STM.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: intros T t t' HT STM。
- en: induction STM; intros.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 对 STM 进行归纳；intros。
- en: assumption.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 假设。
- en: eapply [step_preserves_R'](Norm.html#step_preserves_R'). assumption. apply H.
    apply IHSTM.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[step_preserves_R'](Norm.html#step_preserves_R')。假设。应用 H。应用 IHSTM。
- en: eapply [preservation](Norm.html#preservation);  eauto. auto.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[preservation](Norm.html#preservation)；自动。自动。
- en: Qed.
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE19]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Multisubstitutions, Multi-Extensions, and Instantiations
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多次替换，多次扩展和实例化
- en: However, before we can proceed to formalize the statement and
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在我们继续正式陈述之前
- en: proof of the lemma, we'll need to build some (rather tedious)
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明引理，我们需要构建一些（相当乏味的）
- en: machinery to deal with the fact that we are performing *multiple*
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理我们正在执行*多次*
- en: substitutions on term t and *multiple* extensions of the typing
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对项 t 进行替换和*多次*扩展的
- en: context.  In particular, we must be precise about the order in which
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上下文。特别是，我们必须准确说明
- en: the substitutions occur and how they act on each other.  Often these
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换发生以及它们如何相互作用。通常这些
- en: details are simply elided in informal paper proofs, but of course Coq
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在非正式的论文证明中，细节通常被省略，但当然 Coq
- en: won't let us do that. Since here we are substituting closed terms, we
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不会让我们这样做。因为这里我们正在替换闭合项，我们
- en: don't need to worry about how one substitution might affect the term
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不需要担心一个替换如何影响项
- en: put in place by another.  But we still do need to worry about the
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由另一个放置。但我们仍然需要担心
- en: '*order* of substitutions, because it is quite possible for the same'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*替换的顺序*，因为同一个'
- en: identifier to appear multiple times among the x[1],...xn with
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标识符在 x[1],...xn 中多次出现
- en: different associated vi and Ti.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同的相关 vi 和 Ti。
- en: To make everything precise, we will assume that environments are
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使一切准确，我们将假设环境是
- en: extended from left to right, and multiple substitutions are performed
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从左到右扩展，并执行多次替换
- en: from right to left.  To see that this is consistent, suppose we have
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从右到左。为了看到这是一致的，假设我们有
- en: an environment written as ...,y:bool,...,y:nat,...  and a
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个环境写为...,y:bool,...,y:nat,... 和一个
- en: corresponding term substitution written as ...[y:=(tbool true)]...[y:=(tnat
    3)]...t.  Since environments are extended from
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对应项替换写为...[y:=(tbool true)]...[y:=(tnat 3)]...t。由于环境是从
- en: left to right, the binding y:nat hides the binding y:bool; since
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从左到右，绑定 y:nat 隐藏了绑定 y:bool；因为
- en: substitutions are performed right to left, we do the substitution
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换是从右向左执行的，我们对替换
- en: y:=(tnat 3) first, so that the substitution y:=(tbool true) has
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先执行 y:=(tnat 3)，因此替换 y:=(tbool true) 无效。
- en: no effect. Substitution thus correctly preserves the type of the term.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有影响。因此，替换正确地保留了术语的类型。
- en: With these points in mind, the following definitions should make sense.
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 牢记这些要点，以下定义应该就会有意义。
- en: A *multisubstitution* is the result of applying a list of
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*多重替换* 是应用列表的结果'
- en: substitutions, which we call an *environment*.
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 称之为 *环境* 的替换。
- en: '[PRE20]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We need similar machinery to talk about repeated extension of a
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要类似的机制来讨论重复扩展
- en: typing context using a list of (identifier, type) pairs, which we
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用一个 (标识符，类型) 对列表构建的类型上下文，我们
- en: call a *type assignment*.
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 称为 *类型赋值*。
- en: '[PRE21]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will need some simple operations that work uniformly on
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要一些简单的操作，它们在
- en: environments and type assigments
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 环境和类型赋值
- en: '[PRE22]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An *instantiation* combines a type assignment and a value
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*实例化* 结合了类型赋值和值'
- en: environment with the same domains, where corresponding elements are
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有相同域的环境，在对应元素上
- en: in R.
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 R 中。
- en: '[PRE23]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We now proceed to prove various properties of these definitions.
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们继续证明这些定义的各种属性。
- en: '[PRE24]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lemma vacuous_substitution : ∀ t x,'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma vacuous_substitution : ∀ t x,'
- en: ¬ appears_free_in x t  →
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 若 x 不出现在 t 中 →
- en: ∀t', [x:=t']t = t.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: ∀t', [x:=t']t = t.
- en: Proof with eauto.
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明，使用 eauto。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容 *) 已略过。
- en: 'Lemma subst_closed: ∀t,'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma subst_closed: ∀t,'
- en: closed t  →
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: closed t  →
- en: ∀x t', [x:=t']t = t.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: ∀x t', [x:=t']t = t.
- en: Proof.
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros. apply [vacuous_substitution](Norm.html#vacuous_substitution). apply
    H. Qed.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: intros。应用 [vacuous_substitution](Norm.html#vacuous_substitution)。应用 H。证毕。
- en: 'Lemma subst_not_afi : ∀t x v,'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma subst_not_afi : ∀t x v,'
- en: closed v →  ¬ appears_free_in x ([x:=v]t).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: closed v →  x 不出现在 ([x:=v]t) 中。
- en: Proof with eauto. (* rather slow this way *)
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明，使用 eauto。 (* 这种方式相对较慢 *)
- en: unfold [closed](Norm.html#closed), [not](http://coq.inria.fr/library/Coq.Init.Logic.html#not).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [closed](Norm.html#closed)，[not](http://coq.inria.fr/library/Coq.Init.Logic.html#not)。
- en: induction t; intros x v P A; simpl in A.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t 进行归纳；对 x v P A 进行引入；A 简化。
- en: '- (* tvar *)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tvar *)'
- en: destruct ([beq_idP](Maps.html#beq_idP) x i)...
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x i)...
- en: inversion A; subst. auto.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 对 A 进行反演；替换。自动。
- en: '- (* tapp *)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tapp *)'
- en: inversion A; subst...
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 对 A 进行反演；替换...
- en: '- (* tabs *)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* 标签 *)'
- en: destruct ([beq_idP](Maps.html#beq_idP) x i)...
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x i)...
- en: + inversion A; subst...
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: + 对 A 进行反演；替换...
- en: + inversion A; subst...
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: + 对 A 进行反演；替换...
- en: '- (* tpair *)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tpair *)'
- en: inversion A; subst...
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对 A 进行反演；替换...
- en: '- (* tfst *)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tfst *)'
- en: inversion A; subst...
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 对 A 进行反演；替换...
- en: '- (* tsnd *)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tsnd *)'
- en: inversion A; subst...
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 对 A 进行反演；替换...
- en: '- (* ttrue *)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* ttrue *)'
- en: inversion A.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 对 A 进行反演。
- en: '- (* tfalse *)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tfalse *)'
- en: inversion A.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 对 A 进行反演。
- en: '- (* tif *)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tif *)'
- en: inversion A; subst...
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 对 A 进行反演；替换...
- en: Qed.
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证毕。
- en: 'Lemma duplicate_subst : ∀t'' x t v,'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma duplicate_subst : ∀t'' x t v,'
- en: closed v → [x:=t]([x:=v]t') = [x:=v]t'.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: closed v → [x:=t]([x:=v]t') = [x:=v]t'。
- en: Proof.
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros. eapply [vacuous_substitution](Norm.html#vacuous_substitution). apply
    [subst_not_afi](Norm.html#subst_not_afi). auto.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: intros。应用 [vacuous_substitution](Norm.html#vacuous_substitution)。应用 [subst_not_afi](Norm.html#subst_not_afi)。自动。
- en: Qed.
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证毕。
- en: 'Lemma swap_subst : ∀t x x[1] v v[1],'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma swap_subst : ∀t x x[1] v v[1],'
- en: x ≠ x[1] →
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: x ≠ x[1] →
- en: closed v → closed v[1] →
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: closed v → closed v[1] →
- en: '[x[1]:=v[1]]([x:=v]t) = [x:=v]([x[1]:=v[1]]t).'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[x[1]:=v[1]]([x:=v]t) = [x:=v]([x[1]:=v[1]]t).'
- en: Proof with eauto.
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明，使用 eauto。
- en: induction t; intros; simpl.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t 进行归纳；引入；简化。
- en: '- (* tvar *)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tvar *)'
- en: destruct ([beq_idP](Maps.html#beq_idP) x i); destruct ([beq_idP](Maps.html#beq_idP)
    x[1] i).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x i); destruct ([beq_idP](Maps.html#beq_idP)
    x[1] i).
- en: + subst. exfalso...
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: + 替换。矛盾...
- en: + subst. simpl. rewrite ← [beq_id_refl](Maps.html#beq_id_refl). apply [subst_closed](Norm.html#subst_closed)...
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: + 替换。简化。重写 ← [beq_id_refl](Maps.html#beq_id_refl)。应用 [subst_closed](Norm.html#subst_closed)...
- en: + subst. simpl. rewrite ← [beq_id_refl](Maps.html#beq_id_refl). rewrite [subst_closed](Norm.html#subst_closed)...
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: + 替换。简化。重写 ← [beq_id_refl](Maps.html#beq_id_refl)。重写 [subst_closed](Norm.html#subst_closed)...
- en: + simpl. rewrite [false_beq_id](Maps.html#false_beq_id)... rewrite [false_beq_id](Maps.html#false_beq_id)...
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: + 简化。重写 [false_beq_id](Maps.html#false_beq_id)... 重写 [false_beq_id](Maps.html#false_beq_id)...
- en: (* FILL IN HERE *) Admitted.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容 *) 已略过。
- en: '[PRE25]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lemma msubst_closed: ∀t, closed t → ∀ss, msubst ss t = t.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma msubst_closed: ∀t, closed t → ∀ss, msubst ss t = t.'
- en: Proof.
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: induction ss.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 对 ss 进行归纳。
- en: reflexivity.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 自反性。
- en: destruct a. simpl. rewrite [subst_closed](Norm.html#subst_closed); assumption.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: destruct a. 简化。重写 [subst_closed](Norm.html#subst_closed); 假设成立。
- en: Qed.
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证毕。
- en: '[PRE26]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Fixpoint closed_env (env:env) {struct env} :=
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: Fixpoint closed_env (env:env) {struct env} :=
- en: match env with
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 env 。
- en: '| nil ⇒ True'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil ⇒ True'
- en: '| (x,t)::env'' ⇒ closed t ∧ closed_env env'''
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '| (x,t)::env'' ⇒ closed t ∧ closed_env env'''
- en: end.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE27]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lemma subst_msubst: ∀env x v t, closed v → closed_env env →'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma subst_msubst: ∀env x v t, 闭合 v → 闭合环境 env →'
- en: msubst env ([x:=v]t) = [x:=v](msubst (drop x env) t).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: msubst env ([x:=v]t) = [x:=v](msubst (drop x env) t)。
- en: Proof.
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof.
- en: induction env0; intros; auto.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 env0；引入；自动。
- en: destruct a. simpl.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 a。简化。
- en: inversion H[0]. fold [closed_env](Norm.html#closed_env) in H[2].
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 推导 H[0]。在 H[2] 中重写 [closed_env](Norm.html#closed_env)。
- en: destruct ([beq_idP](Maps.html#beq_idP) i x).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_idP](Maps.html#beq_idP) i x)。
- en: '- subst. rewrite [duplicate_subst](Norm.html#duplicate_subst); auto.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '- 替换。重写 [duplicate_subst](Norm.html#duplicate_subst)；自动。'
- en: '- simpl. rewrite [swap_subst](Norm.html#swap_subst); eauto.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '- 简化。重写 [swap_subst](Norm.html#swap_subst)；自动。'
- en: Qed.
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed。
- en: 'Lemma msubst_var:  ∀ss x, closed_env ss →'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma msubst_var:  ∀ss x, 闭合环境 ss →'
- en: msubst ss (tvar x) =
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: msubst ss (tvar x) =
- en: match lookup x ss with
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配查找 x ss。
- en: '| Some t ⇒ t'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '| Some t ⇒ t'
- en: '| None ⇒ tvar x'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '| None ⇒ tvar x'
- en: end.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: end。
- en: Proof.
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof.
- en: induction ss; intros.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 ss；引入。
- en: reflexivity.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 反射性。
- en: destruct a.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 a。
- en: simpl. destruct ([beq_id](Maps.html#beq_id) i x).
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。分解 ([beq_id](Maps.html#beq_id) i x)。
- en: apply [msubst_closed](Norm.html#msubst_closed). inversion H; auto.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [msubst_closed](Norm.html#msubst_closed)。推导 H；自动。
- en: apply IHss. inversion H; auto.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHss。推导 H；自动。
- en: Qed.
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma msubst_abs: ∀ss x T t,'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma msubst_abs: ∀ss x T t,'
- en: msubst ss (tabs x T t) = tabs x T (msubst (drop x ss) t).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: msubst ss (tabs x T t) = tabs x T (msubst (drop x ss) t)。
- en: Proof.
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof。
- en: induction ss; intros.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 ss；引入。
- en: reflexivity.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 反射性。
- en: destruct a.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 a。
- en: simpl. destruct ([beq_id](Maps.html#beq_id) i x); simpl; auto.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。分解 ([beq_id](Maps.html#beq_id) i x)；简化；自动。
- en: Qed.
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed。
- en: 'Lemma msubst_app : ∀ss t[1] t[2], msubst ss (tapp t[1] t[2]) = tapp (msubst
    ss t[1]) (msubst ss t[2]).'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma msubst_app : ∀ss t[1] t[2], msubst ss (tapp t[1] t[2]) = tapp (msubst
    ss t[1]) (msubst ss t[2]).'
- en: Proof.
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof。
- en: induction ss; intros.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 ss；引入。
- en: reflexivity.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 自反性。
- en: destruct a.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 a。
- en: simpl. rewrite ← IHss. auto.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。重写 ← IHss。自动。
- en: Qed.
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: '[PRE28]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: (* FILL IN HERE *)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容 *)
- en: '[PRE29]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lemma mupdate_lookup : ∀(c : tass) (x:id),'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma mupdate_lookup : ∀(c : tass) (x:id),'
- en: lookup x c = (mupdate empty c) x.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 x c = (mupdate empty c) x。
- en: Proof.
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof.
- en: induction c; intros.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 c；引入。
- en: auto.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: destruct a. unfold [lookup](Norm.html#lookup), [mupdate](Norm.html#mupdate),
    [update](Maps.html#update), [t_update](Maps.html#t_update). destruct ([beq_id](Maps.html#beq_id)
    i x); auto.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 a。展开 [lookup](Norm.html#lookup)，[mupdate](Norm.html#mupdate)，[update](Maps.html#update)，[t_update](Maps.html#t_update)。分解
    ([beq_id](Maps.html#beq_id) i x)；自动。
- en: Qed.
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma mupdate_drop : ∀(c: tass) Γ x x'','
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma mupdate_drop : ∀(c: tass) Γ x x''，'
- en: mupdate Γ (drop x c) x'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: mupdate Γ (drop x c) x'。
- en: = if beq_id x x' then Γ x' else mupdate Γ c x'.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: = 若 beq_id x x' 则 Γ x' 否则 mupdate Γ c x'。
- en: Proof.
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof。
- en: induction c; intros.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 c；引入。
- en: '- destruct ([beq_idP](Maps.html#beq_idP) x x''); auto.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '- 分解 ([beq_idP](Maps.html#beq_idP) x x'')；自动。'
- en: '- destruct a. simpl.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '- 分解 a。简化。'
- en: destruct ([beq_idP](Maps.html#beq_idP) i x).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_idP](Maps.html#beq_idP) i x)。
- en: + subst. rewrite IHc.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: + 替换。重写 IHc。
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). destruct
    ([beq_idP](Maps.html#beq_idP) x x'); auto.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [update](Maps.html#update)，[t_update](Maps.html#t_update)。分解 ([beq_idP](Maps.html#beq_idP)
    x x')；自动。
- en: + simpl. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
    destruct ([beq_idP](Maps.html#beq_idP) i x'); auto.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: + 简化。展开 [update](Maps.html#update)，[t_update](Maps.html#t_update)。分解 ([beq_idP](Maps.html#beq_idP)
    i x')；自动。
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id); congruence.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。重写 [false_beq_id](Maps.html#false_beq_id)；一致性。
- en: Qed.
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE30]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lemma instantiation_domains_match: ∀{c} {e},'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma instantiation_domains_match: ∀{c} {e},'
- en: instantiation c e →
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 c e →
- en: ∀{x} {T},
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ∀{x} {T}，
- en: lookup x c = Some T → ∃t, lookup x e = Some t.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 x c = Some T → ∃t, 查找 x e = Some t。
- en: Proof.
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof.
- en: intros c e V. induction V; intros x[0] T[0] C.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 c e V。归纳 V；引入 x[0] T[0] C。
- en: solve_by_invert.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 解决反转。
- en: simpl in *.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。
- en: destruct ([beq_id](Maps.html#beq_id) x x[0]); eauto.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_id](Maps.html#beq_id) x x[0])；自动。
- en: Qed.
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma instantiation_env_closed : ∀c e,'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma instantiation_env_closed : ∀c e，'
- en: instantiation c e → closed_env e.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 c e → 闭合环境 e.
- en: Proof.
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof.
- en: intros c e V; induction V; intros.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 c e V；归纳 V；引入。
- en: econstructor.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 构造者。
- en: unfold [closed_env](Norm.html#closed_env). fold [closed_env](Norm.html#closed_env).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [closed_env](Norm.html#closed_env)。重写 [closed_env](Norm.html#closed_env)。
- en: split. eapply [typable_empty__closed](Norm.html#typable_empty__closed). eapply
    [R_typable_empty](Norm.html#R_typable_empty). eauto.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 分割。应用 [typable_empty__closed](Norm.html#typable_empty__closed)。应用 [R_typable_empty](Norm.html#R_typable_empty)。自动。
- en: auto.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: Qed.
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma instantiation_R : ∀c e,'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma instantiation_R : ∀c e，'
- en: instantiation c e →
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 c e →
- en: ∀x t T,
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: ∀x t T，
- en: lookup x c = Some T →
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 x c = Some T →
- en: lookup x e = Some t → R T t.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 x e = Some t → R T t。
- en: Proof.
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof.
- en: intros c e V. induction V; intros x' t' T' G E.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 c e V。归纳 V；引入 x' t' T' G E。
- en: solve_by_invert.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 解决反转。
- en: unfold [lookup](Norm.html#lookup) in *. destruct ([beq_id](Maps.html#beq_id)
    x x').
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [lookup](Norm.html#lookup)。分解 ([beq_id](Maps.html#beq_id) x x')。
- en: inversion G; inversion E; subst. auto.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 推导 G；推导 E；替换。自动。
- en: eauto.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: Qed.
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed。
- en: 'Lemma instantiation_drop : ∀c env,'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 instantiation_drop: ∀c env，'
- en: instantiation c env →
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 c env →
- en: ∀x, instantiation (drop x c) (drop x env).
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: ∀x，实例化 (drop x c) (drop x env)。
- en: Proof.
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros c e V. induction V.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: intros c e V。对 V 进行归纳。
- en: intros. simpl. constructor.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: intros。简化。构造。
- en: intros. unfold [drop](Norm.html#drop). destruct ([beq_id](Maps.html#beq_id)
    x x[0]); auto. constructor; eauto.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: intros。展开 [drop](Norm.html#drop)。解构 ([beq_id](Maps.html#beq_id) x x[0]); 自动。构造;
    自动。
- en: Qed.
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE31]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Lemma multistep_App2 : ∀v t t'','
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 multistep_App2: ∀v t t''，'
- en: value v → (t ⇒* t') → (tapp v t) ⇒* (tapp v t').
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v → (t ⇒* t') → (tapp v t) ⇒* (tapp v t')。
- en: Proof.
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros v t t' V STM. induction STM.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: intros v t t' V STM。对 STM 进行归纳。
- en: apply [multi_refl](Smallstep.html#multi_refl).
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [multi_refl](Smallstep.html#multi_refl)。
- en: eapply [multi_step](Smallstep.html#multi_step).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [multi_step](Smallstep.html#multi_step)。
- en: apply [ST_App2](Norm.html#ST_App2); eauto. auto.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [ST_App2](Norm.html#ST_App2); 自动。自动。
- en: Qed.
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: (* FILL IN HERE *)
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容 *)
- en: '[PRE32]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lemma msubst_preserves_typing : ∀c e,'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 msubst_preserves_typing: ∀c e,'
- en: instantiation c e →
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 c e →
- en: ∀Γ t S, has_type (mupdate Γ c) t S →
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: ∀Γ t S，有类型 (mupdate Γ c) t S →
- en: has_type Γ (msubst e t) S.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 有类型 Γ (msubst e t) S。
- en: Proof.
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: induction 1; intros.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 对 1 进行归纳；intros。
- en: simpl in H. simpl. auto.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 简化 H。简化。自动。
- en: simpl in H[2]. simpl.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: H[2] 简化。简化。
- en: apply IHinstantiation.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHinstantiation。
- en: eapply [substitution_preserves_typing](Norm.html#substitution_preserves_typing);
    eauto.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [substitution_preserves_typing](Norm.html#substitution_preserves_typing);
    自动。
- en: apply ([R_typable_empty](Norm.html#R_typable_empty) H[0]).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 ([R_typable_empty](Norm.html#R_typable_empty) H[0])。
- en: Qed.
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE33]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lemma msubst_R : ∀c env t T,'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 msubst_R: ∀c env t T，'
- en: has_type (mupdate empty c) t T →
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 有类型的 (mupdate empty c) t T →
- en: instantiation c env →
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 c env →
- en: R T (msubst env t).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: R T (msubst env t)。
- en: Proof.
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros c env0 t T HT V.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: intros c env0 t T HT V。
- en: generalize dependent env0.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 推广 env0。
- en: (* We need to generalize the hypothesis a bit before setting up the induction. *)
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: (* 我们需要在进行归纳之前稍微概括一下假设。 *)
- en: remember ([mupdate](Norm.html#mupdate) [empty](Maps.html#empty) c) as Γ.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 ([mupdate](Norm.html#mupdate) [empty](Maps.html#empty) c) 为 Γ。
- en: assert (∀x, Γ [x](Norm.html#x) = [lookup](Norm.html#lookup) [x](Norm.html#x)
    c).
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 断言 (∀x, Γ [x](Norm.html#x) = [lookup](Norm.html#lookup) [x](Norm.html#x) c)。
- en: intros. rewrite HeqGamma. rewrite [mupdate_lookup](Norm.html#mupdate_lookup).
    auto.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: intros。重写 HeqGamma。重写 [mupdate_lookup](Norm.html#mupdate_lookup)。自动。
- en: clear HeqGamma.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 清除 HeqGamma。
- en: generalize dependent c.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 推广 c。
- en: induction HT; intros.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HT 进行归纳；intros。
- en: '- (* T_Var *)'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Var *)'
- en: rewrite H[0] in H. destruct ([instantiation_domains_match](Norm.html#instantiation_domains_match)
    V H) as [t P].
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H 中重写 H[0]。将 ([instantiation_domains_match](Norm.html#instantiation_domains_match)
    V H) 解构为 [t P]。
- en: eapply [instantiation_R](Norm.html#instantiation_R); eauto.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [instantiation_R](Norm.html#instantiation_R); 自动。
- en: rewrite [msubst_var](Norm.html#msubst_var). rewrite P. auto. eapply [instantiation_env_closed](Norm.html#instantiation_env_closed);
    eauto.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 [msubst_var](Norm.html#msubst_var)。重写 P。自动。应用 [instantiation_env_closed](Norm.html#instantiation_env_closed);
    自动。
- en: '- (* T_Abs *)'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: rewrite [msubst_abs](Norm.html#msubst_abs).
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 [msubst_abs](Norm.html#msubst_abs)。
- en: (* We'll need variants of the following fact several times, so its simplest to
           establish it just once. *)
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: (* 我们将需要以下事实的变体多次，因此最好只建立一次。 *)
- en: 'assert (WT: [has_type](Norm.html#has_type) [empty](Maps.html#empty) ([tabs](Norm.html#tabs)
    x T[11] ([msubst](Norm.html#msubst) ([drop](Norm.html#drop) x env0) t[12])) ([TArrow](Norm.html#TArrow)
    T[11] T[12])).'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '断言 (WT: [has_type](Norm.html#has_type) [empty](Maps.html#empty) ([tabs](Norm.html#tabs)
    x T[11] ([msubst](Norm.html#msubst) ([drop](Norm.html#drop) x env0) t[12])) ([TArrow](Norm.html#TArrow)
    T[11] T[12])).'
- en: '{ eapply [T_Abs](Norm.html#T_Abs). eapply [msubst_preserves_typing](Norm.html#msubst_preserves_typing).'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 应用 [T_Abs](Norm.html#T_Abs)。应用 [msubst_preserves_typing](Norm.html#msubst_preserves_typing)。'
- en: '{ eapply [instantiation_drop](Norm.html#instantiation_drop); eauto. }'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 应用 [instantiation_drop](Norm.html#instantiation_drop); 自动。 }'
- en: eapply [context_invariance](Norm.html#context_invariance).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [context_invariance](Norm.html#context_invariance)。
- en: '{ apply HT. }'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 应用 HT。 }'
- en: intros.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: intros。
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). rewrite [mupdate_drop](Norm.html#mupdate_drop).
    destruct ([beq_idP](Maps.html#beq_idP) x x[0]).
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [update](Maps.html#update), [t_update](Maps.html#t_update)。重写 [mupdate_drop](Norm.html#mupdate_drop)。解构
    ([beq_idP](Maps.html#beq_idP) x x[0])。
- en: + auto.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: + 自动。
- en: + rewrite H.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: + 重写 H。
- en: clear - c n. induction c.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 清除 - c n。对 c 进行归纳。
- en: simpl. rewrite [false_beq_id](Maps.html#false_beq_id); auto.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。重写 [false_beq_id](Maps.html#false_beq_id); 自动。
- en: simpl. destruct a. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。解构 a。展开 [update](Maps.html#update), [t_update](Maps.html#t_update)。
- en: destruct ([beq_id](Maps.html#beq_id) i x[0]); auto. }
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 解构 ([beq_id](Maps.html#beq_id) i x[0]); 自动。}
- en: unfold [R](Norm.html#R). fold [R](Norm.html#R). split.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [R](Norm.html#R)。折叠 [R](Norm.html#R)。分割。
- en: auto.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: split. apply [value_halts](Norm.html#value_halts). apply [v_abs](Norm.html#v_abs).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 分解。应用[value_halts](Norm.html#value_halts)。应用[v_abs](Norm.html#v_abs)。
- en: intros.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 引入。
- en: destruct ([R_halts](Norm.html#R_halts) H[0]) as [v [P Q]].
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 将([R_halts](Norm.html#R_halts) H[0])分解为[v [P Q]]。
- en: pose proof ([multistep_preserves_R](Norm.html#multistep_preserves_R) _ _ _ P
    H[0]).
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 引入证明([multistep_preserves_R](Norm.html#multistep_preserves_R) _ _ _ P H[0])。
- en: apply [multistep_preserves_R'](Norm.html#multistep_preserves_R') with ([msubst](Norm.html#msubst)
    ((x,v)::env0) t[12]).
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[multistep_preserves_R'](Norm.html#multistep_preserves_R')，使用([msubst](Norm.html#msubst)
    ((x,v)::env0) t[12])。
- en: eapply [T_App](Norm.html#T_App). eauto.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[T_App](Norm.html#T_App)。自动。
- en: apply [R_typable_empty](Norm.html#R_typable_empty); auto.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[R_typable_empty](Norm.html#R_typable_empty); 自动。
- en: eapply [multi_trans](Smallstep.html#multi_trans). eapply [multistep_App2](Norm.html#multistep_App2);
    eauto.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[multi_trans](Smallstep.html#multi_trans)。应用[multistep_App2](Norm.html#multistep_App2);
    自动。
- en: eapply [multi_R](Smallstep.html#multi_R).
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[multi_R](Smallstep.html#multi_R)。
- en: simpl. rewrite [subst_msubst](Norm.html#subst_msubst).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。重写[subst_msubst](Norm.html#subst_msubst)。
- en: eapply [ST_AppAbs](Norm.html#ST_AppAbs); eauto.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[ST_AppAbs](Norm.html#ST_AppAbs); 自动。
- en: eapply [typable_empty__closed](Norm.html#typable_empty__closed).
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[typable_empty__closed](Norm.html#typable_empty__closed)。
- en: apply ([R_typable_empty](Norm.html#R_typable_empty) H[1]).
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 应用([R_typable_empty](Norm.html#R_typable_empty) H[1])。
- en: eapply [instantiation_env_closed](Norm.html#instantiation_env_closed); eauto.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[instantiation_env_closed](Norm.html#instantiation_env_closed); 自动。
- en: eapply (IHHT ((x,T[11])::c)).
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 应用(IHHT ((x,T[11])::c))。
- en: intros. unfold [update](Maps.html#update), [t_update](Maps.html#t_update), [lookup](Norm.html#lookup).
    destruct ([beq_id](Maps.html#beq_id) x x[0]); auto.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 引入。展开[update](Maps.html#update)，[t_update](Maps.html#t_update)，[lookup](Norm.html#lookup)。分解([beq_id](Maps.html#beq_id)
    x x[0]); 自动。
- en: constructor; auto.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 构造者; 自动。
- en: '- (* T_App *)'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: rewrite [msubst_app](Norm.html#msubst_app).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 重写[msubst_app](Norm.html#msubst_app)。
- en: destruct (IHHT1 c H env0 V) as [_ [_ P[1]]].
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 将IHHT1 c H env0 V的证明分解为[_ [_ P[1]]]。
- en: pose proof (IHHT2 c H env0 V) as P[2]. fold [R](Norm.html#R) in P[1]. auto.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 将IHHT2 c H env0 V的证明命名为P[2]。在P[1]中折叠[R](Norm.html#R)。自动。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *) 已承认。
- en: '[PRE34]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Theorem normalization : ∀t T, has_type empty t T → halts t.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 定理规范化：∀t T，has_type empty t T → halts t。
- en: Proof.
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 引入。
- en: replace t with ([msubst](Norm.html#msubst) [nil](http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil)
    t) by reflexivity.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 用([msubst](Norm.html#msubst) [nil](http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil)
    t)替换t，通过反射性。
- en: apply (@[R_halts](Norm.html#R_halts) T).
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 应用(@[R_halts](Norm.html#R_halts) T)。
- en: apply ([msubst_R](Norm.html#msubst_R) [nil](http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil));
    eauto.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 应用([msubst_R](Norm.html#msubst_R) [nil](http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil));
    自动。
- en: eapply [V_nil](Norm.html#V_nil).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 应用[V_nil](Norm.html#V_nil)。
- en: Qed.
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE35]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
