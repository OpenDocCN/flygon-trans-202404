- en: 'Reading 26: Little Languages'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读26：小语言
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 免于错误 | 易于理解 | 为变化做好准备 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确且未来未知时也正确。 | 与未来程序员清晰沟通，包括未来的自己。 | 设计以适应变化而无需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: 'In this reading we will begin to explore the design of a **little language**
    for constructing and manipulating music. Here’s the bottom line: when you need
    to solve a problem, instead of writing a *program* to solve just that one problem,
    build a *language* that can solve a range of related problems.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将开始探讨用于构建和操作音乐的**小语言**的设计。关键是：当你需要解决一个问题时，不要编写一个仅解决这一个问题的*程序*，而是构建一个可以解决一系列相关问题的*语言*。
- en: The goal for this reading is to introduce the idea of **representing code as
    data** and familiarize you with an initial version of the **music language**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的目标是介绍**将代码表示为数据**的概念，并让您熟悉**音乐语言**的初始版本。
- en: Representing code as data
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码表示为数据
- en: 'Recall the [`Formula` datatype from *Recursive Data Types*](../16-recursive-data-types/recursive/#another_example_boolean_formulas):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[*递归数据类型*中的`Formula`数据类型](../16-recursive-data-types/recursive/#another_example_boolean_formulas)：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We used instances of `Formula` to take propositional logic formulas, e.g. ***(p
    ∨ q) ∧ (¬p ∨ r)***, and represent them in a data structure, e.g.:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Formula`的实例来接受命题逻辑公式，例如***(p ∨ q) ∧ (¬p ∨ r)***，并将其表示为数据结构，例如：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the parlance of grammars and parsers, formulas are a *language*, and `Formula`
    is an [*abstract syntax tree*](../18-parser-generators/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法和解析器的术语中，公式是一种*语言*，而`Formula`是一个[*抽象语法树*](../18-parser-generators/)。
- en: 'But why did we define a `Formula` type? Java already has a way to represent
    expressions of Boolean variables with *logical and*, *or*, and *not*. For example,
    given `boolean` variables `p`, `q`, and `r`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么我们要定义一个`Formula`类型呢？Java已经有一种表示布尔变量表达式的方式，包括*逻辑与*、*或*和*非*。例如，给定`boolean`变量`p`、`q`和`r`：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Done!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: The answer is that the Java code expression `(p || q) && ((!p) || r)` is evaluated
    as soon as we encounter it in our running program. The `Formula` value `And(Or(...),
    Or(...))` is a **first-class value** that can be stored, passed and returned from
    one method to another, manipulated, and evaluated now or later (or more than once)
    as needed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在运行程序中遇到Java代码表达式`(p || q) && ((!p) || r)`时，该表达式会立即被求值。`Formula`值`And(Or(...),
    Or(...))`是一个**一等值**，可以被存储、传递和从一个方法返回到另一个方法，可以根据需要进行操作和立即或以后（或多次）进行评估。
- en: The `Formula` type is an example of **representing code as data**, and we’ve
    seen many more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Formula`类型是**将代码表示为数据**的一个示例，我们已经看到了许多其他示例。'
- en: 'Consider this [functional object](../24-map-filter-reduce/#first-class_functions_in_java):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个[函数对象](../24-map-filter-reduce/#first-class_functions_in_java)：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An instance of `VariableNameComparator` is a value that can be passed around,
    returned, and stored. But at any time, the function that it represents can be
    invoked by calling its `compare` method with a couple of `Variable` arguments:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`VariableNameComparator`的一个实例是一个可以传递、返回和存储的值。但是随时可以通过调用其`compare`方法并提供一对`Variable`参数来调用它所代表的函数：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lambda expressions allow us to create functional objects with a compact syntax:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式允许我们使用简洁的语法创建函数对象：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building languages to solve problems
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建用于解决问题的语言
- en: 'When we define an [abstract data type](../12-abstract-data-types/), we’re extending
    the universe of built-in types provided by Java to include a new type, with new
    operations, appropriate to our problem domain. This new type is like a new language:
    a new set of nouns (values) and verbs (operations) we can manipulate. Of course,
    those nouns and verbs are abstractions built on top the existing nouns and verbs
    which were themselves already abstractions.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个[抽象数据类型](../12-abstract-data-types/)时，我们正在扩展Java提供的内置类型的范围，包括一个新类型，具有适用于我们问题域的新操作。这种新类型就像是一种新语言：一组新的名词（值）和动词（操作）可以操作。当然，这些名词和动词是建立在现有名词和动词之上的抽象。
- en: A *language* has greater flexibility than a mere *program*, because we can use
    a language to solve a large class of related problems, instead of just a single
    problem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*语言*比单纯的*程序*具有更大的灵活性，因为我们可以使用语言来解决一大类相关问题，而不仅仅是一个单一问题。'
- en: That’s the difference between writing `(p || q) && ((!p) || r)` and devising
    a `Formula` type to represent the semantically-equivalent Boolean formula.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是写 `(p || q) && ((!p) || r)` 与设计 `Formula` 类型来表示语义上等价的布尔表达式之间的区别。
- en: And it’s the difference between writing a matrix multiplication function and
    devising a [`MatrixExpression` type](../16-recursive-data-types/matexpr/) to represent
    matrix multiplications — and store them, manipulate them, optimize them, evaluate
    them, and so on.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是编写矩阵乘法函数与设计 [`MatrixExpression` 类型](../16-recursive-data-types/matexpr/)
    来表示矩阵乘法之间的区别—以及存储它们、操作它们、优化它们、评估它们等等。
- en: First-class functions and functional objects enable us to create particularly
    powerful languages because we can capture patterns of computation as reusable
    abstractions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一级函数和函数对象使我们能够创建特别强大的语言，因为我们可以将计算模式捕获为可重用的抽象。
- en: Music language
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音乐语言
- en: In class, we will design and implement a language for generating and playing
    music. To prepare, let’s first understand the Java APIs for playing music with
    the [MIDI](http://en.wikipedia.org/wiki/MIDI) synthesizer. We’ll see how to write
    a *program* to play MIDI music. Then we’ll begin to develop our music *language*
    by writing a recursive abstract data type for simple musical tunes. We’ll choose
    a notation for writing music in strings, and we’ll implement a parser to create
    instances of our `Music` type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在课堂上，我们将设计和实现一个生成和播放音乐的语言。为了准备，让我们首先了解使用 [MIDI](http://en.wikipedia.org/wiki/MIDI)
    合成器播放音乐的 Java API。我们将看到如何编写一个*程序*来播放 MIDI 音乐。然后，我们将开始开发我们的音乐*语言*，编写一个递归的简单音乐旋律的抽象数据类型。我们将选择一种字符串写音乐的符号，并实现解析器来创建我们的
    `Music` 类的实例。
- en: The [**full source code for the basic music language**](https://github.com/mit6005/fa16-ex26-music-starting)
    is on GitHub.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[**基本音乐语言的完整源代码**](https://github.com/mit6005/fa16-ex26-music-starting)在 GitHub
    上。'
- en: '**Clone** the [fa16-ex26-music-starting](https://github.com/mit6005/fa16-ex26-music-starting)
    repo so you can run the code and follow the discussion below.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**克隆**[fa16-ex26-music-starting](https://github.com/mit6005/fa16-ex26-music-starting)
    存储库，以便您可以运行代码并跟踪下面的讨论。'
- en: Playing MIDI music
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放 MIDI 音乐
- en: '[**`music.midi.MidiSequencePlayer`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/midi/MidiSequencePlayer.java)
    uses the Java MIDI APIs to play sequences of notes. It’s quite a bit of code,
    and you don’t need to understand how it works.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[**`music.midi.MidiSequencePlayer`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/midi/MidiSequencePlayer.java)
    使用 Java MIDI API 来播放音符序列。这是相当多的代码，你不需要理解它是如何工作的。'
- en: '`MidiSequencePlayer` implements the [**`music.SequencePlayer`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/SequencePlayer.java)
    interface, allowing clients to use it without depending on the particular MIDI
    implementation. We *do* need to understand this interface and the types it depends
    on:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`MidiSequencePlayer` 实现了[**`music.SequencePlayer`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/SequencePlayer.java)接口，使得客户端可以在不依赖特定
    MIDI 实现的情况下使用它。我们*确实*需要理解这个接口及其所依赖的类型：'
- en: '**`addNote : SequencePlayer × Instrument × Pitch × double × double → void`**
    ([SequencePlayer.java:15](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/SequencePlayer.java#L15))
    is the workhorse of our music player. Calling this method schedules a musical
    pitch to be played at some time during the piece of music.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**`addNote : SequencePlayer × Instrument × Pitch × double × double → void`**
    ([SequencePlayer.java:15](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/SequencePlayer.java#L15))
    是我们音乐播放器的主力军。调用此方法会在音乐片段中的某个时间安排播放一个音高。'
- en: '**`play : SequencePlayer → void`** ([SequencePlayer.java:20](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/SequencePlayer.java#L20))
    actually plays the music. Until we call this method, we’re just scheduling music
    that will, eventually, be played.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**`play : SequencePlayer → void`** ([SequencePlayer.java:20](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/SequencePlayer.java#L20))
    实际上播放音乐。在调用此方法之前，我们只是调度将来会播放的音乐。'
- en: 'The `addNote` operation depends on two more types:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`addNote` 操作还依赖于两个更多的类型：'
- en: '[**`Instrument`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Instrument.java)
    is an enumeration of all the available MIDI instruments.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[**`Instrument`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Instrument.java)
    是所有可用 MIDI 乐器的枚举。'
- en: '[**`Pitch`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Pitch.java)
    is an abstract data type for musical pitches (think keys on the piano keyboard).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[**`Pitch`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Pitch.java)是用于音高的抽象数据类型（类似钢琴键盘上的键）。'
- en: '**Read** and understand the [**`Pitch`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Pitch.java)
    documentation and the specifications for its [public constructor](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Pitch.java#L57-68)
    and all its [public methods](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Pitch.java#L70-122).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**阅读**并理解[**`Pitch`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Pitch.java)文档以及其[公共构造函数](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Pitch.java#L57-68)和所有[公共方法](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Pitch.java#L70-122)的规范。'
- en: Our music data type will rely on `Pitch` in its rep, so be sure to understand
    the `Pitch` spec as well as its rep and abstraction function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音乐数据类型将依赖于`Pitch`，因此请确保理解`Pitch`的规范以及其表示和抽象函数。
- en: Using the MIDI sequence player and `Pitch`, we’re ready to write code for our
    first bit of music!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MIDI序列播放器和`Pitch`，我们已经准备好为我们的第一段音乐编写代码了！
- en: '**Read** and understand the [**`music.examples.ScaleSequence`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/examples/ScaleSequence.java)
    code.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**阅读**并理解[**`music.examples.ScaleSequence`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/examples/ScaleSequence.java)的代码。'
- en: '**Run the main method in `ScaleSequence`.** You should hear a one-octave scale!'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行`ScaleSequence`中的主方法。** 您应该听到一个一个八度音阶！'
- en: reading exercises
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Pitch
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 音高
- en: Which observers could `MidiSequencePlayer` use to determine what frequency an
    arbitrary `Pitch` represents?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`MidiSequencePlayer`可以使用哪些观察者来确定任意`Pitch`代表的频率？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: transpose
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 转位
- en: '`Pitch.transpose(int)` is a:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pitch.transpose(int)` 是一个：'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: addNote
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 添加音符
- en: '`SequencePlayer.addNote(..)` is a:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`SequencePlayer.addNote(..)` 是一个：'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Music data type
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音乐数据类型
- en: The `Pitch` datatype is useful, but if we want to represent a whole piece of
    music using `Pitch` objects, we should create an abstract data type to encapsulate
    that representation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pitch`数据类型很有用，但如果我们想使用`Pitch`对象来表示整个音乐作品，我们应该创建一个抽象数据类型来封装该表示。'
- en: 'To start, we’ll define the [**`Music`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Music.java)
    type with a few operations:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用一些操作定义[**`Music`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Music.java)类型：
- en: '**`notes : String × Instrument → Music`** ([MusicLanguage.java:51](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L51))
    makes a new Music from a string of simplified abc notation, described below.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**`notes : String × Instrument → Music`** ([MusicLanguage.java:51](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L51))
    从简化的abc记谱字符串中创建新的音乐，下面进行描述。'
- en: '**`duration : Music → double`** ([Music.java:11](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Music.java#L11))
    returns the duration, in beats, of the piece of music.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**`duration : Music → double`** ([Music.java:11](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Music.java#L11))
    返回音乐片段的节拍时长。'
- en: '**`play : Music × SequencePlayer × double → void`** ([Music.java:18](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Music.java#L18))
    plays the piece of music using the given sequence player.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**`play : Music × SequencePlayer × double → void`** ([Music.java:18](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Music.java#L18))
    使用给定的序列播放器播放音乐片段。'
- en: We’ll implement `duration` and `play` as instance methods of `Music`, so we
    declare them in the `Music` interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Music`接口中将`duration`和`play`实现为实例方法，因此我们在`Music`接口中声明它们。
- en: '`notes` will be a static factory method; rather than put it in `Music` (which
    we could do), we’ll put it in a separate class: [**`MusicLanguage`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java)
    will be our place for all the static methods we write to operate on `Music`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`notes`将是一个静态工厂方法；我们不会将其放在`Music`中（虽然我们可以这样做），而是将其放在一个单独的类中：[**`MusicLanguage`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java)将是我们编写的所有静态方法操作`Music`的地方。'
- en: Now that we’ve chosen some operations in the spec of `Music`, let’s choose a
    representation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`Music`的规范中选择了一些操作，让我们选择一种表示方式。
- en: 'Looking at [`ScaleSequence`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/examples/ScaleSequence.java),
    the first concrete variant that might jump out at us is one to capture the information
    in each call to `addNote`: a particular pitch on a particular instrument played
    for some amount of time. We’ll call this a [**`Note`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Note.java).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[`ScaleSequence`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/examples/ScaleSequence.java)，我们可能会注意到的第一个具体变体是捕获每次调用`addNote`中的信息：在特定乐器上演奏一定时间的特定音高。我们将其称为[**`Note`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Note.java)。
- en: 'The other basic element of music is the silence between notes: [**`Rest`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Rest.java).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音乐的另一个基本元素是音符之间的沉黙：[**`Rest`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Rest.java)。
- en: 'Finally, we need a way to glue these basic elements together into larger pieces
    of music. We’ll choose a tree-like structure: [**`Concat(m1,m2:Music)`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Concat.java)
    represents `m1` followed by `m2`, where `m1` and `m2` are any music.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方法将这些基本元素粘合在一起形成更大的音乐片段。我们将选择一种类似树状结构的方式：[**`Concat(m1,m2:Music)`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Concat.java)代表`m1`后跟`m2`，其中`m1`和`m2`可以是任何音乐。
- en: This tree structure turns out to be an elegant decision as we further develop
    our `Music` type later on. In a real design process, we might iterate on the recursive
    structure of `Music` before we find the best implementation.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种树结构事实证明是一个优雅的决定，当我们后来进一步开发我们的`Music`类型时。在真正的设计过程中，我们可能会在找到最佳实现之前对`Music`的递归结构进行迭代。
- en: 'Here’s the datatype definition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据类型定义：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Composite
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组合
- en: '`Music` is an example of the **composite pattern**, in which we treat both
    single objects (*primitives*, e.g. `Note` and `Rest`) and groups of objects (*composites*,
    e.g. `Concat`) the same way.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Music`是**组合模式**的一个例子，在其中我们以相同的方式处理单个对象（*原始元素*，例如`Note`和`Rest`）和对象组（*组合元素*，例如`Concat`）。'
- en: '`Formula` is also an example of the composite pattern.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Formula`也是组合模式的一个例子。'
- en: 'The GUI view tree relies heavily on the composite pattern: there are *primitive
    views* like `JLabel` and `JTextField` that don’t have children, and *composite
    views* like `JPanel` and `JScollPage` that do contain other views as children.
    Both implement the common `JComponent` interface.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI视图树在很大程度上依赖于组合模式：有一些*原始视图*，如`JLabel`和`JTextField`，它们没有子元素，还有一些*组合视图*，如`JPanel`和`JScollPage`，它们包含其他视图作为子元素。两者都实现了共同的`JComponent`接口。
- en: The composite pattern gives rise to a tree data structure, with primitives at
    the leaves and composites at the internal nodes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式产生了一种树状数据结构，叶子节点是原始元素，内部节点是组合元素。
- en: Emptiness
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空白
- en: 'One last design consideration: how do we represent the empty music? It’s always
    good to have a representation for *nothing*, and we’re certainly not going to
    use `null`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个设计考虑：我们如何表示空音乐？拥有表示*空白*的表示总是很好的，我们肯定不会使用`null`。
- en: We could introduce an `Empty` variant, but instead we’ll use a `Rest` of duration
    `0` to represent emptiness.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引入一个`Empty`变体，但我们将使用持续时间为`0`的`Rest`来表示空白。
- en: Implementing basic operations
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现基本操作
- en: First we need to create the [**`Note`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Note.java),
    [**`Rest`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Rest.java),
    and [**`Concat`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Concat.java)
    variants. All three are straightforward to implement, starting with constructors,
    `checkRep`, some observers, `toString`, and the equality methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建 [**`Note`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Note.java)、[**`Rest`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Rest.java)
    和 [**`Concat`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Concat.java)
    变体。所有三者都很容易实现，从构造函数、`checkRep`、一些观察者、`toString` 和相等方法开始。
- en: Since the `duration` operation is an instance method, each variant implements
    `duration` appropriately.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `duration` 操作是一个实例方法，因此每个变体都适当地实现了 `duration`。
- en: The `play` operation is also an instance method; we’ll discuss it below under
    [*implementing the player*](#implementing_the_player).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play` 操作也是一个实例方法；我们将在下面的 [*实现播放器*](#implementing_the_player) 中讨论它。'
- en: And we’ll discuss the `notes` operation in [*implementing the parser*](#implementing_the_parser).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*实现解析器*](#implementing_the_parser) 中讨论 `notes` 操作。
- en: '**Read** and understand the [`Note`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Note.java),
    [`Rest`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Rest.java),
    and [`Concat`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Concat.java)
    classes.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读并理解 [`Note`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Note.java)、[`Rest`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Rest.java)
    和 [`Concat`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Concat.java)
    类。
- en: 'To avoid representation exposure, let’s add some additional static factory
    methods to the `Music` interface:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免暴露表示，让我们向 `Music` 接口添加一些额外的静态工厂方法：
- en: '**`note : double × Pitch × Instrument → Music`** ([MusicLanguage.java:92](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L92))'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**`note : double × Pitch × Instrument → Music`** ([MusicLanguage.java:92](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L92))'
- en: '**`rest : double → Music`** ([MusicLanguage.java:100](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L100))'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**`rest : double → Music`** ([MusicLanguage.java:100](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L100))'
- en: '**`concat : Music × Music → Music`** ([MusicLanguage.java:113](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L113))
    is our first producer operation.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**`concat : Music × Music → Music`** ([MusicLanguage.java:113](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L113))
    是我们的第一个生产者操作。'
- en: All three of them are easy to implement by constructing the appropriate variant.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三者都易于通过构造适当的变体来实现。
- en: reading exercises
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Music rep
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐表示
- en: Assume we have
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Which of the following represent a middle C followed by A above middle C?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个代表中音 C 后面的 C 上面的 A？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Music notation
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音乐符号
- en: We will write pieces of music using a simplified version of [**abc notation**](http://en.wikipedia.org/wiki/ABC_notation),
    a text-based music format.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简化版本的 [**abc 符号**](http://en.wikipedia.org/wiki/ABC_notation)，一种基于文本的音乐格式，来编写音乐片段。
- en: We’ve already been representing pitches using their familiar letters. Our simplified
    abc notation represents sequences of **notes** and **rests** with syntax for indicating
    their **duration**, **accidental** (sharp or flat), and **octave**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用熟悉的字母表示音高。我们简化的 abc 符号表示具有指示它们的 **持续时间**、**意外记号**（升音或降音）和**八度**的**音符**和**休止符**序列的语法。
- en: 'For example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '**`C D E F G A B C'' B A G F E D C`** represents the one-octave ascending and
    descending C major scale we played in `ScaleSequence`. `C` is middle C, and `C''`
    is C one octave above middle C. Each note is a quarter note.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**`C D E F G A B C'' B A G F E D C`** 代表我们在 `ScaleSequence` 中演奏的一个八度升降 C 大调音阶。`C`
    是中音 C，`C''` 是中音 C 上面的一个八度。每个音符都是四分音符。'
- en: '**`C/2 D/2 _E/2 F/2 G/2 _A/2 _B/2 C''`** is the ascending scale in C minor,
    played twice as fast. The E, A, and B are flat. Each note is an eighth note.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**`C/2 D/2 _E/2 F/2 G/2 _A/2 _B/2 C''`** 是以 C 小调演奏的升音音阶，速度加倍。E、A 和 B 是降调。每个音符都是八分音符。'
- en: '**Read** and understand the specification of [`notes` in `MusicLanguage`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L20-50).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**阅读** 并理解 [`MusicLanguage` 中的 `notes` 的规范](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L20-50)。'
- en: You don’t need to understand the parser implementation yet, but you should understand
    the simplified abc notation enough to make sense of the examples.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不需要理解解析器的实现，但你应该足够理解简化的 abc 符号来理解示例。
- en: If you’re not familiar with music theory — why is an octave 8 notes but only
    12 semitones? — don’t worry. You might not be able to look at the abc strings
    and guess what they sound like, but you can understand the point of choosing a
    convenient textual syntax.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对音乐理论不熟悉 — 为什么八度有 8 个音符，但只有 12 个半音？ — 不要担心。你可能无法看着 abc 字符串猜出它们的声音是什么样的，但你可以理解选择方便的文本语法的意义。
- en: reading exercises
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Simplified abc syntax
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的 abc 语法
- en: Which of these notes are twice as long as `E/4`?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些音符中哪些是 `E/4` 的两倍长？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Implementing the parser
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现解析器
- en: The `notes` method parses strings of simplified abc notation into `Music`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`notes` 方法将简化的 abc 符号字符串解析为 `Music`。'
- en: '**`notes : String × Instrument → Music`** ([MusicLanguage.java:51](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L51))
    splits the input into individual symbols (e.g. `A,,/2`, `.1/2`). We start with
    the empty `Music`, `rest(0)`, symbols are parsed individually, and we build up
    the `Music` using `concat`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**`notes : String × Instrument → Music`** ([MusicLanguage.java:51](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L51))
    将输入拆分为单个符号（例如 `A,,/2`，`.1/2`）。我们从空的 `Music`，`rest(0)` 开始，符号被逐个解析，然后我们使用 `concat`
    构建 `Music`。'
- en: '**`parseSymbol : String × Instrument → Music`** ([MusicLanguage.java:62](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L62))
    returns a `Rest` or a `Note` for a single abc symbol (`symbol` in the grammar).
    It only parses the type (rest or note) and duration; it relies on `parsePitch`
    to handle pitch letters, accidentals, and octaves.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**`parseSymbol : String × Instrument → Music`** ([MusicLanguage.java:62](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L62))
    返回一个 `Rest` 或一个 `Note`，对于一个单个的 abc 符号（语法中的 `symbol`）。它仅解析类型（休止符或音符）和持续时间；它依赖于
    `parsePitch` 来处理音高、升降号和八度。'
- en: '**`parsePitch : String → Pitch`** ([MusicLanguage.java:77](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L77))
    returns a `Pitch` by parsing a `pitch` grammar production. You should be able
    to understand the recursion — what’s the base case? What are the recursive cases?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**`parsePitch : String → Pitch`** ([MusicLanguage.java:77](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/MusicLanguage.java#L77))
    通过解析 `pitch` 语法产生来返回一个 `Pitch`。你应该能够理解递归 — 基本情况是什么？递归情况是什么？'
- en: reading exercises
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: parsePitch
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: parsePitch
- en: Which of these inputs is handled by the base case of `parsePitch`?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`parsePitch` 的基本情况处理这些输入中的哪些？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Implementing the player
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现播放器
- en: 'Recall our operation for playing music:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们播放音乐的操作：
- en: '**`play : Music × SequencePlayer × double → void`** ([Music.java:18](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Music.java#L18))
    plays the piece of music using the given sequence player after the given number
    of beats delay.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**`play : Music × SequencePlayer × double → void`** ([Music.java:18](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Music.java#L18))
    在给定节拍延迟之后，使用给定的序列播放器播放音乐片段。'
- en: Why does this operation take `atBeat`? Why not simply play the music *now*?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个操作要花费`atBeat`？为什么不直接*现在*播放音乐呢？
- en: If we define `play` in that way, we won’t be able to play sequences of notes
    over time unless we actually *pause* during the `play` operation, for example
    with `Thread.sleep`. Our sequence player’s [`addNote` operation](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/SequencePlayer.java#L15)
    is already designed to schedule notes in the future — it handles the delay.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以这种方式定义`play`，那么除非我们实际上在`play`操作期间*暂停*，例如使用`Thread.sleep`，否则我们将无法随时间播放音符序列。我们的序列播放器的[`addNote`操作](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/SequencePlayer.java#L15)已经设计好了以安排未来的音符
    - 它处理延迟。
- en: With that design decision, it’s straightforward to implement `play` in every
    variant of `Music`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设计决定，就可以在每个`Music`变体中轻松实现`play`。
- en: '**Read** and understand the [`Note.play`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Note.java#L55),
    [`Rest.play`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Rest.java#L33),
    and [`Concat.play`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Concat.java#L51)
    methods.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**阅读**并理解[`Note.play`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Note.java#L55)，[`Rest.play`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Rest.java#L33)，以及[`Concat.play`](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/Concat.java#L51)方法。'
- en: You should be able to follow their recursive implementations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够理解它们的递归实现。
- en: 'Just one more piece of utility code before we’re ready to jam: [**`music.midi.MusicPlayer`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/midi/MusicPlayer.java)
    plays a `Music` using the `MidiSequencePlayer`. `Music` doesn’t know about the
    concrete type of the sequence player, so we need a bit of code to bring them together.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备好进行即兴演奏之前，再加一点实用代码：[**`music.midi.MusicPlayer`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/midi/MusicPlayer.java)使用`MidiSequencePlayer`播放`Music`。`Music`不知道序列播放器的具体类型，因此我们需要一些代码将它们联系起来。
- en: 'Bringing this *all* together, let’s use the `Music` ADT:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起，让我们使用`Music` ADT：
- en: '**Read** and understand the [**`music.examples.ScaleMusic`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/examples/ScaleMusic.java)
    code.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**阅读**并理解[**`music.examples.ScaleMusic`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/examples/ScaleMusic.java)代码。'
- en: '**Run the main method in `ScaleMusic`.** You should hear the same one-octave
    scale again.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行`ScaleMusic`中的主方法。** 你应该再次听到同一个一个八度音阶。'
- en: That’s not very exciting, so **read** [**`music.examples.RowYourBoatInitial`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/examples/RowYourBoatInitial.java)
    and **run the main method.** You should hear *Row, row, row your boat*!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那并不是很令人兴奋，所以**阅读**[**`music.examples.RowYourBoatInitial`**](https://github.com/mit6005/fa16-ex26-music-starting/blob/master/src/music/examples/RowYourBoatInitial.java)并**运行主方法**。你应该听到*Row,
    row, row your boat*！
- en: Can you follow the flow of the code from calling `notes(..)` to having an instance
    of `Music` to the recursive `play(..)` call to individual `addNote(..)` calls?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你能够从调用`notes(..)`到拥有`Music`实例再到递归`play(..)`调用再到单独的`addNote(..)`调用的代码流程吗？
- en: reading exercises
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: notes
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 音符
- en: There are 27 notes in *Row, row, row your boat*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*Row, row, row your boat*中有27个音符。'
- en: Given the actual implementation, how many `Music` objects will be created by
    the `notes` call in `RowYourBoatInitial`?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据实际实现，`RowYourBoatInitial`中的`notes`调用将创建多少个`Music`对象？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: duration
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间
- en: What should be the result of `rowYourBoat.duration()`?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowYourBoat.duration()`的结果应该是什么？'
- en: (missing answer)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Music
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐
- en: Assume we have
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Which of the following is a valid `Music`?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个是有效的`Music`？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: To be continued
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未完待续
- en: Playing *Row, row, row your boat* is pretty exciting, but so far the most powerful
    thing we’ve done is not so much the *music language* as it is the very basic *music
    parser*. Writing music using the simplified abc notation is clearly much more
    **easy to understand**, **safe from bugs**, and **ready for change** than writing
    page after page of `addNote` `addNote` `addNote`…
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 弹奏*Row, row, row your boat*是非常令人兴奋的，但到目前为止，我们所做的最强大的事情并不是*音乐语言*，而是非常基础的*音乐解析器*。使用简化的abc记谱写音乐显然比一页页写`addNote`
    `addNote` `addNote`更**易于理解**，**免受错误的影响**，并且**随时可以更改**。
- en: In class, we’ll expand our music language and turn it into a powerful tool for
    constructing and manipulating complex musical structures.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在课堂上，我们将扩展我们的音乐语言，并将其转化为一个构建和操纵复杂音乐结构的强大工具。
