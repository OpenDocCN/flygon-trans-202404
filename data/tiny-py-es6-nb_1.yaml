- en: Tiny Python 3.6 Notebook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3.6 微型笔记本
- en: 'From: [mattharrison/Tiny-Python-3.6-Notebook](https://github.com/mattharrison/Tiny-Python-3.6-Notebook)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 来自：[mattharrison/Tiny-Python-3.6-Notebook](https://github.com/mattharrison/Tiny-Python-3.6-Notebook)
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This is not so much an instructional manual, but rather notes, tables, and examples
    for Python syntax. It was created by the author as an additional resource during
    training, meant to be distributed as a physical notebook. Participants (who favor
    the physical characteristics of dead tree material) could add their own notes,
    thoughts, and have a valuable reference of curated examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本教学手册，而是 Python 语法的笔记、表格和示例。作者创建它作为培训期间的额外资源，旨在作为一本实体笔记本分发。参与者（喜欢纸质材料的实体特性）可以添加自己的笔记、想法，并拥有一个有价值的精选示例参考。
- en: Running Python
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Python
- en: Installation
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: 'To check if Python is installed, run the following from a terminal:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Python 是否已安装，请从终端运行以下命令：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Otherwise, install Python 3 from the website [[1]](#id2).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，从网站[[1]](#id2)安装 Python 3。
- en: '| [[1]](#id1) | [http://python.org](http://python.org) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [[1]](#id1) | [http://python.org](http://python.org) |'
- en: Invoking Python
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用 Python
- en: 'The Python executable will behave differently depending on the command line
    options you give it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可执行文件的行为取决于您给出的命令行选项：
- en: 'Start the Python REPL:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 Python REPL：
- en: '[PRE1]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Execute the `file.py` file:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`file.py`文件：
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the `file.py` file, and drop into REPL with namespace of `file.py`:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`file.py`文件，并进入具有`file.py`命名空间的 REPL：
- en: '[PRE3]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Execute the `json/tool.py` module:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`json/tool.py`模块：
- en: '[PRE4]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute `"print('hi')"`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`"print('hi')"`
- en: '[PRE5]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: REPL
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REPL
- en: Use the `help` function to read the documentation for a module/class/function.
    As a standalone invocation, you enter the help system and can explore various
    topics.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`help`函数阅读模块/类/函数的文档。作为独立调用，你可以进入帮助系统并探索各种主题。
- en: Use the `dir` function to list contents of the namespace, or attributes of an
    object if you pass one in.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dir`函数列出命名空间的内容，或者如果传入一个对象，则列出该对象的属性。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The majority of code in this book is written as if it were executed in a REPL.
    If you are typing it in, ignore the primary and secondary prompts (`>>>` and `...`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大部分代码都是按照在 REPL 中执行的方式编写的。如果你在输入它，请忽略主要和次要提示（`>>>`和`...`）。
- en: The Zen of Python
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 之禅
- en: 'Run the following in an interpreter to get an Easter egg that describes some
    of the ethos behind Python. This is also codified in PEP 20:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释器中运行以下命令，可以获得一个描述 Python 背后理念的彩蛋。这也在 PEP 20 中有所体现：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These might just seem like silly one liners, but there is a lot of wisdom packed
    in here. It is good for Python programmers to review these every once in a while
    and see if these hold true for their code. (Or to justify their code reviews)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能看起来只是愚蠢的一行代码，但其中包含了很多智慧。对于 Python 程序员来说，不妨偶尔回顾一下这些内容，看看它们是否适用于他们的代码（或者为了证明他们的代码审查）。
- en: Built-in Types
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置类型
- en: Variables
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'Python variables are like cattle tags, they point to objects (which can be
    classes, instances, modules, or functions), but variables are not the objects.
    You can reuse variable names for different object types (though you probably shouldn''t):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python 变量就像牲畜标签，它们指向对象（可以是类、实例、模块或函数），但变量本身不是对象。你可以为不同的对象类型重复使用变量名（尽管你可能不应该这样做）：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `#` character denotes the start of a comment. There are no multi-line comments,
    though most editors with Python support can comment out a region.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` 字符表示注释的开始。虽然没有多行注释，但大多数支持 Python 的编辑器可以注释掉一个区域。'
- en: The figure that follows illustrates how everything is an object in Python and
    variables just point to them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了在 Python 中一切都是对象，变量只是指向它们的指针。
- en: '[![../Images/rebind.png](../Images/rebind.png)](../Images/rebind.png)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/rebind.png](../Images/rebind.png)](../Images/rebind.png)'
- en: Illustration of reusing the same variable
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用相同变量的示例
- en: Numbers
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字
- en: 'Python includes three types of numeric literals: *integers*, *floats*, and
    *complex numbers*. Python 3.6 adds the ability to use underscores to improve readability
    (PEP 515).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包括三种类型的数字字面量：*整数*、*浮点数* 和 *复数*。Python 3.6 添加了使用下划线以提高可读性的功能（PEP 515）。
- en: Number types
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数字类型
- en: '| Type | Example |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 示例 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Integer | `14` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | `14` |'
- en: '| Integer (Hex) | `0xe` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 整数（十六进制） | `0xe` |'
- en: '| Integer (Octal) | `0o16` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 整数（八进制） | `0o16` |'
- en: '| Integer (Binary) | `0b1110` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 整数（二进制） | `0b1110` |'
- en: '| Float | `14.0` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | `14.0` |'
- en: '| Float | `1.4e1` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | `1.4e1` |'
- en: '| Complex | `14+0j` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 复数 | `14+0j` |'
- en: '| Underscore | `1_000` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 下划线 | `1_000` |'
- en: There are many built-in functions for manipulating numbers ie. `abs`, `min`,
    `max`, `ceil`. Also see the `math`, `random`, and `statistics` modules in the
    standard library.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于操作数字的内置函数，如 `abs`、`min`、`max`、`ceil`。还可以查看标准库中的 `math`、`random` 和 `statistics`
    模块。
- en: Number magic methods
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数字魔术方法
- en: '| Operation | Provided By | Result |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `abs(num)` | `__abs__` | Absolute value of `num` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `abs(num)` | `__abs__` | `num` 的绝对值 |'
- en: '| `num + num2` | `__add__` | Addition |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `num + num2` | `__add__` | 加法 |'
- en: '| `bool(num)` | `__bool__` | Boolean conversion |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `bool(num)` | `__bool__` | 布尔转换 |'
- en: '| `num == num2` | `__eq__` | Equality |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `num == num2` | `__eq__` | 等于 |'
- en: '| `float(num)` | `__float__` | Float conversion |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `float(num)` | `__float__` | 浮点数转换 |'
- en: '| `num // num2` | `__floordiv__` | Integer division |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `num // num2` | `__floordiv__` | 整数除法 |'
- en: '| `num >= num2` | `__ge__` | Greater or equal |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `num >= num2` | `__ge__` | 大于或等于 |'
- en: '| `num > num2` | `__gt__` | Greater than |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `num > num2` | `__gt__` | 大于 |'
- en: '| `int(num)` | `__int__` | Integer conversion |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `int(num)` | `__int__` | 整数转换 |'
- en: '| `num <= num2` | `__le__` | Less or equal |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `num <= num2` | `__le__` | 小于或等于 |'
- en: '| `num < num2` | `__lt__` | Less than |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `num < num2` | `__lt__` | 小于 |'
- en: '| `num % num2` | `__mod__` | Modulus |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `num % num2` | `__mod__` | 取模 |'
- en: '| `num * num2` | `__mul__` | Multiplication |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `num * num2` | `__mul__` | 乘法 |'
- en: '| `num != num2` | `__ne__` | Not equal |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `num != num2` | `__ne__` | 不等于 |'
- en: '| `-num` | `__neg__` | Negative |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `-num` | `__neg__` | 负数 |'
- en: '| `+num` | `__pos__` | Positive |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `+num` | `__pos__` | 正数 |'
- en: '| `num ** num2` | `__pow__` | Power |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `num ** num2` | `__pow__` | 幂运算 |'
- en: '| `round(num)` | `__round__` | Round |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `round(num)` | `__round__` | 四舍五入 |'
- en: '| `num.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `num.__sizeof__()` | `__sizeof__` | 内部表示的字节数 |'
- en: '| `str(num)` | `__str__` | String conversion |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `str(num)` | `__str__` | 字符串转换 |'
- en: '| `num - num2` | `__sub__` | Subtraction |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `num - num2` | `__sub__` | 减法 |'
- en: '| `num / num2` | `__truediv__` | Float division |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `num / num2` | `__truediv__` | 浮点数除法 |'
- en: '| `math.trunc(num)` | `__trunc__` | Truncation |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `math.trunc(num)` | `__trunc__` | 截断 |'
- en: Integer specific methods and operations
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 整数特定方法和操作
- en: '| Operation | Provided By | Result |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `num & num2` | `__and__` | Bitwise and |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `num & num2` | `__and__` | 按位与 |'
- en: '| `math.ceil(num)` | `__ceil__` | Ceiling |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `math.ceil(num)` | `__ceil__` | 上取整 |'
- en: '| `math.floor(num)` | `__floor__` | Floor |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `math.floor(num)` | `__floor__` | 下取整 |'
- en: '| `~num` | `__invert__` | Bitwise inverse |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `~num` | `__invert__` | 按位取反 |'
- en: '| `num << num2` | `__lshift__` | Left shift |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `num << num2` | `__lshift__` | 左移 |'
- en: '| `num &#124; num2` | `__or__` | Bitwise or |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `num &#124; num2` | `__or__` | 按位或 |'
- en: '| `num >> num2` | `__rshift__` | Right shift |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `num >> num2` | `__rshift__` | 右移 |'
- en: '| `num ^ num2` | `__xor__` | Bitwise xor |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `num ^ num2` | `__xor__` | 按位异或 |'
- en: '| `num.bit_length()` | `bit_length` | Number of bits necessary |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `num.bit_length()` | `bit_length` | 所需位数 |'
- en: Float specific methods and operations
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数特定方法和操作
- en: '| Operation | Result |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `f.as_integer_ratio()` | Returns num, denom tuple |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `f.as_integer_ratio()` | 返回 num, denom 元组 |'
- en: '| `f.is_integer()` | Boolean if whole number |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `f.is_integer()` | 是否为整数的布尔值 |'
- en: Strings
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Python 3 strings hold unicode data. Python has a few ways to represent strings.
    There is also a bytes type (PEP 3137):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 字符串保存 Unicode 数据。Python 有几种表示字符串的方式。还有一个字节类型（PEP 3137）：
- en: String types
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串类型
- en: '| Type | Example |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 示例 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| String | `"hello\tthere"` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `"你好\t那里"` |'
- en: '| String | `''hello''` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `''你好''` |'
- en: '| String | `''''''He said, "hello"''''''` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `''''''他说，"你好"''''''` |'
- en: '| Raw string | `r''hello\tthere''` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 原始字符串 | `r''你好\t那里''` |'
- en: '| Byte string | `b''hello''` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 字节字符串 | `b''hello''` |'
- en: Escape Characters
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 转义字符
- en: '| Escape Sequence | Output |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 输出 |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\` newline | Ignore trailing newline in triple quoted string |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `\` 换行 | 忽略三引号字符串中的结尾换行符 |'
- en: '| `\\` | Backslash |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 |'
- en: '| `\''` | Single quote |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | 单引号 |'
- en: '| `\"` | Double quote |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 |'
- en: '| `\a` | ASCII Bell |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `\a` | ASCII 响铃 |'
- en: '| `\b` | ASCII Backspace |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | ASCII 退格 |'
- en: '| `\n` | Newline |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行 |'
- en: '| `\r` | ASCII carriage return |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | ASCII 回车 |'
- en: '| `\t` | Tab |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |'
- en: '| `\u12af` | Unicode 16 bit |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `\u12af` | Unicode 16 位 |'
- en: '| `\U12af89bc` | Unicode 32 bit |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `\U12af89bc` | Unicode 32 位 |'
- en: '| `N{BLACK STAR}` | Unicode name |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `N{黑星}` | Unicode 名称 |'
- en: '| `\o84` | Octal character |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `\o84` | 八进制字符 |'
- en: '| `\xFF` | Hex character |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `\xFF` | 十六进制字符 |'
- en: String operations
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作
- en: '| Operation | Provided By | Result |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `s + s2` | `__add__` | String concatenation |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `s + s2` | `__add__` | 字符串连接 |'
- en: '| `"foo" in s` | `__contains__` | Membership |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `"foo" in s` | `__contains__` | 成员关系 |'
- en: '| `s == s2` | `__eq__` | Equality |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `s == s2` | `__eq__` | 等于 |'
- en: '| `s >= s2` | `__ge__` | Greater or equal |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `s >= s2` | `__ge__` | 大于或等于 |'
- en: '| `s[0]` | `__getitem__` | Index operation |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `s[0]` | `__getitem__` | 索引操作 |'
- en: '| `s > s2` | `__gt__` | Greater |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `s > s2` | `__gt__` | 大于 |'
- en: '| `s <= s2` | `__le__` | Less than or equal |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `s <= s2` | `__le__` | 小于或等于 |'
- en: '| `len(s)` | `__len__` | Length |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `len(s)` | `__len__` | 长度 |'
- en: '| `s < s2` | `__lt__` | Less than |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `s < s2` | `__lt__` | 小于 |'
- en: '| `s % (1, ''foo'')` | `__mod__` | Formatting |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `s % (1, ''foo'')` | `__mod__` | 格式化 |'
- en: '| `s * 3` | `__mul__` | Repetition |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `s * 3` | `__mul__` | 重复 |'
- en: '| `s != s2` | `__ne__` | Not equal |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `s != s2` | `__ne__` | 不相等 |'
- en: '| `repr(s)` | `__repr__` | Programmer friendly string |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `repr(s)` | `__repr__` | 程序员友好的字符串 |'
- en: '| `s.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `s.__sizeof__()` | `__sizeof__` | 内部表示的字节数 |'
- en: '| `str(s)` | `__str__` | User friendly string |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `str(s)` | `__str__` | 用户友好的字符串 |'
- en: String methods
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串方法
- en: '| Operation | Result |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `s.capitalize()` | Capitalizes a string |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `s.capitalize()` | 字符串首字母大写 |'
- en: '| `s.casefold()` | Lowercase in a unicode compliant manner |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `s.casefold()` | 以Unicode兼容的方式小写 |'
- en: '| `s.center(w, [char])` | Center a string in `w` spaces with `char` (default
    `" "`) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `s.center(w, [char])` | 在`w`个空格中居中`char`（默认为`" "`） |'
- en: '| `s.count(sub, [start, [end]])` | Count `sub` in `s` between `start` and `end`
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(sub, [start, [end]])` | 计算`start`和`end`之间`s`中`sub`的数量 |'
- en: '| `s.encode(encoding, errors= ''strict'')` | Encode a string into bytes |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `s.encode(encoding, errors= ''strict'')` | 将字符串编码为字节 |'
- en: '| `s.endswith(sub)` | Check for a suffix |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `s.endswith(sub)` | 检查后缀 |'
- en: '| `s.expandtabs( tabsize=8)` | Replaces tabs with spaces |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `s.expandtabs( tabsize=8)` | 用空格替换制表符 |'
- en: '| `s.find(sub, [start, [end]])` | Find substring or return `-1` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `s.find(sub, [start, [end]])` | 查找子字符串或返回`-1` |'
- en: '| `s.format(*args, **kw)` | Format string |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `s.format(*args, **kw)` | 格式化��符串 |'
- en: '| `s.format_map( mapping)` | Format strings with a mapping |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `s.format_map( mapping)` | 使用映射格式化字符串 |'
- en: '| `s.index(sub, [start, [end]])` | Find substring or raise `ValueError` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `s.index(sub, [start, [end]])` | 查找子字符串或引发`ValueError` |'
- en: '| `s.isalnum()` | Boolean if alphanumeric |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `s.isalnum()` | 返回字母数字布尔值 |'
- en: '| `s.isalpha()` | Boolean if alphabetic |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `s.isalpha()` | 返回字母布尔值 |'
- en: '| `s.isdecimal()` | Boolean if decimal |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdecimal()` | 返回十进制布尔值 |'
- en: '| `s.isdigit()` | Boolean if digit |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdigit()` | 返回数字布尔值 |'
- en: '| `s.isidentifier()` | Boolean if valid identifier |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `s.isidentifier()` | 返回有效标识符的布尔值 |'
- en: '| `s.islower()` | Boolean if lowercase |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `s.islower()` | 返回小写布尔值 |'
- en: '| `s.isnumeric()` | Boolean if numeric |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `s.isnumeric()` | 返回数字布尔值 |'
- en: '| `s.isprintable()` | Boolean if printable |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `s.isprintable()` | 返回可打印布尔值 |'
- en: '| `s.isspace()` | Boolean if whitespace |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `s.isspace()` | 返回空格布尔值 |'
- en: '| `s.istitle()` | Boolean if titlecased |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `s.istitle()` | 返回标题布尔值 |'
- en: '| `s.isupper()` | Boolean if uppercased |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `s.isupper()` | 返回大写布尔值 |'
- en: '| `s.join(iterable)` | Return a string inserted between sequence |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `s.join(iterable)` | 在序列之间返回插入的字符串 |'
- en: '| `s.ljust(w, [char])` | Left justify in `w` spaces with `char` (default `''
    ''`) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `s.ljust(w, [char])` | 在`w`个空格中左对齐`char`（默认为`'' ''`） |'
- en: '| `s.lower()` | Lowercase |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `s.lower()` | 小写 |'
- en: '| `s.lstrip([chars])` | Left strip `chars` (default spacing). |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `s.lstrip([chars])` | 左侧去除`chars`（默认为空格）。 |'
- en: '| `s.partition(sub)` | Split string at first occurrence of substring, return
    `(before, sub, after)` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `s.partition(sub)` | 在子字符串的第一次出现处拆分字符串，返回`(before, sub, after)` |'
- en: '| `s.replace(old, new, [count])` | Replace substring with new string |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `s.replace(old, new, [count])` | 用新字符串替换子字符串 |'
- en: '| `s.rfind(sub, [start, [end]])` | Find rightmost substring or return `-1`
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `s.rfind(sub, [start, [end]])` | 查找最右边的子字符串或返回`-1` |'
- en: '| `s.rindex(sub, [start, [end]])` | Find rightmost substring or raise `ValueError`
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `s.rindex(sub, [start, [end]])` | 查找最右边的子字符串或引发`ValueError` |'
- en: '| `s.rjust(w, [char)` | Right justify in w spaces with char (default `" "`)
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `s.rjust(w, [char)` | 在`w`个空格中右对齐`char`（默认为`" "`) |'
- en: '| `s.rpartition(sub)` | Rightmost partition |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `s.rpartition(sub)` | 最右边的分区 |'
- en: '| `s.rsplit([sep, [maxsplit=-1])` | Rightmost split by `sep` (defaults to whitespace)
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `s.rsplit([sep, [maxsplit=-1])` | 由`sep`（默认为空格）右侧拆分 |'
- en: '| `s.rstrip([chars])` | Right strip |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `s.rstrip([chars])` | 右侧去除 |'
- en: '| `s.split([sep, [maxsplit=-1]])` | Split a string into sequence around substring
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `s.split([sep, [maxsplit=-1]])` | 在子字符串周围拆分字符串为序列 |'
- en: '| `s.splitlines( keepends=False)` | Break string at line boundaries |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `s.splitlines( keepends=False)` | 在行边界处断开字符串 |'
- en: '| `s.startswith( prefix, [start, [end]])` | Check for prefix |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `s.startswith( prefix, [start, [end]])` | 检查前缀 |'
- en: '| `s.strip([chars])` | Remove leading and trailing whitespace (default) or
    `chars` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `s.strip([chars])` | 移除前导和尾随空格（默认）或`chars` |'
- en: '| `s.swapcase()` | Swap casing of string |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `s.swapcase()` | 交换字符串的大小写 |'
- en: '| `s.title()` | Titlecase string |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `s.title()` | 标题化字符串 |'
- en: '| `s.translate(table)` | Use a translation table to replace strings |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `s.translate(table)` | 使用翻译表替换字符串 |'
- en: '| `s.upper()` | Uppercase |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `s.upper()` | 大写 |'
- en: '| `s.zfill(width)` | Left fill with `0` so string fills `width` (no truncation)
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `s.zfill(width)` | 左侧填充`0`，使字符串填充到`width`（不截断） |'
- en: Lists
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'Lists are ordered mutable sequences:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序的可变序列：
- en: '[PRE8]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `in` operator is useful for checking membership on sequences:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符对于检查序列成员关系很有用：'
- en: '[PRE9]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we need the index number during iteration, the `enumerate` function gives
    us a tuple of index, item pairs:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在迭代过程中需要索引号，`enumerate`函数会给我们一个索引、项目对的元组：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can do index operations on most sequences:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对大多数序列进行索引操作：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also do *slicing* operations on most sequences:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对大多数序列进行*切片*操作：
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: List Operations
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表操作
- en: '| Operation | Provided By | Result |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `l + l2` | `__add__` | List concatenation (see `.extend`) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `l + l2` | `__add__` | 列表连接（参见`.extend`） |'
- en: '| `"name" in l` | `__contains__` | Membership |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `"name" in l` | `__contains__` | 成员关系 |'
- en: '| `del l[idx]` | `__del__` | Remove item at index `idx` (see `.pop`) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `del l[idx]` | `__del__` | 删除索引`idx`处的项目（参见`.pop`） |'
- en: '| `l == l2` | `__eq__` | Equality |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `l == l2` | `__eq__` | 相等 |'
- en: '| `"{}".format(l)` | `__format__` | String format of list |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `"{}".format(l)` | `__format__` | 列表的字符串格式 |'
- en: '| `l >= l2` | `__ge__` | Greater or equal. Compares items in lists from left
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `l >= l2` | `__ge__` | 大于或等于。从左边比较列表中的项目 |'
- en: '| `l[idx]` | `__getitem__` | Index operation |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `l[idx]` | `__getitem__` | 索引操作 |'
- en: '| `l > l2` | `__gt__` | Greater. Compares items in lists from left |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `l > l2` | `__gt__` | 大于。从左边比较列表中的项目 |'
- en: '| No hash | `__hash__` | Set to `None` to ensure you can''t insert in dictionary
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 无哈希 | `__hash__` | 设置为`None`以确保无法插入字典 |'
- en: '| `l += l2` | `__iadd__` | Augmented (mutates `l`) concatenation |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `l += l2` | `__iadd__` | 增强（改变`l`）连接 |'
- en: '| `l *= 3` | `__imul__` | Augmented (mutates `l`) repetition |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `l *= 3` | `__imul__` | 增强（改变`l`）重复 |'
- en: '| `for thing in l:` | `__iter__` | Iteration |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `for thing in l:` | `__iter__` | 迭代 |'
- en: '| `l <= l2` | `__le__` | Less than or equal. Compares items in lists from left
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `l <= l2` | `__le__` | 小于或等于。从左边比较列表中的项目 |'
- en: '| `len(l)` | `__len__` | Length |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `len(l)` | `__len__` | 长度 |'
- en: '| `l < l2` | `__lt__` | Less than. Compares items in lists from left |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `l < l2` | `__lt__` | 小于。从左边比较列表中的项目 |'
- en: '| `l * 2` | `__mul__` | Repetition |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `l * 2` | `__mul__` | 重复 |'
- en: '| `l != l2` | `__ne__` | Not equal |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `l != l2` | `__ne__` | 不相等 |'
- en: '| `repr(l)` | `__repr__` | Programmer friendly string |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `repr(l)` | `__repr__` | 程序员友好的字符串 |'
- en: '| `reversed(l)` | `__reversed__` | Reverse |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `reversed(l)` | `__reversed__` | 反转 |'
- en: '| `foo * l` | `__rmul__` | Called if `foo` doesn''t implement `__mul__` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `foo * l` | `__rmul__` | 如果`foo`没有实现`__mul__`则调用 |'
- en: '| `l[idx] = ''bar''` | `__setitem__` | Index operation to set value |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `l[idx] = ''bar''` | `__setitem__` | 索引操作设置值 |'
- en: '| `l.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `l.__sizeof__()` | `__sizeof__` | 内部表示的字节 |'
- en: '| `str(l)` | `__str__` | User friendly string |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `str(l)` | `__str__` | 用户友好的字符串 |'
- en: List Methods
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表方法
- en: '| Operation | Result |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `l.append(item)` | Append `item` to end |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `l.append(item)` | 将`item`追加到末尾 |'
- en: '| `l.clear()` | Empty list (mutates `l`) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `l.clear()` | 清空列表（改变`l`） |'
- en: '| `l.copy()` | Shallow copy |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `l.copy()` | 浅复制 |'
- en: '| `l.count(thing)` | Number of occurrences of `thing` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `l.count(thing)` | `thing`的出现次数 |'
- en: '| `l.extend(l2)` | List concatenation (mutates `l`) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `l.extend(l2)` | 列表连接（改变`l`） |'
- en: '| `l.index(thing)` | Index of `thing` else `ValueError` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `l.index(thing)` | `thing`的索引，否则引发`ValueError` |'
- en: '| `l.insert(idx, bar)` | Insert `bar` at index `idx` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `l.insert(idx, bar)` | 在索引`idx`处插入`bar` |'
- en: '| `l.pop([idx])` | Remove last item or item at `idx` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `l.pop([idx])` | 删除最后一个项目或索引处的项目 |'
- en: '| `l.remove(bar)` | Remove first instance of `bar` else `ValueError` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `l.remove(bar)` | 删除第一个实例`bar`，否则引发`ValueError` |'
- en: '| `l.reverse()` | Reverse (mutates `l`) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `l.reverse()` | 反转（改变`l`） |'
- en: '| `l.sort([key=], reverse=False)` | In-place sort, by optional `key` function
    (mutates `l`) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `l.sort([key=], reverse=False)` | 就地排序，使用可选的`key`函数（改变`l`） |'
- en: Dictionaries
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionaries are mutable mappings of keys to values. Keys must be hashable,
    but values can be any object:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是键值对的可变映射。键必须是可哈希的，但值可以是任何对象：
- en: '[PRE13]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Magic Dictionary Methods
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术字典方法
- en: '| Operation | Provided By | Result |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `key in d` | `__contains__` | Membership |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `key in d` | `__contains__` | 成员关系 |'
- en: '| `del d[key]` | `__delitem__` | Delete key |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `del d[key]` | `__delitem__` | 删除键 |'
- en: '| `d == d2` | `__eq__` | Equality. Dicts are equal or not equal |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `d == d2` | `__eq__` | 相等。字典相等或不相等 |'
- en: '| `"{}".format(d)` | `__format__` | String format of dict |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `"{}".format(d)` | `__format__` | 字典的字符串格式 |'
- en: '| `d[key]` | `__getitem__` | Get value for `key` (see `.get`) |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `d[key]` | `__getitem__` | 获取 `key` 的值（参见 `.get`） |'
- en: '| `for key in d:` | `__iter__` | Iteration over keys |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `for key in d:` | `__iter__` | 遍历键 |'
- en: '| `len(d)` | `__len__` | Length |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `len(d)` | `__len__` | 长度 |'
- en: '| `d != d2` | `__ne__` | Not equal |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `d != d2` | `__ne__` | 不相等 |'
- en: '| `repr(d)` | `__repr__` | Programmer friendly string |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `repr(d)` | `__repr__` | 程序员友好字符串 |'
- en: '| `d[key] = value` | `__setitem__` | Set `value` for `key` |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `d[key] = value` | `__setitem__` | 为 `key` 设置 `value` |'
- en: '| `d.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `d.__sizeof__()` | `__sizeof__` | 内部表示的字节 |'
- en: Dictionary Methods
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 字典方法
- en: '| Operation | Result |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `d.clear()` | Remove all items (mutates `d`) |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `d.clear()` | 移除所有项（改变 `d`） |'
- en: '| `d.copy()` | Shallow copy |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `d.copy()` | 浅拷贝 |'
- en: '| `d.fromkeys(iter, value=None)` | Create dict from iterable with values set
    to value |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `d.fromkeys(iter, value=None)` | 使用值设置为 `value` 创建字典 |'
- en: '| `d.get(key, [default])` | Get value for `key` or return default (`None`)
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `d.get(key, [default])` | 获取 `key` 的值或返回默认值（`None`） |'
- en: '| `d.items()` | View of (key, value) pairs |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `d.items()` | (键，值) 对的视图 |'
- en: '| `d.keys()` | View of keys |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `d.keys()` | 键的视图 |'
- en: '| `d.pop(key, [default])` | Return value for key or default (`KeyError` if
    not set) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `d.pop(key, [default])` | 返回键的值或默认值（如果未设置则引发 `KeyError`） |'
- en: '| `d.popitem()` | Return arbitrary (key, value) tuple. `KeyError` if empty
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `d.popitem()` | 返回任意（键，值）元组。如果为空则引发 `KeyError` |'
- en: '| `d.setdefault(k, [default])` | Does `d.get(k, default)`. If `k` missing,
    sets to default |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `d.setdefault(k, [default])` | 执行 `d.get(k, default)`。如果缺少 `k`，则设置为默认值 |'
- en: '| `d.update(d2)` | Mutate `d` with values of `d2` (dictionary or iterable of
    (key, value) pairs) |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `d.update(d2)` | 使用 `d2` 的值（字典或键值对的可迭代对象）改变 `d` |'
- en: '| `d.values()` | View of values |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `d.values()` | 值的视图 |'
- en: Tuples
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are immutable sequences. Typically they are used to store *record* type
    data:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是不可变序列。通常用于存储*记录*类型数据：
- en: '[PRE14]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that parentheses aren''t usually required:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意括号通常不是必需的：
- en: '[PRE15]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Named tuples can be used in place of normal tuples and allow context (or names)
    to be added to positional members. The syntax for creating them is a little different
    because we are dynamically creating a class first (hence the capitalized variable):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组可用于替代普通元组，并允许添加上下文（或名称）到位置成员。创建它们的语法有些不同，因为我们首先动态创建一个类（因此变量首字母大写）：
- en: '[PRE16]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can access members by position or name (name allows us to be more explicit):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过位置或名称访问成员（名称允许我们更加明确）：
- en: '[PRE17]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tuple Operations
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 元组操作
- en: '| Operation | Provided | Result |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `t + t2` | `__add__` | Tuple concatenation |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `t + t2` | `__add__` | 元组连接 |'
- en: '| `"name" in t` | `__contains__` | Membership |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `"name" in t` | `__contains__` | 成员关系 |'
- en: '| `t == t2` | `__eq__` | Equality |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `t == t2` | `__eq__` | 相等 |'
- en: '| `"{}".format(t)` | `__format__` | String format of tuple |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `"{}".format(t)` | `__format__` | 元组的字符串格式 |'
- en: '| `t >= t2` | `__ge__` | Greater or equal. Compares items in tuple from left
    |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `t >= t2` | `__ge__` | 大于或等于。从左边比较元组中的项 |'
- en: '| `t[idx]` | `__getitem__` | Index operation |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `t[idx]` | `__getitem__` | 索引操作 |'
- en: '| `t > t2` | `__gt__` | Greater. Compares items in tuple from left |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `t > t2` | `__gt__` | 大于。从左边比较元组中的项 |'
- en: '| `hash(t)` | `__hash__` | For set/dict insertion |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `hash(t)` | `__hash__` | 用于集合/字典插入 |'
- en: '| `for thing in t:` | `__iter__` | Iteration |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `for thing in t:` | `__iter__` | 迭代 |'
- en: '| `t <= t2` | `__le__` | Less than or equal. Compares items in tuple from left
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `t <= t2` | `__le__` | 小于或等于。从左边比较元组中的项 |'
- en: '| `len(t)` | `__len__` | Length |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `len(t)` | `__len__` | 长度 |'
- en: '| `t < t2` | `__lt__` | Less than. Compares items in tuple from left |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `t < t2` | `__lt__` | 小于。从左边比较元组中的项 |'
- en: '| `t * 2` | `__mul__` | Repetition |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `t * 2` | `__mul__` | 重复 |'
- en: '| `t != t2` | `__ne__` | Not equal |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `t != t2` | `__ne__` | 不相等 |'
- en: '| `repr(t)` | `__repr__` | Programmer friendly string |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `repr(t)` | `__repr__` | 程序员友好字符串 |'
- en: '| `foo * t` | `__rmul__` | Called if `foo` doesn''t implement `__mul__` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `foo * t` | `__rmul__` | 如果 `foo` 没有实现 `__mul__` 则调用 |'
- en: '| `t.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `t.__sizeof__()` | `__sizeof__` | 内部表示的字节 |'
- en: '| `str(l)` | `__str__` | User friendly string |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `str(l)` | `__str__` | 用户友好字符串 |'
- en: Tuple Methods
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 元组方法
- en: '| Operation | Result |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `t.count(item)` | Count of item |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `t.count(item)` | 项的计数 |'
- en: '| `t.index(thing)` | Index of `thing` else `ValueError` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `t.index(thing)` | `thing` 的索引，否则引发 `ValueError` |'
- en: Sets
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set is a mutable unordered collection that cannot contain duplicates. Sets
    are used to remove duplicates and test for membership:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个可变的无序集合，不能包含重复项。集合用于去除重复项和测试成员关系：
- en: '[PRE18]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Sets are useful because they provide *set operations*, such as union (`|`),
    intersection (`&`), difference (`-`), and xor (`^`):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 集合很有用，因为它们提供*集合操作*，如并集（`|`）、交集（`&`）、差集（`-`）和异或（`^`）：
- en: '[PRE19]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is no literal syntax for an empty set. You need to use:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 没有空集的文字语法。您需要使用：
- en: '[PRE20]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Set Operations
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作
- en: '| Operation | Provided By | Result |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `s & s2` | `__and__` | Set intersection (see `.intersection`) |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `s & s2` | `__and__` | 集合交集（参见`.intersection`） |'
- en: '| `"name" in s` | `__contains__` | Membership |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `"name" in s` | `__contains__` | 成员资格 |'
- en: '| `s == s2` | `__eq__` | Equality. Sets are equal or not equal |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `s == s2` | `__eq__` | 相等性。集合相等或不相等 |'
- en: '| `"{}".format(s)` | `__format__` | String format of set |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `"{}".format(s)` | `__format__` | 集合的字符串格式 |'
- en: '| `s >= s2` | `__ge__` | `s` in `s2` (see `.issuperset`) |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `s >= s2` | `__ge__` | `s`在`s2`中（参见`.issuperset`） |'
- en: '| `s > s2` | `__gt__` | Strict superset (`s >= s2` but `s != s2`). |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `s > s2` | `__gt__` | 严格超集（`s >= s2`但`s != s2`） |'
- en: '| No hash | `__hash__` | Set to `None` to ensure you can''t insert in dictionary
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 无哈希 | `__hash__` | 设为`None`以确保无法将其插入字典 |'
- en: '| `s &= s2` | `__iand__` | Augmented (mutates `s`) intersection (see `.intersection_update`)
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `s &= s2` | `__iand__` | 增强（改变`s`）的交集（参见`.intersection_update`） |'
- en: '| `s &#124;= s2` | `__ior__` | Augmented (mutates `s`) union (see `.update`)
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `s &#124;= s2` | `__ior__` | 增强（改变`s`）的并集（参见`.update`） |'
- en: '| `s -= s2` | `__isub__` | Augmented (mutates `s`) difference (see `.difference_update`)
    |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `s -= s2` | `__isub__` | 增强（改变`s`）的差集（参见`.difference_update`） |'
- en: '| `for thing in s:` | `__iter__` | Iteration |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `for thing in s:` | `__iter__` | 迭代 |'
- en: '| `s ^= s2` | `__ixor__` | Augmented (mutates `s`) xor (see `.symmetric_difference_update`)
    |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `s ^= s2` | `__ixor__` | 增强（改变`s`）的异或（参见`.symmetric_difference_update`） |'
- en: '| `s <= s2` | `__le__` | `s2` in `s` (see `.issubset`) |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `s <= s2` | `__le__` | `s`中的`s2`（参见`.issubset`） |'
- en: '| `len(s)` | `__len__` | Length |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `len(s)` | `__len__` | 长度 |'
- en: '| `s < s2` | `__lt__` | Strict subset (`s <= s2` but `s != s2`). |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `s < s2` | `__lt__` | 严格子集（`s <= s2`但`s != s2`） |'
- en: '| `s != s2` | `__ne__` | Not equal |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `s != s2` | `__ne__` | 不相等 |'
- en: '| `s &#124; s2` | `__or__` | Set union (see `.union`) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `s &#124; s2` | `__or__` | 集合并集（参见`.union`） |'
- en: '| `foo & s` | `__rand__` | Called if `foo` doesn''t implement `__and__` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `foo & s` | `__rand__` | 如果`foo`未实现`__and__`则调用 |'
- en: '| `repr(s)` | `__repr__` | Programmer friendly string |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `repr(s)` | `__repr__` | 程序员友好字符串 |'
- en: '| `foo &#124; s` | `__ror__` | Called if `foo` doesn''t implement `__or__`
    |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `foo &#124; s` | `__ror__` | 如果`foo`未实现`__or__`则调用 |'
- en: '| `foo - s` | `__rsub__` | Called if `foo` doesn''t implement `__sub__` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `foo - s` | `__rsub__` | 如果`foo`未实现`__sub__`则调用 |'
- en: '| `foo ^ s` | `__rxor__` | Called if `foo` doesn''t implement `__xor__` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `foo ^ s` | `__rxor__` | 如果`foo`未实现`__xor__`则调用 |'
- en: '| `s.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `s.__sizeof__()` | `__sizeof__` | 内部表示的字节 |'
- en: '| `str(s)` | `__str__` | User friendly string |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `str(s)` | `__str__` | 用户友好字符串 |'
- en: '| `s - s2` | `__sub__` | Set difference (see `.difference`) |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `s - s2` | `__sub__` | 集合差集（参见`.difference`） |'
- en: '| `s ^ s2` | `__xor__` | Set xor (see `.symmetric_difference`) |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `s ^ s2` | `__xor__` | 集合异或（参见`.symmetric_difference`） |'
- en: Set Methods
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 集合方法
- en: '| Operation | Result |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `s.add(item)` | Add `item` to `s` (mutates `s`) |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `s.add(item)` | 将`item`添加到`s`（改变`s`） |'
- en: '| `s.clear()` | Remove elements from `s` (mutates `s`) |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `s.clear()` | 从`s`中移除元素（改变`s`） |'
- en: '| `s.copy()` | Shallow copy |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `s.copy()` | 浅复制 |'
- en: '| `s.difference(s2)` | Return set with elements from `s` and not `s2` |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `s.difference(s2)` | 返回从`s`中获取的元素而不是`s2`的集合 |'
- en: '| `s.difference_update(s2)` | Remove `s2` items from `s` (mutates `s`) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `s.difference_update(s2)` | 从`s`中移除`s2`的项（改变`s`） |'
- en: '| `s.discard(item)` | Remove `item` from s (mutates `s`). No error on missing
    `item` |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `s.discard(item)` | 从`s`中移除`item`（改变`s`）。缺少`item`时不引发错误 |'
- en: '| `s.intersection(s2)` | Return set with elements from both sets |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `s.intersection(s2)` | 返回从两个集合中获取的元素的集合 |'
- en: '| `s.intersection_update(s2)` | Update `s` with members of `s2` (mutates `s`)
    |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `s.intersection_update(s2)` | 使用`s2`的成员更新`s`（改变`s`） |'
- en: '| `s.isdisjoint(s2)` | `True` if there is no intersection of these two sets
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdisjoint(s2)` | 如果这两个���合没有交集，则返回`True` |'
- en: '| `s.issubset(s2)` | `True` if all elements of `s` are in `s2` |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `s.issubset(s2)` | 如果`s`的所有元素都在`s2`中，则返回`True` |'
- en: '| `s.issuperset(s2)` | `True` if all elements of `s2` are in `s` |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `s.issuperset(s2)` | 如果`s`包含`s2`的所有元素，则返回`True` |'
- en: '| `s.pop()` | Remove arbitrary item from s (mutates `s`). `KeyError` on missing
    `item` |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop()` | 从`s`中移除任意项（改变`s`）。缺少`item`时引发`KeyError` |'
- en: '| `s.remove(item)` | Remove `item` from s (mutates `s`). `KeyError` on missing
    `item` |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(item)` | 从`s`中移除`item`（改变`s`）。缺少`item`时引发`KeyError` |'
- en: '| `s.symmetric_difference(s2)` | Return set with elements only in one of the
    sets |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `s.symmetric_difference(s2)` | 返回仅存在一个集合中的元素的集合 |'
- en: '| `s.symmetric_difference_update(s2)` | Update `s` with elements only in one
    of the sets (mutates `s`) |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `s.symmetric_difference_update(s2)` | 更新 `s`，仅使用一个集合中的元素（改变 `s`） |'
- en: '| `s.union(s2)` | Return all elements of both sets |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `s.union(s2)` | 返回两个集合的所有元素 |'
- en: '| `s.update(s2)` | Update `s` with all elements of both sets (mutates `s`)
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `s.update(s2)` | 更新 `s`，使用两个集合的所有元素（改变 `s`） |'
- en: Built in Functions
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置函数
- en: 'In the default namespace you have access to various callables:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认命名空间中，您可以访问各种可调用对象：
- en: Built in callables
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 内置可调用对象
- en: '| Operation | Result |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abs(x)` | Absolute value protocol (call `x.__abs__()`) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `abs(x)` | 绝对值协议（调用 `x.__abs__()`） |'
- en: '| `all(seq)` | Boolean check if all items in `seq` are truthy |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `all(seq)` | 检查 `seq` 中的所有项是否为真值 |'
- en: '| `any(seq)` | Boolean check if at least one item in `seq` is truthy |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `any(seq)` | 检查 `seq` 中是否至少有一项为真值 |'
- en: '| `ascii(x)` | ASCII representation of object |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `ascii(x)` | 对象的 ASCII 表示 |'
- en: '| `bin(i)` | String containing binary version of number (`int(bin(i), 2)` to
    reverse) |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `bin(i)` | 包含数字二进制版本的字符串（`int(bin(i), 2)` 可逆转） |'
- en: '| `bool(x)` | Boolean protocol (call `x.__bool__()`) |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `bool(x)` | 布尔协议（调用 `x.__bool__()`） |'
- en: '| `bytearray(x)` | Create a mutable bytearray from iterable of ints, text string,
    bytes, an integer, or pass nothing for an empty bytearray |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `bytearray(x)` | 从可迭代的整数、文本字符串、字节、整数中创建一个可变的字节数组，或者不传参数来创建一个空的字节数组 |'
- en: '| `bytes(x)` | Create an immutable bytes from iterable of ints, text string,
    bytes, an integer, or pass nothing for an empty bytes |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `bytes(x)` | 从可迭代的整数、文本字符串、字节、整数中创建一个不可变的字节，或者不传参数来创建一个空的字节 |'
- en: '| `callable(x)` | Boolean check if you can do `x()` (ie `x.__call__` exists)
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `callable(x)` | 检查是否可以执行 `x()`（即 `x.__call__` 是否存在） |'
- en: '| `chr(i)` | Convert integer codepoint to Unicode string (`ord(chr(i))` to
    reverse) |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `chr(i)` | 将整数码点转换为 Unicode 字符串（`ord(chr(i))` 可逆转） |'
- en: '| `@classmethod` | Use to decorate a method so you can invoke it on the class
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `@classmethod` | 用于装饰方法，以便您可以在类上调用它 |'
- en: '| `compile(source, fname, mode)` | Compile `source` to code (`fname` used for
    error, `mode` is `exec`: module, `single`: statement, `eval`: expression). Can
    run `eval(code)` on expression, `exec(code)` on statement |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `compile(source, fname, mode)` | 将 `source` 编译为代码（`fname` 用于错误，`mode` 为 `exec`：模块，`single`：语句，`eval`：表达式）。可以在表达式上运行
    `eval(code)`，在语句上运行 `exec(code)` |'
- en: '| `complex(i, y)` | Create complex number |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `complex(i, y)` | 创建复数 |'
- en: '| `copyright` | Python copyright string |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `copyright` | Python 的版权字符串 |'
- en: '| `credits` | Python credits string |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `credits` | Python 的致谢字符串 |'
- en: '| `delattr(obj, attr)` | Remove attribute from `obj` (`del obj.attr`) |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `delattr(obj, attr)` | 从 `obj` 中删除属性（`del obj.attr`） |'
- en: '| `dict([x])` | Create a dictionary from a mapping, iterable of k,v tuples,
    named parameters, or pass nothing for an empty dictionary |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `dict([x])` | 从映射、可迭代的 k,v 元组、命名参数中创建一个字典，或者不传参数来创建一个空字典 |'
- en: '| `dir([obj])` | List attributes of `obj`, or names in current namespace if
    no `obj` provided |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `dir([obj])` | 列出 `obj` 的属性，或者如果未提供 `obj` 则列出当前命名空间中的名称 |'
- en: '| `divmod(num, denom)` | Return tuple pair of `num//denom` and `num%denom`
    |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `divmod(num, denom)` | 返回 `num//denom` 和 `num%denom` 的元组对 |'
- en: '| `enumerate(seq, [start])` | Return iterator of index, item tuple pairs. Index
    begins at `start` or `0` (default) |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `enumerate(seq, [start])` | 返回索引、项元组对的迭代器。索引从 `start` 或 `0`（默认）开始 |'
- en: '| `eval(source, globals=None, locals=None)` | Run `source` (expression string
    or result of `compile`) with globals and locals |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `eval(source, globals=None, locals=None)` | 使用全局和局部变量运行 `source`（表达式字符串或
    `compile` 的结果） |'
- en: '| `exec(source, globals=None, locals=None)` | Run `source` (statement string
    or result of `compile`) with globals and locals |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `exec(source, globals=None, locals=None)` | 使用全局和局部变量运行 `source`（语句字符串或 `compile`
    的结果） |'
- en: '| `exit([code])` | Exit Python interpreter and return code (default 0) |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `exit([code])` | 退出 Python 解释器并返回代码（默认为 0） |'
- en: '| `filter([function], seq)` | Return iterator of items where `function(item)`
    is truthy (or `item` is truthy if `function` is missing) |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `filter([function], seq)` | 返回满足 `function(item)` 为真值的项的迭代器（如果缺少 `function`，则返回
    `item` 为真值的项的迭代器） |'
- en: '| `float(x)` | Convert string or number to float (call `x.__float__()`) |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `float(x)` | 将字符串或数字转换为浮点数（调用 `x.__float__()`） |'
- en: '| `format(obj, fmt)` | Format protocol (call `obj.__format__(fmt)`) |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `format(obj, fmt)` | 格式化协议（调用 `obj.__format__(fmt)`） |'
- en: '| `frozenset([seq])` | Create `frozenset` from `seq` (empty if missing) |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `frozenset([seq])` | 从 `seq` 创建 `frozenset`（如果缺少则为空） |'
- en: '| `getattr(obj, attr)` | Get attribute from `obj` (`obj.attr`) |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `getattr(obj, attr)` | 从 `obj` 获取属性（`obj.attr`） |'
- en: '| `globals()` | Return *mutable* dictionary with current global variables |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `globals()` | 返回当前全局变量的*可变*字典 |'
- en: '| `hasattr(obj, attr)` | Check if attribute on `obj` (`obj.attr` doesn''t throw
    `AttributeError`) |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `hasattr(obj, attr)` | 检查`obj`上的属性（`obj.attr`不会引发`AttributeError`） |'
- en: '| `hash(x)` | Hash value protocol for object (call `x.__hash__()`) |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `hash(x)` | 对象的哈希值协议（调用`x.__hash__()`） |'
- en: '| `help([x])` | Start interactive help (if no `x`), or print documentation
    for `x` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `help([x])` | 启动交互式帮助（如果没有`x`），或打印`x`的文档 |'
- en: '| `hex(i)` | String containing hexadecimal version of number (`int(hex(i),
    16)` to reverse) |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `hex(i)` | 包含数字的十六进制版本的字符串（`int(hex(i), 16)`进行反转） |'
- en: '| `id(x)` | Identity of `x` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `id(x)` | `x`的标识 |'
- en: '| `input([prompt])` | Read string from standard input |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `input([prompt])` | 从标准输入读取字符串 |'
- en: '| `int(x, [base=10])` | Create integer from number or string |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `int(x, [base=10])` | 从数字或字符串创建整数 |'
- en: '| `isinstance(obj, class_or_tuple)` | Boolean check if `obj` is an instance
    or subclass of `class_or_tuple` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `isinstance(obj, class_or_tuple)` | 检查`obj`是否是`class_or_tuple`的实例或子类的布尔值
    |'
- en: '| `issubclass(cls, class_or_tuple)` | Boolean check if `cls` is the class or
    derived from `class_or_tuple` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `issubclass(cls, class_or_tuple)` | 检查`cls`是否是类或派生自`class_or_tuple`的布尔值 |'
- en: '| `iter(seq)` | Iteration protocol (call `seq.__iter__()`) |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `iter(seq)` | 迭代协议（调用`seq.__iter__()`） |'
- en: '| `len(seq)` | Number of items in sequence |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `len(seq)` | 序列中的项目数 |'
- en: '| `license()` | Display Python licenses |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `license()` | 显示Python许可证 |'
- en: '| `list([seq])` | Convert `seq` to list (empty if missing) |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `list([seq])` | 将`seq`转换为列表（如果缺少则为空） |'
- en: '| `locals()` | Return dictionary of local attributes (unlike `globals`, not
    guaranteed to update namespace when mutated) |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `locals()` | 返回本地属性的字典（与`globals`不同，当被修改时不保证更新命名空间） |'
- en: '| `map(function, *seqs)` | Call `function(item)` for item in `seqs` (if single
    sequence) or `function(seqs[0][0], seqs[1][0]...)` |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `map(function, *seqs)` | 对`seqs`中的项目调用`function(item)`（如果是单个序列）或`function(seqs[0][0],
    seqs[1][0]...)` |'
- en: '| `max(seq, *, [default], [key])` | Return maximum value from `seq`. `default`
    (value if empty `seq`) and `key` (function to determine magnitude) are keyword
    parameters. |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `max(seq, *, [default], [key])` | 从`seq`中返回最大值。`default`（如果`seq`为空时的值）和`key`（确定大小的函数）是关键字参数。
    |'
- en: '| `memoryview(obj)` | Create `memoryview` from `obj` |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `memoryview(obj)` | 从`obj`创建`memoryview` |'
- en: '| `min(seq, *, [default], [key])` | Return minimum value from `seq`. `default`
    (value if empty `seq`) and `key` (function to determine magnitude) are keyword
    parameters. |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `min(seq, *, [default], [key])` | 从`seq`中返回最小值。`default`（如果`seq`为空时的值）和`key`（确定大小的函数）是关键字参数。
    |'
- en: '| `next(iter, [default])` | Get next item from iteration protocol (call `iter.__next__()`),
    if `default` provide return instead of raising `StopIteration` |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `next(iter, [default])` | 从迭代协议中获取下一个项目（调用`iter.__next__()`），如果提供`default`则返回而不是引发`StopIteration`
    |'
- en: '| `object` | Root base type |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `object` | 根基类型 |'
- en: '| `oct(i)` | String containing octal version of number (`int(oct(i), 8)` to
    reverse) |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `oct(i)` | 包含数字的八进制版本的字符串（`int(oct(i), 8)`进行反转） |'
- en: '| `open(filename, [mode], [encoding], [errors])` | Open a file |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `open(filename, [mode], [encoding], [errors])` | 打开文件 |'
- en: '| `ord(s)` | Convert Unicode string to integer codepoint (`chr(ord(s))` to
    reverse) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `ord(s)` | 将Unicode字符串转换为整数码点（`chr(ord(s))`进行反转） |'
- en: '| `pow(num, exp, [z])` | Power protocol (call `num.__pow__(exp, z)`) (`num
    ** exp` or `num ** exp % z`) |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `pow(num, exp, [z])` | 幂协议（调用`num.__pow__(exp, z)`）（`num ** exp`或`num **
    exp % z`） |'
- en: '| `print(val, [val2 ...], *, sep='' '', end=''\n'', file=sys.stdout)` | Print
    values to `file`. Print protocol (call `val.__str__()`) |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `print(val, [val2 ...], *, sep='' '', end=''\n'', file=sys.stdout)` | 将值打印到`file`。打印协议（调用`val.__str__()`）
    |'
- en: '| `@property` | Decorator to turn a method into an attribute |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `@property` | 将方法转换为属性的装饰器 |'
- en: '| `quit()` | Quit interpreter |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `quit()` | 退出解释器 |'
- en: '| `range([start], stop, [step])` | Return range object that iterates from `start`
    (default `0`) to `stop - 1`, by `step` increments (default `1`) |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `range([start], stop, [step])` | 返回迭代从`start`（默认为`0`）到`stop - 1`，以`step`增量（默认为`1`）的范围对象
    |'
- en: '| `repr(x)` | Representation protocol (call `x.__repr__()`) |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `repr(x)` | 表示协议（调用`x.__repr__()`） |'
- en: '| `reversed(seq)` | Reverse iterator |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `reversed(seq)` | 反向迭代器 |'
- en: '| `round(num, [ndigits=0])` | Round to `ndigits` protocol (call `num.__round__()`)
    |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `round(num, [ndigits=0])` | 四舍五入到`ndigits`协议（调用`num.__round__()`） |'
- en: '| `set([seq])` | Create `set` from `seq` (empty if missing) |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `set([seq])` | 从`seq`创建`set`（如果缺少则为空） |'
- en: '| `setattr(obj, attr, val)` | Set attribute on `obj` (`obj.attr = val`) |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `setattr(obj, attr, val)` | 在`obj`上设置属性（`obj.attr = val`） |'
- en: '| `slice([start], stop, [step])` | Create `slice` object |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `slice([start], stop, [step])` | 创建`slice`对象 |'
- en: '| `sorted(seq, * [key=None], [reverse=False])` | Sorted list in ascending order
    (use `key` function to customize sort property) |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `sorted(seq, * [key=None], [reverse=False])` | 按升序排序的排序列表（使用`key`函数自定义排序属性）
    |'
- en: '| `@staticmethod` | Use to decorate a method so you can invoke it on the class
    or instance |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `@staticmethod` | 用于修饰方法，以便您可以在类或实例上调用它 |'
- en: '| `str(obj)` | Create string (call `obj.__str__()`) |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `str(obj)` | 创建字符串（调用`obj.__str__()`） |'
- en: '| `str(bytes, [encoding], [errors])` | Create string from bytes (`errors` defaults
    to `strict`) |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `str(bytes, [encoding], [errors])` | 从字节创建字符串（`errors`默认为`strict`） |'
- en: '| `sum(seq, [start=0])` | Sum values from `seq` (use `start` as initial value)
    |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `sum(seq, [start=0])` | 对`seq`中的值求和（使用`start`作为初始值） |'
- en: '| `super()` | Get access to superclass |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `super()` | 获取超类访问权限 |'
- en: '| `tuple([seq])` | Convert `seq` to tuple (empty if missing) |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `tuple([seq])` | 将`seq`转换为元组（如果缺失则为空） |'
- en: '| `type(name, bases, dict)` | Create a new type of `name`, with base classes
    `bases`, and attributes `dict` |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `type(name, bases, dict)` | 创建一个名为`name`的新类型，具有基类`bases`和属性`dict` |'
- en: '| `type(obj)` | Return type of `obj` |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `type(obj)` | 返回`obj`的类型 |'
- en: '| `vars([obj])` | Return `obj.__dict__` or `locals()` if missing |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `vars([obj])` | 返回`obj.__dict__`或如果缺失则返回`locals()` |'
- en: '| `zip(seq1, [seq2, ...])` | Return iterable of tuples of `(seq1[0], seq2[0])`,
    `(seq1[1], seq2[1])`, ... until shortest sequence |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `zip(seq1, [seq2, ...])` | 返回元组的可迭代对象，如`(seq1[0], seq2[0])`，`(seq1[1], seq2[1])`，...直到最短序列
    |'
- en: Unicode
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode
- en: 'Python 3 represents strings as Unicode. We can *encode* strings to a series
    of bytes such as UTF-8\. If we have bytes, we can *decode* them to a Unicode string:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3将字符串表示为Unicode。我们可以将字符串*编码*为一系列字节，例如UTF-8。如果我们有字节，我们可以将其*解码*为Unicode字符串：
- en: '[PRE21]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you have the unicode glyph, you can use that directly. Alternatively, you
    can enter a code point using `\u` followed by the 16-bit hex value xxxx. For larger
    code points, use `\U` followed by xxxxxxxx. If you have the Unicode name (obtained
    by consulting tables at unicode.org), you can use the `\N` syntax. The following
    are equivalent:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有Unicode字符，可以直接使用。或者，您可以使用`\u`后跟16位十六进制值xxxx输入代码点。对于更大的代码点，请使用`\U`后跟xxxxxxxx。如果您有Unicode名称（通过在unicode.org上查看表格获得），您可以使用`\N`语法。以下是等效的：
- en: '[PRE22]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![../Images/uniencode.png](../Images/uniencode.png)](../Images/uniencode.png)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/uniencode.png](../Images/uniencode.png)](../Images/uniencode.png)'
- en: Image illustrating *encoding* a Unicode string to a byte representation. In
    this case, we convert to UTF-8\. There are other byte encodings for this string.
    If we have a UTF-8 byte string, we can *decode* it into a Unicode string. Note
    that we should be explicit about the decoding as there are potentially other encodings
    that we could decode to that might give the user erroneous data, or *mojibake*.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 插图说明了将Unicode字符串编码为字节表示。在这种情况下，我们转换为UTF-8。对于此字符串，还有其他字节编码。如果我们有一个UTF-8字节字符串，我们可以将其*解码*为Unicode字符串。请注意，我们应该明确解码，因为可能有其他编码可以解码为可能给用户错误数据或*乱码*的Unicode字符串。
- en: String Formatting
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: Most modern Python code uses the `.format` method (PEP 3101) to create strings
    from other parts. The format method uses `{}` as a placeholder.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代Python代码使用`.format`方法（PEP 3101）从其他部分创建字符串。格式方法使用`{}`作为占位符。
- en: 'Inside of the placeholder we can provide different specifiers:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在占位符内部，我们可以提供不同的说明符：
- en: '`{0}` - reference first positional argument'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{0}` - 引用第一个位置参数'
- en: '`{}` - reference implicit positional argument'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}` - 引用隐式位置参数'
- en: '`{result}` - reference keyword argument'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{result}` - 引用关键字参数'
- en: '`{bike.tire}` - reference attribute of argument'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{bike.tire}` - 引用参数的属性'
- en: '`{names[0]}` - reference first element of argument'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{names[0]}` - 引用参数的第一个元素'
- en: '[PRE23]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'or:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE24]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also use *f-strings* in Python 3.6 (see PEP 498):'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Python 3.6中使用*f-strings*（参见PEP 498）：
- en: '[PRE25]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: F-strings inspect variables that are available and allow you to inline methods,
    or attributes from those variables.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: F-strings检查可用的变量并允许您内联方法或属性来自这些变量。
- en: Conversion Flags
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换标志
- en: You can provide a *conversion flag* inside the placeholder.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在占位符内部提供*转换标志*。
- en: '`!s` - Call `str()` on argument'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!s` - 对参数调用`str()`函数'
- en: '`!r` - Call `repr()` on argument'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!r` - 对参数调用`repr()`函数'
- en: '`!a` - Call `ascii()` on argument'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!a` - 对参数调用`ascii()`函数'
- en: '[PRE26]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Format Specification
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式规范
- en: 'You can provide a format specification following a colon. The grammar for format
    specification is as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在冒号后提供格式规范。格式规范的语法如下：
- en: '[PRE27]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The following table lists the field meanings.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表列出了字段含义。
- en: '| Field | Meaning |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| Field | 含义 |'
- en: '| --- | --- |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| fill | Fills in space with `align` |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| fill | 使用`align`填充空格 |'
- en: '| align | `<`-left align, `>`-right align, `^`-center align, `=`-put padding
    after sign |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 对齐 | `<`-左对齐，`>`-右对齐，`^`-居中对齐，`=`-在符号后放置填充 |'
- en: '| sign | `+`-for all number, `-`-only negative, *space*-leading space for positive,
    sign on negative |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | `+`-对所有数字，`-`-仅负数，*空格*-正数前导空格，负数带符号 |'
- en: '| # | Prefix integers. `Ob`-binary, `0o`-octal, `0x`-hex |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| # | 整数前缀。`Ob`-二进制，`0o`-八进制，`0x`-十六进制 |'
- en: '| 0 | Enable zero padding |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 启用零填充 |'
- en: '| width | Minimum field width |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| 宽度 | 最小字段宽度 |'
- en: '| grouping_option | `,`-Use comma for thousands separator, `_`-Use underscore
    for thousands separator |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 分组选项 | `,`-使用逗号作为千位分隔符，`_`-使用下划线作为千位分隔符 |'
- en: '| .precision | Digits after period (floats). Max string length (non-numerics)
    |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| .精度 | 小数点后的数字（浮点数）。最大字符串长度（非数字） |'
- en: '| type | `s`-string format (default) see Integer and Float charts |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | `s`-字符串格式（默认）参见整数和浮点图表 |'
- en: The tables below lists the various options we have for formatting integer and
    floating point numbers.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了我们用于格式化整数和浮点数的各种选项。
- en: '| Integer Types | Meaning |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: 整数类型 | ���义 |
- en: '| --- | --- |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `b` | binary |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 二进制 |'
- en: '| `c` | character - convert to unicode character |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 字符 - 转换为 Unicode 字符 |'
- en: '| `d` | decimal (default) |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 十进制（默认） |'
- en: '| `n` | decimal with locale specific separators |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 具有特定区域设置分隔符的十进制 |'
- en: '| `o` | octal |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| `o` | 八进制 |'
- en: '| `x` | hex (lower-case) |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 十六进制（小写） |'
- en: '| `X` | hex (upper-case) |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 十六进制（大写） |'
- en: '| Float Types | Meaning |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| 浮点类型 | 含义 |'
- en: '| --- | --- |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `e`/`E` | Exponent. Lower/upper-case e |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `e`/`E` | 指数。小写/大写 e |'
- en: '| `f` | Fixed point |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 固定点 |'
- en: '| `g`/`G` | General. Fixed with exponent for large, and small numbers (`g`
    default) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `g`/`G` | 通用。对于大数和小数，固定带指数（`g` 默认） |'
- en: '| `n` | `g` with locale specific separators |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 具有特定区域设置分隔符的 `g` |'
- en: '| `%` | Percentage (multiplies by 100) |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 百分比（乘以 100） |'
- en: Some `format` Examples
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些 `format` 示例
- en: 'Here are a few examples of using `.format`. Let’s format a string in the center
    of 12 characters surrounded by `*`. `*` is the *fill* character, `^` is the *align*
    field, and `12` is the *width* field:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用 `.format` 的示例。让我们将一个字符串格式化为 12 个字符的中心，周围包围着 `*`。`*` 是*填充*字符，`^` 是*对齐*字段，`12`
    是*宽度*字段：
- en: '[PRE28]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we format a percentage using a width of 10, one decimal place and the
    sign before the width padding. `=` is the *align* field, `10.1` are the *width*
    and *precision* fields, and `%` is the *float type*, which converts the number
    to a percentage:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用宽度为 10、一位小数点和符号在宽度填充之前的百分比格式化。`=` 是*对齐*字段，`10.1` 是*宽度*和*精度*字段，`%` 是*浮点类型*，将数字转换为百分比：
- en: '[PRE29]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Below is a binary and a hex conversion. The *integer type* field is set to
    `b` and `x` respectively:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个二进制和十六进制转换。*整数类型*字段分别设置为 `b` 和 `x`：
- en: '[PRE30]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Files
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件
- en: 'The `open` function will take a file path and mode as input and return a file
    handle. There are various modes to open a file, depending on the content and your
    needs. If you open the file in binary mode, you will get bytes out. In text mode
    you will get strings back:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 函数将接受文件路径和模式作为输入，并返回一个文件句柄。有各种模式可以打开文件，取决于内容和您的需求。如果以二进制模式打开文件，将得到字节输出。在文本模式下，将得到字符串返回：'
- en: File Modes
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 文件模式
- en: '| Mode | Meaning |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `''r''` | Read text file (default) |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| `''r''` | 读取文本文件（默认） |'
- en: '| `''w''` | Write text file (truncates if exists) |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| `''w''` | 写入文本文件（如果存在则截断） |'
- en: '| `''x''` | Write text file, throw `FileExistsError` if exists. |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| `''x''` | 写入文本文件，如果存在则抛出 `FileExistsError`。 |'
- en: '| `''a''` | Append to text file (write to end) |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `''a''` | 追加到文本文件（写入末尾） |'
- en: '| `''rb''` | Read binary file |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| `''rb''` | 读取二进制文件 |'
- en: '| `''wb''` | Write binary (truncate) |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| `''wb''` | 写入二进制文件（截断） |'
- en: '| `''w+b''` | Open binary file for reading and writing |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| `''w+b''` | 以读写方式打开二进制文件 |'
- en: '| `''xb''` | Write binary file, throw `FileExistsError` if exists. |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| `''xb''` | 写入二进制文件，如果存在则抛出 `FileExistsError`。 |'
- en: '| `''ab''` | Append to binary file (write to end) |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| `''ab''` | 追加到二进制文件（写入末尾） |'
- en: Writing Files
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入文件
- en: We use a context manager with a file to ensure that the file is closed when
    the context block exits.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用文件的上下文管理器来确保在上下文块退出时关闭文件。
- en: '[PRE31]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Reading Files
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'With an opened text file, you can iterate over the lines. This saves memory
    as the lines are read in as needed:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开的文本文件，您可以迭代读取行。这样可以节省内存，因为只在需要时读取行：
- en: '[PRE32]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: File Methods
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 文件方法
- en: '| Operation | Result |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `f.__iter__()` | Support iteration |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `f.__iter__()` | 支持迭代 |'
- en: '| `f.__next__()` | Return next item of iteration (line in text) |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `f.__next__()` | 返回迭代的下一个项目（文本中的行） |'
- en: '| `f.__repr__()` | Implementation for `repr(f)` |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| `f.__repr__()` | `repr(f)` 的实现 |'
- en: '| `f.buffer` | File buffer |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `f.buffer` | 文件缓冲 |'
- en: '| `f.close()` | Close file |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `f.close()` | 关闭文件 |'
- en: '| `f.closed` | Is closed |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `f.closed` | 是否已关闭 |'
- en: '| `f.detach()` | Detach file buffer from file |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `f.detach()` | 将文件缓冲从文件中分离 |'
- en: '| `f.encoding` | The encoding of the file (default is `locale.getpreferredencoding()`)
    |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `f.encoding` | 文件的编码（默认为 `locale.getpreferredencoding()`） |'
- en: '| `f.errors` | Error mode of encoding (`''strict''` default) |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `f.errors` | 编码的错误模式（`''strict''` 默认） |'
- en: '| `f.fileno()` | Return file descriptor |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `f.fileno()` | 返回文件描述符 |'
- en: '| `f.flush()` | Write file buffer |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `f.flush()` | 写文件缓冲 |'
- en: '| `f.isatty()` | Is interactive file |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| `f.isatty()` | 是否为交互式文件 |'
- en: '| `f.linebuffering` | Buffered by lines |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| `f.linebuffering` | 逐行缓冲 |'
- en: '| `f.name` | Name of file |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| `f.name` | 文件名 |'
- en: '| `f.newlines` | End of line characters encountered (tuple or string) |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| `f.newlines` | 遇到的行尾字符（元组或字符串） |'
- en: '| `f.read( size=-1)` | Read `size` characters (`-1` is whole file) |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| `f.read( size=-1)` | 读取 `size` 个字符（`-1` 是整个文件） |'
- en: '| `f.readable()` | Is opened for reading |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| `f.readable()` | 是否已打开以供读取 |'
- en: '| `f.readline( size=-1)` | Read `size` characters from line (`-1` is whole
    line) |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| `f.readline( size=-1)` | 从行中读取 `size` 个字符（`-1` 是整行） |'
- en: '| `f.readlines( hint=-1)` | Read bytes less than `hint` characters of lines
    from file (`-1` is all file) |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| `f.readlines( hint=-1)` | 从文件中读取不超过 `hint` 字符的行的字节（`-1` 是整个文件） |'
- en: '| `f.seek(cookie, whence=0)` | Change stream location to `cookie` bytes (may
    be negative) offset from `whence` (`0` - start, `1` - current position, `2` -
    end). |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `f.seek(cookie, whence=0)` | 将流位置更改为距离 `whence` (`0` - 开始，`1` - 当前位置，`2`
    - 结尾) `cookie` 字节（可以为负）。 |'
- en: '| `f.seekable()` | File supports random access |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| `f.seekable()` | 文件支持随机访问 |'
- en: '| `f.tell()` | Current stream location |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `f.tell()` | 当前流位置 |'
- en: '| `f.truncate( pos=None)` | Truncate file to `pos` bytes |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| `f.truncate( pos=None)` | 将文件截断为 `pos` 字节 |'
- en: '| `f.writeable()` | File supports writing |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `f.writeable()` | 文件支持写入 |'
- en: '| `f.write(text)` | Write `text` to file |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `f.write(text)` | 将 `text` 写入文件 |'
- en: '| `f.writelines( lines)` | Write `lines` to file (provide newlines if you want
    them) |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `f.writelines( lines)` | 将 `lines` 写入文件（如果需要，提供换行符） |'
- en: Functions
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Defining functions
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'Functions may take input, do some processing, and return output. You can provide
    a docstring directly following the name and parameters of the function:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能接受输入，进行一些处理，并返回输出。你可以在函数名称和参数后直接提供文档字符串：
- en: '[PRE33]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We use whitespace to specify a block in Python. We typically indent following
    a colon. PEP 8 recommends using 4 spaces. Don't mix tabs and spaces.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用空格来指定 Python 中的块。我们通常在冒号后缩进。PEP 8 建议使用 4 个空格。不要混用制表符和空格。
- en: 'We can create anonymous functions using the `lambda` statement. Because they
    only allow an expression following the colon, it is somewhat crippled in functionality.
    They are commonly used as a `key` argument to `sorted`, `min`, or `max`:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `lambda` 语句创建匿名函数。因为它们只允许在冒号后跟表达式，所以在功能上有些受限。它们通常作为 `sorted`、`min` 或
    `max` 的 `key` 参数使用：
- en: '[PRE34]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Functions can have *default* arguments. Be careful with mutable types here,
    as the default is bound to the function when the function is created, not when
    it is called:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有 *默认* 参数。在这里要注意可变类型，因为默认值是在函数创建时绑定的，而不是在调用时：
- en: '[PRE35]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Functions can support variable positional arguments:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以支持可变位置参数：
- en: '[PRE36]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Functions can support variable keyword arguments:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以支持可变关键字参数：
- en: '[PRE37]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can indicate the end of positional parameters by using a single `*`. This
    gives you *keyword only* parameters (PEP 3102):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用单个 `*` 来指示位置参数的结束。这给了你 *仅关键字* 参数（PEP 3102）：
- en: '[PRE38]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Calling Functions
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'You can also use `*` and `**` to *unpack* sequence and dictionary arguments:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `*` 和 `**` 来 *解包* 序列和字典参数：
- en: '[PRE39]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following two examples are the equivalent:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个例子是等价的：
- en: '[PRE40]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following two examples are the equivalent:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个例子是等价的：
- en: '[PRE41]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also combine `*` and `**` on invocation:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在调用时结合使用 `*` 和 `**`：
- en: '[PRE42]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Getting Help
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取帮助
- en: 'You can get help on a function that has a docstring by using `help`:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `help` 来获取有文档字符串的函数的帮助：
- en: '[PRE43]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Classes
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'Python supports object oriented programming but doesn''t require you to create
    classes. You can use the built-in data structures to great effect. Here''s a class
    for a simple bike. The class attribute, `num_passengers`, is shared for all instances
    of `Bike`. The instance attributes, `size` and `ratio`, are unique to each instance:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持面向对象编程，但不要求你创建类。你可以有效地使用内置数据结构。这是一个简单自行车的类。类属性 `num_passengers` 对于
    `Bike` 的所有实例都是共享的。实例属性 `size` 和 `ratio` 对于每个实例都是唯一的：
- en: '[PRE44]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can call the constructor (`__init__`), by invoking the class name. Note
    that `self` is the instance, but Python passes that around for us automatically:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用类名来调用构造函数（`__init__`）。请注意，`self`是实例，但Python会自动为我们传递它：
- en: '[PRE45]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can access both class attributes and instance attributes on the instance:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在实例上访问类属性和实例属性：
- en: '[PRE46]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If an attribute is not found on the instance, Python will then look for it on
    the class, it will look through the parent classes to continue to try and find
    it. If the lookup is unsuccessful, an `AttributeError` is raised.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在实例上找不到属性，则Python将在类上查找它，它将继续查找父类以继续尝试找到它。如果查找不成功，将引发`AttributeError`。
- en: Subclasses
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类
- en: 'To subclass a class, simply place the parent class name in parentheses following
    the class name in the declaration. We can call the `super` function to gain access
    to parent methods:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 要对一个类进行子类化，只需在声明中的类名后面用括号括起父类名。我们可以调用`super`函数来访问父类方法：
- en: '[PRE47]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the above example, we used a `\` to indicate that the line continued on the
    following line. This is usually required unless there is an implicit line continuation
    with an opening brace that hasn't been closed (`(`, `[`, or `{`).
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用`\`表示该行在下一行继续。这通常是必需的，除非有一个未关闭的括号（`(`、`[`或`{`）具有隐式的行继续。
- en: 'The instance of the subclass can call methods that are defined on its class
    or the parent class:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 子类的实例可以调用在其类或父类上定义的方法：
- en: '[PRE48]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Class Methods and Static Methods
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法和静态方法
- en: 'The `classmethod` decorator is used to create methods that you can invoke directly
    on the class. This allows us to create alternate constructors. Note that the implicit
    first argument is the class, commonly named `cls` (as `class` is a keyword and
    will error out):'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`classmethod`装饰器用于创建可以直接在类上调用的方法。这允许我们创建替代构造函数。请注意，隐式的第一个参数是类，通常命名为`cls`（因为`class`是一个关键字，会报错）：'
- en: '[PRE49]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the above example, we had an implicit line continuation without a backslash,
    because there was a `(` on the line.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们有一个隐式的行继续，没有反斜杠，因为该行有一个`(`。
- en: 'The `staticmethod` decorator lets you attach functions to a class. (I don''t
    like them, just use a function). Note that they don''t get an implicit first argument.
    It can be called on the instance or the class:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`staticmethod` 装饰器允许你将函数附加到一个类上。（我不喜欢它们，只需使用一个函数）。请注意，它们不会获得隐式的第一个参数。它可以在实例或类上调用：'
- en: '[PRE50]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Properties
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'If you want to have actions occur under the covers on attribute access, you
    can use properties to do that:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在属性访问时执行操作，可以使用属性来实现：
- en: '[PRE51]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Rather than calling the `.name()` method, we access the attribute:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是调用`.name()`方法，我们访问属性：
- en: '[PRE52]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Looping
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'You can loop over objects in a sequence:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遍历序列中的对象：
- en: '[PRE53]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `break` statement will pop you out of a loop:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句将使你跳出循环：'
- en: '[PRE54]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `continue` statement skips over the body of the loop and *continues* at
    the next item of iteration:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句跳过循环体并在下一个迭代项继续：'
- en: '[PRE55]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can use the `else` statement to indicate that every item was looped over,
    and a `break` was never encountered:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`else`语句来指示每个项目都被循环遍历，并且从未遇到`break`：
- en: '[PRE56]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Don''t loop over index values (`range(len(names))`). Use `enumerate`:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 不要遍历索引值（`range(len(names))`）。使用`enumerate`：
- en: '[PRE57]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`while` Loops'
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: 'You can use `while` loops to create loops as well. If it is an infinite loop,
    you can break out of it:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`while`循环来创建循环。如果是无限循环，你可以跳出它：
- en: '[PRE58]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Iteration Protocol
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代协议
- en: 'To make an iterator implement `__iter__` and `__next__`:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 要使迭代器实现`__iter__`和`__next__`：
- en: '[PRE59]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Use the iterator in a loop:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中使用迭代器：
- en: '[PRE60]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Unrolling the protocol:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 展开协议：
- en: '[PRE61]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Conditionals
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Python has an `if` statement with zero or more `elif` statements, and an optional
    `else` statement at the end. In Python, the word `elif` is Dutch for *else if*:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个带有零个或多个`elif`语句的`if`语句，并在末尾可选的`else`语句。在Python中，`elif`一词是荷兰语的*else
    if*：
- en: '[PRE62]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Python supports the following tests: `>`, `>=`, `<`, `<=`, `==`, and `!=`.
    For boolean operators use `and`, `or`, and `not` (`&`, `|`, and `^` are the bitwise
    operators).'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持以下测试：`>`, `>=`, `<`, `<=`, `==` 和 `!=`。对于布尔运算符使用`and`、`or`和`not`（`&`、`|`和`^`是位运算符）。
- en: 'Note that Python also supports *range comparisons*:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python还支持*范围比较*：
- en: '[PRE63]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Python does not have a switch statement, often dictionaries are used to support
    a similar construct:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有switch语句，通常使用字典来支持类似的结构：
- en: '[PRE64]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Truthiness
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真值性
- en: You can define the `__bool__` method to teach your classes how to act in a boolean
    context. If that doesn't exists, Python will use `__len__`, and finally default
    to `True`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义`__bool__`方法来教导您的类在布尔上下文中如何行事。如果不存在，Python将使用`__len__`，最后默认为`True`。
- en: 'The following table lists *truthy* and *falsey* values:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表列出了*真值*和*假值*：
- en: '| Truthy | Falsey |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| 真值 | 假值 |'
- en: '| --- | --- |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `True` | `False` |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| `True` | `False` |'
- en: '| Most objects | `None` |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| 大多数对象 | `None` |'
- en: '| `1` | `0` |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` |'
- en: '| `3.2` | `0.0` |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| `3.2` | `0.0` |'
- en: '| `[1, 2]` | `[]` (empty list) |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| `[1, 2]` | `[]`（空列表） |'
- en: '| `{''a'': 1, ''b'': 2}` | `{}` (empty dict) |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| `{''a'': 1, ''b'': 2}` | `{}`（空字典） |'
- en: '| `''string''` | `""` (empty string) |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| `''string''` | `""`（空字符串） |'
- en: '| `''False''` |   |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| `''False''` |   |'
- en: '| `''0''` |   |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| `''0''` |   |'
- en: Short Circuiting
  id: totrans-654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短路
- en: 'The `and` statement will short circuit if it evaluates to false:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`and`语句评估为假，它将短路：
- en: '[PRE65]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Likewise, the `or` statement will short circuit when something evaluates to
    true:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当某些条件为真时，`or`语句会短路：
- en: '[PRE66]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Ternary Operator
  id: totrans-659
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三元操作符
- en: 'Python has its own ternary operator, called a *conditional expression* (see
    PEP 308). These are handy as they can be used in comprehension constructs and
    `lambda` functions:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: Python有自己的三元操作符，称为*条件表达式*（参见PEP 308）。这些很方便，因为它们可以在推导构造和`lambda`函数中使用：
- en: '[PRE67]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that this has similar behavior to an `if` statement, but it is an expression,
    and not a statement. Python distinguishes these two. An easy way to determine
    between the two, is to remember that an expression follows a `return` statement.
    Anything you can `return` is an expression.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与`if`语句具有类似的行为，但它是一个表达式，而不是语句。Python区分这两者。区分两者的简单方法是记住表达式跟随`return`语句。任何你可以`return`的东西都是表达式。
- en: Exceptions
  id: totrans-663
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'Python can catch one or more exceptions (PEP 3110). You can provide a chain
    of different exceptions to catch if you want to react differently. A few hints:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以捕获一个或多个异常（PEP 3110）。如果您希望以不同方式做出反应，可以提供一系列不同的异常来捕获。一些建议：
- en: Try to keep the block of the `try` statement down to the code that throws exceptions
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量将`try`语句块限制在可能引发异常的代码范围内
- en: Be specific about the exceptions that you catch
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对捕获的异常要具体明确
- en: If you want to inspect the exception, use `as` to create a variable to point
    to it
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想检查异常，请使用`as`创建一个指向它的变量
- en: If you use a bare `raise` inside of an `except` block, Python's traceback will
    point back to the location of the original exception, rather than where it is
    raised from.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`except`块内部使用裸`raise`，Python的回溯将指向原始异常的位置，而不是引发异常的位置。
- en: '[PRE68]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Raising Exceptions
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'You can raise an exception using the `raise` statement (PEP 3109):'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`raise`语句引发异常（PEP 3109）：
- en: '[PRE69]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Decorators
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'A decorator (PEP 318) allows us to insert logic before and after a function
    is called. You can define a decorator with a function that takes a function as
    input and returns a function as output. Here is the identity decorator:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器（PEP 318）允许我们在调用函数之前和之后插入逻辑。您可以定义一个接受函数作为输入并返回函数作为输出的函数作为装饰器。这是身份装饰器：
- en: '[PRE70]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can decorate a function with it like this:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样用它装饰一个函数：
- en: '[PRE71]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A more useful decorator can inject logic before and after calling the original
    function. To do this we create a function inside of the function and return that:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有用的装饰器可以在调用原始函数之前和之后注入逻辑。为此，我们在函数内部创建一个函数并返回它：
- en: '[PRE72]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Above, we use print functions to illustrate before/after behavior, otherwise
    this is very similar to identity decorator.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们使用打印函数来说明前后行为，否则这与身份装饰器非常相似。
- en: 'There is a special syntax for applying the decorator. We put `@` before the
    decorator name and place that on a line directly above the function we wish to
    decorate. Using the `@verbose` line before a function declaration is syntactic
    sugar for re-assigning the variable pointing to the function to the result of
    calling the decorator with the function passed into it:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的语法用于应用装饰器。我们在要装饰的函数正上方的一行上放置`@`，然后将其放在函数声明之前。在函数声明之前使用`@verbose`行是为了将指向函数的变量重新分配为调用装饰器并将函数传递给它的结果：
- en: '[PRE73]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This could also be written as, `sub = verbose(sub)`. Note that our decorated
    function will still call our original function, but add in some `print` statements:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成`sub = verbose(sub)`。请注意，我们的装饰函数仍将调用我们的原始函数，但会添加一些`print`语句：
- en: '[PRE74]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Parameterized Decorators
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化装饰器
- en: 'Because we can use closures to create functions, we can use closures to create
    decorators as well. This is very similar to our decorator above, but now we make
    a function that will return a decorator. Based on the inputs to that function,
    we can control (or parameterize) the behavior of the decorator:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们可以使用闭包来创建函数，我们也可以使用闭包来创建装饰器。这与我们上面的装饰器非常相似，但现在我们创建一个将返回装饰器的函数。根据该函数的输入，我们可以控制（或参数化）装饰器的行为：
- en: '[PRE75]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When you decorate with parameterized decorators, the decoration looks differently,
    because we need to invoke the function to create a decorator:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用带参数的装饰器装饰时，装饰看起来会有所不同，因为我们需要调用函数来创建装饰器：
- en: '[PRE76]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Class Decorators and Metaclasses
  id: totrans-690
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类装饰器和元类
- en: Python allows you to dynamically create and modify classes. Class decorators
    and metaclasses are two ways to do this.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许您动态创建和修改类。类装饰器和元类是实现这一目的的两种方式。
- en: Class Decorators
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类装饰器
- en: You can decorate a class definition with a *class decorator* (PEP 3129). It
    is a function that takes a class as input and returns a class.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用 *类装饰器*（PEP 3129）装饰一个类定义。它是一个以类为输入并返回一个类的函数。
- en: '[PRE77]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Creating Classes with `type`
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `type` 创建类
- en: You can use `type` to determine the type of an object, but you can also provide
    the name, parents, and attributes map, and it will return a class.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `type` 来确定对象的类型，但也可以提供名称、父级和属性映射，它将返回一个类。
- en: '[PRE78]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Metaclasses with Functions
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带函数的元类
- en: In the class definition you can specify a metaclass (PEP 3115), which can be
    a function or a class. Here is an example of a function that can alter the class.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，您可以指定一个元类（PEP 3115），它可以是一个函数或一个类。这里是一个可以改变类的函数的示例。
- en: '[PRE79]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Metaclasses with Classes
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带类的元类
- en: You can define a class decorator and use either `__new__` or `__init__`. Typically
    most use `__new__` as it can alter attributes like `__slots__`.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义一个类装饰器并使用 `__new__` 或 `__init__`。通常大多数人使用 `__new__`，因为它可以改变像 `__slots__`
    这样的属性。
- en: '[PRE80]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Generators
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: 'Generators (PEP 255) are functions that suspend their state as you iterate
    over the results of them. Each `yield` statement returns the next item of iteration
    and then *freezes* the state of the function. When iteration is resumed, the function
    continues from the point it was frozen. Note, that the result of calling the function
    is a generator:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器（PEP 255）是在您迭代它们的结果时暂停其状态的函数。每个 `yield` 语句返回迭代的下一个项目，然后 *冻结* 函数的状态。当恢复迭代时，函数将从冻结的点继续。请注意，调用该函数的结果是一个生成器：
- en: '[PRE81]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can simulate iteration by using the iteration protocol:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用迭代协议来模拟迭代：
- en: '[PRE82]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Coroutines
  id: totrans-709
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程
- en: 'The `asyncio` library (PEP 3153) provides asynchronous I/O in Python 3\. We
    use `async def` to define a *coroutine function* (see PEP 492). The result of
    calling this is a *coroutine object*. Inside a coroutine we can use `var = await
    future` to suspend the coroutine and wait for `future` to return. We can also
    await another coroutine. A coroutine object may be created but isn''t run until
    an event loop is running:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 库（PEP 3153）提供了 Python 3 中的异步 I/O。我们使用 `async def` 来定义一个 *协程函数*（参见
    PEP 492）。调用它的结果是一个 *协程对象*。在协程中，我们可以使用 `var = await future` 来挂起协程并等待 `future` 返回。我们也可以等待另一个协程。协程对象可能已创建，但在运行事件循环之前不会运行：'
- en: '[PRE83]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To return an object, use an `asyncio.Future`:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回一个对象，请使用 `asyncio.Future`：
- en: '[PRE84]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`await` and `async` are *soft keywords* in Python 3.6\. You will get a warning
    if you use them for variable names. In Python 3.7, they will be reserved keywords.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.6 中，`await` 和 `async` 是 *软关键字*。如果您将它们用作变量名，将会收到警告。在 Python 3.7 中，它们将成为保留关键字。
- en: Note
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For backwards compatibility in Python 3.4:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Python 3.4 中向后兼容：
- en: '`await` can be replaced with `yield from`'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await` 可以被替换为 `yield from`'
- en: '`async def` can be replaced with a function decorated with `@asyncio.coroutine`'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async def` 可以被一个用 `@asyncio.coroutine` 装饰的函数替换'
- en: Asynchronous Generators
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步生成器
- en: 'Python 3.6 adds asynchronous generators (PEP 525). You can use the `yield`
    statement in an `async def` function:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6 添加了异步生成器（PEP 525）。您可以在 `async def` 函数中使用 `yield` 语句：
- en: '[PRE85]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Comprehensions
  id: totrans-723
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推导式
- en: 'Comprehension constructs allow us to combine the functional ideas behind map
    and filter into an easy to read, single line of code. When you see code that is
    aggregating into a list (or dict, set, or generator), you can replace it with
    a list comprehension (or dict, set comprehension, or generator expression). Here
    is an example of the code smell:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式构造允许我们将 map 和 filter 的功能思想结合成易于阅读的单行代码。当你看到代码聚合成一个列表（或字典、集合或生成器）时，你可以用列表推导式（或字典、集合推导式或生成器表达式）替换它。以下是代码异味的示例：
- en: '[PRE86]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This can be specified with a list comprehension (PEP 202):'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过列表推导式（PEP 202）指定：
- en: '[PRE87]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To construct a list comprehension:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建列表推导式：
- en: 'Assign the result (`result`) to brackets. The brackets signal to the reader
    of the code that a list will be returned:'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果（`result`）分配给括号。括号向代码读者表明将返回一个列表：
- en: '[PRE88]'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Place the *for* loop construct inside the brackets. No colons are necessary:'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*for*循环结构放在括号内。不需要冒号：
- en: '[PRE89]'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Insert any operations that filter the accumulation after the for loop:'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 for 循环之后插入任何筛选累积的操作：
- en: '[PRE90]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Insert the accumulated object (`num*num`) at the front directly following the
    left bracket. Insert parentheses around the object if it is a tuple:'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左括号后面直接插入累积对象（`num*num`）。如果是元组，则在对象周围插入括号：
- en: '[PRE91]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Set Comprehensions
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'If you replace the `[` with `{`, you will get a set comprehension (PEP 274)
    instead of a list comprehension:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`[`替换为`{`，你将得到一个集合推导式（PEP 274），而不是一个列表推导式：
- en: '[PRE92]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Dict Comprehensions
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典推导式
- en: 'If you replace the `[` with `{`, and separate the key and value with a colon,
    you will get a dictionary comprehension (PEP 274):'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`[`替换为`{`，并用冒号分隔键和值，你将得到一个字典推导式（PEP 274）：
- en: '[PRE93]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 3.6, dictionaries are now ordered by key entry. Hence the ordering
    above.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.6 中，字典现在按键输入排序。因此以上排序。
- en: Generator Expressions
  id: totrans-745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: 'If you replace the `[` with `(`, you will get a generator instead of a list.
    This is called a *generator expression* (PEP 289):'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`[`替换为`(`，您将得到一个生成器而不是一个列表。这称为*生成器表达式*（PEP 289）：
- en: '[PRE94]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Asynchronous Comprehensions
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步推导式
- en: 'Python 3.6 (PEP 530) gives us *asynchronous comprehensions*. You can add `async`
    following what you are collecting to make it asynchronous. If you had the following
    code:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6（PEP 530）为我们提供了*异步推导式*。您可以在您正在收集的内容后面添加`async`以使其异步。如果您有以下代码：
- en: '[PRE95]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You could replace it with:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其替换为：
- en: '[PRE96]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Context Managers
  id: totrans-753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: If you find code where you need to make sure something happens before *and*
    after a block, a context manager (PEP 343) is a convenient way to enforce that.
    Another code smell that indicates you could be using a context manager is a `try`/`finally`
    block.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现需要确保某事在块之前*和*之后发生的代码，上下文管理器（PEP 343）是一种方便的强制执行方式。指示您可能正在使用上下文管理器的另一种代码异味是`try`/`finally`块。
- en: Context managers can be created with functions or classes.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器可以使用函数或类创建。
- en: 'If we were writing a Python module to write TeX, we might do something like
    this to ensure that the environments are closed properly:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写一个用于编写 TeX 的 Python 模块，我们可能会这样做以确保环境被正确关闭：
- en: '[PRE97]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This code can use a context manager to be a little cleaner.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以使用上下文管理器来变得更加清晰。
- en: Function Based Context Managers
  id: totrans-759
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于函数的上下文管理器
- en: 'To create a context manager with a function, decorate with `contextlib.contextmanager`,
    and yield where you want to insert your block:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用函数创建上下文管理器，请使用`contextlib.contextmanager`进行装饰，并在想要插入代码块的地方使用`yield`：
- en: '[PRE98]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Our code looks better now, and there will always be a closing tag:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码现在看起来更好了，并且总是有一个闭合标签：
- en: '[PRE99]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Class Based Context Managers
  id: totrans-764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于类的上下文管理器
- en: 'To create a class based context manager, implement the `__enter__` and `__exit__`
    methods:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建基于类的上下文管理器，请实现`__enter__`和`__exit__`方法：
- en: '[PRE100]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The code looks the same as using the function based context manager:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来与使用基于函数的上下文管理器相同：
- en: '[PRE101]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Context objects
  id: totrans-769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文对象
- en: 'Some context managers create objects that we can use while inside of the context.
    The `open` context manager returns a file object:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 一些上下文管理器创建我们可以在上下文中使用的对象。`open`上下文管理器返回一个文件对象：
- en: '[PRE102]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: To create an object in a function based context manager, simply `yield` the
    object. In a class based context manager, return the object in the `__enter__`
    method.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于函数的上下文管理器中创建对象，只需在`yield`对象。在基于类的上下文管理器中，在`__enter__`方法中返回对象。
- en: Type Annotations
  id: totrans-773
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型注解
- en: 'Python 3.6 (PEP 483 and 484) allows you to provide types for input and output
    of functions. They can be used to:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6（PEP 483 和 484）允许您为函数的输入和输出提供类型。它们可以用于：
- en: Allow 3rd party libraries such as mypy [[2]](#id4) to run static typing
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许第三方库如mypy [[2]](#id4) 运行静态类型检查
- en: Assist editors with type inference
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助编辑器进行类型推断
- en: Aid developers in understanding code
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助开发人员理解代码
- en: '| [[2]](#id3) | [http://mypy-lang.org/](http://mypy-lang.org/) |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| [[2]](#id3) | [http://mypy-lang.org/](http://mypy-lang.org/) |'
- en: 'Types can be expressed as:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以表示为：
- en: Built-in classes
  id: totrans-780
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置类
- en: Third party classes
  id: totrans-781
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方类
- en: Abstract Base Classes
  id: totrans-782
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类
- en: Types found in the `types` module
  id: totrans-783
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`types`模块中的类型'
- en: User-defined classes
  id: totrans-784
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的类
- en: 'A basic example:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本示例：
- en: '[PRE103]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Note that Python does not do type checking, you need to use something like
    mypy:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python不进行类型检查，您需要使用类似mypy的工具：
- en: '[PRE104]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You can also specify the types of variables with a comment:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用注释指定变量的类型：
- en: '[PRE105]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `typing` Module
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`typing`模块'
- en: 'This module allows you to provide hints for:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块允许您为以下内容提供提示：
- en: Callback functions
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数
- en: Generic containers
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用容器
- en: The `Any` type
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any`类型'
- en: To designate a class or function to not type check its annotations, use the
    `@typing.no_type_check` decorator.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定一个类或函数不进行类型检查其注释，使用`@typing.no_type_check`装饰器。
- en: Type Checking
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型检查
- en: 'Python 3.6 provides no support for type checking. You will need to install
    a tool like `mypy`:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6不支持类型检查。您需要安装类似`mypy`这样的工具：
- en: '[PRE106]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Scripts, Packages, and Modules
  id: totrans-800
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本、包和模块
- en: Scripts
  id: totrans-801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本
- en: 'A script is a Python file that you invoke `python` on. Typically there is a
    line near the bottom that looks like this:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是您在其上调用`python`的Python文件。通常在底部附近有一行看起来像这样的代码：
- en: '[PRE107]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This test allows you to change the code path when you execute the code versus
    when you import the code. The `__name__` attribute of a module is set to `'__main__'`
    when you execute that module. Otherwise, if you import the module, it will be
    the name of the module (without `.py`).
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试允许您在执行代码时更改代码路径与导入代码时的路径。当您执行该模块时，模块的`__name__`属性设置为`'__main__'`。否则，如果您导入模块，它将是模块的名称（不带`.py`）。
- en: Modules
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: Modules are files that end in `.py`. According to PEP 8, we lowercase the module
    name and don't put underscores between the words in them. Any module found in
    the `PYTHONPATH` environment variable or the `sys.path` list, can be imported.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是以`.py`结尾的文件。根据PEP 8，我们应该将模块名小写，并且不在单词之间加下划线。任何在`PYTHONPATH`环境变量或`sys.path`列表中找到的模块都可以被导入。
- en: Packages
  id: totrans-807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包
- en: 'A directory that has a file named `__init__.py` in it is a *package*. A package
    can have modules in it as well as sub packages. The package should be found in
    `PYTHONPATH` or `sys.path` to be imported. An example might look like this:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 包含名为`__init__.py`的文件的目录是*包*。包中可以包含模块以及子包。要导入包，应该在`PYTHONPATH`或`sys.path`中找到该包。一个示例可能如下所示：
- en: '[PRE108]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `__init__.py` module can be empty or can import code from other modules
    in the package to remove nesting in import statements.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`模块可以是空的，也可以从包中的其他模块导入代码，以消除导入语句中的嵌套。'
- en: Importing
  id: totrans-811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入
- en: 'You can import a package or a module:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以导入一个包或一个模块：
- en: '[PRE109]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Assume there is a `fib` function in `module1`. You have access to everything
    in the namespace of the module you imported. To use this function you will need
    to use the fully qualified name, `packagename.module1.fib`:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在`module1`中有一个`fib`函数。您可以访问您导入的模块的命名空间中的所有内容。要使用此函数，您需要使用完全限定的名称，`packagename.module1.fib`：
- en: '[PRE110]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If you only want to import the `fib` function, use the `from` variant:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只想导入`fib`函数，使用`from`变体：
- en: '[PRE111]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'You can also rename imports using `as`:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`as`重命名导入：
- en: '[PRE112]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Environments
  id: totrans-820
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境
- en: Python 3 includes the `venv` module for creating a sandbox for your project
    or a *virtual environment*.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3包括`venv`模块，用于为您的项目或*虚拟环境*创建一个沙盒。
- en: 'To create an environment on Unix systems, run:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unix系统上创建一个环境，请运行：
- en: '[PRE113]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'On Windows, run:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上运行：
- en: '[PRE114]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'To enter or *activate* the environment on Unix, run:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入或*激活*Unix上的环境，请运行：
- en: '[PRE115]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'On Windows, run:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上运行：
- en: '[PRE116]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Your prompt should have the name of the active virtual environment in parentheses.
    To *deactivate* an environment on both platforms, just run the following:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 您的提示符应该在括号中显示活动虚拟环境的名称。要在两个平台上*取消激活*���境，只需运行以下命令：
- en: '[PRE117]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Installing Packages
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: 'You should now have a `pip` executable, that will install a package from PyPI
    [[3]](#id6) into your virtual environment:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该有一个`pip`可执行文件，它将从PyPI [[3]](#id6) 安装一个包到您的虚拟环境中：
- en: '[PRE118]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '| [[3]](#id5) | [https://pypi.python.org/pypi](https://pypi.python.org/pypi)
    |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '| [[3]](#id5) | [https://pypi.python.org/pypi](https://pypi.python.org/pypi)
    |'
- en: 'To uninstall a package run:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载一个包，请运行：
- en: '[PRE119]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: If you are having issues installing a package, you might want to look into alternative
    Python distributions such as Anaconda [[4]](#id8) that have prepackaged many harder
    to install packages.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装一个包时遇到问题，你可能想要考虑使用其他的 Python 发行版，比如 Anaconda [[4]](#id8)，它预先打包了许多难以安装的包。
- en: '| [[4]](#id7) | [https://docs.continuum.io/anaconda/](https://docs.continuum.io/anaconda/)
    |'
  id: totrans-839
  prefs: []
  type: TYPE_TB
  zh: '| [[4]](#id7) | [https://docs.continuum.io/anaconda/](https://docs.continuum.io/anaconda/)
    |'
