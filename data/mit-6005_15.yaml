- en: 'Reading 15: Equality'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15节：相等性阅读
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 安全免于错误 | 易于理解 | 为变化做好准备 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确并且在未知的未来也正确。 | 与未来的程序员清晰沟通，包括未来的你。 | 设计用于适应变化而不需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: Understand equality defined in terms of the abstraction function, an equivalence
    relation, and observations.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解根据抽象函数、等价关系和观察定义的相等性。
- en: Differentiate between reference equality and object equality.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分引用相等和对象相等。
- en: Differentiate between strict observational and behavioral equality for mutable
    types.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分可变类型的严格观察相等和行为相等。
- en: Understand the Object contract and be able to implement equality correctly for
    mutable and immutable types.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象契约并能够正确地为可变和不可变类型实现相等性。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,introduction/Bo5bI1CcbMo)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,introduction/Bo5bI1CcbMo)'
- en: In the previous readings we’ve developed a rigorous notion of *data abstraction*
    by creating types that are characterized by their operations, not by their representation.
    For an abstract data type, the *abstraction function* explains how to interpret
    a concrete representation value as a value of the abstract type, and we saw how
    the choice of abstraction function determines how to write the code implementing
    each of the ADT’s operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的阅读中，我们通过创建由操作而不是表示特征特征化的类型来发展了一个严格的*数据抽象*概念。对于抽象数据类型，*抽象函数*解释了如何将具体表示值解释为抽象类型的值，并且我们看到了抽象函数的选择如何确定如何编写实现每个ADT操作的代码。
- en: 'In this reading we turn to how we define the notion of *equality* of values
    in a data type: the abstraction function will give us a way to cleanly define
    the equality operation on an ADT.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇阅读中，我们转向如何定义数据类型中值的*相等性*概念：抽象函数将为我们提供一种清晰地定义ADT上的相等性操作的方法。
- en: In the physical world, every object is distinct – at some level, even two snowflakes
    are different, even if the distinction is just the position they occupy in space.
    (This isn’t strictly true of all subatomic particles, but true enough of large
    objects like snowflakes and baseballs and people.) So two physical objects are
    never truly “equal” to each other; they only have degrees of similarity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理世界中，每个对象都是独一无二的 – 在某个层面上，即使是两片雪花也是不同的，即使区别只是它们在空间中所占的位置。（这并不严格适用于所有的亚原子粒子，但对于大型物体如雪花、棒球和人类来说足够真实。）因此，两个物理对象永远不会真正“相等”；它们只有相似程度。
- en: 'In the world of human language, however, and in the world of mathematical concepts,
    you can have multiple names for the same thing. So it’s natural to ask when two
    expressions represent the same thing: 1+2, √9, and 3 are alternative expressions
    for the same ideal mathematical value.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在人类语言世界和数学概念世界中，你可以对同一件事情有多个名称。因此，问两个表达式何时表示相同的事情是很自然的：1+2、√9和3都是同一个理想数学值的替代表达式。
- en: Three Ways to Regard Equality
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三种看待相等性的方式
- en: Formally, we can regard equality in several ways.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从正式角度来看，我们可以以几种方式来看待相等性。
- en: '**Using an abstraction function**. Recall that an abstraction function f: R
    → A maps concrete instances of a data type to their corresponding abstract values.
    To use f as a definition for equality, we would say that a equals b if and only
    if f(a)=f(b).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用抽象函数**。回想一下，一个抽象函数f: R → A将数据类型的具体实例映射到它们相应的抽象值。要使用f作为相等性的定义，我们会说a等于b当且仅当f(a)=f(b)。'
- en: '**Using a relation**. An *equivalence* is a relation E ⊆ T x T that is:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用关系**。一个*等价关系*是一个关系E ⊆ T x T，具有以下性质：'
- en: 'reflexive: E(t,t) ∀ t ∈ T'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自反性：E(t,t) ∀ t ∈ T
- en: 'symmetric: E(t,u) ⇒ E(u,t)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称性：E(t,u) ⇒ E(u,t)
- en: 'transitive: E(t,u) ∧ E(u,v) ⇒ E(t,v)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递性：E(t,u) ∧ E(u,v) ⇒ E(t,v)
- en: To use E as a definition for equality, we would say that a equals b if and only
    if E(a,b).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用E作为相等性的定义，我们会说a等于b当且仅当E(a,b)。
- en: These two notions are equivalent. An equivalence relation induces an abstraction
    function (the relation partitions T, so f maps each element to its partition class).
    The relation induced by an abstraction function is an equivalence relation (check
    for yourself that the three properties hold).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念是等价的。等价关系会引出一个抽象函数（该关系将T划分为若干部分，因此f将每个元素映射到其划分类别）。由抽象函数引出的关系是一个等价关系（自行验证这三个属性是否成立）。
- en: 'A third way we can talk about the equality between abstract values is in terms
    of what an outsider (a client) can observe about them:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论抽象值之间的相等的第三种方式是从外部人（客户端）可以观察到的角度来讨论：
- en: '**Using observation**. We can say that two objects are equal when they cannot
    be distinguished by observation – every operation we can apply produces the same
    result for both objects. Consider the set expressions {1,2} and {2,1}. Using the
    observer operations available for sets, cardinality |…| and membership ∈, these
    expressions are indistinguishable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用观察**。我们可以说两个对象相等，当它们无法通过观察来区分时 - 我们可以应用的每个操作对两个对象产生相同的结果。考虑集合表达式{1,2}和{2,1}。使用集合的观察操作，基数
    |...| 和成员 ∈，这些表达式是无法区分的：'
- en: '|{1,2}| = 2 and |{2,1}| = 2'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '|{1,2}| = 2 and |{2,1}| = 2'
- en: 1 ∈ {1,2} is true, and 1 ∈ {2,1} is true
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 ∈ {1,2} 是真的，而且 1 ∈ {2,1} 是真的
- en: 2 ∈ {1,2} is true, and 2 ∈ {2,1} is true
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 ∈ {1,2} 是真的，而且 2 ∈ {2,1} 是真的
- en: 3 ∈ {1,2} is false, and 3 ∈ {2,1} is false
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 ∈ {1,2} 是假的，而且 3 ∈ {2,1} 是假的
- en: … and so on
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: … 等等
- en: In terms of abstract data types, “observation” means calling operations on the
    objects. So two objects are equal if and only if they cannot be distinguished
    by calling any operations of the abstract data type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就抽象数据类型而言，“观察”意味着在对象上调用操作。因此，仅当两个对象不能通过调用抽象数据类型的任何操作来区分时，它们才相等。
- en: 'Example: Duration'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例子：持续时间
- en: Here’s a simple example of an immutable ADT.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不可变 ADT 的简单示例。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now which of the following values should be considered equal?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，哪些值应该被视为相等？
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Think in terms of both the abstraction-function definition of equality, and
    the observational equality definition.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象函数定义相等和观察相等定义的角度来思考。
- en: reading exercises
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Any second now
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 随时
- en: Consider the code for `Duration` and the objects `d1`, `d2`, `d3`, `d4` just
    created above.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑上面刚刚创建的`Duration`和对象`d1`、`d2`、`d3`、`d4`的代码。
- en: Using the abstraction-function notion of equality, which of the following would
    be considered equal to `d1`?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象函数的相等概念，以下哪个将被视为与`d1`相等？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Eye on the clock
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 留意时间
- en: Using the observational notion of equality, which of the following would be
    considered equal to `d1`?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察性的相等概念，以下哪个将被视为与`d1`相等？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: == vs. equals()
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: == vs. equals()
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,_vs_equals/SEGmpKM874c)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,_vs_equals/SEGmpKM874c)'
- en: Like many languages, Java has two different operations for testing equality,
    with different semantics.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多语言一样，Java 有两个不同的测试相等性的操作，具有不同的语义。
- en: The `==` operator compares references. More precisely, it tests *referential*
    equality. Two references are == if they point to the same storage in memory. In
    terms of the snapshot diagrams we’ve been drawing, two references are `==` if
    their arrows point to the same object bubble.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`运算符比较引用。更确切地说，它测试*引用*相等性。如果两个引用指向内存中的相同存储，则两个引用是 == 的。就我们一直绘制的快照图中，如果它们的箭头指向同一个对象泡沫，则两个引用是
    == 的。'
- en: The `equals()` operation compares object contents – in other words, *object*
    equality, in the sense that we’ve been talking about in this reading. The equals
    operation has to be defined appropriately for every abstract data type.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`操作比较对象内容 - 换句话说，*对象*相等，在我们讨论中的意义上。equals 操作必须适当地为每种抽象数据类型定义。'
- en: 'For comparison, here are the equality operators in several languages:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为比较，以下是几种语言中的相等运算符：
- en: '|  | *referential equality* | *object equality* |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  | *引用相等性* | *对象相等性* |'
- en: '| Java | `==` | `equals()` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Java | `==` | `equals()` |'
- en: '| Objective C | `==` | `isEqual:` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Objective C | `==` | `isEqual:` |'
- en: '| C# | `==` | `Equals()` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| C# | `==` | `Equals()` |'
- en: '| Python | `is` | `==` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| Python | `is` | `==` |'
- en: '| Javascript | `==` | n/a |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Javascript | `==` | n/a |'
- en: 'Note that `==` unfortunately flips its meaning between Java and Python. Don’t
    let that confuse you: `==` in Java just tests reference identity, it doesn’t compare
    object contents.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`==`在Java和Python之间不幸地翻转了其含义。不要让这让你困惑：在Java中，`==`只是测试引用标识，它不比较对象内容。
- en: As programmers in any of these languages, we can’t change the meaning of the
    referential equality operator. In Java, `==` always means referential equality.
    But when we define a new data type, it’s our responsibility to decide what object
    equality means for values of the data type, and implement the `equals()` operation
    appropriately.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为任何这些语言的程序员，我们不能改变引用相等运算符的含义。在Java中，`==`始终表示引用相等。但是当我们定义一个新的数据类型时，我们有责任决定数据类型的值的对象相等性意味着什么，并适当地实现`equals()`操作。
- en: Equality of Immutable Types
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变类型的相等性
- en: 'The `equals()` method is defined by `Object`, and its default implementation
    looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals()`方法由`Object`定义，其默认实现如下所示：'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In other words, the default meaning of `equals()` is the same as referential
    equality. For immutable data types, this is almost always wrong. So you have to
    **override** the `equals()` method, replacing it with your own implementation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，默认的`equals()`意味着引用相等。对于不可变数据类型，这几乎总是错误的。因此，您必须**重写**`equals()`方法，用自己的实现替换它。
- en: 'Here’s our first try for `Duration`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们为`Duration`的第一次尝试：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There’s a subtle problem here. Why doesn’t this work? Let’s try this code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个微妙的问题。为什么这不起作用？让我们尝试这段代码：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can [see this code in action](http://www.pythontutor.com/java.html#code=public+class+Duration+%7B%0A++++private+final+int+mins%3B%0A++++private+final+int+secs%3B%0A++++//+rep+invariant%3A%0A++++//++++mins+%3E%3D+0,+secs+%3E%3D+0%0A++++//+abstraction+function%3A%0A++++//++++represents+a+span+of+time+of+mins+minutes+and+secs+seconds%0A%0A++++/**+Make+a+duration+lasting+for+m+minutes+and+s+seconds.+*/%0A++++public+Duration(int+m,+int+s%29+%7B%0A++++++++mins+%3D+m%3B+secs+%3D+s%3B%0A++++%7D%0A++++/**+%40return+length+of+this+duration+in+seconds+*/%0A++++public+long+getLength(%29+%7B%0A++++++++return+mins*60+%2B+secs%3B%0A++++%7D%0A++++//+Problematic+definition+of+equals(%29%0A++++public+boolean+equals(Duration+that%29+%7B%0A++++++++return+this.getLength(%29+%3D%3D+that.getLength(%29%3B++++++++%0A++++%7D%0A++++public+static+void+main(String%5B%5D+args%29+%7B%0A++++++Duration+d1+%3D+new+Duration+(1,+2%29%3B%0A++++++Duration+d2+%3D+new+Duration+(1,+2%29%3B%0A++++++Object+o2+%3D+d2%3B%0A++++++System.out.println(%22d1.equals(d2%29%3D%22+%2B+d1.equals(d2%29%29%3B%0A++++++System.out.println(%22d1.equals(o2%29%3D%22+%2B+d1.equals(o2%29%29%3B%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=33).
    You’ll see that even though `d2` and `o2` end up referring to the very same object
    in memory, you still get different results for them from `equals()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以[在这里看到此代码的运行情况](http://www.pythontutor.com/java.html#code=public+class+Duration+%7B%0A++++private+final+int+mins%3B%0A++++private+final+int+secs%3B%0A++++//+rep+invariant%3A%0A++++//++++mins+%3E%3D+0,+secs+%3E%3D+0%0A++++//+abstraction+function%3A%0A++++//++++represents+a+span+of+time+of+mins+minutes+and+secs+seconds%0A%0A++++/**+Make+a+duration+lasting+for+m+minutes+and+s+seconds.+*/%0A++++public+Duration(int+m,+int+s%29+%7B%0A++++++++mins+%3D+m%3B+secs+%3D+s%3B%0A++++%7D%0A++++/**+%40return+length+of+this+duration+in+seconds+*/%0A++++public+long+getLength(%29+%7B%0A++++++++return+mins*60+%2B+secs%3B%0A++++%7D%0A++++//+Problematic+definition+of+equals(%29%0A++++public+boolean+equals(Duration+that%29+%7B%0A++++++++return+this.getLength(%29+%3D%3D+that.getLength(%29%3B++++++++%0A++++%7D%0A++++public+static+void+main(String%5B%5D+args%29+%7B%0A++++++Duration+d1+%3D+new+Duration+(1,+2%29%3B%0A++++++Duration+d2+%3D+new+Duration+(1,+2%29%3B%0A++++++Object+o2+%3D+d2%3B%0A++++++System.out.println(%22d1.equals(d2%29%3D%22+%2B+d1.equals(d2%29%29%3B%0A++++++System.out.println(%22d1.equals(o2%29%3D%22+%2B+d1.equals(o2%29%29%3B%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=33)。您会发现，即使`d2`和`o2`最终引用了内存中的同一个对象，您仍然会从`equals()`得到不同的结果。
- en: 'What’s going on? It turns out that `Duration` has **overloaded** the `equals()`
    method, because the method signature was not identical to `Object`’s. We actually
    have two `equals()` methods in `Duration`: an implicit `equals(Object)` inherited
    from `Object`, and the new `equals(Duration)`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？事实证明，`Duration`已经**重载**了`equals()`方法，因为该方法签名与`Object`的不相同。实际上，我们在`Duration`中有两个`equals()`方法：从`Object`继承的隐式`equals(Object)`，以及新的`equals(Duration)`。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve seen overloading since the very beginning of the course in [static checking](../01-static-checking/#types).
    Recall from [the Java Tutorials](http://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)
    that the compiler selects between overloaded operations using the compile-time
    type of the parameters. For example, when you use the `/` operator, the compiler
    chooses either integer division or float division based on whether the arguments
    are ints or floats. The same compile-time selection happens here. If we pass an
    `Object` reference, as in `d1.equals(o2)`, we end up calling the `equals(Object)`
    implementation. If we pass a `Duration` reference, as in `d1.equals(d2)`, we end
    up calling the `equals(Duration)` version. This happens even though `o2` and `d2`
    both point to the same object at runtime! Equality has become inconsistent.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从课程一开始我们就见过重载，[静态检查](../01-static-checking/#types)中提到过。从[Java教程](http://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)中可以回想起，编译器根据参数的编译时类型选择重载操作。例如，当使用`/`运算符时，编译器根据参数是int还是float选择整数除法或浮点除法。这里也发生了相同的编译时选择。如果我们传递一个`Object`引用，就像`d1.equals(o2)`一样，我们最终调用`equals(Object)`的实现。如果我们传递一个`Duration`引用，就像`d1.equals(d2)`一样，我们最终调用`equals(Duration)`版本。即使在运行时`o2`和`d2`都指向同一个对象！相等性已经变得不一致。
- en: It’s easy to make a mistake in the method signature, and overload a method when
    you meant to override it. This is such a common error that Java has a language
    feature, the annotation [`@Override`](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html),
    which you should use whenever your intention is to override a method in your superclass.
    With this annotation, the Java compiler will check that a method with the same
    signature actually exists in the superclass, and give you a compiler error if
    you’ve made a mistake in the signature.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法签名中很容易出错，并在打算重写时重载方法。这是一个常见错误，Java有一个语言特性，注解[`@Override`](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html)，当你打算在你的超类中重写方法时应该使用它。使用此注解，Java编译器将检查超类中是否实际存在具有相同签名的方法，并在签名错误时给出编译器错误。
- en: 'So here’s the right way to implement `Duration`’s `equals()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是实现`Duration`的`equals()`方法的正确方式：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This fixes the problem:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样修复了问题：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can [see this code in action](http://www.pythontutor.com/java.html#code=public+class+Duration+%7B%0A++++private+final+int+mins%3B%0A++++private+final+int+secs%3B%0A++++//+rep+invariant%3A%0A++++//++++mins+%3E%3D+0,+secs+%3E%3D+0%0A++++//+abstraction+function%3A%0A++++//++++represents+a+span+of+time+of+mins+minutes+and+secs+seconds%0A%0A++++/**+Make+a+duration+lasting+for+m+minutes+and+s+seconds.+*/%0A++++public+Duration(int+m,+int+s%29+%7B%0A++++++++mins+%3D+m%3B+secs+%3D+s%3B%0A++++%7D%0A++++/**+%40return+length+of+this+duration+in+seconds+*/%0A++++public+long+getLength(%29+%7B%0A++++++++return+mins*60+%2B+secs%3B%0A++++%7D%0A++++%40Override%0A++++public+boolean+equals+(Object+thatObject%29+%7B%0A++++++++if+(!(thatObject+instanceof+Duration%29%29+return+false%3B%0A++++++++Duration+thatDuration+%3D+(Duration%29+thatObject%3B%0A++++++++return+this.getLength(%29+%3D%3D+thatDuration.getLength(%29%3B%0A++++%7D%0A++++public+static+void+main(String%5B%5D+args%29+%7B%0A++++++Duration+d1+%3D+new+Duration+(1,+2%29%3B%0A++++++Duration+d2+%3D+new+Duration+(1,+2%29%3B%0A++++++Object+o2+%3D+d2%3B%0A++++++System.out.println(%22d1.equals(d2%29%3D%22+%2B+d1.equals(d2%29%29%3B%0A++++++System.out.println(%22d1.equals(o2%29%3D%22+%2B+d1.equals(o2%29%29%3B%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=49)
    in the Online Python Tutor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[这个代码中查看它的运行情况](http://www.pythontutor.com/java.html#code=public+class+Duration+%7B%0A++++private+final+int+mins%3B%0A++++private+final+int+secs%3B%0A++++//+rep+invariant%3A%0A++++//++++mins+%3E%3D+0,+secs+%3E%3D+0%0A++++//+abstraction+function%3A%0A++++//++++represents+a+span+of+time+of+mins+minutes+and+secs+seconds%0A%0A++++/**+Make+a+duration+lasting+for+m+minutes+and+s+seconds.+*/%0A++++public+Duration(int+m,+int+s%29+%7B%0A++++++++mins+%3D+m%3B+secs+%3D+s%3B%0A++++%7D%0A++++/**+%40return+length+of+this+duration+in+seconds+*/%0A++++public+long+getLength(%29+%7B%0A++++++++return+mins*60+%2B+secs%3B%0A++++%7D%0A++++%40Override%0A++++public+boolean+equals+(Object+thatObject%29+%7B%0A++++++++if+(!(thatObject+instanceof+Duration%29%29+return+false%3B%0A++++++++Duration+thatDuration+%3D+(Duration%29+thatObject%3B%0A++++++++return+this.getLength(%29+%3D%3D+thatDuration.getLength(%29%3B%0A++++%7D%0A++++public+static+void+main(String%5B%5D+args%29+%7B%0A++++++Duration+d1+%3D+new+Duration+(1,+2%29%3B%0A++++++Duration+d2+%3D+new+Duration+(1,+2%29%3B%0A++++++Object+o2+%3D+d2%3B%0A++++++System.out.println(%22d1.equals(d2%29%3D%22+%2B+d1.equals(d2%29%29%3B%0A++++++System.out.println(%22d1.equals(o2%29%3D%22+%2B+d1.equals(o2%29%29%3B%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=49)
    在在线Python教程中。
- en: instanceof
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: instanceof
- en: The [`instanceof` operator](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html)
    tests whether an object is an instance of a particular type. Using `instanceof`
    is dynamic type checking, not the static type checking we vastly prefer. In general,
    using `instanceof` in object-oriented programming is a bad smell. In 6.005 — and
    this is another of our rules that holds true in most good Java programming — **`instanceof`
    is disallowed anywhere except for implementing `equals`**. This prohibition also
    includes other ways of inspecting objects’ runtime types. For example, [`getClass`](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--)
    is also disallowed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[`instanceof` 运算符](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html)
    测试一个对象是否是特定类型的实例。使用 `instanceof` 是动态类型检查，而不是我们极力推荐的静态类型检查。一般来说，在面向对象编程中使用 `instanceof`
    是一个坏习惯。在 6.005 中——这也是我们的另一个规则，适用于大多数良好的 Java 编程——**`instanceof` 在除了实现 `equals`
    之外的任何地方都被禁止**。这个禁令也包括其他检查对象运行时类型的方式。例如，[`getClass`](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--)
    也被禁止。'
- en: We’ll see examples of when you might be tempted to use `instanceof`, and how
    to write alternatives that are safer from bugs and more ready for change, in a
    future reading.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的阅读中看到，何时可能会被诱惑使用 `instanceof`，以及如何编写更安全、更易于更改的替代方案的示例。
- en: The Object Contract
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象约定
- en: 'The specification of the `Object` class is so important that it is often referred
    to as *the `Object` Contract*. The contract can be found in the method specifications
    for the `Object` class. Here we will focus on the contract for `equals`. When
    you override the `equals` method, you must adhere to its general contract. It
    states that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 类的规范是如此重要，以至于经常被称为*对象约定*。该约定可以在 `Object` 类的方法规范中找到。在这里，我们将重点放在 `equals`
    的约定上。当你重写 `equals` 方法时，你必须遵守它的一般约定。它规定：'
- en: '`equals` must define an equivalence relation – that is, a relation that is
    reflexive, symmetric, and transitive;'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals` 必须定义一个等价关系——即，一个反身性、对称性和传递性的关系；'
- en: '`equals` must be consistent: repeated calls to the method must yield the same
    result provided no information used in `equals` comparisons on the object is modified;'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals` 必须是一致的：对该方法的重复调用必须产生相同的结果，只要用于 `equals` 比较的对象上的信息没有被修改；'
- en: for a non-null reference `x`, `x.equals(null)` should return false;
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非空引用 `x`，`x.equals(null)` 应返回 false；
- en: '`hashCode` must produce the same result for two objects that are deemed equal
    by the `equals` method.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于被 `equals` 方法认定为相等的两个对象，`hashCode` 必须产生相同的结果。
- en: Breaking the Equivalence Relation
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破坏等价关系
- en: 'Let’s start with the equivalence relation. We have to make sure that the definition
    of equality implemented by `equals()` is actually an equivalence relation as defined
    earlier: reflexive, symmetric, and transitive. If it isn’t, then operations that
    depend on equality (like sets, searching) will behave erratically and unpredictably.
    You don’t want to program with a data type in which sometimes `a` equals `b`,
    but `b` doesn’t equal `a`. Subtle and painful bugs will result.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从等价关系开始。我们必须确保由 `equals()` 实现的等式定义实际上是一个等价关系，如前所定义：反身性、对称性和传递性。如果不是这样，那么依赖相等性的操作（如集合、搜索）将表现得不稳定和不可预测。你不想用一个数据类型编程，在其中有时候
    `a` 等于 `b`，但 `b` 却不等于 `a`。将导致微妙而痛苦的错误。
- en: 'Here’s an example of how an innocent attempt to make equality more flexible
    can go wrong. Suppose we wanted to allow for a tolerance in comparing `Duration`
    objects, because different computers may have slightly unsynchronized clocks:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使相等性更加灵活的天真尝试如何出错的示例。假设我们想要允许在比较 `Duration` 对象时容忍误差，因为不同的计算机可能具有略微不同步的时钟：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Which property of the equivalence relation is violated?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 等价关系的哪个属性被违反了？
- en: reading exercises
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Equals-ish
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似相等
- en: 'Consider the latest implementation of `Duration` in the reading, reprinted
    here for convenience:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下在阅读中最新的 `Duration` 实现，为方便起见在此重印：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Suppose these `Duration` objects are created:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这些 `Duration` 对象被创建：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Skewed up(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 扭曲了（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Buggy equality(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有问题的相等（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Breaking Hash Tables
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破坏哈希表
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,the_object_contract,breaking_hash_tables/hP2FNsAJQG4)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,the_object_contract,breaking_hash_tables/hP2FNsAJQG4)'
- en: To understand the part of the contract relating to the `hashCode` method, you’ll
    need to have some idea of how hash tables work. Two very common collection implementations,
    `HashSet` and `HashMap`, use a hash table data structure, and depend on the `hashCode`
    method to be implemented correctly for the objects stored in the set and used
    as keys in the map.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解与`hashCode`方法相关的契约部分，您需要对哈希表的工作原理有一些了解。两种非常常见的集合实现，`HashSet`和`HashMap`，使用哈希表数据结构，并依赖于正确实现`hashCode`方法的对象存储在集合中并用作地图中的键。
- en: 'A hash table is a representation for a mapping: an abstract data type that
    maps keys to values. Hash tables offer constant time lookup, so they tend to perform
    better than trees or lists. Keys don’t have to be ordered, or have any particular
    property, except for offering `equals` and `hashCode`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是映射的一种表示：一种将键映射到值的抽象数据类型。哈希表提供了常数时间的查找，因此它们通常比树或列表表现得更好。键不必被排序，也不必具有任何特定的属性，除了提供`equals`和`hashCode`。
- en: Here’s how a hash table works. It contains an array that is initialized to a
    size corresponding to the number of elements that we expect to be inserted. When
    a key and a value are presented for insertion, we compute the hashcode of the
    key, and convert it into an index in the array’s range (e.g., by a modulo division).
    The value is then inserted at that index.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的工作原理如下。它包含一个数组，该数组的大小初始化为我们预计要插入的元素数量。当提供键和值进行插入时，我们计算键的哈希码，并将其转换为数组范围内的索引（例如，通过取模运算）。然后在该索引处插入值。
- en: The rep invariant of a hash table includes the fundamental constraint that keys
    are in the slots determined by their hash codes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的表示不变性包括一个基本约束，即键位于由它们的哈希码确定的槽中。
- en: Hashcodes are designed so that the keys will be spread evenly over the indices.
    But occasionally a conflict occurs, and two keys are placed at the same index.
    So rather than holding a single value at an index, a hash table actually holds
    a list of key/value pairs, usually called a *hash bucket*. A key/value pair is
    implemented in Java simply as an object with two fields. On insertion, you add
    a pair to the list in the array slot determined by the hash code. For lookup,
    you hash the key, find the right slot, and then examine each of the pairs until
    one is found whose key equals the query key.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希码设计成使键均匀分布在索引上。但偶尔会发生冲突，两个键被放置在相同的索引上。因此，哈希表实际上不是在索引处保存单个值，而是保存一个称为*哈希桶*的键/值对列表，通常称为哈希桶。键/值对在Java中简单地被实现为具有两个字段的对象。在插入时，您将一对添加到由哈希码确定的数组槽中的列表中。对于查找，您对键进行哈希处理，找到正确的槽位，然后检查每个对，直到找到一个其键与查询键相等的对。
- en: Now it should be clear why the `Object` contract requires equal objects to have
    the same hashcode. If two equal objects had distinct hashcodes, they might be
    placed in different slots. So if you attempt to lookup a value using a key equal
    to the one with which it was inserted, the lookup may fail.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚为什么`Object`契约要求相等的对象具有相同的哈希码。如果两个相等的对象具有不同的哈希码，它们可能被放置在不同的槽中。所以如果你试图使用与插入它的键相等的键来查找值，查找可能会失败。
- en: '`Object`’s default `hashCode()` implementation is consistent with its default
    `equals()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`的默认`hashCode()`实现与其默认`equals()`一致：'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For references `a` and `b`, if `a == b`, then the address of a `==` the address
    of b. So the `Object` contract is satisfied.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用`a`和`b`，如果`a == b`，那么a的地址== b的地址。因此，`Object`契约得到了满足。
- en: 'But immutable objects need a different implementation of `hashCode()`. For
    `Duration`, since we haven’t overridden the default `hashCode()` yet, we’re currently
    breaking the `Object` contract:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不可变对象需要一个不同的`hashCode()`实现。对于`Duration`，由于我们尚未重写默认的`hashCode()`，因此我们目前正在违反`Object`契约：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`d1` and `d2` are `equal()`, but they have different hash codes. So we need
    to fix that.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`d1`和`d2`是`equal()`的，但它们有不同的哈希码。所以我们需要修复这个问题。'
- en: A simple and drastic way to ensure that the contract is met is for `hashCode`
    to always return some constant value, so every object’s hash code is the same.
    This satisfies the `Object` contract, but it would have a disastrous performance
    effect, since every key will be stored in the same slot, and every lookup will
    degenerate to a linear search along a long list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保满足契约的一个简单而极端的方法是，`hashCode` 总是返回某个常量值，因此每个对象的哈希码都相同。这满足了 `Object` 的契约，但它会产生灾难性的性能影响，因为每个键都将存储在相同的槽中，每次查找都将退化为沿着长列表进行线性搜索。
- en: 'The standard way to construct a more reasonable hash code that still satisfies
    the contract is to compute a hash code for each component of the object that is
    used in the determination of equality (usually by calling the `hashCode` method
    of each component), and then combining these, throwing in a few arithmetic operations.
    For `Duration`, this is easy, because the abstract value of the class is already
    an integer value:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 构造更合理的哈希码的标准方法是计算用于确定相等性的对象的每个组件的哈希码（通常通过调用每个组件的 `hashCode` 方法），然后将这些组合起来，加入一些算术操作。对于
    `Duration` 来说，这很容易，因为类的抽象值已经是一个整数值：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Josh Bloch’s fantastic book, *Effective Java*, explains this issue in more detail,
    and gives some strategies for writing decent hash code functions. The advice is
    summarized in [a good StackOverflow post](http://stackoverflow.com/questions/113511/hash-code-implementation).
    Recent versions of Java now have a utility method [`Objects.hash()`](http://docs.oracle.com/javase/8/docs/api/java/util/Objects.html#hash-java.lang.Object...-)
    that makes it easier to implement a hash code involving multiple fields.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 乔希·布洛赫（Josh Bloch）的精彩著作，*Effective Java*，更详细地解释了这个问题，并提供了一些编写良好哈希码函数的策略。建议总结在
    [一个很好的 StackOverflow 帖子](http://stackoverflow.com/questions/113511/hash-code-implementation)
    中。最近的 Java 版本现在有一个实用方法 [`Objects.hash()`](http://docs.oracle.com/javase/8/docs/api/java/util/Objects.html#hash-java.lang.Object...-)，使得实现涉及多个字段的哈希码更容易。
- en: Note, however, that as long as you satisfy the requirement that equal objects
    have the same hash code value, then the particular hashing technique you use doesn’t
    make a difference to the correctness of your code. It may affect its performance,
    by creating unnecessary collisions between different objects, but even a poorly-performing
    hash function is better than one that breaks the contract.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只要满足相等的对象具有相同的哈希码值的要求，那么您使用的特定哈希技术对代码的正确性并不重要。它可能会影响其性能，因为在不同对象之间创建不必要的冲突，但是即使是性能不佳的哈希函数也比违反契约的好。
- en: 'Most crucially, note that if you don’t override `hashCode` at all, you’ll get
    the one from `Object`, which is based on the address of the object. If you have
    overridden `equals`, this will mean that you will have almost certainly violated
    the contract. So as a general rule:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最关键的是，请注意，如果你根本不重写 `hashCode`，你将得到来自 `Object` 的一个，它基于对象的地址。如果你已经重写了 `equals`，这意味着你几乎肯定违反了契约。所以作为一个通用规则：
- en: '**Always override `hashCode` when you override `equals`.**'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**当你重写 `equals` 时，始终重写 `hashCode`。**'
- en: Many years ago in (a precursor to 6.005 confusingly numbered) 6.170, a student
    spent hours tracking down a bug in a project that amounted to nothing more than
    misspelling `hashCode` as `hashcode`. This created a new method that didn’t override
    the `hashCode` method of `Object` at all, and strange things happened. Use `@Override`!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，在（混乱编号的 6.005 的前身）6.170 中，一个学生花了几个小时追踪一个项目中的一个 bug，结果发现不过是将 `hashCode` 拼写成
    `hashcode`。这创建了一个新方法，根本没有覆盖 `Object` 的 `hashCode` 方法，发生了奇怪的事情。使用 `@Override`！
- en: reading exercises
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Give me the code
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 给我代码
- en: 'Consider the following ADT class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 ADT 类：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Equality of Mutable Types
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变类型的相等性
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,equality_of_mutable_types/HlSJmV919rE)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,equality_of_mutable_types/HlSJmV919rE)'
- en: We’ve been focusing on equality of immutable objects so far in this reading.
    What about mutable objects?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇阅读中，我们一直专注于不可变对象的相等性。那么可变对象呢？
- en: 'Recall our definition: two objects are equal when they cannot be distinguished
    by observation. With mutable objects, there are two ways to interpret this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们的定义：当两个对象无法通过观察加以区分时，它们相等。对于可变对象，有两种解释方法：
- en: when they cannot be distinguished by observation *that doesn’t change the state
    of the objects*, i.e., by calling only observer, producer, and creator methods.
    This is often strictly called **observational equality**, since it tests whether
    the two objects “look” the same, in the current state of the program.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它们不能通过*不改变对象状态的观察*来区分，即仅调用观察者、生产者和创建者方法时。这通常被严格称为**观察相等**，因为它测试两个对象在程序当前状态下是否“看起来”相同。
- en: when they cannot be distinguished by *any* observation, even state changes.
    This interpretation allows calling any methods on the two objects, including mutators.
    This is often called **behavioral equality**, since it tests whether the two objects
    will “behave” the same, in this and all future states.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它们不能通过*任何*观察来区分，甚至是状态更改时。这种解释允许在两个对象上调用任何方法，包括改变器。这通常被称为**行为相等**，因为它测试两个对象是否在当前状态和所有未来状态中都“行为”相同。
- en: For immutable objects, observational and behavioral equality are identical,
    because there aren’t any mutator methods.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不可变对象，观察相等和行为相等是相同的，因为没有任何改变器方法。
- en: For mutable objects, it’s tempting to implement strict observational equality.
    Java uses observational equality for most of its mutable data types, in fact.
    If two distinct `List` objects contain the same sequence of elements, then `equals()`
    reports that they are equal.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变对象，实现严格的观察相等是很诱人的。事实上，Java对其大多数可变数据类型使用观察相等。如果两个不同的`List`对象包含相同的元素序列，则`equals()`报告它们相等。
- en: 'But using observational equality leads to subtle bugs, and in fact allows us
    to easily break the rep invariants of other collection data structures. Suppose
    we make a `List`, and then drop it into a `Set`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用观察相等会导致细微的错误，事实上，它还允许我们轻松地破坏其他集合数据结构的表征不变性。假设我们制作了一个`List`，然后将其放入`Set`中：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can check that the set contains the list we put in it, and it does:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查集合是否包含我们放入其中的列表，确实包含：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But now we mutate the list:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在我们改变了列表：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And it no longer appears in the set!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但它不再出现在集合中了！
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It’s worse than that, in fact: when we iterate over the members of the set,
    we still find the list in there, but `contains()` says it’s not there!'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，事实上是这样的：当我们遍历集合的成员时，我们仍然发现列表在其中，但`contains()`却说它不在那里！
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the set’s own iterator and its own `contains()` method disagree about whether
    an element is in the set, then the set clearly is broken. You can [see this code
    in action](http://www.pythontutor.com/java.html#code=import+java.util.*%3B%0Apublic+class+WhyObservationalEqualityHurts+%7B%0A++public+static+void+main(String%5B%5D+args%29+%7B%0A++++List%3CString%3E+list+%3D+new+ArrayList%3C%3E(%29%3B%0A++++list.add(%22a%22%29%3B%0A++++Set%3CList%3CString%3E%3E+set+%3D+new+HashSet%3CList%3CString%3E%3E(%29%3B%0A++++set.add(list%29%3B%0A++++System.out.println(%22set.contains(list%29%3D%22+%2B+set.contains(list%29%29%3B%0A++++list.add(%22goodbye%22%29%3B%0A++++System.out.println(%22set.contains(list%29%3D%22+%2B+set.contains(list%29%29%3B%0A++++for+(List%3CString%3E+l+%3A+set%29+%7B+%0A++++++System.out.println(%22set.contains(l%29%3D%22+%2B+set.contains(l%29%29%3B%0A++++%7D%0A++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=13)
    on Online Python Tutor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合自己的迭代器和自己的`contains()`方法在是否存在元素的问题上有分歧，那么显然集合是有问题的。你可以[在此代码中查看此代码的运行情况](http://www.pythontutor.com/java.html#code=import+java.util.*%3B%0Apublic+class+WhyObservationalEqualityHurts+%7B%0A++public+static+void+main(String%5B%5D+args%29+%7B%0A++++List%3CString%3E+list+%3D+new+ArrayList%3C%3E(%29%3B%0A++++list.add(%22a%22%29%3B%0A++++Set%3CList%3CString%3E%3E+set+%3D+new+HashSet%3CList%3CString%3E%3E(%29%3B%0A++++set.add(list%29%3B%0A++++System.out.println(%22set.contains(list%29%3D%22+%2B+set.contains(list%29%29%3B%0A++++list.add(%22goodbye%22%29%3B%0A++++System.out.println(%22set.contains(list%29%3D%22+%2B+set.contains(list%29%29%3B%0A++++for+(List%3CString%3E+l+%3A+set%29+%7B+%0A++++++System.out.println(%22set.contains(l%29%3D%22+%2B+set.contains(l%29%29%3B%0A++++%7D%0A++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=13)。
- en: What’s going on? `List<String>` is a mutable object. In the standard Java implementation
    of collection classes like `List`, mutations affect the result of `equals()` and
    `hashCode()`. When the list is first put into the `HashSet`, it is stored in the
    hash bucket corresponding to its `hashCode()` result at that time. When the list
    is subsequently mutated, its `hashCode()` changes, but `HashSet` doesn’t realize
    it should be moved to a different bucket. So it can never be found again.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？`List<String>`是一个可变对象。在标准Java集合类的实现中，如`List`，突变会影响`equals()`和`hashCode()`的结果。当列表首次放入`HashSet`时，它存储在对应于其那时的`hashCode()`结果的哈希桶中。当列表随后发生突变时，其`hashCode()`会更改，但`HashSet`不会意识到它应该移动到另一个桶中。因此，它永远无法再次被找到。
- en: When `equals()` and `hashCode()` can be affected by mutation, we can break the
    rep invariant of a hash table that uses that object as a key.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当`equals()`和`hashCode()`可能受到变化的影响时，我们可能会破坏将该对象用作键的哈希表的表示不变式。
- en: 'Here’s a telling quote from the specification of `java.util.Set`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`java.util.Set`规范的一句有意义的引用：
- en: 'Note: Great care must be exercised if mutable objects are used as set elements.
    The behavior of a set is not specified if the value of an object is changed in
    a manner that affects equals comparisons while the object is an element in the
    set.'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：如果将可变对象用作集合元素，则必须格外小心。如果在对象作为集合元素时以影响相等比较的方式更改对象的值，则集合的行为未指定。
- en: The Java library is unfortunately inconsistent about its interpretation of `equals()`
    for mutable classes. Collections use observational equality, but other mutable
    classes (like `StringBuilder`) use behavioral equality.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Java库对于其对可变类的`equals()`的解释不幸地不一致。集合使用观察性相等性，但其他可变类（如`StringBuilder`）使用行为上的相等性。
- en: The lesson we should draw from this example is that **`equals()` should implement
    behavioral equality**. In general, that means that two references should be `equals()`
    if and only if they are aliases for the same object. So mutable objects should
    just inherit `equals()` and `hashCode()` from `Object`. For clients that need
    a notion of observational equality (whether two mutable objects “look” the same
    in the current state), it’s better to define a new method, e.g., `similar()`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从这个例子中得出的教训是**`equals()`应实现行为上的相等性**。一般来说，这意味着两个引用只有在它们是同一对象的别名时才应该相等。因此，可变对象应该只是继承自`Object`的`equals()`和`hashCode()`。对于需要观察性相等性概念的客户端（即两个可变对象在当前状态下是否“看起来”相同），最好定义一个新方法，例如`similar()`。
- en: The Final Rule for equals() and hashCode()
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: equals()和hashCode()的最终规则
- en: '**For immutable types**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于不可变类型**：'
- en: '`equals()` should compare abstract values. This is the same as saying `equals()`
    should provide behavioral equality.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`应该比较抽象值。这等同于说`equals()`应提供行为上的相等性。'
- en: '`hashCode()` should map the abstract value to an integer.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashCode()`应将抽象值映射为整数。'
- en: So immutable types must override both `equals()` and `hashCode()`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不可变类型必须同时覆盖`equals()`和`hashCode()`。
- en: '**For mutable types**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于可变类型**：'
- en: '`equals()` should compare references, just like `==`. Again, this is the same
    as saying `equals()` should provide behavioral equality.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`应该比较引用，就像`==`一样。同样，这等同于说`equals()`应提供行为上的相等性。'
- en: '`hashCode()` should map the reference into an integer.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashCode()`应将引用映射到整数。'
- en: So mutable types should not override `equals()` and `hashCode()` at all, and
    should simply use the default implementations provided by `Object`. Java doesn’t
    follow this rule for its collections, unfortunately, leading to the pitfalls that
    we saw above.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可变类型根本不应该覆盖`equals()`和`hashCode()`，而应该简单地使用`Object`提供的默认实现。不幸的是，Java并没有遵循这个规则，而是在其集合中提供了默认实现，导致我们上面看到的陷阱。
- en: reading exercises
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Bag
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Bag
- en: 'Suppose `Bag<E>` is a mutable ADT representing what is often called a *multiset*,
    an unordered collection of objects where an object can occur more than once. It
    has the following operations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Bag<E>`是一个可变的ADT，代表通常称为*multiset*的无序对象集合，其中一个对象可以出现多次。它有以下操作：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Suppose we run this code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们运行以下代码：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Bag behavior
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Bag的行为
- en: If `Bag` is implemented with behavioral equality, which of the following expressions
    are true?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用行为上的相等性来实现`Bag`，那么以下哪些表达式是正确的？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Bean bag
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 豆袋
- en: If `Bag` were part of the Java API, it would probably implement observational
    equality, counter to the recommendation in the reading.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Bag`是 Java API 的一部分，它可能会实现观察性相等性，与阅读中的建议相悖。
- en: If `Bag` implemented observational equality despite the dangers, which of the
    following expressions are true?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Bag`尽管存在危险，实现了观察性相等性，那么以下哪些表达式是正确的？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Autoboxing and Equality
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动装箱和相等性
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,the_final_rule_for_equals_and_hashcode,autoboxing_and_equality/2w7-UynuSeI)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_15_equality,the_final_rule_for_equals_and_hashcode,autoboxing_and_equality/2w7-UynuSeI)'
- en: 'One more instructive pitfall in Java. We’ve talked about primitive types and
    their object type equivalents – for example, `int` and `Integer`. The object type
    implements `equals()` in the correct way, so that if you create two `Integer`
    objects with the same value, they’ll be `equals()` to each other:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的另一个有启发性的陷阱。我们已经讨论过原始类型及其对象类型等价物 - 例如，`int` 和 `Integer`。对象类型以正确的方式实现了`equals()`，因此如果您创建两个具有相同值的`Integer`对象，它们将互相`equals()`：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But there’s a subtle problem here; `==` is overloaded. For reference types
    like `Integer`, it implements referential equality:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个微妙的问题；`==`被重载了。对于像`Integer`这样的引用类型，它实现了引用相等性：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But for primitive types like `int`, `==` implements behavioral equality:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于像`int`这样的原始类型，`==`实现了行为相等性：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So you can’t really use `Integer` interchangeably with `int`. The fact that
    Java automatically converts between `int` and `Integer` (this is called *autoboxing*
    and *autounboxing*) can lead to subtle bugs! You have to be aware what the compile-time
    types of your expressions are. Consider this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您不能真正将`Integer`与`int`互换使用。Java 自动在`int`和`Integer`之间转换（这称为*自动装箱*和*自动拆箱*）可能导致微妙的错误！您必须意识到您表达式的编译时类型是什么。考虑这个：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can [see this code in action](http://www.pythontutor.com/java.html#code=import+java.util.*%3B%0Apublic+class+AutounboxingProblem+%7B%0A++public+static+void+main(String%5B%5D+args%29+%7B%0A++++Map%3CString,+Integer%3E+a+%3D+new+HashMap%3C%3E(%29,+b+%3D+new+HashMap%3C%3E(%29%3B%0A++++a.put(%22c%22,+130%29%3B+//+put+ints+into+the+map%0A++++b.put(%22c%22,+130%29%3B%0A++++System.out.println(%22a.get(%5C%22c%5C%22%29+%3D%3D+b.get(%5C%22c%5C%22%29+returns+%22%0A++++++++++++++++++++++++%2B+(a.get(%22c%22%29+%3D%3D+b.get(%22c%22%29%29+%29%3B%0A++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=6)
    on Online Python Tutor.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[这里查看代码运行情况](http://www.pythontutor.com/java.html#code=import+java.util.*%3B%0Apublic+class+AutounboxingProblem+%7B%0A++public+static+void+main(String%5B%5D+args%29+%7B%0A++++Map%3CString,+Integer%3E+a+%3D+new+HashMap%3C%3E(%29,+b+%3D+new+HashMap%3C%3E(%29%3B%0A++++a.put(%22c%22,+130%29%3B+//+put+ints+into+the+map%0A++++b.put(%22c%22,+130%29%3B%0A++++System.out.println(%22a.get(%5C%22c%5C%22%29+%3D%3D+b.get(%5C%22c%5C%22%29+returns+%22%0A++++++++++++++++++++++++%2B+(a.get(%22c%22%29+%3D%3D+b.get(%22c%22%29%29+%29%3B%0A++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=6)
    在 Online Python Tutor 上。
- en: reading exercises
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Boxes
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子
- en: In the last code example above…
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的最后一个代码示例中...
- en: What is the compile-time type of the expression `130`?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`130`的编译时类型是什么？
- en: <select class="form-control"><option>int</option>,<option>Integer</option>,<option>String</option>,<option>something
    else</option></select>(missing answer)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>int</option>,<option>Integer</option>,<option>String</option>,<option>something
    else</option></select>(缺失答案)
- en: (missing explanation)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: After executing `a.put("c", 130)`, what is the runtime type that is used to
    represent the value 130 in the map?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`a.put("c", 130)`后，在地图中表示值130所使用的运行时类型是什么？
- en: <select class="form-control"><option>int</option>,<option>Integer</option>,<option>String</option>,<option>something
    else</option></select>(missing answer)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>int</option>,<option>Integer</option>,<option>String</option>,<option>something
    else</option></select>(缺失答案)
- en: (missing explanation)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: What is the compile-time type of `a.get("c")`?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.get("c")`的编译时类型是什么？'
- en: <select class="form-control"><option>int</option>,<option>Integer</option>,<option>String</option>,<option>something
    else</option></select>(missing answer)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>int</option>,<option>Integer</option>,<option>String</option>,<option>something
    else</option></select>(缺失答案)
- en: (missing explanation)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Circles
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 圆圈
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Draw a snapshot diagram after the code above has executed. How many `HashMap`
    objects are in your snapshot diagram?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码执行后绘制一个快照图。你的快照图中有多少个`HashMap`对象？
- en: (missing answer)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: How many `Integer` objects are in your snapshot diagram?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你的快照图中有多少个`Integer`对象？
- en: (missing answer)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Equals
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Equals
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After this code executes, what would `a.get("c").equals(b.get("c"))` return?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行后，`a.get("c").equals(b.get("c"))`会返回什么？
- en: <select class="form-control"><option>true­</option>,<option>false­</option>,<option>compile-time
    error</option>,<option>runtime error</option></select>(missing answer)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>true­</option>,<option>false­</option>,<option>compile-time
    error</option>,<option>runtime error</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: What would `a.get("c") == b.get("c")` return?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.get("c") == b.get("c")`会返回什么？'
- en: <select class="form-control"><option>true­</option>,<option>false­</option>,<option>compile-time
    error</option>,<option>runtime error</option></select>(missing answer)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>true­</option>,<option>false­</option>,<option>compile-time
    error</option>,<option>runtime error</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Unboxes
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Unboxes
- en: 'Now suppose you assign the `get()` results to `int` variables:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你将`get()`的结果赋给`int`变量：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After executing this code, what is the value of `isEqual`?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完此代码后，`isEqual`的值是多少？
- en: <select class="form-control"><option>true­</option>,<option>false­</option>,<option>compile-time
    error</option>,<option>runtime error</option></select>(missing answer)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>true­</option>,<option>false­</option>,<option>compile-time
    error</option>,<option>runtime error</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Equality should be an equivalence relation (reflexive, symmetric, transitive).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性应该是一个等价关系（自反的，对称的，传递的）。
- en: Equality and hash code must be consistent with each other, so that data structures
    that use hash tables (like `HashSet` and `HashMap`) work properly.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性和哈希码必须彼此一致，以便使用哈希表的数据结构（如`HashSet`和`HashMap`）正常工作。
- en: The abstraction function is the basis for equality in immutable data types.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象函数是不可变数据类型中相等性的基础。
- en: Reference equality is the basis for equality in mutable data types; this is
    the only way to ensure consistency over time and avoid breaking rep invariants
    of hash tables.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用相等性是可变数据类型中相等性的基础；这是确保随着时间的推移保持一致性并避免破坏哈希表表示不变式的唯一方法。
- en: 'Equality is one part of implementing an abstract data type, and we’ve already
    seen how important ADTs are to achieving our three primary objectives. Let’s look
    at equality in particular:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 相等性是实现抽象数据类型的一部分，我们已经看到ADT对于实现我们的三个主要目标是多么重要。让我们特别看看相等性：
- en: '**Safe from bugs**. Correct implementation of equality and hash codes is necessary
    for use with collection data types like sets and maps. It’s also highly desirable
    for writing tests. Since every object in Java inherits the `Object` implementations,
    immutable types must override them.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免于错误**。正确实现相等性和哈希码对于与集合数据类型（如集合和映射）一起使用是必要的。对于编写测试来说也是非常有益的。由于Java中的每个对象都继承了`Object`的实现，不可变类型必须覆盖它们。'
- en: '**Easy to understand**. Clients and other programmers who read our specs will
    expect our types to implement an appropriate equality operation, and will be surprised
    and confused if we do not.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**。阅读我们规范的客户和其他程序员会期望我们的类型实现适当的相等操作，如果我们没有这样做，他们会感到惊讶和困惑。'
- en: '**Ready for change**. Correctly-implemented equality for *immutable* types
    separates equality of reference from equality of abstract value, hiding from clients
    our decisions about whether values are shared. Choosing behavioral rather than
    observational equality for *mutable* types helps avoid unexpected aliasing bugs.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为变更做好准备**。对于*不可变*类型正确实现的相等性将引用的相等性与抽象值的相等性分开，从而隐藏了我们关于值是否共享的决策。对于*可变*类型选择行为而不是观察性的相等性有助于避免意外的别名错误。'
