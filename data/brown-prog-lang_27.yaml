- en: '27Reasoning about Programs: A First Look at Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 27关于程序的推理：类型的初步了解
- en: '|     [27.1 Types as a Static Discipline](#%28part._.Types_as_a_.Static_.Discipline%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [27.1 类型作为静态学科](#%28part._.Types_as_a_.Static_.Discipline%29) |'
- en: '|     [27.2 The Principle of Substitutability](#%28part._type-substitutability%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [27.2 可替代性原则](#%28part._type-substitutability%29) |'
- en: '|     [27.3 A Type(d) Language and Type Errors](#%28part._.A_.Type_d__.Language_and_.Type_.Errors%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [27.3 类型化的语言和类型错误](#%28part._.A_.Type_d__.Language_and_.Type_.Errors%29)
    |'
- en: '|       [27.3.1 Assume-Guarantee Reasoning](#%28part._assume-guarantee%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [27.3.1 假设-保证推理](#%28part._assume-guarantee%29) |'
- en: '|     [27.4 A Type Checker for Expressions and Functions](#%28part._type-checker%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|     [27.4 表达式和函数的类型检查器](#%28part._type-checker%29) |'
- en: '|       [27.4.1 A Pure Checker](#%28part._.A_.Pure_.Checker%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [27.4.1 一个纯粹的检查器](#%28part._.A_.Pure_.Checker%29) |'
- en: '|       [27.4.2 A Calculator and Checker](#%28part._.A_.Calculator_and_.Checker%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|       [27.4.2 一个计算器和检查器](#%28part._.A_.Calculator_and_.Checker%29) |'
- en: '|       [27.4.3 Type-Checking Versus Interpretation](#%28part._.Type-.Checking_.Versus_.Interpretation%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [27.4.3 类型检查与解释](#%28part._.Type-.Checking_.Versus_.Interpretation%29)
    |'
- en: '|     [27.5 Type-Checking, Testing, and Coverage](#%28part._types-v-tests%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|     [27.5 类型检查、测试和覆盖率](#%28part._types-v-tests%29) |'
- en: '|     [27.6 Recursion in Code](#%28part._.Recursion_in_.Code%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|     [27.6 代码中的递归](#%28part._.Recursion_in_.Code%29) |'
- en: '|       [27.6.1 A First Attempt at Typing Recursion](#%28part._.A_.First_.Attempt_at_.Typing_.Recursion%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [27.6.1 对递归进行类型检查的第一次尝试](#%28part._.A_.First_.Attempt_at_.Typing_.Recursion%29)
    |'
- en: '|       [27.6.2 Program Termination](#%28part._strong-normalization%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|       [27.6.2 程序终止](#%28part._strong-normalization%29) |'
- en: '|       [27.6.3 Typing Recursion](#%28part._.Typing_.Recursion%29) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|       [27.6.3 对递归进行类型检查](#%28part._.Typing_.Recursion%29) |'
- en: '|     [27.7 Recursion in Data](#%28part._.Recursion_in_.Data%29) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|     [27.7 数据中的递归](#%28part._.Recursion_in_.Data%29) |'
- en: '|       [27.7.1 Recursive Datatype Definitions](#%28part._.Recursive_.Datatype_.Definitions%29)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|       [27.7.1 递归数据类型定义](#%28part._.Recursive_.Datatype_.Definitions%29) |'
- en: '|       [27.7.2 Introduced Types](#%28part._.Introduced_.Types%29) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|       [27.7.2 引入的类型](#%28part._.Introduced_.Types%29) |'
- en: '|       [27.7.3 Selectors](#%28part._.Selectors%29) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|       [27.7.3 选择器](#%28part._.Selectors%29) |'
- en: '|       [27.7.4 Pattern-Matching and Desugaring](#%28part._.Pattern-.Matching_and_.Desugaring%29)
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|       [27.7.4 模式匹配和解糖](#%28part._.Pattern-.Matching_and_.Desugaring%29) |'
- en: 'One of the themes of this book is predictability ([Predictability as a Theme](Introduction.html#%28part._predictability%29)).
    One of our key tools in reasoning about program behavior before we run it is the
    static checking of types. For example, when we write x :: Number, we mean that
    x will always hold a Number, and that all parts of the program that depend on
    x can rely on this statement being enforced. As we will see, types are just one
    point in a spectrum of invariants we might wish to state, and static type checking—<wbr>itself
    a diverse family of techniques—<wbr>is also a point in a spectrum of methods we
    can use to enforce the invariants.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '本书的一个主题是可预测性（[作为主题的可预测性](Introduction.html#%28part._predictability%29)）。在我们运行程序之前推理程序行为的一个关键工具是类型的静态检查。例如，当我们写
    x :: Number 时，我们的意思是 x 将始终保存一个数字，并且所有依赖于 x 的程序部分都可以依赖于这个语句被执行。正如我们将看到的，类型只是我们可能希望陈述的不变量光谱中的一个点，而静态类型检查——<wbr>本身是一系列多样的技术——<wbr>也是我们可以用来强制执行不变量的方法光谱中的一个点。'
- en: 27.1Types as a Static Discipline
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 27.1类型作为静态学科
- en: 'In this chapter, we will focus especially on static type checking: that is,
    checking (declared) types before the program even executes.This is an extremely
    rich and active subject. For further study, I strongly recommend reading Pierce’s
    Types and Programming Languages. We will explore some of the design space of types
    and their trade-offs. Finally, though static typing is an especially powerful
    and important form of invariant enforcement, we will also examine some other techniques
    that we have available [REF].'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将特别关注静态类型检查：也就是说，在程序执行之前检查（声明的）类型。这是一个非常丰富和活跃的主题。为了进一步学习，我强烈建议阅读皮尔斯的《类型与编程语言》。我们将探讨一些类型设计空间和它们的权衡。最后，虽然静态类型是一种特别强大和重要的不变量强制形式，但我们还将检查一些其他可用的技术[REF]。
- en: 'Consider this Pyret program:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个 Pyret 程序：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We would like to receive a type error before the program begins execution.Pyret
    does not currently perform static type checking, but this will soon change. The
    same program (without the type annotations) can fail only at run-time:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在程序开始执行之前收到类型错误。Pyret目前不执行静态类型检查，但这很快会改变。同样的程序（没有类型注释）只能在运行时失败：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Exercise
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you test the assertions that one fails before the program executes
    while the other fails during execution?
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何测试一个在程序执行之前失败而另一个在执行过程中失败的断言？
- en: 'Now consider the following Pyret program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下Pyret程序：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This too fails before program execution begins, with a parse error. Though
    we think of parsing as being somehow distinct from type-checking—<wbr>usually
    because a type-checker assumes it has a parsed program to begin with—<wbr>it can
    be useful to think of parsing as being simply the very simplest kind of type-checking:
    determining (typically) whether the program obeys a context-free syntax. Type-checking
    then asks whether it obeys a context-sensitive (or richer) syntax. In short, type-checking
    is a generalization of parsing, in that both are concerned with syntactic methods
    for enforcing disciplines on programs.This particular, and very influential, phrasing
    is due to John Reynolds.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这也在程序执行之前失败，出现了解析错误。虽然我们认为解析与类型检查在某种程度上是不同的——通常是因为类型检查器假定它已经有了一个解析的程序——但将解析视为最简单的类型检查可能是有用的：通常是确定程序是否遵守无上下文语法。然后，类型检查问是否遵守上下文敏感（或更丰富）的语法。简而言之，类型检查是解析的一般化，因为两者都关注强制程序遵守规则的句法方法。这种特定且非常有影响力的表述归功于约翰·雷诺兹。
- en: We will begin by introducing a traditional core language of types. Later, we
    will explore both extensions [REF] and variations [REF].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍传统核心类型语言。稍后，我们将探讨扩展[REF]和变体[REF]。
- en: 27.2The Principle of Substitutability
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 27.2可替代性原则
- en: 'The essence of any typing mechanism is usually the principle of substitutability:
    two types A and B “match” when values of one can be used in place of values of
    the other. Therefore, the design of a type system implicitly forces us to consider
    when such substitutions are safe (in the sense given by [The Central Theorem:
    Type Soundness](safety-soundness.html#%28part._type-soundness%29)).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型机制的本质通常是可替代性原则：当一个类型A和B“匹配”时，一个类型的值可以用于另一个类型的值的位置。因此，类型系统的设计隐含地迫使我们考虑这种替换何时是安全的（如[中心定理：类型完备性](safety-soundness.html#%28part._type-soundness%29)所述）。
- en: 'Of course, the simplest notion of substitutability is simply identity: a type
    can only be substituted with itself, and nothing else. For instance, if the declared
    type of a function’s parameter is String, then you can only call it with String-typed
    values, nothing else. This is known as invariance: the set of values that can
    be passed into a type cannot “vary” from the set expected by that type. This is
    so obvious that it might seem to hardly warrant a name! However, it is useful
    to name because it sets up a contrast with later type systems when we will have
    richer, non-trivial notions of substitutability (see [Subtyping](objects.html#%28part._subtyping%29)).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最简单的可替代性概念就是身份：一个类型只能被其自身替代，不能被其他任何东西替代。例如，如果函数参数的声明类型是String，那么你只能用String类型的值调用它，不能用其他任何东西。这被称为不变性：可以传递到类型中的值的集合不能与该类型期望的集合“变化”。这是如此显而易见，以至于似乎几乎不值得一提！然而，给它起个名字是有用的，因为它与后来的类型系统形成对比，当我们有更丰富、非平凡的可替代性概念时（参见[子类型化](objects.html#%28part._subtyping%29)）。
- en: 27.3A Type(d) Language and Type Errors
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 27.3A 类型(d) 语言和类型错误
- en: 'Before we can define a type checker, we have to fix two things: the syntax
    of our typed core language and, hand-in-hand with that, the syntax of types themselves.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义类型检查器之前，我们必须解决两个问题：我们的类型核心语言的语法以及与此同时，类型本身的语法。
- en: We’ll begin with our language with functions-as-values ([Functions Anywhere](Interpreting_Functions.html#%28part._higher-order-functions%29)).
    To this language we have to add type annotations. Conventionally, we don’t impose
    type annotations on constants or on primitive operations such as addition, because
    this would be unbearably tedious; instead, we impose them on the boundaries of
    functions or methods. Over the course of this study we will explore why this is
    a good locus for annotations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从具有函数作为值的语言开始（[随处可见的函数](Interpreting_Functions.html#%28part._higher-order-functions%29)）。对于这种语言，我们必须添加类型注释。通常，我们不会对常量或原始操作（如加法）强加类型注释，因为这将令人无法忍受；相反，我们将它们强加在函数或方法的边界上。在本研究过程中，我们将探讨为什么这是注释的一个好位置。
- en: 'Given this decision, our typed core language becomes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个决定，我们的核心语言变成了：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That is, every procedure is annotated with the type of argument it expects and
    type of argument it purports to produce.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个过程都注释了它期望的参数类型和它声称要生成的参数类型。
- en: 'Now we have to decide on a language of types. To do so, we follow the tradition
    that the types abstract over the set of values. In our language, we have [three
    kinds of values](Interpreting_Functions.html#%28elem._hof-value%29). It follows
    that we should have three kinds of types: one each for numbers, Booleans, and
    functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须决定一种类型语言。为此，我们遵循的传统是类型抽象于值集合之上。在我们的语言中，我们有[三种值的类型](Interpreting_Functions.html#%28elem._hof-value%29)。因此，我们应该有三种类型：分别用于数字、布尔值和函数。
- en: What information does a number type need to record? In most languages, there
    are actually many numeric types, and indeed there may not even be a single one
    that represents “numbers”. However, we have ignored these gradations between numbers
    ((part "change-rep")), so it’s sufficient for us to have just one. Having decided
    that, do we record additional information about which number? We could in principle,
    but that would mean for types to check, we would have to be able to decide whether
    two expressions compute the same number—<wbr>a problem that reduces to the Halting
    Problem [REF].In some specialized type systems, however, we do record some information
    about the number. These systems either have some means of approximation that lets
    them avoid the Halting Problem, or embrace it by not guaranteeing termination!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数字类型需要记录哪些信息？在大多数语言中，实际上有许多数字类型，甚至可能没有一个表示“数字”的类型。然而，我们忽略了数字之间的这些渐变（（部分“change-rep”）），因此对于我们来说，只有一个就足够了。决定了这一点之后，我们是否记录关于哪个数字的附加信息？原则上我们可以，但这意味着为了检查类型，我们必须能够决定两个表达式是否计算出相同的数字——<wbr>这是一个归结为停机问题的问题[REF]。然而，在一些专门的类型系统中，我们确实记录了有关数字的一些信息。这些系统要么具有一些近似的手段，可以避免停机问题，要么通过不保证终止来接受它！
- en: 'We treat Booleans just like numbers: we ignore which Boolean it is. Here, we
    perhaps have more value in being precise, because there are only two values we
    need to track, not an infinite number. That means in some cases, we even know
    which branch of a conditional we will take, and can examine only that branch (though
    that may miss a type-error lurking in the other branch: what should we do about
    that?). However, even the problem of knowing precisely which Boolean we have reduces
    to the Halting Problem [REF].'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将布尔值视为数字：我们忽略它是哪种布尔值。在这里，我们可能更需要精确，因为我们只需要跟踪两个值，而不是无限个数。这意味着在某些情况下，我们甚至知道将会执行条件语句的哪个分支，并且可以仅检查该分支（尽管这可能会错过另一个分支中潜在的类型错误：我们应该怎么处理？）。然而，甚至知道我们有哪种精确布尔值的问题都归结为停机问题[REF]。
- en: Exercise
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct an argument for why determining which number or Boolean an arbitrary
    expression evaluates to is equivalent to solving the Halting Problem.
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么确定任意表达式求值为哪个数字或布尔值等同于解决停机问题的一个理由。
- en: 'As for functions, we have more information: the type of expected argument,
    and the type of claimed result. We might as well record this information we have
    been given until and unless it has proven to not be useful. Combining these, we
    obtain the following abstract language of types:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 至于函数，我们有更多信息：期望参数的类型和声称结果的类型。我们可能会记录这些信息，直到它被证明是无用的为止。将这些结合起来，我们得到以下抽象类型语言：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we’ve fixed both the term and type structure of the language, let’s
    make sure we agree on what constitute type errors in our language (and, by fiat,
    everything not a type error must pass the type checker). There are three obvious
    forms of type errors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修复了语言的术语和类型结构，让我们确保我们对于在我们的语言中构成类型错误的内容达成一致意见（并且，按照规定，任何不是类型错误的内容都必须通过类型检查器）。类型错误有三种明显的形式：
- en: One or both arguments of + is not a number, i.e., does not have type numT.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法的一个或两个参数不是数字，即不具有类型 numT。
- en: One or both arguments of * is not a number.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法的一个或两个参数不是数字。
- en: The expression in the function position of an application is not a function,
    i.e., does not have type funT.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用的函数位置上的表达式不是一个函数，即不具有类型 funT。
- en: Do Now!
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any more?
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有吗？
- en: 'We’re actually missing one:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实漏掉了一个：
- en: The expression in the function position of an application is a function but
    the type of the actual argument does not match the type of the formal argument
    expected by the function.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用的函数位置上的表达式是一个函数，但实际参数的类型与函数期望的形式参数的类型不匹配。
- en: Do Now!
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any more?
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有吗？
- en: 'What about:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么呢：
- en: The expression in the function position of an application is a function but
    its return type does not match the type expected by the expression that invokes
    the function?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用的函数位置上的表达式是一个函数，但其返回类型与调用该函数的表达式所期望的类型不匹配？
- en: 'And we’re still not done!Instead of this kind of ad hoc enumeration, what we
    really ought to do is systematically go over each of the syntactic forms of our
    language and ask how each of them can produce a type error. That indicates:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！与其进行这种临时枚举，我们真正应该做的是系统地审查我们语言的每种语法形式，并询问每种形式如何产生类型错误。这表示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A number on its own can never be a type error. For addition and multiplication,
    both branches must have numeric type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的数字永远不会导致类型错误。对于加法和乘法，两个分支都必须具有数字类型。
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Just as with numbers, Boolean constants on their own cannot be a type error.
    In a conditional, however, we require:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字一样，布尔常量本身不会导致类型错误。然而，在条件语句中，我们要求：
- en: The conditional expression must have type Boolean.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件表达式必须具有布尔类型。
- en: Both branches must have the same type (whatever it may be).Implicit is the idea
    that we can easily determine when two types are the “same”. We’ll return to this
    in [Subtyping](objects.html#%28part._subtyping%29).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个分支必须具有相同的类型（无论它是什么）。隐含的是我们可以轻松确定两种类型何时相同的想法。我们将在 [子类型化](objects.html#%28part._subtyping%29)
    中返回这一点。
- en: 'And finally:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An identifier on its own is never type-erroneous. Applications expect:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的标识符永远不会导致类型错误。应用期望：
- en: The function position (f) must have a function type (funT).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数位置（f）必须具有函数类型（funT）。
- en: The type of the actual argument expression (a) must match the argument type
    (.arg) of the function position.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际参数表达式（a）的类型必须与函数位置的形式参数的类型（.arg）匹配。
- en: 'And finally, a function definition expects:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数定义期望：
- en: The type of the body—<wbr>assuming the formal argument (arg) has been given
    a value of the declared type (at)—<wbr>matches the type declared (rt) as the return
    type.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体的类型——<wbr>假设形式参数（arg）已经被赋予了声明类型（at）的值——与声明的返回类型（rt）相匹配。
- en: 27.3.1Assume-Guarantee Reasoning
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.3.1 假设保证推理
- en: The last few cases we just saw had a very interesting structure. Did you spot
    it?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的最后几种情况有一个非常有趣的结构。你注意到了吗？
- en: 'The rules for function definition and declaration complement each other perfectly.
    Let’s illustrate this with a program written in Pyret syntax:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义和声明的规则完美地相辅相成。让我们通过一个用 Pyret 语法编写的程序来说明这一点：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When type-checking the definition of f, we assume that if and when f is eventually
    applied, it will be applied to a value of String type. We do assume this because
    the annotation on x is String. We can assume this because when checking the application,
    we will first look up the type of f, observe that it expects a String-typed value,
    and confirm that the actual argument indeed matches this type. That is, the type-checker’s
    treatment of application guarantees that this assumption is safe.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 f 的定义进行类型检查时，我们假设当 f 最终被应用时，它将被应用到一个 String 类型的值上。我们之所以假设这一点是因为 x 上的注释是 String。我们可以这样假设是因为在检查应用时，我们将首先查找
    f 的类型，观察到它期望一个 String 类型的值，并确认实际参数确实匹配了这种类型。也就是说，类型检查器对应用的处理保证了这一假设的安全性。
- en: Similarly, when type-checking the application, having looked up the type of
    f, we assume that it will indeed return a value of type Number. We can assume
    this because that is the return type annotation of f. We do assume it because
    the type-checker will ensure that the body of f—<wbr>assuming the type of x—<wbr>will
    indeed return a Number. That is, once again, the type-checker’s treatment of function
    definitions guarantees that the assumption at function applications is safe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在对应用程序进行类型检查时，我们查找了f的类型后，假设它确实会返回一个Number类型的值。我们可以这样假设，因为那是f的返回类型注释。我们之所以这样假设，是因为类型检查器将确保f的主体——假设x的类型——确实会返回一个Number。换句话说，再次强调，函数定义的类型检查器处理保证了函数应用程序的假设是安全的。
- en: 'In short, the treatment of function definition and application are complementary.
    They are joined together by a method called assume-guarantee reasoning, whereby
    each side’s assumptions are guaranteed by the other side, and the two stitch together
    perfectly to give us the desired safe execution (which we elaborate on later:
    [The Central Theorem: Type Soundness](safety-soundness.html#%28part._type-soundness%29)).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，函数定义和应用程序的处理是互补的。它们通过一种称为假设-保证推理的方法联系在一起，每一方的假设都由另一方保证，并且两者完美地结合在一起，以给我们所需的安全执行（我们稍后会详细介绍：[中心定理：类型正确性](safety-soundness.html#%28part._type-soundness%29)）。
- en: 27.4A Type Checker for Expressions and Functions
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 27.4A 表达式和函数的类型检查器
- en: 27.4.1A Pure Checker
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.4.1A 纯类型检查器
- en: 'Since the job of a type-checker is to pass judgment on programs—<wbr>in particular,
    to indicate whether a program passes or fails type-checking—<wbr>a natural type
    for a type-checker would be:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型检查器的工作是对程序进行评判——特别是指示程序是否通过类型检查——类型检查器的自然类型将是：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, because we know expressions contain identifiers, it soon becomes clear
    that we will want a type environment, which maps names to types, analogous to
    the value environment we have seen so far.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，因为我们知道表达式包含标识符，所以很快就会清楚，我们将需要一个类型环境，它将名称映射到类型，类似于我们到目前为止所看到的值环境。
- en: Exercise
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define the types and functions associated with type environments.
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义与类型环境相关的类型和函数。
- en: Thus, we might begin our program as follows:<hof-tc-bool> ::=
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能会这样开始我们的程序：<hof-tc-bool> ::=
- en: '|   fun tc(e :: TyExprC, tnv :: TyEnv) -> Boolean: |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|   fun tc(e :: TyExprC, tnv :: TyEnv) -> Boolean: |'
- en: '|     cases (TyExprC) e: |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|     cases (TyExprC) e: |'
- en: '|       [<hof-tc-bool-numC>](#%28elem._hof-tc-bool-num.C%29) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-bool-numC>](#%28elem._hof-tc-bool-num.C%29) |'
- en: '|       [<hof-tc-bool-idC>](#%28elem._hof-tc-bool-id.C%29) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-bool-idC>](#%28elem._hof-tc-bool-id.C%29) |'
- en: '|       [<hof-tc-bool-appC>](#%28elem._hof-tc-bool-app.C%29) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-bool-appC>](#%28elem._hof-tc-bool-app.C%29) |'
- en: '|     end |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: 'As the abbreviated set of cases above suggests, this approach will not work
    out. We’ll soon see why.Let’s begin with the easy case: numbers. Does a number
    type-check? Well, on its own, of course it does; it may be that the surrounding
    context is not expecting a number, but that error would be signaled elsewhere.
    Thus:<hof-tc-bool-numC> ::='
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上面缩写的情况集所示，这种方法不会奏效。我们很快就会看到原因。让我们从简单的情况开始：数字。数字类型检查吗？当然检查；可能周围的上下文不希望是数字，但那种错误将在其他地方被标识。因此：<hof-tc-bool-numC>
    ::=
- en: '|   &#124; numC(_) => true |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; numC(_) => true |'
- en: (Notice that we’re expressly ignoring which number it is.)Now let’s handle identifiers.
    Is an identifier well-typed? Again, on its own it would appear to be, provided
    it is actually a bound identifier; it may not be what the context desires, but
    hopefully that too would be handled elsewhere. Thus we might write<hof-tc-bool-idC>
    ::=
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，我们明确忽略了它是哪个数字。）现在让我们处理标识符。标识符是否被正确地类型化？同样，单独来看，它似乎是，只要它实际上是一个已绑定的标识符；它可能不是上下文所需的，但希望那也会在其他地方处理。因此，我们可能会写<hof-tc-bool-idC>
    ::=
- en: '|   &#124; idC(s) => ty-lookup(s, tnv) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; idC(s) => ty-lookup(s, tnv) |'
- en: where ty-lookup returns true if the identifier is bound, and false otherwise.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，如果标识符已绑定，则ty-lookup返回true，否则返回false。
- en: 'This should make you a little uncomfortable: we seem to be throwing away valuable
    information about the type of the identifier. Of course, types do throw away information
    (e.g., which specific number an expression computes). However, the kind of information
    we’re throwing away here is much more significant: it’s not about a specific value
    within a type, but the type itself. Nevertheless, let’s push on.It might also
    bother you that, by only returning a Boolean, we have no means to express what
    type error occurred. But you might assuage yourself by saying that’s only because
    we have too weak a return type.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让你有点不舒服：我们似乎正在丢弃关于标识符类型的宝贵信息。当然，类型确实会丢失信息（例如，表达式计算的具体数字）。然而，我们在这里丢弃的信息类型更为重要：它不是关于类型内特定值的信息，而是类型本身。尽管如此，让我们继续前进。你可能也会觉得困扰，因为我们只返回一个布尔值，我们无法表达发���了什么类型错误。但你可以安慰自己说这只是因为我们的返回类型太弱。
- en: Now we tackle applications. We should type-check both the function part, to
    make sure it’s a function, then ensure that the actual argument’s type is consistent
    with what the function declares to be the type of its formal argument. How does
    the code look?<hof-tc-bool-appC> ::=
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理应用程序。我们应该对函数部分进行类型检查，确保它是一个函数，然后确保实际参数的类型与函数声明的形式参数类型一致。代码看起来怎么样？<hof-tc-bool-appC>
    ::=
- en: '|   &#124; appC(f, a) => |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; appC(f, a) => |'
- en: '|     f-t = tc(f, tnv) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|     f-t = tc(f, tnv) |'
- en: '|     a-t = tc(a, tnv) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|     a-t = tc(a, tnv) |'
- en: '|     ... |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|     ... |'
- en: The two recursive calls to tc can only tell us whether the function and argument
    expressions type-check or not. Critically, they cannot tell us whether the argument
    expression’s type (what is it?) matches that of the function’s expected argument
    type (what is it?). Though we might be able to fudge this in the case of simple
    expressions, for complex ones we cannot just examine the expression; furthermore,
    this violates our principle of wanting to avoid probing deep into expressions.
    Put differently, we’d like to have written
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对tc的两个递归调用只能告诉我们函数和参数表达式是否通过类型检查。关键是，它们无法告诉我们参数表达式的类型（它是什么？）是否与函数期望的参数类型匹配（它是什么？）。虽然在简单表达式的情况下我们可能能够糊弄过去，但对于复杂表达式，我们不能仅仅检查表达式；此外，这违反了我们希望避免深入表达式的原则。换句话说，我们希望写成
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: but f-t is a Boolean and hence can never pass is-funT; similarly, comparing
    a-t with f-t.arg is meaningless because both are Booleans (representing whether
    or not the corresponding sub-expressions type-checked), not the actual types of
    those expressions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但f-t是一个布尔值，因此永远无法通过is-funT；同样，将a-t与f-t.arg进行比较是没有意义的，因为两者都是布尔值（表示相应的子表达式是否通过类型检查），而不是这些表达式的实际类型。
- en: In other words, what we need is something that will calculate the type of an
    expression, no matter how complex it is. Of course, such a procedure could only
    succeed if the expression is well-typed; otherwise it would not be able to provide
    a coherent answer. In other words, a type “calculator” has type “checking” as
    a special case!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要的是一种能够计算表达式类型的东西，无论它有多复杂。当然，这样的过程只有在表达式类型正确时才能成功；否则它将无法提供一个连贯的答案。换句话说，类型“计算器”将类型“检查”作为一个特例！
- en: Do Now!
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That was subtle. Read it again.
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这有点微妙。再读一遍。
- en: 'We should therefore strengthen the inductive invariant on tc: that it not only
    tells us whether an expression is typed, but also what its type is. Indeed, by
    giving any type at all it confirms that the expression types, and otherwise it
    signals an error.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该加强对tc的归纳不变性：它不仅告诉我们一个表达式是否有类型，还告诉我们它的类型是什么。实际上，通过给出任何类型，它确认了表达式的类型，否则它会报错。
- en: 27.4.2A Calculator and Checker
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.4.2A 计算器和检查器
- en: Let’s now define this richer notion of a type “checker”.<hof-tc> ::=
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义这个更丰富的类型“检查器”。<hof-tc> ::=
- en: '|   fun tc(e :: TyExprC, tnv :: TyEnv) -> Type: |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|   fun tc(e :: TyExprC, tnv :: TyEnv) -> Type: |'
- en: '|     cases (TyExprC) e: |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|     cases (TyExprC) e: |'
- en: '|       [<hof-tc-numC>](#%28elem._hof-tc-num.C%29) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-numC>](#%28elem._hof-tc-num.C%29) |'
- en: '|       [<hof-tc-plusC>](#%28elem._hof-tc-plus.C%29) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-plusC>](#%28elem._hof-tc-plus.C%29) |'
- en: '|       [<hof-tc-multC>](#%28elem._hof-tc-mult.C%29) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-multC>](#%28elem._hof-tc-mult.C%29) |'
- en: '|       [<hof-tc-bools>](#%28elem._hof-tc-bools%29) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-bools>](#%28elem._hof-tc-bools%29) |'
- en: '|       [<hof-tc-idC>](#%28elem._hof-tc-id.C%29) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-idC>](#%28elem._hof-tc-id.C%29) |'
- en: '|       [<hof-tc-fdC>](#%28elem._hof-tc-fd.C%29) |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-fdC>](#%28elem._hof-tc-fd.C%29) |'
- en: '|       [<hof-tc-appC>](#%28elem._hof-tc-app.C%29) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|       [<hof-tc-appC>](#%28elem._hof-tc-app.C%29) |'
- en: '|     end |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: 'Now let’s fill in the pieces. Numbers are easy: they have the numeric type.<hof-tc-numC>
    ::='
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们填补这些空白。数字很容易：它们有数字类型。<hof-tc-numC> ::=
- en: '|   &#124; numC(_) => numT |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; numC(_) => numT |'
- en: Similarly, identifiers have whatever type the environment says they do (and
    if they aren’t bound, looking them up signals an error).<hof-tc-idC> ::=
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，标识符具有环境中指定的任何类型（如果它们没有绑定，查找它们会报错）。<hof-tc-idC> ::=
- en: '|   &#124; idC(s) => ty-lookup(s, tnv) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; idC(s) => ty-lookup(s, tnv) |'
- en: 'Observe, so far, the similarity to and difference from interpreting: in the
    identifier case we did essentially the same thing (except we returned a type rather
    than an actual value), whereas in the numeric case we returned the abstract “number”
    (numT) rather than indicate which specific number it was.Let’s now examine addition.
    We must make sure both sub-expressions have numeric type; only if they do will
    the overall expression evaluate to a number itself. It will be useful to employ
    a helper function:<hof-tc-plusC> ::='
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，到目前为止，解释和类型检查之间的相似性和差异：在标识符情况下，我们基本上做了相同的事情（除了我们返回一个类型而不是实际值），而在数字情况下，我们返回了抽象的“数字”（numT）而不是指示它是哪个具体的数字。现在让我们来看看加法。我们必须确保两个子表达式都有数字类型；只有这样，整体表达式才能评估为一个数字本身。使用一个辅助函数会很有用：<hof-tc-plusC>
    ::=
- en: '|   &#124; plusC(l, r) => tc-arith-binop(l, r, tnv) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; plusC(l, r) => tc-arith-binop(l, r, tnv) |'
- en: 'where:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s worth not glossing over multiplication:<hof-tc-multC> ::=
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忽略乘法的重要性：<hof-tc-multC> ::=
- en: '|   &#124; multC(l, r) => tc-arith-binop(l, r, tnv) |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; multC(l, r) => tc-arith-binop(l, r, tnv) |'
- en: Do Now!
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you see what’s different?
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你看到了什么不同的地方吗？
- en: 'That’s right: nothing! That’s because, from the perspective of type-checking
    (in this type language), there is no difference between addition and multiplication,
    or indeed between any two operations that consume two numbers and return one.
    Because we are ignoring the actual numbers, we don’t even need to bother passing
    tc-arith-binop a function that reflects what to do with the pair of numbers.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 没错：什么都没有！这是因为，从类型检查的角度来看（在这种类型语言中），加法和乘法之间没有区别，实际上在任何消耗两个数字并返回一个数字的两个操作之间也没有区别。因为我们忽略了实际的数字，所以我们甚至不需要费心向tc-arith-binop传递一个反映如何处理数字对的函数。
- en: 'Observe another difference between interpreting and type-checking. Both care
    that the arguments be numbers. The interpreter then returns a precise sum or product,
    but the type-checker is indifferent to the differences between them: therefore
    the expression that computes what it returns (numT) is a constant, and the same
    constant in both cases.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意解释和类型检查之间的另一个差异。两者都关心参数是数字。然后解释器返回一个精确的和或乘积，但类型检查器对它们之间的区别漠不关心：因此计算返回的表达式（numT）是一个常量，并且两种情况下都是相同的常量。
- en: Next, let’s handle Boolean values and conditionals. We’re simply going to transcribe
    into code what we earlier agreed to do:<hof-tc-bools> ::=
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理布尔值和条件语句。我们将简单地把我们先前同意的内容转录成代码：<hof-tc-bools> ::=
- en: '|   &#124; trueC => boolT |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; trueC => boolT |'
- en: '|   &#124; falseC => boolT |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; falseC => boolT |'
- en: '|   &#124; ifC(cnd, thn, els) => |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; ifC(cnd, thn, els) => |'
- en: '|     cnd-t = tc(cnd, tnv) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|     cnd-t = tc(cnd, tnv) |'
- en: '|     if cnd-t == boolT: |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|     if cnd-t == boolT: |'
- en: '|       thn-t = tc(thn, tnv) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|       thn-t = tc(thn, tnv) |'
- en: '|       els-t = tc(els, tnv) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|       els-t = tc(els, tnv) |'
- en: '|       if thn-t == els-t: |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|       if thn-t == els-t: |'
- en: '|         thn-t |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|         thn-t |'
- en: '|       else: |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|       else: |'
- en: '|         raise("conditional branches don''t match") |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|         raise("conditional branches don''t match") |'
- en: '|       end |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|       end |'
- en: '|     else: |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|     else: |'
- en: '|       raise("conditional isn''t Boolean") |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|       raise("conditional isn''t Boolean") |'
- en: '|     end |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: However, recall our discussion of [The Design Space of Conditionals](growing-lang.html#%28part._design-space-cond%29),
    all of which have consequences for type-checking. Here we are applying the decisions
    we made there.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请回想我们对[条件语句的设计空间](growing-lang.html#%28part._design-space-cond%29)的讨论，所有这些都会对类型检查产生影响。我们在这里应用了我们先前做出的决定。
- en: Exercise
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider each of the three earlier decisions. Change each one, and explain the
    consequences it has for the type-checker.
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑之前做出的三个决定。更改每个决定，并解释它对类型检查器的影响。
- en: 'Finally, the two hard cases: application and functions. We’ve already discussed
    what application must do: compute the value of the function and argument expressions;
    ensure the function expression has function type; and check that the argument
    expression is of compatible type. If all this holds up, then the type of the overall
    application is whatever type the function body would return (because the value
    that eventually returns at run-time is the result of evaluating the function’s
    body).Note that this subtly depends on evaluation and type-checking being in harmony.
    We discuss this under [The Central Theorem: Type Soundness](safety-soundness.html#%28part._type-soundness%29).<hof-tc-appC>
    ::='
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两个棘手的情况：应用和函数。我们已经讨论了应用必须做的事情：计算函数和参数表达式的值；确保函数表达式具有函数类型；检查参数表达式是否具有兼容的类型。如果所有这些都成立，那么总体应用的类型就是函数体将返回的任何类型（因为最终在运行时返回的值是评估函数体的结果）。注意，这在某种程度上取决于评估和类型检查的和谐性。我们在[中心定理：类型完整性](safety-soundness.html#%28part._type-soundness%29)下讨论这一点。<hof-tc-appC>
    ::=
- en: '|   &#124; appC(f, a) => |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; appC(f, a) => |'
- en: '|     f-t = tc(f, tnv) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|     f-t = tc(f, tnv) |'
- en: '|     a-t = tc(a, tnv) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|     a-t = tc(a, tnv) |'
- en: '|     if is-funT(f-t): |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|     if is-funT(f-t): |'
- en: '|       if a-t == f-t.arg: |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|       if a-t == f-t.arg: |'
- en: '|         f-t.ret |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|         f-t.ret |'
- en: '|       else: |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|       else: |'
- en: '|         raise("argument type doesn''t match declared type") |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|         raise("argument type doesn''t match declared type") |'
- en: '|       end |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|       end |'
- en: '|     else: |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|     else: |'
- en: '|       raise("not a function in application position") |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|       raise("not a function in application position") |'
- en: '|     end |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: That leaves function definitions. The function has a formal parameter; unless
    this is bound in the type environment, any use of that parameter in body would
    result in a type error. Thus we have to extend the type environment with the formal
    name bound to its type, and in that extended environment type-check the body.
    Whatever value this computes must be the same as the declared type of the body.
    If that is so, then the function itself has a function type from the type of the
    argument to the type of the body.<hof-tc-fdC> ::=
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了函数定义。函数有一个形式参数；除非在类型环境中绑定了这个参数，否则在函数体中使用该参数将导致类型错误。因此，我们必须扩展类型环境，将形式名称绑定到其类型，并在扩展的环境中检查类型体。这个计算出的任何值必须与体的声明类型相同。如果是这样，那么函数本身就有一个从参数类型到体类型的函数类型。<hof-tc-fdC>
    ::=
- en: '|   &#124; fdC(a, at, rt, b) => |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; fdC(a, at, rt, b) => |'
- en: '|     bt = tc(b, xtend-t-env(tbind(a, at), tnv)) |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|     bt = tc(b, xtend-t-env(tbind(a, at), tnv)) |'
- en: '|     if bt == rt: |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|     if bt == rt: |'
- en: '|       funT(at, rt) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|       funT(at, rt) |'
- en: '|     else: |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|     else: |'
- en: '|       raise("body type doesn''t match declared type") |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|       raise("body type doesn''t match declared type") |'
- en: '|     end |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: 27.4.3Type-Checking Versus Interpretation
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.4.3类型检查与解释
- en: Do Now!
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就开始吧！
- en: ''
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When confronted with a first-class function, our interpreter created a closure.
    However, we don’t seem to have any notion of a “closure” in our type-checker,
    even though we’re using an (type) environment. Why not? In particular, recall
    that the absence of closures resulted in violation of static scope. Is that happening
    here? Write some tests to investigate.
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当面对一个头等函数时，我们的解释器创建了一个闭包。然而，我们的类型检查器似乎没有任何关于“闭包”的概念，即使我们使用了（类型）环境。为什么？特别是，请回想一下，没有闭包导致了静态作用域的违反。这里是否发生了同样的情况？编写一些测试来调查。
- en: Observe a curious difference between the interpreter and type-checker. In the
    interpreter, application was responsible for evaluating the argument expression,
    extending the environment, and evaluating the body. Here, the application case
    does check the argument expression, but leaves the environment alone, and simply
    returns the type of the body without traversing it. Instead, the body is actually
    traversed by the checker when checking a function definition, so this is the point
    at which the environment actually extends.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 观察解释器和类型检查器之间一个有趣的区别。在解释器中，应用负责评估参数表达式，扩展环境，并评估体。在这里，应用案例确实检查参数表达式，但不会改变环境，只是返回体的类型而不对其进行遍历。相反，当检查函数定义时，体实际上是由检查器遍历的，因此这是环境实际上扩展的地方。
- en: Exercise
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is the time of traversal different between interpretation and type-checking?
  id: totrans-196
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么解释和类型检查之间的遍历时间不同？
- en: The consequences of this are worth understanding.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的后果值得理解。
- en: Consider the Pyret function
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑 Pyret 函数
- en: '[PRE12]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we simply define p, the interpreter does not traverse the interior of these
    expressions, in particular the x + y. Instead, these are suspended waiting for
    later use (a feature we actually exploit ((part "laziness"))). Furthermore, when
    we apply p to some argument, this evaluates the outer function, resulting in a
    closure (that closes over the binding of x).
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们简单地定义 p 时，解释器不会遍历这些表达式的内部，特别是 x + y。相反，这些被搁置等待以后使用（实际上是我们利用的一个特性（（部分 "惰性"）））。此外，当我们将
    p 应用于某个参数时，这会计算外部函数，导致一个闭包（它关闭了 x 的绑定）。
- en: 'Now instead consider the type-checker. As soon as we are given this definition,
    it traverses the entire expression, including the innermost sub-expression. Because
    it knows everything it needs to know about x and y—<wbr>their types—<wbr>it can
    immediately type-check the entire expression. This is why it doesn’t not require
    to create a closure: there is nothing to be put off until application time (indeed,
    we don’t want to put type-checking off until execution).'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在考虑一下类型检查器。只要我们给出这个定义，它就遍历整个表达式，包括最内层的子表达式。因为它知道关于 x 和 y 的一切信息-它们的类型-它可以立即对整个表达式进行类型检查。这就是为什么它不需要创建一个闭包：没有什么需要推迟到应用时间（事实上，我们不想把类型检查推迟到执行时）。
- en: 'Another way to think about it is that it behaves like substitution does—<wbr>and
    substitution did not need closures to provide static scoping, either—<wbr>but
    even more eagerly: it can perform substitution with just the program text without
    any values at all, because it is substituting types, which are already given.
    The fact that we use a type environment makes this harder to see, because we may
    have come to associate environments with closures. However, what matters is when
    the necessary value is available. Put differently, we used an environment primarily
    out of convention: here, we could have used (type) substitution just as well.'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种思考方式是它的行为类似于替换-替换没有使用闭包来提供静态作用域，因为它更加急切：它可以仅使用程序文本进行替换，而不需要任何值，因为它正在替换类型，这些类型已经给定。我们使用类型环境使这一点难以看到，因为我们可能已经将环境与闭包联系起来。然而，重要的是何时提供必要的值。换句话说，我们主要出于惯例使用环境：在这里，我们同样可以很好地使用（类型）替换。
- en: Exercise
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write examples to study this. Consider converting the above example as a starting
    point. Also convert your examples from [earlier](Interpreting_Functions.html#%28elem._hof-interp%29).
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写示例来研究这一点。考虑将上面的示例转换为起点。还要将你的例子从[之前](Interpreting_Functions.html#%28elem._hof-interp%29)转换。
- en: 'Consider the following expression:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下表达式：
- en: '[PRE13]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When evaluating the inner f(n), the interpreter has access to actual values
    for f and n. In contrast, when type-checking it, it does not know which function
    will be passed in as f. How, then, can it type-check the use?
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在评估内部的 f(n) 时，解释器可以访问 f 和 n 的实际值。相反，当对其进行类型检查时，它不知道将作为 f 传入的函数是哪个。那么，它如何进行类型检查呢？
- en: The answer is that the annotation tells the type-checker everything it needs
    to know. The annotation says that f must accept numbers; since n is annotated
    to be a number, the application works. It also says that f will return strings;
    because that is what the overall function returns, this also passes.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案是注释告诉类型检查器它需要知道的一切。注释表明 f 必须接受数字；由于 n 被注释为一个数字，所以应用可以工作。它还表示 f 将返回字符串；因为这是整个函数返回的内容，所以这也是可以的。
- en: In other words, the annotation (Number -> String) represents not one but an
    infinite family of all functions of that type, without committing to any one of
    them. The type checker then checks that any such function will work in this setting.
    Once it has done its job, it doesn’t matter which function we actually pass in,
    provided it has this type. Checking that is, of course, the heart of [Assume-Guarantee
    Reasoning](#%28part._assume-guarantee%29).
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，注释（Number -> String）表示的不是一个函数，而是一个无限的函数族，而不会承诺其中任何一个。类型检查器然后检查任何这样的函数在这个设置中是否可行。一旦它完成了它的工作，实际上我们传递的是哪个函数就不重要了，只要它有这个类型。当然，检查这一点是[假设-保证推理](#%28part._assume-guarantee%29)的核心。
- en: 27.5Type-Checking, Testing, and Coverage
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 27.5 类型检查、测试和覆盖率
- en: 'A type-checker can be thought of as a very particular kind of testing framework:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将类型检查器看作是一种非常特殊的测试框架：
- en: Instead of using concrete values, it uses only types. Therefore, it cannot check
    fine gradations inside values.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不使用具体的值，而是只使用类型。因此，它不能检查值内部的细微差别。
- en: 'In return, it works statically: that is, it’s like running a lightweight testing
    procedure before ever running the program. (We should not underestimate the value
    of this: programs that depend on interactive or other external input, on specialized
    hardware, on timing, and so on, can be quite difficult to test. For such programs,
    especially, obtaining a lightweight form of testing that does not require being
    able to run it at all is invaluable.)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为回报，它是静态工作的：也就是说，就像在运行程序之前运行轻量级测试程序一样。（我们不应该低估这一点的价值：依赖于交互式或其他外部输入、专用硬件、定时等的程序可能非常难以测试。对于这样的程序，获得一种不需要运行它的轻量级测试的形式是无价的。）
- en: 'Testing only covers the parts of a program that are exercised by test cases.
    In contrast, the type-checker exercises the whole program. Therefore, it can catch
    lurking errors. Of course, it also means that the entire program has to be type-conformant:
    you can’t have some parts (e.g., conditional branches) that are not yet conformant,
    the way they can fail to work correctly but can be ignored by tests that don’t
    exercise them.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试仅覆盖测试用例执行的程序部分。相反，类型检查器对整个程序进行检查。因此，它可以捕获潜在的错误。当然，这也意味着整个程序必须符合类型：不能有一些部分（例如，条件分支）尚未符合类型，它们可能无法正常工作，但可以被不执行它们的测试忽略。
- en: 'Finally, types provide another very important property: quantification. Recall
    our [earlier example](#%28elem._hof-type-eg%29): the type checker has established
    something about an infinite number of functions!'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，类型提供了另一个非常重要的属性：量化。回想一下我们[之前的例子](#%28elem._hof-type-eg%29)：类型检查器已经对无限数量的函数做出了某种规定！
- en: 'This last point gets to the heart of the tradeoff between types and testing:
    types are “broad” while tests are “deep”. That is, because tests deal with very
    specific values and their actual evaluation, they can ask arbitrarily deep questions
    but about that one situation only. Types, in contast, lacking the specificity
    provided by both values and evaluation, cannot ask deep questions; they compensate
    by being able to talk about all possible values of some shape, providing their
    breadth. As this discussion illustrates, neither attribute dominates the other:
    a good software practice will use a judicious combination of both.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一点触及了类型和测试之间的权衡的核心：类型是“广泛的”，而测试是“深入的”。也就是说，因为测试涉及非常具体的值及其实际评估，它们可以提出任意深入的问题，但仅限于一个特定情况。相反，由于类型缺乏值和评估所提供的特定性，它们无法提出深入的问题；它们通过能够讨论某种形状的所有可能值来弥补这一点，提供其广度。正如本讨论所说明的，这两个属性都没有支配另一个：良好的软件实践将同时使用两者的明智组合。
- en: 27.6Recursion in Code
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 27.6代码中的递归
- en: Now that we’ve obtained a basic programming language, let’s add recursion to
    it. We saw earlier ([Recursion and Non-Termination](Interpreting_Functions.html#%28part._rec-non-term%29))
    that this could be done quite easily. It’ll prove to be a more complex story here.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了一个基本的编程语言，让我们给它加上递归。我们之前已经看到（[递归和非终止](Interpreting_Functions.html#%28part._rec-non-term%29)），这可以很容易地实现。但是这里会变得更加复杂。
- en: 27.6.1A First Attempt at Typing Recursion
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.6.1对递归类型的初步尝试
- en: Let’s now try to express a simple recursive function. We’ve already seen how
    to write infinite loops for first-order functions. Annotating them introduces
    no complications.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试表达一个简单的递归函数。我们已经看到如何为一阶函数编写无限循环。对它们进行注释不会引入复杂性。
- en: Exercise
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Confirm that adding types to recursive and non-terminating first-order functions
    causes no additional problems.
  id: totrans-224
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确认给递归和非终止的一阶函数添加类型不会引起额外的问题。
- en: 'Now let’s move on to higher-order functions. We’ve already seen that this results
    in an infinite loop:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向高阶函数。我们已经看到这导致了一个无限循环：
- en: '[PRE14]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have a typed language, we have to annotate it. (Conventionally,
    we call this term Ω.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个带类型的语言，我们必须对其进行注释。（通常，我们将这个术语称为 Ω。）
- en: Recall that this program is formed by applying ω to itself. Of course, it is
    not a given that identical terms must have precisely the same type, because it
    depends on the context of use. However, the specific structure of ω means that
    it is the same term that ends up in both contexts—<wbr>as function and argument—<wbr>so
    the types of these had better be the same. In other words, typing one instance
    of ω suffices to type them both.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，这个程序是通过将 ω 应用到它自身而形成的。当然，并不是说相同的术语必须具有完全相同的类型，因为它取决于使用的上下文。然而，ω 的特定结构意味着在两个上下文中——作为函数和参数——最终都是相同的术语，所以这两者的类型最好是相同的。换句话说，对
    ω 的一个实例进行类型标注就足以对它们两个进行类型标注。
- en: Therefore, let’s try to type ω; let’s call this type T. It’s clearly a function
    type, and the function takes one argument, so it must be of the form A -> B. Now
    what is that argument? It’s ω itself. That is, the type of the value going into
    A is itself T. Thus, the type of ω is T, which is A -> B, which is the same as
    T -> B. This expands into (A -> B) -> B, which is the same as (T -> B) -> B. Therefore,
    this further expands to ((A -> B) -> B) -> B, and so on. In other words, this
    type cannot be written as any finite string!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试对 ω 进行类型检查；让我们将这种类型称为 T。显然，这是一个函数类型，这个函数接受一个参数，因此它必须是 A -> B 的形式。那么这个参数是什么？就是
    ω 本身。也就是说，进入 A 的值的类型本身就是 T。因此，ω 的类型就是 T，即 A -> B，这与 T -> B 相同。这扩展为 (A -> B) ->
    B，这与 (T -> B) -> B 相同。因此，这进一步扩展为 ((A -> B) -> B) -> B，依此类推。换句话说，这种类型无法被写成任何有限字符串！
- en: Do Now!
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you notice the subtle but important leap we just made?
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你是否注意到我们刚刚进行的微妙但重要的跳跃？
- en: Do Now!
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We have just argued that we can’t type ω. But why does it follow that we can’t
    type Ω?
  id: totrans-235
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们刚刚论证了我们无法输入 ω。但为什么会导致我们无法输入 Ω 呢？
- en: 27.6.2Program Termination
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.6.2 程序终止
- en: 'Because type-checking follows by recurring on sub-terms, to type Ω, we have
    to be able to type ω and then combine its type to obtain one for Ω. But, as we’ve
    seen, typing ω seems to run into serious problems. From that, however, we jumped
    to the conclusion that ω’s type cannot be written as any finite string, for which
    we’ve given only an intuition, not a proof. In fact, something even stranger is
    true: in the type system we’ve defined so far, we cannot type Ω at all!'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类型检查是通过对子项进行递归来实现的，要对 Ω 进行类型检查，我们必须能够对 ω 进行类型检查，然后将其类型组合以获得 Ω 的类型。但是，正如我们所看到的，对
    ω 进行类型检查似乎会遇到严重问题。然而，从那里，我们跳到了 ω 的类型无法被写成任何有限字符串的结论，对此我们只给出了直觉，而不是证明。事实上，更奇怪的是：在我们迄今定义的类型系统中，我们根本无法对
    Ω 进行类型检查！
- en: 'This is a strong statement, but it follows from something even stronger. The
    typed language we have so far has a property called strong normalization: every
    expression that has a type will terminate computation after a finite number of
    steps. In other words, this special (and peculiar) infinite loop program isn’t
    the only one we can’t type; we can’t type any infinite loop (or even potential
    infinite loop). A rough intuition that might help is that any type—<wbr>which
    must be a finite string—<wbr>can have only a finite number of ->’s in it, and
    each application discharges one, so we can perform only a finite number of applications.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强有力的陈述，但它源自更强大的东西。到目前为止，我们的类型化语言具有一种称为强归一化的属性：每个具有类型的表达式在有限步骤后将终止计算。换句话说，这个特殊（而奇特的）无限循环程序并不是我们无法对其进行类型检查的唯一程序；我们无法对任何无限循环（甚至潜在的无限循环）进行类型检查。一个可能有所帮助的粗略直觉是，任何类型—必须是一个有限字符串—其中只能有有限数量的
    ->，每个应用都会释放一个，因此我们只能执行有限数量的应用。
- en: Exercise
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is this not true when we have named first-order functions?
  id: totrans-241
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们有命名的一阶函数时，为什么这不成立？
- en: If our language permitted only straight-line programs, this would be unsurprising.
    However, we have conditionals and even functions being passed around as values,
    and with those we can encode almost every program we’re written so far. Yet, we
    still get this guarantee! That makes this a somewhat astonishing result.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的语言只允许直线程序，那将是不足为奇的。然而，我们有条件语句，甚至函数作为值传递，而且我们可以使用它们来编码我们迄今为止编写的几乎每个程序。然而，我们仍然得到了这个保证！这使得这个结果有些令人惊讶。
- en: Exercise
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try to encode lists using functions in the untyped and then in the typed language
    (see [REF] if you aren’t sure how). What do you see? And what does that tell you
    about the impact of this type system on the encoding?
  id: totrans-245
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试使用未类型化语言和类型化语言中的函数来编码列表（如果不确定如何，请参见[REF]）。你看到了什么？这对编码的影响告诉了你什么？
- en: This result also says something deeper. It shows that, contrary to what you
    may believe—<wbr>that a type system only prevents a few buggy programs from running—<wbr>a
    type system can change the semantics of a language. Whereas previously we could
    write an infinite loop in just one to two lines, now we cannot write one at all.
    It also shows that the type system can establish invariants not just about a particular
    program, but about the language itself. If we want to absolutely ensure that a
    program will terminate, we simply need to write it in this language and pass the
    type checker, and the guarantee is ours!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果还揭示了更深层次的东西。它表明，与你可能相信的相反—<wbr>即类型系统仅阻止一些有错误的程序运行—<wbr>类型系统可以改变语言的语义。而以前我们可以用一两行代码写一个无限循环，现在我们根本就不能写。它还表明，类型系统不仅可以建立关于特定程序的不变性，还可以建立关于语言本身的不变性。如果我们想绝对确保一个程序会终止，我们只需用这种语言编写并通过类型检查，保证就是我们的！
- en: 'What possible use is a language in which all programs terminate? For general-purpose
    programming, none, of course. But in many specialized domains, it’s a tremendously
    useful guarantee to have. Here are several examples of domains that could benefit
    from it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有程序都终止的语言中有什么可能的用途？对于通用编程来说，当然没有。但在许多专业领域中，拥有这一保证是非常有用的。以下是几个可能受益的领域的示例：
- en: A complex scheduling algorithm (the guarantee would ensure that the scheduler
    completes and that the tasks being scheduled will actually run).
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复杂的调度算法（保证将确保调度程序完成，并且正在调度的任务实际上将运行）。
- en: A packet-filter in a router. (Network elements that go into infinite loops put
    a crimp on utility.)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个路由器中的数据包过滤器。（进入无限循环的网络元素会影响实用性。）
- en: A compiler. (The program it generates may or may not terminate, but it ought
    to at least finish generating the program.)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编译器。（它生成的程序可能会终止，也可能不会，但至少应该完成程序的生成。）
- en: A device initializer. (Modern electronics—<wbr>such as a smartphones and photocopiers—<wbr>have
    complex initialization routines. These have to finish so that the device can actually
    be put to use.)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个设备初始化程序。（现代电子产品—<wbr>比如智能手机和复印机—<wbr>有复杂的初始化程序。这些程序必须完成，以便设备真正投入使用。）
- en: The callbacks in JavaScript. (Because the language is single-threaded, not relinquishing
    control means the event loop starves. When this happens in a Web page, the browser
    usually intervenes after a while and asks whether to kill the page—<wbr>because
    otherwise the rest of the page (or even browser) becomes unresponsive.)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的回调函数。（因为该语言是单线程的，不放弃控制意味着事件循环将被饿死。当这种情况发生在网页中时，浏览器通常会在一段时间后介入，并询问是否要关闭该页—<wbr>否则页面的其余部分（甚至整个浏览器）都将无响应。）
- en: A configuration system, such as a build system or a linker.In the Standard ML
    language, the language for linking modules uses essentially this typed language
    for writing module linking specifications. This means developers can write quite
    sophisticated abstractions—<wbr>they have functions-as-values, after all!—<wbr>while
    still being guaranteed that linking will always terminate, producing a program.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置系统，如构建系统或链接器。在Standard ML语言中，用于链接模块的语言基本上使用了这种类型的语言来编写模块链接规范。这意味着开发人员可以编写非常复杂的抽象—<wbr>他们终究有函数作为值！—<wbr>同时仍然保证链接将始终终止，产生一个程序。
- en: 'Notice also an important difference between types and tests ([Type-Checking,
    Testing, and Coverage](#%28part._types-v-tests%29)): you can’t test for termination!'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意类型和测试之间的重要区别（[类型检查、测试和覆盖](#%28part._types-v-tests%29）：你无法测试终止！）
- en: 27.6.3Typing Recursion
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.6.3递归类型
- en: What this says is, if we want potentially unbounded recursion, we must make
    it an explicit part of the typed language. To illustrate this, we will add a simple
    rec construct that recursively binds an identifier to a function. Thus, in the
    surface syntax, one might writeFor convenience, we have also added a if0 construct
    that compares the test expression’s value with 0.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话的意思是，如果我们想要可能无限递归，我们必须将其作为类型语言的一个显式部分。为了说明这一点，我们将添加一个简单的rec结构，该结构将一个标识符递归地绑定到一个函数。因此，在表面语法中，一个人可能会写出为了方便，我们还添加了一个if0结构，用于将测试表达式的值与0进行比较。
- en: '| (rec (S num (n num) |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| (rec (S num (n num) |'
- en: '|         (if0 n |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|         (if0 n |'
- en: '|              0 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|              0 |'
- en: '|              (n + (S (n + -1))))) |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|              (n + (S (n + -1))))) |'
- en: '|   (S 10)) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|   (S 10)) |'
- en: for a summation function, where S is the name of the function, n its argument,
    the first num the type of n and the second num the type returned by the function.
    The expression (S 10) represents the use of this function to sum the numbers from
    10 until 0.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于求和函数，其中 S 是函数的名称，n 是其参数，第一个 num 是 n 的类型，第二个 num 是函数返回的类型。表达式 (S 10) 表示使用该函数对从
    10 到 0 的数字求和。
- en: How do we type such an expression? Clearly, we must have n bound in the body
    of the function as we type it (but not, of course, in the use of the function,
    due to static scope); this much we know from typing functions. But what about
    S? Obviously it must be xbound in the type environment when checking the use (S
    10)), and its type must be num -> num. But it must also be bound, to the same
    type, when checking the body of the function. (Observe, too, that the type returned
    by the body must match its declared return type.)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为这样的表达式确定类型？显然，我们在编写函数时必须将 n 绑定到其主体中（但当然不是在函数的使用中，因为由于静态范围，我们知道了函数的类型）。但是
    S 呢？显然，在检查使用 (S 10)) 时，它必须在类型环境中绑定，并且其类型必须为 num -> num。但是，在检查函数主体时，它也必须绑定到相同的类型。（还要注意，主体返回的类型必须与其声明的返回类型匹配。）
- en: Now we can see how to break the shackles of the finiteness of the type. It is
    certainly true that we can write only a finite number of ->’s in types in the
    program source. However, this rule for typing recursion duplicates the -> in the
    body that refers to itself, thereby ensuring that there is an inexhaustible supply
    of applications.It’s our infinite quiver of arrows.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到如何打破类型的有限性。毫无疑问，我们在程序源代码中只能写入有限数量的->。然而，这种用于类型递归的规则复制了指向自身的主体中的->，从而确保了有无穷无尽的应用程序供应。这是我们无限的箭头集合。
- en: The code to implement this rule would be as follows. Assuming f is bound to
    the function’s name, v its parameter’s name, at is the function’s argument type
    and rt is its return type, b is the function’s body, and c is the function’s use:<tc-recC>
    ::=
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 实施此规则的代码如下。假设 f 绑定到函数的名称，v 绑定到函数的参数名称，at 是函数的参数类型，rt 是其返回类型，b 是函数的主体，c 是函数的使用：<tc-recC>
    ::=
- en: '|   &#124; recC(f, v, at, rt, b, c) => |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; recC(f, v, at, rt, b, c) => |'
- en: '|     extended-env = xtend-t-env(tbind(f, funT(at, rt)), tnv) |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|     extended-env = xtend-t-env(tbind(f, funT(at, rt)), tnv) |'
- en: '|     if not(rt == tc(b, xtend-t-env(tbind(v, at), extended-env))): |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|     如果 not(rt == tc(b, xtend-t-env(tbind(v, at), extended-env))): |'
- en: '|       raise("rec: function return type not correct") |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|       raise("rec: function return type not correct") |'
- en: '|     else: |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|     否则: |'
- en: '|       tc(c, extended-env); |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|       tc(c, extended-env); |'
- en: 27.7Recursion in Data
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 27.7数据中的递归
- en: We have seen how to type recursive programs, but this doesn’t yet enable us
    to create recursive data. We already have one kind of recursive datum—<wbr>the
    function type—<wbr>but this is built-in. We haven’t yet seen how developers can
    create their own recursive datatypes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何编写递归程序，但这还不能让我们创建递归数据。我们已经有一种递归数据类型——函数类型——但这是内置的。我们还没有看到开发者如何创建他们自己的递归数据类型。
- en: 27.7.1Recursive Datatype Definitions
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.7.1递归数据类型定义
- en: 'When we speak of allowing programmers to create recursive data, we are actually
    talking about three different facilities at once:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论允许程序员创建递归数据时，实际上我们一次在谈论三个不同的设施：
- en: Creating a new type.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新类型。
- en: Letting instances of the new type have one or more fields.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让新类型的实例拥有一个或多个字段。
- en: Letting some of these fields refer to instances of the same type.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让其中一些字段引用相同类型的实例。
- en: 'In fact, once we allow the third, we must allow one more:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一旦我们允许第三个，我们必须再允许一个：
- en: Allowing non-recursive base-cases for the type.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许非递归基本情况的类型。
- en: This confluence of design criteria leads to what is commonly called an algebraic
    datatype. For instance, consider the following definition of a binary tree of
    numbers:Later [REF], we will discuss how types can be parameterized.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计标准的融合导致了通常称为代数数据类型的东西。例如，考虑以下数字二叉树的定义：稍后[REF]，我们将讨论类型如何被参数化。
- en: '[PRE15]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Observe that without a name for the new datatype, BinTree, we would not have
    been able to refer back ot it in node. Similarly, without the ability to have
    more than one kind of BinTree, we would not have been able to define leaf, and
    thus wouldn’t have been able to terminate the recursion. Finally, of course, we
    need multiple fields (as in node) to construct useful and interesting data. In
    other words, all three mechanisms are packaged together because they are most
    useful in conjunction. (However, some langauges do permit the definition of stand-alone
    structures. We will return to the impact of this design decision on the type system
    later [REF].)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有新数据类型BinTree的名称，我们将无法在node中引用它。同样，如果没有能够有多种BinTree的能力，我们将无法定义叶子，因此也无法终止递归。最后，当然，我们需要多个字段（如在node中）来构造有用和有趣的数据。换句话说，这三种机制之所以被包装在一起，是因为它们在结合使用时最有用。（但是，一些语言确实允许定义独立的结构。我们稍后会回到这种设计决策对类型系统的影响
    [REF]。）
- en: This style of data definition is sometimes also known as a sum of products.
    At the outer level, the datatype offers a set of choices (a value can be a leaf
    or a node). This corresponds to disjunction (“or”), which is sometimes written
    as a sum (the truth table is suggestive). Inside each sum is a set of fields,
    all of which must be present. These correspond to a conjunction (“and”), which
    is sometimes written as a product (ditto).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据定义风格有时也被称为和的总和。在外层，数据类型提供了一组选择（一个值可以是叶子或节点）。这对应于析取（“或”），有时写成和（真值表是有启示性的）。在每个和内部是一组字段，所有字段都必须存在。这对应于合取（“和”），有时写成积（同上）。
- en: That covers the notation, but we have not explained where this new type, BinTree,
    comes from. It is obviously impractical to pretend that it is baked into our type-checker,
    because we can’t keep changing it for each new recursive type definition—<wbr>it
    would be like modifying our interpreter each time the program contains a recursive
    function! Instead, we need to find a way to make such definitions intrinsic to
    the type language. We will return to this problem later [REF].
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了符号，但我们还没有解释这个新类型BinTree是从哪里来的。显然，假装它被烘焙到我们的类型检查器中是不现实的，因为我们不能为每个新的递归类型定义都改变它——这就像每次程序包含递归函数时都修改我们的解释器一样！相反，我们需要找到一种方法，使这样的定义成为类型语言的固有部分。我们稍后会回到这个问题
    [REF]。
- en: 27.7.2Introduced Types
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.7.2引入的类型
- en: 'Now, what impact does a datatype definition have? First, it introduces a new
    type; then it uses this to define several constructors, predicates, and selectors.
    For instance, in the above example, it first introduces BinTree, then uses it
    to ascribe the following types:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数据类型定义有什么影响呢？首先，它引入了一个新类型；然后，它使用这个类型来定义多个构造器、谓词和选择器。例如，在上面的示例中，它首先引入了BinTree，然后用它来赋予以下类型：
- en: '[PRE16]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Do Now!
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在！
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In what two ways are the last three entries above fictitious?
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上述最后三个条目中有哪两个是虚构的？
- en: 'Observe a few salient facts:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意几个显著的事实：
- en: Both the constructors create instances of BinTree, not something more refined.
    We will discuss this design tradeoff later [REF].
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个构造器都创建BinTree的实例，而不是更精细的东西。我们将在稍后讨论这种设计折衷 [REF]。
- en: Both predicates consume values of type BinTree, not “any” value. This is because
    the type system can already tell us what type a value is. Thus, we only need to
    distinguish between the variants of that one type.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个谓词都消耗BinTree类型的值，而不是“任何”值。这是因为类型系统已经可以告诉我们一个值是什么类型。因此，我们只需要区分这一个类型的各种变体。
- en: The selectors really only work on instances of the relevant variant—<wbr>e.g.,
    .value can work only on instances of node, not on instances of leaf—<wbr>but we
    don’t have a way to express this in the static type system for lack of a suitable
    static type. Thus, applying these can only result in a dynamic error, not a static
    one caught by the type system.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些选择器实际上只对相关变体的实例起作用——例如，.value只能对节点的实例起作用，而不能对叶子的实例起作用——但由于缺乏合适的静态类型，我们没有办法在静态类型系统中表达这一点。因此，应用这些只会导致动态错误，而不是静态类型系统捕获的静态错误。
- en: There is more to say about recursive types, which we will return to shortly
    [REF].
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多关于递归类型的内容需要讨论，我们马上就会回来 [REF]。
- en: 27.7.3Selectors
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.7.3选择器
- en: '.value, .left, and .right are selectors: they select parts of the record by
    name. But here are the two ways in which they are fictitious. First, syntactically:
    in most languages with “dotted field access”, there is no such stand-alone operator
    as .value: e.g., you cannot write .value(...). But even setting aside this syntactic
    matter (which could be addressed by arguing that writing v.value is just an obscure
    syntax for applying this operator) the more interesting subtlety is the semantic
    one.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: .value、.left和.right是选择器：它们按名称选择记录的部分。但以下是它们虚构的两种方式。首先，语法上：在大多数具有“点字段访问”的语言中，没有像.value这样的独立运算符：例如，你不能写成.value(...)。但是即使放开这个语法问题（可以通过论证写成v.value只是应用这个操作符的一个晦涩的语法来解决），更有趣的微妙之处在于语义上。
- en: 'Above, we have given a very particular type to .value. Suppose, however, that
    this datatype was also defined in the same program:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们给.value赋了一个非常特定的类型。然而，假设这个数据类型也在同一个程序中定义了：
- en: '[PRE17]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This too appears to define a .value operator with the type:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这也似乎定义了一个具有以下类型的.value运算符：
- en: '[PRE18]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: or equivalently,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等价地，
- en: '[PRE19]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Will the real .value please stand up? How many .value operations are there?
    Indeed, it would appear that this “operator” freely cross-cuts every datatype
    definition, and even every module boundary!These issues are not really specific
    to types: the cross-cutting nature of field access is independent of it. However,
    ascribing types forces us to confront these issues, because we cannot ignore the
    difficulty of typing the operation.To put this in perspective, consider two other
    very different styles of handling selectors:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的.value请站出来？有多少个.value操作？事实上，似乎这个“运算符”自由地横跨了每一个数据类型定义，甚至是每一个模块边界！这些问题并不是特定于类型的：字段访问的横跨性与之无关。然而，给予类型迫使我们去面对这些问题，因为我们不能忽视这个操作的类型困难。为了让这个问题显得更加具体，考虑另外两种处理选择器的非常不同的样式：
- en: A characteristic of scripting languages is that objects are merely hash tables,
    and all field access is turned into a hash-table reference on the string representing
    the field-name. Hence, o.f is just syntactic sugar for looking up the value indexed
    by "f" in the dictionary associated with o.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本语言的一个特征是对象仅仅是哈希表，所有字段访问都被转换为对表示字段名称的字符串的哈希表引用。因此，o.f只是查找与o相关联的字典中由"f"索引的值的语法糖。
- en: In Racket, the structure definitions such as
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Racket中，结构定义如
- en: '| (struct cash (value)) |'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (struct cash (value)) |'
- en: '| (struct card (number value)) |'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (struct card (number value)) |'
- en: 'generate distinct selectors: in this case, cash-value and card-value, respectively.
    Now there is no longer any potential for confusion, because they have different
    names that can each have distinct types.'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成不同的选择器：在这种情况下，分别是cash-value和card-value。现在再也没有混淆的可能性了，因为它们有不同的名称，每个名称都可以有不同的类型。
- en: 'Compiling between these languages then highlights these distinctions. Compiling
    from Pyret or Java to JavaScript is easy, because all field dereferences turn
    into dictionary lookups. Compiling from (untyped) Pyret to Racket is especially
    easy because the languages are so similar—<wbr>until we get to dotted access.
    Then, assuming we wish to compile Pyret data definitions to Racket’s corresponding
    structure definitions, the compiler would have to traverse the Pyret program to
    gather up all fields with a common name, and turn them into a discriminating selector:
    for instance, v.value might compile to Racket’s (->value v), where ->value is
    defined as (given the above two data definitions):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 编译这些语言之间的区别会突显出这些区别。从Pyret或Java编译到JavaScript很容易，因为所有字段解引用都变成了字典查找。从（未类型化的）Pyret编译到Racket尤其容易，因为这两种语言非常相似—<wbr>直到我们到达点式访问为止。然后，假设我们希望将Pyret数据定义编译成Racket对应的结构定义，编译器将不得不遍历Pyret程序，收集所有具有相同名称的字段，并将它们转换为区分选择器：例如，v.value可能会编译成Racket的（->value v），其中->value被定义为（给定上述两个数据定义）：
- en: '| (define (->value v) |'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (->value v) |'
- en: '|   (cond |'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (cond |'
- en: '|     [(node? v) (node-value v)] |'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(node? v) (node-value v)] |'
- en: '|     [(cash? v) (cash-value v)] |'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(cash? v) (cash-value v)] |'
- en: '|     [(card? v) (card-value v)])) |'
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(card? v) (card-value v)])) |'
- en: 'In contrast, going in the other direction is easy: (node-value v) would check
    that v is indeed a node, and then access v.value.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，向另一个方向走是容易的：（node-value v）将检查v是否确实是一个节点，然后访问v.value。
- en: 27.7.4Pattern-Matching and Desugaring
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.7.4模式匹配和解糖
- en: Once we have understood the names introduced by datatype definitions, and the
    nature of selectors, the only thing left is to provide an account of pattern-matching.
    For instance, we can write the expression
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了由数据类型定义引入的名称以及选择器的性质，唯一剩下的就是提供模式匹配的说明。例如，我们可以写出表达式
- en: '[PRE20]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This simply expands into uses of the above predicates, and binding the pieces:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将上述谓词的用法扩展，并绑定这些部分：
- en: '[PRE21]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In short, this can be done by desugaring, so pattern-matching does not need
    to be in the core language. This, in turn, means that one language can have many
    different pattern-matching mechanisms.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这可以通过去糖化来实现，因此模式匹配不需要在核心语言中。这反过来意味着一个语言可以有许多不同的模式匹配机制。
- en: Except, that’s not quite so easy. Somehow, the desugaring that generates the
    code above in terms of if needs to know that the three positional selectors for
    a node are value, left, and right, respectively. This information is explicit
    in the type definition but only implicitly present in the use of the pattern-matcher
    (that, indeed, being the point). Somehow this information must be communicated
    from definition to use. Thus, the desugarer needs something akin to the type environment
    to accomplish its task.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这并不那么容易。以 if 形式生成上述代码的去糖化需要知道节点的三个位置选择器分别是 value、left 和 right。这些信息在类型定义中是显式的，但在模式匹配器的使用中只是隐含的（这确实是重点）。某种方式必须将这些信息从定义传达到使用。因此，去糖化器需要类似于类型环境的东西来完成其任务。
- en: Observe, furthermore, that expressions such as e1 and e2 cannot be type-checked—<wbr>indeed,
    cannot even be reliable identified as expressions—<wbr>until desugaring expands
    the use of cases. Thus, desugaring depends on the type environment, while type-checking
    depends on the result of desugaring. In other words, the two are symbiotic and
    need to happen, not quite in “parallel”, but rather in lock-step. What this implies
    is that building desugaring for a typed language when the syntactic sugar makes
    assumptions about types is more intricate than doing so for an untyped language.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，诸如 e1 和 e2 这样的表达式无法进行类型检查—<wbr>事实上，甚至无法可靠地识别为表达式—<wbr>直到去糖化扩展了 cases
    的使用。因此，去糖化依赖于类型环境，而类型检查依赖于去糖化的结果。换句话说，这两者是共生的，需要发生，不完全是“并行”的，而是步调一致的。这意味着，当语法糖对类型做出假设时，为带类型的语言构建去糖化比为无类型语言这样做更加复杂。
