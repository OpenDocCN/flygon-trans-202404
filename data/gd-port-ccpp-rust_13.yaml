- en: Features of Rust compared with C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 与 C++ 的特点对比
- en: Features of Rust compared with C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 与 C++ 的特点对比
- en: Rust and C++ have roughly analogous functionality although they often go about
    it in different ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 和 C++ 具有大致相似的功能，尽管它们经常以不同的方式实现。
- en: Rust benefits from learning what works in C / C++ and what doesn't and indeed
    has cherry-picked features from a variety of languages. It also enjoys a cleaner
    API in part because things like Unicode dictate the design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 受益于学习 C/C++ 中有效和无效的东西，而且确实从各种语言中选择了功能。它还享有更清晰的 API，部分原因是像 Unicode 这样的东西决定了设计。
- en: This section will cover such topics as types, strings, variables, literals,
    collections, structs, loops and so on. In each case it will draw comparison between
    how things are in C/C++ and how they are in Rust.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖类型、字符串、变量、字面值、集合、结构体、循环等主题。在每种情况下，它将比较 C/C++ 中的情况与 Rust 中的情况。
- en: Also bear in mind that Rust compiles to binary code and is *designed* to use
    C binaries and be used by C binaries. Therefore the generated code is similar,
    but it is different as source.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 同样要牢记 Rust 编译成二进制代码，并且 *设计* 用于使用 C 二进制文件和被 C 二进制文件使用。因此生成的代码类似，但源代码是不同的。
- en: Types
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: Types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'C/C++ compilers implement a *data model* that affects what width the standard
    types are. The general rule is that:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 编译器实现了影响标准类型宽度的 *数据模型*。一般规则是：
- en: '`1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long
    long)`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long
    long)`'
- en: As you can see, potentially everything all the way to `long long` could be a
    single byte, or there could be some other crazy definition. In practice however,
    data models come in four common types which will be covered in the next section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，潜在地，一直到 `long long` 都可以是单个字节，或者可能有一些其他疯狂的定义。然而，在实践中，数据模型有四种常见类型，将在下一节中介绍。
- en: For this section, we'll cover the *most likely* analogous types between Rust
    and C/C++.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将涵盖 Rust 和 C/C++ 之间 *最可能* 类似的类型。
- en: '| C/C++ | Rust | Notes |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| C/C++ | Rust | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `char` | `i8` (or `u8`) | The signedness of a C++ char can be signed or unsigned
    - the assumption here is signed but it varies by target system. A Rust `char`
    is not the same as a C/C++ `char` since it can hold any Unicode character. ^([1](#fn_1))
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `i8`（或 `u8`）| C++ char 的符号性可以是有符号或无符号的 - 这里的假设是有符号的，但是目标系统有所不同。Rust
    的 `char` 与 C/C++ 的 `char` 不同，因为它可以容纳任何 Unicode 字符。^([1](#fn_1)) |'
- en: '| `unsigned char` | `u8` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned char` | `u8` |'
- en: '| `signed char` | `i8` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `signed char` | `i8` |'
- en: '| `short int` | `i16` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `short int` | `i16` |'
- en: '| `unsigned short int` | `u16` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short int` | `u16` |'
- en: '| `(signed) int` | `i32` or `i16` | In C/C++ this is data model dependent ^([2](#fn_2))
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `(signed) int` | `i32` 或 `i16` | 在 C/C++ 中，这取决于数据模型 ^([2](#fn_2)) |'
- en: '| `unsigned int` | `u32` or `u16` | In C/C++ this is data model dependent ^([2](#fn_2))
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int` | `u32` 或 `u16` | 在 C/C++ 中，这取决于数据模型 ^([2](#fn_2)) |'
- en: '| `(signed) long int` | `i32` or `i64` | In C/C++ this is data model dependent
    ^([2](#fn_2)) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `(signed) long int` | `i32` 或 `i64` | 在 C/C++ 中，这取决于数据模型 ^([2](#fn_2)) |'
- en: '| `unsigned long int` | `u32` or `u64` | In C/C++ this is data model dependent
    ^([2](#fn_2)) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long int` | `u32` 或 `u64` | 在 C/C++ 中，这取决于数据模型 ^([2](#fn_2)) |'
- en: '| `(signed) long long int` | `i64` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `(signed) long long int` | `i64` |'
- en: '| `unsigned long long int` | `u64` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long int` | `u64` |'
- en: '| `size_t` | `usize` | usize holds numbers as large as the address space ^([3](#fn_3))
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `size_t` | `usize` | usize 可以容纳与地址空间一样大的数字 ^([3](#fn_3)) |'
- en: '| `float` | `f32` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `f32` |'
- en: '| `double` | `f64` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `f64` |'
- en: '| `long double` | ~~f128~~ | f128 support was present in Rust but removed due
    to issues for some platforms in implementing it. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `long double` | ~~f128~~ | Rust 中存在对 f128 的支持，但由于在某些平台上实现它存在问题而被移除。'
- en: '| `bool` | `bool` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bool` |'
- en: '| `void` | `()` | The unit type (see below) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `void` | `()` | 单位类型（见下文） |'
- en: ^([1](#fn_1)) Rust's `char` type, is 4 bytes wide, enough to hold any Unicode
    character. This is equivalent to the belated `char32_t` that appears in C++11
    to rectify the abused C++98 `wchar_t` type which on operating systems such as
    Windows is only 2 bytes wide. When you iterate strings in Rust you may do so either
    by character or `u8`, i.e. a byte.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](#fn_1)) Rust 的 `char` 类型，宽度为 4 字节，足以容纳任何 Unicode 字符。这相当于延迟出现的 `char32_t`，它出现在
    C++11 中，以纠正滥用的 C++98 中的 `wchar_t` 类型，该类型在诸如 Windows 等操作系统上仅为 2 字节宽。在 Rust 中迭代字符串时，可以通过字符或
    `u8` 来进行。
- en: ^([2](#fn_2)) See the next section to for a discussion on data models.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](#fn_2)) 请参见下一节讨论数据模型。
- en: ^([3](#fn_3)) Rust has a specific numeric type for indexing on arrays and collections
    called `usize`. A `usize` is designed to be able to reference as many elements
    in an array as there is addressable memory. i.e. if memory is 64-bit addressable
    then usize is 64-bits in length. There is also a signed `isize` which is less
    used but also available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](#fn_3)) Rust 有一个特定的数值类型用于数组和集合的索引称为 `usize`。`usize` 被设计为能够引用与可寻址内存一样多的元素。也就是说，如果内存是
    64 位可寻址的，那么 `usize` 的长度就是 64 位。还有一个称为 `isize` 的有符号类型，虽然不太常用，但也可以使用。
- en: Data model
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模型
- en: 'The four common data models in C++ are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中四种常见的数据模型是：
- en: LP32 - `int` is 16-bit, `long` and pointers are 32-bit. This is an uncommon
    model, a throw-back to DOS / Windows 3.1
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LP32 - `int` 是 16 位，`long` 和指针是 32 位。这是一个不常见的模型，是对 DOS / Windows 3.1 的一种回溯。
- en: ILP32 - `int`, `long` and pointers are 32-bit. Used by Win32, Linux, OS X
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ILP32 - `int`、`long` 和指针都是 32 位。由 Win32、Linux、OS X 使用
- en: LLP64 - `int` and `long` are 32-bit, `long long` and pointers are 64-bit. Used
    by Win64
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLP64 - `int` 和 `long` 是 32 位，`long long` 和指针是 64 位。由 Win64 使用
- en: LP64 - `int` is 32-bit, `long` / `long long` and pointers are 64-bit. Used by
    Linux, OS X
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LP64 - `int` 是 32 位，`long` / `long long` 和指针是 64 位。由 Linux、OS X 使用
- en: C/C++ types compared to Rust
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C/C++ 类型与 Rust 的比较
- en: 'C/C++ and Rust will share the same machine types for each corresponding language
    type and the same compiler / backend technology, i.e.:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 和 Rust 将共享相应语言类型的相同机器类型以及相同的编译器 / 后端技术，即：
- en: Signed types are two's complement
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有符号类型是二进制补码
- en: IEE 754-2008 binary32 and binary64 floating points for float and double precision
    types.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IEE 754-2008 二进制 32 位和 64 位浮点数类型的浮点数和双精度类型。
- en: stdint.h / cstdint
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stdint.h / cstdint
- en: C provides a `<stdint.h>` header that provides unambigious typedefs with length
    and signedess, e.g. `uint32_t`. The equivalent in C++ is `<cstdlib>`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: C 提供了一个 `<stdint.h>` 头文件，提供了具有长度和符号的清晰 typedefs，例如 `uint32_t`。C++ 中的等效物是 `<cstdlib>`。
- en: If you use the types defined in this header file the types become directly analogous
    and unambiguous between C/C++ and Rust.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用此头文件中定义的类型，则类型在 C/C++ 和 Rust 之间变得直接类比和清晰。
- en: '| C/C++ | Rust |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| C/C++ | Rust |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int8_t` | `i8` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `int8_t` | `i8` |'
- en: '| `uint8_t` | `u8` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `uint8_t` | `u8` |'
- en: '| `int16_t` | `i16` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `int16_t` | `i16` |'
- en: '| `uint16_t` | `u16` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `uint16_t` | `u16` |'
- en: '| `uint32_t` | `u32` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `uint32_t` | `u32` |'
- en: '| `int32_t` | `i32` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `int32_t` | `i32` |'
- en: '| `int64_t` | `i64` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `int64_t` | `i64` |'
- en: '| `uint64_t` | `u64` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `uint64_t` | `u64` |'
- en: Integer types
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数类型
- en: C++
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++
- en: C/C++ has primitive types for numeric values, floating point values and booleans.
    Strings will be dealt in a separate section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 中有用于数值、浮点数和布尔值的原始类型。字符串将在单独的部分中处理。
- en: Integer types (`char`, `short`, `int`, `long`) come in `signed` and `unsigned`
    versions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型（`char`、`short`、`int`、`long`）有 `signed` 和 `unsigned` 版本。
- en: A `char` is always 8-bits, but for historical reasons, the standards only guarantee
    the other types are "at least" a certain number of bits. So an `int` is ordinarily
    32-bits but the standard only say it should be at *least as large* as a `short`,
    so potentially it could be 16-bits!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 总是 8 位，但出于历史原因，标准仅保证其他类型至少是某个位数。因此，`int` 通常是 32 位，但标准只规定它应该至少与 `short`
    一样大，因此潜在地它可能是 16 位！'
- en: More recent versions of C and C++ provide a [`<cstdint>`](http://www.cplusplus.com/reference/cstdint/)
    (or `<stdint.h>` for C) with typedefs that are unambiguous about their precision.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 较新版本的 C 和 C++ 提供了一个 [`<cstdint>`](http://www.cplusplus.com/reference/cstdint/)（或
    `<stdint.h>` 用于 C）具有清晰关于精度的 typedefs。
- en: 'Even though `<stdint.h>` can clear up the ambiguities, code frequently sacrifices
    correctness for terseness. It is not unusual to see an `int` used as a temporary
    incremental value in a loop:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `<stdint.h>` 可以消除模糊性，代码经常为简洁性而牺牲正确性。在循环中经常看到一个 `int` 用作临时增量值：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While `int` is unlikely to fail for most loops in a modern compiler supporting
    ILP32 or greater, it is still technically wrong. In a LP32 data model incrementing
    32767 by one would become -32768 so this loop would never terminate if `s.size()`
    was a value greater than that.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数支持 ILP32 或更大的现代编译器中，`int` 不太可能失败，但这仍然是技术上的错误。在 LP32 数据模型中，将 32767 加一会变成
    -32768，因此如果 `s.size()` 的值大于那个值，这个循环永远不会终止。
- en: But look again at this snippet. What if the file read by `read_file()` is outside
    of our control. What if someone deliberately or accidentally feeds us a file so
    large that our loop will fail trying to iterate over it? In doing so our code
    is hopelessly broken.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次看这个片段。如果由 `read_file()` 读取的文件不受我们控制，会怎么样。如果有人故意或者不小心地给我们提供一个超出我们循环迭代的文件呢？这样做，我们的代码就彻底坏掉了。
- en: 'This loop should be using the same type returned from `string::size()` which
    is an opaque unsigned integer type called `size_type`. This is usually a typedef
    for `std::size_t` but not necessarily. Thus we have a type mismatch. A `string`
    has an iterator which could be used instead but perhaps you need the index for
    some reason, but it can messy:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环应该使用与 `string::size()` 返回的相同类型，这是一个称为 `size_type` 的不透明无符号整数类型。这通常是 `std::size_t`
    的 typedef，但不一定是这样。因此，我们有一个类型不匹配。一个 `string` 有一个迭代器，可以使用它，但也许你因为某种原因需要索引，但可能会很混乱：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we've swapped from one opaque type `size_type` to another called `difference_type`.
    Ugh.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从一个不透明类型 `size_type` 切换到另一个称为 `difference_type` 的类型。呃。
- en: C/C++ types can also be needlessly wordy such as `unsigned long long int`. Again,
    this sort of puffery encourages code to make bad assumptions, use a less wordy
    type, or bloat the code with typedefs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 类型也可能是不必要的冗长，例如 `unsigned long long int`。同样，这种膨胀的写法会鼓励代码做出错误的假设，使用更少字的类型，或者用
    typedefs 来膨胀代码。
- en: Rust
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Rust benefits from integer types that unambiguously denote their signedness
    and width in their name - `i16`, `u8` etc.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 从整数类型中受益，这些整数类型在名称中明确地表示了它们的有符号性和宽度 - `i16`、`u8` 等等。
- en: They are also extremely terse making it easy to declare and use them. For example
    a `u32` is an unsigned 32-bit integer. An `i64` is a signed 64-bit integer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也非常简洁，易于声明和使用。例如，`u32` 是一个无符号的 32 位整数。`i64` 是一个有符号的 64 位整数。
- en: 'Types may be inferred or explicitly prefixed to the value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以被推断或显式前缀到值上：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rust also has two types called `usize` and `isize` respectively. These are equivalent
    to `size_t` in that they are as large enough to hold as many elements as there
    is addressable memory. So in a 32-bit operating system they will be 32-bits in
    size, in a 64-bit operating system they will be 64-bits in size.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 还有两种类型分别称为 `usize` 和 `isize`。它们与 `size_t` 等效，因为它们足够大以容纳地址内存中的元素数量。因此，在
    32 位操作系统中，它们的大小为 32 位，在 64 位操作系统中，它们的大小为 64 位。
- en: Rust will not implicitly coerce an integer from one size to another without
    explicit use of the `as` keyword.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不会隐式地将一个大小的整数转换为另一个大小，除非明确使用 `as` 关键字。
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Real types
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际类型
- en: C++
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++
- en: C/C++ has float, double and long double precision floating point types and they
    suffer the same vagueness as integer types.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 中有 `float`、`double` 和 `long double` 等浮点类型，它们与整数类型一样存在模糊性。
- en: '`float`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`double` - "at least as much precision as a `float`"'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double` - "至少与 `float` 一样精确"'
- en: '`long double` - "at least as much precision as a `double`"'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long double` - "至少与 `double` 一样精确"'
- en: In most compilers and architectures however a float is a 32-bit single precision
    value, and a double is an 64-bit double precision value. The most common machine
    representation is the [IEEE 754-2008 format](https://en.wikipedia.org/wiki/IEEE_floating_point).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编译器和架构中，一个 float 是一个 32 位单精度值，一个 double 是一个 64 位双精度值。最常见的机器表示形式是 [IEEE 754-2008
    格式](https://en.wikipedia.org/wiki/IEEE_floating_point)。
- en: Long double
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Long double
- en: The [`long double`](https://en.wikipedia.org/wiki/Long_double) has proven quite
    problematic for compilers. Despite expectations that it is a quadruple precision
    value it usually isn't. Some compilers such as gcc may offer 80-bit extended precision
    on x86 processors with a floating point unit but it is implementation defined
    behaviour.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[`long double`](https://en.wikipedia.org/wiki/Long_double) 对于编译器来说已经非常棘手了。尽管预期它是一个四倍精度的值，但通常并非如此。一些编译器，如
    gcc，可能在具有浮点单位的 x86 处理器上提供 80 位扩展精度，但这是实现定义的行为。'
- en: The Microsoft Visual C++ compiler treats it with the same precision as a `double`.
    Other architectures may treat it as quadruple precision. The fundamental problem
    with `long double` is that most desktop processors do not have the ability in
    hardware to perform 128-bit floating point operations so a compiler must either
    implement it in software or not bother.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Visual C++ 编译器将其视为与 `double` 相同精度的类型。其他架构可能将其视为四倍精度。`long double` 的根本问题在于，大多数桌面处理器在硬件上没有执行
    128 位浮点操作的能力，因此编译器必须在软件中实现它或者不理会。
- en: Math functions
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数学函数
- en: The `<math.h>` C header provides math functions for working with different precision
    types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C 头文件 `<math.h>` 提供了用于处理不同精度类型的数学函数。
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how different calls are required according to the precision, e.g. sinf,
    sin or sinl. C99 supplies a "type-generic" set of macros in `<tgmath.h>` which
    allows sin to be used regardless of type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不同的精度需要不同的调用，例如 sinf、sin 或 sinl。C99 在 `<tgmath.h>` 中提供了一组"类型通用"的宏，允许无论类型如何都可以使用
    sin。
- en: 'C++11 provides a `<cmath>` that uses specialised inline functions for the same
    purpose:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: C++11提供了一个`<cmath>`，使用专门的内联函数来实现相同的目的：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rust
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rust
- en: Rust implements two floating point types - `f32` and `f64`. These would be analogous
    to a 32-bit `float` and 64-bit `double` in C/C++.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Rust实现了两种浮点数类型 - `f32`和`f64`。这些将类似于C/C++中的32位`float`和64位`double`。
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unlike in C/C++, the math functions are directly bound to the type itself providing
    you properly qualify the type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与C/C++不同，数学函数直接绑定到类型本身，只要你正确限定类型即可。
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rust does not have a 128-bit double. A `f128` did exist for a period of time
    but was removed to portability, complexity and maintenance issues. Note how `long
    double` is treated (or not) according to the compiler and target platform.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Rust没有128位双精度浮点数。在某段时间内确实存在`f128`，但由于可移植性、复杂性和维护问题而被移除。注意根据编译器和目标平台处理（或不处理）`long
    double`的方式。
- en: At some point Rust might get a f128 or f80 but at this time does not have such
    a type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，Rust可能会获得一个f128或f80，但目前还没有这样的类型。
- en: Booleans
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: A `bool` (boolean) type in C/C++ can have the value `true` or `false`, however
    it can be promoted to an integer type (0 == `false`, 1 == `true`) and a bool even
    has a ++ operator for turning false to true although it has no -- operator!?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++中，`bool`（布尔）类型可以有值`true`或`false`，但它可以提升为整数类型（0 == `false`，1 == `true`），而且布尔类型甚至有一个++运算符，用于将false转换为true，尽管它没有--运算符！？
- en: But inverting true with a ! becomes false and vice versa.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，将true反转为!false，反之亦然。
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Rust also has a `bool` type that can have the value `true` or `false`. Unlike
    C/C++ it is a true type with no promotion to integer type
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Rust也有一个`bool`类型，它的值可以是`true`或`false`。与C/C++不同，它是一个真正的类型，没有提升为整数类型
- en: void / Unit type
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: void / Unit类型
- en: C/C++ uses `void` to specify a type of nothing or an indeterminate pointer to
    something.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++使用`void`来指定无类型或不确定指针指向的内容。
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The nearest thing to `void` in Rust is the Unit type. It's called a Unit type
    because it's type is `()` and it has one value of `()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，与`void`最接近的东西是Unit类型。它被称为Unit类型，因为它的类型是`()`，并且有一个值是`()`。
- en: Technically `void` is absolutely nothing and `()` is a single value of type
    `()` so they're not analogous but they serve a similar purpose.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`void`绝对什么也不是，`()`是一种`()`类型的单个值，因此它们不是类似的，但它们具有类似的用途。
- en: 'When a block evaluates to nothing it returns `()`. We can also use it in places
    where we don''t care about one parameter. e.g. say we have a function `do_action()`
    that succeeds or fails for various reasons. We don''t need any payload with the
    Ok response so specify `()` as the payload of success:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个块评估为无时，它返回`()`。我们也可以在我们不关心一个参数的地方使用它。例如，假设我们有一个函数`do_action()`，它因各种原因成功或失败。我们不需要Ok响应的任何有效负载，所以将`()`指定为成功的有效负载：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Empty enums
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空枚举
- en: Rust *does* have something closer (but not the same as) `void` - empty enumerations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Rust确实有与`void`更接近（但不完全相同）的东西 - 空枚举。
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Essentially this enum has no values at all so anything that assigns or matches
    this nothing-ness is unreachable and the compiler can issue warnings or errors.
    If the code had used `()` the compiler might not be able to determine this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，此枚举根本没有任何值，因此任何分配或匹配此无值的操作都是无法到达的，编译器可以发出警告或错误。如果代码使用了`()`，编译器可能无法确定这一点。
- en: Tuples
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: A tuple is a collection of values of the same or different type passed to a
    function or returned by one as if it were a single value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个传递给函数或由函数返回的相同类型或不同类型值的集合，就好像它是一个单一的值一样。
- en: 'C/C++ has no concept of a tuple primitive type, however C++11 can construct
    a tuple using a template:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++没有元组原始类型的概念，但是C++11可以使用模板构造元组：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rust supports tuples as part of its language:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Rust支持元组作为其语言的一部分：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see this is more terse and more useful. Note that the way a tuple
    is indexed is different from an array though, values are indexed via .0, .1 etc.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这更简洁更实用。请注意，元组的索引方式与数组不同，值通过`.0`，`.1`等索引。
- en: Tuples can also be returned by functions and assignment operators can ignore
    tuple members we're not interested in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 元组也可以被函数返回，赋值运算符可以忽略我们不感兴趣的元组成员。
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the calculate_coords() function returns a tuple containing
    three `i16` values. We assign the first two values to `x` and `y` respectively
    and ignore the third by passing an underscore. The underscore tells the compiler
    we're aware of the 3rd value but we just don't care about it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，calculate_coords()函数返回一个包含三个`i16`值的元组。我们将前两个值分别赋给`x`和`y`，并通过传递下划线来忽略第三个值。下划线告诉编译器我们知道第3个值，但我们只是不关心它。
- en: 'Tuples can be particularly useful with code blocks. For example, let''s say
    we want to get some values from a piece of code that uses a guard lock on a reference
    counted service. We can lock the service in the block and return all the values
    as a tuple to the recipients outside of the block:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在代码块中可能特别有用。例如，假设我们想从一个使用引用计数服务上的保护锁的代码段中获取一些值。我们可以在块中锁定服务并将所有值作为元组返回给块外的接收者：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code is really neat - the lock allows us to obtain the values, the lock
    goes out of scope and the values are returned in one go.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确实很简洁 - 锁允许我们获取值，锁超出范围后一次返回所有值。
- en: Arrays
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a fixed size list of elements allocated either on the stack or the
    heap.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是在堆栈或堆上分配的固定大小元素列表。
- en: 'E.g to create a 100 element array of `double` values in C++:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 C++ 中创建一个包含 100 个 `double` 值的数组：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And in Rust:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 Rust 中：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note how Rust provides a shorthand to initialise the array with the same value
    or assigns the array with every value. Initialisation in C and C++ is optional
    however it is more expressive in that portions of the array can be set or not
    set using enclosed list syntax.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 Rust 提供了一种用相同值初始化数组的简写方式，或者使用封闭列表语法设置数组的每个值。在 C 和 C++ 中，初始化是可选的，但使用封闭列表语法可以更具表现力地设置或不设置数组的某些部分。
- en: Rust actually *forces* you to initialise an array to something. Attempting to
    declare an array without assigning it a value is a compiler error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 实际上*强制*您将数组初始化为某些值。尝试声明一个数组而不为其分配值将导致编译器错误。
- en: Slices
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: A slice is a runtime view of a part of an array or string. A slice is not a
    copy of the array / string rather that it is a reference to a portion of it. The
    reference holds a pointer to the starting element and the number of elements in
    the slice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是数组或字符串的一部分的运行时视图。切片不是数组/字符串的副本，而是对其中一部分的引用。引用保存指向起始元素的指针以及切片中的元素数。
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This slice represents the portion of array starting from index 2.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此切片表示从索引 2 开始的数组部分。
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Size of the array
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组的大小
- en: C and C++ basically give no easy way to know the length of the array unless
    you encapsulate the array with a `std::array` or happen to remember it from the
    code that declares it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 基本上没有简单的方法来知道数组的长度，除非您使用 `std::array` 封装数组或者记得从声明数组的代码中获取它。
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `std::array` wrapper is of limited use because you cannot pass arrays of
    an unknown size to a function. Therefore even with this template you may pass
    the array into a function as one argument and its size as another.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array` 包装器的用途有限，因为您无法将未知大小的数组传递给函数。因此，即使使用此模板，您也可以将数组作为一个参数传递给函数，将其大小作为另一个参数。'
- en: 'Alternatively you might see code like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可能会看到类似这样的代码：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Or like this
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In Rust, the array has a function bound to it called `len()`. This always provides
    the length of the array. In addition if we take a slice of the array, that also
    has a `len()`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，数组有一个名为 `len()` 的函数与之绑定。这始终提供数组的长度。此外，如果我们取数组的切片，那也有一个 `len()`。
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Strings
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings in C++ are a bit messy thanks to the way languages and characters have
    been mapped onto bytes in different ways. The explanation for this requires some
    backstory...
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言和字符以不同的方式映射到字节上，C++ 中的字符串有点混乱。对此的解释需要一些背景知识...
- en: What is a character exactly?
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符究竟是什么？
- en: Historically in C and C++, a char type is 8-bits. Strictly speaking a char is
    signed type (usually -128 to 127), but the values essentially represent the values
    0-255.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 和 C++ 中，历史上 char 类型是 8 位。严格来说，char 是有符号类型（通常为 -128 到 127），但这些值实质上表示值 0-255。
- en: The US-ASCII standard uses the first 7-bits (0-127) to assign values to upper
    and lower case letters in the English alphabet, numbers, punctuation marks and
    certain control characters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 美国 ASCII 标准使用前 7 位（0-127）为英文字母、数字、标点符号和某些控制字符分配值。
- en: It didn't help the rest of the world who use different character sets. And even
    ASCII was competing with another standard called EBDIC which was found on mainframe
    computers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于使用不同字符集的其他国家并没有帮助。即使 ASCII 也与另一个称为 EBDIC 的标准竞争，后者在大型计算机上找到。
- en: What about the upper values from 128-255? Some operating systems came up with
    a concept called a "code page". According to what "code page" was in effect, the
    symbol that the user would see for a character in the 128-255 range would change.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 128-255 的上限值呢？一些操作系统提出了一个称为“代码页”的概念。根据实施的“代码页”，用户在 128-255 范围内看到的字符符号将会改变。
- en: But even this is not enough. Some languages like Chinese, Japanese, Korean,
    Thai, Arabic etc. have thousands of symbols that must be encoded with more than
    one byte. So the first byte might be a modifier that combines with further bytes
    to render as a symbol. For example Microsoft's code page 932 use an encoding called
    Shift JIS (Japanese) where some symbols are two bytes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使这还不够。一些语言，如中文、日文、韩文、泰文、阿拉伯文等，有成千上万的符号，必须用多个字节进行编码。因此，第一个字节可能是一个修饰符，与后续字节组合以呈现为一个符号。例如，微软的代码页932使用了一个称为Shift
    JIS（日文）的编码，其中一些符号是两个字节。
- en: Obviously this was rapidly becoming a mess. Each code page interpretted the
    same byte array differently according to some external setting. So you could not
    send a file written in Chinese to someone with a different code page and expect
    it to render properly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这很快变得一团糟。每个代码页根据某些外部设置以不同方式解释相同的字节数组。因此，您不能将用中文编写的文件发送给具有不同代码页的人，并期望它正确呈现。
- en: Unicode to the rescue
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unicode来拯救
- en: The Unicode standard assigns every printable symbol in existence with a unique
    32-bit value, called a code point. Most symbols fall in the first 16-bits called
    the Basic Multilingual Plane (BMP).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode标准为每个存在的可打印符号分配了一个唯一的32位值，称为代码点。大多数符号位于称为基本多语言平面（BMP）的前16位中。
- en: China has mandated all software must support all 32-bits. We'll see how this
    has become a major headache for C and C++
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 中国规定所有软件必须支持所有32位。我们将看到这对C和C++造成了重大困扰。
- en: C / C++
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C / C++
- en: There is no string primitive
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有字符串原始类型
- en: C and C++ does not have a string primitive type, instead it has `char` type,
    that is one byte. A "string" is a pointer to an array of chars that are terminated
    with a zero byte, `'\0'`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 没有字符串原始类型，而是有一个长度为一个字节的`char`类型。一个“字符串”是指一个指向以零字节`'\0'`结尾的字符数组的指针。
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In C, functions such as `strlen()`, `strcpy()`, `strdup()` etc. allow strings
    to be manipulated but they work by using the zero byte to figure out the length
    of things. So `strlen()` the number of bytes that were encountered before a `\0`
    was found. Sicne these functions run until they find a terminating character it
    is very easy to accidentally for them to overrun a buffer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，诸如`strlen()`、`strcpy()`、`strdup()`等函数允许对字符串进行操作，但它们通过使用零字节来计算事物的长度。因此，`strlen()`是在找到`\0`之前遇到的字节数。由于这些函数运行直到找到终止字符，很容易意外地使它们超出缓冲区。
- en: In C++ the `std::string` class wraps a char pointer and provides safe methods
    for modifying the string in a safe manner. It is a vast improvement over C but
    it is still not a primitive - it is a class defined in a header that is compiled
    and linked to the executable just like every other class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，`std::string`类包装了一个char指针，并提供了安全的方法来以安全的方式修改字符串。这比C有了很大的改进，但它仍然不是一个原始类型
    - 它是一个在头文件中定义的类，与可执行文件一样被编译和链接。
- en: In addition, a `std::string` will usually use heap to store the string's data
    which can have repercussions for memory usage and fragmentation. There is usually
    a hidden cost to assigning one string to another because memory must be allocated
    to receive a copy of the string, even if the string itself is not modified during
    the assignment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`std::string`通常会使用堆来存储字符串的数据，这可能会对内存使用和碎片化产生影响。将一个字符串分配给另一个字符串通常会有隐藏的成本，因为必须分配内存来接收字符串的副本，即使在分配过程中字符串本身没有被修改。
- en: Unicode support
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unicode支持
- en: C/C++ added Unicode support by creating a wide character called `wchar_t`. And
    C++ has an equivalent `std::wstring`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++通过创建一个称为`wchar_t`的宽字符来添加Unicode支持。C++有一个等效的`std::wstring`。
- en: We're sorted now right?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经排序好了对吧？
- en: Oops no, because `wchar_t` type can be either 2 or 4 bytes wide and is a compiler
    / platform specific decision.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕，因为`wchar_t`类型可以是2或4字节宽，这是编译器/平台特定的决定。
- en: In Microsoft Visual C++ the wide char is an `unsigned short` (corresponding
    to Win32's Unicode API), in gcc it can be 32-bits or 16-bits according to the
    compile flags.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Visual C++中，宽字符是一个`unsigned short`（对应于Win32的Unicode API），在gcc中，根据编译标志，它可以是32位或16位。
- en: A 16-bit value will hold symbols from the Basic Multilingual Plane but not the
    full 32-bit range. This means that 16-bit wide strings should be assumed to be
    UTF-16 encoded because they cannot support Unicode properly otherwise.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 16位值将包含来自基本多语言平面的符号，但不包括完整的32位范围。这意味着应该假定16位宽的字符串是UTF-16编码的，因为否则无法正确支持Unicode。
- en: C++11 rectifies this by introducing explicit `char16_t` and `char32_t` types
    and corresponding versions of string called `std::u16string` and `std::u32string`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C++11通过引入显式的`char16_t`和`char32_t`类型以及相应版本的字符串`std::u16string`和`std::u32string`来纠正这一点。
- en: Character types
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类型
- en: So now C++ has 4 character types. Great huh?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在C++有4种字符类型。很棒，对吧？
- en: '| Character type | Encoding |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 字符类型 | 编码 |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `char` | C, ASCII, EBDIC, UTF-8, ad hoc, ??? |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `char` | C，ASCII，EBDIC，UTF-8，ad hoc，??? |'
- en: '| `wchar_t` | UTF-16 or UTF-32 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `wchar_t` | UTF-16或UTF-32 |'
- en: '| `char16_t` | UTF-16 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `char16_t` | UTF-16 |'
- en: '| `char32_t` | UTF-32 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `char32_t` | UTF-32 |'
- en: Rust
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Rust has been rather fortunate. Unicode preceded it so it makes a very simple
    design choice.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Rust非常幸运。Unicode在它之前出现，所以它做了一个非常简单的设计选择。
- en: A `char` type is a 32-bit Unicode character, always enough to hold a single
    character.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`类型是一个32位的Unicode字符，始终足以容纳一个单一字符。'
- en: A `str` type is a UTF-8 encoded string held in memory. Code tends to use &str
    which is a string slice, basically a reference to the str, or a portion of it.
    A str does not need to be terminated with a zero byte and can contain zero bytes
    if it wants.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`类型是一个UTF-8编码的字符串，保存在内存中。代码倾向于使用`&str`，它是一个字符串切片，基本上是对str的引用，或者是其中的一部分。一个str不需要以零字节结尾，如果需要的话，可以包含零字节。'
- en: A `std::String` is a heap allocated string type use for manipulating strings,
    building them, reading them from file, cloning them etc.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`std::String`是一个堆分配的字符串类型，用于操作字符串，构建字符串，从文件中读取字符串，克隆字符串等。
- en: Note that internally UTF-8 is used for encoding yet a char is 32-bits. The length
    of a strings is considered to be its byte length. There are special iterators
    for walking the string and decoding UTF-8 into 32-bit characters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，内部使用UTF-8进行编码，但一个字符是32位的。字符串的长度被认为是其字节长度。有特殊的迭代器用于遍历字符串并将UTF-8解码为32位字符。
- en: Finally there is a platform specific type `OSString` that handles any differences
    in how the operating system sees strings compared to Rust.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后有一个特定于平台的类型`OSString`，处理操作系统如何看待字符串与Rust的区别。
- en: Types Comparison
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型比较
- en: '| C++ | Rust |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Rust |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|  | `char *` or `wchar_t *` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  | `char *`或`wchar_t *` |'
- en: '| C++11 - `char16_t *`, `char32_t *` | `str`, `&str` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| C++11 - `char16_t *`, `char32_t *` | `str`, `&str` |'
- en: '|  | `std::string`, `std::wstring` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  | `std::string`，`std::wstring` |'
- en: '| `std::u16string` `std::u32string` | `std::String` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `std::u16string` `std::u32string` | `std::String` |'
- en: char * vs str
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: char * vs str
- en: C/C++ do not have a string primitive. A string is a pointer to some bytes in
    memory that are nul terminated. The same applies for wider chars, except of course
    they require 2 or 4 bytes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++没有字符串原语。一个字符串是指向内存中的一些字节的指针，这些字节是以空字符结尾的。对于更宽的字符，同样适用，只是它们需要2或4个字节。
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Rust would use a `str` for this purpose. A `str` is an *immutable* array of
    bytes somewhere in memory. The `str` could be on the heap when it points to a
    `String` object, or it could be in global memory if the string is static. A str
    *slice* is `&str`, is reference to a str which also contains a length value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Rust会使用`str`来实现这个目的。`str`是一个在内存中的*不可变*字节数组。当它指向一个`String`对象时，该`str`可能在堆上，或者如果字符串是静态的，则可能在全局内存中。一个str
    *slice* 是 `&str`，是对str的引用，也包含一个长度值。
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Type inferences for these assignments will create a string slice pointing to
    the statically allocated string data. The data itself doesn't move and the `&str`
    is read-only.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些赋值，类型推断会创建一个指向静态分配的字符串数据的字符串切片。数据本身不会移动，而`&str`是只读的。
- en: We can also observe that Rust removes the mess of character width and literal
    prefixes that C and C++ have to suffer under because Unicode characters are implicitly
    supported.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到，Rust消除了C和C++必须忍受的字符宽度和字面前缀的混乱，因为Unicode字符是隐式支持的。
- en: The `str` has functions for iterating over the string in bytes / characters,
    splitting, find a pattern etc.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`有一些函数用于按字节/字符迭代字符串，拆分字符串，查找模式等。'
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note `len()` is the length in bytes because strings are UTF-8 encoded. A single
    character may be encoded as 1, 2, 3, or 4 bytes. It may not be the number of characters
    a human would actually see.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`len()`是以字节为单位的长度，因为字符串是UTF-8编码的。一个单一字符可能被编码为1、2、3或4个字节。这可能不是一个人类实际看到的字符数。
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can split a `&str` to produce a left and a right `&str` slice like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过拆分`&str`来生成左右`&str`切片，就像这样：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: std::basic_string (C++) vs std::String (Rust)
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::basic_string（C++） vs std::String（Rust）
- en: The standard C++ library also has template class `std::basic_string` that acts
    as a wrapper around the various character types and can be used for manipulating
    a string of any width. This template is specialised as
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 C++ 库还有模板类 `std::basic_string`，它充当各种字符类型的包装器，并可用于操作任意宽度的字符串。这个模板被专门化为
- en: '`std::string`, `std:wstring`, `std::u16string` and `std::u32string`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`, `std:wstring`, `std::u16string` 和 `std::u32string`。'
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In Rust, the `std::String` type serves the same purpose:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`std::String` 类型具有相同的作用：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using it is fairly simple
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它相当简单。
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A `String` has functions to do actions such as appending, e.g.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 有用于执行诸如追加等操作的函数，例如：'
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Strings are always valid UTF-8.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串始终是有效的 UTF-8。
- en: Internally a String has a pointer to the data, its length and a capacity (max
    size). If you intend to expand a string, then you should ensure the `String` has
    sufficient capacity to accommodate its longest value otherwise you may cause it
    to reallocate itself excessively.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串内部有指向数据的指针，它的长度和容量（最大大小）。如果你打算扩展一个字符串，那么你应该确保 `String` 有足够的容量来容纳其最长的值，否则你可能会导致它过度重新分配。
- en: Strings will never shrink their capacity unless you explicitly call `shrink_to_fit()`.
    This means if you use a temporary string in a loop, it's probably best to place
    it outside the loop and reserve space to make it efficient.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串永远不会缩小其容量，除非你显式调用 `shrink_to_fit()`。这意味着如果你在循环中使用临时字符串，最好将其放在循环外，并预留空间以使其高效。
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Strings also have all the methods of str thanks to implementing `Deref` trait.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串还具有所有 `str` 的方法，这得益于实现了 `Deref` 特性。
- en: Formatting strings
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: Strings can be formatted in C with `printf` or `sprintf` or in C++ composed
    with stream operators, e.g. to a `std::stringstream`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以用 `printf` 或 `sprintf` 在 C 中格式化，或者在 C++ 中使用流运算符组合，例如，到 `std::stringstream`。
- en: Rust uses `format!` and `println!` macros that more resemble the `sprintf` model.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 使用 `format!` 和 `println!` 宏，这更类似于 `sprintf` 模型。
- en: '| C++ | Rust formatting trait | Purpose |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Rust 格式化特性 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `%s`, `%u`, `%d`, `%i`, `%f`, `%c` | `{}` | C/C++ require the type of the
    parameter to be specified. In Rust the type is inferred and `{}` will invoked
    the type''s Display trait regardless of what it is. So a String outputs its text,
    numeric types return their value, boolean as returns true or false, and so on.
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `%s`, `%u`, `%d`, `%i`, `%f`, `%c` | `{}` | C/C++ 需要指定参数的类型。在 Rust 中，类型是推断的，而
    `{}` 会调用类型的 Display 特性，无论它是什么。因此，String 输出其文本，数值类型返回其值，布尔类型返回 true 或 false，依此类推。
    |'
- en: '| `%lld`, `%llu` | `{}` | C/C++ has extensions to deal with different size
    ints and floats, e.g. ll for long long due to the way arguments are passed to
    the function. In Rust, there is no need for that. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `%lld`, `%llu` | `{}` | C/C++ 有处理不同大小整数和浮点数的扩展，例如，由于参数传递给函数的方式，long long
    会用 ll 表示。在 Rust 中，这是不需要的。 |'
- en: '|  | `{:?}`, `{:#?}` | In Rust `{:?}` returns whatever is implemented by a
    type''s Debug trait. The `{:#?}` variant can be used to pretty-print the output
    for types that derive the Debug trait. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  | `{:?}`, `{:#?}` | 在 Rust 中，`{:?}` 返回类型实现的 Debug 特性。`{:#?}` 变体可用于漂亮地打印实现
    Debug 特性的类型的输出。 |'
- en: '| `%-10s` | `{:<10}` | Format left aligned string padded to minimum of 10 spaces
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `%-10s` | `{:<10}` | 格式化为左对齐字符串，填充到至少 10 个空格。'
- en: '| `%04` | `{:04}` | Pad a number with zero''s to a width of 4 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `%04` | `{:04}` | 将数字填充到 4 位宽度的零 |'
- en: '| `%.3` | `{:.3}` | Pad a number''s precision to 3 decimal places. May also
    be zero-padded, e.g. {:.03} |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `%.3` | `{:.3}` | 将数字的精度填充到 3 位小数。也可以进行零填充，例如：{:.03} |'
- en: '| `%e`, `%E` | `{:e}`, `{:E}` | Exponent in lower or uppercase |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `%e`, `%E` | `{:e}`, `{:E}` | 指数，小写或大写 |'
- en: '| `%x`, `%X` | `{:x}`, `{:X}` | Hexadecimal in lower or uppercase. Note `{:#x}`,
    `{:#X}` prefixes the output with 0x |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `%x`, `%X` | `{:x}`, `{:X}` | 十六进制，小写或大写。请注意，`{:#x}`、`{:#X}` 会在输出前面加上 0x。
    |'
- en: '| `%o` | `{:o}` | Octal. Note `{:#o}` prefixes the output with 0o |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `%o` | `{:o}` | 八进制。请注意，`{:#o}` 会在输出前面加上 0o。'
- en: '|  | `{:b}` | Binary. Note `{:#b}` prefixes the output with 0b |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  | `{:b}` | 二进制。请注意，`{:#b}` 会在输出前面加上 0b。'
- en: '| `%p` | `{:p}` | Presents a struct''s memory location, i.e. pointer |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `%p` | `{:p}` | 显示结构体的内存位置，即指针 |'
- en: Rust has many [more formatting traits](https://doc.rust-lang.org/std/fmt/#formatting-traits)
    than this.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 比这还有[更多的格式化特性](https://doc.rust-lang.org/std/fmt/#formatting-traits)。
- en: 'For example it allows named parameters like this example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它允许像这个例子这样的命名参数：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Named parameters would be particularly useful for localization where the order
    of values may be different in one language compared to another.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数在本地化中特别有用，因为一个语言中值的顺序可能与另一种语言中的不同。
- en: Display and Debug traits
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示和调试特征
- en: Rust allows types to be formatted as strings based upon the formatting traits
    they implement.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许根据它们实现的格式化特征将类型格式化为字符串。
- en: 'The two main implementation traits are:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要的实现特征是：
- en: '`Display` - this is for standard textual representation of a type.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Display` - 用于类型的标准文本表示。'
- en: '`Debug` - this is for the debugging textual representation of a type. It might
    present additional information or be formatted separately to the Display trait.
    It is possible to `#[derive(Debug)]` this trait which is usually enough for the
    purpose of debugging.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug` - 用于类型的调试文本表示。它可能提供额外信息或单独格式化以供调试。通常通过 `#[derive(Debug)]` 实现此特征，这通常足够用于调试目的。'
- en: If we look at the traits we can see they're identical
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看特征，我们会发现它们是相同的
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All of the intrinsic types implement `Display` and `Debug`. We can explicitly
    implement Display on our own structs too:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置类型都实现了 `Display` 和 `Debug`。我们也可以在自己的结构体上显式实现 Display：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implementing `Debug` is usually done by `#[derive(Debug)]` but it could also
    be implemented. The derived `Debug` will print out the struct name, and then the
    members in curly braces:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过 `#[derive(Debug)]` 实现 `Debug`，但也可以手动实现。派生的 `Debug` 将打印出结构体名称，然后是花括号中的成员：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Many types process formatting traits which are values held between the `{}`
    braces in the string. These are fairly similar to the patterns used in C functions
    for printf, sprintf etc.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型处理格式化特征，这些特征是字符串中 `{}` 括号之间保存的值。这些与 C 函数中用于 printf、sprintf 等的模式非常相似。
- en: OsString / OsStr
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OsString / OsStr
- en: Rust recognises there are times when you need to pass or receive a string from
    a system API.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 认识到有时需要从系统 API 传递或接收字符串。
- en: In this case you may use `OsString` which allows interchange between Rust and
    a system dependent representations of strings. On Windows it will return UTF-16
    strings, on Linux / Unix systems it will return UTF-8.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用 `OsString`，它允许在 Rust 和系统相关的字符串表示之间进行交换。在 Windows 上，它将返回 UTF-16
    字符串，在 Linux / Unix 系统上，它将返回 UTF-8。
- en: An `OsStr` is a slice onto `OsString`, analogous to `str` and `String`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`OsStr` 是对 `OsString` 的切片，类似于 `str` 和 `String`。'
- en: Variables
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Variables
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: C++
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++
- en: Type Inference
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型推断
- en: C++11 has type inference, previous versions of C++ do not. Type inference allows
    the programmer to assign a value to an `auto` typed variable and let the compiler
    infer the type based on the assignment.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 具有类型推断，之前的版本不具备。类型推断允许程序员将值赋给 `auto` 类型的变量，让编译器根据赋值推断类型。
- en: Boolean and numeric types are fairly easy to understand providing the code is
    as explicit as it needs to be.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔和数值类型相对容易理解，只要代码尽可能明确。
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Where C++ gets messy is for arrays and strings. Recall that strings are not
    primitive types in the strong sense within C or C++ so auto requires they be explicitly
    defined or the type will be wrong.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 处理数组和字符串时会变得混乱。请记住，在 C 或 C++ 中，字符串不是原始类型，因此 `auto` 需要明确定义它们，否则类型将错误。
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Strings are covered elsewhere, but essentially there are many kinds of strings
    and C++/C has grown a whole bunch of string prefixes to deal with them all.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串在其他地方有涵盖，但基本上有许多种类的字符串，C++/C 已经发展出了一大堆字符串前缀来处理它们。
- en: Arrays are a more interesting problem. The `auto` keyword has no easy way to
    infer array type so is one hack workaround to assign a templatized array to an
    `auto` and coerce it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个更有趣的问题。`auto` 关键字没有简单的方法推断数组类型，因此将模板化数组分配给 `auto` 并强制转换是一种解决方法。
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Rust
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Rust, variables are declared with a `let` command. The `let` may specify the
    variable's type, or it may also use type inference to infer it from the value
    it is assigned with.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，变量使用 `let` 命令声明。`let` 可能指定变量的类型，也可以使用类型推断从赋值的值中推断出类型。
- en: '[PRE46]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Rust has no problem with using type inference in array assignments:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在数组赋值中使用类型推断没有问题：
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that all array elements must be the same type, inference would generate
    a compiler error for an array like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有数组元素必须是相同类型，推断会为这样的数组生成编译器错误：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Scope rules
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域规则
- en: Scope rules in C, C++ and Rust are fairly similar - the scope that you declare
    the item determines its lifetime.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: C、C++ 和 Rust 中的作用域规则相当相似 - 声明项目的作用域决定了其生命周期。
- en: Shadowing variables
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量的阴影
- en: One very useful feature of Rust is that you can declare the same named variable
    more than once in the same scope or nested scopes and the compiler doesn't mind.
    In fact you'll use this feature a lot.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的一个非常有用的特性是你可以在相同的作用域或嵌套作用域中多次声明同名变量，编译器不会介意。事实上，你会经常使用这个特性。
- en: 'This is called *shadowing* and works like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*遮蔽*，并且像这样工作：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This example uses the variable name `result` 3 times. First to store the result
    of calling `do_something()`, then to extract some value `Foo` from `Option<Foo>`
    and a third time for calling something else. We could have assigned `result` to
    `result2` and then later on assigned the value `do_something_else()` to `result3`
    but we didn't need to because of shadowing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例三次使用变量名`result`。首先是为了存储调用`do_something()`的结果，然后是从`Option<Foo>`中提取某个值`Foo`，第三次是为了调用其他东西。我们本可以将`result`赋值给`result2`，然后稍后将值`do_something_else()`赋给`result3`，但由于遮蔽的原因我们不需要这样做。
- en: Pointers
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针
- en: In C++
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 C++ 中
- en: A pointer is a variable that points to an address somewhere in memory. The pointer's
    *type* indicates to the compiler what to expect at the address but there is no
    enforcement to ensure that the address actually holds that type. A pointer might
    might be assigned `NULL` (or `nullptr` in C++11) or may even be garbage if nothing
    was assigned to it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是指向内存中某个地址的变量。指针的*类型*指示编译器在地址处应该期望什么，但没有强制要求确保地址实际上保存了该类型。指针可能被赋值为`NULL`（或在
    C++11 中为`nullptr`），或者甚至可能是垃圾，如果没有给它赋值的话。
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Generally pointers are used in situations where references cannot be used, e.g.
    functions returning allocated memory or parent / child collection relationships
    where circular dependencies would prevent the use of references.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在无法使用引用的情况下使用指针，例如返回分配的内存的函数或父/子集合关系，在这种情况下，循环依赖会阻止使用引用。
- en: C++11 deprecates `NULL` in favour of new keyword `nullptr` to solve a problem
    with function overloading.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 弃用了`NULL`，改用了新关键字`nullptr`来解决函数重载的问题。
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since `NULL` is essentially `#define NULL 0` and 0 is an integer, we call the
    wrong function by accident. So C++ introduces an explicit `nullptr` for this purpose.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NULL`本质上是`#define NULL 0`，而 0 是一个整数，我们意外地调用了错误的函数。因此，C++引入了一个明确的`nullptr`来解决这个问题。
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In Rust:'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Rust 中：
- en: Rust supports pointers, normally called *raw* pointers however you will rarely
    use them unless you need to interact with C API or similar purposes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 支持指针，通常称为*原始*指针，但除非需要与 C API 或类似目的进行交互，否则很少使用它们。
- en: 'A pointer looks fairly similar to that of C++:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 指针看起来与 C++ 的类似：
- en: '[PRE53]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Although you can make a pointer outside of an unsafe block, many of the functions
    you might want to perform on pointers are unsafe by definition and must be inside
    `unsafe` blocks.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以在非安全块外创建指针，但你可能想对指针执行的许多函数都是根据定义不安全的，并且必须在`unsafe`块内执行。
- en: The documentation in full is [here](https://doc.rust-lang.org/std/primitive.pointer.html).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文档在[这里](https://doc.rust-lang.org/std/primitive.pointer.html)。
- en: References
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: In C++
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 C++ 中
- en: A reference is also a variable that points to an address but unlike a pointer,
    it cannot be reassigned and it cannot be `NULL`. Therefore a reference is generally
    assumed to be safer than a pointer. It is still possible for the a reference to
    become dangling, assuming the address it referenced is no longer valid.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 引用也是指向地址的变量，但与指针不同，它不能重新赋值，也不能为`NULL`。因此，引用通常被认为比指针更安全。引用仍然可能变得悬空，假设其引用的地址不再有效。
- en: In Rust
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Rust 中
- en: A reference is also lifetime tracked by the compiler.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 引用也由编译器进行生命周期跟踪。
- en: Tuples
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: A tuple is list of values held in parenthesis. They're useful in cases where
    transient or ad-hoc data is being passed around and you cannot be bothered to
    write a special struct just for that case.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是用括号括起来的值的列表。它们在传递临时或临时数据时很有用，而且你不想为这种情况写一个特殊的结构体。
- en: In C++
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 C++ 中
- en: 'C++ does not natively support tuples, but C++11 provides a template for passing
    them around like so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 本身不支持元组，但 C++11 提供了一个模板用于像这样传递它们：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In Rust
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Rust 中
- en: Tuples are part of the language and therefore they're far more terse and easy
    to work with.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是语言的一部分，因此它们更加简洁和易于使用。
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Literals
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量
- en: Literals
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量
- en: C++
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C++ 中
- en: Integers
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数
- en: Integer numbers are a decimal value followed by an optional type suffix.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是一个十进制值，后面跟着一个可选的类型后缀。
- en: 'In C++ an [integer literal](http://en.cppreference.com/w/cpp/language/integer_literal#The_type_of_the_literal)
    can be expressed as just the number or also with a suffix. Values in hexadecimal,
    octal and binary are denoted with a prefix:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在C ++中，[整数字面量](http://en.cppreference.com/w/cpp/language/integer_literal#The_type_of_the_literal)可以仅表示数字，也可以带有后缀。十六进制、八进制和二进制中的值用前缀表示：
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `u`, `l`, and `ll` suffixes on integers denotes if it is `unsigned`, `long`
    or a `long long` type. The `u` and `l`/`ll` can be upper or lowercase. Ordinarily
    the `u` must precede the size but C++14 allows the reverse order.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 整数上的`u`、`l`和`ll`后缀表示它是`unsigned`、`long`或`long long`类型。`u`和`l`/`ll`可以是大写或小写。通常，`u`必须在大小之前，但C++14允许反向顺序。
- en: C++14 also allows single quotes to be inserted into the number as separators
    - these quotes can appear anywhere and are ignored.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: C++14还允许在数字中插入单引号作为分隔符 - 这些引号可以出现在任何位置并且被忽略。
- en: Floating point numbers
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: Floating point numbers may represent whole or fractional numbers.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数可以表示整数或小数。
- en: Boolean values
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值
- en: C/C++ `bool` literals are `true` or `false`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++中的`bool`字面量是`true`或`false`。
- en: Characters and Strings
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符和字符串
- en: A character literal is enclosed by single quotes and an optional width prefix.
    The prefix `L` indicates a wide character, `u` for UTF-16 and `U` for UTF-32.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 字符字面量由单引号括起来，可选的宽度前缀。前缀`L`表示宽字符，`u`表示UTF-16，`U`表示UTF-32。
- en: '[PRE57]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: One oddity of a `char` literal is that `sizeof('a')` yields `sizeof(int)` in
    C but `sizeof(char)` in C++. It isn't a good idea to test the size of a character
    literal.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`字面量的一个奇特之处是，在C中`sizeof(''a'')`产生`sizeof(int)`，而在C ++中产生`sizeof(char)`。测试字符字面量的大小并不是一个好主意。'
- en: A `char16_t` and `char32_t` are sufficient to hold any UTF-16 and UTF-32 code
    unit respectively.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`char16_t`和`char32_t`足以容纳任何UTF-16和UTF-32代码单元。'
- en: A string is a sequence of characters enclosed by double quotes. A zero value
    terminator is always appended to the end. Prefixes work the same as for character
    literals with an additional `u8` type to indicate a UTF-8 encoded string.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是由双引号括起来的字符序列。始终在末尾附加零值终止符。前缀的工作方式与字符字面量相同，但额外添加了一个`u8`类型以指示UTF-8编码的字符串。
- en: '[PRE58]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: User-defined literals
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的字面量
- en: C++11 introduced [user-defined literals](http://en.cppreference.com/w/cpp/language/user_literal).
    These allow integer, floats, chars and strings to have a user defined type suffix
    consisting of an underscore and a lowercase string. The prefix may act as a form
    of decorator or even a constant expression operator which modifies the value at
    compile time.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了[用户定义的字面量](http://en.cppreference.com/w/cpp/language/user_literal)。这些允许整数、浮点数、字符和字符串具有用户定义的类型后缀，由下划线和小写字符串组成。前缀可以充当装饰符或甚至是一个在编译时修改值的常量表达式运算符。
- en: C++14 goes further and defines user-defined literals for complex numbers and
    units of time.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: C++14进一步定义了用于复数和时间单位的用户定义字面量。
- en: See the link for more information.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 查看链接以获取更多信息。
- en: Rust
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Integers
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'In Rust [number literals](https://doc.rust-lang.org/reference.html#integer-literals)
    can also be expressed as just the number or also with a suffix. Values in hexadecimal,
    octal and binary are also denoted with a prefix:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，[数字字面量](https://doc.rust-lang.org/reference.html#integer-literals)也可以仅表示数字，也可以带有后缀。十六进制、八进制和二进制中的值也用前缀表示：
- en: '[PRE59]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The underscore in Rust is a separator and functions the same way as the single
    quote in C++14.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的下划线是一个分隔符，并且与C++14中的单引号相同。
- en: Floating point numbers
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: Floating point numbers may represent whole or fractional numbers. As with integers
    they may be suffixed to indicate their type.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数可以表示整数或小数。与整数一样，它们可以添加后缀以指示它们的类型。
- en: '[PRE60]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'One quirk with floating point numbers is the decimal point is used for float
    assignments but it''s also used for member and function invocation. So you can''t
    say `2.f32` since it thinks you are referencing f32 on 2\. Instead syntax requires
    you to say `2.f32` or alter how you declare the type, e.g. `let v: f32 = 2.;`.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '浮点数的一个怪癖是小数点用于浮点分配，但它也用于成员和函数调用。所以你不能说`2.f32`，因为它认为你在引用f32上的2。而是语法要求你说`2.f32`或改变你声明类型的方式，例如`let
    v: f32 = 2.;`。'
- en: Booleans
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: Boolean literals are simply `true` or `false`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔字面量只是`true`或`false`。
- en: '[PRE61]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Characters and Strings
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符和字符串
- en: A character in Rust is any UTF-32 code point enclosed by single quotes. This
    value may be escaped or not since .rs files are UTF-8 encoded.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，字符是由单引号括起来的任何UTF-32代码点。这个值可以转义也可以不转义，因为.rs文件是UTF-8编码的。
- en: A special prefix `b` may be used to denote a byte string, i.e. a string where
    each character is a single byte.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊前缀`b`可以用来表示字节字符串，即每个字符都是单个字节。
- en: '[PRE62]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Strings are the string text enclosed by double quotes:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是由双引号括起来的字符串文本：
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The prefix `b` denotes a byte string, i.e. single byte characters. Rust allows
    newlines, space, double quotes and backslashes to be escaped using backslash notation
    similar to C++.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀`b`表示字节字符串，即单字节字符。Rust允许使用反斜杠符号类似于C++的反斜杠符号对换行、空格、双引号和反斜杠进行转义。
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Strings can also be 'raw' to avoid escaping. In this case, the string is prefixed
    r followed by zero or more hash marks, the string in double quotes and the same
    number of hash marks to close. Byte strings are uninterpretted byte values in
    a string.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也可以是'原始'的，以避免转义。在这种情况下，字符串前缀为r，后跟零个或多个井号，双引号中的字符串，以及相同数量的井号来关闭。字节字符串是字符串中未解释的字节值。
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Collections
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Collections
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A collection is something that holds zero or more elements in some fashion that
    allows you to enumerate those elements, add or remove elements, find them and
    so forth.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是以某种方式保存零个或多个元素的东西，允许你枚举这些元素，添加或删除元素，查找它们等等。
- en: Vector - a dynamic array. Appending or removing elements from the end is cheap
    (providing the array is large enough to accomodate an additional item). Inserting
    items or removing them from any other part of the array is more expensive and
    involves memory movements. Generally speaking you should always reserve enough
    space in a vector for the most elements you anticipate it will hold. Reallocating
    memory can be expensive and lead to fragmentation.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vector - 动态数组。从末尾添加或删除元素很便宜（只要数组足够大以容纳额外的项）。从数组的任何其他部分插入或删除项目更昂贵，涉及内存移动。一般来说，您应该始终为向量保留足够的空间，以容纳您预期的最多元素。重新分配内存可能很昂贵，并导致碎片化。
- en: Vecdeque - a ring buffer array. Items can be added or removed from either end
    relatively cheaply. Items in the array are not arranged sequentially so there
    is a little more complexity to managing wraparound and removal than a Vector.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vecdeque - 环形缓冲数组。可以相对便宜地从任一端添加或删除项目。数组中的项目不是按顺序排列的，因此管理环绕和删除比Vector更复杂一些。
- en: LinkedList - a linked list individually allocates memory for each element making
    it cheap to add or remove elements from anywhere in the list. However there is
    a lot more overhead to iterating the list by index and much more heap allocation.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LinkedList - 链表为每个元素单独分配内存，使得从列表中任何位置添加或删除元素变得便宜。然而，通过索引迭代列表会有更多的开销和更多的堆分配。
- en: Set - a collection that holds a unique set of items. Inserting a duplicate item
    will not succeed. Some sets maintain the order of insertion. Sets are useful where
    you want to weed out duplicates from an input.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Set - 保存一组唯一项的集合。插入重复项将不会成功。一些集合保持插入顺序。集合在你想要从输入中消除重复项时很有用。
- en: Map - a collection where each item is referenced by a unique key. Some maps
    can maintain the order of insertion.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map - 每个项都由唯一键引用的集合。一些映射可以保持插入顺序。
- en: C++ and Rust have have collections as part of their standard library as is common
    with modern languages.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: C++和Rust将集合作为其标准库的一部分，这在现代语言中很常见。
- en: '| C | C++ | Rust |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| C | C++ | Rust |'
- en: '| --- | --- | --- |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| - | `std::vector` | `std::vec::Vec` or `std::collections::VecDeque` |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| - | `std::vector` | `std::vec::Vec`或`std::collections::VecDeque` |'
- en: '| - | `std::list` | `std::collections::LinkedList` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| - | `std::list` | `std::collections::LinkedList` |'
- en: '| - | `std::set` | `std::collections::HashSet`, `std::collections::BTreeSet`
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| - | `std::set` | `std::collections::HashSet`，`std::collections::BTreeSet`
    |'
- en: '| - | `std::map` | `std::collections::HashMap`, `std::collections::BTreeMap`
    |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| - | `std::map` | `std::collections::HashMap`，`std::collections::BTreeMap`
    |'
- en: C has no standard collection classes or types. Some libraries offer collection
    APIs such as [glib](https://developer.gnome.org/glib/) or [cii](https://github.com/drh/cii).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: C没有标准的集合类或类型。一些库提供集合API，比如[glib](https://developer.gnome.org/glib/)或[cii](https://github.com/drh/cii)。
- en: Iterators
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: Iterators are a reference to a position in a collection with the means to step
    through the collection one element at a time.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是集合中位置的引用，可以逐个元素地遍历集合。
- en: C++
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++
- en: 'C++11 provides a shorthand way of iterating a collection:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: C++11提供了一种简便的方式来迭代一个集合：
- en: '[PRE66]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Iterators are more explicit in C++98 and before and the code in C++11 is basically
    equivalent to this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器在C++98及之前更加明确，而在C++11中的代码基本上等同于这样：
- en: '[PRE67]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is quite verbose, but essentially each collection type defines a mutable
    `iterator` and immutable `const_iterator` type and calling `begin` returns an
    iterator to the beginning of the collection. Calling the `++` operator overload
    on the iterator causes it to advance to the next element in the collection. When
    it hits the exclusive value returned by `end` it has reached the end of the collection.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当冗长，但基本上每种集合类型都定义了一个可变的`iterator`和一个不可变的`const_iterator`类型，调用`begin`返回集合的起始迭代器。对迭代器调用`++`操作符重载会使其在集合中前进到下一个元素。当它达到`end`返回的排他值时，它已经到达集合的末尾。
- en: Obviously with an indexed type such as a `vector` you could also reference elements
    by index, but it is far more efficient to use iterators for other collection types.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对于像`vector`这样的索引类型，你也可以通过索引引用元素，但是对于其他集合类型来说，使用迭代器更有效率。
- en: Processing collections
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理集合
- en: C++ provides a number of utility templates in <algorithm class="hljs-meta">for
    modifying sequences in collections on the fly.</algorithm>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了一些实用模板，在<algorithm class="hljs-meta">用于在集合中实时修改序列。</algorithm>
- en: Rust
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rust
- en: Rust also has iterators which work in a similar fashion to C++ - incrementing
    their way through collections.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Rust也有类似于C++的迭代器，它们通过集合逐步增加。
- en: TODO
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项
- en: TODO chaining iterators together
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 待办链式迭代器
- en: TODO mapping one collection to another collection
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 待办将一个集合映射到另一个集合
- en: Structs
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: Structs
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: C++
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++
- en: A `class` and a `struct` in C++ are largely the same thing from an implementation
    standpoint. They both hold fields and they both can have methods attached to the
    class (`static`) or instance level.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上，C++中的`class`和`struct`基本上是相同的东西。它们都包含字段，并且它们都可以在类（`static`）或实例级别附加方法。
- en: '[PRE68]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The default access level is `public` for struct and `private` for class. Some
    rules about templates only apply to classes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的访问级别对于结构体是`public`，对于类是`private`。一些关于模板的规则仅适用于类。
- en: From a psychological perspect a `struct` tends to be used to hold public data
    that is largely static and/or passed around. A `class` tends to be something more
    self contained with methods that are called to access or manage private fields.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 从心理学的角度来看，`struct`倾向于用于保存主要是静态的或传递的公共数据。`class`倾向于更自包含，具有用于访问或管理私有字段的方法。
- en: 'So these are equivalents:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些是等价的：
- en: '[PRE69]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Classes can also use an access specifier to inherit from a base class. So a
    class may specify `public`, `protected` or `private` when deriving from another
    class depending on whether it wants those methods to be visible to callers, or
    subclasses.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以使用访问修饰符从基类继承。因此，当一个类想要那些方法对调用者或子类可见时，类可以指定`public`、`protected`或`private`。
- en: Classes and structs may have special constructor and destructor methods which
    are described in sections below.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体可能具有特殊的构造函数和析构函数方法，这些方法在下面的章节中描述。
- en: '[PRE70]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then in the .cpp file you might implement the constructor and method:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在.cpp文件中，你可能会实现构造函数和方法：
- en: '[PRE71]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Rust
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Rust only has structs. A `struct` consists of a definition which specifies the
    fields and their access level (public or not), and an `impl` section which contains
    the implementation of functions bound to the struct.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Rust仅有结构体。`struct`由一个定义组成，该定义指定字段及其访问级别（公共或否），以及包含与结构体绑定的函数实现的`impl`部分。
- en: '[PRE72]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'An `impl` section follows containing the associated functions:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`impl`部分跟随其中包含相关函数：
- en: '[PRE73]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `new()` function here is a convenience method that returns a struct preinitialised
    with the arguments supplied. The `area()` function specifies a `&self` argument
    and returns an area calculation. Any function that supplies a `&self`, or `&mut
    self` can be called from the variable bound to the struct.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`new()`函数是一个方便的方法，它返回一个使用提供的参数预初始化的结构体。`area()`函数指定了一个`&self`参数，并返回一个区域计算。任何提供了`&self`或`&mut
    self`的函数都可以从绑定到结构体的变量中调用。
- en: '[PRE74]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `self` keyword works in much the same way as C++ uses `this`, as a reference
    to the struct from which the function was invoked. If a function modifies the
    struct it must say `&mut self`, which indicates the function modifies the struct.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`关键字的工作方式与C++中的`this`相似，作为调用函数的结构体的引用。如果函数修改结构体，则必须说明`&mut self`，这表示函数修改结构体。'
- en: There is no inheritance in Rust. Instead, a `struct` may implement zero or more
    traits. A trait describes some kind of behavior that can be associated with the
    struct and described further later on in this chapter.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中没有继承。相反，一个`struct`可以实现零个或多个 traits。一个 trait 描述了可以与结构体关联的某种行为，并在本章后面进一步描述。
- en: Constructors
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: In C++ all classes have implicit or explicit constructors. Either the compiler
    generates them or you do, or a mix of both.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，所有类都有隐式或显式构造函数。要么编译器生成它们，要么你自己生成，或者两者兼而有之。
- en: An implicit default constructor, copy constructor and assignment operator will
    be created when a class does not define its own. We saw on page 73 why this could
    be really bad news.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类没有定义自己的默认构造函数、复制构造函数和赋值运算符时，将创建一个隐式默认构造函数、复制构造函数和赋值运算符。我们在第73页看到为什么这可能是一个坏消息。
- en: What becomes obvious from reading there is a lot of noise and potential for
    error in C++. There would be even more if raw pointers were used instead of a
    `std::unique_ptr` here.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 从阅读中变得明显的是 C++ 中存在许多噪音和潜在错误。如果这里使用原始指针而不是`std::unique_ptr`，那么错误可能会更多。
- en: In Rust, things are simpler, and we'll see how it shakes out errors.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，事情更简单，我们将看到它如何处理错误。
- en: 'First off, let''s declare our equivalent struct in Rust:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 Rust 中声明我们的等效结构体：
- en: '[PRE75]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Since credentials are optional, we wrap in an `Option` object, i.e. credentials
    might be None or it might be `Some(Credentials)`. Any code anywhere in the system
    can instantiate a `Person` simply be declaring an instance:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 由于凭据是可选的，我们将其包装在一个`Option`对象中，即凭据可能是`None`，也可能是`Some(Credentials)`。系统中的任何代码都可以通过声明一个实例来实例化一个`Person`：
- en: '[PRE76]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In Rust you cannot create a struct without initialising all its members so we
    cannot have a situation where we don't know what is in each field - it MUST be
    set by our code.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，你不能创建一个未初始化所有成员的结构体，因此我们不能出现我们不知道每个字段中有什么的情况 - 它必须由我们的代码设置。
- en: But declaring the struct is a bit clumsy, especially if the struct is created
    in lots of places. So can write function that behaves like a constructor in C++.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 但是声明结构体有点笨拙，特别是如果结构体在许多地方创建。因此可以编写一个类似于 C++ 中构造函数的函数。
- en: Instead you implement a static method in the impl of the Struct which returns
    an initialised struct, e.g.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以在结构体的实现中实现一个静态方法，返回一个初始化的结构体，例如：
- en: '[PRE77]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that Rust does not support overloads. So if we had multiple "constructor"
    methods, they would each have to have unique names.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Rust 不支持重载。因此，如果我们有多个“构造函数”方法，它们每个都必须有唯一的名称。
- en: Finally what is we wanted to copy the `Person` struct?
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想复制`Person`结构体呢？
- en: By default Rust does not allow copying on user-defined structs. Assigning a
    variable to another variable moves ownership, it doesn't copy.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rust 不允许在用户定义的结构体上进行复制。将一个变量赋值给另一个变量会移动所有权，而不是复制。
- en: There are two ways to make a user-defined struct copyable
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法使用户定义的结构体可复制
- en: implement the `Copy` trait which means assignment is implicit, but is what we
    want? Do we really want to make copies of a struct by accident?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Copy` trait，这意味着��值是隐式的，但这是我们想要的吗？我们真的想无意中复制一个结构体吗？
- en: implement `Clone` instead to add a `clone()` method and require an explicit
    call to `clone()` order to duplicate the struct a copy.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Clone`而不是添加一个`clone()`方法，并要求显式调用`clone()`来复制结构体的副本。
- en: But the compiler can derive clone() providing all the members of the struct
    implement the Clone trait.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 但是编译器可以派生`clone()`，只要结构体的所有成员实现了 Clone trait。
- en: '[PRE78]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: What we can see is that Rust's construction and `clone()` behavior is basically
    declarative. We saw how C++ has all kinds of rules and nuances to construction,
    copy construction and assignment which make it complicated and prone to error.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 Rust 的构造和`clone()`行为基本上是声明性的。我们看到 C++ 在构造、复制构造和赋值方面有各种规则和细微差别，使其复杂且容易出错。
- en: Destructors
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 析构函数
- en: A C++ destructor is a specialized method called when your object goes out of
    scope or is deleted.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的析构函数是当你的对象超出范围或被删除时调用的专门方法。
- en: '[PRE79]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In C++ you can declare a class destructor to be called when the object is about
    to be destroyed. You have to use a virtual destructor if your class inherits from
    another class in case a caller calls `delete` on the base class.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，你可以声明一个类的析构函数，在对象即将被销毁时调用。如果你的类继承自另一个类，那么在基类上调用`delete`时，你必须使用虚析构函数。
- en: Since Rust does not do inheritance and does not have constructors, the manner
    in which you cleanup is different and simpler. Instead of a destructor you implement
    the `Drop` trait.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Rust不进行继承，也没有构造函数，清理方式不同且更简单。你实现`Drop`特质来代替析构函数。
- en: '[PRE80]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The compiler recognizes this trait. If you implement this trait then the compiler
    knows to call your `drop()` function prior to destroying your struct. It’s that
    simple.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器识别该特质。如果你实现了这个特质，那么编译器就知道在销毁结构体之前调用你的`drop()`函数。就这么简单。
- en: 'Occasionally there might be a reason to explicitly drop a struct before it
    goes out of scope. Perhaps the resources held by the variable should be freed
    as soon as possible to release a resource which is in contention. Whatever the
    reason, the answer is to call `drop` like this:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔可能有理由在它超出范围之前明确删除一个结构体。也许变量持有的资源应该尽快释放，以释放一个处于争用状态的资源。无论原因是什么，答案是像这样调用`drop`：
- en: '[PRE81]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Access specifier rules
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问限定符规则
- en: 'A C++ class can hide or show methods and members to any other class, or to
    things that inherit from itself using the public, private and protected keywords:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: C++类可以使用public、private和protected关键字向任何其他类或从自身继承的东西隐藏或显示方法和成员：
- en: '`public` – can be seen by any code internal or external to the class'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` – 可被类内或类外的任何代码所见。'
- en: '`private` – can only be used by code internal to the class. Not even subclasses
    can access these members'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private` – 只能被类内部的代码使用。甚至子类也无法访问这些成员。'
- en: '`protected` – can be used by code internal to the class and by subclasses.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected` – 可被类内部的代码和子类使用。'
- en: A class may designate another function or class as a friend which has access
    to the private and protected members of a class.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以将另一个函数或类指定为友元，以访问类的私有和受保护成员。
- en: Rust makes things somewhat simpler.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Rust使事情变得有些简单。
- en: If you want a struct to be visible outside your module you mark it `pub`. If
    you do not mark it `pub` then it is only visible within the module and submodules.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让一个结构体在你的模块外可见，你就标记它为`pub`。如果你不标记它为`pub`，那么它只能在模块和子模块内可见。
- en: '[PRE82]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If you want publicaccess a member of a struct (including modifying it if its
    mutable), then mark it `pub`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想公开访问结构体的成员（包括修改它如果它是可变的），那么标记它为`pub`。
- en: '[PRE83]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If you want something to be able to call a function on your struct you mark
    it `pub`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让某些东西能够调用你的结构体上的函数，你就标记它为`pub`。
- en: '[PRE84]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Functions
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions can be bound to a struct within an `impl` block:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以绑定到`impl`块中的结构体内部：
- en: '[PRE85]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Functions that start with a `&self` / `&mut self` parameter are bound to instances.
    Those without are bound to the type. So the `new()` function can be called as
    `Shape::new()`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 以`&self` / `&mut self`参数开头的函数绑定到实例。没有这些参数的绑定到类型。因此，`new()`函数可以被称为`Shape::new()`。
- en: 'Where `&self` is provided, the function is invoked on the instance. So for
    example:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供`&self`时，函数在实例上被调用。所以例如：
- en: '[PRE86]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Where `&mut self` is provided it signifies that the function mutates the struct.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供`&mut self`时，表示该函数会改变结构体的内容。
- en: 'Unlike C++, all access to the struct has to be qualified. In C++ you don''t
    publishing_interval: Double, lifetime_count: UInt32, max_keep_alive_count: UInt32,
    max_notifications_per_publish: UInt32, priority: Bytehave to say `this->foo()`
    to call foo() from another member of the class. Rust requires code to say unambiguously
    `self.foo()`.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++不同，对结构体的所有访问都必须有资格。在C++中，你不必说`this->foo()`来从类的另一个成员调用foo()。Rust要求代码明确地说`self.foo()`。
- en: Static functions
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态函数
- en: Static functions are merely functions in the `impl` block that do not have `&self`
    or `&mut self` as their first parameter, e.g.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 静态函数只是在`impl`块中没有`&self`或`&mut self`作为其第一个参数的函数，例如。
- en: '[PRE87]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In other words they're not bound to an instance of a type, but to the type itself.
    For example, `Circle::pi()`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它们不是绑定到类型的实例，而是绑定到类型本身。例如，`Circle::pi()`。
- en: Traits
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特质
- en: C++ allows one class to inherit from another. Generally this is a useful feature
    although it can get pretty complex if you implement multiple inheritance, particularly
    the dreaded diamond pattern.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许一个类从另一个类继承。一般来说，这是一个有用的功能，尽管如果你实现了多重继承，特别是可怕的菱形模式，它可能会变得非常复杂。
- en: As we’ve found out, Rust doesn’t have classes at all – they’re structs with
    bound functions. So how do you inherit code? The answer is you don’t.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所发现的，Rust根本没有类 - 它们是绑定函数的结构体。那么你如何继承代码呢？答案是你不继承。
- en: Instead your struct may implement traits which are a bit like partial classes.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您的结构体可能实现了一些像部分类的特征。
- en: 'A trait is declared like so:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 trait 的声明如下：
- en: '[PRE88]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here the trait `HasCircumference` has a function called `circumference()` whose
    signature is defined but must be implemented.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 trait `HasCircumference` 有一个名为 `circumference()` 的函数，其签名已定义但必须实现。
- en: A type can implement the trait by declaring and `impl` of it.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类型可以通过声明和 `impl` 来实现该 trait。
- en: '[PRE89]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: A trait may supply default function implementations. For example, a `HasDimensions`
    trait might implement `area()` to spare the implementor the bother of doing it.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 trait 可以提供默认的函数实现。例如，`HasDimensions` trait 可以实现 `area()` 来避免实现者的麻烦。
- en: '[PRE90]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Lifetimes
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期
- en: In C++ an object lives from the moment it is constructed to the moment it is
    destructed.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，一个对象从被构造的那一刻开始存在，直到被析构的那一刻结束。
- en: That lifetime is implicit if you declare the object on the stack. The object
    will be created / destroyed as it goes in and out of scope. It is also implicit
    if your object is a member of another object - the lifetime is within the containing
    object, and the declaration order of other members in the containing object.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在堆栈上声明对象，那么该生命周期是隐式的。对象将随着其进入和离开作用域而创建 / 销毁。如果您的对象是另一个对象的成员，则它也是隐式的 - 生命周期在包含对象中，以及包含对象中其他成员的声明顺序。
- en: However, if you allocate your object via `new` then it is up to you when to
    `delete`. If you `delete` too soon, or forget to `delete` then you may destabilize
    your program. C++ encourages using smart pointers that manage the lifetime of
    your object, tying it to the implicit lifetime of the smart pointer itself - when
    the smart pointer is destroyed, it deletes the held pointer. A more sophisticated
    kind of smart pointer allows multiple instances of the same pointer to exist at
    once, and reference counting is used so that when the last smart pointer is destroyed,
    it destroyes the pointer.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您通过 `new` 分配对象，那么您可以在何时 `delete` 是由您决定的。如果您过早地 `delete`，或者忘记 `delete`，那么您可能会使您的程序不稳定。C++
    鼓励使用智能指针来管理对象的生命周期，将其绑定到智能指针本身的隐式生命周期 - 当智能指针被销毁时，它会删除所持有的指针。一种更复杂的智能指针允许同一指针的多个实例同时存在，并且引用计数用于当最后一个智能指针被销毁时销毁指针。
- en: Even so, C++ itself will not care if you initialized a class with a reference
    or pointer to something that no longer lives. If you do this, your program will
    crash.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，C++ 并不关心你是否用一个不再存在的引用或指针初始化了一个类。如果你这样做了，你的程序将崩溃。
- en: Let's write an `Incrementor` class which increments an integer value and returns
    that value.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 `Incrementor` 类，它会增加一个整数值并返回该值。
- en: '[PRE91]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This seems fine, but what if we use it like this?
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来没问题，但如果我们这样使用它呢？
- en: '[PRE92]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This code passes a reference to an `int` into the class constructor and returns
    the `Incrementor` from the function itself. But when `increment()` is called the
    reference is dangling and anything can happen.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将一个`int`的引用传递给了类构造函数，并从函数本身返回了`Incrementor`。但是当调用`increment()`时，引用是悬挂的，任何事情都可能发生。
- en: Rust lifetimes
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 生命周期
- en: Rust *does* care about the lifetime of objects and tracks them to ensure that
    you cannot reference something that no longer exists. Most of the time this is
    automatic and self-evident from the error message you get if you try something
    bad.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Rust *确实* 关心对象的生命周期，并跟踪它们以确保您不能引用不存在的东西。大多数情况下，这是自动的，并且可以从您尝试坏事时收到的错误消息中明显看出。
- en: 'The compiler also implements a *borrow checker* which tracks references to
    objects to ensure that:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还实现了一个 *借用检查器*，用于跟踪对对象的引用，以确保：
- en: References are held no longer than the lifetime of the object they refer to.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引用的持有时间不会超过它们所引用的对象的生命周期。
- en: Only a single mutable reference is possible at a time and not concurrently with
    immutable references. This is to prevent data races.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一次只能有一个可变引用，不能与不可变引用同时存在。这是为了防止数据竞争。
- en: The compiler will generate compile errors if it finds code in violation of its
    rules.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器发现代码违反了其规则，它将生成编译错误。
- en: 'So let''s write the equivalent of `Incrementor` above but in Rust. The Rust
    code will hold a reference to a integer `i32` and increment it from a bound function:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们写一个与上面的 `Incrementor` 等效的 Rust 代码。Rust 代码将持有一个整数 `i32` 的引用，并从一个绑定函数中递增它：
- en: '[PRE93]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Seems fine, but the first error we get is:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来没问题，但我们得到的第一个错误是：
- en: '[PRE94]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We tried to create a struct that manages a reference, but the compiler doesn't
    know anything about this reference's lifetime and so it has generated a compile
    error.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试创建一个管理引用的结构体，但编译器对这个引用的生命周期一无所知，因此它生成了一个编译错误。
- en: To help the compiler overcome its problem, we will annotate our struct with
    a lifetime which we will call `'a`. The label is anything you like but typically
    it'll be a letter.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助编译器解决它的问题，我们将用一个生命周期来注释我们的结构体，我们将其称为 `'a`。标签可以是任何你喜欢的东西，但通常它会是一个字母。
- en: 'This lifetime label is a hint on our struct that says the reference we use
    inside the struct must have a lifetime of at least as much the struct itself -
    namely that `Incrementor<''a>` and `value: &''a mut i32` share the same lifetime
    constraint and the compiler will enforce it.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '这个生命周期标签是我们结构体的一个提示，它表示我们在结构体内部使用的引用必须至少具有与结构体本身一样长的生命周期 - 即 `Incrementor<''a>`
    和 `value: &''a mut i32` 共享相同的生命周期约束，编译器会强制执行它。'
- en: '[PRE95]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'With the annotation in place, we can now use the code:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 有了注释，我们现在可以使用这段代码：
- en: '[PRE96]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note that the annotation `'a` could be any label we like - `'increment` would
    work if we wanted, but obviously its more longwinded.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 注意注释 `'a` 可以是我们喜欢的任何标签 - 如果我们愿意，`'increment` 就可以工作，但显然它更冗长。
- en: There is a special lifetime called `'static` that refers to things like static
    strings and functions which have a lifetime as long as the runtime and may therefore
    be assumed to always exist.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的生命周期称为 `'static`，它指的是像静态字符串和函数这样的东西，它们的生命周期与运行时一样长，因此可以假定它们总是存在的。
- en: Lifetime elision
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期省略
- en: Rust allows reference lifetimes to be elided (a [fancy word](https://ericlippert.com/2013/01/24/five-dollar-words-for-programmers-elision/)
    for omit) in most function signatures.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许在大多数函数签名中省略引用生命周期。
- en: Basically, it assumes that when passing a reference into a function, that the
    lifetime of the reference is implicitly longer than the function itself so the
    need to annotate is not necessary.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，它假定当将引用传递到函数中时，引用的生命周期隐式长于函数本身，因此不需要注释。
- en: '[PRE97]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The rules for elision are described in the further reference link.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 省略规则在进一步的参考链接中有描述。
- en: Further reference
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步的参考资料
- en: Lifetimes are a large subject and the documentation is [here](https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期是一个庞大的主题，文档在[这里](https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision)。
- en: Comments
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: Comments
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Rust comments are similar to C++ except they may contain Unicode because .rs
    files are UTF-8 encoded:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 注释与 C++ 类似，只是它们可能包含 Unicode，因为 .rs 文件是 UTF-8 编码的：
- en: '[PRE98]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'But in addition anything that uses triple slash `///` annotation can be parsed
    by a tool called `rustdoc` to produce documentation:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了使用三斜杠 `///` 注释的内容外，还可以通过一个名为 `rustdoc` 的工具来解析产生文档：
- en: '[PRE99]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Runnining `cargo doc` on a project will cause HTML documentation to be produced
    from annotated comments within the file.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `cargo doc` 在项目上会产生 HTML 文档，其中包含文件中的注释。
- en: Annotation is written in Markdown format. That means you have a human readable
    language for writing rich-text documentation and if it's not enough you can resort
    to HTML via tags.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 注释以 Markdown 格式编写。这意味着你有一种可读的人类语言来编写丰富的文本文档，如果不够用，你可以通过标签回到 HTML。
- en: See here for [full documentation](https://doc.rust-lang.org/book/documentation.html)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[完整文档](https://doc.rust-lang.org/book/documentation.html)
- en: Lifetimes, References and Borrowing
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期、引用和借用
- en: Lifetimes, References and Borrowing
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期、引用和借用
- en: When you assign an object to a variable in Rust, you are said to be binding
    it. i.e your variable "owns" the object for as long as it is in scope and when
    it goes out of scope it is destroyed.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个对象分配给 Rust 中的一个变量时，你被称为绑定它。也就是说，只要它在范围内，你的变量就“拥有”该对象，当它超出范围时，它就被销毁了。
- en: '[PRE100]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: So variables are scoped and the scope is the constraint that affects their lifetime.
    Outside of the scope, the variable is invalid.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 因此变量是有范围的，范围是影响它们生命周期的约束。在范围之外，变量无效。
- en: In this example, it is important to remember the `Vec` is on the stack but the
    pointer it allocates to hold its elements is on the heap. The heap space will
    also be recovered when the `Vec` is dropped.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，重要的是记住 `Vec` 在堆栈上，但它分配用于保存其元素的指针在堆上。当 `Vec` 被丢弃时，堆空间也将被回收。
- en: 'If we assign v1 to another variable, then all the object ownership is moved
    to that other variable:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 v1 分配给另一个变量，那么所有对象的所有权都将移动到该其他变量：
- en: '[PRE101]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This may seem weird but it's worth remembering a serious problem we saw in C++,
    that of copy constructor errors. It is too easy to duplicate a class and inadvertantly
    share private date or state across multiple instances.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很奇怪，但值得记住 C++ 中出现的一个严重问题，即复制构造函数错误。很容易复制一个类并无意中在多个实例之间共享私有数据或状态。
- en: We don't want objects v1 and v2 to share internal state and in Rust they don't.
    Rust moves the data from v1 to v2 and marks v1 as invalid. If you attempt to reference
    v1 any more in your code, it will generate a compile error. This compile error
    will indicates that ownership was moved to v2.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望对象 v1 和 v2 共享内部状态，在 Rust 中它们不会。Rust 将数据从 v1 移动到 v2，并标记 v1 为无效。如果你尝试在代码中再次引用
    v1，它将生成一个编译错误。这个编译错误将指示所有权已转移到 v2。
- en: 'Likewise, if we pass the value to a function then that also moves ownership:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们将值传递给函数，那也会移动所有权：
- en: '[PRE102]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When we call we_own_it() we moved ownership of the object to the function and
    it never came back. Therefore the following call using v1 is invalid. We could
    call a variation of the function called we_own_and_return_it() which does return
    ownership:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 we_own_it() 时，我们将对象的所有权移交给了函数，它��也没有返回。因此，使用 v1 进行的以下调用是无效的。我们可以调用一个名为
    we_own_and_return_it() 的函数的变体，它确实返回所有权：
- en: '[PRE103]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: But that's pretty messy and there is a better way described in the next section
    called borrowing.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 但这很混乱，下一节中有一种更好的方法称为借用。
- en: These move assignments look weird but it is Rust protecting you from the kinds
    of copy constructor error that is all too common in C++. If you assign a non-Copyable
    object from one variable to another you move ownership and the old variable is
    invalid.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这些移动赋值看起来很奇怪，但这是 Rust 保护你免受 C++ 中常见的复制构造函数错误的方式。如果你将一个不可复制的对象从一个变量赋给另一个变量，你会移动所有权，旧变量将无效。
- en: If you truly want to copy the object from one variable to another so that both
    hold independent objects you must make your object implement the Copy trait. Normally
    it's better to implement the Clone trait which works in a similar way but through
    an explicit clone() operation.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想将对象从一个变量复制到另一个变量，使两者持有独立的对象，你必须使你的对象实现 Copy trait。通常最好实现 Clone trait，它通过一个显式的
    clone() 操作方式工作。
- en: Variables must be bound to something
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量必须绑定到某个东西
- en: 'Another point. Variables must be bound to something. You cannot use a variable
    if it hasn''t been initialized with a value of some kind:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要点。变量必须绑定到某个东西。如果一个变量没有被初始化为某种值，你就不能使用它：
- en: '[PRE104]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: It is quite valid in C++ to declare variable and do nothing with it. Or conditionally
    do something to the variable which confuses the compiler so it only generates
    a warning.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，声明变量并不对其进行任何操作是完全有效的。或者有条件地对变量进行一些操作，这会让编译器困惑，因此它只会生成一个警告。
- en: '[PRE105]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The Rust compiler will throw an error, not a warning, if variables are uninitialised.
    It will also warn you if you declare a variable and end up not using it.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器会抛出一个错误，而不是警告，如果变量未初始化。如果你声明一个变量但最终没有使用它，它也会警告你。
- en: References and Borrowing
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用和借用
- en: We've seen that ownership of an object is tracked by the compiler. If you assign
    one variable to another, ownership of the object is said to have moved to the
    assignee. The original variable is invalid and the compiler will generate errors
    if it is used.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到对象的所有权是由编译器跟踪的。如果你将一个变量赋给另一个变量，对象的所有权被认为已转移到被赋值的变量。原始变量将无效，如果使用它，编译器将生成错误。
- en: 'Unfortunately this extends to passing values into functions and this is a nuisance.
    But variable bindings can be borrowed. If you wish to loan a variable to a function
    for its duration, you can pass a reference to the object:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这也适用于将值传递给函数，这是一个麻烦。但是变量绑定可以被借用。如果你希望将一个变量借给一个函数使用，你可以传递一个对象的引用：
- en: '[PRE106]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here we create an empty vector and pass a mutable reference to it to a function
    called fill_vector(). The compiler knows that the function is borrowing v and
    then ownership is returned to v after the function returns.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个空向量，并将一个可变引用传递给一个名为 fill_vector() 的函数。编译器知道该函数正在借用 v，然后在函数返回后将所有权返回给
    v。
- en: Expressions
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: Expressions
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: An expression is something that evaluates to something. Just like C++ more or
    less...
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是一个会评估为某个值的东西。就像 C++ 差不多...
- en: '[PRE107]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: But blocks are expressions too
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但块也是表达式
- en: 'Where it gets more interesting is that a block of code, denoted by curly braces
    also evaluates to an expression. This is legal code:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，由花括号表示的代码块也会评估为一个表达式。这是合法的代码：
- en: '[PRE108]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: What was assigned to x? In this case the block was empty so x was assigned with
    the value of `()`. The value `()` is a special unitary type that essentially means
    neither yes or no. It just means "value". That is the default type of any function
    or type. It works a little like `void` in C++ meaning the value is meaningless
    so don't even look at it.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: x被分配了什么？在这种情况下，该块为空，所以x被赋予了`()`的值。值`()`是一种特殊的单元类型，基本上意味着既不是是也不是。它只是意味着"值"。这是任何函数或类型的默认类型。它的工作方式有点像C++中的`void`，意味着值是没有意义的，所以甚至不要看它。
- en: '[PRE109]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This block also returns a value of `()`.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 该块还返回了一个`()`的值。
- en: '[PRE110]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Again, that's because although the block does stuff (print Hello), it doesn't
    evaluate to anything so the compiler returns `()` for us.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是因为尽管该块执行某些操作（打印Hello），但它不会评估为任何内容，因此编译器为我们返回了`()`。
- en: 'So far so useless. But we can change what the block expression evaluates to:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还是毫无用处。但是我们可以改变块表达式的评估结果：
- en: '[PRE111]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now x assigned with the result of the last line which is an expression. Note
    how the line is not terminated with a semicolon. That becomes the result of the
    block expression. If we’d put a semicolon on the end of that line as we did with
    the println!("Hello"), the expression would evaluate to ().
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 现在x被分配了最后一行的结果，这是一个表达式。请注意，该行没有用分号终止。这成为了块表达式的结果。如果我们在那一行的末尾放置了一个分号，就像我们用println！("Hello")一样，表达式将评估为()。
- en: Use in functions
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在函数中使用
- en: 'Trivial functions can just omit the return statement:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 简单函数只需省略return语句：
- en: '[PRE112]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: You can use return in blocks too
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您也可以在块中使用return
- en: Sometimes you might explicitly need to use the return statement. The block expression
    evaluates at the end of the block so if you need to bail early you could just
    use return.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能需要显式使用return语句。块表达式在块末尾评估，因此如果您需要提前退出，只需使用return。
- en: '[PRE113]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Simplifying switch statements
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化switch语句
- en: 'In C or C++ you''ll often see code like this:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在C或C++中，您经常会看到这样的代码：
- en: '[PRE114]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The code wants to test a value in server_state and assign a string to result.
    Aside from looking a bit clunky it introduces the possibility of error since we
    might forget to assign, or add a break, or omit one of the values.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码想要测试server_state中的值并将一个字符串分配给result。除了看起来有点笨拙之外，它还引入了错误的可能性，因为我们可能会忘记分配，或者添加一个break，或者省略其中一个值。
- en: In Rust we can assign directly into result of from a match because each match
    condition is a block expression.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们可以直接将结果分配给match的result，因为每个match条件都是一个块表达式。
- en: '[PRE115]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Not only is this half the length it reduces the scope for error. The compiler
    will assign the block expression's value to the variable result. It will also
    check that each match block returns the same kind of type (so you can't return
    a float from one match and strings from others). It will also generate an error
    if the ServerState enum had other values that our match didn't handle.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅长度减半了，而且还减少了错误的范围。编译器将块表达式的值分配给变量result。它还将检查每个匹配块返回相同类型的类型（因此您不能从一个匹配中返回一个浮点数，而从其他匹配中返回字符串）。如果ServerState枚举具有我们的匹配没有处理的其他值，它还将生成错误。
- en: Ternary operator
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三元运算符
- en: The ternary operator in C/C++ is an abbreviated way to perform an if/else expression
    condition, usually to assign the result to a variable.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++中的三元运算符是执行if/else表达式条件的一种缩写方式，通常用于将结果分配给变量。
- en: '[PRE116]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Rust has no such equivalent to a ternary operator but it can be accomplished
    using block expressions.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: Rust没有三元运算符的等价物，但可以使用块表达式来实现。
- en: '[PRE117]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Unlike C/C++ you could add additiona else ifs, matches or anything else to that
    providing each branch returns the same type.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 与C/C++不同，您可以添加额外的else if、匹配项或任何其他内容，只要每个分支返回相同的类型。
- en: Conditions
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件
- en: Conditions
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件
- en: Conditional code is similar between C++ and Rust. You test the boolean truth
    of an expression and you can use boolean operators such as && and || to join expressions
    together.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: C++和Rust之间的条件代码类似。您测试表达式的布尔真值，并且可以使用布尔运算符（例如&&和||）将表达式连接在一起。
- en: '[PRE118]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In Rust:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中：
- en: '[PRE119]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The most notable difference is that Rust omits the outer braces so the code
    is slightly cleaner. You don't have to omit the outer braces but the compiler
    will issue a warning if you leave them in.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 最显着的区别是Rust省略了外部大括号，所以代码稍微清晰一些。您不必省略外部大括号，但是如果您将它们保留下来，编译器将发出警告。
- en: Ternary operator
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'The ternary operator is that special ? : shorthand notation you can use to
    in C++ for simple conditionals.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '三元运算符是C++中用于简单条件的特殊? : 缩写符号。'
- en: '[PRE120]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Rust does not support this notation, however you may take advantage of how
    a block evaluates as an expression to say this instead:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不支持这种记法，不过你可以利用块的求值作为表达式来表达这个意思：
- en: '[PRE121]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'So basically you can do one line conditional assignments using if and else.
    Also note that you could even throw in an "else if" or two if that''s what you
    wanted to do:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你可以使用 if 和 else 来进行一行条件赋值。还要注意，如果你愿意，甚至可以加入一两个 "else if"：
- en: '[PRE122]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Conditional "if let"
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件 "if let"
- en: One unusual feature is the "if let" pattern. This combines a test to see if
    something matches a pattern and if it does, to automatically assign the result
    to the tuple. It would be most commonly see in code that returns an enum such
    as a `Result` or `Option`.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不寻常的特性是 "if let" 模式。这将一个测试与一个模式匹配，并在匹配时自动将结果分配给元组。它最常见于返回枚举值的代码，如 `Result`
    或 `Option`。
- en: 'For example:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE123]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Switch / Match
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Switch / Match
- en: Switch / Match
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Switch / Match
- en: C++
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++
- en: A `switch` statement in C or C++ allows a condition or a variable to be compared
    to a series of values and for code associated with those values to executed as
    a result. There is also a default clause to match any value that is is not caught
    explicitly.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 或 C++ 中，`switch` 语句允许将条件或变量与一系列值进行比较，并根据结果执行与这些值相关联的代码。还有一个默认子句匹配任何未被明确捕获的值。
- en: '[PRE124]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Switch statements can be a source of error because behaviour is undefined when
    a `default` clause is not supplied. It is also possible to inadvertently forget
    the `break` statement. In the above example, the code explicitly "drops" from
    the 404 handler into the default handler. This code would work fine providing
    someone didn't insert some extra clauses between 404 and default...
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: switch 语句可能会引发错误，因为当没有提供 `default` 子句时，行为是未定义的。当意外地忘记了 `break` 语句时，也可能会引发错误。在上面的示例中，代码明确地从
    404 处理程序 "掉入" 到默认处理程序。只要不是有人在 404 和默认之间插入一些额外的子句，这段代码就能正常工作...
- en: Additionally switch statements only work on numeric values (or `bool`).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，switch 语句仅适用于数值（或 `bool`）。
- en: Rust
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: '[Match](https://doc.rust-lang.org/book/match.html) is like a `switch` statement
    on steroids.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '[Match](https://doc.rust-lang.org/book/match.html) 就像是一个强化版的 `switch` 语句。'
- en: In C++ a switch is a straight comparison of an integer value of some kind (including
    chars and enums), against a list of values. If the comparison matches, the code
    next to it executes until the bottom of the switch statement or a break is reached.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，switch 是对某种整数值（包括字符和枚举）与一系列值进行直接比较。如果比较成功，紧邻它的代码将执行，直到 switch 语句的底部或达到一个
    break。
- en: TODO
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: TODO
- en: Casting
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: Casting
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: Casting is the act of coercing one type to be another, or dynamically producing
    the equivalent value in the other type.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 转换是将一种类型强制转换为另一种类型，或者动态地在另一种类型中生成等效值的行为。
- en: C++ has a range of cast operators that turn a pointer or value of one kind into
    a pointer or value of another kind.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 有一系列的转换操作符，可以将一种类型的指针或值转换为另一种类型的指针或值。
- en: '`const_cast<T>(value)` - removes the const enforcement from a value so it may
    be modified.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const_cast<T>(value)` - 移除值的常量限制，以便可以修改。'
- en: '`static_cast<T>(value)` - attempts to convert between types using implicit
    and user defined conversions.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static_cast<T>(value)` - 尝试使用隐式和用户定义的转换在类型之间转换。'
- en: '`reinterpret_cast<T>(value)` - a compiler directive to just treat the input
    as some other kind. It does not involve any form of conversion.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast<T>(value)` - 一个编译器指令，只是将输入视为其他类型。它不涉及任何形式的转换。'
- en: '`dynamic_cast<T>(value)` - attempts to convert a class pointer / reference
    to/from other classes in its inheritance hierarchy. Involves runtime checks.'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic_cast<T>(value)` - 尝试将类指针/引用转换为其继承层次结构中的其他类的指针/引用。涉及运行时检查。'
- en: Traditional C-style cast - a C++ compiler will attempt to interpret it as a
    `const_cast`, a `static_cast` and a `reinterpret_cast` in varying combinations.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的 C 风格转换 - C++ 编译器将尝试将其解释为 `const_cast`、`static_cast` 和 `reinterpret_cast`
    的组合。
- en: That's a very brief summary of casting which probably invokes more questions
    than it answers. Casting in C++ is very complex and nuanced. Some casts merely
    instruct the compiler to ignore const or treat one type as another. A static cast
    might involve code generation to convert a type. A dynamic cast might add runtime
    checks and throw exceptions.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对转换的一个非常简短的总结，可能会引发比解答更多的问题。在 C++ 中，转换非常复杂而微妙。有些转换仅仅是指示编译器忽略 const 或将一种类型视为另一种类型。静态转换可能涉及代码生成以转换类型。动态转换可能添加运行时检查并抛出异常。
- en: Rust has nothing equivalent to this complexity. A numeric type may be converted
    to another numeric type using the [`as`](https://doc.rust-lang.org/book/casting-between-types.html#as)
    keyword.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 没有与此复杂性相当的东西。可以使用 [`as`](https://doc.rust-lang.org/book/casting-between-types.html#as)
    关键字将数字类型转换为另一种数字类型。
- en: '[PRE125]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Anything beyond this requires implementing the `Into<>` or `From<>` traits and
    making conversion an explicit action.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 超出这个范围的任何事情都需要实现 `Into<>` 或 `From<>` 特性，并将转换作为显式操作。
- en: The compiler also does not allow code to cast away `const`-ness or treat one
    type as another except through `unsafe` code blocks.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器也不允许代码去除 `const` 或将一个类型视为另一个类型，除非通过 `unsafe` 代码块。
- en: Transmutation
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: Rust allows some types to be [transmuted](https://doc.rust-lang.org/book/casting-between-types.html#transmute)
    to others. Transmute is an `unsafe` action but it allows a memory location to
    be treated as another type, e.g. an array of bytes as an integer.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许一些类型[转换](https://doc.rust-lang.org/book/casting-between-types.html#transmute)为其他类型。转换是一种
    `unsafe` 操作，但它允许将一个内存位置视为另一种类型，例如将字节数组视为整数。
- en: Enumerations
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Enumerations
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: In C++ an `enum` is a bunch of labels assigned an `int` value. i.e. it is basically
    a bunch of constants with scalar values.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，`enum` 是一组被赋予 `int` 值的标签。即它基本上是一组具有标量值的常量。
- en: '[PRE126]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: C++11 extends this concept a little, allowing you to declare an `enum` that
    uses another kind of integral type, e.g. a `char` to hold the values.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 对此概念进行了一点扩展，允许你声明一个使用另一种整数类型的 `enum`，例如，一个 `char` 来保存值。
- en: '[PRE127]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In Rust an [`enum`](https://doc.rust-lang.org/book/enums.html) can be a scalar
    value just like in C++.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，[`enum`](https://doc.rust-lang.org/book/enums.html) 可以像在 C++ 中一样是标量值。
- en: '[PRE128]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: But an enum can also hold actual data so you can convey far more information
    than a static value could by itself.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 但是枚举也可以保存实际数据，因此你可以传达比静态值本身更多的信息。
- en: '[PRE129]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You can also bind functions to the enum:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将函数绑定到枚举上：
- en: '[PRE130]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'So we might have a function that makes an http request and returns a response:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能有一个函数，它发出一个 http 请求并返回一个响应：
- en: '[PRE131]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now our code is able to return a more meaningful response in an enum and the
    code is able to extract that response to print out useful information.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码能够以枚举返回更有意义的响应，代码能够提取出这些响应并打印出有用的信息。
- en: Loops
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Loops
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: C++
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++
- en: For loops
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: For 循环
- en: 'A `for` loop in C/C++ consists of 3 expression sections housed in the `for()`
    section and a block of code to execute:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 中的 `for` 循环由包含在 `for()` 区域中的 3 个表达式部分和一段要执行的代码块组成：
- en: 'The three segments of a for statement allow:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 'for 语句的三个部分允许： '
- en: Zero or more variables to be initialized (can be empty)
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个要初始化的变量（可以为空）
- en: Zero or more conditions to be true for the loop to continue (can be empty)
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个条件必须为真以使循环继续（可以为空）
- en: Zero or more actions to perform on each iteration (can be empty).
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个在每次迭代中执行的操作（可以为空）。
- en: 'So this is a valid for loop:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个有效的 for 循环：
- en: '[PRE132]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'So is this:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这样也可以：
- en: '[PRE133]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This is clearly a convoluted and somewhat confusing loop because it mixes assignment
    and conditional tests into the terminating text, but it is one which is entirely
    legal.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个复杂而有些混乱的循环，因为它将赋值和条件测试混合到了终止文本中，但这是完全合法的。
- en: Iterating a range
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历一个范围
- en: 'A C++ loop consists of an initialising expression, a condition expression and
    a a loop expression separated by semicolons. So a loop that iterates from 0 to
    100 looks like this:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 循环由一个初始化表达式、一个条件表达式和一个循环表达式组成，用分号分隔。因此，一个从 0 到 100 迭代的循环如下所示：
- en: '[PRE134]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Iterating C++ collections
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历 C++ 集合
- en: C++ introduces the concept of iterators to its collection classes. An `iterator`
    is something that can increment or decrement to traverse a collection.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 引入了迭代器的概念到其集合类中。`iterator` 是可以递增或递减以遍历集合的东西。
- en: So to iterate a collection from one end to the other, an iterator is assigned
    with the collection's `begin()` iterator and incremented until it matches the
    `end()` iterator.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了遍历一个集合从一端到另一端，一个迭代器被赋值为集合的 `begin()` 迭代器，并递增直到匹配 `end()` 迭代器。
- en: '[PRE135]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'C++11 provides new range based for-loop with simpler syntax when iterating
    over arrays and collections:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 提供了一种新的基于范围的 for 循环，用于在数组和集合上进行迭代时具有更简单的语法：
- en: '[PRE136]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Infinite Loop
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无限循环
- en: 'An infinite loop is one that never ends. The typical way to do this in C++
    is to test against an expression that always evaluates to true or use an empty
    for loop:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环是永远不会结束的循环。在 C++ 中通常的做法是测试一个总是评估为 true 的表达式或使用一个空的 for 循环：
- en: '[PRE137]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: While Loop
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: While 循环
- en: C++ has conditional `while() {}` and `do { } while()` forms. The former tests
    the expression before it even runs while the latter runs at least once before
    testing the expression.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: C++有条件的`while() {}`和`do { } while()`形式。前者在运行之前测试表达式，而后者在测试表达式之前至少运行一次。
- en: '[PRE138]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The do-while form in C++ will execute the loop body at least once because the
    condition is only tested after each iteration instead of before.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的do-while形式会至少执行一次循环体，因为条件仅在每次迭代后测试，而不是之前。
- en: '[PRE139]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Break and Continue
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断和继续
- en: If you need to exit a loop or start the next iteration early then you use the
    `break` and `continue` keywords. The break keyword terminates the loop, the continue,
    causes the loop to proceed to the next iteration.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要提前退出循环或开始下一次迭代，则使用`break`和`continue`关键字。break关键字终止循环，而continue导致循环继续到下一次迭代。
- en: '[PRE140]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Rust
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: For loop
  id: totrans-694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: For循环
- en: Rust's `for` loop is actually sugar over the top of iterators. If a structured
    type implements the trait `IntoIterator` it can be looped over using a `for` loop.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的`for`循环实际上是对迭代器的一种糖。如果结构化类型实现了特性`IntoIterator`，它就可以使用`for`循环进行迭代。
- en: 'Basically in pseudo code, the loop desugars to this:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上在伪代码中，循环会转化为以下形式：
- en: '[PRE141]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Iterating a range
  id: totrans-698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代范围
- en: A `Range` object in Rust is expressed as `from..to` where `from` and `to` are
    values or expressions that evaluate to values.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的`Range`对象表示为`from..to`，其中`from`和`to`是值或求值为值的表达式。
- en: 'For example:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE142]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: A range is inclusive / exclusive, i.e. the minimum value is included in the
    `Range` but the maximum value is exclusive.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是包含/排除的，即最小值包含在`Range`中，但最大值是排除的。
- en: Here is a simple loop that counts from 0 to 9
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的循环，从0到9计数
- en: '[PRE143]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The value `0..10` is a `Range` that runs from 0 to exclusive of 10\. A range
    implements the `Iterator` trait so the for loop advances one element at a time
    until it reaches the end.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 值`0..10`是一个从0到不包括10的`Range`。范围实现了`Iterator`特性，因此for循环每次前进一个元素直到达到末尾。
- en: Iterators have a lot of functions on them for doing fancy stuff, but one which
    is useful in loops is the `enumerate()` function. This transforms the iterator
    into returning a tuple containing the index and the value instead of just the
    value.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器有很多函数可以执行各种花式操作，但在循环中有一个有用的函数是`enumerate()`函数。它将迭代器转换为返回包含索引和值的元组，而不仅仅是值。
- en: 'So for example:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 所以例如：
- en: '[PRE144]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: For loop - Iterating arrays and collections
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: For循环-迭代数组和集合
- en: 'Here is a loop that iterates an array:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个迭代数组的循环：
- en: '[PRE145]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note you can only iterate over an array by reference because iterating it by
    value would be destructive.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只能通过引用迭代数组，因为按值迭代会破坏数组。
- en: 'We can directly use the `iter()` function that arrays and collections implement
    which works by reference:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用数组和集合实现的`iter()`函数，该函数通过引用工作：
- en: '[PRE146]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: If the collection is a map, then iterators will return a key and value tuple
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合是映射，则迭代器将返回键和值元组
- en: '[PRE147]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Another way to iterate is using the `for_each()` function on the iterator itself:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种迭代的方法是直接在迭代器上使用`for_each()`函数：
- en: '[PRE148]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Break and Continue
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断和继续
- en: Rust also has `break` and `continue` keywords and they operate in a similar
    fashion - they operate on the innermost loop. A `continue` will start on the next
    iteration while a `break` will terminate the loop.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还有`break`和`continue`关键字，它们的操作方式类似-它们作用于最内层的循环。`continue`将从下一次迭代开始，而`break`将终止循环。
- en: '[PRE149]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Labels
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标签
- en: 'The `break` and `continue` work by default on the current loop. There will
    be occasions where you intend to break out of an enclosing loop instead. For those
    occasions you can label your loops and pass that label into the `break` or `continue:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`默认在当前循环上工作。有时您打算中断外部循环。对于这些情况，您可以为循环加标签，并将该标签传递给`break`或`continue`：'
- en: '[PRE150]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Infinite Loop
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无限循环
- en: 'Rust has an explicit infinite `loop` that runs indefinitely:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有一个明确的无限`loop`，会无限期地运行：
- en: '[PRE151]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Rust recommends using this form when an infinite loop is required to assist
    with code generation. Note that an infinite loop can still be broken out of using
    a `break` statement.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: Rust建议在需要无限循环以辅助代码生成时使用此形式。请注意，仍然可以使用`break`语句中断无限循环。
- en: While Loop
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: While循环
- en: A `while` loop in Rust looks pretty similar to one written in C/C++. The main
    difference is that parentheses are not necessary around the conditional test.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的`while`循环看起来与C/C++中的循环很相似。主要区别在于在条件测试周围不需要括号。
- en: '[PRE152]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Rust has no equivalent to the do-while loop form. It can be simulated but it
    looks a bit inelegant:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: Rust没有等价于do-while循环形式的语法。它可以模拟，但看起来有点不太优雅：
- en: '[PRE153]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: While let loop
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: While let 循环
- en: 'Just as there is an `if let` which tests and assigns a value that matches a
    pattern, there is also a `while let` equivalent:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 正如有 `if let` 用于测试和分配与模式匹配的值一样，还有一个等价的 `while let`：
- en: '[PRE154]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: This loop will break when the iterator returns `None`.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代器返回 `None` 时，此循环将中断。
- en: Functions
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'In C++ the standard form of a function is this:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，函数的标准形式是这样的：
- en: '[PRE155]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Usually you would declare the function, either as a forward reference in a source
    file, or in a header. Then you would implement the function in a source file.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会声明函数，要么是在源文件中的前向引用，要么是在头文件中。然后你会在源文件中实现函数。
- en: If a function does not return something, the return type is `void`. If the function
    does return something, then there should be return statements for each exiting
    branch within the function.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数不返回任何东西，返回类型是 `void`。如果函数确实返回某些东西，则应该对函数内的每个退出分支都有返回语句。
- en: 'You can forego the function declaration in two situations:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在两种情况下放弃函数声明：
- en: If the function is inline, i.e. prefixed with the `inline` keyword. In which
    case the function in its entireity is declared and implemented in one place.
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数是内联的，即以 `inline` 关键字为前缀。在这种情况下，函数的整体在一个地方声明和实现。
- en: If the function is not inline but is declared before the code that calls it
    in the same source file. So if function `foo` above was only used by one source
    file, then just putting the implementation into the source would also act as the
    declaration
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数不是内联的，但是在同一源文件中调用它的代码之前声明。所以如果上面的函数 `foo` 只被一个源文件使用，那么将实现放入源文件中也将起到声明的作用。
- en: 'In Rust the equivalent to `foo` above is this:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，与上面的 `foo` 等价的是这样的：
- en: '[PRE156]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The implementation *is* the declaration there is no separation between the two.
    Functions that return nothing omit the `->` return section. The function can also
    be declared before or after whatever calls it. By default the function is private
    to the model (and submodules) that implement it but making it `pub fn` exposes
    it to other modules.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 *就是* 声明，两者之间没有区别。返回空值的函数省略了 `->` 返回部分。函数也可以在调用它的任何地方之前或之后声明。默认情况下，函数对实现它的模块（和子模块）私有，但将其设置为
    `pub fn` 将其暴露给其他模块。
- en: Like C++, the function must evaluate to something for each exiting branch but
    this is mandatory.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 类似，函数必须对每个退出分支进行评估，但这是强制性的。
- en: 'Also note, that the `return` keyword is not usually unecessary. Here is a function
    that adds two values together and returns them with no return:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，`return` 关键字通常是不必要的。这是一个将两个值相加并无需返回的函数示例：
- en: '[PRE157]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Why is there no `return`? As we saw in the section on Expressions, a block evaluates
    to a value if we omit the semi-colon from the end so `x + y` is the result of
    evaluating the function block and becomes what we return.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么没有 `return`？正如我们在表达式部分看到的，如果我们从末尾省略分号，那么块将计算出一个值，所以 `x + y` 是函数块求值的结果，并成为我们返回的结果。
- en: 'There are occasions were you explicitly need the return keyword. Typically
    you do that if you want to exit the function before you get to the end of the
    function block:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你明确需要 `return` 关键字。如果你想在函数块结束之前退出函数，你通常这样做：
- en: '[PRE158]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Variable arguments
  id: totrans-756
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数
- en: C++ functions can take a variable number of arguments with the ... ellipsis
    pattern. This is used in functions such as print, scanf etc.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 函数可以使用 ... 省略符号模式获取可变数量的参数。这在诸如 print、scanf 等函数中使用。
- en: '[PRE159]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Rust does not support variadic functions (the fancy name for this ability).
    However you could pass additional arguments in an array slice if the values are
    the same, or as a dictionary or a number of other ways.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不支持变长参数函数（这种能力的花哨名称）。但是如果值相同，你可以将额外的参数传递为数组切片，或者作为字典或其他方式。
- en: TODO Rust example of array slice
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: TODO Rust 数组切片示例
- en: Another option is to write your code as a macro. Macros can take any number
    of expressions so you are able to write code that takes variable arguments. This
    is how macros such println!, format! and vec! work.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将代码编写为宏。宏可以接受任意数量的表达式，因此你可以编写接受可变参数的代码。这就是 `println!`、`format!` 和 `vec!`
    等宏的工作原理。
- en: Default arguments
  id: totrans-762
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: C++ arguments can have default values.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 参数可以有默认值。
- en: '[PRE160]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: A function defines what its name is, what types it takes and what value (if
    any) it returns.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义了其名称、它接受的类型以及它返回的值（如果有）。
- en: Function overloading
  id: totrans-766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数重载
- en: C++ functions can be overloaded, e.g.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 函数可以重载，例如：
- en: '[PRE161]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Rust does not support overloading. As an alternative, each variation of the
    function would have to be named uniquely.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: Rust不支持重载。作为替代，每个函数的变体都必须被唯一命名。
- en: C++11 alternative syntax
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++11的替代语法
- en: C++11 introduces a new syntax which is slightly closer to Rust's in style.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了一种风格稍微接近Rust的新语法。
- en: '[PRE162]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: This form was created to allow C++ function declarations to more closely to
    resemble lambda functions in some scenarios and to help with decltype return values.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式是为了让C++函数声明在某些情况下更接近于lambda函数，并帮助处理decltype返回值而创建的。
- en: Polymorphism
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: Polymorphism
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: C++
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++
- en: 'C++ has 4 types of polymorphism:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: C++有4种类型的多态性：
- en: Function name overloading - multiple definitions of the same function taking
    different arguments.
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数名重载 - 多个定义相同函数，接受不同参数。
- en: Coercion - implicit type conversion, e.g. assigning a double to an int or a
    bool.
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制转换 - 隐式类型转换，例如将double赋给int或bool。
- en: Parametric - compile type substitution of parameters in templates
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数化 - 模板中参数的编译时替换
- en: Inclusion - subtyping a class with virtual methods overloads their functionality.
    Your code can use the pointer to a base class, yet when you call the method you
    are calling the function implemented by the subtype.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 - 将具有虚方法的类子类型化会重载它们的功能。你的代码可以使用基类的指针，但当你调用方法时，你调用的是子类型实现的函数。
- en: That is to say, the same named function can be overloaded with different parameters.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，同名函数可以用不同的参数进行重载。
- en: Function name overloading
  id: totrans-783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数名重载
- en: '[PRE163]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: One of the biggest issues that you might begin to see from the above example
    is that is too easy to inadvertantly call the wrong function because C++ will
    also implicitly convert types. On top of that C++ also has default parameter values
    *and* default constructors. So you might call a function using one signature and
    be calling something entirely different after the compiler resolves it.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的例子中你可能开始看到的一个最大问题是，很容易无意中调用错误的函数，因为C++也会隐式转换类型。此外，C++还具有默认参数值和默认构造函数。因此，在编译器解析后，你可能调用一个签名的函数，但实际上调用的是完全不同的东西。
- en: '[PRE164]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: This example will call the integer overload because `NULL` evaluates to 0\.
    One of the changes to `C++11` was to introduce an explicit `nullptr` value and
    type to avoid this issues.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将调用整数重载，因为`NULL`评估为0。`C++11`的一个变化是引入了一个明确的`nullptr`值和类型，以避免这些问题。
- en: Rust
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Rust has limited support for polymorphism.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: Rust对多态性的支持有限。
- en: Function name overloading - there is none. See section below for alternatives.
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数名重载 - 没有。查看下面的替代方案。
- en: Coercion. Rust allows limited, explict coercion between numeric types using
    the `as` keyword. Otherwise see below for use on `Into` and `From` traits.
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制转换。Rust允许使用`as`关键字在数值类型之间进行有限的显式强制转换。否则，查看下面关于`Into`和`From`特性的用法。
- en: Parameteric - similar to C++ via generics
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数化 - 与C++类似，通过泛型
- en: Inclusion - there is no inheritance in Rust. The nearest thing to a virtual
    method in rust is a trait with an implemented function that an implementation
    overrides with its own. However this override is at compile time.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 - Rust中没有继承。在Rust中最接近虚方法的东西是一个具有实现函数的特性，一个实现可以用自己的函数覆盖。然而，这种覆盖是在编译时进行的。
- en: Alternatives to function name overloading
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数名重载的替代方案
- en: If you have a few functions you can just disambiguate them, e.g.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有几个函数，你可以简单地将它们区分开，例如
- en: '[PRE165]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Use traits
  id: totrans-797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用特性
- en: A common way to do polymorphism is with *traits*.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的多态性方式是使用*特性*。
- en: 'There are two standard traits for this purpose:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种标准特性用于此目的：
- en: The `From<>` trait converts from some type into the our type.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`From<>`特性将某种类型转换为我们的类型。'
- en: The `Into<>` trait converts some type (consuming it in the process) into our
    type
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Into<>`特性将某种类型（在过程中消耗它）转换为我们的类型'
- en: You only need to implement `From` or `Into` because one implies the other.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要实现`From`或`Into`，因为一个暗示着另一个。
- en: 'The `From` trait is easier to implement:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '`From`特性更容易实现：'
- en: '[PRE166]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'But let''s say we want an explicit `new` constructor function on type `Foo`.
    In that case, we could write it using the `Into` trait:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们想要在类型`Foo`上有一个显式的`new`构造函数。在这种情况下，我们可以使用`Into`特性来编写它：
- en: '[PRE167]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Since `From` implies `Into` we can just call the constructor like so:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`From`暗示了`Into`，我们可以这样调用构造函数：
- en: '[PRE168]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: If you prefer you could implement `Into` but it's more tricky since it consumes
    the input, which might not be what you want.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以实现`Into`，但这更棘手，因为它消耗了输入，这可能不是你想要的。
- en: '[PRE169]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Use enums
  id: totrans-811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用枚举
- en: 'Remember that an enumeration in Rust can contain actual data, so we could also
    implement a function that takes an enumeration as an argument that has values
    for each kind of value it accepts:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Rust 中的枚举可以包含实际数据，因此我们也可以实现一个函数，该函数将枚举作为参数，该枚举具有每种它接受的值的值。
- en: '[PRE170]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Error Handling
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error Handling
  id: totrans-815
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: C++ allows code to throw and catch exceptions. As the name suggests, exceptions
    indicate an exceptional error. An exception is thrown to interrupt the current
    flow of logic and allows something further up the stack which to catch the exception
    and recover the situation. If nothing catches the throw then the thread itself
    will exit.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 允许代码抛出和捕获异常。顾名思义，异常表示异常错误。异常被抛出以中断当前的逻辑流程，并允许堆栈中更高级别的东西捕获异常并恢复情况。如果没有东西捕获抛出，则线程本身将退出。
- en: '[PRE171]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Most coding guidelines would say to use exceptions sparingly for truly exceptional
    situations, and use return codes and other forms of error propagation for ordinary
    failures. However C++ has no simple way to confer error information for ordinary
    failures and exceptions can be complicated to follow and can cause their own issues.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编码准则会建议仅在真正异常的情况下适度使用异常，并对普通失败使用返回码和其他形式的错误传播。但是 C++ 没有简单的方法来传递普通失败的错误信息，异常可能会变得复杂难以跟踪，并可能引发自身问题。
- en: Rust does not support exceptions. Rust programs are expected to use a type such
    as `Option` or `Result` to propagate errors to their caller. In other words, the
    code is expected to anticipate errors and have code to deal with them.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不支持异常。Rust 程序应该使用诸如 `Option` 或 `Result` 这样的类型将错误传播给调用者。换句话说，代码应该预期错误并编写处理它们的代码。
- en: 'The `Option` enum either returns `None` or `Some` where the `Some` is a payload
    of data. It''s a generic enum that specifies the type of what it may contain:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` 枚举要么返回 `None`，要么返回 `Some`，其中 `Some` 是一组数据的有效载荷。它是一个泛型枚举，指定了它可能包含的数据类型：'
- en: '[PRE172]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: For example, we might have a function that searches a database for a person's
    details, and it either finds them or it doesn't.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能有一个函数，用于搜索数据库中某人的详细信息，它要么找到它们，要么找不到。
- en: '[PRE173]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The `Result` enum either returns a value of some type or an error of some type.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 枚举要么返回某种类型的值，要么返回某种类型的错误。'
- en: '[PRE174]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: So we might have a function `set_thermostat` for setting the room temperature.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能有一个函数 `set_thermostat` 用于设置室温。
- en: '[PRE175]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: This function will return a unity `()` value for success, or a `String` for
    failure.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将返回一个成功的单位 `()` 值，或者一个失败的 `String`。
- en: The ? directive
  id: totrans-829
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '? 指令'
- en: Let's say you have 2 functions `delete_user` and `find_user`. The function `delete_user`
    first calls `find_user` to see if the user even exists and then proceeds to delete
    the user or return the error code that it got from `find_user`.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有 2 个函数 `delete_user` 和 `find_user`。函数 `delete_user` 首先调用 `find_user` 来查看用户是否存在，然后继续删除用户或返回从
    `find_user` 得到的错误代码。
- en: '[PRE176]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'We have a lot of code in `delete_user` to handle success or failure in `find_user`
    and throw its failure code upwards. So Rust provides a convenience `?` mark on
    the end of the call to a function that instructs the compiler to generate the
    if/else branch we hand wrote above, reducing the function to this:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `delete_user` 中有很多代码来处理 `find_user` 的成功或失败，并将其失败代码向上抛出。因此，Rust 提供了一个方便的
    `?` 标记，放在对函数的调用的末尾，指示编译器生成我们手工编写的 if/else 分支，将函数简化为此形式：
- en: '[PRE177]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Providing you want to propogate errors up the call stack, this can eliminate
    a lot of messy conditional testing in the code and make it more robust.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你希望将错误传播到调用栈上，这可以消除代码中大量混乱的条件测试，并使其更加健壮。
- en: Older versions of Rust used a special `try!()` macro for this same purpose (not
    to be confused with `try-catch` in C++) which does the same thing. So if you see
    code like this, it would be the same as above.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的旧版本使用了专用的 `try!()` 宏来实现相同的目的（不要与 C++ 中的 `try-catch` 混淆），它做的事情与上面的相同。因此，如果你看到这样的代码，它和上面的代码是一样的。
- en: '[PRE178]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Nuclear option - panic!()
  id: totrans-837
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心选项 - panic!()
- en: If code really wants to do something equivalent to a throw / catch in C++ it
    may call panic!().
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码真的想要执行类似于 C++ 中的 throw / catch 的操作，它可以调用 panic!()。
- en: This is NOT recommended for dealing with regular errors, only irregular ones
    that the code has no way of dealing with.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 这不推荐用于处理常规错误，仅用于代码无法处理的不规则错误。
- en: This macro will cause the thread to abort and if the thread is the main programme
    thread, the entire process will exit.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏将导致线程中止，如果线程是主程序线程，则整个进程将退出。
- en: A panic!() can be caught and should be if Rust is being invoked from another
    language. The way to catch an unwinding panic is a closure at the topmost point
    in the code where it can be handled.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 可以捕获并且应该捕获 `panic!()`，如果 Rust 是从另一种语言调用的话。捕获未绑定的 panic 的方法是在代码中顶部最高点处使用一个闭包来处理它。
- en: '[PRE179]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Lambda Expressions / Closures
  id: totrans-843
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式 / 闭包
- en: Lambda Expressions / Closures
  id: totrans-844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式 / 闭包
- en: Lambdas in C++11
  id: totrans-845
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++11 中的 Lambda
- en: A [lambda expression](https://msdn.microsoft.com/en-us/library/dd293608.aspx),
    or lambda is an anonymous function that can be declared and passed around from
    within the scope of the call itself.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '[lambda 表达式](https://msdn.microsoft.com/en-us/library/dd293608.aspx)，或 lambda
    是一个可以在调用的范围内声明并传递的匿名函数。'
- en: This can be particularly useful when you want to sort, filter, search or otherwise
    do some trivial small action without the bother of declaring and maintaining a
    separate function.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想对一些微不足道的小操作进行排序、过滤、搜索或者其他一些操作时，这特别有用，而不必声明和维护一个单独的函数。
- en: 'In C++ a lambda looks like this:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，lambda 的样子是这样的：
- en: '[PRE180]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: This lambda is passed to a std::sort function to sort an array of values by
    some criteria.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 lambda 被传递给一个 std::sort 函数，以便根据某些条件对值数组进行排序。
- en: A C++ lambda can (but doesn't have to) capture variables from the enclosing
    scope if it wishes and it can specify capture clauses in the `[]` section that
    define how capture is made. Captures can be by value or reference, and can explicitly
    list the variables to capture, or specify to capture everything by reference or
    assignment. A lambda that captures variables effectively becomes a closure.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: C++ lambda 可以（但不一定）从封闭作用域中捕获变量，如果它希望的话，它可以在 `[]` 部分指定捕获子句，定义捕获的方式。捕获可以是按值或按引用，并且可以明确列出要捕获的变量，也可以指定通过引用或分配捕获一切。捕获变量的
    lambda 实际上变成了一个闭包。
- en: '[PRE181]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'We can see from the output that `multiply()` has captured copies of the values
    in `v1` and `v2`, whereas `sum()` captures by reference and so it is sensitive
    to changes in the variables:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从输出中看到，`multiply()` 捕获了 `v1` 和 `v2` 的值的副本，而 `sum()` 捕获的是引用，因此它对变量的变化是敏感的：
- en: '[PRE182]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: A capture can also specify a default capture mode by specifying `=` in the capture
    clause or by reference `&` and then specify capture behaviour for specific variables.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 一个捕获还可以通过在捕获子句中指定 `=` 或者引用 `&` 来指定默认捕获模式，然后为特定变量指定捕获行为。
- en: 'So our captures above could be simplified to:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们上面的捕获可以简化为：
- en: '[PRE183]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Note that C++ lambdas can exhibit dangerous behaviour - if a lambda captures
    references to variables that go out of scope, the lambda's behaviour is undefined.
    In practice that could mean the application crashes.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C++ lambda 可能会表现出危险的行为 - 如果 lambda 捕获了对超出作用域的变量的引用，那么 lambda 的行为是未定义的。在实践中，这可能意味着应用程序崩溃。
- en: Closures in Rust
  id: totrans-859
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 中的闭包
- en: Rust implements closures. A closure is like a lambda except it automatically
    captures anything it references from the enclosing environment. i.e. by default
    it can access any variable that is in the enclosing scope.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 实现了闭包。闭包类似于 lambda，除了它自动捕获它从封闭环境中引用的任何东西。也就是说，它默认可以访问任何在封闭作用域中的变量。
- en: Here is the same sort snippet we saw in C++ expressed as Rust. This closure
    doesn't borrow anything from its enclosing scope but it does take a pair of arguments
    to compare two values for sorting. The `sort_by()` function repeatedly invokes
    the closure to sort the array.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在 Rust 中看到的相同的排序片段，它表达为 Rust。这个闭包不从其封闭作用域中借用任何东西，但它确实接受一对参数来比较两个值进行排序。`sort_by()`
    函数重复调用闭包来对数组进行排序。
- en: '[PRE184]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'A closure that uses a variable from the enclosing scope borrows it by default.
    That means the borrowed variable can''t change while the closure is in scope.
    To change the value we must ensure the closure goes out of scope to free the borrow,
    e.g. with a block:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 使用封闭作用域中的变量的闭包默认借用它。这意味着在闭包的作用域内，借用变量是不能改变的。要改变值，我们必须确保闭包超出作用域以释放借用，比如使用一个块：
- en: '[PRE185]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Alternatively you can `move` variables used by the closure so it owns them and
    they become inaccessible from the outerscope. Since our closure was accessing
    an integer, the move becomes an implicit copy. So our `square` closure has its
    own `x` assigned the value `100`. Even if we change `x` in the outer scope to
    `200`, the closure has its own independent copy.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以 `move` 闭包中使用的变量，使其拥有它们，并且它们在外部作用域中不可访问。由于我们的闭包正在访问一个整数，move 变成了隐式复制。所以我们的
    `square` 闭包有它自己的 `x`，赋值为 `100`。即使我们将外部作用域中的 `x` 改为 `200`，闭包也有它自己独立的副本。
- en: '[PRE186]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'This is the equivalent to the C++ code above that used lambda expressions to
    bind to copies and references:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于上面使用 lambda 表达式绑定到副本和引用的 C++ 代码：
- en: '[PRE187]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: This will yield the same results as the C++ code. The main difference here is
    that rather than binding our closure to a reference, we passed the reference values
    in as parameters to the closure.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生与 C++ 代码相同的结果。这里的主要区别是，我们没有将闭包绑定到引用，而是将引用值作为参数传递给闭包。
- en: Templates / Generics
  id: totrans-870
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板 / 泛型
- en: Templates / Generics
  id: totrans-871
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板 / 泛型
- en: C++ offers templates as a way to write generic code using an abstract type and
    then specialize it by substituting one or more types into a concrete class.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了模板作为一种编写通用代码的方式，使用抽象类型然后通过将一个或多个类型替换为具体类来特化它。
- en: '[PRE188]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'This template uses the type of the parameter (int this case 10) to create an
    inline function that prints out the value of that type:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板使用参数的类型（在此示例中为 10）来创建一个内联函数，该函数打印出该类型的值：
- en: '[PRE189]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Classes can also be made from templates:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以由模板制作：
- en: '[PRE190]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: This class implements a simple stack using a template to indicate the type of
    object it contains.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用模板来指示它包含的对象的类型，实现了一个简单的堆栈。
- en: This is a very powerful mechanism and the C++ library makes extensive use of
    it.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的机制，C++ 库广泛使用它。
- en: Where templates can become a bit of a mess is that the templates are inline
    and the compiler will expand out anything you call before attempting to compile
    it.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可能会变得有点混乱，因为模板是内联的，编译器会在尝试编译之前展开你调用的任何东西。
- en: An innocuous error such as using a type that has no default copy constructor
    in a collection can cause the compiler to go nuts and output a wall of indecipherable
    errors.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 一个看似无害的错误，比如在集合中使用没有默认复制构造函数的类型，可能会导致编译器疯狂输出一堆难以理解的错误。
- en: Generic Functions
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型函数
- en: Rust's equivalent to a template is called a generic. A generic generalizes a
    function or a trait so it works with different types that match the criteria.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的模板等效物被称为泛型。泛型将函数或特征泛化，使其适用于符合条件的不同类型。
- en: So the Rust equivalent of the `debug()` function in C++ would be this.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C++ 中的 `debug()` 函数的 Rust 等效物将是这样的。
- en: '[PRE191]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Here we describe a function that takes a generic type `T` where the constraint
    is that `T` must implement the trait `std::fmt::Display`. Any struct that implements
    this trait can passed into the call. Since integer types implement the trait,
    we can just call it directly as `debug(10)` and the compiler is happy.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们描述了一个接受泛型类型 `T` 的函数，其中约束是 `T` 必须实现 `std::fmt::Display` 特征。实现此特征的任何结构都可以传递给调用。由于整数类型实现了该特征，我们可以直接调用它作为
    `debug(10)`，编译器会很高兴。
- en: Generic structs
  id: totrans-887
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型结构体
- en: 'Similarly we can use generics on a struct. So the equivalent in Rust of the
    C++ template class `Stack` is this:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在结构体上使用泛型。因此，在 Rust 中与 C++ 模板类 `Stack` 的等效物是这样的：
- en: '[PRE192]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Where clause
  id: totrans-890
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Where 子句
- en: The `where` clause can be added to impose constraints on what generic type must
    do to be allowed to be supplied to the generic function or struct.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 子句可以添加以强制施加约束，指定泛型类型必须执行哪些操作才能被提供给泛型函数或结构。'
- en: For example we might have a function that takes a closure as an argument. A
    closure is a function and so we want to define the shape that the closure will
    take.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能有一个以闭包作为参数的函数。闭包是一个函数，所以我们想定义闭包将采取的形状。
- en: 'So:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 所以：
- en: '[PRE193]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Here we have defined a `compare()` function that takes a couple of values of
    the same type. The `where` clause states that the function must take two values
    of the same type and return a boolean. The compiler will ensure any closure we
    pass in matches that criteria, as indeed our `comparer` closure does.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了一个 `compare()` 函数，它接受相同类型的一对值。`where` 子句规定函数必须接受两个相同类型的值并返回布尔值。编译器将确保我们传递的任何闭包都符合这个标准，就像我们的
    `comparer` 闭包一样。
- en: Attributes
  id: totrans-896
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: Attributes
  id: totrans-897
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'C++ has various ways to give compiler *directives* during compilation:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 有各种方式在编译期间给出编译器*指令*：
- en: Compile flags that control numerous behaviours
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制许多行为的编译标志
- en: '`#pragma` statements - `once`, `optimize`, `comment`, `pack` etc. Some pragmas
    such as `comment` have been wildly abused in some compilers to insert "comments"
    into object files that control the import / export of symbols, static linking
    and other functionality.'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#pragma` 语句 - `once`、`optimize`、`comment`、`pack` 等。一些 pragma，如 `comment`，在某些编译器中已被广泛滥用，用于向目标文件中插入“注释”，以控制符号的导入/导出、静态链接和其他功能。'
- en: '`#define` with ubquitous `#ifdef` / `#else` / `#endif` blocks'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用普遍存在的 `#ifdef` / `#else` / `#endif` 块进行 `#define` 定义
- en: Keywords `inline`, `const`, `volatile` etc.. These hint the code and allow the
    compiler to make decisions that might change its output or optimization. Compilers
    often have their own proprietary extensions.
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字 `inline`、`const`、`volatile` 等。这些提示代码并允许编译器做出可能改变其输出或优化的决策。编译器通常有自己的专有扩展。
- en: Rust uses a notation called *attributes* that serves a similar role to all of
    these things but in a more consistent form.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 使用一种称为 *属性* 的标记，它在更一致的形式中扮演类似的角色。
- en: 'An attribute `#[foo]` applies to the next item it is declared before. A common
    attribute is used to denote a unit test case with `#[test]`:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`#[foo]`适用于在其之前声明的下一个项目。常见属性用于用`#[test]`表示单元测试用例：
- en: '[PRE194]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Attributes can also be expressed as `#![foo]` which affects the thing they're
    contained *by* rather the thing that follows them.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以表示为`#![foo]`，这会影响它们所包含的内容而不是跟随它们的内容。
- en: '[PRE195]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Attributes are enclosed in a `#[ ]` block and provide compiler directives that
    allow:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 属性被包含在`#[ ]`块中，并提供编译器指令，允许：
- en: Functions to be marked as unit or benchmark tests
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数标记为单元测试或基准测试
- en: Functions to be marked for conditional compilation for a target OS. A function
    can be defined that only compiles for one target. e.g. perhaps the code that communicates
    with another process on Windows and Linux is encapsulated in the same function
    but implemented differently.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数标记为针对目标操作系统进行条件编译。可以定义仅适用于一个目标的函数。例如，与另一个进程通信的代码在 Windows 和 Linux 上封装在同一个函数中，但实现方式不同。
- en: Enable / disable lint rules
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用/禁用 lint 规则
- en: Enable / disable compiler features. Certain features of rust may be experimental
    or deprecated and may have to be enabled to be accessed.
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用/禁用编译器功能。Rust 的某些功能可能是实验性的或已弃用的，可能需要启用才能访问。
- en: Change the entry point function from `main` to something else
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将入口函数从 `main` 更改为其他内容
- en: Conditional compilation according to target architecture, OS, family, endianess,
    pointer width
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据目标体系结构、操作系统、家族、字节顺序、指针宽度进行条件编译
- en: Inline hinting
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联提示
- en: Deriving certain traits
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推导出某些特征
- en: Enabling compiler features such as plugins that implement procedural macros.
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用编译器功能，例如实现过程宏的插件。
- en: Importing macros from other crates
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他 crate 导入宏
- en: Used by certain crates like serde and rocket to instrument code - NB Rocket
    uses unstable compiler hooks for this and in so doing limits itself to working
    in nightly builds only.
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被某些 crate（如 serde 和 rocket）用于仪器化代码 - 注意：Rocket 使用不稳定的编译器钩子进行此操作，因此限制自己仅在夜间构建中工作。
- en: Conditional compilation
  id: totrans-920
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件编译
- en: Conditional compilation allows you to test the target configurations and optionally
    compile functions or modules in or not.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译允许您测试目标配置，并选择性地编译函数或模块。
- en: 'The main configurations you will test include:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 您将测试的主要配置包括：
- en: Target architecture - "x86", "x86_64", mips", "arm" etc.
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标体系结构 - "x86"、"x86_64"、"mips"、"arm"等。
- en: Target OS - "windows", "macos", "ios", "linux", "android", "freebsd" etc.
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标操作系统 - "windows"、"macos"、"ios"、"linux"、"android"、"freebsd"等。
- en: Target family - "unix" or "windows"
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标家族 - "unix" 或 "windows"
- en: Target environment - "gnu", "msvc" etc
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标环境 - "gnu"、"msvc" 等
- en: Target endianess
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标字节顺序
- en: Target pointer width
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标指针宽度
- en: 'So if you have a function which is implemented one way for Windows and another
    for Linux you might code it like so:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您有一个函数在 Windows 上以一种方式实现，在 Linux 上以另一种方式实现，您可以像这样编写它：
- en: '[PRE196]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Many more possibilities are listed in the [documentation](https://doc.rust-lang.org/reference/attributes.html#crate-only-attributes).
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 更多可能性在[文档](https://doc.rust-lang.org/reference/attributes.html#crate-only-attributes)中列出。
- en: Linking to native libraries
  id: totrans-932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接到本地库
- en: In C/C++ code is first compiled and then it is linked, either by additional
    arguments to the compiler, or by invoking a linker.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 中，代码首先编译，然后通过向编译器添加额外参数或调用链接器进行链接。
- en: In Rust most of your linking is taken care for you providing you use `cargo`.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，只要使用 `cargo`，大部分的链接工作都是自动完成的。
- en: All your sources are compiled and linked together.
  id: totrans-935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有源代码都会被编译和链接在一起。
- en: External crates are automatically built as static libs and linked in.
  id: totrans-936
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部 crate 会自动构建为静态库并链接进来。
- en: But if you have to link against something external through FFI you have to write
    a `#link` directive in your `lib.rs` or `main.rs`. This is somewhat analogous
    to the `#pragma(comment, "somelib")` in C++.
  id: totrans-937
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，如果您必须通过 FFI 链接到外部内容，则必须在您的 `lib.rs` 或 `main.rs` 中编写 `#link` 指令。这在某种程度上类似于
    C++ 中的 `#pragma(comment, "somelib")`。
- en: '| C++ | Rust |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Rust |'
- en: '| --- | --- |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `#pragma (comment, "somelib")` | `#[link(name = "somelib")]` |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '| `#pragma (comment, "somelib")` | `#[link(name = "somelib")]` |'
- en: '| - | `#[link(name = "somelib", kind = "static")]` |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '| - | `#[link(name = "somelib", kind = "static")]` |'
- en: The default kind for `#link` is `dynamic` library but `static` can be explicitly
    stated specified.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '`#link`的默认类型是`dynamic`库，但可以明确指定为`static`。'
- en: Inlining code
  id: totrans-943
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联代码
- en: Inlining happens where your function logic is inserted in-place to the code
    that invokes it. It tends to happen when the function does something trivial such
    as return a value or execute a simple conditional. The overhead of duplicating
    the code is outweighed by the performance benefit.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 内联发生在您的函数逻辑被插入到调用它的代码中的地方。当函数执行一些微不足道的操作，比如返回一个值或执行一个简单的条件时，它往往会发生。复制代码的开销被性能好处所抵消。
- en: Inlining is achieved in C++ by declaring and implementing a function, class
    method or template method in a header or marking it with the inline keyword.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，可以通过在头文件中声明和实现函数、类方法或模板方法或者使用 inline 关键字标记来实现内联。
- en: In Rust, inlining is only a hint. Rust recommends not forcing inlning, rather
    leaving it as a hint for the LLVM compiler to do with as it sees fit.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，内联只是一个提示。Rust 建议不要强制内联，而是将其留作 LLVM 编译器根据需要处理的提示。
- en: '| C++ | Rust |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Rust |'
- en: '| --- | --- |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Explicitly with `inline` or implicitly through methods implemented in class
    / struct | `#[inline]`, `#[inline(always)]`, `#[inline(never)]` |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '| 显式使用 `inline` 或隐式通过在类/结构中实现的方法 | `#[inline]`、`#[inline(always)]`、`#[inline(never)]`
    |'
- en: Another alternative to explicitly inlining code is to use the link-time optimisation
    in LLVM.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 显式内联代码的另一种选择是使用 LLVM 中的链接时优化。
- en: '[PRE197]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Multi-threading
  id: totrans-952
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: Multithreading
  id: totrans-953
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: Multithreading allows you to run parts of your programming concurrently, performing
    tasks in parallel. Every program has a *main* thread - i.e. the one your `main()`
    started from, in addition to which are any that you create.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程允许你同时运行编程的部分，以并行方式执行任务。每个程序都有一个*主*线程 - 即你的`main()`从中启动的线程，另外还有您创建的任何线程。
- en: 'Examples of reasons to use threads:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程的原因示例：
- en: Long running operations, e.g. zipping up a large file.
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间运行的操作，例如压缩一个大文件。
- en: Activity that is blocking in nature, e.g. listening for connections on a socket
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞式的活动，例如在套接字上监听连接
- en: Processing data in parallel, e.g. physics, collision detection etc.
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理数据，例如物理、碰撞检测等。
- en: Asynchronous activities, e.g. timers, polling operations.
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步活动，例如定时器、轮询操作。
- en: In addition, if you use a graphical toolkit, or 3rd party libraries they may
    spawn their own threads that you do not know about.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果使用图形工具包或第三方库，它们可能会生成您不知道的线程。
- en: Thread safety
  id: totrans-961
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: One word you will hear a lot in multithreading is thread safety.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程中，您会经常听到一个词叫线程安全。
- en: 'By that we mean:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说：
- en: Threads should not be able to modify the data at the same time. When this happens
    it is called a data race and can corrupt the data, causing a crash. e.g. two threads
    trying to append to a string at the same time.
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不应能够同时修改数据。当这种情况发生时，称为数据竞争，可能会损坏数据，导致崩溃。例如，两个线程同时尝试追加到一个字符串。
- en: Threads must not lock resources in a way that could cause deadlock i.e. thread
    1 obtains a lock on resource B and blocks on resource A, while thread 2 obtains
    a lock on resource A and blocks on resource B. Both threads are locked forever
    waiting for a resource to release that never will be.
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不应以可能导致死锁的方式锁定资源，即线程 1 获得资源 B 的锁并在资源 A 上阻塞，而线程 2 获得资源 A 的锁并在资源 B 上阻塞。两个线程将永远被锁定，等待永远不会释放的资源。
- en: Race conditions are bad, i.e. the order of thread execution produces unpredictable
    results on the output from the same input.
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争条件是不好的，即线程执行顺序对相同输入的输出产生不可预测的结果。
- en: APIs that can be called by multiple threads must either protect their data structures
    or make it an explicit problem of the client to sort out.
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以被多个线程调用的 API 必须要么保护它们的数据结构，要么明确地让客户端解决这个问题。
- en: Open files and other resources that are accessed by multiple threads must be
    managed safely.
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被多个线程访问的打开文件和其他资源必须安全地进行管理。
- en: Protecting shared data
  id: totrans-969
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护共享数据
- en: Data should never be read at the same time it is written to in another thread.
    Nor should data be written to at the same time by two threads.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 数据不应在另一个线程同时读取和写入。也不应该由两个线程同时写入数据。
- en: 'The common way to prevent this is either:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种情况的常见方式是：
- en: Use a mutex to guard access to the data. A mutex is a special class that only
    one thread can lock at a time. Other threads that try to lock the mutex will wait
    until the lock held by another thread is relinquished
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁来保护数据访问。互斥锁是一种特殊的类，一次只能有一个线程锁定。尝试锁定互斥锁的其他线程将等待，直到另一个线程持有的锁被释放。
- en: Use a read-write lock. Similar to a mutex, it allows one thread to lock the
    thread for writing data, however it permits multiple threads to have read access,
    providing nothing is already writing to it. For data that is read more frequently
    than it is modified, this is a lot more efficient than just a mutex.
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读写锁。类似于互斥锁，它允许一个线程锁定用于写入数据的线程，但允许多个线程具有读取访问权限，前提是没有其他线程正在写入数据。对于频繁读取而不是修改的数据，这比仅使用互斥锁要高效得多。
- en: Avoiding deadlock
  id: totrans-974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免死锁
- en: The best way to avoid deadlock is only ever obtain a lock to one thing ever
    and release it as soon as you are done. But if you have to lock more than one
    thing, ensure the locking order is consistent between all your threads. So if
    thread 1 locks A and B, then ensure that thread 2 also locks A and B in that order
    and not B then A. The latter is surely going to cause a deadlock.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 避免死锁的最佳方法是只锁定一件事情，并在完成后立即释放。但如果必须锁定多个事物，请确保所有线程之间的锁定顺序是一致的。因此，如果线程 1 锁定 A 和
    B，则确保线程 2 也按照这个顺序锁定 A 和 B，而不是 B 然后 A。后者肯定会导致死锁。
- en: C / C++
  id: totrans-976
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C / C++
- en: C and C++ predate threading to some extent so until C++11 the languages have
    had little built-in support for multi-threading and what there was tended to be
    compiler specific extensions.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 在某种程度上早于线程，因此直到 C++11 之前，这两种语言对多线程几乎没有内置支持，而且存在的支持往往是特定于编译器的扩展。
- en: A consequence of this is that C and C++ have ZERO ENFORCEMENT of thread safety.
    If you data race - too bad. If you forget to write a lock in one function even
    if you remembered all the others - too bad. You have to discipline yourself to
    think concurrently and apply the proper protections where it is required.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致 C 和 C++ 没有线程安全的强制执行。如果数据竞争 - 很遗憾。如果你忘记在一个函数中写锁，即使你记住了所有其他函数 - 很遗憾。你必须自律地考虑并在必要时应用适当的保护。
- en: The consequence of not doing so may not even be felt until your software is
    in production and that one customer starts complaining that their server freezes
    about once a week. Good luck finding that bug!
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 不这样做的后果可能甚至在您的软件投入生产并且某个客户开始抱怨他们的服务器每周冻结一次时才会感受到。祝你好运找到那个 bug！
- en: Multithreading APIs
  id: totrans-980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多线程 API
- en: 'The most common APIs would be:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 API 包括：
- en: '`<thread>`, `<mutex>` - from C++11 onwards'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<thread>`, `<mutex>` - 从 C++11 开始'
- en: POSIX threads, or pthreads. Exposed by POSIX systems such as Linux and most
    other Unix derivatives, e.g. OS X. There is also pthread-win32 support built over
    the top of Win32 threads.
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 线程，或者 pthreads。由类似 Linux 和大多数其他 Unix 派生系统（例如 OS X）的 POSIX 系统提供支持。还有在 Win32
    线程之上构建的 pthread-win32 支持。
- en: Win32 threads. Exposed by the Windows operating system.
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Win32 线程。由 Windows 操作系统提供支持。
- en: OpenMP. Supported by many C++ compilers.
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenMP。许多 C++ 编译器支持。
- en: 3rd party libraries like Boost and Qt provide wrappers that abstract the differences
    between thread APIs.
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方库如 Boost 和 Qt 提供了封装，抽象了线程 API 之间的差异。
- en: 'All APIs will have in common:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 API 都有共同点：
- en: Thread creation, destruction, joins (waiting on threads) and detaches (freeing
    the thread to do what it likes).
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的创建、销毁、加入（等待线程）和分离（释放线程以自由执行其操作）。
- en: Synchronization between threads using locks and barriers.
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁和屏障在线程之间进行同步。
- en: Mutexes - mutual exclusion locks that protect shared data.
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁 - 保护共享数据的互斥锁。
- en: Conditional variables - a means to signal and notify of conditions becoming
    true.
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件变量 - 一种信号和通知条件变为真的方法。
- en: std::thread
  id: totrans-992
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::thread
- en: The `std::thread` represents a single thread of execution and provides an abstraction
    over platform dependent ways of threading.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::thread` 代表一个执行线程，并提供了一个在各种平台上处理线程的抽象方式。'
- en: '[PRE198]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The example spawns a thread which invokes the function and passes the parameter
    into it, printing a message 100 times.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例生成一个线程，调用该函数并将参数传递给它，打印一条消息 100 次。
- en: std::mutex
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::mutex
- en: C++ provides a family of various `mutex` types to protect access to shared data.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了一系列不同的 `mutex` 类型来保护对共享数据的访问。
- en: The mutex is obtained by a `lock_guard` and other attempts to obtain the mutex
    are blocked until the lock is relinquished.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁由 `lock_guard` 获取，并且其他尝试获取互斥锁的尝试将被阻塞，直到锁被释放。
- en: '[PRE199]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: POSIX threads
  id: totrans-1000
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POSIX 线程
- en: 'The pthreads API is prefixed `pthread_` and works like so:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: pthreads API 以`pthread_`为前缀，并且工作原理如下：
- en: '[PRE200]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: This example spawns a thread which invokes DoWork with the payload of 100 which
    causes the function to print a message 100 times.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例生成一个线程，调用带有 100 载荷的 DoWork，导致函数打印消息 100 次。
- en: Win32 Threads
  id: totrans-1004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Win32 线程
- en: Win32 threading has functions analogous to those in POSIX. They have names such
    as `CreateThread`, `ExitThread`, `SetThreadPriority` etc.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 线程具有类似于 POSIX 的函数。它们的名称如`CreateThread`、`ExitThread`、`SetThreadPriority`等。
- en: OpenMP API
  id: totrans-1006
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenMP API
- en: Open Multi-Processing (OpenMP) is an API for multi-threaded parallel processing.
    OpenMP relies on compiler support because you use special `#pragma` directives
    in your source to control thread creation and access to data.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: Open Multi-Processing（OpenMP）是用于多线程并行处理的 API。OpenMP 依赖于编译器支持，因为你在源代码中使用特殊的`#pragma`指令来控制线程创建和对数据的访问。
- en: GCC, Clang and Visual C++ have support for OpenMP so it is an option.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: GCC、Clang 和 Visual C++ 都支持 OpenMP，所以这是一个选择。
- en: OpenMP is a complex standard but the use of directives can make for cleaner
    code than invoking threading APIs directly. The downside is it is also more opaque
    hiding what the software is doing, making it considerably more difficult to debug.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 是一个复杂的标准，但使用指令可以使代码比直接调用线程 API 更清晰。缺点是它也更加不透明，隐藏了软件正在做的事情，使得调试变得相当困难。
- en: OpenMP is described in detail at the OpenMP [website](http://www.openmp.org/).
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMP 在 OpenMP [网站](http://www.openmp.org/)上有详细描述。
- en: Thread local storage
  id: totrans-1011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程局部存储
- en: Thread local storage, or TLS is static or global data which is private to every
    thread. Each thread holds its own copy of this data so it can modify it without
    fear of causing a data race.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部存储，或 TLS 是静态或全局数据，对于每个线程都是私有的。每个线程都持有自己的数据副本，因此可以修改它而不必担心造成数据竞争。
- en: 'Compilers also have proprietary ways to decorate types as thread local:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还有专有的方法来将类型标记为线程本地：
- en: '[PRE201]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: C++11 has gained a `thread_local` directive to decorate variables which should
    use TLS.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 引入了`thread_local`指令，用于修饰应使用 TLS 的变量。
- en: '[PRE202]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Rust
  id: totrans-1017
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: We saw with C++ that you had to be disciplined to remember to protect data from
    race conditions.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 C++ 中看到，你必须严格遵守保护数据免受竞态条件的规定。
- en: Rust doesn't give you that luxury -
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不会给你那样的奢侈 -
- en: Any data that you share must be protected in a thread safe fashion
  id: totrans-1020
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你共享的任何数据都必须以线程安全的方式保护。
- en: Any data that you pass between threads must be marked thread safe
  id: totrans-1021
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在线程之间传递的任何数据都必须标记为线程安全。
- en: Spawning a thread
  id: totrans-1022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个线程
- en: Spawning a thread is easy enough by calling `spawn`, supplying the closure you
    want to run in the context of your new thread.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`spawn`并提供你想在新线程中运行的闭包，轻松创建一个线程。
- en: '[PRE203]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Alternatively you can supply a function to `spawn` which is called in the same
    manner.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以提供一个函数给`spawn`，以相同的方式调用它。
- en: '[PRE204]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: If you supply a closure then it must have a lifetime of `'static` because threads
    can outlive the thing that created them. i.e. they are detached by default.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供一个闭包，则必须具有`'static`的生命周期，因为线程可能会超出创建它的范围。即它们默认是分离的。
- en: A closure can make use of move values that are marked `Send` so the compiler
    allows ownership to transfer between threads.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以使用标记为`Send`的移动值，因此编译器允许所有权在线程之间转移。
- en: Likewise function / closure may also return a value which is marked `Send` so
    the compiler can transfer ownership between the terminating thread and the thread
    which calls `join` to obtain the value.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 同样函数/闭包也可以返回一个标记为`Send`的值，因此编译器可以在终止线程和调用`join`以获取值的线程之间转移所有权。
- en: So the thread above is detached. If we wanted to wait for the thread to complete,
    the `spawn` returns a `JoinHandle` that we can call `join` to wait for termination.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 所以上面的线程是分离的。如果我们想等待线程完成，`spawn`返回一个`JoinHandle`，我们可以调用`join`等待终止。
- en: '[PRE205]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: If the closure or function returns a value, we can use `join` to obtain it.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 如果闭包或函数返回一个值，我们可以使用`join`来获取它。
- en: '[PRE206]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Data race protection in the compiler
  id: totrans-1034
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器中的数据竞争保护
- en: Data races are bad news, but fortunately in Rust the compiler has your back.
    You MUST protect your shared data or it won't compile.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 数据竞争是坏消息，但幸运的是在 Rust 中编译器会支持你。你必须保护你的共享数据，否则它不会编译通过。
- en: The simplest way to protect your data is to wrap the data in a mutex and provide
    each thread instance with a reference counted copy of the mutex.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的数据最简单的方法是将数据包装在互斥锁中，并为每个线程实例提供一个引用计数的锁的副本。
- en: '[PRE207]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Here is a full example that spawns 10 threads that each increment the counter.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个完整的示例，生成 10 个线程，每个线程都增加计数器。
- en: '[PRE208]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'So the basic strategy will be this:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本策略将是这样的：
- en: Every thread will get it's own atomic reference to the mutex.
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个线程将获得自己的互斥锁的原子引用。
- en: Each thread that wishes to access the shared must obtain a lock on the mutex.
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个希望访问共享数据的线程都必须在互斥锁上获取锁。
- en: Once the lock is released, the next waiting thread can obtain access.
  id: totrans-1043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦锁被释放，下一个等待的线程就可以获得访问权限。
- en: The compiler will enforce this and generate errors if ANYTHING is wrong.
  id: totrans-1044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有任何问题，编译器将强制执行并生成错误。
- en: Read Write Lock
  id: totrans-1045
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读写锁
- en: A read write lock works much like a mutex - we wrap the shared data in a `RwLock`,
    and then in an `Arc`.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 读写锁的工作方式与互斥锁类似-我们将共享数据包装在`RwLock`中，然后在`Arc`中包装。
- en: '[PRE209]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Each thread will then either need to obtain a read lock or a write lock on the
    shared data.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 然后每个线程都需要在共享数据上获取读锁或写锁。
- en: '[PRE210]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The advantage of a `RwLock` is that many threads can concurrently read the data,
    providing nothing is writing to it. This may be more efficient in many cases.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '`RwLock`的优势在于许多线程可以同时读取数据，只要没有线程在写入数据。在许多情况下，这可能更有效率。'
- en: Sending data between threads using channels
  id: totrans-1051
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通道在线程之间发送数据
- en: TODO mpsc channel
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: TODO mpsc通道
- en: Thread local storage
  id: totrans-1053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程本地存储
- en: As with C++ you may have reason to use thread local storage
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++一样，您可能有理由使用线程本地存储
- en: '[PRE211]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Useful crates
  id: totrans-1056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用的crate
- en: Rayon
  id: totrans-1057
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Rayon
- en: The [rayon](https://github.com/rayon-rs/rayon) crate implements parallel iterators
    that allow your collections to be iterated in parallel. The crate utilises work
    stealing and divide and conquer algorithms couple to a thread pool to process
    collections more quickly than they could be in a sequential fashion.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '[rayon](https://github.com/rayon-rs/rayon) crate实现了并行迭代器，允许您的集合并行迭代。该crate利用工作窃取和分治算法与线程池结合，以比顺序方式更快地处理集合。'
- en: Generally speaking this is a drop-in replacement with the exception that you
    call `par_iter` instead of `iter`. The crate implements a `ParallelIterator` trait
    on collection classes.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这是一个可替换的方案，唯一的例外是您调用`par_iter`而不是`iter`。该crate在集合类上实现了`ParallelIterator`
    trait。
- en: '[PRE212]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: See the crate site for more information.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 查看crate网站获取更多信息。
- en: Lint
  id: totrans-1062
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查
- en: Lint
  id: totrans-1063
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查
- en: C/C++ compilers can issue many useful warnings but the amount of static analysis
    they can do is usually quite limited.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++编译器可以发出许多有用的警告，但它们可以进行的静态分析通常相当有限。
- en: The Rust compiler performs a far more rigorous lifecycle check on data and then
    follows up with a lint check that inspects your code for potentially bad or erroneous
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: Rust编译器对数据执行更严格的生命周期检查，然后进行代码检查，检查您的代码是否存在潜在的错误或错误
- en: 'In particular it looks for:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是它寻找：
- en: Dead / unused code
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效/未使用的代码
- en: Unreachable code
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可达代码
- en: Deprecated methods
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的方法
- en: Undocumented functions
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未记录的函数
- en: Camel case / snake case violations
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驼峰命名法/蛇形命名法违规
- en: Unbounded recursion code (i.e. no conditionals to stop recursion)
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限递归代码（即没有条件停止递归）
- en: Use of heap memory when stack could be used
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可以使用堆栈的情况下使用堆内存
- en: Unused extern crates, imports, variables, attributes, mut, parentheses
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的外部crate、导入、变量、属性、mut、括号
- en: Using "while true {}" instead of "loop {}"
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用"while true {}"而不是"loop {}"
- en: 'Lint rules can be enforced more strictly or ignored by using attributes:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用属性可以更严格地执行或忽略代码检查规则：
- en: '[PRE213]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'A full list of lint rules can be found by typing "rustc -W help":'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 可以��过键入"rustc -W help"找到lint规则的完整列表：
- en: '[PRE214]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: There are a lot checks than are listed here.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了许多检查。
- en: Macros
  id: totrans-1081
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: Macros
  id: totrans-1082
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: C / C++ Preprocessor
  id: totrans-1083
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C/C++预处理器
- en: 'C languages are little unusual in that they are compiled in two phases. The
    first phase is called the preprocess. In this phase, the preprocessor looks for
    directives starting with a # symbol and runs string substitution and conditional
    inclusion / exclusion based on those directives. Only after the file has been
    preprocessed does the compiler attempt to compile it.'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: C语言在编译时有点不同寻常。第一阶段称为预处理。在此阶段，预处理器查找以#符号开头的指令，并根据这些指令进行字符串替换和条件包含/排除。只有在文件经过预处理后，编译器才尝试编译它。
- en: 'Preprocessor directives start with a `#` symbol. For example the `#define`
    directive creates a macro with an optional value:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理指令以`#`符号开头。例如，`#define`指令创建一个带有可选值的宏：
- en: '[PRE215]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: We'll explore macros more in a moment. Another directive is the `#if\#else\#endif`
    or `#ifdef\#else\#endif` which can be used to include code from one branch or
    the other of a test according to what matches.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后更深入地探讨宏。另一个指令是`#if\#else\#endif`或`#ifdef\#else\#endif`，根据匹配情况从测试的一个分支或另一个分支包含代码。
- en: '[PRE216]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Another directive is `#include`. In C and C++, public functions and structures
    are typically defined and implemented in separate files. The `#include` directive
    allows a header to be pulled in to the front of any file that makes use of those
    definitions.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个指令是 `#include`。在 C 和 C++ 中，公共函数和结构通常在不同的文件中定义和实现。`#include` 指令允许将头文件拉入到使用这些定义的任何文件的前面。
- en: '[PRE217]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The important thing to remember in all of this is ALL of these things happen
    before the compiler even starts! Your `main.c` might only be 10 lines of code
    but if you `#include` some headers the preprocessor may be feeding many thousands
    of lines of types, functions into the compiler, all of which are evaluated before
    they get to your code.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下需要记住的重要事情是，这些事情都发生在编译器甚至开始之前！你的 `main.c` 可能只有 10 行代码，但如果你 `#include`
    了一些头文件，预处理器可能会将成千上万行的类型、函数馈送到编译器中，在它们到达你的代码之前都会被评估。
- en: C / C++ Macros
  id: totrans-1092
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C / C++ 宏
- en: Macros are string substitution patterns performed by the preprocessor before
    the source is compiled. As such they can be very prone to error and so have been
    deprecated in favour of constants and inline functions.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是在源代码编译之前由预处理器执行的字符串替换模式。因此，它们很容易出错，因此已被废弃，而常量和内联函数更受青睐。
- en: 'Here is a simple macro that would behave in an unexpected manner:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的宏，行为可能出乎意料：
- en: '[PRE218]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: The macro is very simple - multiply x by y. But it fails if either argument
    is an expression. Judicious use of parentheses might avoid the error in this case,
    but we could break it again using some pre or post increments.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏非常简单 - 将 x 乘以 y。但如果任一参数是表达式，则会失败。在这种情况下，合理使用括号可能会避免错误，但我们仍然可以通过一些预增量或后增量再次打破它。
- en: Macros in C++ are also unhygenic, i.e. the macro can inadvertently conflict
    with or capture values from outside of itself causing errors in the code.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的宏也是不卫生的，即宏可能会无意间与或捕获到外部值发生冲突，导致代码错误。
- en: '[PRE219]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Here our SWAP macro uses a temporary value called `tmp` that already existed
    in the scope and so the compiler complains. A macro might avoid this by using
    shadow variables enclosed within a `do / while(0)` block to avoid conflicts but
    it is less than ideal.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们的 SWAP 宏使用了一个名为 `tmp` 的临时值，这个值已经存在于作用域中，所以编译器会报错。宏可以通过使用在 `do / while(0)`
    块内的影子变量来避免冲突，但这并不理想。
- en: '[PRE220]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Consequently inline functions are used wherever possible. Even so macros are
    still frequently used in these roles:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽可能使用内联函数。即便如此，宏在这些角色中仍然经常被使用：
- en: To conditionally include for a command-line flag or directive, e.g. the compiler
    might `#define WIN32` so code can conditionally compile one way or another according
    to its presence.
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于根据命令行标志或指令进行条件包含，例如编译器可能会 `#define WIN32`，以便根据其是否存在来有条件地进行编译。
- en: 'For adding guard blocks around headers to prevent them being #include''d more
    than once. Most compilers implement a "#pragma once directive" which is an increasingly
    common alternative'
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '用于在头部周围添加守卫块，以防止它们被 #include 多次。大多数编译器实现了一个“#pragma once 指令”，这是一个越来越常见的替代方案。'
- en: 'For generating snippets of boiler plate code (e.g. namespace wrappers), or
    things that might be compiled away depending on #defines like DEBUG being set
    or not.'
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '用于生成一些样板代码片段（例如命名空间包装器）或者根据 #define（例如是否设置了 DEBUG）等情况可能会被编译删除的东西。'
- en: For making strings of values and other esoteric edge cases
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于生成值字符串和其他奇特边缘情况
- en: 'Writing a macro is easy, perhaps too easy:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 编写宏很容易，也许太容易了：
- en: '[PRE221]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: This macro would expand to printf before compilation but it would fail to compile
    or print the wrong thing if x were not an integer.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏在编译前会展开为 printf，但如果 x 不是整数，则编译失败或打印错误的内容。
- en: Rust macros
  id: totrans-1109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 宏
- en: Macros in Rust are quite a complex topic but they are more powerful and safer
    than the ones in C++.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的宏是一个相当复杂的话题，但它们比 C++ 中的更强大、更安全。
- en: Rust macros are hygenic. That is to say if a macro contains variables, their
    names do not conflict with, hide, or otherwise interfere with named variables
    from the scope they're used from.
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 的宏是卫生的。也就是说，如果一个宏包含变量，它们的名称不会与所在作用域中的命名变量发生冲突、隐藏或以其他方式干扰。
- en: 'The pattern supplied in between the brackets of the macro are tokenized and
    designated as parts of the Rust language. identifiers, expressions etc. In C /
    C++ you can #define a macro to be anything you like whether it is garbage or syntactically
    correct. Furthermore you can call it from anywhere you like because it is preprocessed
    even before the compiler sees the code.'
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在宏的方括号之间提供的模式被标记为 Rust 语言的一部分并进行标记化。标识符，表达式等。在 C / C++ 中，你可以将一个宏 #define 为任何你喜欢的东西，无论它是垃圾还是符合语法规范。此外，你可以从任何地方调用它，因为它在编译器看到代码之前就被预处理了。'
- en: Rust macros are either declarative and rule based with each rule having a left
    hand side pattern "matcher" and a right hand side "substitution". Or they're procedural
    and actualy rust code turns an input into an output (see section below).
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 宏要么是声明性的和基于规则的，每个规则都有一个左手边模式 "匹配器" 和一个右手边 "替换"。要么它们是过程性的，实际的 rust 代码将一个输入转换成一个输出（见下面的部分）。
- en: Macros must produce syntactically correct code.
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏必须生成符合语法规范的代码。
- en: 'Declarative macros can be exported by crates and used in other code providing
    the other code elects to enable macro support from the crate. This is a little
    messy since it must be signalled with a #[macro_export] directive.'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '声明性宏可以由 crate 导出，并在其他代码中使用，前提是其他代码选择启用 crate 的宏支持。这有点混乱，因为它必须用 #[macro_export]
    指令来标志。'
- en: With all that said, macros in Rust *are* complex - perhaps too complex - and
    generally speaking should be used as sparingly as possible.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，Rust 中的宏 *确实* 很复杂 - 也许太复杂了 - 一般来说应该尽可能地少用。
- en: Here is a simple declarative macro demonstrating repetition called hello_x!().
    It will take a comma separated list of expressions and say hello to each one of
    them.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的声明性宏，演示了重复称为 hello_x!()。它将接受逗号分隔的表达式列表，并对其中的每个表达式都说 hello。
- en: '[PRE222]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Essentially the matcher matches against our comma separate list and the substitution
    generates one println!() with the message for each expression.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，匹配器针对我们的逗号分隔列表进行匹配，替换生成一个包含每个表达式消息的 println!()。
- en: '[PRE223]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: What if we threw some other expressions into that array?
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在数组中加入一些其他表达式会怎样呢？
- en: '[PRE224]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Well that works too:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这也可以：
- en: '[PRE225]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'What about some illegal code:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 有些非法代码怎么样：
- en: '[PRE226]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: We get a meaningful error originating from the macro.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从宏中得到一个有意义的错误。
- en: '[PRE227]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Real world example - vec!()
  id: totrans-1129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实世界的例子 - vec!()
- en: Rust comes with a lot of macros for reducing some of the leg work of tedious
    boiler plate. For example the vec!() macro is a way to declare a std::Vec and
    prepopulate it with some values.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 自带了很多宏，用于减少一些繁琐模板的工作。例如，vec!() 宏是声明一个 std::Vec 并预先填充一些值的方法。
- en: 'Here is the actual vec! macro source code taken from the Rust source:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 Rust 源代码中提取的 vec! 宏的实际源代码：
- en: '[PRE228]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'It looks complex but we will break it down to see what it does. Firstly it
    has a match-like syntax with three branches that expand to anything that matches
    the left hand side:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很复杂，但我们将拆解它以了解它的作用。首先，它具有与 match 相似的语法，有三个展开到与左手边匹配的任何内容的分支：
- en: First branch
  id: totrans-1134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一个分支
- en: 'The first matcher matches a pattern such as `1; 100`. The value `1` goes into
    `$elem`, the value `100` goes into `$n`:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个匹配器匹配一个模式，比如 `1; 100`。值 `1` 进入 `$elem`，值 `100` 进入 `$n`：
- en: '[PRE229]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The `$crate` is a special value that resolves to the module crate which happens
    to be std.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '`$crate` 是一个特殊值，解析为模块 crate，恰好是 std。'
- en: 'So this expands to this:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就扩展成了这样：
- en: '[PRE230]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Second branch
  id: totrans-1140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二个分支
- en: 'The second matcher contains a glob expression - zero or more expressions separated
    by comma (the last comma is optional). Each matching expression ends up in `$x`:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个匹配器包含一个全局表达式 - 用逗号分隔的零个或多个表达式（最后一个逗号是可选的）。每个匹配的表达式都会进入 `$x`：
- en: '[PRE231]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'So we can write:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以写：
- en: '[PRE232]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'The box keyword tells Rust to allocate the supplied array on the heap and moves
    the ownership by calling a helper function called into*vec() that wraps the memory
    array with a Vec instance. The <[\*]>:: at the front is a turbo-fish notation
    to make the into_vec() generic function happy.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 'box 关键字告诉 Rust 在堆上分配提供的数组，并通过调用一个名为 into*vec() 的辅助函数转移所有权，该函数使用一个 Vec 实例包装内存数组。前面的
    <[\*]>:: 是一种 turbo-fish 符号，让 into_vec() 泛型函数快乐地工作。'
- en: Third branch
  id: totrans-1146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三个分支
- en: The third branch is a little odd and almost looks the same as the second branch.
    But take at look the comma. In the last branch it was next to the asterisk, this
    time it is inside the inner $().
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个分支有点奇怪，几乎和第二个分支看起来一样。但是看看逗号。在上一个分支中，逗号在星号旁边，这次它在内部 $() 中。
- en: '[PRE233]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'The matcher matches when the the comma is there and if so recursively calls
    vec!() again to resolve to the second branch matcher:'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 当逗号存在时，匹配器匹配，如果是这样，则递归调用 vec!() 再次解析到第二个分支匹配器：
- en: Basically it is there so that there can be a trailing comma in our declaration
    and it will still generate the same code.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这样做是为了我们的声明中可以有一个尾随逗号，而它仍然会生成相同的代码。
- en: '[PRE234]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Procedural Macros
  id: totrans-1152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程宏
- en: So far we've talked about declarative macros that expand out to be Rust code
    based upon how they pattern match the rules defined by the macro.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了展开为 Rust 代码的声明性宏，这是基于宏定义的规则进行模式匹配的。
- en: A second kind of macro is the *procedural macro*. A procedural macro is a plugin
    written in Rust that is compiled and loaded by the compiler to produce arbitrary
    Rust code as its output.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种宏是*过程宏*。过程宏是用 Rust 编写的插件，由编译器编译和加载，以生成任意的 Rust 代码���为其输出。
- en: 'A procedural macro can therefore be thought of as a code generator but one
    that forms part of the actual compiler. Procedural macros can be particularly
    useful for:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，过程宏可以被视为一个代码生成器，但它是实际编译器的一部分。过程宏特别适用于：
- en: Serialization / deserialization (e.g. the [serde](https://github.com/serde-rs/serde)
    module generates code for reading and writing structs to a variety of formats
    - JSON, YAML, TOML, XML etc.)
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化 / 反序列化（例如，[serde](https://github.com/serde-rs/serde) 模块生成用于将结构体读写到各种格式 -
    JSON、YAML、TOML、XML 等的代码。）
- en: Domain Specific Languages (e.g. embedded SQL, regular expressions etc).
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域特定语言（例如嵌入式 SQL，正则表达式等）。
- en: Aspect oriented programming (e.g. extra debugging, performance metrics etc)
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向方面的编程（例如额外的调试、性能指标等）
- en: New lint and derive rules
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 lint 和 derive 规则
- en: For more information look at this section on [compiler plugins](https://doc.rust-lang.org/book/compiler-plugins.html)
    in the Rust book.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请查看 Rust 书中关于[编译器插件](https://doc.rust-lang.org/book/compiler-plugins.html)的部分。
- en: Other forms of conditional compilation
  id: totrans-1161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他形式的条件编译
- en: We saw that the C / C++ preprocessor can be used for conditional compilation.
    The equivalent in Rust is attributes. See the attributes section to see how they
    may be used.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 C / C++ 预处理器可用于条件编译。在 Rust 中的等价物是属性。查看属性部分以了解它们的用法。
- en: Memory Allocation
  id: totrans-1163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配
- en: Memory allocation
  id: totrans-1164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配
- en: This section is concerned with memory allocation, i.e. creating objects that
    reside on the heap and not on the stack, and the manner in which they are created
    and are destroyed.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涉及内存分配，即在堆上创建对象而不是在栈上创建对象，以及它们的创建和销毁方式。
- en: C++
  id: totrans-1166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++
- en: 'C and C++ have various standard ways to allocate memory:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 有各种标准的内存分配方式：
- en: '`malloc`/`calloc`/`realloc()` and `free()` functions'
  id: totrans-1168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`malloc`/`calloc`/`realloc()` 和 `free()` 函数'
- en: '`new` and `delete` (C++ only)'
  id: totrans-1169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new` 和 `delete`（仅限 C++）'
- en: '`new[]` and `delete[]` for arrays (C++ only)'
  id: totrans-1170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new[]` 和 `delete[]` 用于数组（仅限 C++）'
- en: Invoking `malloc()`/`free()` on a C++ class or struct is never a good idea since
    it will not call the corresponding class constructor or destructor. The `realloc()`
    function allocates a new piece of memory, copying the contents of an existing
    piece of memory before freeing the original.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 类或结构体上调用 `malloc()`/`free()` 绝不是一个好主意，因为它不会调用相应的类构造函数或析构函数。`realloc()`
    函数分配一个新的内存块，在释放原始内存之前复制现有内存块的内容。
- en: '[PRE235]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'In each case the allocation must be matched by the corresponding free action
    so immediately we can see scope for error here:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，分配必须与相应的释放操作匹配，因此我们立即可以看到这里存在错误的可能性：
- en: Ownership rules can get messy, especially when a class is passed around a lot
    - who deletes the object and when?
  id: totrans-1174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有权规则可能会变得混乱，特别是当一个类被频繁传递时 - 谁删除对象以及何时删除？
- en: Not using the correct `new` & `delete` pair, causing a memory leak. e.g. calling
    `delete` instead of `delete[]`
  id: totrans-1175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不使用正确的 `new` 和 `delete` 对，导致内存泄漏。例如，调用 `delete` 而不是 `delete[]`
- en: Forgetting to free memory at all causing a memory leak.
  id: totrans-1176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忘记释放内存导致内存泄漏。
- en: Freeing memory more than once.
  id: totrans-1177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次释放内存。
- en: Calling a dangling pointer, i.e. a pointer which refers to freed memory.
  id: totrans-1178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用悬空指针，即指向已释放内存的指针。
- en: Allocating / freeing in a way that causes heap fragmentation. Reallocation can
    cause fragmentation to happen a lot faster.
  id: totrans-1179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配 / 释放方式导致堆碎片化。重新分配可能会导致碎片化发生得更快。
- en: 'C++ has smart pointers which manage the lifetime on objects and are a good
    way to programmer error:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 有智能指针，可以管理对象的生命周期，是一种避免程序员错误的好方法：
- en: '[PRE236]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Unfortunately it is not always possible to use smart pointers but wherever possible
    they should be used.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，智能指针并非总是可用，但在任何可能的地方都应该使用它们。
- en: Other ways of allocating memory
  id: totrans-1183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配内存的其他方式
- en: Virtually every C and C++ library has solutions for managing memory. They all
    their own indivual concept of ownership which is usually different from one to
    the next. Boost and Qt have their own memory management "smart" pointers. Qt even
    requires certain objects to be deleted "later" by a message processing loop on
    the thread that created the object. Some libraries even adopt a COM-like model
    of reference counting objects with smart pointers. Most C libraries will expose
    an alloc and free function for creating and destroying context objects that callers
    pass to the API.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个C和C++库都有管理内存的解决方案。它们都有自己独特的所有权概念，通常各不相同。Boost和Qt有它们自己的内存管理“智能”指针。Qt甚至要求某些对象由创建对象的线程上的消息处理循环“稍后”删除。一些库甚至采用类似COM的引用计数对象与智能指针的模型。大多数C库将公开一个alloc和free函数，用于创建和销毁调用者传递给API的上下文对象。
- en: Memory allocation can even be overwritten and replaced in some circumstances.
    In C, the standard malloc / free can be substituted for another memory allocator,
    e.g. TCMalloc [TCMalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html).
    Or perhaps the code wants to use garbage collected memory in which case [Bohem
    GC](http://www.hboehm.info/gc/) is a popular library for that purpose. Boehm can
    also be used for leak detection since it can find objects which were never released.
    C++ can also [override](http://en.cppreference.com/w/cpp/memory/new/operator_new)
    the global or class specific new / delete operators. Some standard C++ template
    classes also allow memory allocation to be overridden.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，内存分配甚至可以被覆盖和替换。在C中，标准的malloc / free可以被替换为另一个内存分配器，例如TCMalloc [TCMalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)。或者代码可能希望使用垃圾收集内存，在这种情况下[Bohem
    GC](http://www.hboehm.info/gc/)是一个常用的库。Boehm还可以用于泄漏检测，因为它可以找到从未释放的对象。C++还可以[覆盖](http://en.cppreference.com/w/cpp/memory/new/operator_new)全局或类特定的new
    / delete运算符。一些标准C++模板类也允许覆盖内存分配。
- en: Rust
  id: totrans-1186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: As you can guess by now Rust tends to be a lot more strict about allocation
    that C/C++. Lifetimes of objects are tracked and enforced by the compiler and
    that includes memory allocated objects.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能猜到的，Rust在分配方面比C/C++要严格得多。对象的生命周期由编译器跟踪和强制执行，其中包括内存分配的对象。
- en: In normal safe programming there is no explicit new / delete so there is no
    way to forget to free an object. There are no pointers either so code cannot call
    a dangling pointer or inadvertently call a null pointer.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的安全编程中，没有显式的new / delete，因此没有忘记释放对象的方法。也没有指针，因此代码不能调用悬空指针或无意中���用空指针。
- en: A `Box` is a managed pointer that holds a heap allocated object. A box cannot
    be cloned, so there is only one owner at any time.
  id: totrans-1189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`Box`是一个持有堆分配对象的托管指针。Box 不能被克隆，因此任何时候只有一个所有者。
- en: A `Cell` is a mutable memory location - it can hold any kind of copyable type
    and the value within it can be changed.
  id: totrans-1190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`Cell`是一个可变的内存位置 - 它可以保存任何可复制的类型，并且其中的值可以被更改。
- en: A `RefCell` is a mutable memory location that can hold a reference
  id: totrans-1191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`RefCell`是一个可变的内存位置，可以保存一个引用。
- en: The advantage for programmers, is that once you define the lifetime of an object
    properly it just comes into existence and goes away correctly. In many cases this
    lifetime management comes with zero runtime cost, or if there is a cost it is
    no more than the same code correctly written in C/C++.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，一旦正确定义了对象的生命周期，它就会正确地存在和消失。在许多情况下，这种生命周期管理几乎没有运行时成本，或者如果有成本，那也不会超过正确编写的相同代码在C/C++中的成本。
- en: Rust requires most heap allocated memory to be contained by one or more of the
    structs below. The struct manages the lifetime and access to the object inside
    ensuring the lifetime is managed correctly.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: Rust要求大多数堆分配的内存由下面的一个或多个结构体包含。结构体管理对象内部的生命周期和访问，确保生命周期被正确管理。
- en: Box
  id: totrans-1194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Box
- en: A `Box` is memory managed on the heap.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Box`在堆上进行内存管理。
- en: '[PRE237]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Whoever owns the box can access it. Essentially, that means you can pass the
    box around from one place to another and whatever binds to it last can open it.
    Everyone else’s binding becomes invalid and will generate a compile error.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有Box的人可以访问它。基本上，这意味着你可以把Box从一个地方传递到另一个地方，最后绑定到它的任何东西都可以打开它。其他所有人的绑定将变得无效，并将生成编译错误。
- en: A box can be useful for abstraction since it can refer to a struct by a trait
    it implements allowing decoupling between types.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: Box可以用于抽象，因为它可以通过实现的trait引用一个结构体，允许类型之间解耦。
- en: TODO example of a struct holding a box with a trait implemented by another struct
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: TODO示例，一个结构体持有一个通过另一个结构体实现的trait的Box
- en: It can be useful for situations where one piece of code creates an object on
    behalf of another piece of code and hands it over. The Box makes sure that the
    ownership is explicit at all times and when the box moves to its new owner, so
    does the lifetime of the object itself.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用于一段代码代表另一段代码创建对象并移交的情况。Box始终确保所有权是显式的，当Box移动到新所有者时，对象本身的生命周期也会移动。
- en: Cell
  id: totrans-1201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cell
- en: A `Cell` is something that can copied with a `get()` or `set()` to overwrite
    its own copy. As the contents must be copyable they must implement the Copy trait.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Cell`是可以通过`get()`或`set()`进行复制以覆盖自身副本的东西。由于内容必须是可复制的，它们必须实现Copy trait。
- en: The `Cell` has a zero-cost at runtime because it doesn’t have to track borrows
    but the restriction is it only works on Copy types. Therefore it would not be
    suitable for large objects or deep-copy objects.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell`在运行时没有额外开销，因为它不必跟踪借用，但限制是它只适用于Copy类型。因此，它不适用于大对象或深拷贝对象。'
- en: RefCell
  id: totrans-1204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RefCell
- en: Somewhat more useful is the `RefCell<T>` but it incurs a runtime penalty to
    maintain read-write locks.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微更有用的是`RefCell<T>`，但它会产生运行时开销以维护读写锁。
- en: The `RefCell` holds a reference to an object that can be borrowed either mutably
    or immutably. These references are read-write locked so there is a runtime cost
    to this since the borrow must check if something else has already borrowed the
    reference.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '`RefCell`持有一个对象的引用，可以被可变借用或不可变借用。这些引用是读写锁定的，因此这会带来运行时开销，因为借用必须检查是否有其他东西已经借用了引用。'
- en: Typically a piece of code might borrow the reference for a scope and then the
    borrow disappears when it goes out of scope. If a borrow happens before the last
    borrow releases, it will cause a panic.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 通常一段代码可能会在作用域内借用引用，当作用域结束时，借用会消失。如果一个借用发生在最后一个借用释放之前，它会导致恐慌。
- en: Reference Counting objects
  id: totrans-1208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用计数对象
- en: Rust implements `Rc<>` and `Arc<>` for the purpose of reference counting objects
    that need to be shared and used by different parts of code. Rc<> is a single threaded
    reference counted wrapper, while `Arc<>` is atomic reference counted wrapper.
    You use one or the other depending on whether threads are sharing the object.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: Rust实现了`Rc<>`和`Arc<>`用于引用计数需要被代码不同部分共享和使用的对象。Rc<>是单线程引用计数包装器，而`Arc<>`是原子引用计数包装器。你根据线程是否共享对象来使用其中之一。
- en: A reference counted object is usually wrapping a `Box`, `Cell` or `Refcell`.
    So multiple structs can hold a reference to the same object.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个引用计数对象通常包装着一个`Box`、`Cell`或`Refcell`。因此，多个结构体可以持有对同一对象的引用。
- en: Rc
  id: totrans-1211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rc
- en: From `std::rc::Rc`. A reference counted object can be held by multiple owners
    at a time. Each own holds a cloned `Rc<T>` but the T contents are shared. The
    last reference to the object causes the contents to be destroyed.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`std::rc::Rc`。一个引用计数对象可以同时被多个所有者持有。每个所有者持有一个克隆的`Rc<T>`，但T内容是共享的。对对象的最后一个引用会导致内容被销毁。
- en: Arc
  id: totrans-1213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arc
- en: From `std::sync::Arc`. An atomic reference counted object that works like `Rc<T>`
    except it uses an atomically incremented counter which makes it thread safe. There
    is more overhead to maintain an atomic reference count. If multiple threads access
    the same object they are compelled to use `Arc<T>`
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`std::sync::Arc`。一个原子引用计数对象，工作方式类似于`Rc<T>`，只是它使用原子递增的计数器，使其线程安全。维护原子引用计数需要更多开销。如果多个线程访问同一对象，它们被迫使用`Arc<T>`
- en: Foreign Function Interface
  id: totrans-1215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部函数接口
- en: Foreign Function Interface
  id: totrans-1216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部函数接口
- en: Rust doesn't work in a vaccum and was never intended as such. Instead it was
    always assumed that it would need to call other code and other code would need
    to call it,
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: Rust并不是独立存在的，也从未打算如此。相反，它总是假定需要调用其他代码，其他代码也需要调用它，
- en: Call other libraries via their entry points
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过它们的入口点调用其他库
- en: Produce libraries in Rust that can be called by code written in another language.
    e.g. C, C++, Python, Ruby etc.
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust中生成可以被另一种语言编写的代码调用的库。例如C、C++、Python、Ruby等。
- en: To that end it has the Foreign Function Interface, the means to define external
    functions, expose its own functions without name mangling and to invoke unsafe
    code that would otherwise be illegal in Rust.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，它具有外部函数接口，可以定义外部函数、暴露自己的函数而不进行名称混淆，并调用否则在 Rust 中将是非法的不安全代码。
- en: Calling out to C libraries
  id: totrans-1221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用 C 库
- en: Rust supports the concept of a foreign function interface which is a definition
    of an external function or type that is resolved at link time.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 支持外部函数接口的概念，这是在链接时解析的外部函数或类型的定义。
- en: For example, we might wish to link to a library called foo.lib, and invoke a
    command foo_command().
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望链接到一个名为 foo.lib 的库，并调用一个命令 foo_command()。
- en: '[PRE238]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'To call this function we have to turn off safety checks first because we are
    stepping out of the bounds of Rust''s lifetime enforcement. To do this we wrap
    the call in an unsafe block to disable the safety checks:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这个函数，我们必须首先关闭安全检查，因为我们要违反 Rust 生命周期执行的界限。为此，我们将调用包装在一个不安全的块中，以禁用安全检查：
- en: '[PRE239]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Note how we can use unsafe features like pointers inside of this unsafe block.
    This allows interaction with the outside world while still enforcing safety for
    the rest of our code.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在这个不安全块中使用不安全特性，这允许与外界进行交互，同时仍然对我们代码的其余部分进行安全性强制执行。
- en: Making Rust code callable
  id: totrans-1228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使 Rust 代码可调用
- en: The converse is also possible. We can produce a library from Rust that can be
    invoked by some other code.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 反之亦然，我们可以从 Rust 生成一个库，可以被其他代码调用。
- en: For example, imagine we have some code written in Python. The code works fine
    but it is not performant and the bottle neck is in just one portion of the code,
    e.g. some file operation like a checksum. We want our code to consist of a make_checksum()
    and a release_checksum().
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下我们有一些用 Python 编写的代码。代码运行良好，但性能不佳，而且代码的瓶颈只在其中的某一部分，比如某些文件操作，如校验和。我们希望我们的代码由一个
    make_checksum() 和一个 release_checksum() 组成。
- en: '[PRE240]'
  id: totrans-1231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Now in Python we can invoke the library simply:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 Python 中我们可以简单地调用该库：
- en: '[PRE241]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: The [FFI specification](https://doc.rust-lang.org/book/ffi.html) goes into a
    lot more detail than this and explains concepts such as callbacks, structure packing,
    stdcall, linking and other issues that allow full interoperability.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '[FFI 规范](https://doc.rust-lang.org/book/ffi.html) 比这更详细，并解释了诸如回调、结构体打包、stdcall、链接等问题，从而实现了完全的互操作性。'
- en: libc
  id: totrans-1235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: libc
- en: Rust maintains a crate called [libc](https://github.com/rust-lang/libc) which
    holds types and functions corresponding to C.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 维护着一个叫做 [libc](https://github.com/rust-lang/libc) 的 crate，其中包含与 C 对应的类型和函数。
- en: 'A dependency to libc would be added to the `Cargo.toml` of your project:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于 libc 的 `Cargo.toml` 将被添加到您的项目中：
- en: '[PRE242]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'And the file that uses the functions would contain a preamble such as this
    saying what types and functions it calls:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数的文件会包含如下的引言，说明调用了哪些类型和函数：
- en: '[PRE243]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Other libraries
  id: totrans-1241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他库
- en: There are also crates that have the definitions of structures, types and functions.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些包含结构、类型和函数定义的 crates。
- en: '[WinAPI](https://github.com/retep998/winapi-rs) bindings for Win32 programming
    APIs.'
  id: totrans-1243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[WinAPI](https://github.com/retep998/winapi-rs) 对 Win32 编程 API 的绑定'
- en: '[OpenSSL](https://github.com/sfackler/rust-openssl) bindings for OpenSSL'
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenSSL](https://github.com/sfackler/rust-openssl) 对 OpenSSL 的绑定'
