- en: How to HTTP with curl
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用 curl 进行 HTTP 请求
- en: How to HTTP with curl
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用 curl 进行 HTTP 请求
- en: In all user surveys and during all curl's lifetime, HTTP has been the most important
    and most frequently used protocol that curl supports. This chapter will explain
    how to do effective HTTP transfers and general fiddling with curl.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有用户调查和 curl 的整个生命周期中，HTTP 是 curl 支持的最重要和最频繁使用的协议。本章将解释如何进行有效的 HTTP 传输和使用 curl
    进行一般操作。
- en: This will mostly work the same way for HTTPS, as they are really the same thing
    under the hood, as HTTPS is HTTP with an extra security TLS layer. See also the
    specific [HTTPS](#https) section below.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 的工作方式基本相同，因为它们在内部实际上是相同的东西，HTTPS 是带有额外安全 TLS 层的 HTTP。另请参阅下面特定的 [HTTPS](#https)
    部分。
- en: HTTP methods
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: In every HTTP request, there's a method. Sometimes called a verb. The most commonly
    used ones are GET, POST, HEAD and PUT.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 HTTP 请求中，都有一个方法。有时被称为动词。最常用的是 GET、POST、HEAD 和 PUT。
- en: Normally however you don't specify the method in the command line, but instead
    the exact method used depends on the specific options you use. GET is default,
    using `-d` or `-F` makes it a POST, `-I` generates a HEAD and `-T` sends a PUT.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常不会在命令行中指定方法，而是具体使用的方法取决于您使用的特定选项。GET 是默认值，使用 `-d` 或 `-F` 则是 POST，`-I` 生成
    HEAD，`-T` 发送 PUT。
- en: More about this in the [Modify the HTTP request](http-requests.html) section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此更多内容，请参阅 [修改 HTTP 请求](http-requests.html) 部分。
- en: Scripting browser-like tasks
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本化类似浏览器的任务
- en: TBD
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Protocol basics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议基础知识
- en: HTTP protocol basics
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 协议基础知识
- en: (This assumes you have read the [Network and protocols](protocols.html) section
    or are otherwise already familiar with protocols.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: （假设您已阅读了 [网络和协议](protocols.html) 部分或者已经熟悉协议。）
- en: HTTP is a protocol that is easy to learn the basics of. A client connects to
    a server—and it is always the client that takes the initiative—sends a request
    and receives a response. Both the request and the response consist of headers
    and a body. There can be little or a lot of information going in both directions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是一个易于学习基础知识的协议。客户端连接到服务器——总是客户端发起——发送一个请求并接收一个响应。请求和响应都由头部和主体组成。在双向传输中可以有少量或大量信息。
- en: An HTTP request sent by a client starts with a request line, followed by headers
    and then optionally a body. The most common HTTP request is probably the GET request
    which asks the server to return a specific resource, and this request does not
    contain a body.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由客户端发送的 HTTP 请求以一个请求行开头，然后是头部，然后是可选的主体。最常见的 HTTP 请求可能是 GET 请求，它要求服务器返回一个特定的资源，而此请求不包含主体。
- en: 'When a client connects to ''example.com'' and asks for the ''/'' resource,
    it sends a GET without a request body:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接到 'example.com' 并请求 '/' 资源时，它发送一个不带请求体的 GET 请求：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '…the server could respond with something like below, with response headers
    and a response body (''hello''). The first line in the response also contains
    the response code and the specific version the server supports:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: … 服务器可能会响应类似以下的内容，包含响应头和响应主体（'hello'）。响应中的第一行还包含响应码和服务器支持的特定版本：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the client would instead send a request with a small request body (''hello''),
    it could look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端改为发送一个带有小请求体（'hello'）的请求，可能会是这样：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A server always responds to an HTTP request unless something is wrong.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器总是响应 HTTP 请求，除非出现了问题。
- en: The URL converted to a request
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 URL 转换为请求
- en: 'So when a HTTP client is given a URL to operate on, that URL is then used,
    picked apart and those parts are used in various places in the outgoing request
    to the server. Let''s take the an example URL:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当一个 HTTP 客户端被给予一个要操作的 URL 时，该 URL 被使用、分解并且这些部分在传出的请求到服务器中的各个地方使用。让我们以一个示例
    URL 为例：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**https** means that curl will use TLS to the remote port 443 (which is the
    default port number when no specified is used in the URL).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**https** 意味着 curl 将使用 TLS 到远程端口 443（当在 URL 中没有指定端口号时，默认端口号为 443）。'
- en: '**www.example.com** is the host name that curl will resolve to one or more
    IP address to connect to. This host name will also be used in the HTTP request
    in the `Host:` header.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**www.example.com** 是 curl 将解析为一个或多个 IP 地址以连接到的主机名。此主机名也将在 HTTP 请求中的 `Host:`
    头部中使用。'
- en: '**/path/to/file** is used in the HTTP request to tell the server which exact
    document/resources curl wants to fetch'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/path/to/file** 用于在 HTTP 请求中告诉服务器 curl 想要获取哪个确切的文档/资源'
- en: --path-as-is
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --path-as-is
- en: The path part of the URL is the part that starts with the first slash after
    the host name and ends either at the end of the URL or at a '?' or '#' (roughly
    speaking).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: URL 的路径部分是从主机名后的第一个斜杠开始，直到 URL 结束或者在问号 '?' 或井号 '#' 处结束（粗略地说）。
- en: If you include substrings including `/../` or `/./` in the path, curl will automatically
    squash them before the path is sent to the server, as is dictated by standards
    and how such strings tend to work in local file systems. The `/../` sequence will
    remove the previous section so that `/hello/sir/../` ends up just `/hello/` and
    `/./` is simply removed so that `/hello/./sir/` becomes `/hello/sir/`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在路径中包含包含 `/../` 或 `/./` 的子字符串，则 curl 将在路径发送到服务器之前自动压缩它们，这是由标准规定的，并且这些字符串在本地文件系统中的工作方式也是如此。`/../`
    序列将删除前一部分，使 `/hello/sir/../` 最终变成 `/hello/`，而 `/./` 则被简单地删除，使 `/hello/./sir/`
    成为 `/hello/sir/`。
- en: To *prevent* curl from squashing those magic sequences before they are sent
    to the server and thus allow them through, the `--path-as-is` option exists.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了 *防止* curl 在将它们发送到服务器之前压缩这些特殊序列，并允许它们通过，存在 `--path-as-is` 选项。
- en: Responses
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应
- en: HTTP responses
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 响应
- en: When an HTTP client talks HTTP to a server, the server *will* respond with an
    HTTP response message or curl will consider it an error and returns 52 with the
    error message "Empty reply from server".
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTTP 客户端与服务器通信时，服务器 *必定* 会用 HTTP 响应消息进行回应，否则 curl 会将其视为错误，并返回 52 错误，错误消息为
    "Empty reply from server"。
- en: Size of an HTTP response
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTTP 响应的大小
- en: An HTTP response has a certain size and curl needs to figure it out. There are
    several different ways to signal the end of an HTTP response but the most basic
    way is to use the `Content-Length:` header in the response and with that specify
    the exact number of bytes in the response body.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应有一定的大小，curl 需要找出来。有几种不同的方法可以表示 HTTP 响应的结束，但最基本的方法是在响应中使用 `Content-Length:`
    头部，并且使用它来指定响应正文中的确切字节数。
- en: 'Some early HTTP server implementations had problems with file sizes greater
    than 2GB and wrongly managed to send Content-Length: headers with negative sizes
    or otherwise just plain wrong data. curl can be told to ignore the Content-Length:
    header completely with `--ignore-content-length`. Doing so may have some other
    negative side-effects but should at least let you get the data.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '一些早期的 HTTP 服务器实现存在文件大小超过 2GB 的问题，错误地发送了带有负大小的 Content-Length: 头部，或者以其他方式发送了错误的数据。curl
    可以通过 `--ignore-content-length` 告诉它完全忽略 Content-Length: 头部。这样做可能会产生其他负面影响，但至少可以让您获取数据。'
- en: HTTP response codes
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 响应代码
- en: An HTTP transfer gets a 3 digit response code back in the first response line.
    The response code is the server's way of giving the client a hint about how the
    request was handled.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 传输在第一个响应行中会收到一个 3 位数的响应代码。响应代码是服务器向客户端提供关于如何处理请求的提示的方式。
- en: It is important to note that curl does not consider it an error even if the
    response code would indicate that the requested document couldn't be delivered
    (or similar). curl considers a successful sending and receiving of HTTP to be
    good.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，即使响应代码表明无法传递所请求的文档（或类似情况），curl 也不会将其视为错误。curl 认为成功发送和接收 HTTP 就是好的。
- en: 'The first digit of the HTTP response code is a kind of "error class":'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应代码的第一个数字是一种 "错误类"：
- en: '1xx: transient response, more is coming'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1xx: 临时响应，更多内容即将到来'
- en: '2xx: success'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2xx: 成功'
- en: '3xx: a redirect'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3xx: 重定向'
- en: '4xx: the client asked for something the server couldn''t/wouldn''t deliver'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4xx: 客户端请求了服务器无法/不愿提供的内容'
- en: '5xx: there''s problem in the server'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5xx: 服务器出现问题'
- en: Remember that you can use curl's `--write-out` option to extract the response
    code. See the [--write-out](usingcurl-verbose.html#--writeout) section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以使用 curl 的 `--write-out` 选项来提取响应代码。请参阅 [--write-out](usingcurl-verbose.html#--writeout)
    部分。
- en: CONNECT response codes
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CONNECT 响应代码
- en: Since there can be a HTTP request and a separate CONNECT request in the same
    curl transfer, we often separate the CONNECT response (from the proxy) from the
    remote server's HTTP response.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在同一次 curl 传输中可能存在一个 HTTP 请求和一个单独的 CONNECT 请求，因此我们通常将 CONNECT 响应（来自代理）与远程服务器的
    HTTP 响应分开。
- en: The CONNECT is also an HTTP request so it gets response codes in the same numeric
    range and you can use `--write-out` to extract that code as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CONNECT 也是一个 HTTP 请求，因此它的响应代码属于相同的数字范围，您也可以使用 `--write-out` 提取该代码。
- en: Chunked transfer encoding
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分块传输编码
- en: An HTTP 1.1 server can decide to respond with a "chunked" encoded response,
    a feature that wasn't present in HTTP 1.0.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 1.1 服务器可以决定用 "chunked" 编码的响应进行回应，这是 HTTP 1.0 中没有的功能。
- en: 'When sending a chunked response, there''s no Content-Length: for the response
    to indicate its size. Instead, there''s a `Transfer-Encoding: chunked` header
    that tells curl there''s chunked data coming and then in the response body, the
    data comes in a series of "chunks". Every individual chunk starts with the size
    of that particular chunk (in hexadecimal), then a newline and then the contents
    of the chunk. This is repeated over and over until the end of the response, which
    is signaled with a zero sized chunk. The point of this sort of response is for
    the client to be able to figure out when the responses has ended even though the
    server didn''t know the full size before it started to send it. This is usually
    the case when the response is dynamic and generated at the point when the request
    comes.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '发送分块响应时，响应中没有Content-Length:来指示其大小。相反，有一个`Transfer-Encoding: chunked`标头告诉curl有分块数据到来，然后在响应体中，数据以一系列“块”形式出现。每个单独的块以该特定块的大小（十六进制表示）开头，然后是一个换行符，然后是块的内容。这一过程一遍又一遍地重复，直到响应结束，这是通过一个大小为零的块来表示的。这种响应的目的是让客户端能够在服务器开始发送响应之前弄清楚响应何时结束，即使服务器在发送之前并不知道完整的大小。这通常是在响应是动态生成的并在请求到达时生成的情况下。'
- en: Clients like curl will, of course, decode the chunks and not show the chunk
    sizes to users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 像curl这样的客户端当然会解码这些块，并不会向用户显示块的大小。
- en: Gzipped transfers
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩传输
- en: 'Responses over HTTP can be sent in compressed format. This is most commonly
    done by the server when it includes a `Content-Encoding: gzip` in the response
    as a hint to the client. Compressed responses make a lot of sense when either
    static resources are sent (that were compressed at a previous moment in time)
    or even in run-time when there''s more CPU power available than bandwidth. Sending
    a much smaller amount of data is often preferred.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '通过HTTP可以以压缩格式发送响应。当服务器在响应中包含`Content-Encoding: gzip`作为对客户端的提示时，这通常是服务器执行的。在发送静态资源（在以前的某个时刻进行了压缩）或者在运行时有更多的CPU资源可用时，压缩响应通常是有意义的。通常更喜欢发送较少量的数据。'
- en: 'You can ask curl to both ask for compressed content *and* automatically and
    transparently uncompress gzipped data when receiving content encoded gzip (or
    in fact any other compression algorithm that curl understands) by using `--compressed`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以要求curl既要求压缩内容*又*在接收到gzip编码的内容时自动透明地解压缩数据（实际上是curl理解的任何其他压缩算法）使用`--compressed`：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Transfer encoding
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输编码
- en: A less common feature used with transfer encoding is compression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与传输编码一起使用的较少见功能是压缩。
- en: Compression in itself is common. Over time the dominant and web compatible way
    to do compression for HTTP has become to use `Content-Encoding` as described in
    the section above. But HTTP was originally intended and specified to allow transparent
    compression as a transfer encoding, and curl supports this feature.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩本身是常见的。随着时间的推移，用于HTTP的主要和与Web兼容的压缩方式已经变成了如上文所述的使用`Content-Encoding`。但HTTP最初旨在允许透明压缩作为传输编码，而curl支持此功能。
- en: 'The client then simply asks the server to do compression transfer encoding
    and if acceptable, it will response with a header indicating that it will and
    curl will then transparently uncompress that data on arrival. A user enables asking
    for compressed transfer encoding with `--tr-encoding`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后客户端简单地要求服务器执行压缩传输编码，如果可接受，它将响应一个指示将执行压缩传输编码的标头，curl将在到达时透明地解压缩数据。用户可以使用`--tr-encoding`启用请求压缩传输编码：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It should be noted that not many HTTP servers in the wild support this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在野外并不多的HTTP服务器支持这一功能。
- en: Pass on transfer encoding
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递传输编码
- en: In some situations you may want to use curl as some sort of proxy or other in
    between software. In those cases, curl's way to deal with transfer-encoding headers
    and then decoding the actual data transparently may not be desired, if the end
    receiver *also* expects to do the same.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望将curl用作某种代理或其他中间软件。在这种情况下，如果最终接收者*也*希望执行相同的操作，则可能不希望curl处理传输编码标头，然后透明地解码实际数据。
- en: You can then ask curl to pass on the received data, without decoding it. That
    means passing on the sizes in the chunked encoding format or the compressed format
    when compressed transfer encoding is used etc.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以要求curl传递接收到的数据，而不对其进行解码。这意味着在使用分块编码格式或压缩传输编码时传递大小等。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Authentication
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: HTTP authentication
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP身份验证
- en: Each HTTP request can be made authenticated. If a server or a proxy wants the
    user to provide proof that they have the correct credentials to access a URL or
    perform an action, it can send back a HTTP response code that informs the client
    that it needs to provide a correct HTTP authentication header in the request to
    be allowed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 HTTP 请求都可以进行身份验证。 如果服务器或代理希望用户提供证明他们具有正确凭据以访问 URL 或执行操作的证据，它可以发送回一个 HTTP
    响应代码，通知客户端它需要在请求中提供正确的 HTTP 身份验证头以获得允许。
- en: A server that requires authentication sends back a 401 response code and an
    associated `WWW-Authenticate:` header that lists all the authentication methods
    that the server supports.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 需要身份验证的服务器发送回一个 401 响应代码和一个相关的 `WWW-Authenticate:` 头，列出服务器支持的所有身份验证方法。
- en: An HTTP proxy that requires authentication sends back a 407 response code and
    an associated `Proxy-Authenticate:` header that lists all the authentication methods
    that the proxy supports.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要身份验证的 HTTP 代理会发送回一个 407 响应代码和一个相关的 `Proxy-Authenticate:` 头，列出代理支持的所有身份验证方法。
- en: It might be worth to note that most web sites of today do not require HTTP authentication
    for login etc, but they will instead ask users to login on web pages and then
    the browser will issue a POST with the user and password etc, and then subsequently
    maintain cookies for the session.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，今天大多数网站不需要 HTTP 身份验证进行登录等操作，而是会要求用户在网页上登录，然后浏览器将发出一个包含用户和密码等信息的 POST
    请求，然后随后维护会话的 cookie。
- en: 'To tell curl to do an authenticated HTTP request, you use the `-u, --user`
    option to provide user name and password (separated with a colon). Like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉 curl 进行身份验证的 HTTP 请求，您可以使用 `-u, --user` 选项提供用户名和密码（用冒号分隔）。 就像这样：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will make curl use the default "Basic" HTTP authentication method. Yes,
    it is actually called Basic and it is truly very basic. To explicitly ask for
    the basic method, use `--basic`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 curl 使用默认的"基本"HTTP 身份验证方法。 是的，它实际上称为基本，它确实非常基本。 要明确要求使用基本方法，请使用 `--basic`。
- en: The Basic authentication method sends the user name and password in clear text
    over the network (base64 encoded) and should be avoided for HTTP transport.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证方法会以明文形式（base64 编码）发送用户名和密码到网络上，应避免用于 HTTP 传输。
- en: When asking to do a HTTP transfer using a single (specified or implied), authentication
    method, curl will insert the authentication header already in the first request
    on the wire.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当要求使用单个（指定或隐含的）身份验证方法进行 HTTP 传输时，curl 将在第一个请求上自动插入身份验证头。
- en: 'If you''d rather have curl first *test* if the authentication is really required,
    you can ask curl to figure that out and then automatically use the most safe method
    it knows about with `--anyauth`. This makes curl try the request unauthenticated,
    and then switch over to authentication if necessary:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更愿意让 curl 先*测试*一下是否真的需要身份验证，您可以要求 curl 去弄清楚，然后自动使用它所知道的最安全的方法，使用 `--anyauth`。
    这使得 curl 尝试未经身份验证的请求，然后在必要时切换到身份验证：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'and the same concept works for HTTP operations that may require authentication:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的概念也适用于可能需要身份验证的 HTTP 操作：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'curl typically (a little depending on how it was built) speaks several other
    authentication methods as well, including Digest, Negotiate and NTLM. You can
    ask for those methods too specifically:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: curl 通常（略有不同取决于构建方式）也支持几种其他身份验证方法，包括摘要、协商和 NTLM。 您也可以专门要求这些方法：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ranges
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: HTTP ranges
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 范围
- en: What if the client only wants the first 200 bytes out of a remote resource or
    perhaps 300 bytes somewhere in the middle? The HTTP protocol allows a client to
    ask for only a specific data range. The client asks the server for the specific
    range with a start offset and an end offset. It can even combine things and ask
    for several ranges in the same request by just listing a bunch of pieces next
    to each other. When a server sends back multiple independent pieces to answer
    such a request, you will get them separated with mime boundary strings and it
    will be up to the user application to handle that accordingly. curl will not further
    separate such a response.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端只想要远程资源的前 200 字节或者可能是中间某处的 300 字节怎么办？ HTTP 协议允许客户端仅请求特定数据范围。 客户端用起始偏移量和结束偏移量向服务器请求特定范围。
    它甚至可以组合这些内容，通过在同一请求中列出一堆连续的片段。 当服务器发送多个独立的片段来回应这样的请求时，您将得到以 mime 边界字符串分隔的片段，并且由用户应用程序相应地处理。
    curl 不会进一步分隔这样的响应。
- en: However, a byte range is only a request to the server. It does not have to respect
    the request and in many cases, like when the server automatically generates the
    contents on the fly when it is being asked, it will simply refuse to do it and
    it then instead responds with the full contents anyway.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，字节范围仅仅是对服务器的请求。它不必遵守请求，在许多情况下，比如当服务器在被请求时自动生成内容时，它会简单地拒绝执行并且然后用完整的内容响应。
- en: 'You can make curl ask for a range with `-r` or `--range`. If you want the first
    200 bytes out of something:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-r`或`--range`使curl请求范围。如果要从某个地方获取前200个字节：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or everything in the file starting from index 200:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从索引200开始的文件中的所有内容：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Get 200 bytes from index 0 *and* 200 bytes from index 1000:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从索引0获取200字节 *和* 从索引1000获取200字节：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: HTTP versions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP版本
- en: HTTP versions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP版本
- en: As any other Internet protocol, the HTTP protocol has kept evolving over the
    years and now there are clients and servers distributed over the world and over
    time that speak different versions with varying levels of success. So in order
    to get libcurl to work with the URLs you pass in libcurl offers ways for you to
    specify which HTTP version that request and transfer should use. libcurl is designed
    in a way so that it tries to use the most common, the most sensible if you want,
    default values first but sometimes that isn't enough and then you may need to
    instruct libcurl what to do.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他互联网协议一样，HTTP协议随着时间的推移一直在不断发展，现在有分布在世界各地和不同时期的客户端和服务器使用不同版本并且成功程度各不相同。因此，为了使libcurl与您在libcurl中传递的URL一起工作，libcurl提供了一些方式供您指定请求和传输应使用的HTTP版本。libcurl设计的方式是首先尝试使用最常见的、最合理的默认值，但有时这是不够的，然后您可能需要指示libcurl该做什么。
- en: Since perhaps mid 2016, curl will default to use HTTP/1.1 for HTTP servers.
    If you connect to HTTPS and you have a libcurl that has HTTP/2 abilities built-in,
    curl will attempt to use HTTP/2 automatically or fall down to 1.1 in case the
    negotiation failed. Non-HTTP/2 capable curls get 1.1 over HTTPS by default.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自大约2016年中期以来，curl默认使用HTTP/1.1用于HTTP服务器。如果连接到HTTPS并且您有内置了HTTP/2功能的libcurl，curl将尝试自动使用HTTP/2，或者在协商失败时降级到1.1。不支持HTTP/2的curl默认情况下通过HTTPS获取1.1。
- en: If the default isn't good enough for your transfer, the `CURLOPT_HTTP_VERSION`
    option is there for you.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认设置不适合您的传输，则`CURLOPT_HTTP_VERSION`选项适合您。
- en: '| Option | Description |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [default] | fill in |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| [默认] | 填写 |'
- en: '| --http1.0 | fill in |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --http1.0 | 填写 |'
- en: '| --http1.1 | fill in |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --http1.1 | 填写 |'
- en: '| --http2 | fill in |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --http2 | 填写 |'
- en: '| --http2-prior-knowledge | fill in |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --http2-prior-knowledge | 填写 |'
- en: HTTPS
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS
- en: HTTPS
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS
- en: HTTPS is in effect Secure HTTP. The "secure" part means that the TCP transport
    layer is enhanced to provide authentication, privacy (encryption) and data integrity
    by the use of TLS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS实际上是安全的HTTP。 “安全”部分意味着TCP传输层通过使用TLS提供身份验证、隐私（加密）和数据完整性而得到增强。
- en: See the [Using TLS](usincurl-tls.md) section for in-depth details on how to
    modify and tweak the TLS details in a HTTPS transfer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[使用TLS](usincurl-tls.md)部分，了解如何修改和调整HTTPS传输中的TLS详细信息。
- en: HTTP POST
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP POST
- en: HTTP POST
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP POST
- en: POST is the HTTP method that was invented to send data to a receiving web application,
    and it is how most common HTML forms on the web works. It usually sends a chunk
    of relatively small amounts of data to the receiver.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: POST是用于将数据发送到接收方Web应用程序的HTTP方法，这是网络上大多数常见的HTML表单的工作方式。它通常将一小块相对较小的数据发送到接收方。
- en: 'When the data is sent by a browser after data have been filled in a form, it
    will send it "URL encoded", as a serialized name=value pairs separated with ampersand
    symbols (''&''). You send such data with curl''s `-d` or `--data` option like
    this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器在表单中填写数据后发送数据时，它会将其“URL 编码”，作为一系列用和号符号（'&'）分隔的序列化名称=值对发送。您可以使用curl的`-d`或`--data`选项发送此类数据，如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When specifying multiple `-d` options on the command line, curl will concatenate
    them and insert ampersands in between, so the above example could also be made
    like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上指定多个`-d`选项时，curl将把它们连接起来，并在其中插入和号，因此上面的示例也可以这样制作：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the amount of data to send isn''t really fit to put in a mere string on
    the command line, you can also read it off a file name in standard curl style:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要发送的数据量真的不适合在命令行上放置一个简单的字符串中，您还可以以标准curl样式从文件名中读取它：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Content-Type
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Content-Type
- en: 'POSTing with curl''s -d option will make it include a default header that looks
    like `Content-Type: application/x-www-form-urlencoded`. That''s what your typical
    browser will use for a plain POST.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '使用curl的-d选项进行POST将包含一个默认标头，看起来像`Content-Type: application/x-www-form-urlencoded`。这是你典型浏览器用于普通POST的方式。'
- en: Many receivers of POST data don't care about or check the Content-Type header.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 许多接收POST数据的服务器不关心或检查Content-Type标头。
- en: 'If that header is not good enough for you, you should, of course, replace that
    and instead provide the correct one. Such as if you POST JSON to a server and
    want to more accurately tell the server about what the content is:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该标头不够好，当然，你应该替换它并提供正确的标头。例如，如果你向服务器POST JSON并希望更准确地告诉服务器内容是什么：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: POSTing binary
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送二进制数据
- en: 'When reading from a file, `-d` will strip out carriage return and newlines.
    Use `--data-binary` if you want curl to read and use the given file in binary
    exactly as given:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件读取时，`-d`将去除回车符和换行符。如果希望curl按照给定的方式读取和使用文件中的二进制数据，请使用`--data-binary`：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: URL encoding
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL编码
- en: Percent-encoding, also known as URL encoding, is technically a mechanism for
    encoding data so that it can appear in URLs. This encoding is typically used when
    sending POSTs with the `application/x-www-form-urlencoded` content type, such
    as the ones curl sends with `--data` and `--data-binary` etc.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 百分号编码，也称为URL编码，从技术上讲是一种对数据进行编码的机制，以便它可以出现在URL中。当使用`application/x-www-form-urlencoded`内容类型发送POST时，通常会使用此编码，例如curl使用`--data`和`--data-binary`等发送的POST。
- en: The command-line options mentioned above all require that you provide properly
    encoded data, data you need to make sure already exists in the right format. While
    that gives you a lot of freedom, it is also a bit inconvenient at times.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面提到的命令行选项都要求你提供正确编码的数据，你需要确保数据已经以正确的格式存在。虽然这给了你很大的自由度，但有时也有点不方便。
- en: To help you send data you haven't already encoded, curl offers the `--data-urlencode`
    option. This option offers several different ways to URL encode the data you give
    it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你发送尚未编码的数据，curl提供了`--data-urlencode`选项。该选项提供了几种不同的方式来对你提供的数据进行URL编码。
- en: 'You use it like `--data-urlencode data` in the same style as the other --data
    options. To be CGI-compliant, the **data** part should begin with a name followed
    by a separator and a content specification. The **data** part can be passed to
    curl using one of the following syntaxes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用`--data-urlencode data`，与其他--data选项的风格相同。为了符合CGI标准，**data**部分应以名称开头，后跟一个分隔符和内容规范。**data**部分可以使用以下语法之一传递给curl：
- en: '"content": This will make curl URL encode the content and pass that on. Just
    be careful so that the content doesn''t contain any = or @ symbols, as that will
    then make the syntax match one of the other cases below!'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"content": 这将使curl对内容进行URL编码并传递。只需小心，确保内容不包含任何=或@符号，因为那样会使语法匹配下面的其他情况之一！'
- en: '"=content": This will make curl URL encode the content and pass that on. The
    initial ''='' symbol is not included in the data.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"=content": 这将使curl对内容进行URL编码并传递。初始的''=''符号不包含在数据中。'
- en: '"name=content": This will make curl URL encode the content part and pass that
    on. Note that the name part is expected to be URL encoded already.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"name=content": 这将使curl对内容部分进行URL编码并传递。请注意，名称部分应该已经进行了URL编码。'
- en: '"@filename": This will make curl load data from the given file (including any
    newlines), URL encode that data and pass it on in the POST.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"@filename": 这将使curl从给定文件加载数据（包括任何换行符），对该数据进行URL编码并在POST中传递。'
- en: '"name@filename": This will make curl load data from the given file (including
    any newlines), URL encode that data and pass it on in the POST. The name part
    gets an equal sign appended, resulting in name=urlencoded-file-content. Note that
    the name is expected to be URL encoded already.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"name@filename": 这将使curl从给定文件加载数据（包括任何换行符），对该数据进行URL编码并在POST中传递。名称部分会附加一个等号，结果为name=urlencoded-file-content。请注意，名称应该已经进行了URL编码。'
- en: 'As an example, you could POST a name to have it encoded by curl:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以POST一个名称让curl对其进行编码：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '…which would send the following data in the actual request body:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: …这将在实际请求体中发送以下数据：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you store the string `John Doe (Junior)` in a file named `contents.txt`,
    you can tell curl to send that contents URL encoded using the field name ''user''
    like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将字符串`John Doe (Junior)`存储在名为`contents.txt`的文件中，你可以告诉curl使用字段名称'user'将该内容进行URL编码，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In both these examples above, the field name is not URL encoded but is passed
    on as-is. If you want to URL encode the field name as well, like if you want to
    pass on a field name called "user name", you can ask curl to encode the entire
    string by prefixing it with an equals sign (that will not get sent):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的这两个示例中，字段名不是 URL 编码的，而是按原样传递的。如果您还想对字段名进行 URL 编码，比如如果您想传递一个名为“用户名”的字段名，您可以要求
    curl 使用等号作为前缀来编码整个字符串（这不会被发送）：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Convert that to a GET
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将其转换为 GET
- en: A little convenience feature that could be suitable to mention in this context
    (even though it isn't for POSTing), is the `-G` or `--get` option, which takes
    all data you have specified with the different `-d` variants and appends that
    data on the right end of the URL separated with a '?' and then makes curl send
    a GET instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小便利功能，可以在这个上下文中提到（即使它不适用于 POSTing），是 `-G` 或 `--get` 选项，它将您用不同的 `-d` 变体指定的所有数据添加到
    URL 的右端，以问号分隔，然后使 curl 发送 GET 请求。
- en: This option makes it easy to switch between POSTing and GETing a form, for example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项使得在 POST 和 GET 表单之间轻松切换变得容易，例如。
- en: Expect 100-continue
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 期望 100-continue
- en: 'HTTP has no proper way to stop an ongoing transfer (in any direction) and still
    maintain the connection. So, if we figure out that the transfer had better stop
    after the transfer has started, there are only two ways to proceed: cut the connection
    and pay the price of reestablishing the connection again for the next request,
    or keep the transfer going and waste bandwidth but be able to reuse the connection
    next time.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 没有合适的方法来停止正在进行的传输（在任何方向上）并仍保持连接。因此，如果我们在传输开始后发现传输最好停止，只有两种方法可以继续：切断连接并为下一个请求重新建立连接的代价，或者继续传输并浪费带宽但可以在下次重用连接。
- en: One example of when this can happen is when you send a large file over HTTP,
    only to discover that the server requires authentication and immediately sends
    back a 401 response code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过 HTTP 发送一个大文件，却发现服务器需要身份验证并立即发送回 401 响应代码时，就可能发生这种情况。
- en: 'The mitigation that exists to make this scenario less frequent is to have curl
    pass on an extra header, `Expect: 100-continue`, which gives the server a chance
    to deny the request before a lot of data is sent off. curl sends this Expect:
    header by default if the POST it will do is known or suspected to be larger than
    just minuscule. curl also does this for PUT requests.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '为了减少这种情况发生的可能性，curl 可以传递一个额外的头部 `Expect: 100-continue`，这使得服务器有机会在发送大量数据之前拒绝请求。如果
    curl 将要执行的 POST 已知或被怀疑比微不足道的大，则 curl 默认发送这个 Expect: 头。curl 还对 PUT 请求执行此操作。'
- en: When a server gets a request with an 100-continue and deems the request fine,
    it will respond with a 100 response that makes the client continue. If the server
    doesn't like the request, it sends back response code for the error it thinks
    it is.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到一个带有 100-continue 的请求并认为请求没有问题时，它将响应一个使客户端继续的 100 响应。如果服务器不喜欢请求，它会发送回它认为的错误的响应代码。
- en: 'Unfortunately, lots of servers in the world don''t properly support the Expect:
    header or don''t handle it correctly, so curl will only wait 1000 milliseconds
    for that first response before it will continue anyway.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '不幸的是，世界上许多服务器不正确地支持 Expect: 头部，或者不正确地处理它，因此 curl 将在等待第一个响应之前等待 1000 毫秒，然后继续执行。'
- en: 'Those are 1000 wasted milliseconds. You can then remove the use of Expect:
    from the request and avoid the waiting with `-H`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '那是 1000 毫秒的浪费。然后，您可以通过 `-H` 移除请求中的 Expect: 并避免等待：'
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In some situations, curl will inhibit the use of the Expect header if the content
    it is about to send is very small (like below one kilobyte), as having to "waste"
    such a small chunk of data is not considered much of a problem.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果要发送的内容非常小（如小于一千字节），curl 将抑制使用 Expect 头部，因为浪费这么小的数据块不被认为是一个大问题。
- en: Chunked encoded POSTs
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分块编码的 POST
- en: When talking to a HTTP 1.1 server, you can tell curl to send the request body
    without a `Content-Length:` header upfront that specifies exactly how big the
    POST is. By insisting on curl using chunked Transfer-Encoding, curl will send
    the POST "chunked" piece by piece in a special style that also sends the size
    for each such chunk as it goes along.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 HTTP 1.1 服务器通信时，您可以告诉 curl 在发送请求体时不需要事先发送一个指定 POST 大小的 `Content-Length:`
    头。通过坚持使用 chunked Transfer-Encoding，curl 将以特殊的方式“分块”逐块发送 POST，并随着发送每个这样的块的大小。
- en: 'You send a chunked POST with curl like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样使用 curl 发送分块 POST：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Hidden form fields
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐藏表单字段
- en: This chapter has explained how sending a post with `-d` is the equivalent of
    what a browser does when an HTML form is filled in and submitted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经解释了使用 `-d` 发送 POST 请求相当于浏览器填写并提交 HTML 表单的过程。
- en: Submitting such forms is a very common operation with curl; effectively, to
    have curl fill in a web form in an automated fashion.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 curl 提交这样的表单是一个非常常见的操作；实际上，让 curl 自动填写网页表单。
- en: If you want to submit a form with curl and make it look as if it has been done
    with a browser, it is important to provide all the input fields from the form.
    A very common method for web pages is to set a few hidden input fields to the
    form and have them assigned values directly in the HTML. A successful form submission,
    of course, also includes those fields and in order to do that automatically you
    may be forced to first download the HTML page that holds the form, parse it, and
    extract the hidden field values so that you can send them off with curl.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要用 curl 提交一个表单，并让它看起来像是通过浏览器完成的，重要的是要提供表单中的所有输入字段。网页常用的一种方法是在表单中设置一些隐藏的输入字段，并直接在
    HTML 中为它们赋值。当然，成功提交表单也包括这些字段，为了自动完成这一过程，你可能需要先下载包含表单的 HTML 页面，解析它，并提取隐藏字段的值，然后用
    curl 发送它们。
- en: Figure out what a browser sends
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弄清���浏览器发送了什么
- en: A very common shortcut is to simply fill in the form with your browser and submit
    it and check in the browser's network development tools exactly what it sent.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的快捷方式是用浏览器填写表单并提交，然后在浏览器的网络开发工具中检查它发送了什么。
- en: A slightly different way is to save the HTML page containing the form, and then
    edit that HTML page to redirect the 'action=' part of the form to your own server
    or a test server that just outputs exactly what it gets. Completing that form
    submission will then show you exactly how a browser sends it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种稍微不同的方法是保存包含表单的 HTML 页面，然后编辑该 HTML 页面，将表单的 'action=' 部分重定向到你自己的服务器或一个仅输出接收到的内容的测试服务器。完成表单提交后，你将看到浏览器发送的内容。
- en: A third option is, of course, to use a network capture tool such as Wireshark
    to check exactly what is sent over the wire. If you are working with HTTPS, you
    can't see form submissions in clear text on the wire but instead you need to make
    sure you can have Wireshark extract your TLS private key from your browser. See
    the Wireshark documentation for details on doing that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项当然是使用网络抓包工具，比如 Wireshark，来准确检查发送的内容。如果你使用 HTTPS，你无法在明文中看到表单提交的内容，而是需要确保
    Wireshark 可以从浏览器中提取你的 TLS 私钥。请参考 Wireshark 文档以获取详细信息。
- en: JavaScript and forms
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 和表单
- en: A very common mitigation against automated "agents" or scripts using curl is
    to have the page with the HTML form use JavaScript to set values of some input
    fields, usually one of the hidden ones. Often, there's some JavaScript code that
    executes on page load or when the submit button is pressed which sets a magic
    value that the server then can verify before it considers the submission to be
    valid.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 防止使用 curl 的自动化 "代理" 或脚本的一个非常常见的方法是让包含 HTML 表单的页面使用 JavaScript 设置一些输入字段的值，通常是其中一个隐藏字段。通常，页面加载时或提交按钮按下时会执行一些
    JavaScript 代码，设置一个魔术值，服务器在考虑提交是否有效之前会验证这个值。
- en: You can usually work around that by just reading the JavaScript code and redoing
    that logic in your script. Using the above mentioned tricks to check exactly what
    a browser sends is then also a good help.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以通过阅读 JavaScript 代码并在脚本中重新实现该逻辑来解决这个问题。使用上述提到的技巧来检查浏览器发送的内容也是一个很好的帮助。
- en: Multipart formposts
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多部分表单提交
- en: HTTP multipart formposts
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 多部分表单提交
- en: A multipart formpost is what an HTTP client sends when an HTML form is submitted
    with *enctype* set to "multipart/form-data".
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTML 表单提交时，HTTP 客户端发送的是一个多部分表单（multipart formpost），*enctype* 设置为 "multipart/form-data"。
- en: It is an HTTP POST request sent with the request body specially formatted as
    a series of "parts", separated with MIME boundaries.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 HTTP POST 请求，请求体特别格式化为一系列以 MIME 边界分隔的 "部分"。
- en: 'An example piece of HTML would look like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 HTML 示例可能如下所示：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Which could look something like this in a web browser:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 web 浏览器中可能看起来像这样：
- en: '![a multipart form](multipart-form.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![一个多部分表单](multipart-form.png)'
- en: A user can fill in text in the 'Name' field and by pressing the 'Browse' button
    a local file can be selected that will be uploaded when 'Submit' is pressed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在 'Name' 字段中填写文本，并通过点击 'Browse' 按钮选择一个本地文件，当按下 'Submit' 时将上传该文件。
- en: Sending such a form with curl
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 curl 发送这样的表单
- en: With curl, you add each separate multipart with one `-F` (or `--form`) flag
    and you then continue and add one -F for every input field in the form that you
    want to send.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用curl，您可以使用一个`-F`（或`--form`）标志添加每个单独的多部分，然后继续添加一个-F，以便发送表单中每个输入字段。
- en: The above small example form has two parts, one named 'person' that is a plain
    text field and one named 'secret' that is a file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的小例子表单有两部分，一个名为'person'，是一个纯文本字段，另一个名为'secret'，是一个文件。
- en: 'Send your data to that form like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的数据发送到该表单，如下所示：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The HTTP this generates
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这生成的HTTP
- en: The **action** specifies where the POST is sent. **method** says it is a POST
    and **enctype** tells us it is a multipart formpost.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**action**指定POST发送的位置。**method**表示这是一个POST，**enctype**告诉我们这是一个多部分表单提交。'
- en: 'With the fields filled in as shown above, curl generates and sends these HTTP
    request headers to the host example.com:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如上所示填写的字段，curl生成并将这些HTTP请求标头发送到主机example.com：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Content-Length**, of course, tells the server how much data to expect. This
    example''s 313 bytes is really small.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**Content-Length**当然，告诉服务器期望多少数据。这个例子的313字节真的很小。'
- en: The **Expect** header is explained in the [HTTP POST](http-post.html) chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Expect**标头在[HTTP POST](http-post.html)章节中有解释。'
- en: The **Content-Type** header is a bit special. It tells that this is a multipart
    formpost and then it sets the "boundary" string. The boundary string is a line
    of characters with a bunch of random digits somewhere in it, that serves as a
    separator between the different parts of the form that will be submitted. The
    particular boundary you see in this example has the random part `d74496d66958873e`
    but you will, of course, get something different when you run curl (or when you
    submit such a form with a browser).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**Content-Type**标头有点特殊。它告诉这是一个多部分表单提交，然后设置“边界”字符串。边界字符串是一行字符，其中包含一堆随机数字，用作将要提交的表单的不同部分之间的分隔符。在此示例中，您看到的特定边界具有随机部分`d74496d66958873e`，但当您运行curl（或使用浏览器提交这样的表单）时，您当然会得到不同的内容。'
- en: So after that initial set of headers follows the request body
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在初始的一组标头之后是请求正文
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here you clearly see the two parts sent, separated with the boundary strings.
    Each part starts with one or more headers describing the individual part with
    its name and possibly some more details. Then after the part's headers come the
    actual data of the part, without any sort of encoding.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您清楚地看到发送的两个部分，用边界字符串分隔。每个部分都以一个或多个描述具有其名称和可能一些更多详细信息的单独部分的标头开头。然后，在部分的标头之后，是部分的实际数据，没有任何编码。
- en: The last boundary string has two extra dashes `--` appended to signal the end.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个边界字符串附加了两个额外的破折号`--`，表示结束。
- en: Content-Type
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容类型
- en: POSTing with curl's -F option will make it include a default Content-Type header
    in its request, as shown in the above example. This says `multipart/form-data`
    and then specifies the MIME boundary string. That content-type is the default
    for multipart formposts but you can, of course, still modify that for your own
    commands and if you do, curl is clever enough to still append the boundary magic
    to the replaced header. You can't really alter the boundary string, since curl
    needs that for producing the POST stream.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用curl的-F选项进行POST将使其在请求中包含默认的Content-Type标头，如上例所示。这表示`multipart/form-data`，然后指定MIME边界字符串。该内容类型是多部分表单提交的默认值，但您当然仍然可以修改自己的命令，如果这样做，curl足够聪明，仍会附加边界魔术到替换的标头中。您实际上不能更改边界字符串，因为curl需要它来生成POST流。
- en: 'To replace the header, use `-H` like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换标头，请使用`-H`，如下所示：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Converting an HTML form
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换HTML表单
- en: TBD
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: -d vs -F
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -d与-F
- en: -d vs -F
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -d与-F
- en: Previous chapters talked about [regular POST](http-post.html) and [multipart
    formpost](http-multipart.html), and in your typical command lines you do them
    with `-d` or `-F`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节讨论了[常规POST](http-post.html)和[多部分表单提交](http-multipart.html)，在您典型的命令行中，您可以使用`-d`或`-F`来执行它们。
- en: But when do you use which of them?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么时候使用它们？
- en: As described in the chapters mentioned above, both these options send the specified
    data to the server. The difference is in how the data is formatted over the wire.
    Most of the time, the receiving end is written to expect a specific format and
    it expects that the sender formats and sends the data correctly. A client cannot
    just pick a format of its own choice.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述章节中所述，这两个选项都将指定的数据发送到服务器。区别在于数据在传输过程中的格式化方式。大多数情况下，接收端被编写为期望特定格式，并且期望发送方正确格式化和发送数据。客户端不能随意选择格式。
- en: HTML web forms
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML网络表单
- en: When we are talking browsers and HTML, the standard way is to offer a form to
    the user that sends off data when the form has been filled in. The `<form>` tag
    is what makes one of those appear on the web page. The tag instructs the browser
    how to format its POST. If the form tag includes `enctype=multipart/form-data`,
    it tells the browser to send the data as a [multipart formpost](http-multipart.html)
    which you make with curl's `-F` option. This method is typically used when the
    form includes a `<input type=file>` tag, for file uploads.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论浏览器和HTML时，标准的方式是向用户提供一个表单，当表单填写完成后发送数据。`<form>`标签就是让一个表单在网页上出现的东西。该标签告诉浏览器如何格式化其POST。如果表单标签包含`enctype=multipart/form-data`，它告诉浏览器将数据作为[multipart
    formpost](http-multipart.html)发送，你可以用curl的`-F`选项制作。这种方法通常用于表单包含`<input type=file>`标签时，用于文件上传。
- en: The default `enctype` used by forms, which is rarely spelled out in HTML since
    it is default, is `application/x-www-form-urlencoded`. It makes the browser "URL
    encode" the input as name=value pairs with the data encoded to avoid unsafe character.
    We often refer to that as a [regular POST](http-post.html), and you perform one
    with curl's `-d` and friends.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 表单默认使用的`enctype`，由于它是默认的，很少在HTML中详细说明，是`application/x-www-form-urlencoded`。它让浏览器“URL编码”输入，将数据编码为避免不安全字符的name=value对。我们通常称之为[常规POST](http-post.html)，您可以使用curl的`-d`和相关选项执行它。
- en: POST outside of HTML
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML之外的POST
- en: POST is a regular HTTP method and there is no requirement that it be triggered
    by HTML or involve a browser. Lots of services, APIs and other systems allow you
    to pass in data these days in order to get things done.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: POST是一个常规的HTTP方法，不要求由HTML触发或涉及浏览器。许多服务、API和其他系统现在都允许您传递数据以完成任务。
- en: If these services expect plain "raw" data or perhaps data formatted as JSON
    or similar, you want the [regular POST](http-post.html) approach. curl's `-d`
    option won't alter or encode the data at all but will just send exactly what you
    tell it to. Just pay attention to -d's default Content-Type as that might not
    be what you want.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些服务期望原始“原始”数据或者可能是JSON等格式化的数据，你就需要[常规POST](http-post.html)方法。curl的`-d`选项不会改变或编码数据，而是只会发送你告诉它的数据。只需注意-d的默认Content-Type，因为那可能不是你想要的。
- en: Redirects
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向
- en: HTTP redirects
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP重定向
- en: The “redirect” is a fundamental part of the HTTP protocol. The concept was present
    and is documented already in the first spec (RFC 1945), published in 1996, and
    it has remained well-used ever since.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: “重定向”是HTTP协议的一个基本部分。这个概念在1996年首个规范（RFC 1945）中已经存在并且有所记录，自那以后一直被广泛使用。
- en: A redirect is exactly what it sounds like. It is the server sending back an
    instruction to the client instead of giving back the contents the client wanted.
    The server basically says “go look over *here* instead for that thing you asked
    for“.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向确实就是其字面意思。服务器发送一个指令给客户端，而不是返回客户端想要的内容。服务器基本上说“去这里看看，而不是给你要求的那个东西”。
- en: But not all redirects are alike. How permanent is the redirect? What request
    method should the client use in the next request?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不是所有的重定向都一样。这个重定向有多永久？客户端在下一个请求中应该使用什么请求方法？
- en: All redirects also need to send back a `Location:` header with the new URI to
    ask for, which can be absolute or relative.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的重定向还需要发送一个`Location:`头部带有新URI的内容，可以是绝对的或相对的。
- en: Permanent and temporary
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 永久重定向和临时重定向
- en: Is the redirect meant to last or just remain valid for now? If you want a GET
    to permanently redirect users to resource B with another GET, send back a 301\.
    It also means that the user-agent (browser) is meant to cache this and keep going
    to the new URI from now on when the original URI is requested.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向是指持续还是只保持暂时有效？如果你希望GET永久重定向用户到资源B，并带有另一个GET，就发送一个301。这也意味着用户代理（浏览器）应该缓存这个并且以后当请求原始URI时继续去新的URI。
- en: The temporary alternative is 302\. Right now the server wants the client to
    send a GET request to B, but it shouldn't cache this but keep trying the original
    URI when directed to it next time.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 临时替代方案是302。现在服务器希望客户端发送一个GET请求到B，但不应该缓存这个请求，而是下次再重定向到原始URI时继续尝试。
- en: Note that both 301 and 302 will make browsers do a GET in the next request,
    which possibly means changing the method if it started with a POST (and only if
    POST). This changing of the HTTP method to GET for 301 and 302 responses is said
    to be “for historical reasons”, but that’s still what browsers do so most of the
    public web will behave this way.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，301 和 302 都会让浏览器在下一个请求中执行 GET 请求，这可能意味着如果开始是 POST 请求，则会更改方法（仅在 POST 请求时）。301
    和 302 响应中将 HTTP 方法更改为 GET 的行为被称为“出于历史原因”，但这仍然是浏览器的行为，因此大多数公共网络都会以这种方式行事。
- en: In practice, the 303 code is very similar to 302\. It will not be cached and
    it will make the client issue a GET in the next request. The differences between
    a 302 and 303 are subtle, but 303 seems to be more designed for an “indirect response”
    to the original request rather than just a redirect.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，303 代码与 302 非常相似。它不会被缓存，并且会使客户端在下一个请求中发出 GET 请求。302 和 303 之间的差异微妙，但 303
    似乎更��地设计为对原始请求的“间接响应”，而不仅仅是重定向。
- en: These three codes were the only redirect codes in the HTTP/1.0 spec.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个代码是 HTTP/1.0 规范中唯一的重定向代码。
- en: curl however, doesn't remember or cache any redirects at all so to it, there's
    really no difference between permanent and temporary redirects.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，curl 不会记住或缓存任何重定向，因此对于它来说，永久重定向和临时重定向之间实际上没有区别。
- en: Tell curl to follow redirects
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 告诉 curl 跟随重定向
- en: In curl's tradition of only doing the basics unless you tell it differently,
    it doesn't follow HTTP redirects by default. Use the `-L, --location` to tell
    it to do that.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 curl 的传统中，除非告诉它要做不同的事情，否则默认情况下不会跟随 HTTP 重定向。使用 `-L, --location` 告诉它执行该操作。
- en: When following redirects is enabled, curl will follow up to 50 redirects by
    default. There's a maximum limit mostly to avoid the risk of getting caught in
    endless loops. If 50 isn't sufficient for you, you can change the maximum number
    of redirects to follow with the `--max-redirs` option.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用重定向时，curl 默认会跟随最多 50 次重定向。通常有一个最大限制，主要是为了避免陷入无限循环的风险。如果 50 次不够用，你可以使用 `--max-redirs`
    选项来更改要跟随的最大重定向次数。
- en: GET or POST?
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET 还是 POST？
- en: All three of these response codes, 301 and 302/303, will assume that the client
    sends a GET to get the new URI, even if the client might have sent a POST in the
    first request. This is very important, at least if you do something that doesn't
    use GET.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个响应代码中的 301 和 302/303，都会假设客户端发送 GET 请求以获取新的 URI，即使客户端可能在第一个请求中发送了 POST 请求。这是非常重要的，至少如果你做的事情不使用
    GET 请求。
- en: If the server instead wants to redirect the client to a new URI and wants it
    to send the same method in the second request as it did in the first, like if
    it first sent POST it’d like it to send POST again in the next request, the server
    would use different response codes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器希望将客户端重定向到新的 URI，并希望在第二个请求中发送与第一个请求相同的方法，例如，如果首先发送了 POST 请求，则希望在下一个请求中再次发送
    POST 请求，则服务器将使用不同的响应代码。
- en: To tell the client “the URI you sent a POST to, is permanently redirected to
    B where you should instead send your POST now and in the future”, the server responds
    with a 308\. And to complicate matters, the 308 code is only recently defined
    (the [spec](https://tools.ietf.org/html/rfc7238#section-3) was published in June
    2014) so older clients may not treat it correctly! If so, then the only response
    code left for you is…
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉客户端“您发送 POST 请求的 URI 已永久重定向到 B，您现在和将来应该将您的 POST 请求发送到 B”，服务器会响应 308。并且，为了使事情更加复杂，308
    代码是最近才定义的（[规范](https://tools.ietf.org/html/rfc7238#section-3)于 2014 年 6 月发布），因此旧客户端可能无法正确处理它！如果是这样，那么你唯一剩下的响应代码是…
- en: The (older) response code to tell a client to send a POST also in the next request
    but temporarily is 307\. This redirect will not be cached by the client though,
    so it’ll again post to A if requested to again. The 307 code was introduced in
    HTTP/1.1.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉客户端在下一个请求中也临时发送 POST 的（较旧的）响应代码是 307。但是，客户端不会缓存此重定向，因此如果再次请求，则会再次发送 POST 请求到
    A。307 代码是在 HTTP/1.1 中引入的。
- en: Oh, and redirects work the exact same way in HTTP/2 as they do in HTTP/1.1.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，在 HTTP/2 中，重定向的工作方式与 HTTP/1.1 完全相同。
- en: '|  | Permanent | Temporary |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  | 永久重定向 | 临时重定向 |'
- en: '| --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Switch to GET | 301 | 302 and 303 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 切换到 GET | 301 | 302 和 303 |'
- en: '| Keep original method | 308 | 307 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 保持原始方法 | 308 | 307 |'
- en: Decide what method to use in redirects
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决定在重定向中使用的方法
- en: It turns out that there are web services out there in the world that want a
    POST sent to the original URL, but are responding with HTTP redirects that use
    a 301, 302 or 303 response codes and *still* want the HTTP client to send the
    next request as a POST. As explained above, browsers won’t do that and neither
    will curl—by default.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，世界上有一些网络服务希望发送 POST 到原始 URL，但是响应的 HTTP 重定向使用了 301、302 或 303 响应代码，*仍然*希望
    HTTP 客户端将下一个请求发送为 POST。如上所述，浏览器不会这样做，curl 也不会—默认情况下。
- en: Since these setups exist, and they’re actually not terribly rare, curl offers
    options to alter its behavior.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在这些设置，并且它们实际上并不是非常罕见的，curl 提供了选项来改变其行为。
- en: 'You can tell curl to not change the non-GET request method to GET after a 30x
    response by using the dedicated options for that: `--post301`, `--post302` and
    `--post303`. If you are instead writing a libcurl based application, you control
    that behavior with the `CURLOPT_POSTREDIR` option.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用专门的选项 `--post301`、`--post302` 和 `--post303` 来告诉 curl 在 30x 响应后不将非 GET
    请求方法更改为 GET。如果你正在编写基于 libcurl 的应用程序，则可以使用 `CURLOPT_POSTREDIR` 选项来控制该行为。
- en: Redirecting to other host names
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向到其他主机名
- en: When you use curl you may provide credentials like user name and password for
    a particular site, but since a HTTP redirect might very well move away to a different
    host curl limits what it sends away to other hosts than the original within the
    same "transfer".
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 curl 时，你可能会为特定站点提供用户名和密码等凭据，但由于 HTTP 重定向很可能会移动到不同的主机，curl 会限制它发送给原始主机之外的其他主机的内容在同一
    "传输" 中。
- en: So if you want the credentials to also get sent to the following host names
    even though they are not the same as the original—presumably because you trust
    them and know that there's no harm in doing that—you can tell curl that it is
    fine to do so by using the `--location-trusted` option.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你希望凭据也发送到以下主机名，即使它们与原始主机名不同——可能是因为你信任它们并且知道这样做没有危害，你可以告诉 curl 这样做是可以接受的，使用
    `--location-trusted` 选项。
- en: Non-HTTP redirects
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非 HTTP 重定向
- en: Browsers support more ways to do redirects that sometimes make life complicated
    to a curl user as these methods are not supported or recognized by curl.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器支持更多的重定向方式，有时对于 curl 用户来说会使生活变得复杂，因为这些方法不受 curl 支持或识别。
- en: HTML redirects
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 重定向
- en: If the above wasn't enough, the web world also provides a method to redirect
    browsers by plain HTML. See the example `<meta>` tag below. This is somewhat complicated
    with curl since curl never parses HTML and thus has no knowledge of these kinds
    of redirects.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述内容还不够，网络世界还提供了一种通过纯 HTML 重定向浏览器的方法。请参阅下面的示例 `<meta>` 标签。由于 curl 从不解析 HTML，因此它对于这种类型的重定向毫无了解。
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: JavaScript redirects
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 重定向
- en: The modern web is full of JavaScript and as you know, JavaScript is a language
    and a full run time that allows code to execute in the browser when visiting web
    sites.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络充满了 JavaScript，正如你所知，JavaScript 是一种语言和完整的运行时，允许在访问网站时在浏览器中执行代码。
- en: JavaScript also provides means for it to instruct the browser to move on to
    another site—a redirect, if you will.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 还提供了一种指示浏览器转到另一个站点的方法——重定向。
- en: Modify the HTTP request
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 HTTP 请求
- en: Modify the HTTP request
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 HTTP 请求
- en: As described earlier, each HTTP transfer starts with curl sending a HTTP request.
    That request consists of a request line and a number of request headers, and this
    chapter details how you can modify all of those.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个 HTTP 传输都以 curl 发送 HTTP 请求开始。该请求包含一个请求行和一些请求头，并且本章详细介绍了如何修改所有这些内容。
- en: Request method
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求方法
- en: 'The first line of the request includes the *method* - sometimes also referred
    to as "the verb". When doing a simple GET request as this command line would do:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的第一行包含了 *方法* - 有时也称为 "动词"。当像这条命令行那样执行简单的 GET 请求时：
- en: '[PRE31]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '…the initial request line looks like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: …初始请求行看起来像这样：
- en: '[PRE32]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can tell curl to change the method into something else by using the `-X`
    or `--request` command-line options followed by the actual method name. You can,
    for example, send a `DELETE` instead of `GET` like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `-X` 或 `--request` 命令行选项后跟实际方法名来告诉 curl 将方法更改为其他内容。例如，你可以像这样发送 `DELETE`
    而不是 `GET`：
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command-line option only changes the text in the outgoing request, it does
    not change any behavior. This is particularly important if you, for example, ask
    curl to send a HEAD with `-X`, as HEAD is specified to send all the headers a
    GET response would get but *never* send a response body, even if the headers otherwise
    imply that one would come. So, adding `-X HEAD` to a command line that would otherwise
    do a GET will cause curl to hang, waiting for a response body that won't come.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令行选项仅更改传出请求中的文本，不会更改任何行为。如果，例如，你要求curl使用`-X`发送一个HEAD，因为HEAD被指定为发送所有GET响应会得到的头部，但*永远*不会发送响应主体，即使头部否则暗示会有一个响应主体。因此，将`-X
    HEAD`添加到否则执行GET的命令行中将导致curl挂起，等待不会到达的响应主体。
- en: When asking curl to perform HTTP transfers, it will pick the correct method
    based on the option so you should only very rarely have to explicitly ask for
    it with `-X`. It should also be noted that when curl follows redirects like asked
    to with `-L`, the request method set with `-X` will be sent even on the subsequent
    redirects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当要求curl执行HTTP传输时，它将根据选项选择正确的方法，因此你只应该极少地需要使用`-X`显式请求。还应该注意，当curl像使用`-L`请求的那样遵循重定向时，使用`-X`设置的请求方法将发送，即使在随后的重定向中。
- en: Request target
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求目标
- en: In the example above, you can see how the path section of the URL gets turned
    into `/file` in the request line. That is called the "request target". That's
    the resource this request will interact with. Normally this request target is
    extracted from the URL and then used in the request and as a user you don't need
    to think about it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，你可以看到URL的路径部分在请求行中变成了`/file`。那被称为“请求目标”。那是此请求将与之交互的资源。通常，此请求目标是从URL中提取然后在请求中使用的，作为用户，你不需要考虑它。
- en: 'In some rare circumstances, user may want to go creative and change this request
    target in ways that the URL doesn''t really allow. For example, the HTTP OPTIONS
    method has a specially define request target for magic that concerns *the server*
    and not a specific path, and it uses `*` for that. Yes, a single asterisk. There''s
    no way to specicy a URL for this, so if you want to pass a single asterisk in
    the request target to a server, like for OPTIONS, you have to do it like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些罕见的情况下，用户可能想要创造性地更改此请求目标，以一种URL实际不允许的方式。例如，HTTP OPTIONS方法有一个特别定义的请求目标，用于涉及*服务器*而不是特定路径的魔术，并且它使用`*`表示。是的，一个单独的星号。没有办法为此指定URL，因此，如果你想将一个单独的星号作为请求目标传递给服务器，例如用于OPTIONS，你必须这样做：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Anchors or fragments
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锚点或片段
- en: A URL may contain an anchor, also known as a fragment, which is written with
    a pound sign and string at the end of the URL. Like for example `http://example.com/foo.html#here-it-is`.
    That fragment part, everything from the pound/hash sign to the end of the URL,
    is only intend for local use and will not be sent over the network. curl will
    simply strip that data off and discard it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: URL可能包含一个锚点，也称为片段，写在URL末尾的井号和字符串。例如`http://example.com/foo.html#here-it-is`。该片段部分，从井号/散列符号到URL末尾的所有内容，仅供本地使用，不会被发送到网络上。curl将简单地剥离该数据并丢弃它。
- en: Customize headers
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义头部
- en: 'In a HTTP request, after the initial request-line, there will typically follow
    a numbre of request headers. That''s a set of `name: value` pairs that ends with
    a blank line that separates the headers from the following request body (that
    sometimes is empty).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '在HTTP请求中，初始请求行之后，通常会跟随一些请求头。那是一组以空行结束的`name: value`对，该空行将头部与随后的请求主体（有时为空）分隔开来。'
- en: curl will by default and on its own account pass a few headers in requests,
    like for example `Host:`, `Accept:`, `User-Agent:` and a few others that may depend
    on what the user asks curl to do.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: curl默认会在请求中自己传递一些头部，例如`Host:`、`Accept:`、`User-Agent:`等，可能还会根据用户要求curl执行的操作而添加一些其他头部。
- en: All headers set by curl itself can be overriden, replaced if you will, by the
    user. You just then tell curl's `-H` or `--header` the new header to use and it
    will then replace the internal one if the header field matches one of those headers,
    or it will add the specified header to the list of headers to send in the request.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由curl本身设置的标题都可以被用户覆盖，如果你愿意的话，可以被替换。然后你只需告诉curl的`-H`或`--header`要使用的新标题，它就会用新的标题替换内部的标题，如果标题字段匹配其中一个标题，或者它将把指定的标题添加到要发送的标题列表中。
- en: 'To change the `Host:` header, do this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改`Host:`头部，请执行以下操作：
- en: '[PRE35]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To add a `Elevator: floor-9` header, do this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '要添加一个`Elevator: floor-9`头部，做如下操作：'
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you just want to delete an internally generated header, just give it to curl
    without a value, just nothing on the right side of the colon.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想删除一个内部生成的头部，只需将其传递给 curl 而不带任何值，冒号右边什么也不用写。
- en: 'To switch off the `User-Agent:` header, do this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭 `User-Agent:` 头部，做如下操作：
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, if you then truly want to add a header with no contents on the right
    side of the colon (which is a rare thing), the magic marker for that is to instead
    end the header field name with a *semicolon*. Like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你确实想要添加一个冒号右边没有内容的头部（这是一件罕见的事情），那么魔术标记就是将头部字段名称结束符号设置为分号。就像这样：
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Referer
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用页
- en: When a user clicks on a link on a web page and the browser takes the user away
    to the next URL, it will send the new URL a "referer" header in the new request
    telling it where it came from. That is the referer header. And yes, referer is
    misspelled but that's how it is supposed to be!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击网页上的链接并且浏览器将用户带到下一个 URL 时，它会在新请求中向新 URL 发送一个“referer”头，告诉它来自哪里。那就是 referer
    头部。是的，referer 拼写错误，但这就是它的本意！
- en: 'With curl you set the referer header with `-e` or `--referer`, like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 curl 可以通过 `-e` 或 `--referer` 设置 referer 头，如下所示：
- en: '[PRE39]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: User-agent
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户代理
- en: The User-Agent is a header that each client can set in the request to inform
    the server which user-agent it is. Sometimes servers will look at this header
    and determine how to act based on its contents.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理是每个客户端可以在请求中设置的头部，以通知服务器它是哪个用户代理。有时服务器会查看这个头部并根据其内容确定如何操作。
- en: 'The default header value is ''curl/[version]'', as in `User-Agent: curl/7.54.1`
    for curl version 7.54.1.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '默认头部值是 ''curl/[version]''，如 curl 版本 7.54.1 的 `User-Agent: curl/7.54.1`。'
- en: 'You can set any value you like, using the option `-A` or `--user-agent` plus
    the string to use or, as it''s just a header, `-H "User-Agent: foobar/2000"`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以设置任何你喜欢的值，使用选项 `-A` 或 `--user-agent` 再加上要使用的字符串，或者，由于它只是一个头部，`-H "User-Agent:
    foobar/2000"`。'
- en: 'As comparison, a recent test version of Firefox on a Linux machine sent this
    User-Agent header:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对比，Linux 机器上最近测试版本的 Firefox 发送了这个 User-Agent 头部：
- en: '`User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0`'
- en: --time-cond
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: --time-cond
- en: TBD
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: HTTP PUT
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP PUT
- en: PUT
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PUT
- en: The difference between a PUT and a POST is subtle. They are virtually identical
    transmissions except for the different method strings. Where POST is meant to
    pass on data to a remote resource, PUT is supposed to be the new version of that
    resource.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: PUT 和 POST 之间的区别很微妙。它们在传输上几乎是完全相同的，除了不同的方法字符串。在 POST 旨在将数据传递给远程资源的情况下，PUT 则应该是该资源的新版本。
- en: 'In that aspect, PUT is similar to good old standard file upload found in other
    protocols. You upload a new version of the resource with PUT. The URL identifies
    the resource and you point out the local file to put there:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，PUT 类似于其他协议中找到的好旧标准文件上传。你使用 PUT 上传资源的新版本。URL 标识资源，并指出要放置的本地文件：
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '…so -T will imply a PUT and tell curl which file to send off. But the similarities
    between POST and PUT also allows you to send a PUT with a string by using the
    regular curl POST mechanism using `-d` but asking for it to use a PUT instead:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: …所以 -T 将意味着一个 PUT，并告诉 curl 要发送哪个文件。但是 POST 和 PUT 之间的相似之处也允许你使用常规的 curl POST
    机制发送一个带有字符串的 PUT，只需使用 `-d` 但要求其使用 PUT：
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Cookies
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cookies
- en: Cookies
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cookies
- en: HTTP cookies are key/value pairs that a client stores on the behalf of a server.
    They are sent back in subsequent requests to allow clients to keep state between
    requests. Remember that the HTTP protocol itself has no state but instead the
    client has to resend all data in subsequent requests that it wants the server
    to be aware of.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP cookies 是客户端代表服务器存储的键/值对。它们在后续请求中发送回来，以允许客户端在请求之间保持状态。记住 HTTP 协议本身没有状态，而是客户端必须在后续请求中重新发送所有数据，以便服务器知道它们。
- en: Cookies are set by the server with the `Set-Cookie:` header and with each cookie
    the server sends a bunch of extra properties that need to match for the client
    to send the cookie back. Like domain name and path and perhaps most important
    for how long the cookie should live on.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用 `Set-Cookie:` 头部设置 Cookies，并且对于每个 Cookie，服务器发送一堆额外的属性，这些属性需要与客户端发送的 Cookie
    匹配。比如域名和路径，也许最重要的是 Cookie 应该存在多长时间。
- en: The expiry of a cookie is either set to a fixed time in the future (or to live
    a number of seconds) or it gets no expiry at all. A cookie without an expire time
    is called a "session cookie" and is meant to live for the duration of the "session"
    but not longer. A session in this aspect is typically thought to be the life time
    of the browser used to view a site. When you close the browser, you end your session.
    Doing HTTP operations with a command-line client that supports cookies begs the
    question of when a session really ends…
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: cookie 的到期时间要么设置为将来的固定时间（或者活多少秒），要么根本没有到期时间。没有到期时间的 cookie 被称为“会话 cookie”，意味着在“会话”期间但不再长一点。在这个方面，会话通常被认为是用于查看网站的浏览器的寿命。当你关闭浏览器时，会话结束。使用支持
    cookie 的命令行客户端进行 HTTP 操作引发了一个问题，即会话真正何时结束…
- en: Cookie engine
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cookie 引擎
- en: The general concept of curl only doing the bare minimum unless you tell it differently
    makes it not acknowledge cookies by default. You need to switch on "the cookie
    engine" to make curl keep track of cookies it receives and then subsequently send
    them out on requests that have matching cookies.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的 `curl` 概念默认只执行最低限度的操作，除非你另行指定，这使它默认不会识别 cookie。你需要打开“cookie 引擎”来让 `curl`
    跟踪收到的 cookie，并在随后发送带有匹配 cookie 的请求。
- en: 'You enable the cookie engine by asking curl to read or write cookies. If you
    tell curl to read cookies from a non-existing file, you will only switch on the
    engine but start off with an empty internal cookie store:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过让 `curl` 读取或写入 cookie 来启用 cookie 引擎。如果你告诉 `curl` 从不存在的文件中读取 cookie，你只会打开引擎，但会从一个空的内部
    cookie 存储开始：
- en: '[PRE42]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'But just switching on the cookie engine, getting a single resource and then
    quitting would be pointless as curl would have no chance to actually send any
    cookies it received. Assuming the site in this example would set cookies and then
    do a redirect we would do:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 但是仅仅打开 cookie 引擎，获取单个资源然后退出是没有意义的，因为 `curl` 没有机会实际发送任何它收到的 cookie。假设在这个例子中的站点设置了
    cookie 然后重定向，我们会这样做：
- en: '[PRE43]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Reading cookies from file
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件中读取 cookie
- en: Starting off with a blank cookie store may not be desirable. Why not start off
    with cookies you stored in a previous fetch or that you otherwise acquired? The
    file format curl uses for cookies is called the Netscape cookie format because
    it was once the file format used by browsers and then you could easily tell curl
    to use the browser's cookies!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个空的 cookie 存储开始可能并不理想。为什么不从之前获取的 cookie 或其他方式获取的 cookie 开始呢？`curl` 用于 cookie
    的文件格式称为 Netscape cookie 格式，因为曾经是浏览器使用的文件格式，然后你可以轻松地告诉 `curl` 使用浏览器的 cookie！
- en: As a convenience, curl also supports a cookie file being a set of HTTP headers
    that set cookies. It's an inferior format but may be the only thing you have.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，`curl` 还支持 cookie 文件作为设置 cookie 的一组 HTTP 标头。这是一个较差的格式，但可能是你唯一拥有的东西。
- en: 'Tell curl which file to read the initial cookies from:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉 `curl` 从哪个文件中读取初始 cookie：
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Remember that this only *reads* from the file. If the server would update the
    cookies in its response, curl would update that cookie in its in-memory store
    but then eventually throw them all away when it exits and a subsequent invocation
    of the same input file would use the original cookie contents again.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这仅仅 *从* 文件 *读取*。如果服务器在其响应中更新了 cookie，`curl` 会在其内存存储中更新该 cookie，但当它退出时最终会将它们全部丢弃，并且对同一输入文件的随后调用会再次使用原始的
    cookie 内容。
- en: Writing cookies to file
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 cookie 写入文件
- en: The place where cookies are stored is sometimes referred to as the "cookie jar".
    When you enable the cookie engine in curl and it has received cookies, you can
    instruct curl to write down all its known cookies to a file, the cookie jar, before
    it exists. It is important to remember that curl only updates the output cookie
    jar on exit and not during its lifetime, no matter how long the handling of the
    given input takes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 存储 cookie 的地方有时被称为“cookie 存储罐”。当你在 `curl` 中启用 cookie 引擎并且它已收到 cookie 时，你可以指示
    `curl` 在退出之前将其所有已知的 cookie 写入文件，即 cookie 存储罐。重要的是要记住，`curl` 仅在退出时更新输出 cookie 存储罐，而不是在其生命周期内，无论给定输入的处理时间有多长。
- en: 'You point out the cookie jar output with `-c`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-c` 指定 cookie 存储文件输出位置：
- en: '[PRE45]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`-c` is the instruction to *write* cookies to a file, `-b` is the instruction
    to *read* cookies from a file. Oftentimes you want both.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c` 是 *写入* cookie 到文件的指令，`-b` 是 *从* 文件中 *读取* cookie 的指令。通常你会两者都需要。'
- en: When curl writes cookies to this file, it will save all known cookies including
    those that are session cookies (without a given lifetime). curl itself has no
    notion of a session and it doesn't know when a session ends so it will not flush
    session cookies unless you tell it to.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当curl将cookie写入此文件时，它将保存所有已知的cookie，包括那些会话cookie（没有给定生存期的）。curl本身不知道会话的概念，也不知道会话何时结束，因此除非告诉它，否则它不会刷新会话cookie。
- en: New cookie session
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的cookie会话
- en: Instead of telling curl when a session ends, in order to flush session cookies
    and with this basically signal to the server that we are starting a new session,
    curl features an option that lets the user decide when a new session begins.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 与其告诉curl会话何时结束，以刷新会话cookie并基本上向服务器发出我们正在开始新会话的信号，curl提供了一个选项，让用户决定何时开始新会话。
- en: A new cookie session means that all the session cookies will be thrown away.
    It is the equivalent of closing a browser and starting it up again.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 新的cookie会话意味着所有会话cookie将被丢弃。这相当于关闭浏览器并重新启动。
- en: 'Tell curl a new cookie session starts by using `-j, --junk-session-cookies`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`-j, --junk-session-cookies`告诉curl一个新的cookie会���开始：
- en: '[PRE46]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: HTTP/2
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2
- en: HTTP/2
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP/2
- en: curl supports HTTP/2 for both HTTP:// and HTTPS:// URLs assuming that curl was
    built with the proper prerequisites. It will even default to using HTTP/2 when
    given a HTTPS URL since doing so implies no penalty and when curl is used with
    sites that don't support HTTP/2 the request will instead negotiate HTTP/1.1.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: curl支持HTTP/2协议，适用于HTTP://和HTTPS:// URL，假设curl是使用正确的先决条件构建的。即使给定HTTPS URL时，curl甚至会默认使用HTTP/2，因为这样做不会有任何惩罚，当curl与不支持HTTP/2的站点一起使用时，请求将协商HTTP/1.1。
- en: With HTTP:// URLs however, the upgrade to HTTP/2 is done with an `Upgrade:`
    header that may cause an extra round-trip and perhaps even more troublesome, a
    sizable share of old servers will return a 400 response when seeing such a header.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于HTTP:// URL，升级到HTTP/2是通过一个`Upgrade:`头完成的，这可能会导致额外的往返，甚至更麻烦的是，很大一部分旧服务器在看到这样的头时会返回400响应。
- en: It should also be noted that some (most?) servers that support HTTP/2 for HTTP://
    (which in itself isn't all servers) will not acknowledge the `Upgrade:` header
    on POST, for example.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意，一些（大多数？）支持HTTP/2的HTTP://服务器（本身并非所有服务器）不会在POST请求中承认`Upgrade:`头。
- en: 'To ask a server to use HTTP/2, just:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要求服务器使用HTTP/2，只需：
- en: '[PRE47]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If your curl doesn't support HTTP/2, that command line will return an error
    saying so. Running `curl -V` will show if your version of curl supports it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的curl不支持HTTP/2，那个命令行将返回一个错误。运行`curl -V`将显示你的curl版本是否支持它。
- en: If you by some chance already know that your server speaks HTTP/2 (for example,
    within your own controlled environment where you know exactly what runs in your
    machines) you can shortcut the HTTP/2 "negotiation" with `--http2-prior-knowledge`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你碰巧已经知道你的服务器支持HTTP/2（例如，在你自己控制的环境中，你确切地知道你的机器上运行着什么），你可以使用`--http2-prior-knowledge`来快速完成HTTP/2的“协商”。
- en: Multiplexing
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多路复用
- en: One of the primary features in the HTTP/2 protocol is the ability to multiplex
    several logical stream over the same physical connection. When using the curl
    command-line tool, you cannot take advantage of that cool feature since curl is
    doing all its network requests in a strictly serial manner, one after the next,
    with the second only ever starting once the previous one has ended.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2协议中的一个主要特性是能够在同一物理连接上复用多个逻辑流。当使用curl命令行工具时，你无法利用这一酷炫功能，因为curl会严格按照串行方式执行所有网络请求，一个接一个地进行，第二个请求只有在前一个请求结束后才会开始。
- en: Hopefully, a future curl version will be enhanced to allow the use of this feature.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 希望未来的curl版本将增强以允许使用这一功能。
- en: HTTP cheat sheet
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP速查表
- en: curl HTTP cheat sheet
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: curl HTTP速查表
- en: '[online here](https://bagder.github.io/curl-cheat-sheet/http-sheet.html)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[在线链接](https://bagder.github.io/curl-cheat-sheet/http-sheet.html)'
- en: '| Verbose | Hide progress | extra info | Write output | Timeout |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 详细信息 | 隐藏进度 | 额外信息 | 写入输出 | 超时 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| -v | -s | -w "format" | -O | -m |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| -v | -s | -w "format" | -O | -m |'
- en: '| --trace-ascii |  |  | -o |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| --trace-ascii |  |  | -o |'
- en: '| **POST** | **multipart** | **PUT** | **HEAD** | **custom** |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **POST** | **multipart** | **PUT** | **HEAD** | **custom** |'
- en: '| -d "string" | -F name=value | -T | -I | -X "METHOD" |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| -d "string" | -F name=value | -T | -I | -X "METHOD" |'
- en: '| -d @file | -F name=@file |  |  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| -d @file | -F name=@file |  |  |'
- en: '| **Basic auth** | **read cookies** | **write cookies** | **send cookies**
    | **user-agent** |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **基本认证** | **读取cookie** | **写入cookie** | **发送cookie** | **用户代理** |'
- en: '| -u user:password | -b | -c | -b "c=1; d=2" | -A "string" |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| -u 用户:密码 | -b | -c | -b "c=1; d=2" | -A "字符串" |'
- en: '| **Use proxy** | **Headers, add/remove** | **follow redirs** | **gzip** |
    **insecure** |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **使用代理** | **头部，添加/移除** | **跟随重定向** | **gzip** | **不安全** |'
- en: '| -x<hostu0003aport class="calibre28"></hostu0003aport> | -H "name: value"
    | -L | --compressed | -k |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| -x<主机端口 class="calibre28"></主机端口> | -H "名称: 值" | -L | --压缩 | -k |'
- en: '|  | -H "name:" |  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|  | -H "名称:" |  |'
