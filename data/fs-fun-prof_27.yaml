- en: The "Recursive types and folds" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “递归类型和折叠”系列
- en: In this series, we'll look at recursive types and how to use them, and on the
    way, we'll look at catamorphisms, tail recursion, the difference between left
    and right folds, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们将看到递归类型及其如何使用，并在此过程中，我们将看到积累、尾递归、左折叠和右折叠之间的区别等等。
- en: '[Introduction to recursive types](recursive-types-and-folds1.html). Don''t
    fear the catamorphism....'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[递归类型简介](recursive-types-and-folds1.html)。不要害怕积累....'
- en: '[Catamorphism examples](recursive-types-and-folds-1b.html). Applying the rules
    to other domains.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[积累示例](recursive-types-and-folds-1b.html)。将规则应用于其他领域。'
- en: '[Introducing Folds](recursive-types-and-folds-2.html). Threading state through
    a recursive data structure.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍折叠](recursive-types-and-folds-2.html)。通过递归数据结构传递状态。'
- en: '[Understanding Folds](recursive-types-and-folds-2b.html). Recursion vs. iteration.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解折叠](recursive-types-and-folds-2b.html)。递归 vs. 迭代。'
- en: '[Generic recursive types](recursive-types-and-folds-3.html). Implementing a
    domain in three ways.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通用递归类型](recursive-types-and-folds-3.html)。以三种方式实现领域。'
- en: '[Trees in the real world](recursive-types-and-folds-3b.html). Examples using
    databases, JSON and error handling.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[现实世界中的树](recursive-types-and-folds-3b.html)。使用数据库、JSON 和错误处理的示例。'
- en: Introduction to recursive types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归类型简介
- en: Introduction to recursive types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归类型简介
- en: In this series, we'll look at recursive types and how to use them, and on the
    way, we'll look at catamorphisms, tail recursion, the difference between left
    and right folds, and more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们将看到递归类型及其如何使用，并在此过程中，我们将看到积累、尾递归、左折叠和右折叠之间的区别等等。
- en: Series contents
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s the contents of this series:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系列的内容如下：
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 1 部分：介绍递归类型和积累**'
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一个简单的递归类型](recursive-types-and-folds1.html#basic-recursive-type)'
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参数化一切](recursive-types-and-folds1.html#parameterize)'
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍积累](recursive-types-and-folds1.html#catamorphisms)'
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[积累的好处](recursive-types-and-folds1.html#benefits)'
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建积累的规则](recursive-types-and-folds1.html#rules)'
- en: '**Part 2: Catamorphism examples**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 2 部分：积累示例**'
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[积累示例：文件系统领域](recursive-types-and-folds-1b.html#file-system)'
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[积累示例：产品领域](recursive-types-and-folds-1b.html#product)'
- en: '**Part 3: Introducing folds**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 3 部分：介绍折叠**'
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我们的积累实现中的一个缺陷](recursive-types-and-folds-2.html#flaw)'
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 `fold`](recursive-types-and-folds-2.html#fold)'
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠的问题](recursive-types-and-folds-2.html#problems)'
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数用作累加器](recursive-types-and-folds-2.html#functions)'
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 `foldback`](recursive-types-and-folds-2.html#foldback)'
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建折叠的规则](recursive-types-and-folds-2.html#rules)'
- en: '**Part 4: Understanding folds**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 4 部分：理解折叠**'
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[迭代 vs. 递归](recursive-types-and-folds-2b.html#iteration)'
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠示例：文件系统领域](recursive-types-and-folds-2b.html#file-system)'
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于“fold”的常见问题](recursive-types-and-folds-2b.html#questions)'
- en: '**Part 5: Generic recursive types**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 5 部分：通用递归类型**'
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[LinkedList：一个通用的递归类型](recursive-types-and-folds-3.html#linkedlist)'
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使 Gift 领域通用化](recursive-types-and-folds-3.html#revisiting-gift)'
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义一个通用的容器类型](recursive-types-and-folds-3.html#container)'
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现礼品领域的第三种方法](recursive-types-and-folds-3.html#another-gift)'
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抽象还是具体？比较这三种设计](recursive-types-and-folds-3.html#compare)'
- en: '**Part 6: Trees in the real world**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 6 部分：现实世界中的树**'
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用的树类型](recursive-types-and-folds-3b.html#tree)'
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[现实世界中的树类型](recursive-types-and-folds-3b.html#reuse)'
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射树类型](recursive-types-and-folds-3b.html#map)'
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：创建目录列表](recursive-types-and-folds-3b.html#listing)'
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：并行grep](recursive-types-and-folds-3b.html#grep)'
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将文件系统存储在数据库中](recursive-types-and-folds-3b.html#database)'
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将树序列化为JSON](recursive-types-and-folds-3b.html#tojson)'
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从JSON反序列化树](recursive-types-and-folds-3b.html#fromjson)'
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从JSON反序列化树-带错误处理](recursive-types-and-folds-3b.html#json-with-error-handling)'
- en: '* * *'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A basic recursive type
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个基本的递归类型
- en: Let's start with a simple example -- how to model a gift.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始--如何建模一个礼物。
- en: As it happens, I'm a very lazy gift-giver. I always give people a book or chocolates.
    I generally wrap them, and sometimes, if I'm feeling particularly extravagant,
    I put them in a gift box and add a card too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 碰巧，我是一个非常懒惰的送礼者。我总是送人一本书或巧克力。我通常会包装它们，有时，如果我感觉格外慷慨，我会把它们放在礼品盒里，还会加上一张卡片。
- en: 'Let''s see how I might model this in types:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我如何在类型中建模这个：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see that three of the cases are "containers" that refer to another `Gift`.
    The `Wrapped` case has some paper and a inner gift, as does the `Boxed` case,
    as does the `WithACard` case. The two other cases, `Book` and `Chocolate`, do
    not refer to a gift and can be considered "leaf" nodes or terminals.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到三种情况是指向另一个`Gift`的“容器”。`Wrapped`情况有一些纸和一个内部礼物，`Boxed`情况也是如此，`WithACard`情况也是如此。另外两种情况，`Book`和`Chocolate`，不涉及礼物，可以被视为“叶”节点或终端。
- en: The presence of a reference to an inner `Gift` in those three cases makes `Gift`
    a *recursive type*. Note that, unlike functions, the `rec` keyword is *not* needed
    for defining recursive types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种情况中引用内部`Gift`使`Gift`成为*递归类型*。请注意，与函数不同，定义递归类型时*不*需要使用`rec`关键字。
- en: 'Let''s create some example values:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些示例值：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before we start working with these values, a word of advice...
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理这些值之前，给出一个建议...
- en: 'Guideline: Avoid infinitely recursive types'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指南：避免无限递归类型
- en: I suggest that, in F#, every recursive type should consist of a mix of recursive
    and non-recursive cases. If there were no non-recursive elements, such as `Book`,
    all values of the type would have to be infinitely recursive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议，在F#中，每个递归类型都应该包含递归和非递归情况的混合。如果没有非递归元素，比如`Book`，那么该类型的所有值都必须是无限递归的。
- en: For example, in the `ImpossibleGift` type below, all the cases are recursive.
    To construct any one of the cases you need an inner gift, and that needs to be
    constructed too, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的`ImpossibleGift`类型中，所有情况都是递归的。要构造任何一个情况，你需要一个内部礼物，而那也需要被构造，依此类推。
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is possible to create such types if you allow [laziness](https://wiki.haskell.org/Tying_the_Knot),
    mutation, or reflection. But in general, in a non-lazy language like F#, it's
    a good idea to avoid such types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许[懒惰](https://wiki.haskell.org/Tying_the_Knot)、变异或反射，就可以创建这种类型。但一般来说，在像F#这样的非懒惰语言中，最好避免使用这种类型。
- en: Working with recursive types
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理递归类型
- en: End of public service announcement -- let's get coding!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 公共服务公告结束--让我们开始编码吧！
- en: 'First, say that we want a description of the gift. The logic will be:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们说我们想要一个礼物的描述。逻辑将是：
- en: For the two non-recursive cases, return a string describing that case.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两种非递归情况，返回描述该情况的字符串。
- en: For the three recursive cases, return a string that describes the case, but
    also includes the description of the inner gift. This means that `description`
    function is going to refer to itself, and therefore it must be marked with the
    `rec` keyword.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于三种递归情况，返回描述该情况的字符串，但也包括内部礼物的描述。这意味着`description`函数将引用自身，因此必须用`rec`关键字标记。
- en: 'Here''s an example implementation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例实现：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note the recursive calls like this one in the `Boxed` case:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Boxed`情况中的递归调用，如下所示：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we try this with our example values, let''s see what we get:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试用我们的示例值来做这个，让我们看看我们会得到什么：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That looks pretty good to me. Things like `HappyHolidays` look a bit funny without
    spaces, but it's good enough to demonstrate the idea.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说看起来很不错。像`HappyHolidays`这样的东西没有空格看起来有点奇怪，但足以演示这个想法。
- en: What about creating another function? For example, what is the total cost of
    a gift?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个函数怎么样？例如，一个礼物的总成本是多少？
- en: 'For `totalCost`, the logic will be:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`totalCost`，逻辑将是：
- en: Books and chocolate capture the price in the case-specific data, so use that.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍和巧克力在特定情况下捕获了价格，所以使用它。
- en: Wrapping adds `0.5` to the cost.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装将成本增加`0.5`。
- en: A box adds `1.0` to the cost.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个盒子将成本增加`1.0`。
- en: A card adds `2.0` to the cost.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张卡将成本增加`2.0`。
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here are the costs for the two examples:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个示例的成本：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sometimes, people ask what is inside the box or wrapping paper. A `whatsInside`
    function is easy to implement -- just ignore the container cases and return something
    for the non-recursive cases.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，人们问盒子或包装纸里面装了什么。一个`whatsInside`函数很容易实现——只需忽略容器情况并为非递归情况返回一些内容。
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And the results:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So that's a good start -- three functions, all quite easy to write.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的开始——三个函数，都很容易编写。
- en: Parameterize all the things
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化所有东西
- en: However, these three functions have some duplicate code. In addition to the
    unique application logic, each function is doing its own pattern matching and
    its own logic for recursively visiting the inner gift.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这三个函数有一些重复的代码。除了独特的应用逻辑之外，每个函数都在进行自己的模式匹配和递归访问内部礼物的逻辑。
- en: How can we separate the navigation logic from the application logic?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将导航逻辑与应用逻辑分开？
- en: 'Answer: Parameterize all the things!'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：参数化所有东西！
- en: As always, we can parameterize the application logic by passing in functions.
    In this case, we will need *five* functions, one for each case.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们可以通过传递函数来参数化应用程序逻辑。在这种情况下，我们将需要*五个*函数，每个情况一个。
- en: Here is the new, parameterized version -- I'll explain why I have called it
    `cataGift` shortly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的、参数化版本——我会解释为什么我称它为`cataGift`的。
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see this function is created using a purely mechanical process:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这个函数是使用一个纯机械的过程创建的：
- en: Each function parameter (`fBook`, `fChocolate`, etc) corresponds to a case.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数参数（`fBook`，`fChocolate`等）对应一个情况。
- en: For the two non-recursive cases, the function parameter is passed all the data
    associated with that case.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两个非递归情况，将函数参数传递给与该情况相关的所有数据。
- en: 'For the three recursive cases, there are two steps:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于三个递归情况，有两个步骤：
- en: First, the `cataGift` function is called recursively on the `innerGift` to get
    an `innerGiftResult`
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在`innerGift`上递归调用`cataGift`函数以获得`innerGiftResult`
- en: Then the appropriate handler is passed all the data associated with that case,
    but with `innerGiftResult` replacing `innerGift`.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，适当的处理程序将所有与该情况相关的数据传递给它，但是使用`innerGiftResult`替换`innerGift`。
- en: Let's rewrite total cost using the generic `cataGift` function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用通用的`cataGift`函数重写总成本。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注：
- en: The `innerGiftResult` is now the total cost of the inner gift, so I have renamed
    it to `innerCost`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，`innerGiftResult`是内部礼物的总成本，所以我将其重命名为`innerCost`。
- en: The `totalCostUsingCata` function itself is not recursive, because it uses the
    `cataGift` function, and so no longer needs the `rec` keyword.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalCostUsingCata`函数本身不是递归的，因为它使用了`cataGift`函数，所以不再需要`rec`关键字。'
- en: 'And this function gives the same result as before:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数给出了与以前相同的结果：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can rewrite the `description` function using `cataGift` in the same way,
    changing `innerGiftResult` to `innerText`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以同样的方式使用`cataGift`重写`description`函数，将`innerGiftResult`改为`innerText`。
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the results are the same as before:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结果和以前一样：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Introducing catamorphisms
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入折叠函数
- en: The `cataGift` function we wrote above is called a "[catamorphism](https://en.wikipedia.org/wiki/Catamorphism)",
    from the Greek components "down + shape". In normal usage, a catamorphism is a
    function that "collapses" a recursive type into a new value based on its *structure*.
    In fact, you can think of a catamorphism as a sort of "visitor pattern".
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面写的`cataGift`函数被称为"[折叠函数](https://en.wikipedia.org/wiki/Catamorphism)"，来自希腊词组"向下
    + 形状"。在正常用法中，折叠函数是一个根据其*结构*将递归类型"折叠"为新值的函数。实际上，您可以将折叠函数看作是一种"访问者模式"。
- en: A catamorphism is very powerful concept, because it is the most fundamental
    function that you can define for a structure like this. *Any other function* can
    be defined in terms of it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠函数是一个非常强大的概念，因为它是您可以为这样的结构定义的最基本函数。*任何其他函数*都可以用它来定义。
- en: That is, if we want to create a function with signature `Gift -> string` or
    `Gift -> int`, we can use a catamorphism to create it by specifying a function
    for each case in the `Gift` structure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们想要创建一个带有签名`Gift -> string`或`Gift -> int`的函数，我们可以使用catamorphism通过为`Gift`结构中的每个案例指定一个函数来创建它。
- en: We saw above how we could rewrite `totalCost` as `totalCostUsingCata` using
    the catamorphism, and we'll see lots of other examples later.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到了如何使用catamorphism重写`totalCost`为`totalCostUsingCata`，以及以后会看到许多其他示例。
- en: Catamorphisms and folds
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Catamorphisms和folds
- en: Catamorphisms are often called "folds", but there is more than one kind of fold,
    so I will tend to use "catamorphism" to refer the *concept* and "fold" to refer
    to a specific kind of implementation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Catamorphisms`通常被称为“folds”，但是有多种类型的折叠，所以我倾向于使用“catamorphism”来指代*概念*，并使用“fold”来指代特定类型的实现。
- en: I will talk in detail about the various kinds of folds in a [subsequent post](recursive-types-and-folds-2.html),
    so for the rest of this post I will just use "catamorphism".
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[后续帖子](recursive-types-and-folds-2.html)中详细讨论各种折叠类型，所以在本帖子的其余部分，我将仅使用“catamorphism”。
- en: Tidying up the implementation
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整理实现
- en: The `cataGift` implementation above was deliberately long-winded so that you
    could see each step. Once you understand what is going on though, you can simplify
    it somewhat.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`cataGift`实现故意冗长，以便您可以看到每个步骤。不过一旦您理解了正在发生的事情，您可以稍微简化它。
- en: 'First, the `cataGift fBook fChocolate fWrapped fBox fCard` crops up three times,
    once for each recursive case. Let''s assign it a name like `recurse`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`cataGift fBook fChocolate fWrapped fBox fCard`出现了三次，每次都是为了处理递归情况。让我们给它分配一个名称，比如`recurse`：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `recurse` function has the simple signature `Gift -> 'a` -- that is, it
    converts a `Gift` to the return type we need, and so we can use it to work with
    the various `innerGift` values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`recurse`函数具有简单的签名`Gift -> ''a` -- 也就是说，它将`Gift`转换为我们需要的返回类型，因此我们可以使用它来处理各种`innerGift`值。'
- en: The other thing is to replace `innerGift` with just `gift` in the recursive
    cases -- this is called "shadowing". The benefit is that the "outer" `gift` is
    no longer visible to the case-handling code, and so we can't accidentally recurse
    into it, which would cause an infinite loop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是在递归案例中将`innerGift`替换为`gift`--这被称为“遮蔽”。好处是“外部”的`gift`不再对案例处理代码可见，因此我们不会意外地递归进入其中，这会导致无限循环。
- en: Generally I avoid shadowing, but this is one case where it actually is a good
    practice, because it eliminates a particularly nasty kind of bug.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我会避免遮蔽，但这是一种情况，实际上这是一种良好的做法，因为它消除了一种特别讨厌的bug。
- en: 'Here''s the version after the clean up:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清理后的版本：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One more thing. I'm going to explicitly annotate the return type and call it
    `'r`. Later on in this series we'll be dealing with other generic types such as
    `'a` and `'b`, so it will be helpful to be consistent and always have a standard
    name for the return type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事。我会明确注释返回类型并将其称为`'r`。在这个系列的后续部分中，我们将处理其他泛型类型，比如`'a`和`'b`，所以保持一致并始终为返回类型使用标准名称会很有帮助。
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s the final version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终版本：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It's much simpler than the original implementation, and also demonstrates the
    symmetry between a case constructor like `Wrapped (gift,style)` and the corresponding
    handler `fWrapped (recurse gift,style)`. Which leads us nicely to...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 比起原始实现，这简单多了，也展示了像`Wrapped (gift,style)`这样的案例构造函数与相应的处理函数`fWrapped (recurse
    gift,style)`之间的对称性。这让我们很好地过渡到了...
- en: The relationship between the type constructors and the handlers
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型构造函数和处理程序之间的关系
- en: 'Here is the signature for the `cataGift` function. You can see that each case
    handler function (`fBook`, `fBox`, etc.) has the same pattern: an input which
    contains all the data for that case, and a common output type `''r`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`cataGift`函数的签名。你可以看到每个案例处理函数（`fBook`，`fBox`等）都有相同的模式：一个包含该案例所有数据的输入，以及一个共同的输出类型`'r`。
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another way to think about this is that: everywhere that there is a `Gift`
    type in the constructor, it has been replaced with an `''r`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考这个问题的方式是：在构造函数中的每个`Gift`类型处，它都已被替换为`'r`。
- en: 'For example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: The `Gift.Book` constructor takes a `Book` and returns a `Gift`. The `fBook`
    handler takes a `Book` and returns an `'r`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gift.Book`构造函数接受一个`Book`并返回一个`Gift`。`fBook`处理程序接受一个`Book`并返回一个`''r`。'
- en: The `Gift.Wrapped` constructor takes a `Gift * WrappingPaperStyle` and returns
    a `Gift`. The `fWrapped` handler takes an `'r * WrappingPaperStyle` as input and
    returns an `'r`.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gift.Wrapped`构造函数接受一个`Gift * WrappingPaperStyle`并返回一个`Gift`。`fWrapped`处理程序接受一个`''r
    * WrappingPaperStyle`作为输入，并返回一个`''r`。'
- en: 'Here is that relationship expressed through type signatures:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里通过类型签名表达了这种关系：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: and so on for all of the rest.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，其他的都是一样的。
- en: Benefits of catamorphisms
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范畴折叠的好处
- en: There is a lot of theory behind catamorphisms, but what are the benefits in
    practice?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多关于范畴折叠的理论，但实践中有什么好处呢？
- en: Why bother to create a special function like `cataGift`? Why not just leave
    the original functions alone?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要创建像`cataGift`这样的特殊函数？为什么不只是保留原始函数？
- en: 'There are number of reasons, including:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 包括以下原因：
- en: '**Reuse**. Later, we will be creating quite complex catamorphisms. It''s nice
    if you only have to get the logic right once.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重用**。稍后，我们将创建相当复杂的范畴折叠。如果你只需一次正确地处理逻辑就好了。'
- en: '**Encapsulation**. By exposing functions only, you hide the internal structure
    of the data type.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**。通过仅暴露函数，你隐藏了数据类型的内部结构。'
- en: '**Flexibility**. Functions are more flexible than pattern matching -- they
    can be composed, partially applied, etc.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**。函数比模式匹配更灵活 -- 它们可以组合，部分应用等。'
- en: '**Mapping**. With a catamorphism in hand you can easily create functions that
    map the various cases to new structures.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**。有了范畴折叠，你可以轻松地创建将各种情况映射到新结构的函数。'
- en: It's true that most of these benefits apply to non-recursive types as well,
    but recursive types tend to be more complex so the benefits of encapsulation,
    flexibility, etc. are correspondingly stronger.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数这些好处也适用于非递归类型，但递归类型往往更复杂，因此封装、灵活性等好处相应更强。
- en: In the following sections, we'll look at the last three points in more detail.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地看一下最后三点。
- en: Using function parameters to hide internal structure
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数参数隐藏内部结构
- en: The first benefit is that a catamorphism abstracts out the internal design.
    By using functions, the client code is somewhat isolated from the internal structure.
    Again, you can think of the Visitor pattern as analogous in the OO world.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个好处是范畴折叠将内部设计抽象出来。通过使用函数，客户端代码与内部结构有些隔离。同样，你可以将访问者模式视为面向对象世界中的类比。
- en: For example, if all the clients used the catamorphism function rather than pattern
    matching, I could safely rename cases, and even, with a bit of care, add or remove
    cases.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果所有客户端都使用范畴折叠函数而不是模式匹配，我可以安全地重命名情况，甚至在小心的情况下添加或删除情况。
- en: 'Here''s an example. Let''s say that I had a earlier design for `Gift` that
    didn''t have the `WithACard` case. I''ll call it version 1:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。假设我之前为`Gift`设计了一个没有`WithACard`情况的版本。我将其称为版本1：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And say that we built and published a catamorphism function for that structure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们构建并发布了针对该结构的范畴折叠函数：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this has only *four* function parameters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只有*四*个函数参数。
- en: 'Now suppose that version 2 of `Gift` comes along, which adds the `WithACard`
    case:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设`Gift`的第2个版本出现，添加了`WithACard`情况：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: and now there are five cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有五种情况。
- en: Often, when we add a new case, we *want* to break all the clients and force
    them to deal with the new case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，当我们添加一个新情况时，*希望*打破所有客户端，强迫他们处理新情况。
- en: 'But sometimes, we don''t. And so we can stay compatible with the original `cataGift`
    by handling the extra case silently, like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时候，我们不这样做。因此，我们可以通过默默处理额外情况来保持与原始`cataGift`的兼容性，就像这样：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function still has only four function parameters -- there is no special
    behavior for the `WithACard` case.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数仍然只有四个函数参数 -- 对于`WithACard`情况没有特殊行为。
- en: There are a number of alternative ways of being compatible, such as returning
    a default value. The important point is that the clients are not aware of the
    change.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他兼容的替代方法，比如返回一个默认值。重要的是客户端不知道这个变化。
- en: '**Aside: Using active patterns to hide data**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**另外：使用活动模式隐藏数据**'
- en: While we're on the topic of hiding the structure of a type, I should mention
    that you can also use active patterns to do this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到隐藏类型结构时，我应该提到你也可以使用活动模式来做到这一点。
- en: For example, we could create a active pattern for the first four cases, and
    ignore the `WithACard` case.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为前四种情况创建一个活动模式，并忽略`WithACard`情况。
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The clients can pattern match on the four cases without knowing that the new
    case even exists:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以在不知道新情况存在的情况下对这四种情况进行模式匹配：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Case-handling functions vs. pattern matching
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理情况的函数 vs. 模式匹配
- en: Catamorphisms use function parameters, and as noted above, functions are more
    flexible than pattern matching due to tools such composition, partial application,
    etc.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Catamorphisms使用函数参数，正如上面所述，函数比模式匹配更灵活，因为可以使用组合、部分应用等工具。
- en: Here's an example where all the "container" cases are ignored, and only the
    "content" cases are handled.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，其中所有“容器”情况都被忽略，只处理“内容”情况。
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And here it is in use, with the two remaining cases handled "inline" using
    piping:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的使用方式，剩下的两种情况使用管道“内联”处理：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course this could be done with pattern matching, but being able to work with
    the existing `cataGift` function directly makes life easier.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也可以通过模式匹配来完成，但直接使用现有的`cataGift`函数可以让生活更轻松。
- en: Using catamorphisms for mapping
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用catamorphisms进行映射
- en: I said above that a catamorphism is a function that "collapses" a recursive
    type into a new value. For example, in `totalCost`, the recursive gift structure
    was collapsed into a single cost value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，catamorphism是一个将递归类型“折叠”为新值的函数。例如，在`totalCost`中，递归的礼物结构被折叠成一个单一的成本值。
- en: But a "single value" can be more than just a primitive -- it can be a complicated
    structure too, such as a another recursive structure.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是“单一值”不仅仅是一个原始值 -- 它也可以是一个复杂的结构，比如另一个递归结构。
- en: In fact, catamorphisms are great for mapping one kind of structure onto another,
    especially if they are very similar.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，catamorphisms非常适合将一种结构映射到另一种结构，特别是它们非常相似的情况。
- en: For example, let's say that I have a chocolate-loving room-mate who will stealthily
    remove and devour any chocolate in a gift, leaving the wrapping untouched, but
    discarding the box and gift card.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我有一个喜欢巧克力的室友，他会偷偷拿走并吃掉礼物中的任何巧克力，留下包装不动，但丢弃盒子和礼品卡。
- en: 'What''s left at the end is a "gift minus chocolate" that we can model as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后剩下的是一个“减去巧克力的礼物”，我们可以这样建模：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can easily map from a `Gift` to a `GiftMinusChocolate`, because the cases
    are almost parallel.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地从`礼物`映射到`减去巧克力的礼物`，因为这些情况几乎是平行的。
- en: A `Book` is passed through untouched.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`书`被保持不变地传递。
- en: '`Chocolate` is eaten and replaced with an `Apology`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巧克力被吃掉，然后用一个`道歉`替换。
- en: The `Wrapped` case is passed through untouched.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`包装`情况被保持不变地传递。'
- en: The `Box` and `WithACard` cases are ignored.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`盒子`和`带卡片`的情况被忽略。'
- en: 'Here''s the code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And if we test...
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试...
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Deep copying
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度复制
- en: One more thing. Remember that each case-handling function takes the data associated
    with that case? That means that we can just use *the original case constructors*
    as the functions!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事。记住每个情况处理函数都带有与该情况相关联的数据吗？这意味着我们可以直接使用*原始情况构造函数*作为函数！
- en: 'To see what I mean, let''s define a function called `deepCopy` that clones
    the original value. Each case handler is just the corresponding case constructor:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我的意思，让我们定义一个名为`deepCopy`的函数，它克隆原始值。每个情况处理程序只是相应的情况构造函数：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can simplify this further by removing the redundant parameters for each
    handler:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除每个处理程序的冗余参数进一步简化这个过程：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can test that this works yourself:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己测试这个是否有效：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So that leads to another way of thinking about a catamorphism:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了另一种思考catamorphism的方式：
- en: A catamorphism is a function for a recursive type such that when you pass in
    the type's case constructors, you get a "clone" function.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Catamorphism是适用于递归类型的函数，当您传入类型的情况构造函数时，您会得到一个“克隆”函数。
- en: Mapping and transforming in one pass
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在一次遍历中进行映射和转换
- en: A slight variant on `deepCopy` allows us to recurse through an object and change
    bits of it as we do so.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对`deepCopy`进行轻微变体，允许我们递归遍历对象并在此过程中更改其中的位。
- en: For example, let's say I don't like milk chocolate. Well, I can write a function
    that upgrades the gift to better quality chocolate and leaves all the other cases
    alone.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我不喜欢牛奶巧克力。好吧，我可以编写一个函数，将礼物升级为更好质量的巧克力，同时保持所有其他情况不变。
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here it is in use:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用的示例：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you are thinking that this is beginning to smell like a `map`, you'd be right.
    We'll look at generic maps in the [sixth post, as part of a discussion of generic
    recursive types](recursive-types-and-folds-3b.html#map).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这开始有点像`map`，那么你是对的。我们将在[第六篇文章中看到通用映射，作为对通用递归类型讨论的一部分](recursive-types-and-folds-3b.html#map)。
- en: Rules for creating catamorphisms
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建catamorphisms的规则
- en: 'We saw above that creating a catamorphism is a mechanical process:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到创建catamorphism是一个机械过程：
- en: Create a function parameter to handle each case in the structure.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数参数来处理结构中的每种情况。
- en: For non-recursive cases, pass the function parameter all the data associated
    with that case.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非递归情况，将函数参数传递给与该情况相关的所有数据。
- en: 'For recursive cases, perform two steps:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于递归情况，执行两个步骤：
- en: First, call the catamorphism recursively on the nested value.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在嵌套值上递归调用猫摄影术。
- en: Then pass the handler all the data associated with that case, but with the result
    of the catamorphism replacing the original nested value.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将处理程序传递给该情况的所有数据，但将猫摄影术的结果替换原始嵌套值。
- en: Let's now see if we can apply these rules to create catamorphisms in other domains.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看是否可以应用这些规则来在其他领域创建猫摄影术。
- en: '* * *'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We've seen in this post how to define a recursive type, and been introduced
    to catamorphisms.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本文中我们已经看到如何定义递归类型，并介绍了猫摄影术。
- en: In the [next post](recursive-types-and-folds-1b.html) we'll uses these rules
    to create catamorphisms for some other domains.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](recursive-types-and-folds-1b.html)中，我们将使用这些规则为其他领域创建猫摄影术。
- en: See you then!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们下次见！
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/60938b4417d12cfa0a97).*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文的源代码可在[此代码片段](https://gist.github.com/swlaschin/60938b4417d12cfa0a97)中找到。*'
- en: Catamorphism examples
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猫摄影术示例
- en: Catamorphism examples
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猫摄影术示例
- en: This post is the second in a series.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是系列中的第二篇。
- en: In the [previous post](recursive-types-and-folds1.html), I introduced "catamorphisms",
    a way of creating functions for recursive types, and listed some rules which can
    be used to implement them mechanically. In this post, we'll use these rules to
    implement catamorphisms for some other domains.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一篇文章](recursive-types-and-folds1.html)中，我介绍了“猫摄影术”，这是一种创建递归类型函数的方法，并列举了一些可用于机械实现它们的规则。在本文中，我们将使用这些规则来为其他领域实现猫摄影术。
- en: Series contents
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s the contents of this series:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本系列的内容：
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1部分：递归类型和猫摄影术简介**'
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一个简单的递归类型](recursive-types-and-folds1.html#basic-recursive-type)'
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参数化所有事物](recursive-types-and-folds1.html#parameterize)'
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍猫摄影术](recursive-types-and-folds1.html#catamorphisms)'
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[猫摄影术的好处](recursive-types-and-folds1.html#benefits)'
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建猫摄影术的规则](recursive-types-and-folds1.html#rules)'
- en: '**Part 2: Catamorphism examples**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2部分：猫摄影术示例**'
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[猫摄影术示例：文件系统领域](recursive-types-and-folds-1b.html#file-system)'
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[猫摄影术示例：产品领域](recursive-types-and-folds-1b.html#product)'
- en: '**Part 3: Introducing folds**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3部分：介绍折叠**'
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我们猫摄影术实现中的一个缺陷](recursive-types-and-folds-2.html#flaw)'
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍`fold`](recursive-types-and-folds-2.html#fold)'
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠的问题](recursive-types-and-folds-2.html#problems)'
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数用作累加器](recursive-types-and-folds-2.html#functions)'
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍`foldback`](recursive-types-and-folds-2.html#foldback)'
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建折叠的规则](recursive-types-and-folds-2.html#rules)'
- en: '**Part 4: Understanding folds**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第4部分：理解折叠**'
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[迭代与递归的比较](recursive-types-and-folds-2b.html#iteration)'
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠示例：文件系统领域](recursive-types-and-folds-2b.html#file-system)'
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于“折叠”的常见问题](recursive-types-and-folds-2b.html#questions)'
- en: '**Part 5: Generic recursive types**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5部分：通用递归类型**'
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[链表：一个通用递归类型](recursive-types-and-folds-3.html#linkedlist)'
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使礼物领域变得通用](recursive-types-and-folds-3.html#revisiting-gift)'
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用的容器类型](recursive-types-and-folds-3.html#container)'
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现礼物领域的第三种方法](recursive-types-and-folds-3.html#another-gift)'
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抽象还是具体？比较这三种设计](recursive-types-and-folds-3.html#compare)'
- en: '**Part 6: Trees in the real world**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 6 部分：现实世界中的树**'
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用的 Tree 类型](recursive-types-and-folds-3b.html#tree)'
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[现实世界中的 Tree 类型](recursive-types-and-folds-3b.html#reuse)'
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射 Tree 类型](recursive-types-and-folds-3b.html#map)'
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：创建目录列表](recursive-types-and-folds-3b.html#listing)'
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：并行 grep](recursive-types-and-folds-3b.html#grep)'
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将文件系统存储在数据库中](recursive-types-and-folds-3b.html#database)'
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将树序列化为 JSON](recursive-types-and-folds-3b.html#tojson)'
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化树](recursive-types-and-folds-3b.html#fromjson)'
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化树 - 带错误处理](recursive-types-and-folds-3b.html#json-with-error-handling)'
- en: '* * *'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Rules for creating catamorphisms
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 catamorphisms 的规则
- en: 'We saw in the previous post that creating a catamorphism is a mechanical process,
    and the rules were:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一篇帖子中看到，创建 catamorphism 是一个机械过程，规则是：
- en: Create a function parameter to handle each case in the structure.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为结构中的每种情况创建一个函数参数来处理。
- en: For non-recursive cases, pass the function parameter all the data associated
    with that case.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非递归情况，将函数参数传递给与该情况相关联的所有数据。
- en: 'For recursive cases, perform two steps:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于递归情况，执行两个步骤：
- en: First, call the catamorphism recursively on the nested value.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在嵌套值上递归调用 catamorphism。
- en: Then pass the handler all the data associated with that case, but with the result
    of the catamorphism replacing the original nested value.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将处理程序传递给该情况相关联的所有数据，但是结果 catamorphism 替换了原始的嵌套值。
- en: Let's now see if we can apply these rules to create catamorphisms in other domains.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看是否可以应用这些规则来创建其他领域的 catamorphisms。
- en: '* * *'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Catamorphism example: File system domain'
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Catamorphism 示例：文件系统领域
- en: 'Let''s start with a very crude model of a file system:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简陋的文件系统模型开始：
- en: Each file has a name and a size.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件都有一个名称和一个大小。
- en: Each directory has a name and a size and a list of subitems.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个目录都有一个名称、一个大小和一个子项列表。
- en: 'Here''s how I might model that:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我可能会模拟的方式：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I admit it's a pretty bad model, but it's just good enough for this example!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认这是一个相当糟糕的模型，但对于这个例子来说已经足够好了！
- en: 'Ok, here are some sample files and directories:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里有一些示例文件和目录：
- en: '[PRE38]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Time to create the catamorphism!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建 **catamorphism** 了！
- en: Let's start by looking at the signatures to figure out what we need.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看签名开始，找出我们需要什么。
- en: The `File` constructor takes a `File` and returns a `FileSystemItem`. Using
    the guidelines above, the handler for the `File` case needs to have the signature
    `File -> 'r`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 构造函数接受一个 `File` 并返回一个 `FileSystemItem`。根据上述指南，`File` 情况的处理程序需要具有签名 `File
    -> ''r`。'
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That''s simple enough. Let''s put together an initial skeleton of `cataFS`,
    as I''ll call it:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。让我们组合一个初始的 `cataFS` 框架，我将其称为：
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Directory` case is more complicated. If we naively applied the guidelines
    above, the handler for the `Directory` case would have the signature `Directory
    -> 'r`, but that would be incorrect, because the `Directory` record itself contains
    a `FileSystemItem` that needs to be replaced with an `'r` too. How can we do this?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directory` 情况更加复杂。如果我们天真地应用上述指南，`Directory` 情况的处理程序将具有签名 `Directory -> ''r`，但那将是不正确的，因为
    `Directory` 记录本身包含一个需要用 `''r` 替换的 `FileSystemItem`。我们该怎么办？'
- en: One way is to "explode" the `Directory` record into a tuple of `(string,int,FileSystemItem
    list)`, and then replace the `FileSystemItem` with `'r` in there too.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将 `Directory` 记录 "爆炸" 成一个元组 `(string,int,FileSystemItem list)`，然后在其中也用
    `'r` 替换 `FileSystemItem`。
- en: 'In other words, we have this sequence of transformations:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们有以下转换序列：
- en: '[PRE41]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Another issue is that the data associated with the Directory case is a *list*
    of `FileSystemItem`s. How can we convert that into a list of `'r`s?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是与 Directory 情况相关联的数据是 `FileSystemItem` 的 *列表*。我们怎样才能将其转换为 `'r` 的列表？
- en: Well, the `recurse` helper turns a `FileSystemItem` into an `'r`, so we can
    just use `List.map` passing in `recurse` as the mapping function, and that will
    give us the list of `'r`s we need!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，`recurse`助手将`FileSystemItem`转换为`'r`，所以我们可以简单地使用`List.map`，将`recurse`作为映射函数传入，这将给我们提供所需的`'r`列表！
- en: 'Putting it all together, we get this implementation:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容组合起来，我们得到了这个实现：
- en: '[PRE42]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'and if we look at the type signature, we can see that it is just what we want:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下类型签名，我们会发现它正是我们想要的：
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So we're done. It's a bit complicated to set up, but once built, we have a nice
    reusable function that can be the basis for many others.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们完成了。设置起来有点复杂，但一旦建立起来，我们就有了一个不错的可重复使用的函数，可以成为许多其他函数的基础。
- en: 'File system domain: `totalSize` example'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统域：`totalSize`示例
- en: Alrighty then, let's use it in practice.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们实际使用它。
- en: 'To start with, we can easily define a `totalSize` function that returns the
    total size of an item and all its subitems:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们可以轻松地定义一个`totalSize`函数，它返回项目及其所有子项目的总大小：
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And here are the results:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是结果：
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'File system domain: `largestFile` example'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统域：`largestFile`示例
- en: How about a more complicated function, such as "what is the largest file in
    the tree?"
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理更复杂的函数，比如“树中最大的文件是什么”？
- en: Before we start this one, let's think about what it should return. That is,
    what is the `'r`?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们想一想它应该返回什么。也就是说，什么是`'r`？
- en: You might think that it's just a `File`. But what if the subdirectory is empty
    and there *are* no files?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为它只是一个`File`。但是如果子目录为空，而且没有文件呢？
- en: So let's make `'r` a `File option` instead.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将`'r`改为`File option`。
- en: 'The function for the `File` case should return `Some file` then:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`情况的函数应该返回`Some file`：'
- en: '[PRE46]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The function for the `Directory` case needs more thought:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directory`情况的函数需要更多的思考：'
- en: If list of subfiles is empty, then return `None`
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子文件列表为空，则返回`None`。
- en: If list of subfiles is non-empty, then return the largest one
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子文件列表非空，则返回最大的子文件。
- en: '[PRE47]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: But remember that `'r` is not a `File` but a `File option`. So that means that
    `subfiles` is not a list of files, but a list of `File option`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请记住，`'r`不是`File`而是`File option`。这意味着`subfiles`不是文件列表，而是`File option`的列表。
- en: Now, how can we find the largest one of these? We probably want to use `List.maxBy`
    and pass in the size. But what is the size of a `File option`?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们怎样才能找到这些中最大的一个呢？我们可能想要使用`List.maxBy`并传入大小。但是`File option`的大小是多少？
- en: 'Let''s write a helper function to provide the size of a `File option`, using
    this logic:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个辅助函数，提供`File option`的大小，使用以下逻辑：
- en: If the `File option` is `None`, return 0
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`File option`为`None`，则返回0
- en: Else return the size of the file inside the option
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则返回选项内文件的大小
- en: 'Here''s the code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Putting it all together then, we have our `largestFile` function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，我们有了我们的`largestFile`函数：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we test it, we get the results we expect:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试它，我们会得到我们预期的结果：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, a little bit tricky to set up, but no more than if we had to write it
    from scratch without using a catamorphism at all.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，设置起来有点棘手，但不比完全不使用范畴形式写起来更复杂。
- en: '* * *'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Catamorphism example: Product domain'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范畴形式示例：Product域
- en: 'Let''s work with a slightly more complicated domain. This time, imagine that
    we make and sell products of some kind:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来处理一个稍微复杂的领域。这一次，想象一下我们制造和销售某种产品：
- en: Some products are bought, with an optional vendor.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些产品是购买的，有时会有可选供应商。
- en: Some products are made on our premises, built from subcomponents, where a subcomponent
    is some quantity of another product.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些产品是在我们的场地上制造的，由子组件构建，其中子组件是另一种产品的某个数量。
- en: 'Here''s the domain modelled as types:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是以类型建模的域：
- en: '[PRE51]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that the types are mutally recursive. `Product` references `MadeProduct`
    which references `Component` which in turn references `Product` again.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些类型是相互递归的。`Product`引用`MadeProduct`，后者引用`Component`，后者又引用`Product`。
- en: 'Here are some example products:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些示例产品：
- en: '[PRE52]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now to design the catamorphism, we need to do is replace the `Product` type
    with `'r` in all the constructors.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要设计这个范畴形式，我们需要做的就是在所有构造函数中将`Product`类型替换为`'r`。
- en: 'Just as with the previous example, the `Bought` case is easy:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，`Bought`情况很容易：
- en: '[PRE53]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `Made` case is trickier. We need to expand the `MadeProduct` into a tuple.
    But that tuple contains a `Component`, so we need to expand that as well. Finally
    we get to the inner `Product`, and we can then mechanically replace that with
    `'r`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`Made`情况更加棘手。我们需要将`MadeProduct`扩展为一个元组。但是该元组包含一个`Component`，所以我们也需要扩展它。最后我们到达内部的`Product`，然后可以机械地将其替换为`''r`。'
- en: 'Here''s the sequence of transformations:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是转换的顺序：
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When implementing the `cataProduct` function we need to the same kind of mapping
    as before, turning a list of `Component` into a list of `(int,'r)`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`cataProduct`函数时，我们需要与之前相同类型的映射，将`Component`的列表转换为`(int,'r)`的列表。
- en: 'We''ll need a helper for that:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个辅助函数：
- en: '[PRE55]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can see that this uses the `recurse` function to turn the inner product
    (`comp.product`) into an `'r` and then make a tuple `int * 'r`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里使用`recurse`函数将内部产品（`comp.product`）转换为`'r`，然后制作一个元组`int * 'r`。
- en: 'With `convertComponentToTuple` available, we can convert all the components
    to tuples using `List.map`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`convertComponentToTuple`可用，我们可以使用`List.map`将所有组件转换为元组：
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`componentTuples` is a list of `(int * ''r)`, which is just what we need for
    the `fMade` function.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentTuples`是一个`(int * ''r)`的列表，这正是我们需要的`fMade`函数。'
- en: 'The complete implementation of `cataProduct` looks like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`cataProduct`的完整实现如下：'
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Product domain: `productWeight` example'
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品领域：`productWeight`示例
- en: We can now use `cataProduct` to calculate the weight, say.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`cataProduct`来计算权重，比如说。
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s test it interactively to make sure it works:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行交互式测试以确保它能正常工作：
- en: '[PRE59]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That's as we expect.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如我们所期望的。
- en: Try implementing `productWeight` from scratch, without using a helper function
    like `cataProduct`. Again, it's do-able, but you'll probably waste quite bit of
    time getting the recursion logic right.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从头开始实现`productWeight`，而不使用像`cataProduct`这样的辅助函数。再次强调，这是可行的，但你可能会浪费相当多的时间来理清递归逻辑。
- en: 'Product domain: `mostUsedVendor` example'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品领域：`mostUsedVendor`示例
- en: Let's do a more complex function now. What is the most used vendor?
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做一个更复杂的函数。谁是最常用的供应商？
- en: 'The logic is simple: each time a product references a vendor, we''ll give that
    vendor one point, and the vendor with the highest score wins.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单：每当一个产品引用一个供应商，我们就给该供应商一个点，得分最高的供应商获胜。
- en: Again, let's think about what it should return. That is, what is the `'r`?
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们考虑它应该返回什么。也就是说，`'r`是什么？
- en: You might think that it's just a score of some kind, but we also need to know
    the vendor name. Ok, a tuple then. But what if there are no vendors?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这只是某种得分，但我们还需要知道供应商的名称。好的，那就是一个元组。但如果没有供应商呢？
- en: So let's make `'r` a `VendorScore option`, where we are going to create a little
    type `VendorScore`, rather than using a tuple.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此让我们将`'r`设为`VendorScore option`，我们将创建一个小类型`VendorScore`，而不���使用元组。
- en: '[PRE60]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ll also define some helpers to get data from a `VendorScore` easily:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一些辅助函数，以便轻松从`VendorScore`中获取数据：
- en: '[PRE61]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, you can't determine the most used vendor over until you have results from
    the entire tree, so both the `Bought` case and the `Made` case need to return
    a list which can added to as we recurse up the tree. And then, after getting *all*
    the scores, we'll sort descending to find the vendor with the highest one.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在获得整个树的结果之前，你无法确定最常用的供应商，因此`Bought`情况和`Made`情况都需要返回一个列表，当我们递归遍历树时可以添加到其中。然后，在获取*所有*分数之后，我们将按降序排序以找到得分最高的供应商。
- en: So we have to make `'r` a `VendorScore list`, not just an option!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们必须将`'r`变为`VendorScore list`，而不仅仅是一个选项！
- en: 'The logic for the `Bought` case is then:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bought`情况的逻辑是：'
- en: If the vendor is present, return a `VendorScore` with score = 1, but as a one-element
    list rather than as a single item.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果供应商存在，则返回一个得分为1的`VendorScore`，但作为一个元素列表而不是单个项目。
- en: If the vendor is missing, return an empty list.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果供应商缺失，则返回一个空列表。
- en: '[PRE62]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The function for the `Made` case is more complicated.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`Made`情况的函数更复杂。'
- en: If list of subscores is empty, then return an empty list.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子分数列表为空，则返回一个空列表。
- en: If list of subscores is non-empty, we sum them by vendor and then return the
    new list.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子分数列表非空，则按供应商对它们求和，然后返回新列表。
- en: But the list of subresults passed into the `fMade` function will not be a list
    of subscores, it will be a list of tuples, `qty * 'r` where `'r` is `VendorScore
    list`. Complicated!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 但传递给`fMade`函数的子结果列表将不是子分数列表，而是一个元组列表，`qty * 'r`其中`'r`是`VendorScore list`。复杂！
- en: 'What we need to do then is:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们需要做的是：
- en: Turn `qty * 'r` into just `'r` because we don't care about the qty in this case.
    We now have a list of `VendorScore list`. We can use `List.map snd` to do this.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`qty * 'r`转换为`'r`，因为在这种情况下我们不关心数量。现在我们有一个`VendorScore list`的列表。我们可以使用`List.map
    snd`来做这个。
- en: But now we would have a list of `VendorScore list`. We can flatten a list of
    lists into a simple list using `List.collect`. And in fact, using `List.collect
    snd` can do both steps in one go.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但现在我们将得到一个 `VendorScore list` 列表。我们可以使用 `List.collect` 将列表的列表展平为一个简单的列表。事实上，使用
    `List.collect snd` 可以一次完成两个步骤。
- en: Group this list by vendor so that we have a list of `key=vendor; values=VendorScore
    list` tuples.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这个列表按供应商分组，这样我们就得到了一个 `key=vendor; values=VendorScore list` 元组的列表。
- en: Sum up the scores for each vendor (`values=VendorScore list`) into a single
    value, so that we have a list of `key=vendor; values=VendorScore` tuples.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每个供应商的分数进行求和（`values=VendorScore list`），得到一个单一的值，这样我们就有了一个 `key=vendor; values=VendorScore`
    元组的列表。
- en: At this point the `cata` function will return a `VendorScore list`. To get the
    highest score, use `List.sortByDescending` then `List.tryHead`. Note that `maxBy`
    won't work because the list could be empty.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`cata` 函数将返回一个 `VendorScore list`。要获取最高分，请使用 `List.sortByDescending` 然后 `List.tryHead`。请注意，`maxBy`
    不会起作用，因为列表可能为空。
- en: 'Here''s the complete `mostUsedVendor` function:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整的 `mostUsedVendor` 函数：
- en: '[PRE63]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now let''s test it:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来测试一下：
- en: '[PRE64]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This isn't the only possible implementation of `fMade`, of course. I could have
    used `List.fold` and done the whole thing in one pass, but this version seems
    like the most obvious and readable implementation.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是 `fMade` 的唯一可能实现。我本可以使用 `List.fold`，一次完成所有操作，但这个版本似乎是最明显和可读性最强的实现。
- en: It's also true that I could have avoided using `cataProduct` altogether and
    written `mostUsedVendor` from scratch. If performance is an issue, then that might
    be a better approach, because the generic catamorphism creates intermediate values
    (such as the list of `qty * VendorScore option`) which are over general and potentially
    wasteful.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我完全可以避免使用 `cataProduct`，从头开始编写 `mostUsedVendor`。如果性能是一个问题，那么这可能是一个更好的方法，因为通用的折叠函数会创建中间值（比如
    `qty * VendorScore option` 的列表），这些值过于一般化，可能是浪费的。
- en: On other hand, by using the catamorphism, I could focus on the counting logic
    only and ignore the recursion logic.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过使用对折叠函数，我可以只专注于计数逻辑，而忽略递归逻辑。
- en: So as always, you should consider the pros and cons of reuse vs. creating from
    scratch; the benefits of writing common code once and using it in a standardized
    way, versus the performance but extra effort (and potential bugginess) of custom
    code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该始终权衡重用和从头开始创建之间的利弊；编写通用代码一次并以标准化的方式使用它的好处，与自定义代码的性能但额外的努力（和潜在的错误）之间的权衡。
- en: '* * *'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We've seen in this post how to define a recursive type, and been introduced
    to catamorphisms.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇中，我们看到了如何定义递归类型，并介绍了对折叠函数。
- en: 'And we have also seen some uses for catamorphisms:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一些对折叠函数的用法：
- en: Any function that "collapses" a recursive type, such as `Gift -> 'r`, can be
    written in terms of the catamorphism for that type.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何“折叠”递归类型的函数，比如 `Gift -> 'r`，都可以根据该类型的对折叠函数来编写。
- en: Catamorphisms can be used to hide the internal structure of the type.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对折叠函数可用于隐藏类型的内部结构。
- en: Catamorphisms can be used to create mappings from one type to another by tweaking
    the functions that handle each case.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调整处理每种情况的函数，可以使用对折叠函数将一个类型映射到另一个类型。
- en: Catamorphisms can be used to create a clone of the original value by passing
    in the type's case constructors.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对折叠函数可用于通过传递类型的 case 构造函数来创建原始值的克隆。
- en: But all is not perfect in the land of catamorphisms. In fact, all the catamorphism
    implementations on this page have a potentially serious flaw.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在对折叠函数的国度中并非一切完美。实际上，本页面上所有的对折叠函数的实现都存在一个潜在的严重缺陷。
- en: In the [next post](recursive-types-and-folds-2.html) we'll see what can go wrong
    with them, how to fix them, and in the process look at the various kinds of "fold".
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](recursive-types-and-folds-2.html)中，我们将看到它们可能出现的问题，如何修复它们，并在此过程中查看各种类型的“折叠”。
- en: See you then!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 到时见！
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/dc2b3fcdca319ca8be60).*'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文的源代码可以在[此代码片段](https://gist.github.com/swlaschin/dc2b3fcdca319ca8be60)中找到。*'
- en: '*UPDATE: Fixed logic error in `mostUsedVendor` as pointed out by Paul Schnapp
    in comments. Thanks, Paul!*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新：根据保罗·施纳普在评论中指出的逻辑错误，修复了 `mostUsedVendor`。谢谢，保罗！*'
- en: Introducing Folds
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入折叠
- en: Introducing Folds
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入折叠
- en: This post is the third in a series.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是系列文章的第三篇。
- en: In the [first post](recursive-types-and-folds1.html), I introduced "catamorphisms",
    a way of creating functions for recursive types, and in the [second post](recursive-types-and-folds-1b.html),
    we created a few catamorphism implementations.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一篇文章](recursive-types-and-folds1.html)中，我介绍了“catamorphisms”，一种为递归类型创建函数的方法，在[第二篇文章](recursive-types-and-folds-1b.html)中，我们创建了一些
    catamorphism 的实现。
- en: But at the end of the previous post, I noted that all the catamorphism implementations
    so far have had a potentially serious flaw.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 但在上一篇文章的结尾，我指出到目前为止，所有的 catamorphism 实现都存在一个潜在的严重缺陷。
- en: In this post, we'll look at the flaw and how to work around it, and in the process
    look at folds, tail-recursion and the difference between "left fold" and "right
    fold".
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇文章中，我们将看到这个缺陷以及如何解决它，并在此过程中看到折叠、尾递归以及“左折叠”和“右折叠”之间的区别。
- en: Series contents
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s the contents of this series:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列的内容如下：
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 1 部分：递归类型和 catamorphisms 介绍**'
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一个简单的递归类型](recursive-types-and-folds1.html#basic-recursive-type)'
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参数化所有内容](recursive-types-and-folds1.html#parameterize)'
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[catamorphisms 的好处](recursive-types-and-folds1.html#benefits)'
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建 catamorphism 的规则](recursive-types-and-folds1.html#rules)'
- en: '**Part 2: Catamorphism examples**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 2 部分：Catamorphism 示例**'
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Catamorphism 示例：文件系统领域](recursive-types-and-folds-1b.html#file-system)'
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Catamorphism 示例：产品领域](recursive-types-and-folds-1b.html#product)'
- en: '**Part 3: Introducing folds**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 3 部分：折叠介绍**'
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我们 catamorphism 实现中的一个缺陷](recursive-types-and-folds-2.html#flaw)'
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 `fold`](recursive-types-and-folds-2.html#fold)'
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠的问题](recursive-types-and-folds-2.html#problems)'
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数用作累加器](recursive-types-and-folds-2.html#functions)'
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 `foldback`](recursive-types-and-folds-2.html#foldback)'
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建折叠的规则](recursive-types-and-folds-2.html#rules)'
- en: '**Part 4: Understanding folds**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 4 部分：理解折叠**'
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[迭代 vs. 递归](recursive-types-and-folds-2b.html#iteration)'
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠示例：文件系统领域](recursive-types-and-folds-2b.html#file-system)'
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于“折叠”的常见问题](recursive-types-and-folds-2b.html#questions)'
- en: '**Part 5: Generic recursive types**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 5 部分：通用递归类型**'
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[LinkedList：通用的递归类型](recursive-types-and-folds-3.html#linkedlist)'
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使 Gift 领域通用化](recursive-types-and-folds-3.html#revisiting-gift)'
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用的容器类型](recursive-types-and-folds-3.html#container)'
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现 Gift 领域的第三种方式](recursive-types-and-folds-3.html#another-gift)'
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抽象还是具体？比较三种设计](recursive-types-and-folds-3.html#compare)'
- en: '**Part 6: Trees in the real world**'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 6 部分：现实世界中的树**'
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用的树类型](recursive-types-and-folds-3b.html#tree)'
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[现实世界中的树类型](recursive-types-and-folds-3b.html#reuse)'
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射树类型](recursive-types-and-folds-3b.html#map)'
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：创建目录列表](recursive-types-and-folds-3b.html#listing)'
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：并行 grep](recursive-types-and-folds-3b.html#grep)'
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将文件系统存储在数据库中](recursive-types-and-folds-3b.html#database)'
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将树序列化为 JSON](recursive-types-and-folds-3b.html#tojson)'
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化树](recursive-types-and-folds-3b.html#fromjson)'
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化树 - 带错误处理](recursive-types-and-folds-3b.html#json-with-error-handling)'
- en: '* * *'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A flaw in our catamorphism implementation
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的折叠实现中的一个缺陷
- en: Before we look at the flaw, let's first review the recursive type `Gift` and
    the associated catamorphism `cataGift` that we created for it.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看缺陷之前，让我们首先回顾一下递归类型`Gift`和我们为其创建的相关折叠`cataGift`。
- en: 'Here''s the domain:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这是领域：
- en: '[PRE65]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here are some example values that we''ll be using in this post:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本文中将要使用的一些示例值：
- en: '[PRE66]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here''s the catamorphism:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这是折叠：
- en: '[PRE67]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'and here is a `totalCostUsingCata` function built using `cataGift`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`cataGift`构建的`totalCostUsingCata`函数：
- en: '[PRE68]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: What's the flaw?
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有什么缺陷？
- en: So what is wrong with this implementation? Let's stress test it and find out!
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个实现有什么问题呢？让我们对其进行压力测试并找出！
- en: What we'll do is create a `Box` inside a `Box` inside a `Box` a very large number
    of times, and see what happens.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常多次嵌套的`Box`内部的`Box`内部的`Box`，看看会发生什么。
- en: 'Here''s a little helper function to create nested boxes:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建嵌套框的小助手函数：
- en: '[PRE69]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s try it to make sure it works:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下，确保它能正常工作：
- en: '[PRE70]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now try running `totalCostUsingCata` with these deeply nested boxes:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用这些深度嵌套的盒子运行`totalCostUsingCata`：
- en: '[PRE71]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: So far so good.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。
- en: 'But if we use much larger numbers, we soon run into a stack overflow exception:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们使用更大的数字，很快就会遇到堆栈溢出异常：
- en: '[PRE72]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The exact number which causes an error depends on the environment, available
    memory, and so on. But it is a certainty that you will run into it when you start
    using largish numbers.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 导致错误的确切数字取决于环境、可用内存等。但可以肯定的是，当你开始使用较大的数字时，你会遇到这个问题。
- en: Why is this happening?
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？
- en: The problem with deep recursion
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度递归的问题
- en: 'Recall that the definition of the cost for the Boxed case (`fBox`) was `innerCost
    + 1.0m`. And what is the inner cost? That''s another box too, so we end up with
    a chain of calculations looking like this:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`fBox`（Boxed 案例的成本定义）的定义是`innerCost + 1.0m`。内部成本是什么？那也是另一个盒子，所以我们最终得到一个看起来像这样的计算链：
- en: '[PRE73]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In other words, `innerCost1000` has to be calculated before `innerCost999` can
    be calculated, and 999 other inner costs have to be calculated before the top
    level `innerCost` can be calculated.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`innerCost1000`必须在`innerCost999`之前计算，而在顶层`innerCost`可以计算之前，还必须计算其他 999
    个内部成本。
- en: Every level is waiting for its inner cost to be calculated before doing the
    calculation for that level.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别都在等待其内部成本计算完成，然后再进行该级别的计算。
- en: All these unfinished calculations are stacked up waiting for the inner one to
    complete. And when you have too many? Boom! Stack overflow!
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些未完成的计算都堆积在一起，等待内部计算完成。当你有太多时？崩溃！堆栈溢出！
- en: The solution to stack overflows
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈溢出的解决方案
- en: The solution to this problem is simple. Rather than each level waiting for the
    inner cost to be calculated, each level calculates the cost so far, using an accumulator,
    and passes that down to the next inner level. When we get to the bottom level,
    we have the final answer.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题很简单。每个级别不再等待内部成本计算完成，而是使用累加器计算到目前为止的成本，并将其传递给下一个内部级别。当我们到达底层时，我们就有了最终答案。
- en: '[PRE74]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The big advantange of this approach is that all calculations at a particular
    level are *completely finished* before the next lowel level is called. Which means
    that the level and its associated data can be safely discarded from the stack.
    Which means no stack overflow!
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要优点是，在特定级别的所有计算在下一个低级别被调用之前*完全完成*。这意味着该级别及其相关数据可以安全地从堆栈中丢弃。这意味着没有堆栈溢出！
- en: An implementation like this, where the higher levels can be safely discarded,
    is called *tail recursive*.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的实现，其中较高级别可以安全丢弃，被称为*尾递归*。
- en: Reimplementating the `totalCost` function with an accumulator
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用累加器重新实现`totalCost`函数
- en: 'Let''s rewrite the total cost function from scratch, using an accumulator called
    `costSoFar`:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始重新编写总成本函数，使用一个名为`costSoFar`的累加器：
- en: '[PRE75]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'A few things to note:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: The new version of the function has an extra parameter (`costSoFar`). We will
    have to provide an initial value for this (such as zero) when we call it at the
    top level.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的新版本有一个额外的参数（`costSoFar`）。当我们在顶层调用它时，我们将不得不为此提供一个初始值（比如零）。
- en: The non-recursive cases (`Book` and `Chocolate`) are the end points. The take
    the cost so far and add it to their price, and then that is the final result.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非递归情况（`Book`和`Chocolate`）是终点。它们获取到目前为止的成本并将其加到它们的价格中，然后这就是最终结果。
- en: The recursive cases calculate a new `costSoFar` based on the parameter that
    is passed in. The new `costSoFar` is then passed down to the next lower level,
    just as in the example above.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归情况根据传入的参数计算一个新的`costSoFar`。然后将新的`costSoFar`传递给下一个更低的级别，就像上面的例子一样。
- en: 'Let''s stress test this version:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对这个版本进行压力测试：
- en: '[PRE76]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Excellent. Up to one million nested levels without a hiccup.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。最多可以嵌套一百万层而不出现任何问题。
- en: Introducing "fold"
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入“fold”
- en: Now let's apply the same design principle to the catamorphism implementation.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将相同的设计原则应用于范畴实现。
- en: We'll create a new function `foldGift`. We'll introduce an accumulator `acc`
    that we will thread through each level, and the non-recursive cases will return
    the final accumulator.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新函数`foldGift`。我们将引入一个累加器`acc`，我们将通过每个级别传递它，并且非递归情况将返回最终累加器。
- en: '[PRE77]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If we look at the type signature, we can see that it is subtly different. The
    type of the accumulator `'a` is being used everywhere now. The only time where
    the final return type is used is in the two non-recursive cases (`fBook` and `fChocolate`).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下类型签名，我们会发现它略有不同。现在到处都使用累加器`'a`的类型。唯一使用最终返回类型的时��是在两个非递归情况（`fBook`和`fChocolate`）中。
- en: '[PRE78]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Let's look at this more closely, and compare the signatures of the original
    catamorphism from the last post with the signatures of the new `fold` function.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下这一点，并比较上一篇文章中原始范畴的签名与新`fold`函数的签名。
- en: 'First of all, the non-recursive cases:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是非递归情况：
- en: '[PRE79]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see, with "fold", the non-recursive cases take an extra parameter
    (the accumulator) and return the `'r` type.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用“fold”，非递归情况需要一个额外的参数（累加器），并返回`'r`类型。
- en: 'This is a very important point: *the type of the accumulator does not need
    to be the same as the return type.* We will need to take advantage of this shortly.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的观点：*累加器的类型不需要与返回类型相同*。我们很快将需要利用这一点。
- en: What about the recursive cases? How did their signature change?
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况呢？它们的签名如何改变？
- en: '[PRE80]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: For the recursive cases, the structure is identical but all use of the `'r`
    type has been replaced with the `'a` type. The recursive cases do not use the
    `'r` type at all.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递归情况，结构是相同的，但所有对`'r`类型的使用都已替换为`'a`类型。递归情况根本不使用`'r`类型。
- en: Reimplementating the `totalCost` function using fold
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用fold重新实现`totalCost`函数
- en: 'Once again, we can reimplement the total cost function, but this time using
    the `foldGift` function:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以重新实现总成本函数，但这次使用`foldGift`函数：
- en: '[PRE81]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And again, we can process very large numbers of nested boxes without a stack
    overflow:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以处理非常大量的嵌套盒子而不会出现堆栈溢出：
- en: '[PRE82]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Problems with fold
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fold的问题
- en: So using fold solves all our problems, right?
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 所以使用fold解决了我们所有的问题，对吧？
- en: Unfortunately, no.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，不会。
- en: Yes, there are no more stack overflows, but we have another problem now.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，没有更多的堆栈溢出，但现在我们有另一个问题。
- en: Reimplementation of the `description` function
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新实现`description`函数
- en: To see what the problem is, let's revisit the `description` function that we
    created in the first post.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要看问题在哪里，让我们重新访问我们在第一篇文章中创建的`description`函数。
- en: The original one was not tail-recursive, so let's make it safer and reimplement
    it using `foldGift`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 原始版本不是尾递归的，所以让我们更安全地使用`foldGift`重新实现它。
- en: '[PRE83]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let''s see what the output is:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出是什么：
- en: '[PRE84]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: These outputs are wrong! The order of the decorations has been mixed up.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输出是错误的！装饰的顺序被搞乱了。
- en: It's supposed to be a wrapped book with a card, not a book and a card wrapped
    together. And it's supposed to be chocolate in a box, then wrapped, not wrapped
    chocolate in a box!
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是一个包裹着卡片的书，而不是一本书和一张卡片一起包装。而且应该是盒子里的巧克力，然后包装，而不是包装着的巧克力在盒子里！
- en: '[PRE85]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: What has gone wrong?
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么问题？
- en: The answer is that the correct description for each layer depends on the description
    of the layer below. We can't "pre-calculate" the description for a layer and pass
    it down to the next layer using a `descriptionSoFar` accumulator.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，每一层的正确描述取决于下面一层的描述。我们不能“预先计算”一层的描述并将其传递给下一层，使用一个`descriptionSoFar`累加器。
- en: 'But now we have a dilemma: a layer depends on information from the layer below,
    but we want to avoid a stack overflow.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们面临一个困境：一层依赖于下面一层的信息，但我们想避免堆栈溢出。
- en: Using functions as accumulators
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数作为累加器
- en: Remember that the accumulator type does not have to be the same as the return
    type. We can use anything as an accumulator, even a function!
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 记住累加器类型不必与返回类型相同。我们可以使用任何东西作为累加器，甚至是一个函数！
- en: So what we'll do is, rather than passing a `descriptionSoFar` as the accumulator,
    we'll pass a function (`descriptionGenerator` say) that will build the appropriate
    description given the value of the next layer down.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将做的是，不再传递`descriptionSoFar`作为累加器，而是传递一个函数（比如说`descriptionGenerator`），它将根据下一层的值构建适当的描述。
- en: 'Here''s the implementation for the non-recursive cases:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非递归情况的实现：
- en: '[PRE86]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The implementation for recursive cases is a bit more complicated:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况的实现有点更复杂：
- en: We are given an accumulator (`descriptionGenerator`) as a parameter.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以一个累加器（`descriptionGenerator`）作为参数。
- en: We need to create a new accumulator (a new `descriptionGenerator`) to pass down
    to the next lower layer.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的累加器（一个新的`descriptionGenerator`），传递给下一层。
- en: The *input* to the description generator will be all the data accumulated from
    the lower layers. We manipulate that to make a new description and then call the
    `descriptionGenerator` passed in from the higher layer.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述生成器的*输入*将是从较低层累积的所有数据。我们操纵它以生成新的描述，然后调用从更高层传入的`descriptionGenerator`。
- en: 'It''s more complicated to talk about than to demonstrate, so here are implementations
    for two of the cases:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论起来比演示要复杂，所以这里有两个案例的实现：
- en: '[PRE87]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can simplify that code a little by using a lambda directly:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接使用 lambda 稍微简化代码：
- en: '[PRE88]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We could continue to make it more compact using piping and other things, but
    I think that what we have here is a good balance between conciseness and obscurity.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用管道和其他方法使其更加紧凑，但我认为我们现在有一个在简洁和晦涩之间保持良好平衡的东西。
- en: 'Here is the entire function:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个函数：
- en: '[PRE89]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Again, I'm using overly descriptive intermediate values to make it clear what
    is going on.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我使用过于描述性的中间值来清楚地说明正在发生的事情。
- en: 'If we try `descriptionUsingFoldWithGenerator` now, we get the correct answers
    again:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试`descriptionUsingFoldWithGenerator`，我们再次得到正确的答案：
- en: '[PRE90]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Introducing "foldback"
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍“折返”
- en: 'Now that we understand what to do, let''s make a generic version that that
    handles the generator function logic for us. This one we will call "foldback":'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们明白了该做什么，让我们制作一个通用版本，处理生成函数逻辑。这个我们将称之为“折返”：
- en: '*By the way, I''m going to use term "generator" here. In other places, it is
    commonly referred to as a "continuation" function, often abbreviated to just "k".*'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺便说一句，在这里我将使用术语“生成函数”。在其他地方，它通常被称为“续延”函数，常简称为“k”。*'
- en: 'Here''s the implementation:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现：
- en: '[PRE91]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can see that it is just like the `descriptionUsingFoldWithGenerator` implementation,
    except that we are using generic `newInnerVal` and `generator` values.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它就像`descriptionUsingFoldWithGenerator`实现一样，只是我们现在使用泛型的`newInnerVal`和`generator`值。
- en: The type signatures are similar to the original catamorphism, except that every
    case works with `'a` only now. The only time `'r` is used is in the generator
    function itself!
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名与原始的范畴形式相似，只是现在每种情况都只使用`'a`。`'r`唯一使用的时间是在生成函数本身！
- en: '[PRE92]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '*The `foldback` implementation above is written from scratch. If you want a
    fun exercise, see if you can write `foldback` in terms of `fold`.*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '*上面的`foldback`实现是从头开始编写的。如果你想要一个有趣的练习，看看你是否能够根据`fold`来编写`foldback`。*'
- en: 'Let''s rewrite the `description` function using `foldback`:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`foldback`重新编写`description`函数：
- en: '[PRE93]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And the results are still correct:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 结果仍然正确：
- en: '[PRE94]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Comparing `foldback` to the original catamorphism
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较`foldback`和原始的范畴形式
- en: The implementation of `descriptionUsingFoldBack` is almost identical to the
    version in the last post that used the original catamorphism `cataGift`.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`descriptionUsingFoldBack`的实现几乎与上一篇帖子中使用原始范畴形式`cataGift`的版本相同。
- en: 'Here''s the version using `cataGift`:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`cataGift`的版本：
- en: '[PRE95]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'And here''s the version using `foldbackGift`:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`foldbackGift`的版本：
- en: '[PRE96]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: All the handler functions are basically identical. The only change is the addition
    of an initial generator function, which is just `id` in this case.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 所有处理程序函数基本上是相同的。唯一的变化是添加了一个初始生成函数，这在这种情况下只是`id`。
- en: However, although the code looks the same in both cases, they differ in their
    recursion safety. The `foldbackGift` version is still tail recursive, and can
    handle very large nesting depths, unlike the `cataGift` version.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，尽管代码在两种情况下看起来相同，但它们在递归安全性上有所不同。`foldbackGift`版本仍然是尾递归的，并且可以处理非常大的嵌套深度，不像`cataGift`版本。
- en: But this implementation is not perfect either. The chain of nested functions
    can get very slow and generate a lot of garbage, and for this particular example,
    there is an even faster way, which we'll look at in the next post.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种实现也不完美。嵌套函数链可能会变得非常缓慢并且生成大量垃圾，对于这个特定的示例，有一种更快的方法，我们将在下一篇文章中介绍。
- en: Changing the type signature of `foldback` to avoid a mixup
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改`foldback`的类型签名以避免混淆
- en: 'In `foldGift` the signature for `fWrapped` is:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在`foldGift`中，`fWrapped`的签名是：
- en: '[PRE97]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'But in `foldbackGift` the signature for `fWrapped` is:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 但在`foldbackGift`中，`fWrapped`的签名是：
- en: '[PRE98]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Can you spot the difference? No, me neither.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现区别吗？不，我也不能。
- en: The two functions are very similar, yet work very differently. In the `foldGift`
    version, the first parameter is the accumulator from the *outer* levels, while
    in `foldbackGift` version, the first parameter is the accumulator from the *inner*
    levels. Quite an important distinction!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数非常相似，但工作方式完全不同。在`foldGift`版本中，第一个参数是*外部*级别的累加器，而在`foldbackGift`版本中，第一个参数是*内部*级别的累加器。这是一个非常重要的区别！
- en: It is therefore common to change the signature of the `foldBack` version so
    that the accumulator always comes *last*, while in the normal `fold` function,
    the accumulator always comes *first*.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常会更改`foldBack`版本的签名，以便累加器始终出现在*最后*，而在正常的`fold`函数中，累加器始终出现在*第一*。
- en: '[PRE99]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This change shows up in the type signature. The `Gift` value comes before the
    accumulator now:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化显示在类型签名中。现在，`Gift`值在累加器之前：
- en: '[PRE100]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: and now we *can* tell the two versions apart easily.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地区分这两个版本了。
- en: '[PRE101]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Rules for creating a fold
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建折叠的规则
- en: To finish up this post, let's summarize the rules for creating a fold.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 结束这篇文章时，让我们总结一下创建折叠的规则。
- en: 'In the first post we saw that creating a catamorphism is a mechanical process
    that [follows rules](recursive-types-and-folds1.html#rules). The same is true
    for creating a iterative top-down fold. The process is:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一篇文章中，我们看到创建一个析取范畴是一个遵循规则的机械过程。创建迭代式自顶向下折叠也是如此。该过程如下：
- en: Create a function parameter to handle each case in the structure.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数参数来处理结构中的每种情况。
- en: Add an additional parameter as an accumulator.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个额外的参数作为累加器。
- en: For non-recursive cases, pass the function parameter the accumulator plus all
    the data associated with that case.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非递归情况，将函数参数传递给累加器以及与该情况相关的所有数据。
- en: 'For recursive cases, perform two steps:'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于递归情况，执行两个步骤：
- en: First, pass the handler the accumulator plus all the data associated with that
    case (except the inner recursive data). The result is a new accumulator value.
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，将处理程序传递给累加器以及与该情况相关的所有数据（除了内部递归数据）。结果是一个新的累加器值。
- en: Then, call the fold recursively on the nested value using the new accumulator
    value.
  id: totrans-605
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用新的累加器值对嵌套值递归调用折叠。
- en: Note that each handler only "sees" (a) the data for that case, and (b) the accumulator
    passed to it from the outer level. It does not have access to the results from
    the inner levels.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个处理程序仅“看到”（a）该情况的数据和（b）从外部级别传递给它的累加器。它无法访问内部级别的结果。
- en: '* * *'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summary
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We've seen in this post how to define a tail-recursive implementation of a catamorphism,
    called "fold" and the reverse version "foldback".
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们看到了如何定义一个尾递归实现的析取范畴，称为“fold”和相反版本的“foldback”。
- en: In the [next post](recursive-types-and-folds-2b.html) we'll step back a bit
    and spend some time understanding what "fold" really means, and at some guidelines
    for choosing between `fold`, `foldback` and `cata`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](recursive-types-and-folds-2b.html)中，我们将稍微退后一步，并花一些时间了解“折叠”真正意味着什么，并提供一些在`fold`、`foldback`和`cata`之间选择的指南。
- en: We'll then see if we can apply these rules to another domain.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看是否可以将这些规则应用于另一个领域。
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/df4427d0043d7146e592).*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文的源代码可在[此代码片段](https://gist.github.com/swlaschin/df4427d0043d7146e592)中找到。*'
- en: Understanding Folds
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解折叠
- en: Understanding Folds
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解折叠
- en: This post is the fourth in a series.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章是系列中的第四篇。
- en: In the [previous post](recursive-types-and-folds1.html), I introduced "folds",
    a way of creating top-down iterative functions for recursive types.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一篇文章](recursive-types-and-folds1.html)中，我介绍了“折叠”，一种为递归类型创建自顶向下迭代函数的方法。
- en: In this post, we'll spend some time understanding folds in more detail.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将花一些时间更详细地了解折叠。
- en: Series contents
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列目录
- en: 'Here''s the contents of this series:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系列的内容如下：
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1部分：递归类型和消解**'
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-621
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一个简单的递归类型](recursive-types-and-folds1.html#basic-recursive-type)'
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-622
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参数化一切](recursive-types-and-folds1.html#parameterize)'
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-623
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍消解](recursive-types-and-folds1.html#catamorphisms)'
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-624
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消解的好处](recursive-types-and-folds1.html#benefits)'
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建消解的规则](recursive-types-and-folds1.html#rules)'
- en: '**Part 2: Catamorphism examples**'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2部分：消解示例**'
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消解示例：文件系统领域](recursive-types-and-folds-1b.html#file-system)'
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消解示例：产品领域](recursive-types-and-folds-1b.html#product)'
- en: '**Part 3: Introducing folds**'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3部分：介绍折叠**'
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我们消解实现中的一个缺陷](recursive-types-and-folds-2.html#flaw)'
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-631
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 `fold`](recursive-types-and-folds-2.html#fold)'
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-632
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠的问题](recursive-types-and-folds-2.html#problems)'
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数用作累加器](recursive-types-and-folds-2.html#functions)'
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-634
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 `foldback`](recursive-types-and-folds-2.html#foldback)'
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-635
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建折叠的规则](recursive-types-and-folds-2.html#rules)'
- en: '**Part 4: Understanding folds**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第4部分：理解折叠**'
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[迭代 vs. 递归](recursive-types-and-folds-2b.html#iteration)'
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠示例：文件系统领域](recursive-types-and-folds-2b.html#file-system)'
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于“折叠”的常见问题](recursive-types-and-folds-2b.html#questions)'
- en: '**Part 5: Generic recursive types**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5部分：通用递归类型**'
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-641
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[链表：一个通用递归类型](recursive-types-and-folds-3.html#linkedlist)'
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使礼物领域通用化](recursive-types-and-folds-3.html#revisiting-gift)'
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用容器类型](recursive-types-and-folds-3.html#container)'
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现礼物领域的第三种方式](recursive-types-and-folds-3.html#another-gift)'
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抽象还是具体？比较三种设计](recursive-types-and-folds-3.html#compare)'
- en: '**Part 6: Trees in the real world**'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第6部分：现实世界中的树**'
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用树类型](recursive-types-and-folds-3b.html#tree)'
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[现实世界中的树类型](recursive-types-and-folds-3b.html#reuse)'
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射树类型](recursive-types-and-folds-3b.html#map)'
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：创建目录列表](recursive-types-and-folds-3b.html#listing)'
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-651
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：并行 grep](recursive-types-and-folds-3b.html#grep)'
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将文件系统存储在数据库中](recursive-types-and-folds-3b.html#database)'
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将树序列化为 JSON](recursive-types-and-folds-3b.html#tojson)'
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化树](recursive-types-and-folds-3b.html#fromjson)'
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化树 - 带错误处理](recursive-types-and-folds-3b.html#json-with-error-handling)'
- en: '* * *'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Iteration vs. recursion
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代 vs. 递归
- en: We now have *three* different functions -- `cata`, `fold` and `foldback`.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了*三个*不同的函数 -- `cata`, `fold` 和 `foldback`。
- en: So what exactly are the differences between them? We've seen that something
    that doesn't work with `fold` will work with `foldBack`, but is there an easy
    way to remember the difference?
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它们之间的区别到底是什么？我们已经看到了一些在`fold`中不起作用但在`foldBack`中起作用的东西，但是否有一种容易记住区别的方法？
- en: 'One way to differentiate the three approaches is by remembering this:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这三种方法的一种方法是记住这一点：
- en: '`fold` is top-down *iteration*'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fold`是自顶向下的*迭代*'
- en: '`cata` is bottom-up *recursion*'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cata`是自底向上的*递归*'
- en: '`foldBack` is bottom-up *iteration*'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foldBack`是自底向上的*迭代*'
- en: What does this mean?
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？
- en: Well, for in `fold`, the accumulator was initialized at the top level, and was
    passed down to each lower level until the lowest and last level was reached.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在`fold`中，累加器是在顶层初始化的，并且传递到每个较低级别，直到达到最低且最后一个级别。
- en: 'In code terms, each level did this:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，每个级别都执行了这样的操作：
- en: '[PRE102]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In an imperative language, this is exactly a "for loop" with a mutable variable
    storing the accumulator.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式语言中，这正是一个带有存储累加器的可变变量的“for循环”。
- en: '[PRE103]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: So, this kind of top-to-bottom folding can be thought of as iteration (and in
    fact, the F# compiler will turn a tail-recursive function like this into an iteration
    behind the scenes).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种自顶向下的折叠可以被视为迭代（实际上，F#编译器将像这样的尾递归函数转换为迭代）。
- en: On the other hand, in `cata`, the accumulator started at the bottom level, and
    was passed up to each higher level until the top level was reached.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在`cata`中，累加器从底部级别开始，并传递到每个较高级别，直到达到顶级。
- en: 'In code terms, each level did this:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，每个级别都执行了这样的操作：
- en: '[PRE104]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This is exactly a recursive loop:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是一个递归循环：
- en: '[PRE105]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Finally, `foldback` can be thought of as "reverse iteration". The accumulator
    is threaded through all the levels, but starting at the bottom rather than at
    the top. It has the benefits of `cata` in that the inner values are calculated
    first and passed back up, but because it is iterative, there cannot be a stack
    overflow.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`foldback`可以被视为“反向迭代”。累加器在所有级别中都被穿过，但是从底部开始而不是从顶部开始。它具有`cata`的优点，即首先计算内部值并将其传递回来，但由于它是迭代的，所以不会发生堆栈溢出。
- en: 'Many of the concepts we have discussed so far become clear when expressed in
    terms of iteration vs. recursion. For example:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 当以迭代与递归的方式表达时，我们讨论的许多概念变得清晰起来。例如：
- en: The iterative versions (`fold` and `foldback`) have no stack, and cannot cause
    a stack overflow.
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代版本（`fold`和`foldback`）没有堆栈，不会导致堆栈溢出。
- en: The "total cost" function needed no inner data, and so the top-down iterative
    version (`fold`) worked without problems.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “总成本”函数不需要内部数据，所以自上而下的迭代版本（`fold`）可以顺利运行。
- en: The "description" function though, needed inner text for correct formatting,
    and so the recursive version (`cata`) or bottom up iteration (`foldback`) was
    more suitable.
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，“description”函数需要内部文本以正确格式化，因此递归版本（`cata`）或自底向上的迭代（`foldback`）更合适。
- en: 'Fold example: File system domain'
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折叠示例：文件系统域
- en: In the last post, we described some rules for creating folds. Let's see if we
    can apply these rules to create a fold in another domain, the "File System" domain
    from the [second post in the series](recursive-types-and-folds-1b.html#file-system).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们描述了创建折叠的一些规则。让我们看看是否可以将这些规则应用于另一个领域的折叠，即来自[系列第二篇文章](recursive-types-and-folds-1b.html#file-system)的“文件系统”领域。
- en: 'As a reminder, here is the crude "file system" domain from that post:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这是来自该文章的粗略“文件系统”域：
- en: '[PRE106]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note that each directory contains a *list* of subitems, so this is not a linear
    structure like `Gift`, but a tree-like structure. Out implementation of fold will
    have to take this into account.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个目录都包含一个*子项列表*，因此这不是像`Gift`那样的线性结构，而是一个类似树的结构。我们的折叠实现将必须考虑到这一点。
- en: 'Here are some sample values:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些样本值：
- en: '[PRE107]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We want to create a fold, `foldFS`, say. So, following the rules, let''s add
    an extra accumulator parameter `acc` and pass it to the `File` case:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个折叠，比如`foldFS`。因此，遵循规则，让我们添加一个额外的累加器参数`acc`，并将其传递给`File`情况：
- en: '[PRE108]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `Directory` case is trickier. We are not supposed to know about the subitems,
    so that means that the only data we can use is the `name`, `dirSize`, and the
    accumulator passed in from a higher level. These are combined to make a new accumulator.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directory`情况更棘手。我们不应该知道子项，这意味着我们只能使用`name`、`dirSize`和来自更高级别的累加器。这些被组合起来形成一个新的累加器。'
- en: '[PRE109]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '*NOTE: I''m keeping the `name` and `dirSize` as a tuple for grouping purposes,
    but of course you could pass them in as separate parameters.*'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：我将`name`和`dirSize`保留为元组以进行分组，但当然你也可以将它们作为单独的参数传递。*'
- en: 'Now we need to pass this new accumulator down to each subitem in turn, but
    each subitem will return a new accumulator of its own, so we need to use the following
    approach:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这个新的累加器依次传递给每个子项，但是每个子项将返回自己的新累加器，所以我们需要使用以下方法：
- en: Take the newly created accumulator and pass it to the first subitem.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新创建的累加器传递给第一个子项。
- en: Take the output of that (another accumulator) and pass it to the second subitem.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其输出（另一个累加器）传递给第二个子项。
- en: Take the output of that (another accumulator) and pass it to the third subitem.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其输出（另一个累加器）传递给第三个子项。
- en: And so on. The output of the last subitem is the final result.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依此类推。最后一个子项的输出是最终结果。
- en: 'That approach is already available to us though. It''s exactly what `List.fold`
    does! So here''s the code for the Directory case:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管这种方法已经可用于我们。这正是`List.fold`所做的！因此，这是Directory情况��代码： '
- en: '[PRE110]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And here''s the entire `foldFS` function:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是整个`foldFS`函数：
- en: '[PRE111]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: With this in place, we can rewrite the same two functions we implemented in
    the last post.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以重写在上一篇文章中实现的相同的两个函数。
- en: 'First, the `totalSize` function, which just sums up all the sizes:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`totalSize`函数，它只是将所有大小相加：
- en: '[PRE112]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And if we test it we get the same results as before:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试它，我们会得到与之前相同的结果：
- en: '[PRE113]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'File system domain: `largestFile` example'
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统领域：`largestFile`示例
- en: We can also reimplement the "what is the largest file in the tree?" function.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以重新实现“树中最大文件是什么？”函数。
- en: As before it will return a `File option`, because the tree might be empty. This
    means that the accumulator will be a `File option` too.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，它将返回一个`File option`，因为树可能为空。这意味着累加器也将是一个`File option`。
- en: 'This time it is the `File` case handler which is tricky:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这次是`File`情况处理程序有点棘手：
- en: If the accumulator being passed in is `None`, then this current file becomes
    the new accumulator.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传入的累加器是`None`，那么当前文件就成为新的累加器。
- en: If the accumulator being passed in is `Some file`, then compare the size of
    that file with this file. Whichever is bigger becomes the new accumulator.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传入的累加器是`Some file`，那么将该文件的大小与此文件进行比较。哪个更大就成为新的累加器。
- en: 'Here''s the code:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE114]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: On the other hand, the `Directory` handler is trivial -- just pass the "largest
    so far" accumulator down to the next level
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Directory`处理程序很简单--只需将“到目前为止最大”的累加器传递到下一级
- en: '[PRE115]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Here''s the complete implementation:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的实现：
- en: '[PRE116]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'And if we test it we get the same results as before:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试它，我们会得到与之前相同的结果：
- en: '[PRE117]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: It is interesting to compare this implementation with the [recursive version
    in the second post](recursive-types-and-folds-1b.html#file-system). I think that
    this one is easier to implement, myself.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种实现与[第二篇文章中的递归版本](recursive-types-and-folds-1b.html#file-system)进行比较。我认为这个实现更容易实现。
- en: Tree traversal types
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树遍历类型
- en: 'The various fold functions discussed so far correspond to various kinds of
    tree traversals:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的各种折叠函数对应于各种树遍历方式：
- en: A `fold` function (as implemented here) is more properly called a "pre-order
    depth-first" tree traversal.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`fold`函数（在这里实现）更恰当地称为“前序深度优先”树遍历。
- en: A `foldback` function would be a "post-order depth-first" tree traversal.
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foldback`函数将是“后序深度优先”树遍历。'
- en: A `cata` function would not be a "traversal" at all, because each internal node
    deals with a list of all the subresults at once.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cata`函数根本不是“遍历”，因为每个内部节点一次处理所有子结果的列表。'
- en: By tweaking the logic, you can make other variants.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整逻辑，您可以制作其他变体。
- en: For a description of the various kinds of tree traversals, see [Wikipedia](https://en.wikipedia.org/wiki/Tree_traversal).
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 有关各种树遍历的描述，请参见[Wikipedia](https://en.wikipedia.org/wiki/Tree_traversal)。
- en: Do we need `foldback`?
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们需要`foldback`吗？
- en: Do we need to implement a `foldback` function for the FileSystem domain?
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为文件系统领域实现一个`foldback`函数吗？
- en: I don't think so. If we need access to the inner data, we can just use the original
    "naive" catamorphism implementation in the previous post.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 我不这么认为。如果我们需要访问内部数据，我们可以使用上一篇文章中原始的“天真”范畴折叠实现。
- en: But, hey wait, didn't I say at the beginning that we had to watch out for stack
    overflows?
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等，我不是在开头说过我们必须注意堆栈溢出吗？
- en: 'Yes, if the recursive type is deeply nested. But consider a file system with
    only two subdirectories per directory. How many directories would there be if
    there were 64 nested levels? (Hint: you may be familiar with a similar problem.
    Something to do with [grains on a chessboard](https://en.wikipedia.org/wiki/Wheat_and_chessboard_problem)).'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，如果递归类型是深度嵌套的。但是考虑一个每个目录只有两个子目录的文件系统。如果有64个嵌套级别，会有多少个目录？（提示：你可能熟悉一个类似的问题。与[国际象棋棋盘上的麦粒问题](https://en.wikipedia.org/wiki/Wheat_and_chessboard_problem)有关）。
- en: We saw earlier that the stack overflow issue only occurs with more than 1000
    nested levels, and that level of nesting generally only occurs with *linear* recursive
    types, not trees like the FileSystem domain.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，堆栈溢出问题只会发生在超过1000个嵌套级别时，而那种级别的嵌套通常只出现在*线性*递归类型中，而不是像FileSystem领域这样的树形结构。
- en: Common questions about "fold"
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于“折叠”的常见问题
- en: At this point you might be getting overwhelmed! All these different implementations
    with different advantages and disadvantages.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 此时你可能会感到不知所措！所有这些不同的实现都有不同的优势和劣势。
- en: So let's take a short break and address some common questions.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们稍作休息，解答一些常见问题。
- en: What's the difference between "left fold" and "right fold"
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '"左折叠"和"右折叠"有什么区别呢？'
- en: 'There is often quite a lot of confusion around the terminology of folds: "left"
    vs. "right", "forward" vs. "backwards", etc.'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在折叠术语的术语方面常常会有相当多的混淆：“左”vs。“右”，“前”vs。“后”，等等。
- en: A *left fold* or *forward fold* is what I have just called `fold` -- the top-down
    iterative approach.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*左折叠*或*前向折叠*就是我刚刚称为`fold`的东西——自上而下的迭代方法。'
- en: A *right fold* or *backward fold* is what I have called `foldBack` -- the bottom-up
    iterative approach.
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*右折叠*或*向后折叠*就是我所说的`foldBack`——自下而上的迭代方法。'
- en: 'These terms, though, really only apply to linear recursive structures like
    `Gift`. When it comes to more complex tree-like structures, these distinctions
    are too simple, because there are many ways to traverse them: breadth-first, depth-first,
    pre-order and post-order, and so on.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些术语实际上只适用于像`Gift`这样的线性递归结构。当涉及到更复杂的树状结构时，这些区别就太简单了，因为有许多遍历方法：广度优先、深度优先、前序和后序等等。
- en: Which type of fold function should I use?
  id: totrans-743
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我应该使用哪种类型的折叠函数？
- en: 'Here are some guidelines:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些指导方针：
- en: If your recursive type is not going to be too deeply nested (less than 100 levels
    deep, say), then the naive `cata` catamorphism we described in the first post
    is fine. It's really easy to implement mechanically -- just replace the main recursive
    type with `'r`.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的递归类型不会太深嵌套（比如少于100层深），那么我们在第一篇文章中描述的简单`cata`范畴叠加就可以了。它真的很容易机械化实现——只需用`'r`替换主递归类型即可。
- en: If your recursive type is going to be deeply nested and you want to prevent
    stack overflows, use the iterative `fold`.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的递归类型将会被深度嵌套，并且你想要避免堆栈溢出，那就使用迭代的`fold`。
- en: If you are using an iterative fold but you need to have access to the inner
    data, pass a continuation function as an accumulator.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是迭代折叠，但需要访问内部数据，请将一个继续函数作为累加器传递。
- en: Finally, the iterative approach is generally faster and uses less memory than
    the recursive approach (but that advantage is lost if you pass around too many
    nested continuations).
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，迭代方法通常比递归方法更快，且使用的内存更少（但如果传递了太多嵌套的继续，这个优势就会丧失）。
- en: 'Another way to think about it is to look at your "combiner" function. At each
    step, you are combining data from the different levels:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考方式是看你的“组合器”函数。在每一步，你都在组合来自不同层级的数据：
- en: '[PRE118]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If your combiner function is "left associative" like this:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组合器函数是“左结合”的，就像这样：
- en: '[PRE119]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'then use the iterative approach, but if your combiner function is "right associative"
    like this:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用迭代方法，但如果你的组合器函数是“右结合”的，就像这样：
- en: '[PRE120]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: then use the `cata` or `foldback` approach.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`cata`或`foldback`方法。
- en: And if your combiner function doesn't care (like addition, for example), use
    whichever one is more convenient.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组合器函数不在乎（比如加法，例如），那就使用更方便的那种。
- en: How can I know whether code is tail-recursive or not?
  id: totrans-757
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我怎么知道代码是否是尾递归的？
- en: It's not always obvious whether an implementation is tail-recursive or not.
    The easiest way to be sure is to look at the very last expression for each case.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 是否一个实现是尾递归并不总是明显的。确保的最简单方法是查看每种情况的最后一个表达式。
- en: If the call to "recurse" is the very last expression, then it is tail-recursive.
    If there is any other work after that, then it is not tail-recursive.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对“recurse”的调用是最后一个表达式，那么它是尾递归的。如果在此之后还有其他工作，则不是尾递归。
- en: See for yourself with the three implementations that we have discussed.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们讨论过的三种实现自己看看。
- en: 'First, here''s the code for the `WithACard` case in the original `cataGift`
    implementation:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是原始`cataGift`实现中`WithACard`情��的代码：
- en: '[PRE121]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `cataGift` implementation is *not* tail-recursive.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '`cataGift`实现*不是*尾递归的。'
- en: 'Here''s the code from the `foldGift` implementation:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`foldGift`实现的代码：
- en: '[PRE122]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `foldGift` implementation *is* tail-recursive.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldGift`实现*是*尾递归的。'
- en: 'And here''s the code from the `foldbackGift` implementation:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`foldbackGift`实现的代码：
- en: '[PRE123]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `foldbackGift` implementation is also tail-recursive.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldbackGift`实现也是尾递归的。'
- en: How do I short-circuit a fold?
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何中断折叠？
- en: 'In a language like C#, you can exit a iterative loop early using `break` like
    this:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在像C#这样的语言中，您可以使用`break`提前退出迭代循环，就像这样：
- en: '[PRE124]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: So how do you do the same thing with a fold?
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何使用折叠做同样的事情呢？
- en: The short answer is, you can't! A fold is designed to visit all elements in
    turn. The Visitor Pattern has the same constraint.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，你不能！折叠设计为依次访问所有元素。访问者模式也有相同的约束。
- en: There are three workarounds.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种解决方法。
- en: 'The first one is to not use `fold` at all and create your own recursive function
    that terminates on the required condition:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是根本不使用`fold`，而是创建自己的递归函数，在满足所需条件时终止：
- en: 'In this example, the loop exits when the sum is larger than 100:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当总和大于100时，循环退出：
- en: '[PRE125]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The second approach is to use `fold` but to add some kind of "ignore" flag to
    the accumulator that is passed around. Once this flag is set, the remaining iterations
    do nothing.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用`fold`，但向累加器添加某种“忽略”标志，一旦设置了此标志，剩余的迭代将不起作用。
- en: 'Here''s an example of calculating the sum, but the accumulator is actually
    a tuple with an `ignoreFlag` in addition to the `sumSoFar`:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算总和的示例，但累加器实际上是一个元组，其中除了`sumSoFar`之外还有一个`ignoreFlag`：
- en: '[PRE126]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The third version is a variant of the second -- create a special value to signal
    that the remaining data should be ignored, but wrap it in a computation expression
    so that it looks more natural.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个版本是第二个的变体--创建一个特殊值来表示应忽略剩余数据，但将其包装在计算表达式中，使其看起来更自然。
- en: 'This approach is documented on [Tomas Petricek''s blog](http://tomasp.net/blog/imperative-ii-break.aspx/)
    and the code looks like this:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在[Tomas Petricek的博客](http://tomasp.net/blog/imperative-ii-break.aspx/)上有文档记录，代码如下：
- en: '[PRE127]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '* * *'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summary
  id: totrans-786
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The goal of this post was to help you understand folds better, and to show how
    they could be applied to a tree structure like the file system. I hope it was
    helpful!
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的目标是帮助您更好地理解折叠，并展示如何将其应用于文件系统等树结构。希望对您有所帮助！
- en: Up to this point in the series all the examples have been very concrete; we
    have implemented custom folds for each domain we have encountered. Can we be a
    bit more generic and build some reusable fold implementations?
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，系列中的所有示例都非常具体；我们为遇到的每个领域实现了自定义折叠。我们能否更通用一些，构建一些可重用的折叠实现呢？
- en: In the [next post](recursive-types-and-folds-3.html) we'll look at generic recursive
    types, and how to work with them.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](recursive-types-and-folds-3.html)中，我们将看看通用递归类型，以及如何处理它们。
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/e065b0e99dd68cd35846).*'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文的源代码可在[this gist](https://gist.github.com/swlaschin/e065b0e99dd68cd35846)中找到。*'
- en: Generic recursive types
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用递归类型
- en: Generic recursive types
  id: totrans-792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用递归类型
- en: This post is the fifth in a series.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是系列中的第五篇。
- en: In the [previous post](recursive-types-and-folds-2b.html), we spent some time
    understanding folds for specific domain types.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一篇文章](recursive-types-and-folds-2b.html)中，我们花了一些时间理解特定领域类型的折叠。
- en: In this post, we'll broaden our horizons and look at how to use generic recursive
    types.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将拓宽视野，看看如何使用通用递归类型。
- en: Series contents
  id: totrans-796
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s the contents of this series:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本系列的内容：
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1部分：递归类型和catamorphisms简介**'
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-799
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一个简单的递归类型](recursive-types-and-folds1.html#basic-recursive-type)'
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-800
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参数化所有事物](recursive-types-and-folds1.html#parameterize)'
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-801
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[引入分类折叠法](recursive-types-and-folds1.html#catamorphisms)'
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-802
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分类折叠法的好处](recursive-types-and-folds1.html#benefits)'
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-803
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建分类折叠法的规则](recursive-types-and-folds1.html#rules)'
- en: '**Part 2: Catamorphism examples**'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二部分：分类折叠法示例**'
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-805
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分类折叠法示例：文件系统领域](recursive-types-and-folds-1b.html#file-system)'
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分类折叠法示例：产品领域](recursive-types-and-folds-1b.html#product)'
- en: '**Part 3: Introducing folds**'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三部分：介绍折叠法**'
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我们折叠法实现的一个缺陷](recursive-types-and-folds-2.html#flaw)'
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[引入 `fold`](recursive-types-and-folds-2.html#fold)'
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-810
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠法的问题](recursive-types-and-folds-2.html#problems)'
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数用作累加器](recursive-types-and-folds-2.html#functions)'
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[引入 `foldback`](recursive-types-and-folds-2.html#foldback)'
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建折叠法的规则](recursive-types-and-folds-2.html#rules)'
- en: '**Part 4: Understanding folds**'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四部分：理解折叠**'
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-815
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[迭代与递归的比较](recursive-types-and-folds-2b.html#iteration)'
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-816
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠法示例：文件系统领域](recursive-types-and-folds-2b.html#file-system)'
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-817
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于 "fold" 的常见问题](recursive-types-and-folds-2b.html#questions)'
- en: '**Part 5: Generic recursive types**'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第五部分：通用递归类型**'
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-819
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[LinkedList：一个通用的递归类型](recursive-types-and-folds-3.html#linkedlist)'
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-820
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使礼物领域通用化](recursive-types-and-folds-3.html#revisiting-gift)'
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-821
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义一个通用的 Container 类型](recursive-types-and-folds-3.html#container)'
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-822
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[另一个礼物领域的实现方式](recursive-types-and-folds-3.html#another-gift)'
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-823
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抽象还是具体？比较三种设计](recursive-types-and-folds-3.html#compare)'
- en: '**Part 6: Trees in the real world**'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第六部分：现实世界中的树**'
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-825
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义一个通用的 Tree 类型](recursive-types-and-folds-3b.html#tree)'
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-826
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[现实世界中的 Tree 类型](recursive-types-and-folds-3b.html#reuse)'
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-827
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射 Tree 类型](recursive-types-and-folds-3b.html#map)'
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-828
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：创建目录列表](recursive-types-and-folds-3b.html#listing)'
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-829
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：并行 grep](recursive-types-and-folds-3b.html#grep)'
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-830
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将文件系统存储在数据库中](recursive-types-and-folds-3b.html#database)'
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-831
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将树序列化为 JSON](recursive-types-and-folds-3b.html#tojson)'
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-832
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化树](recursive-types-and-folds-3b.html#fromjson)'
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-833
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化树 - 带错误处理](recursive-types-and-folds-3b.html#json-with-error-handling)'
- en: '* * *'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'LinkedList: A generic recursive type'
  id: totrans-835
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LinkedList：一个通用的递归类型
- en: 'Here''s a question: if you only have algebraic types, and you can only combine
    them as products ([tuples](tuples.html), [records](records.html)) or sums ([discriminated
    unions](discriminated-unions.html)), then how can you make a list type just by
    using these operations?'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题：如果你只有代数类型，并且只能将它们作为积（[元组](tuples.html)、[记录](records.html)）或和（[鉴别联合](discriminated-unions.html)）来组合，那么你如何仅使用这些操作来制作一个列表类型？
- en: The answer is, of course, recursion!
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，答案是递归！
- en: 'Let''s start with the most basic recursive type: the list.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的递归类型开始：列表。
- en: I'm going to call my version `LinkedList`, but it is basically the same as the
    `list` type in F#.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的版本称为 `LinkedList`，但它基本上与 F# 中的 `list` 类型相同。
- en: So, how do you define a list in a recursive way?
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何以递归方式定义列表呢？
- en: 'Well, it''s either empty, or it consists of an element plus another list. In
    other words we can define it as a choice type ("discriminated union") like this:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它要么是空的，要么包含一个元素加上另一个列表。换句话说，我们可以定义它为一个选择类型（“鉴别联合”），如下所示：
- en: '[PRE128]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The `Empty` case represents an empty list. The `Cons` case has a tuple: the
    head element, and the tail, which is another list.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 案例表示空列表。`Cons` 案例有一个元组：头元素和尾部，即另一个列表。'
- en: 'We can then define a particular `LinkedList` value like this:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样定义一个特定的 `LinkedList` 值：
- en: '[PRE129]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Using the native F# list type, the equivalent definition would be:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生的 F# list 类型，等效的定义将是：
- en: '[PRE130]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: which is just `[1; 2; 3]`
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 它就是 `[1; 2; 3]`
- en: '`cata` for LinkedList'
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cata` 适用于 LinkedList'
- en: 'Following the rules in the [first post in this series](recursive-types-and-folds1.html#rules),
    we can mechanically create a `cata` function by replacing `Empty` and `Cons` with
    `fEmpty` and `fCons`:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个系列中[第一篇文章中的规则](recursive-types-and-folds1.html#rules)，我们可以通过用 `fEmpty` 和
    `fCons` 替换 `Empty` 和 `Cons` 来机械地创建一个 `cata` 函数：
- en: '[PRE131]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '*Note: We will be putting all the functions associated with `LinkedList<''a>`
    in a module called `LinkedList`. One nice thing about using generic types is that
    the type name does not clash with a similar module name!*'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：我们将把与 `LinkedList<''a>` 关联的所有函数放在一个名为 `LinkedList` 的模块中。使用泛型类型的一个好处是类型名称不会与类似的模块名称冲突！*'
- en: As always, the signatures of the case handling functions are parallel to the
    signatures of the type constructors, with `LinkedList` replaced by `'r`.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型构造函数的签名平行的是案例处理函数的签名，其中 `LinkedList` 被替换为 `'r`。
- en: '[PRE132]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '`fold` for LinkedList'
  id: totrans-855
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`fold` 适用于 LinkedList'
- en: We can also create a top-down iterative `fold` function using the rules in the
    [earlier post](recursive-types-and-folds-2.html#rules).
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这个系列中[早期文章](recursive-types-and-folds-2.html#rules)中的规则创建一个自上而下的迭代 `fold`
    函数。
- en: '[PRE133]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This `foldWithEmpty` function is not quite the same as the standard `List.fold`
    function, because it has an extra function parameter for the empty case (`fEmpty`).
    However, if we eliminate that parameter and just return the accumulator we get
    this variant:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `foldWithEmpty` 函数与标准的 `List.fold` 函数不完全相同，因为它有一个额外的函数参数用于空情况（`fEmpty`）。但是，如果我们消除该参数并只返回累加器，我们会得到这个变体：
- en: '[PRE134]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'If we compare the signature with the [List.fold documentation](https://msdn.microsoft.com/en-us/library/ee353894.aspx)
    we can see that they are equivalent, with `''State` replaced by `''r` and `''T
    list` replaced by `LinkedList<''a>`:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将签名与[List.fold文档](https://msdn.microsoft.com/en-us/library/ee353894.aspx)进行比较，我们会发现它们是等效的，其中
    `'State` 被替换为 `'r`，`'T list` 被替换为 `LinkedList<'a>`：
- en: '[PRE135]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Let''s test that `fold` works by doing a small sum:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过做一个小的求和来测试 `fold` 是否有效：
- en: '[PRE136]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '`foldBack` for LinkedList'
  id: totrans-864
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`foldBack` 适用于 LinkedList'
- en: 'Finally we can create a `foldBack` function, using the "function accumulator"
    approach described in the previous post:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个 `foldBack` 函数，使用前一篇文章中描述的“函数累加器”方法：
- en: '[PRE137]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Again, if we compare the signature with the [List.foldBack documentation](https://msdn.microsoft.com/en-us/library/ee353846.aspx),
    they are also equivalent, with `''State` replaced by `''r` and `''T list` replaced
    by `LinkedList<''a>`:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们将签名与[List.foldBack文档](https://msdn.microsoft.com/en-us/library/ee353846.aspx)进行比较，它们也是等效的，其中
    `'State` 被替换为 `'r`，`'T list` 被替换为 `LinkedList<'a>`：
- en: '[PRE138]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Using `foldBack` to convert between list types
  id: totrans-869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `foldBack` 在列表类型之间进行转换
- en: In the [first post](recursive-types-and-folds1.html#benefits) we noted that
    catamorphisms could be used for converting between types of similar structure.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一篇文章](recursive-types-and-folds1.html#benefits)中，我们注意到，catamorphisms可用于在类似结构的类型之间进行转换。
- en: Let's demonstrate that now by creating some functions that convert from `LinkedList`
    to the native `list` type and back again.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一些函数来演示，将 `LinkedList` 转换为原生的 `list` 类型，然后再转回来。
- en: 'To convert a `LinkedList` to a native `list` all we need to do is replace `Cons`
    with `::` and `Empty` with `[]`:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `LinkedList` 转换为原生的 `list`，我们只需要用 `Cons` 替换 `::`，用 `Empty` 替换 `[]`：
- en: '[PRE139]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'To convert the other way, we need to replace `::` with `Cons` and `[]` with
    `Empty`:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行另一种转换，我们需要用 `Cons` 替换 `::`，用 `Empty` 替换 `[]`：
- en: '[PRE140]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Simple! Let''s test `toList`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！让我们测试 `toList`：
- en: '[PRE141]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'and `ofList`:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `ofList`：
- en: '[PRE142]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Both work as expected.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都按预期工作。
- en: Using `foldBack` to implement other functions
  id: totrans-881
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `foldBack` 实现其他函数
- en: I said earlier that a catamorphism function (for linear lists, `foldBack`) is
    the most basic function available for a recursive type, and in fact is the *only*
    function you need!
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，一个 catamorphism 函数（对于线性列表，`foldBack`）是递归类型可用的最基本函数，实际上是*唯一*需要的函数！
- en: Let's see for ourselves by implementing some other common functions using `foldBack`.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`foldBack`实现一些其他常见函数来亲自看看。
- en: 'Here''s `map` defined in terms of `foldBack`:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是以`foldBack`定义的`map`：
- en: '[PRE143]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'And here''s a test:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个测试：
- en: '[PRE144]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Here''s `filter` defined in terms of `foldBack`:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是以`foldBack`定义的`filter`：
- en: '[PRE145]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'And here''s a test:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个测试：
- en: '[PRE146]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Finally, here''s `rev` defined in terms of `fold`:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是以`fold`定义的`rev`：
- en: '[PRE147]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'And here''s a test:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个测试：
- en: '[PRE148]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: So, I hope you're convinced!
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，希望你被说服了！
- en: Avoiding generator functions
  id: totrans-897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免生成器函数
- en: I mentioned earlier that there was an alternative and (sometimes) more efficient
    way to implement `foldBack` without using generators or continuations.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，有一种替代方法（有时更有效）可以实现`foldBack`，而无需使用生成器或延续。
- en: As we have seen, `foldBack` is reverse iteration, which means that it is the
    same as `fold` applied to a reversed list!
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`foldBack`是反向迭代，这意味着它与应用于反转列表的`fold`相同！
- en: 'So we could implement it like this:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以这样实现它：
- en: '[PRE149]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: It involves making an extra copy of the list, but on the other hand there is
    no longer a large set of pending continuations. It might be worth comparing the
    profile of the two versions in your environment if performance is an issue.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 它涉及制作列表的额外副本，但另一方面不再有大量待处理的延续。如果性能是一个问题，那么在您的环境中比较这两个版本的配置文件可能是值得的。
- en: Making the Gift domain generic
  id: totrans-903
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使礼物领域通用化
- en: In the rest of this post, we'll look at the `Gift` type and see if we can make
    it more generic.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文的其余部分，我们将查看`Gift`类型，并看看是否可以使其更通用。
- en: 'As a reminder, here is the original design:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这是原始设计：
- en: '[PRE150]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Three of the cases are recursive and two are non-recursive.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 三种情况是递归的，两种是非递归的。
- en: Now, the focus of this particular design was on modelling the domain, which
    is why there are so many separate cases.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个特定设计的重点是对领域进行建模，这就是为什么有这么多单独的情况。
- en: But if we want to focus on *reusability* instead of domain modelling, then we
    should simplify the design to the essentials, and all these special cases now
    become a hindrance.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想要专注于*可重用性*而不是领域建模，那么我们应该简化设计至基本要素，所有这些特殊情况现在成为了障碍。
- en: 'To make this ready for reuse, then, let''s collapse all the non-recursive cases
    into one case, say `GiftContents`, and all the recursive cases into another case,
    say `GiftDecoration`, like this:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其准备好重用，让我们将所有非递归情况合并为一个情况，比如`GiftContents`，将所有递归情况合并为另一个情况，比如`GiftDecoration`，如下所示：
- en: '[PRE151]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The main `Gift` type has only two cases now: the non-recursive one and the
    recursive one.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的`Gift`类型现在只有两种情况：非递归和递归。
- en: Defining a generic Container type
  id: totrans-913
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个通用的容器类型
- en: Now that the type is simplified, we can "genericize" it by allowing *any* kind
    of contents *and* any kind of decoration.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类型被简化了，我们可以通过允许*任何*类型的内容*和*任何类型的装饰来“泛型化”它。
- en: '[PRE152]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'And as before, we can mechanically create a `cata` and `fold` and `foldBack`
    for it, using the standard process:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，我们可以使用标准流程为其创建`cata`和`fold`和`foldBack`，如下所示：
- en: '[PRE153]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Converting the gift domain to use the Container type
  id: totrans-918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将礼物领域转换为使用容器类型
- en: 'Let''s convert the gift type to this generic Container type:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将礼物类型转换为这个通用的容器类型：
- en: '[PRE154]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Now we need some helper methods to construct values while hiding the "real"
    cases of the generic type:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一些辅助方法来构造值，同时隐藏通用类型的“真实”情况：
- en: '[PRE155]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Finally we can create some test values:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一些测试值：
- en: '[PRE156]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The `totalCost` function using the Container type
  id: totrans-925
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用容器类型的`totalCost`函数
- en: The "total cost" function can be written using `fold`, since it doesn't need
    any inner data.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: “总成本”函数可以使用`fold`编写，因为它不需要任何内部数据。
- en: Unlike the earlier implementations, we only have two function parameters, `fContents`
    and `fDecoration`, so each of these will need some pattern matching to get at
    the "real" data.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期的实现不同，我们只有两个函数参数，`fContents`和`fDecoration`，因此每个参数都需要一些模式匹配来获取“真实”数据。
- en: 'Here''s the code:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE157]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'And the code works as expected:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 代码按预期工作：
- en: '[PRE158]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `description` function using the Container type
  id: totrans-932
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用容器类型的`description`函数
- en: The "description" function needs to be written using `foldBack`, since it *does*
    need the inner data. As with the code above, we need some pattern matching to
    get at the "real" data for each case.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: “描述”函数需要使用`foldBack`编写，因为它确实需要内部数据。与上面的代码一样，我们需要一些模式匹配来获取每种情况的“真实”数据。
- en: '[PRE159]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'And again the code works as we want:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 而且代码按我们的期望工作：
- en: '[PRE160]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: A third way to implement the gift domain
  id: totrans-937
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现礼物领域的第三种方式
- en: That all looks quite nice, doesn't it?
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来相当不错，不是吗？
- en: But I have to confess that I have been holding something back.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 但我不得不承认，我一直有所保留。
- en: None of that code above was strictly necessary, because it turns out that there
    is yet *another* way to model a `Gift`, without creating any new generic types
    at all!
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码都不是严格必需的，因为事实证明，还有*另一种*方法来建模`Gift`，而无需创建任何新的通用类型！
- en: 'The `Gift` type is basically a linear sequence of decorations, with some content
    as the final step. We can just model this as a pair -- a `Content` and a list
    of `Decoration`. Or to make it a little friendlier, a record with two fields:
    one for the content and one for the decorations.'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gift`类型基本上是一系列装饰的线性序列，最后一步是一些内容。我们可以将其建模为一对--一个`Content`和一个`Decoration`列表。或者为了使其更友好一些，可以使用两个字段的记录：一个用于内容，一个用于装饰。'
- en: '[PRE161]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: That's it! No other new types needed!
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！不需要其他新类型！
- en: Building values using the record type
  id: totrans-944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用记录类型构建值
- en: 'As before, let''s create some helpers to construct values using this type:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，让我们创建一些辅助函数来使用这种类型构建值：
- en: '[PRE162]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: With these helper functions, the way the values are constructed is *identical*
    to the previous version. This is why it is good to hide your raw constructors,
    folks!
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些辅助函数，值的构建方式与之前的版本*完全相同*。这就是为什么要隐藏你的原始构造函数，伙计们！
- en: '[PRE163]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The `totalCost` function using the record type
  id: totrans-949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用记录类型的`totalCost`函数
- en: The `totalCost` function is even easier to write now.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写`totalCost`函数甚至更容易了。
- en: '[PRE164]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The `description` function using the record type
  id: totrans-952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用记录类型的`description`函数
- en: Similarly, the `description` function is also easy to write.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`description`函数也很容易编写。
- en: '[PRE165]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Abstract or concrete? Comparing the three designs
  id: totrans-955
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象还是具体？比较三种设计
- en: If you are confused by this plethora of designs, I don't blame you!
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这么多种设计感到困惑，我不怪你！
- en: 'But as it happens, the three different definitions are actually interchangable:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实上，这三种不同的定义实际上是可以互换的：
- en: '**The original version**'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始版本**'
- en: '[PRE166]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '**The generic container version**'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用容器版本**'
- en: '[PRE167]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '**The record version**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**记录版本**'
- en: '[PRE168]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: If this is not obvious, it might be helpful to read my post on [data type sizes](type-size-and-design.html).
    It explains how two types can be "equivalent", even though they appear to be completely
    different at first glance.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不明显，阅读我关于[数据类型大小](type-size-and-design.html)的帖子可能会有所帮助。它解释了两种类型如何“等价”，即使乍一看它们似乎完全不同。
- en: Picking a design
  id: totrans-965
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择设计
- en: So which design is best? The answer is, as always, "it depends".
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 那么哪种设计最好？答案如常，“这取决于情况”。
- en: For modelling and documenting a domain, I like the first design with the five
    explicit cases. Being easy for other people to understand is more important to
    me than introducing abstraction for the sake of reusability.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 对于建模和记录领域，我喜欢第一种设计，其中包含五个明确的情况。对我来说，易于其他人理解比为了可重用性而引入抽象更重要。
- en: If I wanted a reusable model that was applicable in many situations, I'd probably
    choose the second ("Container") design. It seems to me that this type does represent
    a commonly encountered situation, where the contents are one kind of thing and
    the wrappers are another kind of thing. This abstraction is therefore likely to
    get some use.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想要一个适用于许多情况的可重用模型，我可能会选择第二种（“容器”）设计。在我看来，这种类型似乎代表了一个常见的情况，其中内容是一种东西，包装是另一种东西。因此，这种抽象很可能会被使用。
- en: The final "pair" model is fine, but by separating the two components, we've
    over-abstracted the design for this scenario. In other situations, this design
    might be a great fit (e.g. the decorator pattern), but not here, in my opinion.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的“对”模型很好，但通过分离两个组件，我们为这种情况过度抽象了设计。在其他情况下，这种设计可能非常合适（例如装饰者模式），但在这里，我认为不适用。
- en: There is one further choice which gives you the best of all worlds.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选择，可以让你兼顾所有优点。
- en: As I noted above, all the designs are logically equivalent, which means there
    are "lossless" mappings between them. In that case, your "public" design can be
    the domain-oriented one, like the first one, but behind the scenes you can map
    it to a more efficient and reusable "private" type.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我上面所指出的，所有设计在逻辑上是等价的，这意味着它们之间存在“无损”映射。在这种情况下，你的“公共”设计可以是面向领域的设计，就像第一个设计一样，但在幕后，你可以将其映射到更高效和可重用的“私有”类型。
- en: Even the F# list implementation itself does this. For example, some of the functions
    in the `List` module, such `foldBack` and `sort`, convert the list into an array,
    do the operations, and then convert it back to a list again.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至 F# 的列表实现本身也这样做。例如，`List` 模块中的一些函数，如`foldBack`和`sort`，将列表转换为数组，执行操作，然后再将其转换回列表。
- en: '* * *'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summary
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this post we looked at some ways of modelling the `Gift` as a generic type,
    and the pros and cons of each approach.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们探讨了一些将`Gift`建模为通用类型的方式，以及每种方法的优缺点。
- en: In the [next post](recursive-types-and-folds-3b.html) we'll look at real-world
    examples of using a generic recursive type.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](recursive-types-and-folds-3b.html)中，我们将看到使用通用递归类型的真实世界示例。
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/c423a0f78b22496a0aff).*'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文的源代码可在[此处的 gist](https://gist.github.com/swlaschin/c423a0f78b22496a0aff)找到。*'
- en: Trees in the real world
  id: totrans-978
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界中的树
- en: Trees in the real world
  id: totrans-979
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界中的树
- en: This post is the sixth in a series.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章是系列中的第六篇。
- en: In the [previous post](recursive-types-and-folds-3.html), we briefly looked
    at some generic types.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一篇文章](recursive-types-and-folds-3.html)中，我们简要地看了一些通用类型。
- en: In this post, we'll do some deeper dives into some real-world examples of using
    trees and folds.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将深入研究一些使用树和折叠的真实世界示例。
- en: Series contents
  id: totrans-983
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s the contents of this series:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系列的内容如下：
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一部分：递归类型和消解简介**'
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-986
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一个简单的递归类型](recursive-types-and-folds1.html#basic-recursive-type)'
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-987
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参数化所有东西](recursive-types-and-folds1.html#parameterize)'
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-988
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍消解](recursive-types-and-folds1.html#catamorphisms)'
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-989
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消解的好处](recursive-types-and-folds1.html#benefits)'
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-990
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建消解的规则](recursive-types-and-folds1.html#rules)'
- en: '**Part 2: Catamorphism examples**'
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二部分：消解示例**'
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-992
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消解示例：文件系统领域](recursive-types-and-folds-1b.html#file-system)'
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-993
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消解示例：产品领域](recursive-types-and-folds-1b.html#product)'
- en: '**Part 3: Introducing folds**'
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三部分：介绍折叠**'
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我们的消解实现中的一个缺陷](recursive-types-and-folds-2.html#flaw)'
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 `fold`](recursive-types-and-folds-2.html#fold)'
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-997
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠的问题](recursive-types-and-folds-2.html#problems)'
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-998
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数用作累加器](recursive-types-and-folds-2.html#functions)'
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-999
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍 `foldback`](recursive-types-and-folds-2.html#foldback)'
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-1000
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建折叠的规则](recursive-types-and-folds-2.html#rules)'
- en: '**Part 4: Understanding folds**'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四部分：理解折叠**'
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[迭代 vs. 递归](recursive-types-and-folds-2b.html#iteration)'
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-1003
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[折叠示例：文件系统领域](recursive-types-and-folds-2b.html#file-system)'
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-1004
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于“折叠”的常见问题](recursive-types-and-folds-2b.html#questions)'
- en: '**Part 5: Generic recursive types**'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第五部分：通用递归类型**'
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-1006
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[LinkedList：通用递归类型](recursive-types-and-folds-3.html#linkedlist)'
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-1007
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使礼物领域成为通用的](recursive-types-and-folds-3.html#revisiting-gift)'
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-1008
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用容器类型](recursive-types-and-folds-3.html#container)'
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-1009
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现礼物领域的第三种方式](recursive-types-and-folds-3.html#another-gift)'
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-1010
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抽象还是具体？比较三种设计](recursive-types-and-folds-3.html#compare)'
- en: '**Part 6: Trees in the real world**'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第六部分：现实世界中的树**'
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-1012
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用树类型](recursive-types-and-folds-3b.html#tree)'
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-1013
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[现实世界中的树类型](recursive-types-and-folds-3b.html#reuse)'
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-1014
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射树类型](recursive-types-and-folds-3b.html#map)'
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-1015
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：创建目录列表](recursive-types-and-folds-3b.html#listing)'
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-1016
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：并行 grep](recursive-types-and-folds-3b.html#grep)'
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-1017
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将文件系统存储在数据库中](recursive-types-and-folds-3b.html#database)'
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将 Tree 序列化为 JSON](recursive-types-and-folds-3b.html#tojson)'
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-1019
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化 Tree](recursive-types-and-folds-3b.html#fromjson)'
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-1020
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从 JSON 反序列化 Tree - 带错误处理](recursive-types-and-folds-3b.html#json-with-error-handling)'
- en: '* * *'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Defining a generic Tree type
  id: totrans-1022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义通用的Tree类型
- en: In this post, we'll be working with a generic `Tree` inspired by the `FileSystem`
    domain that we explored earlier.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将使用受之前探索的`FileSystem`领域启发的通用`Tree`。
- en: 'Here was the original design:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始设计：
- en: '[PRE169]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'We can separate out the data from the recursion, and create a generic `Tree`
    type like this:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数据与递归分开，并像这样创建通用的`Tree`类型：
- en: '[PRE170]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Notice that I have used `seq` to represent the subitems rather than `list`.
    The reason for this will become apparent shortly.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用`seq`来表示子项，而不是`list`。不久之后，这个原因就会变得显而易见。
- en: 'The file system domain can then be modelled using `Tree` by specifying `FileInfo`
    as data associated with a leaf node and `DirectoryInfo` as data associated with
    an internal node:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以通过将`FileInfo`指定为叶节点关联的数据，并将`DirectoryInfo`指定为内部节点关联的数据来使用`Tree`来模拟文件系统领域：
- en: '[PRE171]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '`cata` and `fold` for Tree'
  id: totrans-1031
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Tree`的`cata`和`fold`'
- en: 'We can define `cata` and `fold` in the usual way:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照通常的方式定义`cata`和`fold`：
- en: '[PRE172]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Note that I am *not* going to implement `foldBack` for the `Tree` type, because
    it's unlikely that the tree will get so deep as to cause a stack overflow. Functions
    that need inner data can use `cata`.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我*不*打算为`Tree`类型实现`foldBack`，因为树很少会深入到导致堆栈溢出的程度。需要内部数据的函数可以使用`cata`。
- en: Modelling the File System domain with Tree
  id: totrans-1035
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Tree模拟文件系统领域
- en: 'Let''s test it with the same values that we used before:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用与之前相同的值来测试它：
- en: '[PRE173]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The `totalSize` function is almost identical to the one in the previous post:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalSize`函数与上一篇文章中的函数几乎相同：'
- en: '[PRE174]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'And so is the `largestFile` function:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '`largestFile`函数也是如此：'
- en: '[PRE175]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The source code for this section is available at [this gist](https://gist.github.com/swlaschin/1ef784481bae91b63a36).
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分的源代码可在[此要点](https://gist.github.com/swlaschin/1ef784481bae91b63a36)处获得。
- en: The Tree type in the real world
  id: totrans-1043
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实世界中的Tree类型
- en: We can use the `Tree` to model the *real* file system too! To do this, just
    set the leaf node type to `System.IO.FileInfo` and the internal node type to `System.IO.DirectoryInfo`.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`Tree`来模拟*真实*的文件系统！要做到这一点，只需将叶节点类型设置为`System.IO.FileInfo`，将内部节点类型设置为`System.IO.DirectoryInfo`。
- en: '[PRE176]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'And let''s create some helper methods to create the various nodes:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些辅助方法来创建各种节点：
- en: '[PRE177]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Now you can see why I used `seq` rather than `list` for the subitems. The `seq`
    is lazy, which means that we can create nodes without actually hitting the disk.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到我为什么使用`seq`而不是`list`作为子项。`seq`是惰性的，这意味着我们可以创建节点而不实际命中磁盘。
- en: 'Here''s the `totalSize` function again, this time using the real file information:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`totalSize`函数，这次使用真实的文件信息：
- en: '[PRE178]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Let''s see what the size of the current directory is:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前目录的大小：
- en: '[PRE179]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Similarly, we can get the largest file:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以获取最大的文件：
- en: '[PRE180]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: So that's one big benefit of using generic recursive types. If we can turn a
    real-world hierarchy into our tree structure, we can get all the benefits of fold
    "for free".
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是使用通用递归类型的一个巨大好处。如果我们可以将真实的层次结构转换为我们的树结构，我们就可以免费获得所有fold的好处。
- en: Mapping with generic types
  id: totrans-1056
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用通用类型进行映射
- en: One other advantage of using generic types is that you can do things like `map`
    -- converting every element to a new type without changing the structure.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用类型的另一个优点是可以执行诸如`map`之类的操作——将每个元素转换为新类型而不更改结构。
- en: We can see this in action with the real world file system. But first we need
    to define `map` for the `Tree` type!
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在真实的文件系统中看到这一点。但首先，我们需要为`Tree`类型定义`map`！
- en: 'The implementation of `map` can also be done mechanically, using the following
    rules:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`的实现也可以机械化，使用以下规则：'
- en: Create a function parameter to handle each case in the structure.
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数参数来处理结构中的每种情况。
- en: For non-recursive cases
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非递归案例
- en: First, use the function parameter to transform the non-recursive data associated
    with that case
  id: totrans-1062
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用函数参数来转换与该情况相关的非递归数据
- en: Then wrap the result in the same case constructor
  id: totrans-1063
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后用相同的情况构造器包装结果
- en: 'For recursive cases, perform two steps:'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于递归情况，执行两个步骤：
- en: First, use the function parameter to transform the non-recursive data associated
    with that case
  id: totrans-1065
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用函数参数来转换与该情况相关的非递归数据
- en: Next, recursively `map` the nested values.
  id: totrans-1066
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，递归地 `map` 嵌套的值。
- en: Finally, wrap the results in the same case constructor
  id: totrans-1067
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，用相同的情况构造器包装结果
- en: 'Here''s the implementation of `map` for `Tree`, created by following those
    rules:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为 `Tree` 创建的 `map` 的实现，遵循了这些规则：
- en: '[PRE181]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: If we look at the signature of `Tree.map`, we can see that all the leaf data
    is transformed to type `'a`, all the node data is transformed to type `'b`, and
    the final result is a `Tree<'a,'b>`.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `Tree.map` 的签名，我们可以看到所有叶子数据都被转换为类型 `'a`，所有节点数据都被转换为类型 `'b`，最终结果是一个 `Tree<'a,'b>`。
- en: '[PRE182]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'We can define `Tree.iter` in a similar way:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似的方式定义 `Tree.iter`：
- en: '[PRE183]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '* * *'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Creating a directory listing'
  id: totrans-1075
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：创建目录列表
- en: 'Let''s say we want to use `map` to transform the file system into a directory
    listing - a tree of strings where each string has information about the corresponding
    file or directory. Here''s how we could do it:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用 `map` 将文件系统转换为目录列表 - 一个包含有关相应文件或目录的信息的字符串树。 这是我们可以做的：
- en: '[PRE184]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'And then we can print the strings out like this:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样打印字符串：
- en: '[PRE185]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The results will look something like this:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会看起来像这样：
- en: '[PRE186]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/77fadc19acb8cc850276).*'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个示例的源代码可以在 [此代码片段](https://gist.github.com/swlaschin/77fadc19acb8cc850276)
    上找到。*'
- en: '* * *'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Creating a parallel grep'
  id: totrans-1084
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：创建并行 grep
- en: Let's look at a more complex example. I'll demonstrate how to create a parallel
    "grep" style search using `fold`.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的例子。 我将演示如何使用 `fold` 创建并行的“grep”样式搜索。
- en: 'The logic will be like this:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑将是这样的：
- en: Use `fold` to iterate through the files.
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `fold` 来迭代文件。
- en: For each file, if its name doesn't match the desired file pattern, return `None`.
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个文件，如果其名称与所需文件模式不匹配，则返回 `None`。
- en: If the file is to be processed, then return an async that returns all the line
    matches in the file.
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要处理文件，则返回一个返回文件中所有行匹配的异步。
- en: Next, all these asyncs -- the output of the fold -- are aggregated into a sequence.
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，所有这些 async -- fold 的输出 -- 被聚合成一个序列。
- en: The sequence of asyncs is transformed into a single one using `Async.Parallel`
    which returns a list of results.
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Async.Parallel` 将异步序列转换为单个异步，该函数返回结果列表。
- en: Before we start writing the main code, we'll need some helper functions.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写主要代码之前，我们需要一些辅助函数。
- en: First, a generic function that folds over the lines in a file asynchronously.
    This will be the basis of the pattern matching.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个异步地在文件中折叠行的通用函数。 这将是模式匹配的基础。
- en: '[PRE187]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Next, a little helper that allows us to `map` over `Async` values:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个小助手，允许我们对 `Async` 值进行 `map`：
- en: '[PRE188]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Now for the central logic. We will create a function that, given a `textPattern`
    and a `FileInfo`, will return a list of lines that match the textPattern, but
    asynchronously:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是中心逻辑。 我们将创建一个函数，给定一个 `textPattern` 和一个 `FileInfo`，将异步返回与 textPattern 匹配的行的列表：
- en: '[PRE189]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'And now for the `grep` function itself:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 `grep` 函数本身：
- en: '[PRE190]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Let's test it!
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下吧！
- en: '[PRE191]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The result will look something like this:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会看起来像这样：
- en: '[PRE192]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: That's not bad for about 40 lines of code. This conciseness is because we are
    using various kinds of `fold` and `map` which hide the recursion, allowing us
    to focus on the pattern matching logic itself.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于大约 40 行代码来说不算糟糕。 这种简洁性是因为我们使用了各种隐藏了递归的 `fold` 和 `map`，这使我们能够专注于模式匹配逻辑本身。
- en: Of course, this is not at all efficient or optimized (an async for every line!),
    and so I wouldn't use it as a real implementation, but it does give you an idea
    of the power of fold.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不高效或优化（每一行都有一个异步！），所以我不会将其用作真正的实现，但它确实给出了 `fold` 的强大功能的一个想法。
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/137c322b5a46b97cc8be).*'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个示例的源代码可以在 [此代码片段](https://gist.github.com/swlaschin/137c322b5a46b97cc8be)
    上找到。*'
- en: '* * *'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Storing the file system in a database'
  id: totrans-1109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：将文件系统存储在数据库中
- en: For the next example, let's look at how to store a file system tree in a database.
    I don't really know why you would want to do that, but the principles would work
    equally well for storing any hierarchical structure, so I will demonstrate it
    anyway!
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，让我们看看如何在数据库中存储文件系统树。我真的不知道为什么你要这样做，但这些原则同样适用于存储任何分层结构，所以我还是会演示一下！
- en: 'To model the file system hierarchy in the database, say that we have four tables:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在数据库中建模文件系统层次结构，假设我们有四个表：
- en: '`DbDir` stores information about each directory.'
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DbDir` 存储关于每个目录的信息。'
- en: '`DbFile` stores information about each file.'
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DbFile` 存储关于每个文件的信息。'
- en: '`DbDir_File` stores the relationship between a directory and a file.'
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DbDir_File` 存储目录和文件之间的关系。'
- en: '`DbDir_Dir` stores the relationship between a parent directory and a child
    directory.'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DbDir_Dir` 存储父目录和子目录之间的关系。'
- en: 'Here are the database table definitions:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是数据库表定义：
- en: '[PRE193]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: That's simple enough. But note that in order to save a directory completely
    along with its relationships to its child items, we first need the ids of all
    its children, and each child directory needs the ids of its children, and so on.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。但请注意，为了完全保存一个目录及其与子项的关系，我们首先需要所有子项的 id，每个子目录都需要其子项的 id，依此类推。
- en: This implies that we should use `cata` instead of `fold`, so that we have access
    to the data from the lower levels of the hierarchy.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该使用 `cata` 而不是 `fold`，这样我们就可以访问层次结构下层的数据。
- en: Implementing the database functions
  id: totrans-1120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现数据库函数
- en: 'We''re not wise enough to be using the [SQL Provider](https://fsprojects.github.io/SQLProvider/)
    and so we have written our own table insertion functions, like this dummy one:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不够聪明来使用 [SQL Provider](https://fsprojects.github.io/SQLProvider/)，所以我们编写了自己的表插入函数，就像这个虚拟的：
- en: '[PRE194]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'In a real database, the identity column would be automatically generated for
    you, but for this example, I''ll use a little helper function `nextIdentity`:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实的数据库中，标识列会自动生成，但对于这个示例，我会使用一个小助手函数 `nextIdentity`：
- en: '[PRE195]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Now in order to insert a directory, we need to first know all the ids of the
    files in the directory. This implies that the `insertDbFile` function should return
    the id that was generated.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了插入一个目录，我们需要首先知道目录中所有文件的 id。这意味着 `insertDbFile` 函数应该返回生成的 id。
- en: '[PRE196]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'But that logic applies to the directories too:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个逻辑也适用于目录：
- en: '[PRE197]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: But that's still not good enough. When the child ids are passed to the parent
    directory, it needs to distinguish between files and directories, because the
    relations are stored in different tables.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够好。当子 id 传递给父目录时，它需要区分文件和目录，因为关系存储在不同的表中。
- en: No problem -- we'll just use a choice type to distinguish between them!
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题 -- 我们只需使用一个选择类型来区分它们！
- en: '[PRE198]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'With this in place, we can complete the implementation of the database functions:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以完成数据库函数的实现：
- en: '[PRE199]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Working with the catamorphism
  id: totrans-1134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 catamorphism
- en: As noted above, we need to use `cata` instead of `fold`, because we need the
    inner ids at each step.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我们需要使用 `cata` 而不是 `fold`，因为我们需要在每一步中访问内部 id。
- en: The function to handle the `File` case is easy -- just insert it and return
    the `PrimaryKey`.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 `File` 情况的函数很简单 -- 只需插入并返回 `PrimaryKey`。
- en: '[PRE200]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The function to handle the `Directory` case will be passed the `DirectoryInfo`
    and a sequence of `PrimaryKey`s from the children that have already been inserted.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 `Directory` 情况的函数将接收 `DirectoryInfo` 和已经插入的子项的 `PrimaryKey` 序列。
- en: 'It should insert the main directory record, then insert the children, and then
    return the `PrimaryKey` for the next higher level:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该插入主目录记录，然后插入子目录，然后返回下一个更高级别的 `PrimaryKey`：
- en: '[PRE201]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: After inserting the directory record and getting its id, for each child id,
    we insert either into the `DbDir_File` table or the `DbDir_Dir`, depending on
    the type of the `childId`.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入目录记录并获取其 id 后，对于每个子 id，我们要插入到 `DbDir_File` 表或 `DbDir_Dir`，取决于 `childId` 的类型。
- en: '[PRE202]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Note that I've also created a little helper function `pkToInt` that extracts
    the integer id from the `PrimaryKey` type.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我还创建了一个小助手函数 `pkToInt`，从 `PrimaryKey` 类型中提取整数 id。
- en: 'Here is all the code in one chunk:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有代码的整体：
- en: '[PRE203]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Now let''s test it:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来测试一下：
- en: '[PRE204]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The output should look something like this:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE205]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: You can see that the ids are being generated as the files are iterated over,
    and that each `DbFile` insert is followed by a `DbDir_File` insert.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在迭代文件时生成了ids，并且每个`DbFile`插入后都跟着一个`DbDir_File`插入。
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/3a416f26d873faa84cde).*'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '*此示例的源代码可在[此代码片段](https://gist.github.com/swlaschin/3a416f26d873faa84cde)中找到。*'
- en: '* * *'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Serializing a Tree to JSON'
  id: totrans-1153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：将树序列化为JSON
- en: 'Let''s look at another common challenge: serializing and deserializing a tree
    to JSON, XML, or some other format.'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个常见的挑战：将树序列化和反序列化为JSON、XML或其他格式。
- en: Let's use the Gift domain again, but this time, we'll model the `Gift` type
    as a tree. That means we get to put more than one thing in a box!
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用Gift域，但这次，我们将`Gift`类型建模为一棵树。这意味着我们可以在一个盒子里放更多的东西！
- en: Modelling the Gift domain as a tree
  id: totrans-1156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Gift域建模为树
- en: 'Here are the main types again, but notice that the final `Gift` type is defined
    as a tree:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次是主要类型，但请注意最终的`Gift`类型被定义为一棵树：
- en: '[PRE206]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'As usual, we can create some helper functions to assist with constructing a
    `Gift`:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以创建一些辅助函数来帮助构建`Gift`：
- en: '[PRE207]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'And we can create some sample data:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一些示例数据：
- en: '[PRE208]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Functions like `description` now need to handle a *list* of inner texts, rather
    than one. We''ll just concat the strings together with an `&` separator:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '`description`等函数现在需要处理一个*列表*的内部文本，而不是一个。我们将用`&`分隔符将字符串连接在一起：'
- en: '[PRE209]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Finally, we can check that the function still works as before, and that multiple
    items are handled correctly:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检查函数是否仍然像以前一样工作，并且多个项目是否被正确处理：
- en: '[PRE210]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Step 1: Defining `GiftDto`'
  id: totrans-1167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：定义`GiftDto`
- en: Our `Gift` type consists of many discriminated unions. In my experience, these
    do not serialize well. In fact, most complex types do not serialize well!
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Gift`类型由许多区分联合组成。根据我的经验，这些不会序列化得很好。事实上，大多数复杂类型都不会序列化得很好！
- en: 'So what I like to do is define [DTO](https://en.wikipedia.org/wiki/Data_transfer_object)
    types that are explicitly designed to be serialized well. In practice this means
    that the DTO types are constrained as follows:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我喜欢定义[DTO](https://en.wikipedia.org/wiki/Data_transfer_object)类型，这些类型专门设计用于良好的序列化。实际上，这意味着DTO类型受到以下约束：
- en: Only record types should be used.
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只应使用记录类型。
- en: The record fields should consist only primitive values such as `int`, `string`
    and `bool`.
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录字段应仅包含原始值，如`int`、`string`和`bool`。
- en: 'By doing this, we also get some other advantages:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们还能获得一些其他优势：
- en: '**We gain control of the serialization output.** These kinds of data types
    are handled the same by most serializers, while "strange" things such as unions
    can be interpreted differently by different libraries.'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们能控制序列化输出。** 大多数序列化器都以相同的方式处理这些数据类型，而“奇怪”的东西，比如联合类型，可能会被不同的库解释得不同。'
- en: '**We have better control of error handling.** My number one rule when dealing
    with serialized data is "trust no one". It''s very common that the data is structured
    correctly but is invalid for the domain: supposedly non-null strings are null,
    strings are too long, integers are outside the correct bounds, and so on.'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们能更好地控制错误处理。** 我在处理序列化数据时的首要规则是“不要相信任何人”。很常见的情况是数据结构正确但对于域来说是无效的：被认为是非空字符串实际上是空的，字符串太长，整数超出了正确的范围，等等。'
- en: By using DTOs, we can be sure that the deserialization step itself will work.
    Then, when we convert the DTO to a domain type, we can do proper validation.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用DTO，我们可以确保反序列化步骤本身能够工作。然后，当我们将DTO转换为域类型时，我们可以进行适当的验证。
- en: 'So, let''s define some DTO types for out domain. Each DTO type will correspond
    to a domain type, so let''s start with `GiftContents`. We''ll define a corresponding
    DTO type called `GiftContentsDto` as follows:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们为我们的域定义一些DTO类型。每个DTO类型将对应一个域类型，所以让我们从`GiftContents`开始。我们将定义一个相应的DTO类型，称为`GiftContentsDto`，如下所示：
- en: '[PRE211]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Obviously, this quite different from the original `GiftContents`, so let''s
    look at the differences:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这与原始的`GiftContents`相当不同，让我们看看它们的区别：
- en: First, it has the `CLIMutableAttribute`, which allows deserializers to construct
    them using reflection.
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它具有`CLIMutableAttribute`，允许反序列化器使用反射构造它们。
- en: Second, it has a `discriminator` which indicates which case of the original
    union type is being used. Obviously, this string could be set to anything, so
    when converting from the DTO back to the domain type, we'll have to check that
    carefully!
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它有一个`discriminator`，指示正在使用原始联合类型的哪种情况。显然，这个字符串可以设置为任何值，因此在将DTO转换回域类型时，我们必须仔细检查！
- en: Next is a series of fields, one for every possible item of data that needs to
    be stored. For example, in the `Book` case, we need a `bookTitle`, while in the
    `Chocolate` case, we need the chocolate type. And finally the `price` field which
    is in both types. Note that the chocolate type is stored as a string as well,
    and so will also need special treatment when we convert from DTO to domain.
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一系列字段，每个字段用于存储需要存储的所有可能数据项。例如，在`Book`情况下，我们需要一个`bookTitle`，而在`Chocolate`情况下，我们需要巧克力类型。最后`price`字段在两种类型中都存在。请注意，巧克力类型也存储为字符串，因此在从
    DTO 转换为领域时也需要特殊处理。
- en: The `GiftDecorationDto` type is created in the same way, with a discriminator
    and strings rather than unions.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '`GiftDecorationDto` 类型以相同方式创建，具有鉴别器和字符串而不是联合。'
- en: '[PRE212]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Finally, we can define a `GiftDto` type as being a tree that is composed of
    the two DTO types:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将`GiftDto`类型定义为由两个 DTO 类型组成的树：
- en: '[PRE213]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Step 2: Transforming a `Gift` to a `GiftDto`'
  id: totrans-1186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：将`Gift`转换为`GiftDto`
- en: 'Now that we have this DTO type, all we need to do is use `Tree.map` to convert
    from a `Gift` to a `GiftDto`. And in order to do that, we need to create two functions:
    one that converts from `GiftContents` to `GiftContentsDto` and one that converts
    from `GiftDecoration` to `GiftDecorationDto`.'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个 DTO 类型，我们只需要使用`Tree.map`将`Gift`转换为`GiftDto`。为了做到这一点，我们需要创建两个函数：一个将`GiftContents`转换为`GiftContentsDto`，另一个将`GiftDecoration`转换为`GiftDecorationDto`。
- en: 'Here''s the complete code for `giftToDto`, which should be self-explanatory:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`giftToDto`的完整代码，应该是不言自明的：
- en: '[PRE214]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: You can see that the case (`Book`, `Chocolate`, etc.) is turned into a `discriminator`
    string and the `chocolateType` is also turned into a string, just as explained
    above.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到情况（`Book`，`Chocolate`等）被转换为`discriminator`字符串，`chocolateType`也被转换为字符串，就像上面解释的那样。
- en: 'Step 3: Defining a `TreeDto`'
  id: totrans-1191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：定义一个`TreeDto`
- en: I said above that a good DTO should be a record type. Well we have converted
    the nodes of the tree, but the tree *itself* is a union type! We need to transform
    the `Tree` type as well, into say a `TreeDto` type.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，一个好的 DTO 应该是一个记录类型。我们已经转换了树的节点，但树*本身*是一个联合类型！我们还需要将`Tree`类型转换为比如`TreeDto`类型。
- en: How can we do this? Just as for the gift DTO types, we will create a record
    type which contains all the data for both cases. We could use a discriminator
    field as we did before, but this time, since there are only two choices, leaf
    and internal node, I'll just check whether the values are null or not when deserializing.
    If the leaf value is not null, then the record must represent the `LeafNode` case,
    otherwise the record must represent the `InternalNode` case.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何做到这一点？就像对于礼物 DTO 类型一样，我们将创建一个包含两种情况所有数据的记录类型。我们可以像之前一样使用鉴别器字段，但这次，由于只有两种选择，叶子和内部节点，当进行反序列化时，我将仅检查值是否为
    null。如果叶子值不为 null，则记录必须表示`LeafNode`情况，否则记录必须表示`InternalNode`情况。
- en: 'Here''s the definition of the data type:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据类型的定义：
- en: '[PRE215]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: As before, the type has the `CLIMutableAttribute`. And as before, the type has
    fields to store the data from all possible choices. The `subtrees` are stored
    as an array rather than a seq -- this makes the serializer happy!
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，类型具有`CLIMutableAttribute`。并且与以前一样，类型具有字段来存储所有可能选择的数据。`subtrees`存储为数组而不是
    seq -- 这使得序列化程序很高兴！
- en: To create a `TreeDto`, we use our old friend `cata` to assemble the record from
    a regular `Tree`.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`TreeDto`，我们使用我们的老朋友`cata`从常规`Tree`中组装记录。
- en: '[PRE216]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Note that in F#, records are not nullable, so I am using `Unchecked.defaultof<'NodeData>`
    rather than `null` to indicate missing data.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 F# 中，记录不可为空，因此我使用`Unchecked.defaultof<'NodeData>`而不是`null`来指示缺失数据。
- en: Note also that I am assuming that `LeafData` or `NodeData` are reference types.
    If `LeafData` or `NodeData` are ever value types like `int` or `bool`, then this
    approach will break down, because you won't be able to tell the difference between
    a default value and a missing value. In which case, I'd switch to a discriminator
    field as before.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我假设`LeafData`或`NodeData`是引用类型。如果`LeafData`或`NodeData`是像`int`或`bool`这样的值类型，那么这种方法将会失败，因为您无法区分默认值和缺失值。在这种情况下，我会像以前一样切换到鉴别器字段。
- en: Alternatively, I could have used an `IDictionary`. That would be less convenient
    to deserialize, but would avoid the need for null-checking.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我可以使用`IDictionary`。这样做反序列化会不太方便，但可以避免需要进行空值检查。
- en: 'Step 4: Serializing a `TreeDto`'
  id: totrans-1202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：��列化`TreeDto`
- en: Finally we can serialize the `TreeDto` using a JSON serializer.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 JSON 序列化程序序列化`TreeDto`。
- en: For this example, I am using the built-in `DataContractJsonSerializer` so that
    I don't need to take a dependency on a NuGet package. There are other JSON serializers
    that might be better for a serious project.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我使用内置的 `DataContractJsonSerializer`，这样我就不需要依赖于 NuGet 包。还有其他一些 JSON 序列化器可能更适合一个正式的项目。
- en: '[PRE217]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Step 5: Assembling the pipeline'
  id: totrans-1206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第五步：组装管道
- en: 'So, putting it all together, we have the following pipeline:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，把所有这些放在一起，我们有以下管道：
- en: Transform `Gift` to `GiftDto` using `giftToDto`,
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `giftToDto` 将 `Gift` 转换为 `GiftDto`，
- en: that is, use `Tree.map` to go from `Tree<GiftContents,GiftDecoration>` to `Tree<GiftContentsDto,GiftDecorationDto>`
  id: totrans-1209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，使用 `Tree.map` 从 `Tree<GiftContents,GiftDecoration>` 转换到 `Tree<GiftContentsDto,GiftDecorationDto>`
- en: Transform `Tree` to `TreeDto` using `treeToDto`,
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换 `Tree` 到 `TreeDto` 使用 `treeToDto`，
- en: that is, use `Tree.cata` to go from `Tree<GiftContentsDto,GiftDecorationDto>`
    to `TreeDto<GiftContentsDto,GiftDecorationDto>`
  id: totrans-1211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，使用 `Tree.cata` 从 `Tree<GiftContentsDto,GiftDecorationDto>` 转换到 `TreeDto<GiftContentsDto,GiftDecorationDto>`
- en: Serialize `TreeDto` to a JSON string
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `TreeDto` 序列化为 JSON 字符串
- en: 'Here''s some example code:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些示例代码：
- en: '[PRE218]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'And here is what the JSON output looks like:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 JSON 输出的样子：
- en: '[PRE219]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: The ugly `@` signs on the field names are an artifact of serializing the F#
    record type. This can be corrected with a bit of effort, but I'm not going to
    bother right now!
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名上的丑陋 `@` 符号是序列化 F# 记录类型的产物。这可以通过一点努力来纠正，但我现在不打算费心！
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/bbe70c768215b209c06c)*'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '*此示例的源代码可在 [此代码片段](https://gist.github.com/swlaschin/bbe70c768215b209c06c)
    上找到*'
- en: '* * *'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Deserializing a Tree from JSON'
  id: totrans-1220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：从 JSON 反序列化树
- en: Now that we have created the JSON, what about going the other way and loading
    it into a `Gift`?
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 JSON，那么反过来加载到 `Gift` 呢？
- en: 'Simple! We just need to reverse the pipeline:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！我们只需要颠倒管道：
- en: Deserialize a JSON string into a `TreeDto`.
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JSON 字符串反序列化为 `TreeDto`。
- en: Transform a `TreeDto` into a `Tree` to using `dtoToTree`,
  id: totrans-1224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dtoToTree` 将 `TreeDto` 转换为 `Tree`，
- en: that is, go from `TreeDto<GiftContentsDto,GiftDecorationDto>` to `Tree<GiftContentsDto,GiftDecorationDto>`.
    We can't use `cata` for this -- we'll have to create a little recursive loop.
  id: totrans-1225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，从 `TreeDto<GiftContentsDto,GiftDecorationDto>` 转换到 `Tree<GiftContentsDto,GiftDecorationDto>`。我们不能使用
    `cata` 来实现这一点 -- 我们将不得不创建一个小的递归循环。
- en: Transform `GiftDto` to `Gift` using `dtoToGift`,
  id: totrans-1226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dtoToGift` 将 `GiftDto` 转换为 `Gift`，
- en: that is, use `Tree.map` to go from `Tree<GiftContentsDto,GiftDecorationDto>`
    to `Tree<GiftContents,GiftDecoration>`.
  id: totrans-1227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，使用 `Tree.map` 从 `Tree<GiftContentsDto,GiftDecorationDto>` 转换到 `Tree<GiftContents,GiftDecoration>`。
- en: 'Step 1: Deserializing a `TreeDto`'
  id: totrans-1228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：反序列化 `TreeDto`
- en: We can deserialize the `TreeDto` using a JSON serializer.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 JSON 序列化器反序列化 `TreeDto`。
- en: '[PRE220]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: What if the deserialization fails? For now, we will ignore any error handling
    and let the exception propagate.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果反序列化失败会怎么样？暂时，我们将忽略任何错误处理，并让异常传播。
- en: 'Step 2: Transforming a `TreeDto` into a `Tree`'
  id: totrans-1232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：将 `TreeDto` 转换为 `Tree`
- en: To transform a `TreeDto` into a `Tree` we recursively loop through the record
    and its subtrees, turning each one into a `InternalNode` or a `LeafNode`, based
    on whether the appropriate field is null or not.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `TreeDto` 转换为 `Tree`，我们需要递归地遍历记录及其子树，根据适当的字段是否为 null，将每个字段转换为 `InternalNode`
    或 `LeafNode`。
- en: '[PRE221]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'As you can see, a number of things could go wrong:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有很多事情可能出错：
- en: What if the `leafData` and `nodeData` fields are both null?
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `leafData` 和 `nodeData` 字段都为 null 会怎么样？
- en: What if the `nodeData` field is not null but the `subtrees` field *is* null?
  id: totrans-1237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `nodeData` 字段不为 null，但 `subtrees` 字段 *为* null 会怎么样？
- en: Again, we will ignore any error handling and just throw exceptions (for now).
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将忽略任何错误处理，只是抛出异常（暂时）。
- en: '*Question: Could we create a `cata` for `TreeDto` that would make this code
    simpler? Would it be worth it?*'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '*问题：我们是否可以为 `TreeDto` 创建一个 `cata`，使这段代码更简单？是否值得？*'
- en: 'Step 3: Transforming a `GiftDto` into `Gift`'
  id: totrans-1240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步：将 `GiftDto` 转换为 `Gift`
- en: Now we have a proper tree, we can use `Tree.map` again to convert each leaf
    and internal node from a DTO to the proper domain type.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个合适的树，我们可以再次使用 `Tree.map` 将每个叶子和内部节点从 DTO 转换为适当的域类型。
- en: That means we need functions that map a `GiftContentsDto` into a `GiftContents`
    and a `GiftDecorationDto` into a `GiftDecoration`.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要将 `GiftContentsDto` 映射到 `GiftContents`，将 `GiftDecorationDto` 映射到 `GiftDecoration`
    的函数。
- en: Here's the complete code -- it's a lot more complicated than going in the other
    direction!
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的代码 -- 比起另一个方向要复杂得多！
- en: 'The code can be grouped as follows:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以分组如下：
- en: Helper methods (such as `strToChocolateType`) that convert a string into a proper
    domain type and throw an exception if the input is invalid.
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助方法（如`strToChocolateType`），将字符串转换为适当的领域类型，并在输入无效时抛出异常。
- en: Case converter methods (such as `bookFromDto`) that convert an entire DTO into
    a case.
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: case转换器方法（如`bookFromDto`），将整个DTO转换为一个case。
- en: And finally, the `dtoToGift` function itself. It looks at the `discriminator`
    field to see which case converter to call, and throws an exception if the discriminator
    value is not recognized.
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`dtoToGift`函数本身。它查看`discriminator`字段，看看调用哪个case转换器，并在识别不出discriminator值时抛出异常。
- en: '[PRE222]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Step 4: Assembling the pipeline'
  id: totrans-1249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：组装管道
- en: We can now assemble the pipeline that takes a JSON string and creates a `Gift`.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以组装管道，接受一个JSON字符串并创建一个`Gift`。
- en: '[PRE223]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: This works fine, but the error handling is terrible!
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做没问题，但错误处理很糟糕！
- en: 'Look what happens if we corrupt the JSON a little:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如果我们稍微损坏JSON会发生什么：
- en: '[PRE224]'
  id: totrans-1254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: We get an ugly exception.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个丑陋的异常。
- en: Or what if a discriminator is wrong?
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果discriminator是错误的会怎样？
- en: '[PRE225]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: or one of the values for the WrappingPaperStyle DU?
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 或者WrappingPaperStyle DU的值之一？
- en: '[PRE226]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: We get lots of exceptions, and as as functional programmers, we should try to
    remove them whenever we can.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到很多异常，作为函数式程序员，我们应该尽可能地消除它们。
- en: How we can do that will be discussed in the next section.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论如何做到这一点。
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/bbe70c768215b209c06c).*'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '*此示例的源代码可在[此代码片段](https://gist.github.com/swlaschin/bbe70c768215b209c06c)中找到。*'
- en: '* * *'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Deserializing a Tree from JSON - with error handling'
  id: totrans-1264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：从JSON反序列化Tree - 带有错误处理
- en: 'To address the error handling issue, we''re going use the `Result` type shown
    below:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决错误处理问题，我们将使用下面显示的`Result`类型：
- en: '[PRE227]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: I'm not going to explain how it works here. If you are not familar with this
    approach, please [read my post](recipe-part2.html) or [watch my talk](http://fsharpforfunandprofit.com/rop/)
    on the topic of functional error handling.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里解释它是如何工作的。如果你对这种方法不熟悉，请[阅读我的文章](recipe-part2.html)或[观看我关于函数式错误处理主题的讲座](http://fsharpforfunandprofit.com/rop/)。
- en: Let's revisit all the steps from the previous section, and use `Result` rather
    than throwing exceptions.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视前一节中的所有步骤，并使用`Result`而不是抛出异常。
- en: 'Step 1: Deserializing a `TreeDto`'
  id: totrans-1269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：反序列化`TreeDto`
- en: When we deserialize the `TreeDto` using a JSON serializer we will trap exceptions
    and turn them into a `Result`.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用JSON序列化器反序列化`TreeDto`时，我们将捕获异常并将其转换为`Result`。
- en: '[PRE228]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The signature of `fromJson` is now `string -> Result<'a>`.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`fromJson`的签名是`string -> Result<'a>`。
- en: 'Step 2: Transforming a `TreeDto` into a `Tree`'
  id: totrans-1273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：将`TreeDto`转换为`Tree`
- en: As before, we transform a `TreeDto` into a `Tree` by recursively looping through
    the record and its subtrees, turning each one into a `InternalNode` or a `LeafNode`.
    This time, though, we use `Result` to handle any errors.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，通过递归循环遍历记录及其子树，将每个转换为`InternalNode`或`LeafNode`，我们将`TreeDto`转换为`Tree`。不过，这次我们使用`Result`来处理任何错误。
- en: '[PRE229]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'But uh-oh, we now have a `Tree` where every internal node and leaf is wrapped
    in a `Result`. It''s a tree of `Results`! The actual ugly signature is this: `Tree<Result<''Leaf>,Result<''Node>>`.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，糟糕的是，我们现在有一个`Tree`，其中每个内部节点和叶子都包裹在一个`Result`中。这是一个`Results`的树！实际的丑陋签名是这样的：`Tree<Result<'Leaf>,Result<'Node>>`。
- en: But this type is useless as it stands -- what we *really* want is to merge all
    the errors together and return a `Result` containing a `Tree`.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种类型是无用的 -- 我们*真正*想要的是将所有错误合并在一起，并返回包含`Tree`的`Result`。
- en: How can we transform a Tree of Results into a Result of Tree?
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将一组Results的Tree转换为一个Tree的Result？
- en: The answer is to use a `sequence` function which "swaps" the two types. You
    can read much more about `sequence` in [my series on elevated worlds](elevated-world-4.html#sequence).
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用一个`sequence`函数，它可以"交换"这两种类型。你可以在[我的提升世界系列文章中](elevated-world-4.html#sequence)更多地了解`sequence`。
- en: '*Note that we could also use the slightly more complicated `traverse` variant
    to combine the `map` and `sequence` into one step, but for the purposes of this
    demonstration, it''s easier to understand if the steps are kept separate.*'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，我们也可以使用稍微复杂一点的`traverse`变体将`map`和`sequence`合并为一步，但为了演示的目的，如果将步骤保持分开，更容易理解。*'
- en: 'We need to create our own `sequence` function for the Tree/Result combination.
    Luckily the creation of a sequence function is a mechanical process:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为Tree/Result组合创建自己的`sequence`函数。幸运的是，创建一个序列函数是一个机械过程：
- en: For the lower type (`Result`) we need to define `apply` and `return` functions.
    See [here for more details](elevated-world.html#apply) on what `apply` means.
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于低类型（`Result`），我们需要定义 `apply` 和 `return` 函数。有关 `apply` 的更多详细信息，请参见[这里](elevated-world.html#apply)。
- en: For the higher type (`Tree`) we need to have a `cata` function, which we do.
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更高的类型（`Tree`），我们需要一个 `cata` 函数，我们已经有了。
- en: In the catamorphism, each constructor of the higher type (`LeafNode` and `InternalNode`
    in this case) is replaced by an equivalent that is "lifted" to the `Result` type
    (e.g. `retn LeafNode <*> data`)
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在范畴化中，高类型的每个构造器（在这种情况下是 `LeafNode` 和 `InternalNode`）都被等效地替换为一个被 "提升" 到 `Result`
    类型的等价物（例如 `retn LeafNode <*> data`）。
- en: Here is the actual code -- don't worry if you can't understand it immediately.
    Luckily, we only need to write it once for each combination of types, so for any
    kind of Tree/Result combination in the future, we're set!
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际的代码 -- 如果你不能立即理解也不要担心。幸运的是，我们只需要为每种类型组合写一次，所以对于将来任何类型的树/结果组合，我们都准备好了！
- en: '[PRE230]'
  id: totrans-1286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Finally, the actual `dtoToTree` function is simple -- just send the `treeDto`
    through `dtoToTreeOfResults` and then use `sequenceTreeOfResult` to convert the
    final result into a `Result<Tree<..>>`, which is just what we need.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实际的 `dtoToTree` 函数很简单 -- 只需将 `treeDto` 通过 `dtoToTreeOfResults` 发送，然后使用 `sequenceTreeOfResult`
    将最终结果转换为 `Result<Tree<..>>`，这正是我们需要的。
- en: '[PRE231]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Step 3: Transforming a `GiftDto` into a `Gift`'
  id: totrans-1289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：将 `GiftDto` 转换为 `Gift`
- en: Again we can use `Tree.map` to convert each leaf and internal node from a DTO
    to the proper domain type.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以使用 `Tree.map` 来将 DTO 的每个叶子和内部节点转换为正确的域类型。
- en: But our functions will handle errors, so they need to map a `GiftContentsDto`
    into a `Result<GiftContents>` and a `GiftDecorationDto` into a `Result<GiftDecoration>`.
    This results in a Tree of Results again, and so we'll have to use `sequenceTreeOfResult`
    again to get it back into the correct `Result<Tree<..>>` shape.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们的函数将处理错误，所以它们需要将 `GiftContentsDto` 映射到 `Result<GiftContents>`，将 `GiftDecorationDto`
    映射到 `Result<GiftDecoration>`。这将再次导致结果的 Tree，并且我们将再次使用 `sequenceTreeOfResult` 将其转换回正确的
    `Result<Tree<..>>` 形状。
- en: Let's start with the helper methods (such as `strToChocolateType`) that convert
    a string into a proper domain type. This time, they return a `Result` rather than
    throwing an exception.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从辅助方法（如 `strToChocolateType`）开始，将字符串转换为正确的域类型。这一次，它们返回一个 `Result` 而不是抛出异常。
- en: '[PRE232]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The case converter methods have to build a `Book` or `Chocolate` from parameters
    that are `Result`s rather than normal values. This is where lifting functions
    like `Result.lift2` can help. For details on how this works, see [this post on
    lifting](elevated-world.html#lift) and [this one on validation with applicatives](elevated-world-3.html#validation).
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 情况转换器方法必须从 `Result` 而不是正常值构建一个 `Book` 或 `Chocolate`。这就是提升函数如 `Result.lift2`
    如何帮助的地方。有关此操作的详细信息，请参见[提升文章](elevated-world.html#lift)和[应用验证的文章](elevated-world-3.html#validation)。
- en: '[PRE233]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: And finally, the `dtoToGift` function itself is changed to return a `Result`
    if the `discriminator` is invalid.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 `discriminator` 无效，`dtoToGift` 函数本身也将更改为返回一个 `Result`。
- en: As before, this mapping creates a Tree of Results, so we pipe the output of
    the `Tree.map` through `sequenceTreeOfResult` ...
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，这种映射创建了一个结果的 Tree，因此我们将 `Tree.map` 的输出通过 `sequenceTreeOfResult` 管道 ...
- en: '[PRE234]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '... to return a Result of Tree.'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '... 返回一个 Tree 的 Result。'
- en: 'Here''s the complete code for `dtoToGift`:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `dtoToGift` 的完整代码：
- en: '[PRE235]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The type signature of `dtoToGift` has changed -- it now returns a `Result<Gift>`
    rather than just a `Gift`.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtoToGift` 的类型签名已更改 -- 现在它返回一个 `Result<Gift>` 而不仅仅是一个 `Gift`。'
- en: '[PRE236]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Step 4: Assembling the pipeline'
  id: totrans-1304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：组装管道
- en: We can now reassemble the pipeline that takes a JSON string and creates a `Gift`.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重新组合管道，以将 JSON 字符串转换为一个 `Gift`。
- en: 'But changes are needed to work with the new error handling code:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 但是需要对新的错误处理代码进行更改：
- en: The `fromJson` function returns a `Result<TreeDto>` but the next function in
    the pipeline (`dtoToTree`) expects a regular `TreeDto` as input.
  id: totrans-1307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromJson` 函数返回一个 `Result<TreeDto>`，但管道中的下一个函数（`dtoToTree`）期望一个常规的 `TreeDto`
    作为输入。'
- en: Similarly `dtoToTree` returns a `Result<Tree>` but the next function in the
    pipeline (`dtoToGift`) expects a regular `Tree` as input.
  id: totrans-1308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，`dtoToTree` 返回一个 `Result<Tree>`，但管道中的下一个函数（`dtoToGift`）期望一个常规的 `Tree` 作为输入。
- en: In both case, `Result.bind` can be used to solve that problem of mis-matched
    output/input. See [here for a more detailed discussion of bind](elevated-world-2.html#bind).
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`Result.bind` 可以用来解决输出/输入不匹配的问题。有关更详细的 bind 讨论，请参见[这里](elevated-world-2.html#bind)。
- en: Ok, let's try deserializing the `goodJson` string we created earlier.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们尝试反序列化我们之前创建的`goodJson`字符串。
- en: '[PRE237]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: That's fine.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题。
- en: 'Let''s see if the error handling has improved now. We''ll corrupt the JSON
    again:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 看看现在错误处理是否改善了。我们再次破坏 JSON：
- en: '[PRE238]'
  id: totrans-1314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Great! We get an nice `Failure` case.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！我们得到了一个很好的`Failure`案例。
- en: Or what if a discriminator is wrong?
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果鉴别器错了呢？
- en: '[PRE239]'
  id: totrans-1317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: or one of the values for the WrappingPaperStyle DU?
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 或 WrappingPaperStyle DU 的值之一？
- en: '[PRE240]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Again, nice `Failure` cases.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 再次出现了很好的`Failure`案例。
- en: What's very nice (and this is something that the exception handling approach
    can't offer) is that if there is more than one error, the various errors can be
    aggregated so that we get a list of *all* the things that went wrong, rather than
    just one error at a time.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好的一点是（这是异常处理方法无法提供的），如果有多个错误，各种错误可以被聚合，这样我们就可以得到一个列出了*所有*出错原因的列表，而不仅仅是一次一个错误。
- en: 'Let''s see this in action by introducing two errors into the JSON string:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 JSON 字符串引入两个错误，让我们看看它的实际效果：
- en: '[PRE241]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: So overall, I'd say that's a success!
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我认为这是一个成功！
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/2b06fe266e3299a656c1).*'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个示例的源代码可以在[这个 gist](https://gist.github.com/swlaschin/2b06fe266e3299a656c1)找到。*'
- en: '* * *'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summary
  id: totrans-1327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We've seen in this series how to define catamorphisms, folds, and in this post
    in particular, how to use them to solve real world problems. I hope these posts
    have been useful, and have provided you with some tips and insights that you can
    apply to your own code.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们已经看到了如何定义catamorphisms（折叠），以及特别是在这篇文章中，如何使用它们来解决实际问题。我希望这些文章对你有用，并为你提供了一些可以应用到自己代码中的提示和见解。
- en: This series turned out to be a lot longer that I intended, so thanks for making
    it to the end! Cheers!
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系列的长度超出了我的预期，所以感谢您一直坚持看到最后！干杯！
