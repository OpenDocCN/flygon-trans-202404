- en: Is your programming language unreasonable?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的编程语言是否合理？
- en: Is your programming language unreasonable?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的编程语言是否合理？
- en: As should be obvious, one of the goals of this site is to persuade people to
    take F# seriously as a general purpose development language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如显而易见的，这个网站的目标之一是说服人们认真对待 F# 作为一种通用开发语言。
- en: But as functional idioms have become more mainstream, and C# has added functional
    capabilities such as lambdas and LINQ, it seems like C# is "catching up" with
    F# more and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但随着函数式习惯变得更加主流，以及 C# 添加了诸如 lambda 和 LINQ 等函数式功能，似乎 C# 正在越来越“赶上” F#。
- en: 'So, ironically, I''ve now started to hear people say things like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具有讽刺意味的是，我现在开始听到人们说这样的话：
- en: '"C# already has most of the features of F#, so why should I bother to switch?"*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"C# 已经拥有了大部分 F# 的特性，那么我为什么要费心去切换呢？"*'
- en: '"There is no need to change. All we have do is wait a couple of years and C#
    will get many of the F# features that provide the most benefits."'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"没有必要改变。我们只需要等几年，C# 将获得许多提供最大好处的 F# 特性。"'
- en: '"F# is slightly better than C#, but not so much that it''s really worth the
    effort to move towards it."'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"F# 稍微比 C# 好一点，但并不值得花费精力去转向它。"'
- en: '"F# seems really nice, even if it''s a bit intimidating. But I can''t see a
    practical purpose to use it over C#."'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"F# 看起来确实很好，尽管有点令人生畏。但我看不出使用它而不是 C# 的实际目的。"'
- en: No doubt, the same comments are being made in the JVM ecosystem about Scala
    and Clojure vs. Java, now that Java has lambdas too.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，在 JVM 生态系统中，关于 Scala 和 Clojure 与 Java 的对比，现在 Java 也有了 lambda，相同的评论也在被提出。
- en: So for this post, I'm going to stray away from F#, and focus on C# (and by proxy,
    other mainstream languages), and try to demonstrate that, even with all the functional
    features in the world, programming in C# will never be the same as programming
    in F#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这篇文章中，我将远离 F#，专注于 C#（以及其他主流语言），并尝试证明，即使拥有世界上所有的函数式特性，使用 C# 编程永远不会与使用 F#
    编程相同。
- en: Before I start, I want to make it clear that I am *not* hating on C#. As it
    happens I like C# very much; it is one of my favorite mainstream languages, and
    it has evolved to be very powerful while being consistent and backwards compatible,
    which is a hard thing to pull off.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始之前，我想明确一点，我*并不*讨厌 C#。事实上，我非常喜欢 C#；它是我最喜欢的主流语言之一，它已经发展成为非常强大的同时保持一致性和向后兼容性，这是一件难以实现的事情。
- en: But C# is not perfect. Like most mainstream OO languages, it contains some design
    decisions which no amount of LINQ or lambda goodness can compensate for.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 C# 并不完美。像大多数主流面向对象语言一样，它包含一些设计决策，LINQ 或 lambda 的优点也无法弥补。
- en: In this post, I'll show you some of the issues that these design decisions cause,
    and suggest some ways to improve the language to avoid them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我将展示一些这些设计决策引起的问题，并提出一些改进语言以避免这些问题的方法。
- en: '*(I''m now going to don my flameproof suit. I think I might need it!)*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*(我现在要穿上防火服了。我觉得我可能需要它！)*'
- en: '* * *'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'UPDATE: Many people have [seriously misread](http://www.washingtonpost.com/local/serious-reading-takes-a-hit-from-online-scanning-and-skimming-researchers-say/2014/04/06/088028d2-b5d2-11e3-b899-20667de76985_story.html)
    this post, it seems. So let me be clear:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更新：许多人严重误解了这篇文章，似乎是这样。所以让我明确一点：
- en: I am *not* saying that statically typed languages are "better" than dynamic
    languages.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我*并不*是说静态类型语言比动态语言“更好”。
- en: I am *not* saying that FP languages are "better" than OO languages.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我*并不*是说函数式编程语言比面向对象语言“更好”。
- en: I am *not* saying that being able to reason about code is the most important
    aspect of a language.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我*并不*是说能够推理代码是一种语言中最重要的方面。
- en: 'What I *am* saying is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我*所说的是*：
- en: Not being able to reason about code has costs that many developers might not
    be aware of.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能推理代码会带来许多开发人员可能没有意识到的成本。
- en: Therefore, being "reasonable" should be one of the (many) factors under consideration
    when choosing a programming language, not just ignored due to lack of awareness.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，在选择编程语言时，“合理性”应该是考虑的（众多）因素之一，而不仅仅是因为缺乏认识而被忽视。
- en: '*IF* you want to be able to reason about your code, *THEN* it will be much
    easier if your language supports the features that I mention.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果*你想要能够推理你的代码，*那么*如果你的语言支持我提到的特性，那么将会更容易。'
- en: The fundamental paradigm of OO (object-identity, behavior-based) is not compatible
    with "reasonability", and so it will be hard to retrofit existing OO languages
    to add this quality.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象（对象标识、基于行为）的基本范式与“合理性”不兼容，因此很难向现有的面向对象语言添加这种特性。
- en: That's it. Thank you!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。谢谢！
- en: '* * *'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: What is a "reasonable" programming language, anyway?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是“合理”的编程语言？
- en: If you hang around functional programmers, you will often hear the phrase "reason
    about", as in "we want to reason about our programs".
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常与函数式编程人员交往，你经常会听到“推理”，比如“我们想推理我们的程序”。
- en: What does that mean? Why use the word "reason" rather than just "understand"?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？为什么使用“推理”这个词而不是只是“理解”？
- en: 'The use of "reasoning" goes back to mathematics and logic, but I''m going to
    use a simple and pragmatic definition:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “推理”的使用可以追溯到数学和逻辑，但我将使用一个简单而实用的定义：
- en: '"reasoning about the code" means that you can draw conclusions using only the
    information that you have *right in front of you*, rather than having to delve
    into other parts of the codebase.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “推理代码”意味着你可以仅仅通过你面前的信息得出结论，而不必深入到代码库的其他部分。
- en: In other words, you can predict the behavior of some code just by looking at
    it. You may need to understand the interfaces to other components, but you shouldn't
    need to look inside them to see what they do.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可以通过查看一些代码来预测其行为。你可能需要了解其他组件的接口，但你不应该需要深入了解它们来看看它们做了什么。
- en: Since, as developers, we spend most of our time looking at code, this is a pretty
    important aspect of programming!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们大部分时间都在看代码，这是编程的一个非常重要的方面！
- en: 'Of course, there is a huge amount of advice out there on how to do just this:
    naming guidelines, formatting rules, design patterns, etc., etc.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于如何做到这一点有大量的建议：命名指南，格式化规则，设计模式等等。
- en: But can your programming language *by itself* help your code to be more reasonable,
    more predictable? I think the answer is yes, but I'll let you judge for yourself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你的编程语言*本身*可以帮助你的代码更合理、更可预测吗？我认为答案是肯定的，但我会让你自己判断。
- en: Below, I'll present a series of code fragments. After each snippet, I'm going
    to ask you what you think the code does. I've deliberately not shown my own comments
    so that you can think about it and do your own reasoning. After you have thought
    about it, scroll down to read my opinion.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，我将呈现一系列代码片段。在每个片段之后，我会问你认为这段代码做了什么。我特意没有展示我的评论，这样你可以自己思考。在你思考过之后，往下滚动查看我的观点。
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example 1
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1
- en: Let's start off by looking at the following code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看下面的代码。
- en: We start with a variable `x` that is assigned the integer `2`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一个变量`x`开始，它被赋予整数`2`。
- en: Then `DoSomething` is called with `x` as a parameter.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后以`x`作为参数调用`DoSomething`。
- en: Then `y` is assigned to `x - 1`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后`y`被赋值为`x - 1`。
- en: 'The question I would ask you is simple: What is the value of `y`?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我要问你的问题很简单：`y`的值是多少？
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (scroll down for answer)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: （向下滚动查看答案）
- en: The answer is `-1`. Did you get that answer? No? If you can't figure it out,
    scroll down again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`-1`。你得到了那个答案吗？没有？如果你猜不出来，再次向下滚动。
- en: Trick question! This code is actually JavaScript!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个恶作剧问题！这段代码实际上是 JavaScript！
- en: 'Here''s the whole thing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Yes, it's horrible! `DoSomething` accesses `x` directly rather than through
    the parameter, and then turns it into a boolean of all things! Then, subtracting
    1 from `x` casts it from `false` to `0`, so that `y` is `-1`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，太可怕了！`DoSomething`直接访问`x`而不是通过参数，然后将其转换为布尔值！然后，从`x`中减去1将其从`false`转换为`0`，所以`y`是`-1`。
- en: Don't you totally hate this? Sorry to mislead you about the language, but I
    just wanted to demonstrate how annoying it is when the language behaves in unpredictable
    ways.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你难道不是完全讨厌这个吗？对不起让你误解语言，但我只是想演示当语言表现出不可预测的行为时是多么令人恼火。
- en: JavaScript is a very useful and important language. But no one would claim that
    [reasonableness](http://stackoverflow.com/a/1995298/1136133) was one of its [strengths](../assets/img/javascript-the-good-parts.jpg).
    In fact, most dynamically-typed languages have [quirks that make them hard to
    reason about](https://www.destroyallsoftware.com/talks/wat) in this way.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种非常有用和重要的语言。但没有人会声称[合理性](http://stackoverflow.com/a/1995298/1136133)是其[优势](../assets/img/javascript-the-good-parts.jpg)之一。事实上，大多数动态类型语言都有[怪癖，使得它们难以通过推理来理解](https://www.destroyallsoftware.com/talks/wat)。
- en: Thanks to static typing and sensible scoping rules, this kind of thing could
    never happen in C# (unless you tried really hard!) In C#, if you don't match up
    the types properly, you get a *compile-time* error rather than a *run-time* error.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于静态类型和合理的作用域规则，这种事情在 C#中不可能发生（除非你非常努力！）。在 C#中，如果你没有正确匹配类型，你会得到一个*编译时*错误而不是*运行时*错误。
- en: In other words, C# is much more predictable than JavaScript. Score one for static
    typing!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，C#比 JavaScript 更可预测。给静态类型加一分！
- en: 'So now we have our first requirement for making a language predictable:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了使语言可预测的第一个要求：
- en: '***How to make your language predictable***:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '***如何使你的语言可预测***：'
- en: Variables should not be allowed to change their type.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量不应该被允许改变它们的类型。
- en: C# is looking good compared to JavaScript. But we're not done yet...
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相比 JavaScript，C#看起来不错。但我们还没完成...
- en: '*UPDATE: This is an admittedly silly example. In retrospect, I could have picked
    a better one. Yes, I know that no one sensible would ever do this. The point still
    stands: the JavaScript language does not prevent you from doing stupid things
    with implicit typecasts.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新：这显然是一个愚蠢的例子。回想起来，我本可以选一个更好的例子。是的，我知道没有理智的人会这么做。但问题依然存在：JavaScript 语言不会阻止你用隐式类型转换做蠢事。*'
- en: '* * *'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example 2
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例 2
- en: In this next example, we're going to create two instances of the same `Customer`
    class, with exactly the same data in them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将创建两个完全相同数据的相同`Customer`类的实例。
- en: 'The question is: Are they equal?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：它们相等吗？
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (scroll down for answer)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: （向下滚动获取答案）
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Who knows? It depends on how the `Customer` class has been implemented. This
    code is *not* predictable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 谁知道呢？这取决于`Customer`类的实现方式。这段代码是*不可预测*的。
- en: You'll have to look at whether the class implements `IEquatable` at least, and
    you'll probably have to look at the internals of the class as well to see exactly
    what is going on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不得不查看类是否至少实现了`IEquatable`，而且你可能还需要查看类的内部以确切了解发生了什么。
- en: '*But why is this even an issue?*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*但这到底是个问题吗？*'
- en: 'Let me ask you this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我问你这个问题：
- en: How often would you NOT want the instances to be equal?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有多经常不希望实例相等？
- en: How often have you had to override the `Equals` method?
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有多经常需要重写`Equals`方法？
- en: How often have you had a bug caused by *forgetting* to override the `Equals`
    method?
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有多经常因为*忘记*重写`Equals`方法而导致 bug？
- en: How often have you had a bug caused by mis-implementing `GetHashCode` (such
    as forgetting to change it when the fields that you compare on change)?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有多经常因为误实现`GetHashCode`（比如在你比较的字段变化时忘记修改）而导致 bug？
- en: Why not make the objects equal by default, and make reference equality testing
    the special case?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不默认让对象相等，而将引用相等测试作为特例呢？
- en: So let's add another item to our list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们在列表中再添加一项。
- en: '***How to make your language predictable***:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '***如何使你的语言可预测***：'
- en: Variables should not be allowed to change their type.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量不应该被允许改变它们的类型。
- en: '**Objects containing the same values should be equal by default.**'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**包含相同值的对象应该默认相等。**'
- en: '* * *'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example 3
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例 3
- en: In this next example, I've got two objects containing exactly the same data,
    but which are instances of different classes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我有两个包含完全相同数据但是是不同类实例的对象。
- en: 'The question again is: Are they equal?'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次问题是：它们相等吗？
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: (scroll down for answer)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: （向下滚动获取答案）
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Who cares! This is almost certainly a bug! Why are you even comparing two different
    classes like this in the first place?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 谁在乎！这几乎肯定是个 bug！你为什么一开始就要比较两个不同的类呢？
- en: Compare their names or ids, certainly, but not the objects themselves. This
    should be a compiler error.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比较它们的名字或者 id，当然可以，但不是对象本身。这应该是个编译器错误。
- en: If it isn't, why not? You probably just used the wrong variable name by mistake
    but now you have a subtle bug in your code. Why does your language let you do
    this?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，为什么？你可能只是错用了变量名，但现在你的代码中有一个微妙的 bug。你的语言为什么让你这样做呢？
- en: So let's add another item to our list.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们在列表中再添加一项。
- en: '***How to make your language predictable***:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '***如何使你的语言可预测***：'
- en: Variables should not be allowed to change their type.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量不应该被允许改变它们的类型。
- en: Objects containing the same values should be equal by default.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含相同值的对象应该默认相等。
- en: '**Comparing objects of different types is a compile-time error.**'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**比较不同类型的对象是编译时错误。**'
- en: '*UPDATE: Many people have pointed out that you need this when comparing classes
    related by inheritance. This is true, of course. But what is the cost of this
    feature? You get the ability to compare subclasses, but you lose the ability to
    detect accidental errors.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新：许多人指出，当比较由继承关系相关的类时，你需要这个。当然，这是真的。但这个特性的成本是多少呢？你获得了比较子类的能力，但你失去了检测意外错误的能力。*'
- en: '*Which is more important in practice? That''s for you to decide, I just wanted
    to make it clear that there are costs associated with the status quo, not just
    benefits.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实践中哪个更重要？这取决于你的决定，我只是想明确指出现状存在成本，不仅仅是好处。*'
- en: '* * *'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example 4
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 4
- en: In this snippet, we're just going to create a `Customer` instance. That's all.
    Can't get much more basic than that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们只是要创建一个`Customer`实例。就这样。不能再基本了。
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now the question is: what is the expected output of `WriteLine`?'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：`WriteLine`的预期输出是什么？
- en: (scroll down for answer)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: （向下滚动查看答案）
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Who knows?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 谁知道呢？
- en: It depends on whether the `Address` property is null or not. And that is something
    you can't tell without looking at the internals of the `Customer` class again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于`Address`属性是否为空。而且这是你无法不查看`Customer`类的内部就无法确定的事情。
- en: Yes, we know that it is a best practice that constructors should initialize
    all fields at construction time, but why doesn't the language enforce it?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们知道构造函数应在构建时初始化所有字段是一种最佳实践，但为什么语言不强制执行呢？
- en: If the address is required, then make it be required in the constructor. And
    if the address is *not* always required, then make it clear that the `Address`
    property is optional and might be missing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地址是必需的，则在构造函数中使其为必需。如果地址*不*总是必需的，那么明确地指出`Address`属性是可选的，并且可能会丢失。
- en: So let's add another item to our list of improvements.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们将另一个改进项目添加到我们的列表中。
- en: '***How to make your language predictable***:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '***如何使你的语言可预测***：'
- en: Variables should not be allowed to change their type.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量不应允许更改其类型。
- en: Objects containing the same values should be equal by default.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含相同值的对象默认应该是相等的。
- en: Comparing objects of different types is a compile-time error.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较不同类型的对象是一个编译时错误。
- en: '**Objects must *always* be initialized to a valid state. Not doing so is a
    compile-time error.**'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对象必须*始终*初始化为有效状态。不这样做将导致编译时错误。**'
- en: '* * *'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example 5
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 5
- en: 'In this next example, we''re going to:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将：
- en: Create a customer.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个客户。
- en: Add it to a set that uses hashing.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其添加到使用哈希的集合中。
- en: Do something with the customer object.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对客户对象进行一些操作。
- en: See if the customer is still in the set.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看客户是否仍在集合中。
- en: What could possibly go wrong?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 会有什么问题吗？
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, does the set still contain the customer at the end of this code?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这段代码结束时，集合中还包含客户吗？
- en: (scroll down for answer)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: （向下滚动查看答案）
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Maybe. Maybe not.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可能。也可能不是。
- en: 'It depends on two things:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它取决于两件事：
- en: First, does the hash code of the customer depend on a *mutable* field, such
    as an id.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，客户的哈希码是否取决于一个*可变*字段，比如一个 id。
- en: Second, does `ProcessCustomer` change this field?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，`ProcessCustomer`是否更改了这个字段？
- en: If both are true, then the hash will have been changed, and the customer will
    not longer *appear* to exist in the set (even though it is still in there somewhere!).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者都是真的，那么哈希码将被更改，并且客户将不再*看起来*存在于集合中（即使它仍然存在于其中的某个地方！）。
- en: This might well cause subtle performance and memory problems (e.g. if the set
    is a cache).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致微妙的性能和内存问题（例如，如果集合是一个缓存）。
- en: How could the language prevent this?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 语言如何防止这种情况发生？
- en: One way would be to say that any field or property used in `GetHashCode` must
    be immutable, while allowing other properties to be mutable. But that is really
    impractical.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是说，`GetHashCode`中使用的任何字段或属性都必须是不可变的，而允许其他属性是可变的。但这真的不切实际。
- en: Better to just make the entire `Customer` class immutable instead!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最好只是将整个`Customer`类设为不可变！
- en: 'Now if the `Customer` class was immutable, and `ProcessCustomer` wanted to
    make changes, it would have to return a *new version* of the customer, and the
    code would look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果`Customer`类是不可变的，并且`ProcessCustomer`想要进行更改，它将不得不返回客户的*新版本*，代码将如下所示：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that the `ProcessCustomer` line has changed to:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ProcessCustomer`行已更改为：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's clear that `ProcessCustomer` has changed something just by looking at this
    code. If `ProcessCustomer` *hadn't* changed anything, it wouldn't have needed
    to return an object at all.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`ProcessCustomer`通过查看这段代码就改变了一些东西。如果`ProcessCustomer` *没有*改变任何东西，它根本就不需要返回一个对象。
- en: Going back to the question, it's clear that in this implementation the original
    version of the customer is guaranteed to still be in the set, no matter what `ProcessCustomer`
    does.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 回到问题，很明显，在这个实现中，无论`ProcessCustomer`做了什么，原始版本的顾客都保证仍然在集合中。
- en: Of course, that doesn't solve the issue of whether the new one or the old one
    (or both) should be in the set. But unlike the implementation using the mutable
    customer, this issue is now staring you in the face and won't go unnoticed accidentally.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并没有解决新旧版本中应该在集合中的问题。但是，与使用可变顾客的实现不同，这个问题现在直接摆在你面前，不会被无意中忽略。
- en: So [immutability FTW](http://stackoverflow.com/a/4763485/1136133)!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以[不可变性万岁](http://stackoverflow.com/a/4763485/1136133)！
- en: So that's another item for our list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们清单上的另一项。
- en: '***How to make your language predictable***:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '***如何使你的语言可预测***：'
- en: Variables should not be allowed to change their type.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量不应该允许改变它们的类型。
- en: Objects containing the same values should be equal by default.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含相同值的对象默认应该是相等的。
- en: Comparing objects of different types is a compile-time error.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较不同类型的对象是编译时错误。
- en: Objects must *always* be initialized to a valid state. Not doing so is a compile-time
    error.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象必须*始终*被初始化为有效状态。不这样做是编译时错误。
- en: '**Once created, objects and collections *must* be immutable.**'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一旦创建，对象和集合*必须*是不可变的。**'
- en: 'Time for a quick joke about immutability:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候讲一个关于不可变性的笑话了：
- en: '"How many Haskell programmers does it take to change a lightbulb?"'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"有多少Haskell程序员需要更换灯泡？"'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"Haskell programmers don''t "change" lightbulbs, they "replace" them. And you
    must also replace the whole house at the same time."'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"Haskell程序员不会“更改”灯泡，他们会“替换”它们。而且你还必须同时替换整个房子。"'
- en: Almost done now -- just one more!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 快完成了 -- 只剩下一个了！
- en: '* * *'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example 6
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子 6
- en: In this final example, we'll try to fetch a customer from a `CustomerRepository`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，我们将尝试从`CustomerRepository`中获取一个客户。
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The question is: after we do `customer = repo.GetById(42)`, what is the value
    of `customer.Id`?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：我们执行`customer = repo.GetById(42)`之后，`customer.Id`的值是多少？
- en: (scroll down for answer)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: （向下滚动查看答案）
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It all depends, of course.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这一切都取决于情况。
- en: If I look at the method signature of `GetById`, it tells me it always returns
    a `Customer`. But does it *really*?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我查看`GetById`的方法签名，它告诉我它总是返回一个`Customer`。但是它*真的*吗？
- en: What happens if the customer is missing? Does `repo.GetById` return `null`?
    Does it throw an exception? You can't tell just by looking at the code that we've
    got.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户丢失会发生什么？`repo.GetById`返回`null`吗？它会抛出异常吗？你只是通过查看我们的代码无法确定。
- en: In particular, `null` is a terrible thing to return. It's a turncoat that pretends
    to be a `Customer` and can be assigned to `Customer` variables with nary a complaint
    from the compiler, but when you actually ask it to do something, it blows up in
    your face with an evil cackle. Unfortunately, I can't tell by looking at this
    code whether a null is returned or not.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，返回`null`是一件可怕的事情。它是一个背叛者，假装是一个`Customer`，并且可以被分配给`Customer`变量，而编译器却毫不抱怨，但是当你实际要求它做点什么时，它会冷笑着在你脸上爆炸。不幸的是，通过查看这段代码，我无法确定是否返回了null。
- en: Exceptions are a little better, because at least they are typed and contain
    information about the context. But it's not apparent from the method signature
    which exceptions might be thrown. The only way that you can know for sure is by
    looking at the internal source code (and maybe the documentation, if you're lucky
    and it is up to date).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 异常稍微好一点，因为至少它们是有类型的，并且包含有关上下文的信息。但是从方法签名中看不出可能抛出哪些异常。你唯一可以确定的方法是查看内部源代码（也许还有文档，如果你幸运的话，并且它是最新的）。
- en: But now imagine that your language did not allow `null` and did not allow exceptions.
    What could you do instead?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在想象一下，你的语言不允许`null`，也不允许异常。那你可以做什么呢？
- en: 'The answer is, you would be forced to return a special class that might contain
    *either* a customer *or* an error, like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，你会被迫返回一个特殊的类，它可能包含*一个*顾客*或者*一个错误，就像这样：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code that processed this "customerOrError" result would then have to test
    what kind of result it was, and handle each case separately, like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个“customerOrError”结果的代码然后必须测试它是什么类型的结果，并分别处理每种情况，就像这样：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is exactly the approach taken by most functional languages. It does help
    if the language provides conveniences to make this technique easier, such as sum
    types, but even without that, this approach is still the only way to go if you
    want to make it obvious what your code is doing. (You can read more about this
    technique [here](http://fsharpforfunandprofit.com/rop/).)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是大多数函数式语言采取的方法。如果语言提供了使这种技术更容易的便利，比如和类型，那么这将有所帮助，但即使没有，这种方法仍然是唯一可行的方式，如果你想让你的代码明确地表达出来的话。（你可以在[这里](http://fsharpforfunandprofit.com/rop/)阅读更多关于这种技术的内容。）
- en: So that's the last two items to add to our list, at least for now.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们的清单中要添加的最后两个项目，至少目前是这样。
- en: '***How to make your language predictable***:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '***如何使您的语言可预测***：'
- en: Variables should not be allowed to change their type.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不应允许变量更改其类型。
- en: Objects containing the same values should be equal by default.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含相同值的对象默认应该相等。
- en: Comparing objects of different types is a compile-time error.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较不同类型的对象是编译时错误。
- en: Objects must *always* be initialized to a valid state. Not doing so is a compile-time
    error.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象必须始终初始化为有效状态。不这样做是编译时错误。
- en: Once created, objects and collections *must* be immutable.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建，对象和集合必须是不可变的。
- en: '**No nulls allowed.**'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不允许空值。**'
- en: '**Missing data or errors must be made explicit in the function signature.**'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**函数签名中必须明确表示缺失数据或错误。**'
- en: I could go on, with snippets demonstrating the misuse of globals, side-effects,
    casting, and so on. But I think I'll stop here -- you've probably got the idea
    by now!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以继续，用一些片段来展示全局变量、副作用、强制转换等的错误用法。但我想我会在这里停下来--你现在可能已经有了想法！
- en: Can your programming language do *this*?
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的编程语言能做到*这个*吗？
- en: I hope that it is obvious that making these additions to a programming language
    will help to make it more reasonable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望很明显，对编程语言进行这些增强将有助于使其更加合理。
- en: Unfortunately, mainstream OO languages like C# are very unlikely to add these
    features.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，主流OO语言如C#很不可能添加这些功能。
- en: First of all, it would be a major breaking change to all existing code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这将是对所有现有代码的重大破坏性更改。
- en: Second, many of these changes go deeply against the grain of the object-oriented
    programming model itself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，许多这些变化深深违背了面向对象编程模型本身的基本原则。
- en: For example, in the OO model, object identity is paramount, so *of course* equality
    by reference is the default.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在OO模型中，对象的身份至关重要，因此默认情况下是按引用相等的。
- en: Also, from an OO point of view, how two objects are compared is entirely up
    to the objects themselves -- OO is all about polymorphic behavior and the compiler
    needs to stay out of it! Similarly, how objects are constructed and initialized
    is again entirely up to the object itself. There are no rules to say what should
    or should not be allowed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从OO的角度来看，两个对象如何进行比较完全取决于对象本身--OO完全是关于多态行为的，编译器需要保持距离！同样，对象如何构造和初始化也完全取决于对象本身。没有规则规定允许什么或不允许什么。
- en: Finally, it is very hard to add non-nullable reference types to a statically
    typed OO language without also implementing the initialization constraints in
    point 4. As Eric Lippert himself has said ["Non-nullability is the sort of thing
    you want baked into a type system from day one, not something you want to retrofit
    12 years later"](http://blog.coverity.com/2013/11/20/c-non-nullable-reference-types/).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在没有实现点4中的初始化约束的情况下，向静态类型的OO语言添加非空引用类型非常困难。正如Eric Lippert本人所说的["非空性是你希望从第一天就包含在类型系统中的东西，而不是12年后才想要进行后期改造"](http://blog.coverity.com/2013/11/20/c-non-nullable-reference-types/)。
- en: In contrast, most functional programming languages have these "high-predictability"
    features as a core part of the language.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，大多数函数式编程语言将这些“高可预测性”特性作为语言的核心部分。
- en: 'For example, in F#, all but one of the items on that list are built into the
    language:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在F#中，除了列表中的一个项目外，所有项目都已内置到语言中：
- en: Values are not allowed to change their type. (And this even includes implicit
    casts from int to float, say).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值不允许更改其类型。（甚至包括从int到float的隐式转换，比如说）。
- en: Records with the same internal data *ARE* equal by default.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有相同内部数据的记录默认是相等的。
- en: Comparing values of different types *IS* a compile-time error.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较不同类型的值是编译时错误。
- en: Values *MUST* be initialized to a valid state. Not doing so is a compile-time
    error.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值必须初始化为有效状态。不这样做是编译时错误。
- en: Once created, values *ARE* immutable by default.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建，值默认是不可变的。
- en: Nulls are *NOT* allowed, in general.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般情况下不允许空值。
- en: 'Item #7 is not enforced by the compiler, but discriminated unions (sum types)
    are generally used to return errors rather than using exceptions, so that the
    function signature indicates exactly what the possible errors are.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 编号#7不受编译器强制执行，但通常使用区分联合（和类型）来返回错误，而不是使用异常，以便函数签名明确指示可能的错误。
- en: It's true that when working with F# there are still many caveats. You *can*
    have mutable values, you *can* create and throw exceptions, and you may indeed
    have to deal with nulls that come from non-F# code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当使用F#时仍然存在许多注意事项。你*可以*有可变值，你*可以*创建并抛出异常，并且你确实可能不得不处理来自非F#代码的空值。
- en: But these things are considered code smells and are unusual, rather than being
    the general default.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些事情被认为是代码异味并且不寻常，而不是一般的默认设置。
- en: Other languages such as Haskell are even purer (and hence even more reasonable)
    than F#, but even Haskell programs will not be perfect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言如Haskell甚至比F#更加纯粹（因此更加合理），但即使是Haskell程序也不会是完美的。
- en: In fact, no language can be reasoned about *perfectly* and still be practical.
    But still, some languages are certainly more reasonable than others.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，没有一种语言可以完美地进行推理并且仍然是实用的。但是，有些语言确实比其他语言更合理。
- en: 'I think that one of the reasons why many people have become so enthusiastic
    about functional-style code (and call it "simple" even though it''s full of [strange
    symbols](https://gist.github.com/folone/6089236)!) is exactly this: immutability,
    and lack of side effects, and all the other functional principles, act together
    to enforce this reasonability and predictability, which in turn helps to reduce
    your cognitive burden so that you need only focus on the code in front of you.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为许多人对函数式代码如此热衷（甚至称其为“简单”尽管它充满了[奇怪的符号](https://gist.github.com/folone/6089236)）的其中一个原因恰恰是这个：不可变性，缺乏副作用以及其他所有函数式原则共同作用，以强制执行这种合理性和可预测性，进而帮助减轻你的认知负担，让你只需专注于眼前的代码。
- en: Lambdas aren't the solution
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda不是解决方案
- en: So now it should be clear that this list of proposed improvements has nothing
    to do with language enhancements such as lambdas or clever functional libraries.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚了，这个提出的改进列表与诸如lambda或聪明的函数库等语言增强无关。
- en: In other words, when I focus on reasonability, **I don't care what my language
    *will* let me do, I care more about what my language *won't* let me do.** I want
    a language that stops me doing stupid things by mistake.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我关注合理性时，**我不关心我的语言会让我做什么，我更关心的是我的语言不会让我做什么。** 我想要一种语言，可以阻止我犯愚蠢的错误。
- en: That is, if I had to choose between language A that didn't allow nulls, or language
    B that had higher-kinded types but still allowed objects to be null easily, I
    would pick language A without hesitation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果让我在允许空值的语言A和拥有高阶类型但仍容易允许对象为空的语言B之间选择，我会毫不犹豫地选择语言A。
- en: Questions
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Let me see if I can prempt some questions...
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我看看我是否可以预先回答一些问题...
- en: '**Question: These examples are very contrived! If you code carefully and follow
    good practices, you can write safe code without these features!**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题：这些例子非常牵强！如果你小心编码并遵循良好的实践，你可以在没有这些功能的情况下编写安全的代码！**'
- en: Yes, you can. I'm not claiming you can't. But this post is not about writing
    safe code, it's about *reasoning* about the code. There is a difference.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以。我并没有说你不能。但是这篇文章不是关于编写安全代码，而是关于*对代码进行推理*。有区别。
- en: And it's not about what you can do if you are careful. It's about what can happen
    if you are not careful!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说只要你小心就可以做什么。而是说如果你不小心会发生什么！
- en: That is, does your *programming language* (not your coding guidelines, or tests,
    or IDE, or development practices) give you support for reasoning about your code?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你的*编程语言*（而不是你的编码指南、测试、IDE或开发实践）是否为你的代码推理提供支持？
- en: '**Question: You''re telling me that a language *should* have these features.
    Isn''t that very arrogant of you?**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题：你在告诉我语言*应该*具有这些特性。这不是非常傲慢吗？**'
- en: 'Please read carefully. I am not saying that at all. What I *am* saying is that:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细阅读。我根本没有这么说。我*要*说的是：
- en: '*IF* you want to be able to reason about your code, *THEN* it will be much
    easier if your language supports the features that I mention.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果*你想要能够推理你的代码，*那么*如果你的语言支持我提到的功能，那将会更容易。'
- en: If reasoning about your code is not that important to you, then please do feel
    free to ignore everything I've said!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你并不重视对代码的推理，那么请随意忽略我所说的一切！
- en: '**Question: Focusing on just one aspect of a programming language is too limiting.
    Surely other qualities are just as important?**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题：专注于编程语言的某个方面会太过狭隘。其他品质肯定也同样重要吧？**'
- en: Yes, or course they are. I am not a absolutist on this topic. I think that factors
    such as comprehensive libraries, good tooling, a welcoming community, and the
    strength of the ecosystem are very important too.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，当然它们是。我在这个问题上不是绝对主义者。我认为全面的库、良好的工具、友好的社区以及生态系统的强大性等因素也非常重要。
- en: 'But the purpose of this post was to address the specific comments I mentioned
    at the beginning, such as: "C# already has most of the features of F#, so why
    should I bother to switch?".'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但本文的目的是解决我在开头提到的特定评论，例如：“C#已经拥有了大部分F#的功能，那么我为什么要费心去转换呢？”。
- en: '**Question: Why are you dismissing dynamic languages so quickly?**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题：为什么你会这么快地排除动态语言？**'
- en: First, my apologies to JavaScript developers for the dig earlier!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我为JavaScript开发人员之前的调侃道歉！
- en: I like dynamic languages a lot, and one of my favorite languages, Smalltalk,
    is completely unreasonable by the standards I've talked about. Luckily, this post
    is not trying to persuade you which languages are "best" in general, but rather
    just discussing one aspect of that choice.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢动态语言，我最喜欢的语言之一，Smalltalk，完全不符合我上面谈到的标准。幸运的是，本文并不试图说服你哪些语言在总体上是“最好的”，而只是讨论了这个选择的一个方面。
- en: '**Question: Immutable data structures are slow, and there will be lots of extra
    allocation going on. Won''t this affect performance?**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题：不可变数据结构很慢，并且会产生大量额外的分配。这不会影响性能吗？**'
- en: This post is not attempting to address the performance impact (or any other
    aspect) of these features.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本文不试图解决这些特性（或其他任何方面）的性能影响。
- en: 'But it is indeed a valid question to ask which should have a higher priority:
    code quality or performance? That''s for you to decide, and it depends on the
    context.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但确实有一个有效的问题值得提出：代码质量和性能哪个应该更重要？这取决于你自己来决定，也取决于具体情境。
- en: 'Personally, I would go for safety and quality first, unless there was a compelling
    reason not to. Here''s a sign I like:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我会优先考虑安全和质量，除非有充分的理由不这样做。以下是我喜欢的一则标志：
- en: '![Safety, Quality, Quantity, in that order](safety_first.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![按顺序排列的安全、质量、数量](safety_first.jpg)'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: I said just above that this post is not trying to persuade you to pick a language
    based on "reasonability" alone. But that's not quite true.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才说过，本文并不试图仅仅基于“合理性”来说服你选择一种语言。但这并不完全正确。
- en: If you have already picked a statically typed, high-level language such as C#
    or Java, then it's clear that reasonability or something like it was an important
    criterion in your language decision.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经选择了像C#或Java这样的静态类型、高级语言，那么显然合理性或类似的因素是你语言选择中的重要标准之一。
- en: In that case, I hope that the examples in this post might have made you more
    willing to consider using an even more "reasonable" language on your platform
    of choice (.NET or JVM).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我希望本文中的示例能让你更愿意考虑在你选择的平台（.NET或JVM）上使用更“合理”的语言。
- en: The argument for staying put -- that your current language will eventually "catch
    up" -- may be true purely in terms of features, but no amount of future enhancements
    can really change the core design decisions in an OO language. You'll never get
    rid of nulls, or mutability, or having to override equality all the time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 留在原地的论点是，你当前的语言最终会“赶上”——这在功能上可能是真的，但任何未来的增强都不能真正改变面向对象语言的核心设计决策。你永远无法摆脱空指针、可变性，或者一直要覆盖相等性。
- en: What's nice about F#, or Scala/Clojure, is that these functional alternatives
    don't require you to change your ecosystem, but they do immediately improve your
    code quality.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: F#、Scala/Clojure之类的优点在于，这些函数式的替代方案不需要你改变你的生态系统，但它们立即提高了你的代码质量。
- en: In my opinion, it's quite a low risk compared with the cost of business as usual.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，与业务惯例的成本相比，这是一个非常低风险的选择。
- en: '*(I''ll leave the issue of finding skilled people, training, support, etc,
    for another post. But see [this](http://www.paulgraham.com/pypar.html), [this](https://twitter.com/panesofglass/status/559431579328475136),
    [this](https://twitter.com/foxyjackfox/status/559415445594206208), and [this](http://wesmorgan.svbtle.com/recruiting-software-developers-language-matters)
    if you''re worried about hiring)*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*(我将把寻找熟练人才、培训、支持等问题留到另一篇文章。但如果你担心招聘问题，可以参考[这篇文章](http://www.paulgraham.com/pypar.html)，[这条推文](https://twitter.com/panesofglass/status/559431579328475136)，[这条推文](https://twitter.com/foxyjackfox/status/559415445594206208)，以及[这篇文章](http://wesmorgan.svbtle.com/recruiting-software-developers-language-matters)*'
