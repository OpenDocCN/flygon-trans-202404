- en: 6Processing Lists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6处理列表
- en: '|     [6.1 Making Lists and Taking Them Apart](#%28part._.Making_.Lists_and_.Taking_.Them_.Apart%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [6.1 制作列表和拆分列表](https://wiki.example.org/feynmans_learning_method) |'
- en: '|     [6.2 Some Example Exercises](#%28part._my-len%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [6.2 一些示例练习](https://wiki.example.org/feynmans_learning_method) |'
- en: '|     [6.3 Structural Problems with Scalar Answers](#%28part._.Structural_.Problems_with_.Scalar_.Answers%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [6.3 标量答案的结构问题](https://wiki.example.org/feynmans_learning_method) |'
- en: '|       [6.3.1 my-len: Examples](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Examples%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [6.3.1 my-len: 示例](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.3.2 my-sum: Examples](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Examples%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [6.3.2 my-sum: 示例](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.3.3 From Examples to Code](#%28part._.From_.Examples_to_.Code%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [6.3.3 从示例到代码](https://wiki.example.org/feynmans_learning_method) |'
- en: '|     [6.4 Structural Problems with List Answers](#%28part._.Structural_.Problems_with_.List_.Answers%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|     [6.4 列表答案的结构问题](https://wiki.example.org/feynmans_learning_method) |'
- en: '|       [6.4.1 my-str-len: Examples and Code](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Examples_and_.Code%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [6.4.1 my-str-len: 示例和代码](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.4.2 my-pos-nums: Examples and Code](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Examples_and_.Code%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [6.4.2 my-pos-nums: 示例和代码](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.4.3 my-alternating: First Attempt](#%28part._alternating-1st-attempt%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|       [6.4.3 my-alternating: 第一次尝试](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.4.4 my-running-sum: First Attempt](#%28part._running-sum-1st-attempt%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [6.4.4 my-running-sum: 第一次尝试](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|     [6.5 Structural Problems with Sub-Domains](#%28part._struct-prob-sub-dom%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|     [6.5 子域的结构问题](https://wiki.example.org/feynmans_learning_method) |'
- en: '|       [6.5.1 my-max: Examples](#%28part._my-max%29) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|       [6.5.1 my-max: 示例](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.5.2 my-max: From Examples to Code](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.From_.Examples_to_.Code%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|       [6.5.2 my-max: 从示例到代码](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.5.3 my-alternating: Examples and Code](#%28part._alternating-adjusting%29)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|       [6.5.3 my-alternating: 示例和代码](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|     [6.6 More Structural Problems with Scalar Answers](#%28part._.More_.Structural_.Problems_with_.Scalar_.Answers%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|     [6.6 更多标量答案的结构问题](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.6.1 my-avg: Examples](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Examples%29)
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|       [6.6.1 my-avg: 示例](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|     [6.7 Structural Problems with Accumulators](#%28part._accumulators%29)
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|     [6.7 累加器的结构问题](https://wiki.example.org/feynmans_learning_method) |'
- en: '|       [6.7.1 my-running-sum: Examples and Code](#%28part._running-sum-eg-code%29)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|       [6.7.1 my-running-sum: 示例和代码](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.7.2 my-alternating: Examples and Code](#%28part._alternating-accumulator%29)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|       [6.7.2 my-alternating: 示例和代码](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|     [6.8 Dealing with Multiple Answers](#%28part._.Dealing_with_.Multiple_.Answers%29)
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|     [6.8 处理多个答案](https://wiki.example.org/feynmans_learning_method) |'
- en: '|       [6.8.1 uqiq: Problem Setup](#%28part._uniq%29) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|       [6.8.1 uqiq: 问题设置](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.8.2 uniq: Examples](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Examples%29)
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|       [6.8.2 uniq: 示例](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.8.3 uniq: Code](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Code%29)
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|       [6.8.3 uniq: 代码](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.8.4 uniq: Reducing Computation](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Reducing_.Computation%29)
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|       [6.8.4 uniq: 减少计算](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.8.5 uniq: Example and Code Variations](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Example_and_.Code_.Variations%29)
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|       [6.8.5 uniq: 示例和代码变体](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|       [6.8.6 uniq: Why Produce a List?](#%28part.___struct_traverse-element___procedure_____render-cond_rkt_38_12____.Why_.Produce_a_.List_%29)
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|       [6.8.6 uniq: 为什么生成列表？](https://wiki.example.org/feynmans_learning_method)
    |'
- en: '|     [6.9 Monomorphic Lists and Polymorphic Types](#%28part._.Monomorphic_.Lists_and_.Polymorphic_.Types%29)
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|     [6.9 单态列表和多态类型](#%28part._.Monomorphic_.Lists_and_.Polymorphic_.Types%29)
    |'
- en: We have already seen [[From Tables to Lists](tables-to-lists.html)] several
    examples of list-processing functions. They have been especially useful for advanced
    processing of tables. However, lists arise frequently in programs, and they do
    so naturally because so many things in our lives—<wbr>from shopping lists to to-do
    lists to checklists—<wbr>are naturally lists. As we already briefly discussed
    earlier [[Lists as Anonymous Data](tables-to-lists.html#%28part._lists-generic-data%29)],
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了[从表到列表](tables-to-lists.html)中的几个列表处理函数示例。它们对表的高级处理非常有用。但是，列表经常在程序中出现，这是很自然的，因为我们生活中的许多事物——从购物清单到待办事项列表再到检查清单——都是自然列表。正如我们之前已经简要讨论的那样[列表作为匿名数据](tables-to-lists.html#%28part._lists-generic-data%29)，
- en: 'some list functions are generic and operate on any kind of list: e.g., the
    length of a list is the same irrespective of what kind of values it contains;'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些列表函数是通用的，可以操作任何类型的列表：例如，列表的长度是相同的，不管它包含什么类型的值；
- en: 'some are specific at least to the type of data: e.g., the sum assumes that
    all the values are numbers (though they may be ages or prices or other information
    represented by numbers); and'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些至少对数据类型是特定的：例如，总和假设所有值都是数字（尽管它们可能是年龄或价格或用数字表示的其他信息）；以及
- en: 'some are somewhere in-between: e.g., a maximum function applies to any list
    of comparable values, such as numbers or strings.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些处于中间状态：例如，最大函数适用于任何可比较值的列表，例如数字或字符串。
- en: This seems like a great varity, and we might worry about how we can handle this
    many different kinds of functions. Fortunately, and perhaps surprisingly, there
    is one standard way in which we can think about writing all these functions! Our
    mission is to understand and internalize this process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个很大的变化，我们可能会担心我们如何处理这么多不同种类的函数。幸运的是，也许令人惊讶的是，有一种标准的方式，我们可以考虑编写所有这些函数！我们的任务是理解并内化这个过程。
- en: 6.1Making Lists and Taking Them Apart
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1制作列表并拆分列表
- en: 'So far we’ve seen one way to make a list: by writing [list: …]. While useful,
    writing lists this way actually hides their true nature. Every list actually has
    two parts: a first element and the rest of the list. The rest of the list is itself
    a list, so it too has two parts…and so on.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们已经看到了一种制作列表的方法：通过写 [list: …]。虽然有用，但是以这种方式写列表实际上隐藏了它们真正的本质。每个列表实际上有两部分：第一个元素和列表的其余部分。列表的其余部分本身也是一个列表，所以它也有两部分……等等。'
- en: 'Consider the list [list: 1, 2, 3]. Its head is 1, and the rest of it is [list:
    2, 3]. For this second list, the head is 2 and the rest is [list: 3].'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑列表 [list: 1, 2, 3]。其头部是1，其余部分是 [list: 2, 3]。对于这第二个列表，头部是2，其余部分是 [list: 3]。'
- en: Do Now!
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take apart this third list.
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拆解这第三个列表。
- en: 'For the third list, the head is 3 and the rest is [list: ], i.e., the empty
    list. In Pyret, we have another way of writing the empty list: empty.Here, we’ve
    taken the lists apart manually. Naturally, Pyret has operations that let us do
    that. Lists are an instance of structured data, and in general there are two ways
    to take apart structured data: using cases, which we will see below, and using
    accessors. A list has two accessors: first and rest. We use an accessor by writing
    an expression, followed by a dot (.), followed by the accessor’s name. Thus:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '对于第三个列表，头部是3，其余部分是 [list: ]，即空列表。在Pyret中，我们还有另一种写空列表的方式：empty。在这里，我们手动拆分了列表。当然，Pyret有让我们做到这一点的操作。列表是结构化数据的一个实例，在一般情况下，有两种拆解结构化数据的方式：使用cases，我们将在下面看到，以及使用访问器。列表有两个访问器：first
    和 rest。我们通过写一个表达式，后跟一个点（.），再跟访问器的名称来使用访问器。因此：'
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Thus, .first and .rest give us a way to take apart a list. Can we also put
    together a list piece-by-piece? This would be especially useful for building up
    a list. And indeed we can: the function (called a constructor) that makes lists
    is called link. It takes two arguments: a list element, and the rest of the list.
    Thus, l1 above is equivalent to a series of links followed by empty:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，.first 和 .rest 给了我们一种拆解列表的方式。我们也能把列表一块块地组合起来吗？这对于构建列表尤其有用。事实上我们可以：制造列表的函数（称为构造函数）叫做
    link。它接受两个参数：一个列表元素，以及列表的其余部分。因此，上面的 l1 等价于一系列链接后跟空：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Obviously, writing the link form is not very convenient to humans. But it will
    prove very valuable to programs!Observe, in summary, that broadly speaking we
    have two kinds of lists. Some lists are empty. All other lists are non-empty lists,
    meaning they have at least one link. There may be more interesting structure to
    some lists, but all lists have this much in common. Specifically, a list is either
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，以链接形式书写不太方便给人阅读。但对程序来说，这将非常有价值！总之，大体上我们有两种类型的列表。有些列表是空的。所有其他列表都是非空列表，意味着它们至少有一个链接。某些列表可能具有更有趣的结构，但所有列表都有这么多共同之处。具体来说，一个列表要么是
- en: 'empty (written empty or [list: ]), or'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '空（写作 empty 或者 [list: ]），或者'
- en: 'non-empty (written link(…, …) or [list: ] with at least one value inside the
    brackets), where the rest is also a list (and hence may in turn be empty or non-empty,
    …).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '非空（写作 link(…, …) 或者 [list: ]，括号内至少有一个值），其中剩余部分也是列表（因此可能为空或非空，…）。'
- en: 6.2Some Example Exercises
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 一些示例练习
- en: To illustrate our thinking, let’s work through a few concrete examples of list-processing
    functions. All of these will consume lists; some will even produce them. Since
    some of these functions already exist in Pyret, we’ll name them with the prefix
    my- to avoid errors.Be sure to use the my- name consistently, including inside
    the body of the function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们的思路，让我们通过一些具体的列表处理函数示例来解决几个具体的问题。所有这些函数都将消耗列表；有些甚至会生成列表。由于其中一些函数已经存在于
    Pyret 中，我们将它们命名为 my- 前缀以避免错误。请务必一致使用 my- 名称，包括在函数体内。
- en: 'Compute the length of a list:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算列表的长度：
- en: '[PRE2]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compute the sum of a list (of numbers):'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算列表（数字）的总和：
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compute the maximum of a list (of numbers or strings):'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算列表（数字或字符串）的最大值：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Given a list of strings, convert each string to a number representing its length:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一组字符串，将每个字符串转换为表示其长度的数字：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Given a list of numbers, generate a list of its positive numbers:If you want
    to be pedantic: its positive numbers with the same count and in the same order.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一组数字，生成其正数列表：如果你想追究起来：具有相同数量并且顺序相同的正数列表。
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given a list of numbers, replace every element with the running sum, i.e.,
    the sum of all the elements from the beginning of the list until that element
    (inclusive):'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一组数字，将每个元素替换为累加和，即从列表开头到该元素的所有元素的总和（含该元素）：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Given a list, keep every alternate element in it, starting from the first:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个列表，从第一个元素开始，保留其中的每个交替元素：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Given a list of numbers, compute the average of the numbers:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一组数字，计算数字的平均值：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To solve problems like this, there are two things we should do:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这类问题，我们应该做两件事：
- en: Construct examples of the function’s behavior.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数行为的示例。
- en: Employ the template that suggests possible solutions.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用建议可能解决方案的模板。
- en: Both steps sound simple but have several nuances, which we will explore.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤听起来很简单，但有几个细微之处，我们将探讨。
- en: 6.3Structural Problems with Scalar Answers
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 标量答案的结构性问题
- en: 'Let’s write out examples for a few of the functions described above. We’ll
    approach writing examples in a very specific, stylized way. First of all, we should
    always construct at least two examples: one with empty and the other with at least
    one link, so that we’ve covered the two very broad kinds of lists. Then, we should
    have more examples specific to the kind of list stated in the problem. Finally,
    we should have even more examples to illustrate how we think about solving the
    problem.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为上述几个函数写出一些示例。我们将以一种非常具体、风格化的方式编写示例。首先，我们应该至少构造两个示例：一个是空的，另一个至少有一个链接，这样我们就涵盖了两种非常广泛的列表类型。然后，我们应该有更多针对问题陈述的列表类型的具体示例。最后，我们应该有更多示例来说明我们如何考虑解决问题。
- en: '6.3.1my-len: Examples'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 my-len：示例
- en: We have’t precisely defined what it means to be “the length” of a list. We confront
    this right away when trying to write an example. What is the length of the list
    empty?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有精确定义“列表的长度”是什么意思。在尝试编写示例时，我们立即面对这个问题。空列表的长度是多少？
- en: Do Now!
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think?
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你认为呢？
- en: 'Two common examples are 0 and 1. The latter, 1, certainly looks reasonable.
    However, if you write the list as [list: ], now it doesn’t look so right: this
    is clearly (as the name empty also suggests) an empty list, and an empty list
    has zero elements in it. Therefore, it’s conventional to declare that'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '两个常见的示例是 0 和 1。后者，1，看起来肯定合理。但是，如果你把列表写成 [list: ]，现在它看起来不太对：显然（正如 empty 这个名称所暗示的那样）这是一个空列表，并且空列表中没有元素。因此，习惯上声明'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'How about a list like [list: 7]? Well, it’s clearly got one element (7) in
    it, so'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '对于像[list: 7]这样的列表呢？嗯，显然它只有一个元素（7），所以'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, for a list like [list: 7, 8, 9], we would say'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '类似地，对于像[list: 7, 8, 9]这样的列表，我们会说'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let’s look at that last example in a different light. Consider the argument
    [list: 7, 8, 9]. Its first element is 7 and the rest of it is [list: 8, 9]. Well,
    7 is a number, not a list; but [list: 8, 9] certainly is a list, so we can ask
    for its length. What is my-len([list: 8, 9])? It has two elements, so'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们从另一个角度来看最后一个例子。考虑参数[list: 7, 8, 9]。它的第一个元素是7，其余部分是[list: 8, 9]。嗯，7是一个数字，而不是一个列表；但[list:
    8, 9]显然是一个列表，所以我们可以问它的长度。my-len([list: 8, 9])是多少？它有两个元素，所以'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first element of that list is 8 while its rest is [list: 9]. What is its
    length? Note that we asked a very similar question before, for the length of the
    list [list: 7]. But [list: 7] is not a sub-list of [list: 7, 8, 9], which we started
    with, whereas [list: 9] is. And using the same reasoning as before, we can say'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '列表的第一个元素是8，而其余部分是[list: 9]。它的长度是多少？请注意，我们之前问过一个非常类似的问题，关于列表[list: 7]的长度。但是[list:
    7]不是[list: 7, 8, 9]的子列表，而我们起初的列表是，而[list: 9]是。使用与之前相同的推理，我们可以说'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The rest of this last list is, of course, the empty list, whose length we have
    already decided is 0.Putting together these examples, and writing out empty in
    its other form, here’s what we get:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后一个列表的其余部分当然是空列表，我们已经决定其长度为0。将这些示例放在一起，并用其另一种形式写出empty，我们得到以下结果：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Another way we can write this (paying attention to the right side) is
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其另一种写法（注意右侧）为
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From this, maybe you can start to see a pattern. For an empty list, the length
    is 0. For a non-empty list, it’s the sum of 1 (the first element’s “contribution”
    to the list’s length) to the length of the rest of the list. That is,
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，也许你可以开始看到一个模式。对于空列表，长度为0。对于非空列表，它是1（第一个元素对列表长度的“贡献”）加上列表其余部分的长度的总和。也就是说，
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That is, we can use the result of computing my-len on the rest of the list to
    compute the answer for the entire list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可以使用计算出的my-len在列表的其余部分上计算出整个列表的答案。
- en: Double-check all these and make sure you understand the calculations. It’ll
    prove central to how we write the program later!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查所有这些，并确保你理解这些计算。这将对我们后面如何编写程序至关重要！
- en: '6.3.2my-sum: Examples'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2my-sum：示例
- en: 'A similar logic applies to how we treat a function like my-sum. What do we
    want the sum of the empty list to be? Well, it may be entirely clear, so let’s
    move on for a moment. What is the sum of the list [list: 7, 8, 9]? Well, clearly
    we intend for this to be 24. Let’s see how that works out.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '类似的逻辑适用于我们如何处理像my-sum这样的函数。我们希望空列表的总和是多少？嗯，可能并不是完全清楚，所以让我们暂时继续。列表[list: 7,
    8, 9]的总和是多少？显然，我们打算它是24。让我们看看结果如何。'
- en: 'Setting aside the empty list for a moment, here are sums we can agree upon:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时搁置空列表，以下是我们可以达成一致的总和：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: which is the same as
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下相同：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From this, we can see that the sum of the empty list must be 0:Zero is called
    the additive identity: a fancy way of saying, adding zero to any number N gives
    you N. Therefore, it makes sense that it would be the length of the empty list,
    because the empty list has no items to contribute to a sum. Can you figure out
    what the multiplicative identity is?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们可以看出空列表的总和必须为0：零被称为加法恒等式：一个说法是，将零添加到任何数字N中都会得到N。因此，它是空列表的长度是有道理的，因为空列表没有项目可以贡献给总和。你能想出乘法恒等式是什么吗？
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Observe, again, how we can use the result of computing my-sum of the rest of
    the list to compute its result for the whole list.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次观察，我们如何使用计算出的my-sum的结果来计算整个列表的结果。
- en: 6.3.3From Examples to Code
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3从示例到代码
- en: Given these examples, we can now turn them into code. We introduce the construct
    cases, which lets us tell apart different kinds of lists, and use it to provide
    answers for each kind of list.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些示例，我们现在可以将它们转换为代码。我们引入了cases结构，它让我们区分不同类型的列表，并使用它来为每种类型的列表提供答案。
- en: 'The grammar for cases is as follows: [FILL] [FILL TEMPLATES]'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 情况的语法如下：[填充] [填充模板]
- en: 'Now let’s use cases to define my-len:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用cases来定义my-len：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This follows from our examples: when the list is empty my-len produces 0; when
    it is not empty, we add one to the length of the rest of the list (here, r).Similarly,
    let’s define my-sum:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从我们的示例中得出的：当列表为空时，my-len产生0；当它不为空时，我们将其余部分的长度（这里是r）加一。同样，让我们定义my-sum：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how similar they are in code, and how readily the structure of the data
    suggest a structure for the program. This is a pattern you will get very used
    to soon!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它们在代码中是多么相似，以及数据结构如何迅速地为程序的结构提供了结构。这是一个你很快会非常熟悉的模式！
- en: 6.4Structural Problems with List Answers
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4列表答案的结构问题
- en: Now let’s tackle the functions that produce a list as the answer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来解决产生列表作为答案的函数。
- en: '6.4.1my-str-len: Examples and Code'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1我的字符串长度：示例和代码
- en: 'As always, we’ll begin with some examples. Given a list of strings, we want
    the lengths of each string (in the same order). Thus, here’s a reasonable example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们将从一些示例开始。给定一个字符串列表，我们想要每个字符串的长度（按照相同的顺序）。因此，这是一个合理的例子：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we have before, we should consider how the answers for each sub-problem
    of the above example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们以前所做的，我们应该考虑以上例子的每个子问题的答案：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or, in other words:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，换句话说：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'which tells us that the response for the empty list should be empty:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们空列表的响应应该是空的：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that for brevity we’re written the answers of converting each string (2,
    5, and 6), each of which we obtain by applying string-length to the first element
    of the list at each point. Therefore, we can formulate a solution from this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了简洁起见，我们已经写出了转换每个字符串（2、5 和 6）的答案，每个答案都是通过将字符串长度应用于列表中的第一个元素而获得的。因此，我们可以从中制定一个解决方案：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '6.4.2my-pos-nums: Examples and Code'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2我的正数：示例和代码
- en: Do Now!
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 立即行动！
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Construct the sequence of examples that we obtain from the input [list: 1,
    -2, 3, -4].'
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '构造我们从输入 [list: 1, -2, 3, -4] 得到的示例序列。'
- en: 'Here we go:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can write this in the following form:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下形式写出它：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: or, even more explicitly,
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更明确地说，
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That is, when the first element is positive we link it into the result of computing
    my-pos-nums on the rest of the list; when the first element is negative, the result
    is just that of computing my-pos-nums on the rest of the list. This yields the
    following program:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，当第一个元素为正时，我们将其连接到计算列表其余部分的我的正数结果中；当第一个元素为负时，结果只是计算列表其余部分的我的正数。这产生了以下程序：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Do Now!
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 立即行动！
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is our set of examples comprehensive?
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们的示例集是否全面？
- en: Not really. There are many examples we haven’t considered, such as lists that
    end with positive numbers and lists with 0.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其实不是。我们还没有考虑许多示例，比如以正数结尾的列表和包含 0 的列表。
- en: Exercise
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work through these examples and see how they affect the program!
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过这些示例看看它们如何影响程序！
- en: '6.4.3my-alternating: First Attempt'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3我的替代：第一次尝试
- en: Once again, we’re going to work from examples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将从示例开始。
- en: Do Now!
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 立即行动！
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for my-alternating starting from the list [list: 1, 2,
    3, 4, 5, 6].'
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '计算从列表 [list: 1, 2, 3, 4, 5, 6] 开始的我的替代结果。'
- en: Here’s how they work out:<alternating-egs-1> ::=
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它们的计算结果：<alternating-egs-1> ::=
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Wait, what’s that? The two answers above are each correct, but the second answer
    does not help us in any way construct the first answer. That means the way we’ve
    solved these problems until now is not enough, and we have more thinking to do.
    We’ll return to this later [[my-alternating: Examples and Code](#%28part._alternating-adjusting%29)
    and also [my-alternating: Examples and Code](#%28part._alternating-accumulator%29)].'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么？以上两个答案都是正确的，但第二个答案并没有帮助我们构建第一个答案。这意味着我们到目前为止解决这些问题的方式还不够，我们还需要更多的思考。我们稍后会回到这个问题
    [[我的替代：示例和代码](#%28part._alternating-adjusting%29) 和 [我的替代：示例和代码](#%28part._alternating-accumulator%29)]。
- en: '6.4.4my-running-sum: First Attempt'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.4我的累积和：第一次尝试
- en: One more time, we’ll begin with an example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们将从一个例子开始。
- en: Do Now!
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 立即行动！
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for my-running-sum starting from the list [list: 1, 2,
    3, 4, 5].'
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '计算从列表 [list: 1, 2, 3, 4, 5] 开始的我的累积和结果。'
- en: Here’s what our first few examples look like:<running-sum-egs-1> ::=
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的前几个示例的样子：<running-sum-egs-1> ::=
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Again, there doesn’t appear to be any clear connection between the result on
    the rest of the list and the result on the entire list.(That isn’t strictly true:
    we can still line up the answers as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，似乎没有明显的联系在列表其余部分的结果和整个列表的结果之间。（这并不严格正确：我们仍然可以按照以下方式排列答案：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: and observe that we’re computing the answer for the rest of the list, then adding
    the first element to each element in the answer, and linking the first element
    to the front. In principle, we can compute this solution directly (as we will
    see later [REF]), but for now that may be more work than finding a simpler way
    to answer it.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并且观察我们正在计算列表的其余部分的答案，然后将第一个元素添加到答案中的每个元素，并将第一个元素链接到前面。原则上，我们可以直接计算这个解决方案（正如我们将在稍后看到的那样[REF]），但是目前这可能比找到一个更简单的方法来回答它更费力。）
- en: 'We’ll return to this function later, too [[my-running-sum: Examples and Code](#%28part._running-sum-eg-code%29)].'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '我们稍后也会回到这个函数 [[my-running-sum: Examples and Code](#%28part._running-sum-eg-code%29)]。'
- en: 6.5Structural Problems with Sub-Domains
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5子域的结构问题
- en: '6.5.1my-max: Examples'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1my-max：示例
- en: 'Now let’s find the maximum value of a list. Let’s assume for simplicity that
    we’re dealing with just lists of numbers. What kinds of lists should we construct?
    Clearly, we should have empty and non-empty lists…but what else? Is a list like
    [list: 1, 2, 3] a good example? Well, there’s nothing wrong with it, but we should
    also consider lists where the maximum at the beginning rather than at the end;
    the maximum might be in the middle; the maximum might be repeated; the maximum
    might be negative; and so on. While not comprehensive, here is a small but interesting
    set of examples:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们找到列表的最大值。为了简单起见，假设我们只处理数字列表。我们应该构造什么样的列表？显然，我们应该有空列表和非空列表...但是还有什么？像 [list:
    1, 2, 3] 这样的列表是一个好的例子吗？嗯，这没问题，但是我们还应该考虑列表中的最大值在开始而不是结束；最大值可能在中间；最大值可能重复；最大值可能是负数；等等。虽然不全面，但这里是一组小但有趣的例子：'
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What about my-max(empty)?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: my-max(empty) 怎么样？
- en: Do Now!
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Could we define my-max(empty) to be 0? Returning 0 for the empty list has worked
    well twice already!
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们能把 my-max(empty) 定义为 0 吗？返回空列表的 0 已经成功两次了！
- en: 'We’ll return to this in a while.Before we proceed, it’s useful to know that
    there’s a function called num-max already defined in Pyret, that compares two
    numbers:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一会儿会回到这个问题。在我们继续之前，了解一下在 Pyret 中已经定义了一个叫做 num-max 的函数，它可以比较两个数字：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Exercise
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose num-max were not already built in. Can you define it? You will find
    what you learned about [Booleans](basic-data-expr.html#%28part._booleans%29) handy.
    Remember to write some tests!
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设 num-max 还没有内置。你能定义它吗？你会发现你对[布尔值](basic-data-expr.html#%28part._booleans%29)所学的东西很有用。记得写一些测试！
- en: 'Now we can look at my-max at work:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看 my-max 在工作了：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Hmm. That didn’t really teach us anything, did it? Maybe, we can’t be sure.
    And we still don’t know what to do with empty.Let’s try the second example input:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯。那并没有真正教给我们什么，对吧？也许，我们不能确定。而且我们还不知道该怎么处理空。让我们尝试第二个示例输入：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is actually telling us something useful as well, but maybe we can’t see
    it yet. Let’s take on something more ambitious:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上也告诉了我们一些有用的信息，但也许我们还看不到。让我们尝试一些更有雄心的事情：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Observe how the maximum of the rest of the list gives us a candidate answer,
    but comparing it to the first element gives us a definitive one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意观察剩余列表的最大值如何给我们一个候选答案，但是与第一个元素进行比较给我们一个确定的答案：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last one is a little awkward: we’d like to write'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有点尴尬：我们想写
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: but we don’t really know what the maximum (or minimum, or any other element)
    of the empty list is, but we can only provide numbers to num-max. Therefore, leaving
    out that dodgy case, we’re left with
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们并不真正知道空列表的最大值（或最小值，或任何其他元素），但是我们只能向 num-max 提供数字。因此，略过这个可疑的情况，我们剩下的是
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our examples have again helped: they’ve revealed how we can use the answer
    for each rest of the list to compute the answer for the whole list, which in turn
    is the rest of some other list, and so on. If you go back and look at the other
    example lists we wrote above, you’ll see the pattern holds there too.However,
    it’s time we now confront the empty case. The real problem is that we don’t have
    a maximum for the empty list: for any number we might provide, there is always
    a number bigger than it (assuming our computer is large enough) that could have
    been the answer instead. In short, it’s nonsensical to ask for the maximum (or
    minimum) of the empty list: the concept of “maximum” is only defined on non-empty
    lists! That is, when asked for the maximum of an empty list, we should signal
    an error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子再次有所帮助：它们揭示了我们如何使用列表的每个剩余部分的答案来计算整个列表的答案，而整个列表的答案又是另一个列表的剩余部分，依此类推。如果你回头看一下我们上面写过的其他示例列表，你会发现模式也适用于那里。然而，现在是时候面对空情况了。真正的问题是，我们没有空列表的最大值：无论我们提供的数字是多少，总有一个比它更大的数字（假设我们的计算机足够大），可以成为答案。简而言之，询问空列表的最大值（或最小值）是不合逻辑的：“最大值”这个概念仅在非空列表上定义！也就是说，当被问及空列表的最大值时，我们应该发出错误信号：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: (which is how, in Pyret, we say that it will generate an error; we don’t care
    about the details of the error, hence the empty string).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: （这就是在 Pyret 中我们说它会生成错误的方式；我们不关心错误的细节，因此为空字符串）。
- en: '6.5.2my-max: From Examples to Code'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '6.5.2my-max: 从示例到代码'
- en: 'Once again, we can codify the examples above, i.e., turn them into a uniform
    program that works for all instances. However, we now have a twist. If we blindly
    followed the pattern we’ve used earlier, we would end up with:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以将上述例子编码，即将它们转换为适用于所有实例的统一程序。然而，现在我们有了一个转折。如果我们盲目地遵循我们之前使用的模式，我们最终会得到：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Do Now!
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s wrong with this?
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这有什么问题？
- en: 'Consider the list [list: 2]. This turns into'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑列表 [list: 2]。这变成了'
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: which of course raises an error. Therefore, this function never works for any
    list that has one or more elements!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然会引发错误。因此，这个函数永远不会对任何具有一个或多个元素的列表起作用！
- en: 'That’s because we need to make sure aren’t trying to compute the maximum of
    the empty list. There are two ways to do this. We’ll see one now, and return to
    the other way later [REF: accumulators].'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '这是因为我们需要确保不要尝试计算空列表的最大值。有两种方法可以做到这一点。我们现在来看一种方法，稍后回到另一种方法[REF: 累加器]。'
- en: 'Going back to our examples, we see that what we need to do, before calling
    my-max, is check whether the rest of the list is empty. If it is, we do not want
    to call my-max at all. That is:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，我们看到在调用 my-max 之前，我们需要做的是检查列表的剩余部分是否为空。如果是的话，我们根本不想调用 my-max。也就是：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We’ll return to what to do when the rest is not empty in a moment.If the rest
    of the list l is empty, our examples above tell us that the maximum is the first
    element in the list. Therefore, we can fill this on:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们马上会回到当剩余部分不为空时该怎么办的问题。如果列表 l 的剩余部分为空，我们上面的例子告诉我们最大值是列表中的第一个元素。因此，我们可以填写这个：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note in particular the absence of a call to my-max. If the list is not empty,
    however, our examples above tell us that my-max will give us the maximum of the
    rest of the list, and we just need to compare this answer with the first element
    (f):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，没有调用 my-max。然而，如果列表不为空，我们上面的例子告诉我们 my-max 将给出列表剩余部分的最大值，我们只需要将这个答案与第一个元素（f）进行比较：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And sure enough, this definition does the job!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 而确实，这个定义完成了任务！
- en: '6.5.3my-alternating: Examples and Code'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '6.5.3my-alternating: 示例和代码'
- en: 'Looking back at [my-alternating: First Attempt](#%28part._alternating-1st-attempt%29),
    we can see that every alternate example is one we want. The problem is, to get
    from one example to the one two below, we have to remove two elements, not just
    one. That is, we have to pretend our list has elements in pairs, not singles.
    In terms of examples, this would look as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '回顾一下[my-alternating: 第一次尝试](#%28part._alternating-1st-attempt%29)，我们可以看到每个交替的例子都是我们想要的。问题在于，要从一个例子到下面的两个例子，我们必须移除两个元素，而不仅仅是一个。也就是说，我们必须假装我们的列表是成对的元素，而不是单个元素。就示例而言，这看起来如下：'
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now it’s pretty easy to see how to construct a program: keep the first element,
    skip the second, and repeat. Let’s see how far we can get using the template:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易看出如何构建一个程序：保留第一个元素，跳过第二个元素，然后重复。让我们看看使用模板能走多远：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Do Now!
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about how to complete this definition.
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想一想如何完成这个定义。
- en: 'Before we proceed, there is a small problem: our example is not good enough
    to cover all the cases we’ll encounter. Specifically, to traverse by two we must
    have two elements, but we might not: the list might have only an odd number of
    elements. That is, we might instead have'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一个小问题：我们的例子不足以涵盖我们将遇到的所有情况。具体来说，要以两个元素遍历，我们必须有两个元素，但我们可能没有：列表可能只有奇数个元素。也就是说，我们可能会有
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'What this means is: We won’t always terminate with the empty list. We have
    to be prepared to terminate with a list of one element. This suggests how we can
    complete the definition:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：我们不会总是以空列表终止。我们必须准备以一个元素的列表终止。这提示了我们如何完成定义：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In [my-alternating: Examples and Code](#%28part._alternating-accumulator%29)
    we’ll see another way of approaching this problem.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[my-alternating：示例和代码](#%28part._alternating-accumulator%29)中，我们将看到另一种解决这个问题的方法。
- en: 6.6More Structural Problems with Scalar Answers
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6更多具有标量答案的结构性问题
- en: '6.6.1my-avg: Examples'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1my-avg：示例
- en: 'Let’s now try to compute the average of a list of numbers. Let’s start with
    the example list [list: 1, 2, 3, 4] and work out more examples from it. The average
    of numbers in this list is clearly (1 + 2 + 3 + 4)/4, or 10/4.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们尝试计算一组数字的平均值。让我们从示例列表[list: 1, 2, 3, 4]开始，并从中找出更多例子。这个列表中数字的平均值显然是(1 +
    2 + 3 + 4)/4，或10/4。'
- en: 'Based on the list’s structure, we see that the rest of the list is [list: 2,
    3, 4], and the rest of that is [list: 3, 4], and so on. The resulting averages
    are:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '根据列表的结构，我们看到剩余列表是[list: 2, 3, 4]，其余部分是[list: 3, 4]，依此类推。得到的平均值是：'
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The problem is, it’s simply not clear how we get from the answer for the sub-list
    to the answer for the whole list. That is, given the following two bits of information:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们如何从子列表的答案得到整个列表的答案并不清楚。也就是说，给定以下两个信息：
- en: The average of the remainder of the list is 9/3, i.e., 3.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余列表的平均值为9/3，即3。
- en: The first number in the list is 1.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中的第一个数字是1。
- en: 'How do we determine that the average of the whole list must be 10/4? If it’s
    not clear to you, don’t worry: with just those two pieces of information, it’s
    impossible!Here’s a simpler example that explains why. Let’s suppose the first
    value in a list is 1, and the average of the rest of the list is 2. Here are two
    very different lists that fit this description:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定整个列表的平均值必须是10/4？如果你不清楚，不要担心：仅凭这两个信息，是不可能的！以下是一个更简单的例子，解释了为什么。假设列表中的第一个值是1，剩余列表的平均值为2。以下是两个符合此描述的非常不同的列表：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The average of the entire first list is 3/2, while the average of the entire
    second list is 5/3, and the two are not the same.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 整个第一个列表的平均值为3/2，而整个第二个列表的平均值为5/3，两者并不相同。
- en: That is, to compute the average of a whole list, it’s not even useful to know
    the average of the rest of the list. Rather, we need to know the sum and the length
    of the rest of the list. With these two, we can add the first to the sum, and
    1 to the length, and compute the new average.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，要计算整个列表的平均值，甚至不需要知道剩余列表的平均值。相反，我们需要知道剩余列表的总和和长度。有了这两个信息，我们可以将第一个值加到总和中，将1加到长度中，并计算新的平均值。
- en: 'In principle, we could try to make a average function that returns all this
    information. Instead, it will be a lot simpler to simply decompose the task into
    two smaller tasks. After all, we have already seen how to compute the length and
    how to compute the sum. The average, therefore, can just use these existing functions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们可以尝试制作一个返回所有这些信息的平均函数。相反，将任务简单分解为两个较小的任务会更简单。毕竟，我们已经看到如何计算长度和如何计算总和。因此，平均值可以简单地使用这些现有函数：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Do Now!
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 立即行动！
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should be the average of the empty list? Does the above code produce what
    you would expect?
  id: totrans-236
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 空列表的平均值应该是多少？上面的代码产生了你期望的结果吗？
- en: 'Just as we argued earlier about the maximum [[Structural Problems with Sub-Domains](#%28part._struct-prob-sub-dom%29)],
    the average of the empty list isn’t a well-defined concept. Therefore, it would
    be appropriate to signal an error. The implementation above does this, but poorly:
    it reports an error on division. A better programming practice would be to catch
    this situation and report the error right away, rather than hoping some other
    function will report the error.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论过关于最大值[[具有子域的结构性问题](#%28part._struct-prob-sub-dom%29)]一样，空列表的平均值不是一个明确定义的概念。因此，适当的做法是发出错误信号。上面的实现做到了这一点，但效果不佳：它在除法上报告错误。更好的编程实践是捕获这种情况并立即报告错误，而不是希望其他函数会报告错误。
- en: Exercise
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alter my-avg above to signal an error when given the empty list.
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改上面的`my-avg`，当给出空列表时发出错误信号。
- en: 'Therefore, we see that the process we’ve used—<wbr>of inferring code from examples—<wbr>won’t
    may not always suffice, and we’ll need more sophisticated techniques to solve
    some problems. However, notice that working from examples helps us quickly identify
    situations where this approach does and doesn’t work. Furthermore, if you look
    more closely you’ll notice that the examples above do hint at how to solve the
    problem: in our very first examples, we wrote answers like 10/4, 9/3, and 7/2,
    which correspond to the sum of the numbers divided by the length. Thus, writing
    the answers in this form (as opposed, for instance, to writing the second of those
    as 3) already reveals a structure for a solution.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到我们使用的推断代码的过程——从示例中推断代码——并不总是足够，我们需要更复杂的技术来解决一些问题。然而，请注意，从示例中工作有助于我们快速识别这种方法何时有效，何时无效。此外，如果你仔细观察，你会注意到上面的示例暗示了如何解决问题：在我们的第一个示例中，我们写下了像10/4、9/3和7/2这样的答案，这对应于数字之和除以长度。因此，以这种形式写答案（而不是例如将第二个写为3）已经揭示了解决方案的结构。
- en: 6.7Structural Problems with Accumulators
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7累加器的结构问题
- en: Now we are ready to tackle the problems we’ve left unfinished. They will require
    a new technique to solve.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备解决我们留下的问题。它们将需要一种新的技术来解决。
- en: '6.7.1my-running-sum: Examples and Code'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.1`my-running-sum`：示例和代码
- en: 'Recall how we began in [my-running-sum: First Attempt](#%28part._running-sum-1st-attempt%29).
    Our examples [[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)] showed the
    following problem. When we process the rest of the list, we have forgotten everything
    about what preceded it. That is, when processing the list starting at 2 we forget
    that we’ve seen a 1 earlier; when starting from 3, we forget that we’ve seen both
    1 and 2 earlier; and so on. In other words, we keep forgetting the past. We need
    some way of avoiding that.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '回想一下我们是如何开始的[my-running-sum: First Attempt](#%28part._running-sum-1st-attempt%29)。我们的示例[[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)]展示了以下问题。当我们处理列表的其余部分时，我们忘记了之前的一切。也就是说，当从2开始处理列表时，我们忘记了之前看到的1；当从3开始时，我们忘记了之前看到的1和2；依此类推。换句话说，我们一直在忘记过去。我们需要一种避免这种情况的方法。'
- en: The easiest thing we can do is simply change our function to carry along this
    “memory”, or what we’ll call an accumulator. That is, imagine we were defining
    a new function, called my-rs. It will consume a list of numbers and produce a
    list of numbers, but in addition it will also take the sum of numbers preceding
    the current list.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的最简单的事情就是简单地改变我们的函数来携带这个“记忆”，或者我们将其称为累加器。也就是说，想象我们正在定义一个名为`my-rs`的新函数。它将消耗一个数字列表并产生一个数字列表，但另外它还将取当前列表之前数字的总和。
- en: Do Now!
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始吧！
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should the initial sum be?
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初始总和应该是多少？
- en: 'Initially there is no “preceding list”, so we will use the additive identity:
    0. The type of my-rs is'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最初没有“先前的列表”，所以我们将使用加法恒等式：0。`my-rs`的类型是
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s now re-work our examples from [<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)
    as examples of my-rs instead:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新将我们的示例从[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)重新作为`my-rs`的示例：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'That is, my-rs translates into the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`my-rs`转换为以下代码：
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'All that’s then left is to call it from my-running-sum:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ��后剩下的就是从`my-running-sum`中调用它：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Observe that we do not change my-running-sum itself to take extra arguments.
    There are multiple reasons for this. [FILL]
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们并没有改变`my-running-sum`本身来接受额外的参数。这样做有多个原因。[FILL]
- en: '6.7.2my-alternating: Examples and Code'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.2`my-alternating`：示例和代码
- en: 'Recall our effort in [my-alternating: First Attempt](#%28part._alternating-1st-attempt%29),
    which we tackled in [my-alternating: Examples and Code](#%28part._alternating-adjusting%29).
    There, we solved the problem by thinking of the list a little differently: we
    try, as much as possible, to skip two elements of the list at a time, so the first
    element we see is one we always want to keep as part of the answer. Here we will
    see another way to think about the same problem.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '回想一下我们在[my-alternating: First Attempt](#%28part._alternating-1st-attempt%29)中的努力，我们在[my-alternating:
    Examples and Code](#%28part._alternating-adjusting%29)中解决了这个问题。在那里，我们通过以稍微不同的方式考虑列表来解决问题：我们尽可能地跳过两个元素，这样我们看到的第一个元素总是我们想要保留作为答案的元素。在这里，我们将看到另一种思考相同问题的方式。'
- en: 'Return to the examples we’ve already seen [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)].
    As we’ve already noted [[my-alternating: Examples and Code](#%28part._alternating-adjusting%29)],
    in effect we want the output from every alternate example. One option was to traverse
    the list essentially two elements at a time. Another is to traverse it just one
    element at a time, but keeping track of whether we’re at an odd or even element—<wbr>i.e.,
    add “memory” to our program. Since we just need to track that one piece of information,
    we can use a Boolean to do it. Let’s define a new function for this purpose:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 返回我们已经看过的示例[[<alternating-egs-1>](#%28elem._alternating-egs-1%29)]。正如我们已经指出的[[我的交替：示例和代码](#%28part._alternating-adjusting%29)]，实际上我们想要从每个交替示例中得到输出。一种选择是基本上每次遍历列表两个元素。另一种选择是每次只遍历一个元素，但要跟踪我们是否处于奇数还是偶数元素位置-即，向我们的程序添加“内存”。由于我们只需要跟踪一个信息片段，我们可以使用布尔值来做到这一点。让我们为此定义一个新函数：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The extra argument accumulates whether we’re at an element to keep or one to
    discard.We can reuse the existing template for list functions. When we have an
    element, we have to consult the accumulator whether to keep it or not. If its
    value is true we link it to the answer; otherwise we ignore it. As we process
    the rest of the list, however, we have to remember to update the accumulator:
    if we kept an element we don’t wish to keep the next one, and vice versa.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的参数累积我们是否处于要保留的元素还是要丢弃的元素。我们可以重用现有的列表函数模板。当我们有一个元素时，我们必须咨询累加器是否保留它。如果它的值为真，则将其链接到答案；否则，我们将忽略它。但是，当我们处理列表的其余部分时，我们必须记住更新累加器：如果我们保留了一个元素，我们不希望保留下一个元素，反之亦然。
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we have to determine the initial value of the accumulator. In this
    case, since we want to keep alternating elements starting with the first one,
    its initial value should be true:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须确定累加器的初始值。在这种情况下，由于我们想要交替保留从第一个元素开始的元素，所以它的初始值应该是true：
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 6.8Dealing with Multiple Answers
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8处理多个答案
- en: Our discussion above has assumed there is only one answer for a given input.
    This is often true, but it also depends on how the problem is worded and how we
    choose to generate examples. We will study this in some detail now.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的讨论假设给定输入只有一个答案。这通常是正确的，但它还取决于问题的措辞方式和我们选择生成示例的方式。我们现在将详细研究这个问题。
- en: '6.8.1uqiq: Problem Setup'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.1uqiq：问题设定
- en: Consider the task of writing uniq:uniq is the name of a Unix utility with similar
    behavior; hence the spelling of the name. given a list of values, it produces
    a collection of the same elements while avoiding any duplicates (hence uniq, short
    for “unique”).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑写作uniq的任务：uniq是类似行为的Unix实用程序的名称；因此名字的拼写也类似。给定一个值列表，它产生相同元素的集合，同时避免任何重复项（因此uniq，缩写为“unique”）。
- en: 'Consider the following input: [list: 1, 2, 1, 3, 1, 2, 4, 1].'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑以下输入：[list: 1, 2, 1, 3, 1, 2, 4, 1]。'
- en: Do Now!
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the sequence of examples this input generates? It’s really important
    you stop and try to do this by hand. As we will see there are multiple solutions,
    and it’s useful for you to consider what you generate. Even if you can’t generate
    a sequence, trying to do so will better prepare you for what you read next.
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个输入生成的示例序列是什么？停下来尝试手工完成这个是非常重要的。正如我们将看到的那样，有多种解决方案，你考虑生成的内容非常有用。即使你不能生成一个序列，尝试这样做也会更好地为你阅读下面的内容做准备。
- en: How did you obtain your example? If you just “thought about it for a moment
    and wrote something down”, you may or may not have gotten something you can turn
    into a program. Programs can only proceed systematically; they can’t “think”.
    So, hopefully you took a well-defined path to computing the answer.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你是如何获得你的例子的？如果你只是“花了一会儿时间思考然后写下了一些东西”，你可能得到了或者可能没有得到可以转换为程序的东西。程序只能系统地进行；它们不能“思考”。所以，希望你以计算答案的明确定义路径进行。
- en: '6.8.2uniq: Examples'
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.2uniq：示例
- en: It turns out there are several possible answers, because we have (intentionally)
    left the problem unspecified. Suppose there are two instances of a value in the
    list; which one do we keep, the first or the second? On the one hand, since the
    two instances must be equivalent it doesn’t matter, but it does for writing concrete
    examples and deriving a solution.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结果有几个可能的答案，因为我们故意（有意地）没有明确说明问题。假设列表中有两个值的实例；我们保留哪一个，第一个还是第二个？一方面，由于这两个实例必须是等价的，所以无所谓，但对于编写具体示例和推导解决方案却很重要。
- en: 'For instance, you might have generated this sequence:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能生成了这个序列：
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: However, you might have also generated sequences that began with
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可能也生成了以…开头的序列
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: or
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: and so on. Let’s work with the example we’ve worked out above.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。让我们使用我们上面解决过的例子来工作。
- en: '6.8.3uniq: Code'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.3uniq：代码
- en: 'What is the systematic approach that gets us to this answer? When given a non-empty
    list, we split it into its first element and the rest of the list. Suppose we
    have the answer to uniq applied to the rest of the list. Now we can ask: is the
    first element in the rest of the list? If it is, then we can ignore it, since
    it is certain to be in the uniq of the rest of the list. If, however, it is not
    in the rest of the list, it’s critical that we link it to the answer.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的系统化方法是什么？当给定一个非空列表时，我们将其分成第一个元素和列表的其余部分。假设我们已经对剩余列表应用了 uniq 的答案。现在我们可以问：第一个元素是否在剩余列表中？如果是，则我们可以忽略它，因为它肯定是在剩余列表的
    uniq 中。然而，如果它不在剩余列表中，将它与答案联系起来是至关重要的。
- en: This translates into the following program. For the empty list, we return the
    empty list. If the list is non-empty, we check whether the first is in the rest
    of the list. If it is not, we include it; otherwise we can ignore it for now.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这转化为以下程序。对于空列表，我们返回空列表。如果列表不为空，我们检查第一个元素是否在剩余列表中。如果不是，我们将其包含进去；否则我们可以暂时忽略它。
- en: 'This results in the following program:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下程序：
- en: '[PRE66]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: which we’ve called uniq-rec instead of uniq to differentiate it from other versions
    of uniq.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为 uniq-rec 而不是 uniq，以区别于其他版本的 uniq。
- en: Exercise
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that we’re using .member to check whether an element is a member of the
    list. Write a function member that consumes an element and a list, and tells us
    whether the element is a member of the list.
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，我们使用 .member 来检查一个元素是否是列表的成员。编写一个函数 member，它接受一个元素和一个列表，并告诉我们该元素是否是列表的成员。
- en: '6.8.4uniq: Reducing Computation'
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.4uniq：减少计算
- en: 'Notice that this function has a repeated expression. Instead of writing it
    twice, we could call it just once and use the result in both places:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此函数具有重复的表达式。我们可以不必两次写入它，而只需调用一次并在两个地方使用结果：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: While it may seem that we have merely avoided repeating an expression, by moving
    the computation uniq-rec(r) to before the conditional, we have actually changed
    the program’s behavior in a subtle way. We will discuss this later when we get
    to [REC tail calls].
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来我们仅仅是避免了重复表达式，通过将计算 uniq-rec(r) 移到条件之前，我们实际上以微妙的方式改变了程序的行为。我们将在[REC tail
    calls]时稍后讨论这一点。
- en: You might think, because we replaced two function calls with one, that we’ve
    reduced the amount of computation the program does. It does not! The two function
    calls are both in the two branches of the same conditional; therefore, for any
    given list element, only one or the other call to uniq happens. In fact, in both
    cases, there was one call to uniq before, and there is one now. So we have reduced
    the number of calls in the source program, but not the number that take place
    when the program runs. In that sense, the name of this section was intentionally
    misleading!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，因为我们用一个函数调用替换了两个函数调用，所以我们减少了程序的计算量。并不是这样！两个函数调用都在同一个条件分支的两个分支中；因此，对于任何给定的列表元素，只会发生一次或另一次对
    uniq 的调用。事实上，在这两种情况下，以前都有一次对 uniq 的调用，现在也是一样。因此，我们减少了源程序中的调用次数，但并没有减少程序运行时发生的调用次数。在这个意义上，本节的名称是故意误导的！
- en: 'However, there is one useful reduction we can perform, which is enabled by
    the structure of uniq-rec2. We currently check whether f is a member of r, which
    is the list of all the remaining elements. In our example, this means that in
    the very second turn, we check whether 2 is a member of the list [list: 1, 3,
    1, 2, 4, 1]. This is a list of six elements, including three copies of 1. We compare
    2 against two copies of 1. However, we gain nothing from the second comparison.
    Put differently, we can think of uniq(r) as a “summary” of the rest of the list
    that is exactly as good as r itself for checking membership, with the advantage
    that it might be significantly shorter. This, of course, is exactly what ur represents.
    Therefore, we cna encode this intuition as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '但是，我们可以执行一个有用的简化，这是由 uniq-rec2 的结构所启用的。我们目前检查 f 是否是 r 的成员，r 是所有剩余元素的列表。在我们的例子中，这意味着在第二轮中，我们检查
    2 是否是列表 [list: 1, 3, 1, 2, 4, 1] 的成员。这是一个包含六个元素的列表，包括三个副本的 1。我们将 2 与两个 1 进行比较。然而，我们从第二次比较中没有收获任何东西。换句话说，我们可以将
    uniq(r) 视为剩余列表的“摘要”，它对于检查成员的效果与 r 本身一样好，但它可能要短得多。当然，这正是 ur 所代表的。因此，我们可以将这种直觉编码如下：'
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that all that changed is that we check for membership in ur rather than
    in r.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有的改变都只是我们检查 ur 而不是 r 是否为成员。
- en: Exercise
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later [[Predicting Growth](predicting-growth.html)] we will study how to formally
    study how long a program takes to run. By the measure introduced in that section,
    does the change we just made make any difference? Be careful with your answer:
    it depends on how we count “the length” of the list.'
  id: totrans-304
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 稍后[[预测增长](predicting-growth.html)]，我们将学习如何正式研究程序运行所需时间的长短。根据那一部分介绍的度量标准，我们刚刚做的更改有没有任何区别？注意你的答案：这取决于我们如何计算列表的“长度”。
- en: Observe that if the list never contained duplicates in the first place, then
    it wouldn’t matter which list we check membership in—<wbr>but if we knew the list
    didn’t contain duplicates, we wouldn’t be using uniq in the first place! We will
    return to the issue of lists and duplicate elements in (part "sets").
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果列表从未包含重复项，那么我们检查成员身份的列表就不重要了，但是如果我们知道列表不包含重复项，我们就不会首先使用uniq！我们将在（part "sets"）中回到列表和重复元素的问题。
- en: '6.8.5uniq: Example and Code Variations'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.5uniq：示例和代码变体
- en: 'As we mentioned earlier, there are other example sequences you might have written
    down. Here’s a very different process:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，你可能已经写下了其他示例序列。这是一个非常不同的过程：
- en: Start with the entire given list and with the empty answer (so far).
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从给定的整个列表和空白答案（到目前为止）开始。
- en: For each list element, check whether it’s already in the answer so far. If it
    is, ignore it, otherwise extend the answer with it.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个列表元素，检查它是否已经在到目前为止的答案中。如果是，则忽略它，否则将答案扩展为包含它。
- en: When there are no more elements in the list, the answer so far is the answer
    for the whole list.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当列表中没有更多元素时，到目前为止的答案就是整个列表的答案。
- en: Notice that this solution assumes that we will be accumulating the answer as
    we traverse the list. Therefore, we can’t even write the example with one parameter
    as we did before. We would argue that a natural solution asks whether we can solve
    the problem just from the structure of the data using the computation we are already
    defining, as we did above. If we cannot, then we have to resort to an accumulator.
    But because we can, the accumulator is unnecessary here and greatly complicated
    even writing down examples (give it a try!).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个解决方案假设我们在遍历列表时将答案累积起来。因此，我们甚至不能像之前那样只用一个参数写出这个例子。我们会认为一个自然的解决方案是询问我们是否可以仅通过已经定义的计算来解决问题，就像我们之前做过的那样，而不是通过累加器。但是因为我们可以，所以在这里累加器是不必要的，并且甚至大大地复杂化了写下例子（试试看！）。
- en: '6.8.6uniq: Why Produce a List?'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.6uniq：为什么要生成一个列表？
- en: 'If you go back to the original statement of the uniq problem [[uqiq: Problem
    Setup](#%28part._uniq%29)], you’ll notice it said nothing about what order the
    output should have; in fact, it didn’t even say the output needs to be a list
    (and hence have an order). In that case, we should think about whether a list
    even makes sense for this problem. In fact, if we don’t care about order and don’t
    want duplicates (by definition of uniq), then there is a much simpler solution,
    which is to produce a set. Pyret already has sets built in, and converting the
    list to a set automatically takes care of duplicates. This is of course cheating
    from the perspective of learning how to write uniq, but it is worth remembering
    that sometimes the right data structure to produce isn’t necessarily the same
    as the one we were given. Also, later [(part "sets")], we will see how to build
    sets for ourselves (at which point, uniq will look familiar, since it is at the
    heart of set-ness).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下uniq问题的原始陈述[[uqiq：问题设置](#%28part._uniq%29)]，你会注意到它对输出的顺序没有任何要求；实际上，它甚至没有说输出需要是一个列表（因此没有顺序）。在这种情况下，我们应该考虑一下列表是否对这个问题有意义。实际上，如果我们不关心顺序，也不想要重复（根据uniq的定义），那么有一个更简单的解决方案，就是生成一个集合。Pyret已经内置了集合，并且将列表转换为集合可以自动处理重复项。当然，从学习如何编写uniq的角度来看，这是作弊的，但值得记住的是，有时候产生的正确数据结构并不一定与我们给出的数据结构相同。此外，稍后[(part
    "sets")]，我们将看到如何自己构建集合（在这一点上，uniq看起来会很熟悉，因为它是集合性质的核心）。
- en: 6.9Monomorphic Lists and Polymorphic Types
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9单态列表和多态类型
- en: 'Earlier we wrote contracts like:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们写下了像这样的合同：
- en: '[PRE69]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: These are unsatisfying for several reasons.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原因令人不满意。
