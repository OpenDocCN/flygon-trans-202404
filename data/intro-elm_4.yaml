- en: Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: One of Elm's major benefits is that **users do not see runtime errors in practice**.
    This is possible because the Elm compiler can analyze your source code very quickly
    to see how values flow through your program. If a value can ever be used in an
    invalid way, the compiler tells you about it with a friendly error message. This
    is called *type inference*. The compiler figures out what *type* of values flow
    in and out of all your functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Elm的一个主要优点是**用户在实践中看不到运行时错误**。这是可能的，因为Elm编译器可以快速分析您的源代码，看看值如何在程序中流动。如果一个值可能以无效方式使用，编译器会用友好的错误消息告诉您。这被称为*类型推断*。编译器会弄清楚所有函数中的值是什么*类型*。
- en: An Example of Type Inference
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断的一个例子
- en: 'The following code defines a `toFullName` function which extracts a persons
    full name as a string:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了一个`toFullName`函数，该函数提取一个人的全名作为字符串：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Like in JavaScript or Python, we just write the code with no extra clutter.
    Do you see the bug though?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在JavaScript或Python中一样，我们只需编写代码，没有额外的混乱。不过你看到了bug吗？
- en: 'In JavaScript, the equivalent code spits out `"undefined Hesse"`. Not even
    an error! Hopefully one of your users will tell you about it when they see it
    in the wild. In contrast, the Elm compiler just looks at the source code and tells
    you:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，等效的代码输出`"undefined Hesse"`。甚至没有错误！希望你的用户中的某个人在实际使用中看到时会告诉你。相比之下，Elm编译器只查看源代码并告诉你：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It sees that `toFullName` is getting the wrong *type* of argument. Like the
    hint in the error message says, someone accidentally wrote `fist` instead of `first`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它发现`toFullName`得到了错误的*类型*参数。就像错误消息中的提示所说，有人不小心写成了`fist`而不是`first`。
- en: It is great to have an assistant for simple mistakes like this, but it is even
    more valuable when you have hundreds of files and a bunch of collaborators making
    changes. No matter how big and complex things get, the Elm compiler checks that
    *everything* fits together properly just based on the source code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种简单错误有一个助手是很棒的，但是当你有数百个文件和一堆合作者进行更改时，它甚至更有价值。无论事情变得多么庞大和复杂，Elm编译器都会根据源代码检查*一切*是否正确地组合在一起。
- en: The better you understand types, the more the compiler feels like a friendly
    assistant. So let's start learning more!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你越了解类型，编译器就越像一个友好的助手。所以让我们开始学习更多吧！
- en: Reading Types
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读类型
- en: Reading Types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读类型
- en: 'In the [Core Language](core_language.html) section of this book, we ran a bunch
    of code in the REPL. Well, we are going to do it again, but now with an emphasis
    on the types that are getting spit out. So type `elm repl` in your terminal again.
    You should see this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[核心语言](core_language.html)部分，我们在REPL中运行了一堆代码。好吧，我们将再次这样做，但现在重点放在输出的类型上。所以在终端中键入`elm
    repl`。你应该看到这个：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Primitives and Lists
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本类型和列表
- en: 'Let''s enter some simple expressions and see what happens:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入一些简单的表达式，看看会发生什么：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In these three examples, the REPL tells us the resulting value along with what
    *type* of value it happens to be. The value `"hello"` is a `String`. The value
    `3` is an `Int`. Nothing too crazy here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个例子中，REPL告诉我们结果值以及它是什么*类型*的值。值`"hello"`是一个`String`。值`3`是一个`Int`。这里没有什么太疯狂的东西。
- en: 'Let''s see what happens with lists holding different types of values:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看持有不同类型值的列表会发生什么：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the first case, we have a `List` filled with `String` values. In the second,
    the `List` is filled with `Float` values. In the third case the list is empty,
    so we do not actually know what kind of values are in the list. So the type `List
    a` is saying "I know I have a list, but it could be filled with anything". The
    lower-case `a` is called a *type variable*, meaning that there are no constraints
    in our program that pin this down to some specific type. In other words, the type
    can vary based on how it is used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个案例中，我们有一个填充有`String`值的`List`。在第二个案例中，`List`填充有`Float`值。在第三个案例中，列表是空的，所以我们实际上不知道列表中有什么类型的值。因此，类型`List
    a`表示“我知道我有一个列表，但它可以填充任何内容”。小写的`a`被称为*类型变量*，意味着在我们的程序中没有约束将其固定为某种特定类型。换句话说，类型可以根据使用方式而变化。
- en: Functions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Let''s see the type of some functions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些函数的类型：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The function `String.length` has type `String -> Int`. This means it *must*
    take in a `String` argument, and it will definitely return an integer result.
    So let''s try giving it an argument:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`String.length`的类型为`String -> Int`。这意味着它*必须*接受一个`String`参数，并且肯定会返回一个整数结果。所以让我们尝试给它一个参数：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The important thing to understand here is how the type of the result `Int` is
    built up from the initial expression. We have a `String -> Int` function and give
    it a `String` argument. This results in an `Int`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要理解的重要一点是结果类型`Int`如何从初始表达式构建起来的。我们有一个`String -> Int`函数并给它一个`String`参数。这将导致一个`Int`。
- en: What happens when you do not give a `String` though?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不给出一个`String`会发生什么？
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `String -> Int` function *must* get a `String` argument!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`String -> Int`函数 *必须* 接收一个`String`参数！
- en: Anonymous Functions
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'Elm has a feature called *anonymous functions*. Basically, you can create a
    function without naming it, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Elm有一个称为*匿名函数*的特性。基本上，你可以创建一个不命名的函数，就像这样：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Between the backslash and the arrow, you list the arguments of the function,
    and on the right of the arrow, you say what to do with those arguments. In this
    example, it is saying: I take in some argument I will call `n` and then I am going
    to divide it by two.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在反斜杠和箭头之间，列出函数的参数，在箭头的右侧，说明对这些参数要做什么。在这个例子中，它的意思是：我接收一个名为`n`的参数，然后我将把它除以二。
- en: 'We can use anonymous functions directly. Here is us using our anonymous function
    with `128` as the argument:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用匿名函数。这是我们使用`128`作为参数的匿名函数的使用方式：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We start with a `Float -> Float` function and give it a `Float` argument. The
    result is another `Float`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个`Float -> Float`函数开始，并给它一个`Float`参数。结果是另一个`Float`。
- en: '**Notes:** The backslash that starts an anonymous function is supposed to look
    like a lambda `λ` if you squint. This is a possibly ill-conceived wink to the
    intellectual history that led to languages like Elm.'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注：**开始匿名函数的反斜杠如果你眯眼看的话应该看起来像一个λ。这是对导致Elm等语言出现的知识历史的可能不切实际的暗示。'
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also, when we wrote the expression `(\n -> n / 2) 128`, it is important that
    we put parentheses around the anonymous function. After the arrow, Elm is just
    going to keep reading code as long as it can. The parentheses put bounds on this,
    indicating where the function body ends.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，当我们写表达式`(\n -> n / 2) 128`时，重要的是我们在匿名函数周围放置括号。在箭头之后，Elm只会继续读取代码，只要它能。括号对此进行了界定，指示函数体的结束位置。
- en: Named Functions
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名函数
- en: In the same way that we can name a value, we can name an anonymous function.
    So rebellious!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以给一个值取一个名字一样，我们也可以给一个匿名函数取一个名字。太叛逆了！
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the end, it works just like when nothing was named. You have a `Float ->
    Float` function, you give it a `Float`, and you end up with another `Float`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它的工作方式就像没有命名的时候一样。你有一个`Float -> Float`函数，你给它一个`Float`，最终你得到另一个`Float`。
- en: 'Here is the crazy secret though: this is how all functions are defined! You
    are just giving a name to an anonymous function. So when you see things like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这里有个疯狂的秘密：这就是所有函数的定义方式！你只是给一个匿名函数取了一个名字。所以当你看到这样的东西时：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can think of it as a convenient shorthand for:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其视为一种方便的简写形式：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is true for all functions, no matter how many arguments they have. So
    now let''s take that a step farther and think about what it means for functions
    with *multiple* arguments:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数都适用，无论它们有多少个参数。所以现在让我们更进一步，思考一下对于具有*多个*参数的函数意味着什么：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That seems fine, but why are there *two* arrows in the type for `divide`?! To
    start out, it is fine to think that "all the arguments are separated by arrows,
    and whatever is last is the result of the function". So `divide` takes two arguments
    and returns a `Float`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来没问题，但是为什么`divide`的类型中有*两个*箭头？起初，认为“所有参数都被箭头分隔，最后的是函数的结果”是可以的。所以`divide`接受两个参数并返回一个`Float`。
- en: To really understand why there are two arrows in the type of `divide`, it helps
    to convert the definition to use anonymous functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解`divide`类型中为什么有两个箭头，有助于将定义转换为使用匿名函数。
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All of these are totally equivalent. We just moved the arguments over, turning
    them into anonymous functions one at a time. So when we run an expression like
    `divide 3 2` we are actually doing a bunch of evaluation steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是完全等价的。我们只是将参数移到了一边，一次将它们转换为匿名函数。所以当我们运行像`divide 3 2`这样的表达式时，实际上进行了一系列的求值步骤：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After you expand `divide`, you actually provide the arguments one at a time.
    Replacing `x` and `y` are actually two different steps.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`divide`之后，你实际上是逐个提供参数。替换`x`和`y`实际上是两个不同的步骤。
- en: 'Let''s break that down a bit more to see how the types work. In evaluation
    step #3 we saw the following function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地分解一下看看类型是如何工作的。在求值步骤#3中，我们看到了以下函数：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is a `Float -> Float` function, just like `half`. Now in step #2 we saw
    a fancier function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `Float -> Float` 函数，就像 `half` 一样。现在在步骤＃2中，我们看到了一个更复杂的函数：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Well, we are starting with `\x -> ...` so we know the type is going to be something
    like `Float -> ...`. We also know that `(\y -> x / y)` has type `Float -> Float`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们从 `\x -> ...` 开始，所以我们知道类型将会是像 `Float -> ...` 这样的东西。我们还知道 `(\y -> x / y)`
    具有类型 `Float -> Float`。
- en: So if you actually wrote down all the parentheses in the type, it would instead
    say **`Float -> (Float -> Float)`**. You provide arguments one at a time. So when
    you replace `x`, the result is actually *another function*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果您实际上写下了类型中的所有括号，它将会说 **`Float -> (Float -> Float)`**。您一次提供一个参数。所以当您替换 `x`
    时，结果实际上是*另一个函数*。
- en: 'It is the same with all functions in Elm:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的所有函数都是一样的：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is really `Int -> (String -> String)` because you are providing the arguments
    one at a time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是 `Int -> (String -> String)`，因为您一次提供一个参数。
- en: 'Because all functions in Elm work this way, you do not need to give all the
    arguments at once. It is possible to say things like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Elm 中的所有函数都是这样工作的，所以你不需要一次性提供所有的参数。可以这样说：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is called *partial application*. It lets us use [the `|>` operator](http://package.elm-lang.org/packages/elm-lang/core/latest/Basics#|>)
    to chain functions together in a nice way, and it is why function types have so
    many arrows!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为*部分应用*。它让我们以一种很好的方式使用 [the `|>` operator](http://package.elm-lang.org/packages/elm-lang/core/latest/Basics#|>)
    来链接函数，这也是为什么函数类型有这么多箭头的原因！
- en: Type Annotations
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型注解
- en: 'So far we have just let Elm figure out the types, but it also lets you write
    a *type annotation* on the line above a definition if you want. So when you are
    writing code, you can say things like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是让 Elm 自己找出类型，但它也允许您在定义的上面一行写一个*类型注解*。所以当您编写代码时，您可以这样说：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: People can make mistakes in type annotations, so what happens if they say the
    wrong thing? Well, the compiler does not make mistakes, so it still figures out
    the type on its own. It then checks that your annotation matches the real answer.
    In other words, the compiler will always verify that all the annotations you add
    are correct.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在类型注解中可能会犯错误，那么如果他们说错了会发生什么？嗯，编译器不会犯错，所以它仍然自己找出类型。然后它检查您的注解是否与真实答案匹配。换句话说，编译器将始终验证您添加的所有注解是否正确。
- en: '**Note:** Some folks feel that it is odd that the type annotation goes on the
    line above the actual definition. The reasoning is that it should be easy and
    noninvasive to add a type annotation *later*. This way you can turn a sloppy prototype
    into higher-quality code just by adding lines.'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**有些人觉得类型注解放在实际定义的上面有点奇怪。理由是应该很容易和不具侵入性地稍后添加类型注解。这样你就可以通过添加行将一个懒散的原型转变为更高质量的代码。'
- en: Type Aliases
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: Type Aliases
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: The whole point of type aliases is to make your type annotations easier to read.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名的整个目的是使您的类型注解更易于阅读。
- en: 'As your programs get more complicated, you find yourself working with larger
    and more complex data. For example, maybe you are making twitter-for-dogs and
    you need to represent a user. And maybe you want a function that checks to see
    if a user has a bio or not. You might write a function like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的程序变得越来越复杂，您会发现自己处理着更大更复杂的数据。例如，也许您正在制作 Twitter-for-dogs，您需要代表一个用户。也许您想要一个检查用户是否有生物的函数。您可能会写一个像这样的函数：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That type annotation is kind of a mess, and users do not even have that many
    details! Imagine if there were ten fields. Or if you had a function that took
    users as an argument and gave users as the result.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那个类型注解有点混乱，而且用户甚至没有那么多细节！想象一下如果有十个字段会怎样。或者如果你有一个以用户作为参数并给出用户作为结果的函数。
- en: 'In cases like this, you should create a *type alias* for your data:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您应该为您的数据创建一个*类型别名*：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is saying, wherever you see `User`, replace it by all this other stuff.
    So now we can rewrite our `hasBio` function in a much nicer way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，无论你在哪里看到 `User`，都用所有这些其他内容替换它。所以现在我们可以用一种更好的方式重写我们的 `hasBio` 函数：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Looks way better! It is important to emphasize that *these two definitions are
    exactly the same*. We just made an alias so we can say the same thing in fewer
    key strokes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好多了！重要的是要强调*这两个定义是完全相同的*。我们只是创建了一个别名，这样我们可以用更少的按键来说同样的话。
- en: 'So if we write a function to add a bio, it would be like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们写一个添加生物的函数，它会是这样的：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Imagine what that type annotation would look like if we did not have the `User`
    type alias. Bad!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下如果我们没有 `User` 类型别名那个类型注解会是什么样子。糟糕！
- en: Type aliases are not just about cosmetics though. They can help you think more
    clearly. When writing Elm programs, it is often best to *start* with the type
    alias before writing a bunch of functions. I find it helps direct my progress
    in a way that ends up being more efficient overall. Suddenly you know exactly
    what kind of data you are working with. If you need to add stuff to it, the compiler
    will tell you about any existing code that is affected by it. I think most experienced
    Elm folks use a similar process when working with records especially.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名不仅仅是为了美观。它们可以帮助你更清晰地思考。编写 Elm 程序时，通常最好是在编写一堆函数之前*先*写出类型别名。我发现这有助于以更高效的方式引导我的进展。突然间你完全知道你正在处理的是什么类型的数据。如果你需要向其添加内容，编译器会告诉你受到影响的任何现有代码。我认为大多数有经验的
    Elm 开发者在处理记录时特别使用类似的过程。
- en: '**Note:** When you create a type alias specifically for a record, it also generates
    a *record constructor*. So our `User` type alias will also generate this function:'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**当你为记录专门创建类型别名时，它还会生成一个*记录构造函数*。所以我们的`User`类型别名也会生成这个函数：'
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The arguments are in the order they appear in the type alias declaration, so
    in the REPL you could do this:'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数的顺序与类型别名声明中出现的顺序相同，所以在 REPL 中你可以这样做：
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This can be pretty handy!
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这可能会非常方便！
- en: Union Types
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型
- en: Union Types
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型
- en: Many languages have trouble expressing data with weird shapes. They give you
    a small set of built-in types, and you have to represent everything with them.
    So you often find yourself using `null` or booleans or strings to encode details
    in a way that is quite error prone.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言在表达具有奇怪形状的数据时会遇到麻烦。它们只给你提供了一小组内置类型，你必须用它们来表示一切。因此，你经常会发现自己使用`null`或布尔值或字符串来编码细节，这种方式相当容易出错。
- en: Elm's *union types* let you represent complex data much more naturally. We will
    go through a couple concrete examples to build some intuition about how and when
    to use union types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 的*联合类型*让你更自然地表示复杂的数据。我们将通过几个具体的例子来建立一些关于何时以及如何使用联合类型的直觉。
- en: '**Note:** Union types are sometimes called [tagged unions](https://en.wikipedia.org/wiki/Tagged_union).
    Some communities call them [ADTs](https://en.wikipedia.org/wiki/Algebraic_data_type).'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**联合类型有时被称为[标签联合](https://en.wikipedia.org/wiki/Tagged_union)。一些社区将其称为[ADTs](https://en.wikipedia.org/wiki/Algebraic_data_type)。'
- en: Filtering a Todo List
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤待办事项列表
- en: '**Problem:** We are creating a [todo list](http://evancz.github.io/elm-todomvc/)
    full of tasks. We want to have three views: show *all* tasks, show only *active*
    tasks, and show only *completed* tasks. How do we represent which of these three
    states we are in?'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**问题：**我们正在创建一个[待办事项列表](http://evancz.github.io/elm-todomvc/)，其中充满了任务。我们想要有三个视图：显示*所有*任务，仅显示*活动*任务，仅显示*已完成*任务。我们如何表示我们处于这三种状态中的哪一种？'
- en: 'Whenever you have weird shaped data in Elm, you want to reach for a union type.
    In this case, we would create a type `Visibility` that has three possible values:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在 Elm 中遇到奇怪形状的数据时，你会想要使用联合类型。在这种情况下，我们会创建一个名为`Visibility`的类型，它有三种可能的值：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have these three cases defined, we want to create a function `keep`
    that will properly filter our tasks. It should work like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了这三种情况，我们想要创建一个名为`keep`的函数，它将正确地过滤我们的任务。它应该像这样工作：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So the `keep` function needs to look at its first argument, and depending on
    what it is, filter the list in various ways. We use a `case` expression to do
    this. It is like an `if` on steroids:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`keep`函数需要查看它的第一个参数，并根据它的内容以不同的方式过滤列表。我们使用`case`表达式来做到这一点。这就像是一个更强大的`if`：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `case` is saying, look at the structure of `visibility`. If it is `All`,
    just give back all the tasks. If it is `Active`, keep only the tasks that are
    not complete. If it is `Completed`, keep only the tasks that are complete.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`的意思是，看一看`visibility`的结构。如果它是`All`，就把所有的任务都交出来。如果是`Active`，只保留未完成的任务。如果是`Completed`，只保留已完成的任务。'
- en: 'The cool thing about `case` expressions is that all the branches are checked
    by the compiler. This has some nice benefits:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`表达式的酷炫之处在于编译器会检查所有的分支。这带来了一些很好的好处：'
- en: If you mistype `Compleet` by accident, you get a hint about the typo.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你无意中打错了`Compleet`，你会得到一个有关拼写错误的提示。
- en: If you forget to handle a case, the compiler will figure it out and tell you.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你忘记处理一个情况，编译器会找出并告诉你。
- en: So say you want to add `Recent` as a fourth possible `Visibility` value. The
    compiler will find all the `case` expressions in your code that work with `Visibility`
    values and remind you to handle the new possibility! This means you can change
    and extend `Visibility` without the risk of silently creating bugs in existing
    code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以说你想将`Recent`作为第四种可能的`Visibility`值添加进去。编译器将查找你的代码中所有使用`Visibility`值的`case`表达式，并提醒你处理新的可能性！这意味着你可以更改和扩展`Visibility`，而不会在现有代码中悄悄创建错误。
- en: '**Exercise:** Imagine how you would solve this same problem in JavaScript.
    Three strings? A boolean that can be `null`? What would the definition of `keep`
    look like? What sort of tests would you want to write to make sure adding new
    code later was safe.'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**练习：** 想象一下你如何在JavaScript中解决相同的问题。三个字符串？一个可以为`null`的布尔值？`keep`的定义会是什么样子？你想要编写什么样的测试来确保稍后添加新代码是安全的。'
- en: Anonymous Users
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名用户
- en: '**Problem:** We have a chat room where people can post whatever they want.
    Some users are logged in and some are anonymous. How should we represent a user?'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**问题：** 我们有一个聊天室，人们可以发布任何他们想要的东西。有些用户已登录，有些用户是匿名的。我们应该如何表示一个用户？'
- en: 'Again, whenever there is weird shaped data, you want to reach for a union type.
    For this case, we want one where users are either anonymous or named:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，每当有奇怪形状的数据时，你都想使用联合类型。对于这种情况，我们想要一个用户要么是匿名的要么是命名的：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So creating the type `User` also created constructors named `Anonymous` and
    `Named`. If you want to create a `User` you *must* use one of these two constructors.
    This guarantees that all the possible `User` values are things like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以创建`User`类型也创建了名为`Anonymous`和`Named`的构造函数。如果你想创建一个`User`，你*必须*使用这两个构造函数之一。这保证了所有可能的`User`值都是这样的：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have a representation of a user, lets say we want to get a photo
    of them to show next to their posts. Again, we need to use a `case` expression
    to work with our `User` type:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个用户的表示，假设我们想要获取他们的照片以便在他们的帖子旁边显示。再次，我们需要使用一个`case`表达式来处理我们的`User`类型：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are two possible cases when we have a `User`. If they are `Anonymous`
    we show a dummy picture. If they are `Named` we construct the URL of their photo.
    This `case` is slightly fancier than the one we saw before. Notice that the second
    branch has a lower case variable `name`. This means that when we see a value like
    `Named "AzureDiamond"`, the `name` variable will be bound to `"AzureDiamond"`
    so we can do other things with it. This is called *pattern matching*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个`User`时，有两种可能的情况。如果他们是`Anonymous`，我们显示一个虚拟图片。如果他们是`Named`，我们构造他们照片的URL。这个`case`比我们之前看到的那个稍微花哨一点。注意第二个分支有一个小写变量`name`。这意味着当我们看到像`Named
    "AzureDiamond"`这样的值时，`name`变量将绑定到`"AzureDiamond"`，所以我们可以对其进行其他操作。这就是所谓的*模式匹配*。
- en: Now imagine we have a bunch of users in a chat room and we want to show their
    pictures.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一群用户在一个聊天室里，我们想展示他们的图片。
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The nice thing about creating a type like `User` is that no one in your whole
    codebase can ever "forget" that some users may be anonymous. Anyone who can get
    a hold of a `User` needs to use a `case` to get any information out of it, and
    the compiler guarantees every `case` and handles all possible scenarios!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建像`User`这样的类型的好处是，你整个代码库中的任何人都不可能“忘记”一些用户可能是匿名的。任何能获取`User`的人都需要使用一个`case`来从中获取任何信息，编译器保证每个`case`都处理了所有可能的情况！
- en: '**Exercise:** Think about how you would solve this problem in some other language.
    A string where empty string means they are anonymous? A string that can be null?
    How much testing would you want to do to make sure that everyone handles these
    special cases correctly?'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**练习：** 想想你会如何用其他语言解决这个问题。一个字符串，空字符串表示他们是匿名的？一个可以为空的字符串？你会想要进行多少测试来确保每个人都正确处理这些特殊情况？'
- en: Widget Dashboard
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件仪表板
- en: '**Problem:** You are creating a dashboard with three different kinds of widgets.
    One shows recent log data, one shows time plots, and one shows scatter plots.
    How do you represent a widget?'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**问题：** 你正在创建一个带有三种不同类型小部件的仪表板。一个显示最近的日志数据，一个显示时间图，一个显示散点图。如何表示一个小部件？'
- en: 'Alright, we are getting a bit fancier now. In Elm, you want to start by solving
    each case individually. (As you get more experience, you will see that Elm *wants*
    you to build programs out of small, reusable parts. It is weird.) So I would create
    representations for each of our three scenarios, along with `view` functions to
    actually turn them into HTML or SVG or whatever:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们现在有点高级了。在Elm中，你要从独立解决每种情况开始。（随着经验的增长，你会发现Elm*希望*你从小而可重用的部分构建��序。这很奇怪。）所以我会为我们的三种情况创建表示，并编写`view`函数，将它们实际转换为HTML或SVG或其他内容：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point, you have created all the helper functions needed to work with
    these three cases totally independent from each other. Someone can come along
    later and say, "I need a nice way to show scatter plots" and use just that part
    of the code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了所有需要独立处理这三种情况的辅助函数。稍后可以有人过来说，“我需要一个漂亮的方法来显示散点图”，然后只使用代码的那一部分。
- en: 'So the question is really: how do I put these three standalone things together
    for my particular scenario?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以问题实际上是：如何将这三个独立的事物组合起来以适应我的特定情况？
- en: Again, union types are there to put together a bunch of different types!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，联合类型用于组合各种不同的类型！
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So we created a `Widget` type that can only be created with these constructor
    functions. You can think of these constructors as *tagging* the data so we can
    tell it apart at runtime. Now we can write something to render a widget like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们创建了一个只能使用这些构造函数创建的`Widget`类型。你可以将这些构造函数视为*标记*数据，以便我们可以在运行时区分它们。现在我们可以编写一些东西来渲染一个小部件，就像这样：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: One nice thing about this approach is that there is no mystery about what kind
    of widgets are supported. There are exactly three. If someone wants to add a fourth,
    they modify the `Widget` type. This means you can never be surprised by the data
    you get, even if someone on a different team is messing with your code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是，对于支持的小部件类型没有任何神秘之处。恰好有三种。如果有人想要添加第四种，他们会修改`Widget`类型。这意味着，即使其他团队的人在修改你的代码，你也永远不会对所获得的数据感到惊讶。
- en: '**Takeaways:**'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**要点：**'
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solve each subproblem first.
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先解决每个子问题。
- en: Use union types to put together all the solutions.
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用联合类型将所有解决方案组合在一起。
- en: Creating a union type generates a bunch of *constructors*.
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个联合类型会生成一堆*构造函数*。
- en: These constuctors *tag* data so that we can differentiate it at runtime.
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些构造函数*标记*数据，以便我们可以在运行时区分它们。
- en: A `case` expression lets us tear data apart based on these tags.
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`case`表达式让我们根据这些标记拆分数据。
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The same strategies can be used if you are making a game and have a bunch of
    different bad guys. Goombas should update one way, but Koopa Troopas do something
    totally different. Solve each problem independently, and then use a union type
    to put them all together.
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在制作游戏并有一堆不同的坏家伙，可以使用相同的策略。Goombas应该以一种方式更新，但Koopa Troopas则完全不同。独立解决每个问题，然后使用联合类型将它们全部组合在一起。
- en: Linked Lists
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表
- en: '**Problem:** You are stuck on a bus speeding down the highway. If the bus slows
    down, it will blow up. The only way to save yourself and everyone on the bus is
    to reimplement linked lists in Elm. HURRY, WE ARE RUNNING OUT OF GAS!'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**问题：** 你被困在一辆飞驰在高速公路上的公共汽车上。如果公共汽车减速，它将爆炸。拯救自己和公共汽车上的每个人的唯一方法是在Elm中重新实现链表。快点，我们的汽油快用完了！'
- en: Yeah, yeah, the problem is contrived this time, but it is important to see some
    of the more advanced things you can do with union types!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，是的，这次问题是刻意设计的，但重要的是要看到你可以使用联合类型做一些更高级的事情！
- en: 'A [linked list](https://en.wikipedia.org/wiki/Linked_list) is a sequence of
    values. If you are looking at a linked list, it is either empty or it is a value
    and more list. That list is either empty or is a value and more list. etc. This
    intuitive definition works pretty directly in Elm. Let''s see it for lists of
    integers:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[链表](https://en.wikipedia.org/wiki/Linked_list)是一系列值。如果你看着一个链表，它要么是空的，要么是一个值和更多的列表。那个列表要么是空的，要么是一个值和更多的列表。等等。这种直观的定义在Elm中直接有效。让我们看看整数列表的情况：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we did two new things here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在这里做了两件新事情：
- en: The `Node` constructor takes *two* arguments instead of one. This is fine. In
    fact, you can have them take as many arguments as you want.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Node`构造函数接受*两个*参数而不是一个。这没问题。事实上，你可以让它们接受任意数量的参数。'
- en: Our union type is *recursive*. An `IntList` may hold another `IntList`. Again,
    this is fine if you are using union types.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的联合类型是*递归*的。`IntList`可能包含另一个`IntList`。同样，如果使用联合类型，这是可以的。
- en: The nice thing about our `IntList` type is that now we can only build valid
    linked lists. Every linked list needs to start with `Empty` and the only way to
    add a new value is with `Node`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`IntList`类型的好处在于现在我们只能构建有效的链表。每个链表都需要以`Empty`开始，而添加新值的唯一方法是使用`Node`。
- en: 'It is equally nice to work with. Let''s say we want to compute the sum of all
    of the numbers in a list. Just like with any other union type, we need to use
    a `case` and handle all possible scenarios:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它同样易于使用。假设我们想计算列表中所有数字的总和。与任何其他联合类型一样，我们需要使用`case`并处理所有可能的情况：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we get an `Empty` value, the sum is 0\. If we have a `Node` we add the first
    element to the sum of all the remaining ones. So an expression like `(sum (Node
    1 (Node 2 (Node 3 Empty))))` is evaluated like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到一个`Empty`值，总和就是0。如果我们有一个`Node`，我们将第一个元素加到所有剩余元素的总和中。因此，表达式`(sum (Node
    1 (Node 2 (Node 3 Empty))))`的评估如下：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: On each line, we see one evaluation step. When we call `sum` it transforms the
    list based on whether it is looking at a `Node` or an `Empty` value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行上，我们看到一个评估步骤。当我们调用`sum`时，它会根据它是在查看`Node`还是`Empty`值来转换列表。
- en: '**Note:** This is the first recursive function we have written together! Notice
    that `sum` calls itself to get the sum. It can be tricky to get into the mindset
    of writing recursive functions, so I wanted to share one weird trick. **Pretend
    you are already done.**'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**这是我们一起编写的第一个递归函数！请注意，`sum`调用自身以获得总和。编写递归函数的思维模式可能会有些棘手，因此我想分享一个奇怪的技巧。**假装你已经完成了。**'
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I always start with a `case` and all of the branches listed but not filled in.
    From there, I solve each branch one at a time, pretending that nothing else exists.
    So with `sum` I'd look at `Empty ->` and say, an empty list has to sum to zero.
    Then I'd look at the `Node n remainingNumbers ->` branch and think, well, I know
    I have a number, a list, and a `sum` function that definitely already exists and
    totally works. I can just use that and add a number to it!
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我总是从一个`case`开始，列出所有分支但未填写。从那里，我逐个解决每个分支，假装没有其他东西存在。因此，对于`sum`，我会看`Empty ->`并说，空列表必须总和为零。然后我会看`Node
    n remainingNumbers ->`分支，并想，嗯，我知道我有一个数字，一个列表，还有一个肯定已经存在并且完全有效的`sum`函数。我可以只是使用它并将数字添加到其中！
- en: Generic Data Structures
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用数据结构
- en: '**Problem:** The last section showed linked lists that only worked for integers.
    That is pretty lame. How can we make linked lists that hold any kind of value?'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**问题：**上一节展示了仅适用于整数的链表。那太糟糕了。我们如何制作可以保存任何类型值的链表？'
- en: 'Everything is going to be pretty much the same, except we are going to introduce
    a *type variable* in our definition of lists:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都基本相同，只是在我们的列表定义中引入了*类型变量*：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The fancy part comes in the `Node` constructor. Instead of pinning the data
    to `Int` and `IntList`, we say that it can hold `a` and `List a`. Basically, you
    can add a value as long as it is the same type of value as everything else in
    the list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 精彩之处在于`Node`构造函数。我们不是将数据固定在`Int`和`IntList`上，而是说它可以保存`a`和`List a`。基本上，只要添加的值与列表中的所有其他值的类型相同，就可以添加一个值。
- en: Everything else is the same. You pattern match on lists with `case` and you
    write recursive functions. The only difference is that our lists can hold anything
    now!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切都一样。您可以使用`case`对列表进行模式匹配，并编写递归函数。唯一的区别是我们的列表现在可以保存任何东西！
- en: '**Exercise:** This is exactly how the `List` type in Elm works, so take a look
    at [the `List` library](http://package.elm-lang.org/packages/elm-lang/core/latest/List)
    and see if you can implement some of those functions yourself.'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**练习：**这正是Elm中的`List`类型的工作方式，因此请查看[列表库](http://package.elm-lang.org/packages/elm-lang/core/latest/List)
    ，看看您是否可以自己实现其中一些函数。'
- en: Additional Examples
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的例子
- en: We have seen a couple scenarios, but the best way to get more comfortable is
    to use union types more! So here are two examples that are kind of fun.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些情况，但更加熟悉的最佳方法是更多地使用联合类型！因此，这里有两个有趣的例子。
- en: Binary Trees
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二叉树
- en: '[Binary trees](https://en.wikipedia.org/wiki/Binary_tree) are almost exactly
    the same as linked lists:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)与链表几乎完全相同：'
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A tree is either empty or it is a node with a value and two children. Check
    out [this example](http://elm-lang.org/examples/binary-tree) for more info on
    this. If you can do all of the exercises at the end of that link, consider yourself
    a capable user of union types!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 树要么为空，要么是具有值和两个子节点的节点。查看[此示例](http://elm-lang.org/examples/binary-tree)了解更多信息。如果您能完成该链接末尾的所有练习，请自认为是联合类型的熟练用户！
- en: Languages
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言
- en: 'We can even model a programming language as data if we want to go really crazy!
    In this case, it is one that only deals with [Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra#Operations):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将编程语言建模为数据，如果我们想要变得疯狂的话！在这种情况下，它是仅涉及[布尔代数](https://en.wikipedia.org/wiki/Boolean_algebra#Operations)的一种语言：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once we have modeled the possible values we can define functions like `eval`
    which evaluates any `Boolean` to `True` or `False`. See [this example](http://elm-lang.org/examples/boolean-expressions)
    for more about representing boolean expressions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对可能的值进行了建模，我们就可以定义像`eval`这样的函数，它将任何`Boolean`评估为`True`或`False`。查看[此示例](http://elm-lang.org/examples/boolean-expressions)了解更多关于表示布尔表达式的内容。
