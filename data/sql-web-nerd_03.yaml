- en: '| [![IMTA Show 1995 Manhattan](../Images/206ba9ef3ed4d9f64a8f3851aacf93c1.jpg)](/http://philip.greenspun.com/images/pcd1341/legs-overview-20.tcl)
    |'
  id: totrans-0
  prefs: []
  type: TYPE_TB
  zh: '| [![1995年曼哈顿IMTA秀](../Images/206ba9ef3ed4d9f64a8f3851aacf93c1.jpg)](/http://philip.greenspun.com/images/pcd1341/legs-overview-20.tcl)
    |'
- en: Data Modeling
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据建模
- en: part of [SQL for Web Nerds](index.html) by [Philip Greenspun](http://philip.greenspun.com/)
    | [![IMTA Show 1995 Manhattan](../Images/493d3f69d2ebcc3623ce3eae7176e7d7.jpg)](/http://philip.greenspun.com/images/pcd1341/little-boy-61.tcl)
    |
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL for Web Nerds](index.html) 的一部分，由 [Philip Greenspun](http://philip.greenspun.com/)
    编写 | [![1995年曼哈顿IMTA秀](../Images/493d3f69d2ebcc3623ce3eae7176e7d7.jpg)](/http://philip.greenspun.com/images/pcd1341/little-boy-61.tcl)
    |'
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[![Christina Perreault, aged 14, suffering from chicken pox at the 1995 IMTA
    Show in Manhattan.  Being made up by Francesca Milano.](../Images/c4dd8c7acfd1b889f53fc7cd00b76621.jpg)](/http://philip.greenspun.com/images/pcd1341/chicken-pox-51.tcl)
    Data modeling is the hardest and most important activity in the RDBMS world. If
    you get the data model wrong, your application might not do what users need, it
    might be unreliable, it might fill up the database with garbage. Why then do we
    start a SQL tutorial with the most challenging part of the job? Because you can''t
    do queries, inserts, and updates until you''ve defined some tables. And defining
    tables is *data modeling*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1995年曼哈顿IMTA秀上患水痘的14岁Christina Perreault，由Francesca Milano化妆。](../Images/c4dd8c7acfd1b889f53fc7cd00b76621.jpg)](/http://philip.greenspun.com/images/pcd1341/chicken-pox-51.tcl)
    数据建模是关系数据库世界中最困难且最重要的活动。如果数据模型错误，您的应用程序可能无法满足用户需求，可能不可靠，可能会用垃圾填满数据库。那么为什么我们要从工作中最具挑战性的部分开始SQL教程呢？因为在定义一些表之前，您无法进行查询、插入和更新。而定义表就是*数据建模*。'
- en: 'When data modeling, you are telling the RDBMS the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据建模时，您告诉关系数据库管理系统以下内容：
- en: what elements of the data you will store
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将存储哪些数据元素
- en: how large each element can be
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个元素可以有多大
- en: what kind of information each element can contain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个元素可以包含什么样的信息
- en: what elements may be left blank
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些元素可能为空白
- en: which elements are constrained to a fixed range
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些元素受限于固定范围
- en: whether and how various tables are to be linked
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种表是否以及如何链接
- en: Three-Valued Logic
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三值逻辑
- en: Programmers in most computer languages are familiar with Boolean logic. A variable
    may be either true or false. Pervading SQL, however, is the alien idea of *three-valued
    logic*. A column can be true, false, or NULL. When building the data model you
    must affirmatively decide whether a NULL value will be permitted for a column
    and, if so, what it means.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机语言的程序员都熟悉布尔逻辑。一个变量可以是真或假。然而，在SQL中普遍存在的是*三值逻辑*的陌生概念。一列可以是真、假或NULL。在构建数据模型时，您必须积极决定是否允许列的NULL值，以及如果允许，它代表什么。
- en: 'For example, consider a table for recording user-submitted comments to a Web
    site. The publisher has made the following stipulations:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个用于记录用户提交评论到网站的表。出版商已经做出了以下规定：
- en: comments won't go live until approved by an editor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论在编辑批准之前不会发布
- en: the admin pages will present editors with all comments that are pending approval,
    i.e., have been submitted but neither approved nor disapproved by an editor already
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理页面将向编辑显示所有待批准的评论，即已提交但尚未被编辑批准或拒绝的评论
- en: 'Here''s the data model:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据模型：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Implicit in this model is the assumption that `approved_p` can be NULL and that,
    if not explicitly set during the INSERT, that is what it will default to. What
    about the check constraint? It would seem to restrict `approved_p` to values of
    "t" or "f". NULL, however, is a special value and if we wanted to prevent `approved_p`
    from taking on NULL we'd have to add an explicit `not null` constraint.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型中的隐含假设是`approved_p`可以为NULL，并且如果在INSERT期间没有显式设置，那就是默认值。那么检查约束呢？它似乎将`approved_p`限制为“t”或“f”的值。然而，NULL是一个特殊值，如果我们想要防止`approved_p`取NULL值，我们必须添加一个显式的`not
    null`约束。
- en: 'How do NULLs work with queries? Let''s fill `user_submitted_comments` with
    some sample data and see:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理查询中的 NULL 值？让我们在`user_submitted_comments`中填充一些示例数据并查看：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've successfully JOINed the `user_submitted_comments` and `users` table to
    get both the comment content and the name of the user who submitted it. Notice
    that in the select list we had to explicitly request `**user_submitted_comments**.approved_p`.
    This is because the `users` table also has an `approved_p` column.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功将`user_submitted_comments`和`users`表JOIN起来，以获取评论内容和提交评论的用户姓名。请注意，在选择列表中，我们必须明确请求`**user_submitted_comments**.approved_p`。这是因为`users`表也有一个`approved_p`列。
- en: When we inserted the comment row we did not specify a value for the `approved_p`
    column. Thus we expect that the value would be NULL and in fact that's what it
    seems to be. Oracle's SQL*Plus application indicates a NULL value with white space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们插入评论行时，没有为 `approved_p` 列指定值。因此我们期望该值为 NULL，事实上似乎也是这样。Oracle 的 SQL*Plus 应用程序用空白表示
    NULL 值。
- en: 'For the administration page, we''ll want to show *only* those comments where
    the `approved_p` column is NULL:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理页面，我们将只显示 `approved_p` 列为 NULL 的评论：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '"No rows selected"? That''s odd. We know for a fact that we have one row in
    the comments table and that is `approved_p` column is set to NULL. How to debug
    the query? The first thing to do is simplify by removing the JOIN:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '"未选择任何行"? 这很奇怪。我们确实知道在评论表中有一行，而且它的 `approved_p` 列被设置为 NULL。如何调试查询？首先要做的是简化，删除
    JOIN：'
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What is happening here is that any expression involving NULL evaluates to NULL,
    including one that effectively looks like "NULL = NULL". The WHERE clause is looking
    for expressions that evaluate to true. What you need to use is the special test
    IS NULL:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，涉及到 NULL 的任何表达式都会求值为 NULL，包括看起来像是 "NULL = NULL" 的表达式。WHERE 子句正在寻找求值为真的表达式。你需要使用的是特殊的测试
    IS NULL：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An adage among SQL programmers is that the only time you can use "= NULL" is
    in an UPDATE statement (to set a column's value to NULL). It never makes sense
    to use "= NULL" in a WHERE clause.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 程序员之间的格言是，你只能在 UPDATE 语句中使用 "= NULL"（将列的值设置为 NULL）。在 WHERE 子句中使用 "= NULL"
    是毫无意义的。
- en: The bottom line is that as a data modeler you will have to decide which columns
    can be NULL and what that value will mean.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，作为数据建模者，你将不得不决定哪些列可以是 NULL，以及该值的含义是什么。
- en: Back to the Mailing List
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到邮件列表
- en: 'Let''s return to the mailing list data model from the introduction:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到引言中的邮件列表数据模型：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This data model locks you into some realities:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据模型将你锁定在一些现实中：
- en: You will not be sending out any physical New Year's cards to folks on your mailing
    list; you don't have any way to store their addresses.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会向邮件列表中的人发送任何实体的新年贺卡；你没有任何方法存储他们的地址。
- en: You will not be sending out any electronic mail to folks who work at companies
    with elaborate Lotus Notes configurations; sometimes Lotus Notes results in email
    addresses that are longer than 100 characters.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将不会向那些工作在拥有复杂 Lotus Notes 配置的公司的人发送任何电子邮件；有时 Lotus Notes 会导致电子邮件地址超过 100 个字符。
- en: You are running the risk of filling the database with garbage since you have
    not constrained phone numbers in any way. American users could add or delete digits
    by mistake. International users could mistype country codes.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有可能使数据库充斥着垃圾，因为你没有以任何方式限制电话号码。美国用户可能会因错误而添加或删除数字。国际用户可能会输错国家代码。
- en: You are running the risk of not being able to serve rich people because the
    `number_type` column may be too constrained. Suppose William H. Gates the Third
    wishes to record some extra phone numbers with types of "boat", "ranch", "island",
    and "private_jet". The `check (number_type in ('work','home','cell','beeper'))`
    statement prevents Mr. Gates from doing this.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有可能无法为富人服务，因为 `number_type` 列可能受到太多限制。假设威廉·H·盖茨三世想记录一些额外的电话号码，类型为 "boat"、"ranch"、"island"
    和 "private_jet"。`check (number_type in ('work','home','cell','beeper'))` 语句阻止盖茨先生这样做。
- en: You run the risk of having records in the database for people whose name you
    don't know, since the `name` column of `mailing_list` is free to be NULL.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有可能在数据库中有些人的记录，而他们的名字你并不知道，因为 `mailing_list` 的 `name` 列可以是 NULL。
- en: Changing a user's email address won't be the simplest possible operation. You're
    using `email` as a key in two tables and therefore will have to update both tables.
    The `references mailing_list` keeps you from making the mistake of only updating
    `mailing_list` and leaving orphaned rows in `phone_numbers`. But if users changed
    their email addresses frequently, you might not want to do things this way.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改用户的电子邮件地址不会是最简单的操作。你在两个表中都使用 `email` 作为键，因此必须更新两个表。`references mailing_list`
    防止你只更新 `mailing_list` 而在 `phone_numbers` 中留下孤立的行。但如果用户频繁更改他们的电子邮件地址，你可能不希望以这种方式处理。
- en: Since you've no provision for storing a password or any other means of authentication,
    if you allow users to update their information, you run a minor risk of allowing
    a malicious change. (The risk isn't as great as it seems because you probably
    won't be publishing the complete mailing list; an attacker would have to guess
    the names of people on your mailing list.)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于您没有为存储密码或任何其他身份验证手段提供任何准备，如果允许用户更新其信息，您会面临允许恶意更改的轻微风险。（风险并不像看起来那么大，因为您可能不会发布完整的邮寄名单；攻击者必须猜测您邮寄名单上的人名。）
- en: These aren't necessarily bad realities in which to be locked. However, a good
    data modeler recognizes that every line of code in the .sql file has profound
    implications for the Web service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不一定是您希望陷入的不良现实。然而，一个优秀的数据建模者认识到.sql文件中的每一行代码对网络服务都有深远的影响。
- en: Papering Over Your Mistakes with Triggers
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用触发器掩盖您的错误
- en: 'Suppose that you''ve been using the above data model to collect the names of
    Web site readers who''d like to be alerted when you add new articles. You haven''t
    sent any notices for two months. You want to send everyone who signed up in the
    last two months a "Welcome to my Web service; thanks for signing up; here''s what''s
    new" message. You want to send the older subscribers a simple "here''s what''s
    new" message. But you can''t do this because you didn''t store a registration
    date. It is easy enough to fix the table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您一直在使用上述数据模型来收集希望在您添加新文章时收到提醒的网站读者的姓名。您已经两个月没有发送任何通知了。您想要发送给过去两个月内注册的所有人一个“欢迎来到我的网络服务；感谢您的注册；这里有什么新内容”的消息。您想要给较早注册的订阅者发送一个简单的“这里有什么新内容”的消息。但是您无法这样做，因为您没有存储注册日期。很容易修复表：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But what if you have 15 different Web scripts that use this table? The ones
    that query it aren't a problem. If they don't ask for the new column, they won't
    get it and won't realize that the table has been changed (this is one of the big
    selling features of the RDBMS). But the scripts that update the table will all
    need to be changed. If you miss a script, you're potentially stuck with a table
    where various random rows are missing critical information.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果您有15个不同的Web脚本使用这个表怎么办？查询它的不是问题。如果它们不请求新列，它们将不会得到它，也不会意识到表已经更改（这是关系数据库管理系统的一个重要卖点之一）。但是更新表的脚本都需要更改。如果您错过了一个脚本，您可能会陷入一个表中各种随机行缺少关键信息的困境。
- en: 'Oracle has a solution to your problem: *triggers*. A trigger is a way of telling
    Oracle "any time anyone touches this table, I want you to execute the following
    little fragment of code". Here''s how we define the trigger `mailing_list_registration_date`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle为您的问题提供了解决方案：*触发器*。触发器是告诉Oracle“每当有人触及这个表，我希望您执行以下代码片段”的一种方式。以下是我们如何定义触发器`mailing_list_registration_date`：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the trigger only runs when someone is trying to insert a row with
    a NULL registration date. If for some reason you need to copy over records from
    another database and they have a registration date, you don't want this trigger
    overwriting it with the date of the copy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，触发器仅在有人尝试插入具有NULL注册日期的行时才运行。如果出于某种原因您需要从另一个数据库复制记录，并且它们具有注册日期，您不希望此触发器用复制的日期覆盖它。
- en: A second point to note about this trigger is that it runs `for each row`. This
    is called a "row-level trigger" rather than a "statement-level trigger", which
    runs once per transaction, and is usually not what you want.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个触发器的第二点要注意的是它是`for each row`运行的。这被称为“行级触发器”，而不是“语句级触发器”，后者每个事务只运行一次，通常不是您想要的。
- en: A third point is that we're using the magic Oracle procedure `sysdate`, which
    will return the current time. The Oracle `date` type is precise to the second
    even though the default is to display only the day.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点是我们正在使用魔术Oracle过程`sysdate`，它将返回当前时间。Oracle的`date`类型精确到秒，即使默认只显示日期。
- en: A fourth point is that, starting with Oracle 8, we could have done this more
    cleanly by adding a `default sysdate` instruction to the column's definition.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第四点是，从Oracle 8开始，我们可以通过在列的定义中添加`default sysdate`指令来更清晰地执行此操作。
- en: 'The final point worth noting is the `:new.` syntax. This lets you refer to
    the new values being inserted. There is an analogous :old. feature, which is useful
    for update triggers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的最后一点是`:new.`语法。这使您可以引用正在插入的新值。还有一个类似的`:old.`功能，对于更新触发器很有用：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This time we used the `create or replace` syntax. This keeps us from having
    to `drop trigger mailing_list_update` if we want to change the trigger definition.
    We added a comment using the SQL comment shortcut "--". The syntax `new.` and
    `old.` is used in the trigger definition, limiting the conditions under which
    the trigger runs. Between the `begin` and `end`, we're in a PL/SQL block. This
    is Oracle's procedural language, described later, in which `new.name` would mean
    "the `name` element from the record in `new`". So you have to use `:new` instead.
    It is obscurities like this that lead to competent Oracle consultants being paid
    $200+ per hour.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了`create or replace`语法。这样我们就不必在想要更改触发器定义时`drop trigger mailing_list_update`。我们使用SQL注释快捷键"--"添加了一条注释。在触发器定义中使用了`new.`和`old.`，限制了触发器运行的条件。在`begin`和`end`之间，我们处于一个PL/SQL块中。这是Oracle的过程化语言，稍后会描述，其中`new.name`表示"从`new`中的记录中的`name`元素"。所以你必须使用`:new`。正是这些晦涩的地方导致了有能力的Oracle顾问每小时收费200美元以上。
- en: The "/" and `show errors` at the end are instructions to Oracle's SQL*Plus program.
    The slash says "I'm done typing this piece of PL/SQL, please evaluate what I've
    typed." The "show errors" says "if you found anything to object to in what I just
    typed, please tell me".
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '"/"和`show errors`在最后是给Oracle的SQL*Plus程序的指令。斜杠表示"我已经输入完这段PL/SQL，请评估我刚刚输入的内容。"
    "show errors"表示"如果你发现我刚刚输入的内容有任何问题，请告诉我"。'
- en: The Discussion Forum -- philg's personal odyssey
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论论坛--菲尔格的个人奥德赛
- en: 'Back in 1995, I built a threaded discussion forum, described *ad nauseum* in
    [http://philip.greenspun.com/wtr/dead-trees/53013.htm](/wtr/dead-trees/53013.htm).
    Here''s how I stored the postings:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，我建立了一个分级讨论论坛，详细描述在[http://philip.greenspun.com/wtr/dead-trees/53013.htm](/wtr/dead-trees/53013.htm)中。这是我存储帖子的方式：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'German order reigns inside the system itself: messages are uniquely keyed with
    `msg_id`, refer to each other (i.e., say "I''m a response to msg X") with `refers_to`,
    and a thread can be displayed conveniently by using the `sort_key` column.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 系统内部采用德国排序：消息通过`msg_id`唯一标识，通过`refers_to`相互引用（即说"我是对消息X的回复"），通过`sort_key`列可以方便地显示一个主题串。
- en: Italian chaos is permitted in the `email` and `name` columns; users could remain
    anonymous, masquerade as "president@whitehouse.gov" or give any name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`email`和`name`列允许意大利式混乱；用户可以保持匿名，冒充"president@whitehouse.gov"或给出任何名字。'
- en: This seemed like a good idea when I built the system. I was concerned that it
    work reliably. I didn't care whether or not users put in bogus content; the admin
    pages made it really easy to remove such postings and, in any case, if someone
    had something interesting to say but needed to remain anonymous, why should the
    system reject their posting?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我建立系统时，这似乎是个好主意。我关心的是它能够可靠运行。我不在乎用户是否输入虚假内容；管理页面使得删除这样的帖子非常容易，而且，无论如何，如果有人有有趣的东西要说但需要保持匿名，为什么系统要拒绝他们的帖子呢？
- en: One hundred thousand postings later, as the moderator of the [photo.net](http://www.photo.net/)
    Q&A forum, I began to see the dimensions of my data modeling mistakes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 10万个帖子后，作为[photo.net](http://www.photo.net/)问答论坛的管理员，我开始看到我的数据建模错误的规模。
- en: First, anonymous postings and fake email addresses didn't come from Microsoft
    employees revealing the dark truth about their evil bosses. They came from complete
    losers trying and failing to be funny or wishing to humiliate other readers. Some
    fake addresses came from people scared by the rising tide of spam email (not a
    serious problem back in 1995).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，匿名帖子和虚假电子邮件地址并不是来自微软员工揭露他们邪恶老板的黑暗真相。它们来自一些失败者，试图但失败地想要搞笑或者希望羞辱其他读者。一些虚假地址来自于被垃圾邮件潮水吓到的人们（在1995年并不是一个严重的问题）。
- en: Second, I didn't realize how the combination of my email alert systems, fake
    email addresses, and Unix mailers would result in my personal mailbox filling
    up with messages that couldn't be delivered to "asdf@asdf.com" or "duh@duh.net".
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我没有意识到我的电子邮件警报系统、虚假电子邮件地址和Unix邮件程序的结合会导致我的个人邮箱被填满无法发送到"asdf@asdf.com"或"duh@duh.net"的消息。
- en: 'Although the solution involved changing some Web scripts, fundamentally the
    fix was add a column to store the IP address from which a post was made:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解决方案涉及更改一些Web脚本，但基本上修复的方法是添加一列来存储发帖的IP地址：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Keeping these data enabled me to see that most of the anonymous posters were
    people who'd been using the forum for some time, typically from the same IP address.
    I just sent them mail and asked them to stop, explaining the problem with bounced
    email.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 保留这些数据使我能够看到大多数匿名发帖者是那些使用论坛已经一段时间的人，通常来自相同的IP地址。我只是给他们发送邮件，要求他们停止，解释了电子邮件退信的问题。
- en: After four years of operating the photo.net community, it became apparent that
    we needed ways to
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 经营photo.net社区四年后，我们意识到我们需要一些方法来
- en: display site history for users who had changed their email addresses
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为已更改其电子邮件地址的用户显示站点历史记录
- en: discourage problem users from burdening the moderators and the community
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止问题用户给管理员和社区带来负担
- en: carefully tie together user-contributed content in the various subsystems of
    photo.net
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细地将用户贡献的内容在photo.net的各个子系统中紧密联系在一起
- en: 'The solution was obvious to any experienced database nerd: a canonical users
    table and then content tables that reference it. Here''s a simplified version
    of the data model, taken from a toolkit for building online communities, describe
    in [http://philip.greenspun.com/panda/community](/panda/community):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何有经验的数据库极客来说，解决方案是显而易见的：一个规范的用户表，然后引用它的内容表。这里是一个简化版本的数据模型，取自一个用于构建在线社区的工具包，描述在[http://philip.greenspun.com/panda/community](/panda/community)中：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that a contributor''s name and email address no longer appear in the `bboard`
    table. That doesn''t mean we don''t know who posted a message. In fact, this data
    model can''t even represent an anonymous posting: `user_id integer not null references
    users` requires that each posting be associated with a user ID and that there
    actually be a row in the `users` table with that ID.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，贡献者的姓名和电子邮件地址不再出现在`bboard`表中。这并不意味着我们不知道谁发布了消息。事实上，这个数据模型甚至不能表示匿名帖子：`user_id
    integer not null references users`要求每个帖子都与一个用户ID相关联，并且`users`表中实际上有一个具有该ID的行。
- en: First, let's talk about how much fun it is to move a live-on-the-Web 600,000
    hit/day service from one data model to another. In this case, note that the original
    `bboard` data model had a single `name` column. The community system has separate
    columns for first and last names. A conversion script can easily split up "Joe
    Smith" but what is it to do with [William Henry Gates III](/bg/)?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈将一个每天有60万次点击的网络服务从一个数据模型移动到另一个数据模型是多么有趣。在这种情况下，请注意原始的`bboard`数据模型只有一个`name`列。社区系统有单独的列用于名字和姓氏。一个转换脚本可以轻松地拆分"Joe
    Smith"，但是对于[William Henry Gates III](/bg/)该怎么办呢？
- en: How do we copy over anonymous postings? Remember that Oracle is not flexible
    or intelligent. We said that we wanted every row in the `bboard` table to reference
    a row in the `users` table. Oracle will abort any transaction that would result
    in a violation of this integrity constraint. So we either have to drop all those
    anonymous postings (and any non-anonymous postings that refer to them) or we have
    to create a user called "Anonymous" and assign all the anonymous postings to that
    person. The technical term for this kind of solution is *kludge*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何复制匿名帖子？请记住，Oracle不灵活也不智能。我们说我们希望`bboard`表中的每一行都引用`users`表中的一行。Oracle将中止任何可能违反完整性约束的事务。因此，我们要么放弃所有这些匿名帖子（以及引用它们的任何非匿名帖子），要么创建一个名为"Anonymous"的用户，并将所有匿名帖子分配给该用户。这种解决方案的技术术语是*kludge*。
- en: A more difficult problem than anonymous postings is presented by long-time users
    who have difficulty typing and or keeping a job. Consider a user who has identified
    himself as
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 长期用���中比匿名帖子更困难的问题是那些在打字或保持工作方面有困难的用户。考虑一个已经自我识别为
- en: Joe Smith; jsmith@ibm.com
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Joe Smith; jsmith@ibm.com
- en: Jo Smith; jsmith@ibm.com (typo in name)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jo Smith; jsmith@ibm.com (姓名拼写错误)
- en: Joseph Smith; jsmth@ibm.com (typo in email)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Joseph Smith; jsmth@ibm.com (电子邮件中的拼写错误)
- en: Joe Smith; cantuseworkaddr@hotmail.com (new IBM policy)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Joe Smith; cantuseworkaddr@hotmail.com (IBM的新政策)
- en: Joe Smith-Jones; joe_smithjones@hp.com (got married, changed name, changed jobs)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Joe Smith-Jones; joe_smithjones@hp.com (结婚，改名字，换工作)
- en: Joe Smith-Jones; jsmith@somedivision.hp.com (valid but not canonical corporate
    email address)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Joe Smith-Jones; jsmith@somedivision.hp.com (有效但不是规范的公司电子邮件地址)
- en: Josephina Smith; jsmith@somedivision.hp.com (sex change; divorce)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Josephina Smith; jsmith@somedivision.hp.com (性别变更；离婚)
- en: Josephina Smith; josephina_smith@hp.com (new corporate address)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Josephina Smith; josephina_smith@hp.com (新的公司地址)
- en: Siddhartha Bodhisattva; josephina_smith@hp.com (change of philosophy)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Siddhartha Bodhisattva; josephina_smith@hp.com (哲学观念的改变)
- en: Siddhartha Bodhisattva; thinkwaitfast@hotmail.com (traveling for awhile to find
    enlightenment)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Siddhartha Bodhisattva; thinkwaitfast@hotmail.com（暂时旅行以寻找启示）
- en: Contemporary community members all recognize these postings as coming from the
    same person but it would be very challenging even to build a good semi-automated
    means of merging postings from this person into one user record.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当代社区成员都认识这些帖子来自同一个人，但要构建一个良好的半自动合并该人的帖子到一个用户记录中的方法是非常具有挑战性的。
- en: Once we've copied everything into this new *normalized* data model, notice that
    we can't dig ourselves into the same hole again. If a user has contributed 1000
    postings, we don't have 1000 different records of that person's name and email
    address. If a user changes jobs, we need only update one column in one row in
    one table.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将所有内容复制到这个新的*规范化*数据模型中，注意到我们不能再次陷入同样的困境。如果一个用户贡献了1000篇帖子，我们不会有1000条不同的记录来记录该用户的姓名和电子邮件地址。如果一个用户换工作了，我们只需要更新一个表中的一行中的一个列。
- en: The `html_p` column in the new data model is worth mentioning. In 1995, I didn't
    understand the problems of user-submitted data. Some users will submit plain text,
    which seems simple, but in fact you can't just spit this out as HTML. If user
    A typed < or > characters, they might get swallowed by user B's Web browser. Does
    this matter? Consider that "<g>" is interpreted in various online circles as an
    abbreviation for "grin" but by Netscape Navigator as an unrecognized (and therefore
    ignore) HTML tag. Compare the meaning of
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 新数据模型中的`html_p`列值得一提。在1995年，我并不了解用户提交数据的问题。一些用户会提交纯文本，看起来很简单，但实际上你不能简单地将其输出为HTML。如果用户A键入<或>字符，它们可能会被用户B的Web浏览器吞噬。这有关紧要吗？考虑"<g>"在各个在线圈子中被解释为"咧嘴笑"的缩写，但在Netscape
    Navigator中被解释为未识别（因此被忽略）的HTML标签。比较以下含义
- en: '"We shouldn''t think it unfair that Bill Gates has more wealth than the 100
    million poorest Americans *combined*. After all, he invented the personal computer,
    the graphical user interface, and the Internet."'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"我们不应认为比尔·盖茨拥有的财富比1亿最贫困的美国人*加起来*还要多是不公平的。毕竟，他发明了个人电脑、图形用户界面和互联网。"'
- en: with
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: with
- en: '"We shouldn''t think it unfair that Bill Gates has more wealth than the 100
    million poorest Americans *combined*. After all, he invented the personal computer,
    the graphical user interface, and the Internet. <g>"'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"我们不应认为比尔·盖茨拥有的财富比1亿最贫困的美国人*加起来*还要多是不公平的。毕竟，他发明了个人电脑、图形用户界面和互联网。<g>"'
- en: It would have been easy enough for me to make sure that such characters never
    got interpreted as markup. In fact, with AOLserver one can do it with a single
    call to the built-in procedure `ns_quotehtml`. However, consider the case where
    a nerd posts some HTML. Other users would then see
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，确保这些字符永远不会被解释为标记是很容易的。事实上，使用AOLserver，只需调用内置过程`ns_quotehtml`就可以做到。然而，考虑一个情况，一个书呆子发布了一些HTML。其他用户会看到
- en: '"For more examples of my brilliant thinking and modesty, check out <a href="http://philip.greenspun.com/">my
    home page</a>."'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"想要了解更多我卓越的思考和谦逊，请查看<a href="http://philip.greenspun.com/">我的主页</a>。"'
- en: I discovered that the only real solution is to ask the user whether the submission
    is an HTML fragment or plain text, show the user an approval page where the content
    may be previewed, and then remember what the user told us in an `html_p` column
    in the database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现唯一真正的解决方案是询问用户提交的内容是HTML片段还是纯文本，在数据库中的`html_p`列中显示用户告诉我们的内容，并向用户展示一个可预览内容的批准页面。
- en: 'Is this data model perfect? Permanent? Absolutely. It will last for at least...
    Whoa! Wait a minute. I didn''t know that Dave Clark was replacing his original
    Internet Protocol, which the world has been running since around 1980, with IPv6
    ([http://www.faqs.org/rfcs/rfc2460.html](http://www.faqs.org/rfcs/rfc2460.html)).
    In the near future, we''ll have IP addresses that are 128 bits long. That''s 16
    bytes, each of which takes two hex characters to represent. So we need 32 characters
    plus at least 7 more for periods that separate the hex digits. We might also need
    a couple of characters in front to say "this is a hex representation". Thus our
    brand new data model in fact has a crippling deficiency. How easy is it to fix?
    In Oracle:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据模型完美吗？永久吗？绝对是。它至少会持续...哇！等一下。我不知道 Dave Clark 正在用 IPv6 ([http://www.faqs.org/rfcs/rfc2460.html](http://www.faqs.org/rfcs/rfc2460.html))
    替换自 1980 年左右以来世界一直在运行的原始互联网协议。在不久的将来，我们将拥有 128 位长的 IP 地址。这是 16 字节，每个字节需要两个十六进制字符来表示。因此我们需要
    32 个字符，再加上至少 7 个用于分隔十六进制数字的句号。我们可能还需要几个字符来表示“这是一个十六进制表示”。因此，我们全新的数据模型实际上存在严重的缺陷。修复起来有多容易？在
    Oracle 中：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You won't always get off this easy. Oracle won't let you shrink a column from
    a maximum of 50 characters to 16, even if no row has a value longer than 16 characters.
    Oracle also makes it tough to add a column that is constrained `not null`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会总是这么轻松。Oracle 不会让你将列从最大长度为 50 个字符缩减到 16 个字符，即使没有任何行的值长于 16 个字符。Oracle 也让添加一个约束为`not
    null`的列变得困难。
- en: Representing Web Site Core Content
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代表网站核心内容
- en: Free-for-all Internet discussions can often be useful and occasionally are compelling,
    but the anchor of a good Web site is usually a set of carefully authored extended
    documents. Historically these have tended to be stored in the Unix file system
    and they don't change too often. Hence I refer to them as *static pages*. Examples
    of static pages on the photo.net server include this book chapter, the tutorial
    on light for photographers at [http://www.photo.net/making-photographs/light](http://www.photo.net/making-photographs/light).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 无限制的互联网讨论通常是有用的，有时也是引人入胜的，但一个好的网站的支柱通常是一组精心编写的扩展文档。从历史上看，这些文档往往存储在 Unix 文件系统中，且不经常更改。因此，我将它们称为*静态页面*。在
    photo.net 服务器上的静态页面示例包括本书章节，摄影师光线教程在 [http://www.photo.net/making-photographs/light](http://www.photo.net/making-photographs/light)。
- en: We have some big goals to consider. We want the data in the database to
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些重要的目标要考虑。我们希望数据库中的数据
- en: help community experts figure out which articles need revision and which new
    articles would be most valued by the community at large.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助社区专家确定哪些文章需要修订，以及社区整体最看重哪些新文章。
- en: help contributors work together on a draft article or a new version of an old
    article.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助贡献者共同撰写草稿文章或旧文章的新版本。
- en: collect and organize reader comments and discussion, both for presentation to
    other readers but also to assist authors in keeping content up-to-date.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集和组织读者的评论和讨论，不仅用于展示给其他读者，还用于帮助作者保持内容的更新。
- en: collect and organize reader-submitted suggestions of related content out on
    the wider Internet (i.e., links).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集和组织读者提交的有关更广泛互联网上相关内容（即链接）的建议。
- en: help point readers to new or new-to-them content that might interest them, based
    on what they've read before or based on what kind of content they've said is interesting.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助读者指向可能对他们感兴趣的新内容或对他们来说是新的内容，这是基于他们之前阅读的内容或基于他们认为有趣的内容类型。
- en: 'The big goals lead to some more concrete objectives:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重要目标导致了一些更具体的目标：
- en: We will need a table that holds the static pages themselves.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将需要一个保存静态页面本身的表。
- en: Since there are potentially many comments per page, we need a separate table
    to hold the user-submitted comments.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每页可能有许多评论，我们需要一个单独的表来保存用户提交的评论。
- en: Since there are potentially many related links per page, we need a separate
    table to hold the user-submitted links.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每页可能有许多相关链接，我们需要一个单独的表来保存用户提交的链接。
- en: Since there are potentially many authors for one page, we need a separate table
    to register the author-page many-to-one relation.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于一个页面可能有许多作者，我们需要一个单独的表来注册作者-页面的多对一关系。
- en: Considering the "help point readers to stuff that will interest them" objective,
    it seems that we need to store the category or categories under which a page falls.
    Since there are potentially many categories for one page, we need a separate table
    to hold the mapping between pages and categories.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到“帮助读者找到他们感兴趣的内容”目标，似乎我们需要存储页面所属的类别或类别。由于一个页面可能有多个类别，我们需要一个单独的表来保存页面和类别之间的映射。
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we use a generated integer `page_id` key for this table. We could
    key the table by the `url_stub` (filename), but that would make it very difficult
    to reorganize files in the Unix file system (something that should actually happen
    very seldom on a Web server; it breaks links from foreign sites).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这个表中使用一个生成的整数`page_id`键。我们本可以用`url_stub`（文件名）作为表的键，但这样会使在Unix文件系统中重新组织文件变得非常困难（这在Web服务器上实际上很少发生；它会破坏来自外部站点的链接）。
- en: How to generate these unique integer keys when you have to insert a new row
    into `static_pages`? You could
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要向`static_pages`插入新行时，如何生成这些唯一的整数键？您可以
- en: lock the table
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定表
- en: find the maximum `page_id` so far
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到迄今为止的最大`page_id`
- en: add one to create a new unique `page_id`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加一以创建一个新的唯一`page_id`
- en: insert the row
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入行
- en: commit the transaction (releases the table lock)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交事务（释放表锁）
- en: 'Much better is to use Oracle''s built-in sequence generation facility:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用Oracle内置的序列生成功能：
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then we can get new page IDs by using `page_id_sequence.nextval` in INSERT statements
    (see [the Transactions chapter](transactions.html) for a fuller discussion of
    sequences).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过在INSERT语句中使用`page_id_sequence.nextval`来获得新的页面ID（详见[事务章节](transactions.html)以获取有关序列的更全面讨论）。
- en: '* * *'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Reference
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考
- en: 'Here is a summary of the data modeling tools available to you in Oracle, each
    hyperlinked to the Oracle documentation. This reference section covers the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Oracle中可用的数据建模工具的摘要，每个都链接到Oracle文档。本参考部分涵盖以下内容：
- en: data types
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: statements for creating, altering, and dropping tables
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建、修改和删除表的语句
- en: constraints
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束
- en: Data Types
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'For each column that you define for a table, you must specify the data type
    of that column. Here are your options:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于为表定义的每一列，您必须指定该列的数据类型。以下是您的选项：
- en: '| Character Data |'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 字符数据 |'
- en: '| char(n) | A fixed-length character string, e.g., `char(200)` will take up
    200 bytes regardless of how long the string actually is. This works well when
    the data truly are of fixed size, e.g., when you are recording a user''s sex as
    "m" or "f". This works badly when the data are of variable length. Not only does
    it waste space on the disk and in the memory cache, but it makes comparisons fail.
    For example, suppose you insert "rating" into a `comment_type` column of type
    `char(30)` and then your Tcl program queries the database. Oracle sends this column
    value back to procedural language clients padded with enough spaces to make up
    30 total characters. Thus if you have a comparison within Tcl of whether `$comment_type
    == "rating"`, the comparison will fail because `$comment_type` is actually "rating"
    followed by 24 spaces.'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| char(n) | 固定长度的字符字符串，例如，`char(200)`将占用200字节，无论实际字符串有多长。当数据确实是固定大小时，这种方法效果很好，例如，当您将用户的性别记录为“m”或“f”时。当数据长度可变时，这种方法效果很差。它不仅在磁盘和内存缓存中浪费空间，而且使比较失败。例如，假设您将“rating”插入到`char(30)`类型的`comment_type`列中，然后您的Tcl程序查询数据库。Oracle将此列值返回给过程化语言客户端，用足够的空格填充以使总共达到30个字符。因此，如果您在Tcl中有一个比较，比如`$comment_type
    == "rating"`，比较将失败，因为`$comment_type`实际上是“rating”后面跟着24个空格。'
- en: The maximum length char in Oracle8 is 2000 bytes. |
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Oracle8中char的最大长度为2000字节。
- en: '| varchar(n) | A variable-length character string, up to 4000 bytes long in
    Oracle8. These are stored in such a way as to minimize disk space usage, i.e.,
    if you only put one character into a column of type `varchar(4000)`, Oracle only
    consumes two bytes on disk. The reason that you don''t just make all the columns
    `varchar(4000)` is that the Oracle indexing system is limited to indexing keys
    of about 700 bytes. |'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| varchar(n) | Oracle8中的可变长度字符字符串，最长可达4000字节。这些存储方式旨在最大程度地减少磁盘空间的使用，即，如果你只在`varchar(4000)`类型的列中放入一个字符，Oracle在磁盘上只消耗两个字节。你不将所有列都设为`varchar(4000)`的原因是Oracle的索引系统限制了大约700字节的索引键。'
- en: '| clob | A variable-length character string, up to 4 gigabytes long in Oracle8.
    The CLOB data type is useful for accepting user input from such applications as
    discussion forums. Sadly, Oracle8 has tremendous limitations on how CLOB data
    may be inserted, modified, and queried. Use `varchar(4000)` if you can and prepare
    to suffer if you can''t.In a spectacular demonstration of what happens when companies
    don''t follow the lessons of [The Mythical Man Month](http://www.amazon.com/exec/obidos/ASIN/0201835959/pgreenspun-20),
    the regular string functions don''t work on CLOBs. You need to call identically
    named functions in the DBMS_LOB package. These functions take the same arguments
    but in different orders. You''ll never be able to write a working line of code
    without first reading [the DBMS_LOB section of the Oracle8 Server Application
    Developer''s Guide](http://www.oradoc.com/keyword/dbms_lob). |'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| clob | 一个可变长度的字符字符串，在Oracle8中最长可达4GB。CLOB数据类型对于接受来自诸如讨论论坛之类的应用程序的用户输入非常有用。遗憾的是，Oracle8对于如何插入、修改和查询CLOB数据有巨大的限制。如果可以的话，请使用`varchar(4000)`，如果不行就准备受苦吧。在一次极好的演示中展示了当公司不遵循《神话般的程序员月份》的教训时会发生什么，常规字符串函数无法在CLOB上工作。您需要调用DBMS_LOB包中同名的函数。这些函数接受相同的参数，但顺序不同。如果没有先阅读[Oracle8服务器应用程序开发人员指南中的DBMS_LOB部分](http://www.oradoc.com/keyword/dbms_lob)，您将永远无法编写出可工作的代码。'
- en: '| nchar, nvarchar, nclob | The n prefix stands for "national character set".
    These work like char, varchar, and clob but for multi-byte characters (e.g., Unicode;
    see [http://www.unicode.org](http://www.unicode.org)). |'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| nchar, nvarchar, nclob | n前缀代表“国家字符集”。这些工作方式类似于char、varchar和clob，但适用于多字节字符（例如Unicode；参见[http://www.unicode.org](http://www.unicode.org)）。'
- en: '| Numeric Data |'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 数值数据 |'
- en: '| number | Oracle actually only has one internal data type that is used for
    storing numbers. It can handle 38 digits of precision and exponents from -130
    to +126\. If you want to get fancy, you can specify precision and scale limits.
    For example, `number(3,0)` says "round everything to an integer [scale 0] and
    accept numbers than range from -999 to +999". If you''re American and commercially
    minded, `number(9,2)` will probably work well for storing prices in dollars and
    cents (unless you''re selling stuff to [Bill Gates](/WealthClock), in which case
    the billion dollar limit imposed by the precision of 9 might prove constraining).
    If you *are* [Bill Gates](http://www.photo.net/bg/), you might not want to get
    distracted by insignificant numbers: Tell Oracle to round everything to the nearest
    million with `number(38,-6)`. |'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| number | Oracle实际上只有一个内部数据类型用于存储数字。它可以处理38位精度和指数范围从-130到+126。如果您想要更精确，可以指定精度和标度限制。例如，`number(3,0)`表示“将所有内容四舍五入为整数[标度0]，接受范围从-999到+999的数字”。如果您是美国人并且商业头脑，`number(9,2)`可能很适合用于存储美元和美分的价格（除非您在向[比尔·盖茨](/WealthClock)出售商品，在这种情况下，由于9的精度限制可能会限制）。如果您*是*
    [比尔·盖茨](http://www.photo.net/bg/)，您可能不想被无关紧要的数字分散注意力：告诉Oracle将所有内容四舍五入到最接近的百万，使用`number(38,-6)`。'
- en: '| integer | In terms of storage consumed and behavior, this is not any different
    from `number(38)` but I think it reads better and it is more in line with ANSI
    SQL (which would be a standard if anyone actually implemented it). |'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| integer | 就存储消耗和行为而言，这与`number(38)`没有任何不同，但我认为它读起来更好，更符合ANSI SQL（如果有人实际上实现了它的话）。'
- en: '| Dates and Date/Time Intervals (Version 9i and newer) |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 日期和日期/时间间隔（9i版本及更新版本） |'
- en: '| timestamp | A point in time, recorded with sub-second precision. When creating
    a column you specify the number of digits of precision beyond one second from
    0 (single second precision) to 9 (nanosecond precision). Oracle''s calendar can
    handle dates between between January 1, 4712 BC and December 31, 9999 AD. You
    can put in values with the `to_timestamp` function and query them out using the
    `to_char` function. Oracle offers several variants of this datatype for coping
    with data aggregated across multiple timezones. |'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| timestamp | 一个记录了亚秒精度的时间点。在创建列时，您可以指定从0（单秒精度）到9（纳秒精度）的精度位数。Oracle的日历可以处理公元前4712年1月1日至公元9999年12月31日之间的日期。您可以使用`to_timestamp`函数输入值，并使用`to_char`函数查询这些值。Oracle提供了几种此数据类型的变体，用于处理跨多个时区聚合的数据。'
- en: '| interval year to month | An amount of time, expressed in years and months.
    |'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| interval year to month | 一段时间，以年和月表示。'
- en: '| interval day to second | An amount of time, expressed in days, hours, minutes,
    and seconds. Can be precise down to the nanosecond if desired. |'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| interval day to second | 一段时间，以天、小时、分钟和秒表示。如果需要，可以精确到纳秒。 |'
- en: '| Dates and Date/Time Intervals (Versions 8i and earlier) |'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 日期和日期/时间间隔（8i及更早版本） |'
- en: '| date | Obsolete as of version 9i. A point in time, recorded with one-second
    precision, between January 1, 4712 BC and December 31, 4712 AD. You can put in
    values with the `to_date` function and query them out using the `to_char` function.
    If you don''t use these functions, you''re limited to specifying the date with
    the default system format mask, usually ''DD-MON-YY''. This is a good recipe for
    a Year 2000 bug since January 23, 2000 would be ''23-JAN-00''. On better-maintained
    systems, this is often the ANSI default: ''YYYY-MM-DD'', e.g., ''2000-01-23''
    for January 23, 2000. |'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| date | 自9i版本起已过时。一个时间点，以秒为精度记录，介于公元前4712年1月1日和公元4712年12月31日之间。您可以使用`to_date`函数输入值，并使用`to_char`函数查询出来。如果不使用这些函数，您将受限于使用默认系统格式掩码指定日期，通常为''DD-MON-YY''。这是一��引发2000年问题的好方法，因为2000年1月23日将被表示为''23-JAN-00''。在维护更好的系统中，这通常是ANSI的默认格式：''YYYY-MM-DD''，例如，2000年1月23日表示为''2000-01-23''。
    |'
- en: '| number | Hey, isn''t this a typo? What''s `number` doing in the date section?
    It is here because this is how Oracle versions prior to 9i represented date-time
    intervals, though their docs never say this explicitly. If you add numbers to
    dates, you get new dates. For example, tomorrow at exactly this time is `sysdate+1`.
    To query for stuff submitted in the last hour, you limit to `submitted_date >
    sysdate - 1/24`. |'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| number | 嘿，这不是一个打字错误吗？`number`在日期部分做什么？它在这里是因为在9i版本之前的Oracle版本中代表日期时间间隔，尽管他们的文档从未明确说明这一点。如果您将数字添加到日期中，您将得到新的日期。例如，明天的这个时间是`sysdate+1`。要查询最近一小时提交的内容，您可以限制为`submitted_date
    > sysdate - 1/24`。 |'
- en: '| Binary Data |'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 二进制数据 |'
- en: '| blob | BLOB stands for "Binary Large OBject". It doesn''t really have to
    be all that large, though Oracle will let you store up to 4 GB. The BLOB data
    type was set up to permit the storage of images, sound recordings, and other inherently
    binary data. In practice, it also gets used by fraudulent application software
    vendors. They spend a few years kludging together some nasty format of their own.
    Their MBA executive customers demand that the whole thing be RDBMS-based. The
    software vendor learns enough about Oracle to "stuff everything into a BLOB".
    Then all the marketing and sales folks are happy because the application is now
    running from Oracle instead of from the file system. Sadly, the programmers and
    users don''t get much because you can''t use SQL very effectively to query or
    update what''s inside a BLOB. |'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| blob | BLOB代表“二进制大对象”。虽然它不一定非常大，但是Oracle允许您存储高达4 GB的数据。BLOB数据类型被设置为允许存储图像、声音录音和其他固有的二进制数据。实际上，它也被欺诈性应用软件供应商使用。他们花几年时间把一些自己的恶劣格式凑在一起。他们的MBA高管客户要求整个系统基于关系数据库管理系统。软件供应商学会了足够的Oracle知识来“把所有东西都塞进一个BLOB中”。然后所有的市场营销和销售人员都很高兴，因为应用现在是从Oracle而不是文件系统中运行的。不幸的是，程序员和用户得不到太多帮助，因为你不能很有效地使用SQL来查询或更新BLOB中的内容。
    |'
- en: '| bfile | A binary file, stored by the operating system (typically Unix) and
    kept track of by Oracle. These would be useful when you need to get to information
    both from SQL (which is kept purposefully ignorant about what goes on in the wider
    world) and from an application that can only read from standard files (e.g., a
    typical Web server). The bfile data type is pretty new but to my mind it is already
    obsolete: Oracle 8.1 (8i) lets external applications view content in the database
    as though it were a file on a Windows NT server. So why not keep everything as
    a BLOB and enable Oracle''s Internet File System? |'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| bfile | 一个由操作系统（通常是Unix）存储并由Oracle跟踪的二进制文件。当您需要从SQL（故意对外部世界发生的事情一无所知）和只能从标准文件读取的应用程序（例如典型的Web服务器）中获取信息时，这些将非常有用。bfile数据类型是相当新的，但在我看来已经过时了：Oracle
    8.1（8i）让外部应用程序可以查看数据库中的内容，就好像它是Windows NT服务器上的文件一样。那么为什么不将所有内容都保留为BLOB并启用Oracle的Internet文件系统呢？
    |'
- en: Despite this plethora of data types, Oracle has some glaring holes that torture
    developers. For example, there is no Boolean data type. A developer who needs
    an `approved_p` column is forced to use `char(1) check(this_column in ('t','f'))`
    and then, instead of the clean query `where approved_p` is forced into `where
    approved_p = 't'`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这么多数据类型，Oracle还存在一些折磨开发人员的明显缺陷。例如，没有布尔数据类型。需要一个`approved_p`列的开发人员被迫使用`char(1)
    check(this_column in ('t','f'))`，然后，而不是简洁的查询`where approved_p`，被迫使用`where approved_p
    = 't'`。
- en: Oracle8 includes a limited ability to create your own data types. Covering these
    is beyond the scope of this book. See Oracle8 Server Concepts, [User-Defined Datatypes](http://www.oradoc.com/keyword/user_datatypes).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle8 包括有限的能力来创建自己的数据类型。涵盖这些内容超出了本书的范围。请参阅 Oracle8 Server Concepts，[User-Defined
    Datatypes](http://www.oradoc.com/keyword/user_datatypes)。
- en: Tables
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表
- en: 'The basics:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 基础知识：
- en: '[PRE15]'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even in a simple example such as the one above, there are few items worth noting.
    First, I like to define the key column(s) at the very top. Second, the `primary
    key` constraint has some powerful effects. It forces `the_key_column` to be non-null.
    It causes the creation of an index on `the_key_column`, which will slow down updates
    to `your_table_name` but improve the speed of access when someone queries for
    a row with a particular value of `the_key_column`. Oracle checks this index when
    inserting any new row and aborts the transaction if there is already a row with
    the same value for `the_key_column`. Third, note that there is no comma following
    the definition of the last row. If you are careless and leave the comma in, Oracle
    will give you a very confusing error message.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在上面这个简单的示例中，也有一些值得注意的地方。首先，我喜欢在最顶部定义关键列。其次，`primary key` 约束具有一些强大的效果。它强制`the_key_column`为非空。它会在`the_key_column`上创建一个索引，这会减慢对`your_table_name`的更新速度，但在有人查询具有特定`the_key_column`值的行时，会提高访问速度。Oracle
    在插入任何新行时会检查此索引，并在`the_key_column`已经存在具有相同值的行时中止事务。第三，注意在最后一行的定义后没有逗号。如果你粗心大意地留下逗号，Oracle
    将给出一个非常令人困惑的错误消息。
- en: If you didn't get it right the first time, you'll probably want to
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一次没有做对，你可能会想要
- en: '[PRE16]'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: or
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE17]'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Oracle 8i you can drop a column:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 8i 中，你可以删除一列：
- en: '[PRE18]'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE18]'
- en: (see [http://www.oradoc.com/keyword/drop_column](http://www.oradoc.com/keyword/drop_column)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: （参见[http://www.oradoc.com/keyword/drop_column](http://www.oradoc.com/keyword/drop_column)）。
- en: If you're still in the prototype stage, you'll probably find it easier to simply
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍处于原型阶段，你可能会发现简单地
- en: '[PRE19]'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'and recreate it. At any time, you can see what you''ve got defined in the database
    by querying Oracle''s *Data Dictionary*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 并重新创建它。随时，你可以通过查询 Oracle 的*数据字典*来查看在数据库中定义的内容：
- en: '[PRE20]'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'after which you will typically type `describe table_name_of_interest` in SQL*Plus:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你通常会在 SQL*Plus 中键入`describe table_name_of_interest`：
- en: '[PRE21]'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that Oracle displays its internal data types rather than the ones you've
    given, e.g., `number(38)` rather than `integer` and `varchar2` instead of the
    specified `varchar`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Oracle 显示的是其内部数据类型，而不是你给定的数据类型，例如，`number(38)` 而不是 `integer`，`varchar2`
    而不是指定的 `varchar`。
- en: Constraints
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 约束
- en: 'When you''re defining a table, you can constrain single rows by adding some
    magic words after the data type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义表时，可以通过在数据类型后添加一些魔术词来约束单行：
- en: '`not null`; requires a value for this column'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not null`；要求此列有一个值'
- en: '`unique`; two rows can''t have the same value in this column (side effect in
    Oracle: creates an index)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique`；两行不能在此列中具有相同的值（在 Oracle 中的副作用：创建索引）'
- en: '`primary key`; same as `unique` except that no row can have a null value for
    this column and other tables can refer to this column'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primary key`；与`unique`相同，只是此列不能有空值，其他表可以引用此列'
- en: '`check`; limit the range of values for column, e.g., `rating integer check(rating
    > 0 and rating <= 10)<="" code="">`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check`；限制列的值范围，例如，`rating integer check(rating > 0 and rating <= 10)`'
- en: '``references`; this column can only contain values present in another table''s
    primary key column, e.g., `user_id not null references users` in the `bboard`
    table forces the `user_id` column to only point to valid users. An interesting
    twist is that you don''t have to give a data type for `user_id`; Oracle assigns
    this column to whatever data type the foreign key has (in this case `integer`).`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`references`；此列只能包含另一个表的主键列中存在的值，例如，在`bboard`表中，`user_id not null references
    users` 强制`user_id`列只能指向有效的用户。一个有趣的转折是，你不必为`user_id`指定数据类型；Oracle 会将此列分配给外键具有的数据类型（在本例中为`integer`）。'
- en: 'Constraints can apply to multiple columns:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 约束可以应用于多列：
- en: '[PRE22]'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Oracle will let us keep rows that have the same `page_id` and rows that have
    the same `user_id` but not rows that have the same value in both columns (which
    would not make sense; a person can''t be the author of a document more than once).
    Suppose that you run a university distinguished lecture series. You want speakers
    who are professors at other universities or at least PhDs. On the other hand,
    if someone controls enough money, be it his own or his company''s, he''s in. Oracle
    stands ready:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle允许我们保留具有相同`page_id`的行和具有相同`user_id`的行，但不允许具有两列中相同值的行（这是没有意义的；一个人不能多次成为文档的作者）。假设你运行一个大学的杰出讲座系列。你希望演讲者是其他大学的教授或至少是博士。另一方面，如果有人控制足够的资金，无论是他自己的还是他公司的，他都可以参加。Oracle随时待命：
- en: '[PRE23]'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As desired, Oracle prevented us from inserting some random average loser into
    the `distinguished_lecturers` table, but the error message was confusing in that
    it refers to a constraint given the name of "SYS_C001819" and owned by the PHOTONET
    user. We can give our constraint a name at definition time:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如期望的那样，Oracle阻止我们向`distinguished_lecturers`表中插入一些随机的普通失败者，但错误消息令人困惑，因为它引用了一个名为"SYS_C001819"的约束，并由PHOTONET用户拥有。我们可以在定义时为我们的约束命名：
- en: '[PRE24]'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now the error message is easier to understand by application programmers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在错误消息对应用程序员来说更容易理解。
- en: Creating More Elaborate Constraints with Triggers
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用触发器创建更复杂的约束
- en: The default Oracle mechanisms for constraining data are not always adequate.
    For example, the ArsDigita Community System auction module has a table called
    `au_categories`. The `category_keyword` column is a unique shorthand way of referring
    to a category in a URL. However, this column may be NULL because it is not the
    primary key to the table. The shorthand method of referring to the category is
    optional.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 默认的数据约束机制并不总是足够。例如，ArsDigita社区系统的拍卖模块有一个名为`au_categories`的表。`category_keyword`列是在URL中引用类别的唯一简写方式。然而，这一列可能为空，因为它不是表的主键。引用类别的简写方法是可选的。
- en: '[PRE25]'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can''t add a UNIQUE constraint to the `category_keyword` column. That would
    allow the table to only have one row where `category_keyword` was NULL. So we
    add a trigger that can execute an arbitrary PL/SQL expression and raise an error
    to prevent an INSERT if necessary:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法向`category_keyword`列添加唯一约束。这将允许表只有一行`category_keyword`为空的情况。因此，我们添加一个触发器，可以执行任意的PL/SQL表达式，并在必要时引发错误以阻止插入：
- en: '[PRE26]'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This trigger queries the table to find out if there are any matching keywords
    already inserted. If there are, it calls the built-in Oracle procedure `raise_application_error`
    to abort the transaction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此触发器查询表以查找是否已插入任何匹配的关键字。如果有，它调用内置的Oracle过程`raise_application_error`来中止事务。
- en: The True Oracle Religion
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正统的Oracle宗教
- en: Oracle8 Server Application Developer's Guide, [Selecting a Datatype](http://www.oradoc.com/keyword/datatype_selection)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle8服务器应用程序开发人员指南，[选择数据类型](http://www.oradoc.com/keyword/datatype_selection)
- en: Oracle8 Server Concepts, [Built-In Datatypes](http://www.oradoc.com/keyword/builtin_datatypes)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle8服务器概念，[内置数据类型](http://www.oradoc.com/keyword/builtin_datatypes)
- en: Oracle8 Server Concepts, [User-Defined Datatypes](http://www.oradoc.com/keyword/user_datatypes)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle8服务器概念，[用户定义数据类型](http://www.oradoc.com/keyword/user_datatypes)
- en: 'Next: [queries](queries.html)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步：[查询](queries.html)
- en: '* * *'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[philg@mit.edu](http://philip.greenspun.com/)[Add a comment](/comments/add?page_id=3459)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[philg@mit.edu](http://philip.greenspun.com/)[添加评论](/comments/add?page_id=3459)'
