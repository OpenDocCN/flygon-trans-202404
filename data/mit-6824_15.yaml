- en: Spanner
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spanner
- en: 6.824 2015 Lecture 15 Spanner
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.824 2015年第15讲Spanner
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.824 [course website](http://nil.csail.mit.edu/6.824/2015/schedule.html)
    from Spring 2015.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**这些讲座笔记略有修改，来源于2015年春季6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html)上发布的内容。'
- en: Intro
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: '[Spanner paper, OSDI 2012](http://research.google.com/archive/spanner.html)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[Spanner论文，OSDI 2012](http://research.google.com/archive/spanner.html)'
- en: 'Shattered old assumption: cannot assume that clocks are tightly synchronized'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打破了旧的假设：不能假设时钟紧密同步
- en: 'tightly synchronized clocks are now feasible in a global scale distributed
    system: GPS and atomic clocks as independent sources'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在全球范围内的分布式系统中，紧密同步的时钟现在是可行的：GPS和原子钟作为独立的来源
- en: '*Data model:* immutable versioned data'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据模型：*不可变版本化数据'
- en: built and deployed system in multiple data centers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个数据中心构建和部署系统
- en: Paxos helps you determine order of events. Why do we still need time?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paxos帮助您确定事件顺序。为什么我们仍然需要时间？
- en: used synchronized time to allow local reads without locks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同步时间允许本地读取而无需锁定
- en: transactions on top of replication
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复制之上的事务
- en: two-phase commit across groups of replicas
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨多个副本组的两阶段提交
- en: concurrency control
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发控制
- en: strict two phase locking with timestamps
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格的两阶段锁定与时间戳
- en: Paxos
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paxos
- en: long-lived leader (timed leases)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长寿领导者（定时租约）
- en: pipelined (multiple proposals in flight)
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线（多个提案在飞行中）
- en: out-of-order commit, in-order apply
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序提交，有序应用
- en: Spanner and 'research'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spanner和“研究”
- en: team is chock-full of PhDs
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队中充满了博士学位的人
- en: we write research papers when we feel the urge and we have something to say
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们有冲动并且有话要说时，我们会写研究论文
- en: cutting edge development, unbelievable scale, but we are not researchers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尖端开发，令人难以置信的规模，但我们不是研究人员
- en: Historical context
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史背景
- en: '[Bigtable paper, OSDI 2006](http://research.google.com/archive/bigtable.html)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[Bigtable论文，OSDI 2006](http://research.google.com/archive/bigtable.html)'
- en: started development at end of 2003 (6 PhDs)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2003年底开始开发（6位博士）
- en: first customer launched on Bigtable mid 2005
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个客户于2005年中期启动了Bigtable
- en: distributed key-value store
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式键值存储
- en: single-row transactions
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行事务
- en: later added lazy replication
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后来添加了延迟复制
- en: value proposition
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价值主张
- en: scale to large numbers
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展到大量数据
- en: automatic resharding
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动重新分片
- en: Bigtable was one of the progenitors of "NoSQL" or more precisely "of how do
    you store a lot of data without building a database"
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bigtable是“NoSQL”的鼻祖之一，或者更准确地说是“如何在不构建数据库的情况下存储大量数据”的鼻祖之一
- en: 'basic tenets at the time (design assumptions for Bigtable):'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当时的基本原则（Bigtable的设计假设）：
- en: who needs a database? key-value store suffices
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁需要数据库？键值存储就足够了
- en: who needs SQL? unnecessary for most applications
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁需要SQL？对大多数应用程序来说是不必要的
- en: who needs transactions? two-phase commit is too expensive
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁需要事务？两阶段提交太昂贵
- en: Why Spanner?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择Spanner？
- en: found that Bigtable is too hard to use
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现Bigtable太难使用
- en: users like the power that SQL database give them
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户喜欢SQL数据库给他们带来的强大功能
- en: engineers shouldn't have to code around
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师不应该被迫绕过
- en: the lack of transactions
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏事务
- en: the bugs that manifest due to weak semantics provided by lazy replication
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于延迟复制提供的弱语义而显现出的错误
- en: programmer productivity matters
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员的生产力很重要
- en: Megastore, started ca. 2006, built on top of Bigtable
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Megastore，约2006年开始，建立在Bigtable之上
- en: optimistic concurrency control
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乐观并发控制
- en: paxos-based replication
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Paxos的复制
- en: no long-lived leader (paxos "election" on every write)
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有长寿领导者（每次写入都进行Paxos“选举”）
- en: every paxos message was written to bigtable
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Paxos消息都写入Bigtable
- en: broader class of transactions than bigtable
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比Bigtable更广泛的事务类
- en: SQL-like schema and query languages
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似SQL的模式和查询语言
- en: had consistent replication
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有一致复制
- en: Dremel, data analysis at Google, started ca. 2008
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Dremel，Google的数据分析，约2008年开始
- en: column-oriented storage and query engine
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列向存储和查询引擎
- en: '[http://research.google.com/pubs/pub36632.html](http://research.google.com/pubs/pub36632.html)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://research.google.com/pubs/pub36632.html](http://research.google.com/pubs/pub36632.html)'
- en: popular because it allowed SQL
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它允许SQL而受欢迎
- en: Transactions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务
- en: '[Percolator, general purpose transactions](http://research.google.com/pubs/pub36726.html)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[Percolator，通用事务](http://research.google.com/pubs/pub36726.html)'
- en: 'snapshot isolation: a normal transaction has one commit point (logically when
    you commit, everything happened then)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照隔离：普通事务有一个提交点（逻辑上，当您提交时，一切都发生了）
- en: 'TODO: lookup what this means, because I couldn''t write down his explanation'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待办事项：查找这意味着什么，因为我无法记下他的解释
- en: built on top of Bigtable
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立在Bigtable之上
- en: users demanded transactions, but we weren't ready to build that into bigtable
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户要求事务，但我们还没有准备好将其构建到 bigtable 中
- en: Spanner
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spanner
- en: we knew we needed
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道我们需要
- en: a database
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库
- en: SQL
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL
- en: consistent replication across data centers
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据中心之间的一致复制
- en: general purpose transactions
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用事务
- en: the rest was "merely engineering"
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的只是“纯粹的工程”
- en: TrueTime came along... (story about how they found out about a guy in NY who
    was working on distributed clocks and they realized it could be useful for their
    concurrency control)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TrueTime 出现了...（关于他们如何发现纽约有人在研究分布式时钟，他们意识到这对于他们的并发控制可能有用的故事）
- en: Globally synchronized clocks
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球同步时钟
- en: spanner behaves like a single-machine database
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spanner 的行为就像单机数据库
- en: 'consistent replication: replicas all report the same state'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致的复制：副本都报告相同的状态
- en: 'external consistency: replicas all report the same order of events'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部一致性：副本都报告相同的事件顺序
- en: nice semantics
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的语义
- en: Were we wrong with bigtable
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们对 bigtable 错了吗
- en: 'Yes, and no:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，也不是：
- en: 'yes for the long-term: didn''t know in 2003 what they knew in 2009, didn''t
    have the people or the technology'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，对于长期来说是的：2003年不知道2009年所知道的，没有人员或技术
- en: no, because lots of people use bigtable at Google
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不，因为很多人在 Google 使用 bigtable
- en: Imagine you are running a startup. What long-term issues can be postponed?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在经营一家初创公司。哪些长期问题可以推迟解决？
- en: 'Startup dilemma:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 初创公司困境：
- en: too much time spent on scalable storage => wasted effort => not done in time
    => fail
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太多时间花在可扩展存储上 => 浪费的努力 => 未能按时完成 => 失败
- en: too little time spent on scalable storage => when they get popular can't scale
    => fail
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可扩展存储上花费太少时间 => 当他们变得受欢迎时无法扩展 => 失败
- en: What do you have the skill/ability/will/vision to do?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你有能力/意愿/愿景做什么？
- en: 'we could not have built Spanner 10 years ago: or even 5 years ago'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10年前我们无法构建 Spanner：甚至5年前也不行
- en: someone told them they should build transactions in, but they didn't do it because
    they couldn't at the time
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人告诉他们应该内置事务，但他们没有这样做，因为当时他们无法做到
- en: Interesting questions
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有趣的问题
- en: Why has the Bigtable paper had arguably a bigger impact on both the research
    communities and technology communities?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 Bigtable 论文在研究界和技术界都产生了更大的影响？
- en: research vs. practice
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究与实践
- en: Why do system-researchers insist on building scalable key-value stores (and
    not databases)?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么系统研究人员坚持构建可扩展的键值存储（而不是数据库）？
- en: Lessons
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 教训
- en: Lesson 0
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第零课
- en: Timing is everything. Except luck trumps timing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 时机是一切。除非运气胜过时机。
- en: 'You can''t plan timing when the world is changing: design the best you can
    for the problems you have in front of you'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当世界正在变化时，你无法计划时机：为你面前的问题设计最好的解决方案
- en: 'TrueTime happened due to fortuitous confluence of events and people (i.e. luck).
    Same with Bigtable. Spanner''s initial design (before 2008) was nowhere near what
    Google has now: they had anti-luck until the project was restarted in 2008.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: TrueTime 的发生是由于事件和人的幸运巧合（即运气）。Bigtable 也是如此。Spanner 的初始设计（2008年之前）与 Google 现在拥有的完全不同：直到项目在2008年重新启动之前，他们一直在反运气。
- en: Lesson 1
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一课
- en: Build what you need, and don't overdesign. Don't underdesign either, because
    you'll pay for it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你需要的东西，不要设计过度。也不要设计不足，因为你会为此付出代价。
- en: Lesson 2
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二课
- en: Sometimes ignorance really is bliss. Or maybe luck.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时无知真的是福。或者可能是运气。
- en: If you have blinders on, you can't overreach. If we had known we needed a distributed
    replicated database with external consistency in 2004, we would have failed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你戴着眼罩，你就无法超越。如果我们在2004年就知道我们需要一个具有外部一致性的分布式复制数据库，我们就会失败。
- en: Lesson 3
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三课
- en: Your userbase matters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你的用户群很重要。
- en: bigtable was started when Google `< 2000` employees
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Google `< 2000`名员工时，bigtable 就开始了
- en: 'limited # of products'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限的产品数量
- en: not that many engineers
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师并不多
- en: spanner was started when Google was `10K` employees
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Google 有`10K`名员工时，spanner 就开始了
- en: more products
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的产品
- en: many more engineers, many more junior engineers, many more acquired companies
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的工程师，更多的初级工程师，更多的收购公司
- en: productivity of your employees matters
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 员工的生产力很重要
- en: Wrap up
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: You can't buy luck. You can't plan for luck. But you can't ignore luck.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法购买运气。你无法计划运气。但你不能忽视运气。
- en: 'You can increase your chances to be lucky:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以增加自己幸运的机会：
- en: have strong technical skills
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备强大的技术技能
- en: work on your design sense (find opportunities to learn!)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锻炼你的设计感（找到学习的机会！）
- en: build a strong network of colleagues and friends
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立一个强大的同事和朋友网络
- en: learn how to work on a team
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会如何在团队中工作
- en: learn what you are good at, and what you are *not* good at
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会你擅长什么，以及你*不*擅长什么
- en: be brutally honest with yourself
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对自己要毫无保留地诚实
- en: be willing to ask for help
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 愿意寻求帮助
- en: admit when you are wrong
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承认当你错了
- en: people don't like working with people that constantly tell them they are wrong
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们不喜欢与经常告诉他们错误的人合作
- en: What Spanner lacks?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spanner 缺少什么？
- en: 'Maybe disconnected access: Can we build apps that use DBs and can operate offline?'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的断开连接访问：我们能否构建可以使用数据库并能脱机运行的应用程序？
- en: '[Disconnected operation in Coda file system](https://www.cs.berkeley.edu/~brewer/cs262b/Coda-TOCS.pdf)
    work.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[Coda 文件系统中的断开操作](https://www.cs.berkeley.edu/~brewer/cs262b/Coda-TOCS.pdf)工作。'
- en: 6.824 notes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.824 笔记
- en: '[Spanner: Google''s Globally-Distributed Database](papers/spanner.pdf), Corbett
    et al, OSDI 2012'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[Spanner：谷歌的全球分布式数据库](papers/spanner.pdf)，Corbett 等人，OSDI 2012'
- en: Why this paper?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择这篇论文？
- en: modern, high performance, driven by real-world needs
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代化、高性能、受现实需求驱动
- en: sophisticated use of paxos
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paxos 的复杂使用
- en: tackles consistency + performance (will be a big theme)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决一致性 + 性能（将是一个重要主题）
- en: Lab 4 a (hugely) simplified version of Spanner
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lab 4 是 Spanner 的（极大地）简化版本
- en: What are the big ideas?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些重要的想法？
- en: shard management w/ paxos replication
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Paxos 复制的分片管理
- en: high performance despite synchronous WAN replication
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管进行同步的广域网复制，仍然保持高性能
- en: fast reads by **asking only the nearest replica**
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**仅询问最近的复制品**来快速读取
- en: consistency despite sharding (this is the real focus)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管进行分片（这是真正的重点）仍然保持一致性
- en: '**clever use of time** for consistency'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**巧妙使用时间**来保持一致性'
- en: distributed transactions
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式事务
- en: This is a dense paper! I've tried to boil down some of the ideas to simpler
    form.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一篇深奥的论文！我试图将一些想法简化成更简单的形式。
- en: Sharding
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分片
- en: 'Idea: sharding'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 思路：分片
- en: we've seen this before in FDS
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以前在 FDS 中见过这种情况
- en: the real problem is managing configuration changes
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正的问题是管理配置更改
- en: Spanner has a more convincing design for this than FDS
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spanner 对此的设计比 FDS 更有说服力
- en: 'Simplified sharding outline (lab 4):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的分片轮廓（实验 4）：
- en: replica groups, paxos-replicated
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制组，Paxos 复制
- en: paxos log in each replica group
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个复制组中都有 Paxos 日志
- en: master, paxos-replicated
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点，Paxos 复制
- en: assigns shards to groups
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分片分配给组
- en: numbered configurations
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编号配置
- en: if master moves a shard, groups eventually see new config
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主节点移动了一个分片，组最终会看到新的配置
- en: '`"start handoff Num=7"` op in both groups'' paxos logs'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个组的 Paxos 日志中都有 `"start handoff Num=7"` 操作
- en: though perhaps not at the same time
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管可能不是同时进行的
- en: '`dst` can''t finish handoff until it has copies of shard data at majority'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dst` 在获得多数派的片段数据副本之前无法完成移交'
- en: and can't wait long for possibly-dead minority
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且不能长时间等待可能失败的少数派
- en: minority must catch up, so perhaps put shard data in paxos log (!)
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 少数派必须赶上，所以也许将分片数据放入 Paxos 日志中（！）
- en: '`"end handoff Num=7"` op in both groups'' logs'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个组的日志中都有 `"end handoff Num=7"` 操作
- en: '**Q:** What if a Put is concurrent w/ handoff?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**如果一个 Put 操作与移交同时发生会怎样？'
- en: client sees new config, sends Put to new group before handoff starts?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端看到新的配置，在移交开始前将其发送到新组？
- en: client has stale view and sends it to old group after handoff?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端具有陈旧的视图，并在移交后将其发送到旧的组？
- en: arrives at either during handoff?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移交期间到达任何一个？
- en: '**Q:** What if a failure during handoff?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**如果移交期间发生故障？'
- en: e.g. old group thinks shard is handed off
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，旧的组认为分片已移交
- en: but new group fails before it thinks so
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但新组在它认为如此之前失败了
- en: '**Q:** Can *two* groups think they are serving a shard?'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** *两个* 组可以认为它们正在提供分片吗？'
- en: '**Q:** Could old group still serve shard if can''t hear master?'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**如果旧的组无法听到主节点，是否仍然可以提供分片？'
- en: '**Idea:** wide-area synchronous replication'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**思路：**广域同步复制'
- en: '*Goal:* survive single-site disasters'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标：*在单一站点灾难中生存'
- en: '*Goal:* replica near customers'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标：*靠近客户的复制品'
- en: '*Goal:* don''t lose any updates'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标：*不要丢失任何更新'
- en: Considered impractical until a few years ago
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 直到几年前都被认为是不切实际的
- en: paxos too expensive, so maybe primary/backup?
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paxos 太昂贵了，那么也许是主/备份？
- en: if primary waits for ACK from backup
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主节点等待来自备份的 ACK
- en: 50ms network will limit throughput and cause palpable delay
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50ms 网络将限制吞吐量并引起明显的延迟
- en: esp if app has to do multiple reads at 50ms each
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是如果应用程序必须在每次 50ms 进行多次读取
- en: if primary does not wait, it will reply to client before durable
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主节点不等待，它将在持久之前回复给客户端
- en: danger of split brain; can't make network reliable
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分裂脑的危险；无法使网络可靠
- en: What's changed?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么变化吗？
- en: other site may be only 5 ms away -- San Francisco / Los Angeles
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他站点可能只有 5ms 距离 - 旧金山 / 洛杉矶
- en: faster/cheaper WAN
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快/更便宜的广域网
- en: apps written to tolerate delays
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序编写以容忍延迟
- en: may make many slow read requests
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会发出许多慢速读取请求
- en: but issue them in parallel
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但并行发出
- en: maybe time out quickly and try elsewhere, or redundant gets
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能很快超时并尝试其他地方，或者冗余获取
- en: 'huge # of concurrent clients lets you get hi thruput despite high delay'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量并发客户端使您能够在延迟较高的情况下获得高吞吐量
- en: run their requests in parallel
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行他们的请求
- en: people appreciate paxos more and have streamlined variants
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们更加欣赏paxos并拥有更简化的变体
- en: fewer msgs
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较少的消息
- en: 'page 9 of paxos paper: 1 round per op w/ leader + bulk preprepare'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: paxos论文第9页：领导者每个操作1轮+大量预准备
- en: paper's scheme a little more involved b/c they must ensure there's at most one
    leader
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论文中的方案稍微复杂一些，因为他们必须确保最多只有一个领导者
- en: read at any replica
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何副本处进行读取
- en: Actual performance?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际性能？
- en: Table 3
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表3
- en: pretend just measuring paxos for writes, read at any replica for reads latency
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假装只是为了测量写入而测量paxos，读取任何副本以获取读取延迟
- en: why doesn't write latency go up w/ more replicas?
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么随着副本数量的增加，写入延迟不会增加？
- en: why does std dev of latency go down w/ more replicas?
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么随着副本数量增加，延迟的标准差会下降？
- en: r/o a *lot* faster since not a paxos agreement + use closest replica throughput
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: r/o *快*很多，因为不是paxos协议 + 使用最接近的副本吞吐量
- en: 'why does read throughput go up w/ # replicas?'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么读取吞吐量随着#副本增加而增加？
- en: why doesn't write throughput go up?
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么写入吞吐量不会增加？
- en: does write thruput seem to be going down?
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入吞吐量似乎在下降吗？
- en: what can we conclude from Table 3?
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能从表3中得出什么结论？
- en: is the system fast? slow?
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统快吗？慢吗？
- en: how fast do your paxoses run?
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的paxos运行多快？
- en: mine takes 10 ms per agreement
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的协议每个协议花费10毫秒
- en: with purely local communication and no disk
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅具有纯本地通信且无磁盘
- en: Spanner paxos might wait for disk write
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spanner paxos可能会等待磁盘写入
- en: Figure 5
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图5
- en: '`npaxos=5`, all leaders in same zone'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npaxos=5`，所有领导者在同一区域'
- en: why does killing a non-leader in each group have no effect? for killing all
    the leaders ("leader-hard")
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在每个组中杀死一个非领导者没有效果？对于杀死所有领导者（“领导者硬化”）
- en: why flat for a few seconds?
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么有几秒钟是平坦的？
- en: what causes it to start going up?
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么导致它开始上升？
- en: why does it take 5 to 10 seconds to recover?
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要5到10秒才能恢复？
- en: why is slope *higher* until it rejoins?
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么直到重新加入时斜率*更高*？
- en: Spanner reads from any paxos replica
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Spanner从任何paxos副本中读取
- en: read does *not* involve a paxos agreement
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取不涉及paxos协议
- en: just reads the data directly from replica's k/v DB
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从副本的k/v数据库中读取数据
- en: maybe 100x faster -- same room rather than cross-country
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能快100倍——在同一房间而不是跨国
- en: '**Q:** Could we *write* to just one replica?'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**我们可以只*写*到一个副本吗？'
- en: '**Q:** Is reading from any replica correct?'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**从任何副本进行读取是正确的吗？'
- en: 'Example of problem:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的例子：
- en: photo sharing site
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照片分享站点
- en: i have photos
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有照片
- en: i have an ACL (access control list) saying who can see my photos
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个ACL（访问控制列表）规定谁可以看我的照片
- en: i take my mom out of my ACL, then upload new photo
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我把我的妈妈从我的ACL中删除，然后上传新照片
- en: really it's web front ends doing these client reads/writes
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上是网络前端执行这些客户端读/写操作
- en: 'Order of events:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 事件顺序：
- en: 'W1: I write ACL on group G1 (bare majority), then'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: W1：我在G1组上（裸多数）写ACL，然后
- en: 'W2: I add image on G2 (bare majority), then'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: W2：我在G2组上添加图像（裸多数），然后
- en: mom reads image -- may get old data from lagging G2 replica
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 妈妈读取图像——可能从滞后的G2副本获取旧数据
- en: mom reads ACL -- may get new data from G1
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 妈妈读取ACL——可能从G1获取新数据
- en: This system is not acting like a single server!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统不像单个服务器那样运行！
- en: there was not really any point at which the image was
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上没有任何一个时刻图像被...
- en: present but the ACL hadn't been updated
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在，但ACL还没有更新
- en: This problem is caused by a combination of
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是由以下几个因素的组合引起的
- en: partitioning -- replica groups operate independently
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区——副本组独立运行
- en: cutting corners for performance -- read from any replica
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了性能而采取捷径——从任何副本读取
- en: How can we fix this?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么修复这个问题？
- en: Make reads see latest data
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使读取看到最新数据
- en: e.g. full paxos for reads expensive!
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，全面的paxos用于读取昂贵！
- en: Make reads see *consistent* data
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使读取看到*一致*的数据
- en: data as it existed at *some* previous point in time
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据如*某个*以前的时间点存在
- en: 'i.e. before #1, between #1 and #2, or after #2'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '即在 #1之前，#1和#2之间，或#2之后'
- en: this turns out to be much cheaper
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这事实证明更加便宜
- en: spanner does this
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spanner做到了这一点
- en: Here's a super-simplification of spanner's consistency story for r/o clients
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是spanner一致性故事的一个超级简化版本，适用于r/o客户端
- en: '"snapshot" or "lock-free" reads'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “快照”或“无锁”读取
- en: assume for now that all the clocks agree
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在假设所有时钟都一致
- en: server (paxos leader) tags each write with the time at which it occurred
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器（paxos领导者）使用写入时间标记每个写入操作
- en: k/v DB stores *multiple* values for each key,
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: k/v数据库为每个键存储*多个*值，
- en: each with a different time
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个都有不同的时间
- en: reading client picks a time `t`
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读客户选择了时间 `t`
- en: for each read
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次读取
- en: ask relevant replica to do the read at time `t`
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在时间 `t` 询问相关的副本进行读取
- en: how does a replica read a key at time `t`?
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个副本如何在时间 `t` 读取一个键？
- en: return the stored value with highest time `<= t`
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`<= t`的最高时间的存储值
- en: but wait, the replica may be behind
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是等等，副本可能落后了
- en: that is, there may be a write at time `< t`, but replica hasn't seen it
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也就是说，可能有一个时间 `< t` 的写入，但副本还没有看到
- en: so replica must somehow be sure it has seen all writes `<= t`
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以副本必须以某种方式确保它已经看到了所有的写入`<= t`
- en: 'idea: has it seen *any* operation from time `> t`?'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思路：它是否已经看到了从时间 `> t` 开始的*任何*操作？
- en: if yes, and paxos group always agrees on ops in time order, it's enough to check/wait
    for an op with time `> t`
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是的，并且 PAXOS 组总是按时间顺序达成一致意见，那么检查/等待具有时间`> t`的操作就足够了
- en: that is what spanner does on reads (4.1.3)
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是 Spanner 在读取时所做的（4.1.3）
- en: what time should a reading client pick?
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取客户端应该选择什么时间？
- en: using current time may force lagging replicas to wait
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用当前时间可能会强制滞后的副本等待
- en: so perhaps a little in the past
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以可能有一点过去的时间
- en: client may miss latest updates
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可能会错过最新的更新
- en: but at least it will see consistent snapshot
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但至少它会看到一致的快照
- en: in our example, won't see new image w/o also seeing ACL update
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的例子中，没有看到新图像也没有看到 ACL 更新
- en: How does that fix our ACL/image example?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何修复我们的 ACL/图像例子？
- en: 'W1: I write ACL, G1 assigns it time=10, then'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: W1：我在 G1 上写入 ACL，G1 将其分配时间=10，然后
- en: 'W2: I add image, G2 assigns it time=15 (> 10 since clocks agree)'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: W2：我添加图像，G2分配时间=15（> 10，因为时钟一致）
- en: mom picks a time, for example t=14
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 妈妈选了一个时间，例如 t=14
- en: mom reads ACL t=14 from lagging G1 replica
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 妈妈从滞后的 G1 副本读取 t=14 的 ACL
- en: if it hasn't seen paxos agreements up through t=14, it knows to wait so it will
    return G1
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它没有看到通过 t=14 的 PAXOS 协议，它知道要等待，以便返回 G1
- en: mom reads image from G2 at t=14
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 妈妈在 t=14 时从滞后的 G1 副本读取图像
- en: image may have been written on that replica
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像可能已经在那个副本上写入
- en: but it will know to *not* return it since image's time is 15
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是它将知道*不*返回它，因为图像的时间是15
- en: other choices of `t` work too.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`的其他选择也可以工作。'
- en: '**Q:** Is it reasonable to assume that different computers'' clocks agree?'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**假设不同计算机的时钟一致是合理的吗？'
- en: Why might they not agree?
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么他们可能不会同意？
- en: '**Q:** What may go wrong if servers'' clocks don''t agree?'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**如果服务器的时钟不一致会发生什么？'
- en: 'A performance problem: reading client may pick time in the future, forcing
    reading replicas to wait to "catch up"'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一个性能问题：读取客户端可能会选择未来的时间，迫使读取副本等待“赶上”
- en: 'A correctness problem:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确性问题：
- en: again, the ACL/image example
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，ACL/图像的例子
- en: G1 and G2 disagree about what time it is
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1 和 G2 对于时间的看法不一致
- en: 'Sequence of events:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列：
- en: 'W1: I write ACL on G1 -- stamped with time=15'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: W1：我在 G1 上写入 ACL -- 时间戳为 15
- en: 'W2: I add image on G2 -- stamped with time=10'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: W2：我在 G2 上添加了图像 -- 时间戳为 10
- en: Now a client read at t=14 will see image but not ACL update
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端在 t=14 时读取将看到图像但不会看到 ACL 更新
- en: '**Q:** Why doesn''t spanner just ensure that the clocks are all correct?'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**为什么 Spanner 不直接确保所有时钟都正确？'
- en: after all, it has all those master GPS / atomic clocks
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毕竟，它拥有所有那些主 GPS / 原子钟
- en: TrueTime (section 3)
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TrueTime（第3节）
- en: there is an actual "absolute" time `t_abs`
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上存在一个"绝对"时间`t_abs`
- en: but server clocks are typically off by some unknown amount
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是服务器时钟通常偏移一些未知的量
- en: TrueTime can bound the error
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TrueTime 可以限制错误
- en: 'so `now()` yields an interval: [earliest,latest]'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以`now()`产生一个区间：[最早，最晚]
- en: earliest and latest are ordinary scalar times
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最早和最晚是普通的标量时间
- en: perhaps microseconds since Jan 1 1970
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是自1970年1月1日以来的微秒
- en: '`t_abs` is highly likely to be between earliest and latest'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t_abs`高度可能在最早和最晚之间'
- en: '**Q:** How does TrueTime choose the interval?'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**TrueTime如何选择时间间隔？'
- en: '**Q:** Why are GPS time receivers able to avoid this problem?'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：**为什么 GPS 时间接收器能够避免这个问题？'
- en: Do they actually avoid it?
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们实际上是否会避免这种问题？
- en: What about the "atomic clocks"?
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"原子钟"呢？'
- en: Spanner assigns each write a scalar time
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Spanner 为每个写入分配一个标量时间
- en: might not be the actual absolute time
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不是实际的绝对时间
- en: but is chosen to ensure consistency
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是选择的是确保一致性
- en: 'The danger:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 危险：
- en: W1 at G1, G1's interval is [20,30]
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W1 在 G1，G1的区间是 [20,30]
- en: is any time in that interval OK?
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那个区间的任何时间都可以吗？
- en: then W2 at G2, G2's interval is [11,21]
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 W2 在 G2，G2的区间是[11,21]
- en: is any time in that interval OK?
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那个区间的任何时间都可以吗？
- en: if they are not careful, might get s1=25 s2=15
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们不小心，可能会得到 s1=25 s2=15
- en: 'So what we want is:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们想要的是：
- en: if W2 starts after W1 finishes, then `s2 > s1`
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 W2 在 W1 结束后开始，则`s2 > s1`
- en: simplified *"external consistency invariant"* from 4.1.2
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从4.1.2简化的*"外部一致性不变式"*
- en: causes snapshot reads to see data consistent w/ true order of W1, W2
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致快照读取看到与 W1、W2 的真实顺序一致的数据
- en: How does spanner assign times to writes?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Spanner 如何为写入分配时间？
- en: (again, this is much simplified, see 4.1.2)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （同样，这是大大简化的，参见4.1.2）
- en: a write request arrives at paxos leader
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入请求到达 PAXOS 领导者
- en: '`s` will be the write''s time-stamp'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`将是写入的时间戳。'
- en: leader sets `s` to `TrueTime now().latest`
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领导者将`s`设置为`TrueTime now().latest`。
- en: this is "Start" in 4.1.2
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是4.1.2中的“开始”。
- en: then leader *delays* until `s < now().earliest`
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后领导者*延迟*直到`s < now().earliest`。
- en: i.e. until `s` is guaranteed to be in the past (compared to absolute time)
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即直到`s`被保证在过去（与绝对时间相比）。
- en: this is "commit wait" in 4.1.2
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是4.1.2中的“提交等待”。
- en: then leader runs paxos to cause the write to happen
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后领导者运行 Paxos 以导致写入发生。
- en: then leader replies to client
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后领导者回复客户端。
- en: Does this work for our example?
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们的例子有效吗？
- en: W1 at G1, TrueTime says [20,30]
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1处的W1，TrueTime 说[20,30]。
- en: '`s1 = 30`'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s1 = 30`。'
- en: commit wait until TrueTime says [31,41]
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待提交直到TrueTime 说[31,41]。
- en: reply to client
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回复客户端。
- en: W2 at G2, TrueTime *must* now say `>= [21,31]`
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G2处的W2，TrueTime *现在必须*说`>= [21,31]`。
- en: (otherwise TrueTime is broken)
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （否则TrueTime就会出问题）。
- en: s2 = 31
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: s2 = 31。
- en: commit wait until TrueTime says [32,43]
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待提交直到TrueTime 说[32,43]。
- en: reply to client
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回复客户端。
- en: 'it does work for this example:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对这个例子有效。
- en: the client observed that W1 finished before S2 started,
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端观察到W1在S2开始之前完成，
- en: and indeed `s2 > s1`
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而且`s2 > s1`。
- en: even though G2's TrueTime clock was slow by the most it could be
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使 G2 的 TrueTime 时钟慢了最多可能的时间。
- en: so if my mom sees S2, she is guaranteed to also see W1
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以如果我妈妈看到S2，她也保证会看到W1。
- en: Why the "Start" rule?
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么“开始”规则？
- en: i.e. why choose the time at the end of the TrueTime interval?
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即为什么选择TrueTime间隔的结束时间？
- en: previous writers waited only until their timestamps were barely `< t_abs`
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先前的写入者只等到他们的时间戳刚好`< t_abs`。
- en: new writer must choose `s` greater than any completed write
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的写入者必须选择`s`大于任何已完成写入。
- en: '`t_abs` might be as high as `now().latest`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t_abs`可能高达`now().latest`。'
- en: so s = now().latest
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以`s = now().latest`。
- en: Why the "Commit Wait" rule?
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么“提交等待”规则？
- en: ensures that `s < t_abs`
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保`s < t_abs`。
- en: otherwise write might complete with an s in the future
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则写入可能会在未来完成。
- en: and would let Start rule give too low an `s` to a subsequent write
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且会让“开始”规则给后续写入的`s`太低。
- en: '**Q:** Why commit *wait*; why not immediately write value with chosen time?'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q:** 为什么提交*等待*；为什么不立即使用选择的时间写入值？'
- en: indirectly forces subsequent write to have high enough s
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间接地迫使后续写入具有足够高的`s`。
- en: the system has no other way to communicate minimum acceptable next s for writes
    in different replica groups
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统没有其他方式来通信不同副本组中写入的下一个最小可接受的`s`。
- en: waiting forces writes that some external agent is serializing to have monotonically
    increasing timestamps
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待迫使一些外部代理正在串行化的写入具有单调递增的时间戳。
- en: w/o wait, our example goes back to s1=30 s2=21
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有等待，我们的例子回到了s1=30 s2=21。
- en: you could imagine explicit schemes to communicate last write's TS to the next
    write
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象明确的方案来将上次写入的TS传达给下一个写入。
- en: '**Q:** How long is the commit wait?'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q:** 提交等待多长时间？'
- en: 'This answers today''s Question: a large TrueTime uncertainty requires a long
    commit wait so Spanner authors are interested in accurate low-uncertainty time'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这回答了今天的问题：大的TrueTime不确定性需要长时间的提交等待，因此Spanner的作者对准确的低不确定性时间感兴趣。
- en: Let's step back
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步。
- en: why did we get into all this timestamp stuff?
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么要涉及所有这些时间戳的东西？
- en: our replicas were 100s or 1000s of miles apart (for locality/fault tol)
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的副本相距100英里或1000英里（为了本地性/容错）。
- en: we wanted fast reads from a local replica (no full paxos)
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要从本地副本进行快速读取（无需完整的 Paxos）。
- en: our data was partitioned over many replica groups w/ separate clocks
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的数据分布在许多具有独立时钟的副本组上。
- en: 'we wanted consistency for reads:'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要读取的一致性：
- en: if W1 then W2, reads don't see W2 but not W1
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 W1 然后 W2，读取不会看到 W2 但不看到 W1。
- en: it's complex but it makes sense as a
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很复杂，但作为一个整体是有道理的。
- en: high-performance evolution of Lab 3 / Lab 4
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lab 3 / Lab 4的高性能演变。
- en: Why is this timestamp technique interesting?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个时间戳技术很有趣？
- en: we want to enforce order -- things that happened in some order in real time
    are ordered the same way by the distributed system -- "external consistency"
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要强制顺序--在实时发生的事情以某种顺序被分布式系统排序--“外部一致性”。
- en: the naive approach requires a central agent, or lots of communication
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幼稚的方法需要一个中央代理，或大量的通信。
- en: Spanner does the synchronization implicitly via time
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spanner通过时间隐式地进行同步。
- en: time can be a form of communication
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间可以是一种通信形式。
- en: e.g. we agree in advance to meet for dinner at 6:00pm
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，我们预先同意在晚上6:00见面吃晚餐。
- en: There's a lot of additional complexity in the paper
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 论文中有很多额外的复杂性。
- en: transactions, two phase commit, two phase locking,
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务，两阶段提交，两阶段锁定，
- en: schema change, query language, &c
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式更改，查询语言，等等。
- en: some of this we'll see more of later
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些我们以后会看到更多的东西。
- en: in particular, the problem of ordering events in a distributed system will come
    up a lot, soon
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是，在分布式系统中，事件排序的问题很快就会经常出现。
