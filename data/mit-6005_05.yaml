- en: 'Reading 5: Version Control'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 5：版本控制
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 免受错误影响 | 易于理解 | 为变化做好准备 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确且未来未知时也正确。 | 与未来的程序员清晰沟通，包括未来的自己。 | 设计以适应变化而无需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: Know what version control is and why we use it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解版本控制是什么以及为什么我们使用它
- en: Understand how Git stores version history as a graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Git 如何将版本历史存储为图形
- en: Practice reading, creating, and using version history
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习阅读、创建和使用版本历史
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: '[Version control systems](http://en.wikipedia.org/wiki/Revision_control) are
    essential tools of the software engineering world. More or less every project
    — serious or hobby, open source or proprietary — uses version control. Without
    version control, coordinating a team of programmers all editing the same project’s
    code will reach pull-out-your-hair levels of aggravation.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[版本控制系统](http://en.wikipedia.org/wiki/Revision_control) 是软件工程世界中必不可少的工具。几乎每个项目
    — 无论是严肃的还是业余的，开源的还是专有的 — 都使用版本控制。没有版本控制，协调一组程序员同时编辑同一项目代码将达到让人抓狂的程度。'
- en: Version control systems you’ve already used
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你已经使用过的版本控制系统
- en: Dropbox
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dropbox
- en: '[Undo/redo buffer](http://en.wikipedia.org/wiki/Undo)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[撤销/重做缓冲区](http://en.wikipedia.org/wiki/Undo)'
- en: Keeping multiple copies of files with version numbers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留带有版本号的多个文件副本
- en: '| ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    |'
- en: '| Project Report | Project Report v2 | Project Report v3 | Project Report final
    | Project Report final-v2 | Project Report final-v2-fix-part-5 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 项目报告 | 项目报告 v2 | 项目报告 v3 | 项目报告 最终版 | 项目报告 最终版-v2 | 项目报告 最终版-v2-修复部分5 |'
- en: Inventing version control
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发明版本控制
- en: Suppose [Alice](http://en.wikipedia.org/wiki/Alice_and_Bob) is working on a
    problem set by herself.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 [爱丽丝](http://en.wikipedia.org/wiki/Alice_and_Bob) 正在独自解决一个问题。
- en: '|   Alice | Version 1  Hello.java |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|   爱丽丝 | 版本 1  你好.java |'
- en: She starts with one file `Hello.java` in her pset, which she works on for several
    days.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 她从她的作业中的一个文件 `你好.java` 开始，她在上面工作了几天。
- en: At the last minute before she needs to hand in her pset to be graded, she realizes
    she has made a change that breaks everything. If only she could go back in time
    and retrieve a past version!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在她需要交作业给老师评分的最后一刻，她意识到自己做出的更改导致一切都错了。要是她能回到过去并检索以前的版本就好了！
- en: A simple discipline of saving backup files would get the job done.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的保存备份文件的纪律就能完成任务。
- en: '|   Alice | Version 1  Hello.1.java | Version 2  Hello.2.java | Version 3  Hello.java
    |  HEAD |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|   爱丽丝 | 版本 1  你好.1.java | 版本 2  你好.2.java | 版本 3  你好.java |  主分支 |'
- en: Alice uses her judgment to decide when she has reached some milestone that justifies
    saving the code. She saves the versions of `Hello.java` as `Hello.1.java`, `Hello.2.java`,
    and `Hello.java`. She follows the convention that the most recent version is just
    `Hello.java` to avoid confusing Eclipse. We will call the most recent version
    the *head*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝根据自己的判断力决定何时达到了值得保存代码的里程碑。她将 `你好.java` 的版本保存为 `你好.1.java`，`你好.2.java` 和 `你好.java`。她遵循最近版本就是
    `你好.java` 的约定，以避免混淆 Eclipse。我们将最近版本称为 *主分支*。
- en: Now when Alice realizes that version 3 is fatally flawed, she can just copy
    version 2 back into the location for her current code. Disaster averted! But what
    if version 3 included some changes that were good and some that were bad? Alice
    can compare the files manually to find the changes, and sort them into good and
    bad changes. Then she can copy the good changes into version 2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当爱丽丝意识到版本 3 有致命缺陷时，她只需将版本 2 复制回当前代码的位置。灾难避免了！但如果版本 3 包含一些好的和一些坏的更改怎么办？爱丽丝可以手动比较文件以找到更改，并将其分类为好的和坏的更改。然后她可以将好的更改复制到版本
    2 中。
- en: This is a lot of work, and it’s easy for the human eye to miss changes. Luckily,
    there are standard software tools for comparing text; in the UNIX world, one such
    tool is [`diff`](http://en.wikipedia.org/wiki/Diff). A better version control
    system will make diffs easy to generate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多工作，而且人眼很容易忽略变化。幸运的是，有标准的软件工具用于比较文本；在UNIX世界中，其中一个工具是[`diff`](http://en.wikipedia.org/wiki/Diff)。一个更好的版本控制系统将使生成差异变得容易。
- en: '|   Cloud | Version 1  Hello.1.java | Version 2  Hello.2.java | Version 3  Hello.java
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|   云 | 版本 1  Hello.1.java | 版本 2  Hello.2.java | 版本 3  Hello.java |'
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|   Alice | Version 1  Hello.1.java | Version 2  Hello.2.java | Version 3  Hello.java
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|   艾丽丝 | 版本 1  Hello.1.java | 版本 2  Hello.2.java | 版本 3  Hello.java |'
- en: Alice also wants to be prepared in case her laptop gets run over by a bus, so
    she saves a backup of her work in the cloud, uploading the contents of her working
    directory whenever she’s satisfied with its contents.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 艾丽丝还想要做好准备，以防她的笔记本电脑被公交车碾过，所以她在云端保存了她的工作备份，在她对其内容满意时上传她的工作目录的内容。
- en: If her laptop is kicked into the Charles, Alice can retrieve the backup and
    resume work on the pset on a fresh machine, retaining the ability to time-travel
    back to old versions at will.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果她的笔记本电脑被丢进了查尔斯河，艾丽丝可以检索备份，并在一台新机器上恢复作业，保留随时返回旧版本的能力。
- en: Furthermore, she can develop her pset on multiple machines, using the cloud
    provider as a common interchange point. Alice makes some changes on her laptop
    and uploads them to the cloud. Then she downloads onto her desktop machine at
    home, does some more work, and uploads the improved code (complete with old file
    versions) back to the cloud.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，她可以在多台机器上开发她的作业，使用云服务提供商作为公共交换点。艾丽丝在她的笔记本电脑上做了一些更改，并将它们上传到云端。然后她在家里的台式机上下载，做了更多的工作，并将改进的代码（包括旧文件版本）上传回云端。
- en: '|  |  Cloud |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |  云 |'
- en: '|  |    |  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  |    |  |'
- en: '| Version 5L  Hello.java |  Alice on laptop |  |  Alice on desktop | Version
    5D  Hello.java |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 版本 5L  Hello.java |  艾丽丝在笔记本电脑上 |  |  艾丽丝在台式机上 | 版本 5D  Hello.java |'
- en: If Alice isn’t careful, though, she can run into trouble with this approach.
    Imagine that she starts editing `Hello.java` to create “version 5” on her laptop.
    Then she gets distracted and forgets about her changes. Later, she starts working
    on a new “version 5” on her desktop machine, including *different* improvements.
    We’ll call these versions “5L” and “5D,” for “laptop” and “desktop.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果艾丽丝不小心，她可能会遇到麻烦。想象一下，她开始在她的笔记本电脑上编辑`Hello.java`以创建“版本 5”。然后她分心了，忘记了她的改变。后来，她开始在她的台式机上工作一个新的“版本
    5”，包括*不同的*改进。我们将这些版本称为“5L”和“5D”，分别代表“笔记本电脑”和“台式机”。
- en: When it comes time to upload changes to the cloud, there is an opportunity for
    a mishap! Alice might copy all her local files into the cloud, causing it to contain
    version 5D only. Later Alice syncs from the cloud to her laptop, potentially overwriting
    version 5L, losing the worthwhile changes. What Alice really wants here is a *merge*,
    to create a new version based on the two version 5’s.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当到了上传变更到云端的时候，就有可能出现问题！艾丽丝可能会将她所有的本地文件复制到云端，导致其中只包含版本 5D。后来，艾丽丝从云端同步到她的笔记本电脑，潜在地覆盖版本
    5L，丢失了有价值的更改。艾丽丝真正想要的是一个*合并*，以基于两个版本 5 创建一个新版本。
- en: 'At this point, considering just the scenario of one programmer working alone,
    we already have a list of operations that should be supported by a version control
    scheme:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，仅考虑一个程序员独自工作的情况，我们已经有了一个应该由版本控制方案支持的操作列表：
- en: '*reverting* to a past version'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*恢复*到以前的版本'
- en: '*comparing* two different versions'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*比较*两个不同版本'
- en: '*pushing* full version history to another location'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推送*完整版本历史到另一个位置'
- en: '*pulling* history back from that location'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从那个位置*拉取历史'
- en: '*merging* versions that are offshoots of the same earlier version'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合并*来自同一早期版本的分支的版本'
- en: Multiple developers
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个开发者
- en: Now let’s add into the picture Bob, another developer. The picture isn’t too
    different from what we were just thinking about.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把鲍勃也加入到图片中，另一个开发者。这个情况与我们刚刚考虑的情况并没有太大不同。
- en: '|  |  Cloud |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |  云 |'
- en: '|  |    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  |    |'
- en: '| Version 5A  Hello.java | Version 5A  Greet.java |   Alice |  |   Bob | Version
    5B  Hello.java | Version 5B  Greet.java |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 版本 5A  Hello.java | 版本 5A  Greet.java |   艾丽丝 |  |   鲍勃 | 版本 5B  Hello.java
    | 版本 5B  Greet.java |'
- en: Alice and Bob here are like the two Alices working on different computers. They
    no longer share a brain, which makes it even more important to follow a strict
    discipline in pushing to and pulling from the shared cloud server. The two programmers
    must coordinate on a scheme for coming up with version numbers. Ideally, the scheme
    allows us to assign clear names to *whole sets of files*, not just individual
    files. (Files depend on other files, so thinking about them in isolation allows
    inconsistencies.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的Alice和Bob就像在不同计算机上工作的两个Alices。他们不再共享一个大脑，这使得在向共享云服务器推送和拉取时遵循严格的纪律变得更加重要。这两位程序员必须协调一个用于生成版本号的方案。理想情况下，该方案允许我们为*整套文件*分配清晰的名称，而不仅仅是单个文件。
    （文件依赖于其他文件，因此孤立地考虑它们可能会导致不一致。）
- en: Merely uploading new source files is not a very good way to communicate to others
    the high-level idea of a set of changes. So let’s add a log that records for each
    version *who* wrote it, *when* it was finalized, and *what* the changes were,
    in the form of a short human-authored message.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅上传新的源文件并不是向他人传达一组变更的高层想法的好方法。因此，让我们添加一个记录每个版本*谁*编写的，*何时*完成的，以及*哪些*变更的日志，以简短的人工编写消息的形式。
- en: '|  |  Cloud |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|  |  云 |'
- en: '|  |    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |    |'
- en: '| Log: 1: Alice, 7pm, ...'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '| 日志: 1: Alice, 晚上7点, ...'
- en: '...'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '4: Bob, 8pm, ...'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '4: Bob, 晚上8点, ...'
- en: '5A: Alice, 9pm, ... | Ver. 5A  Hello.java | Ver. 5A  Greet.java |   Alice |  |   Bob
    | Ver. 5B  Hello.java | Ver. 5B  Greet.java | Log: 1: Alice, 7pm, ...'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '5A: Alice, 晚上9点, ... | Ver. 5A  Hello.java | Ver. 5A  Greet.java |   Alice
    |  |   Bob | Ver. 5B  Hello.java | Ver. 5B  Greet.java | 日志: 1: Alice, 晚上7点, ...'
- en: '...'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '4: Bob, 8pm, ...'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '4: Bob, 晚上8点, ...'
- en: '5B: Bob, 9pm, ... |'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '5B: Bob, 晚上9点, ... |'
- en: 'Pushing another version now gets a bit more complicated, as we need to merge
    the logs. This is easier to do than for Java files, since logs have a simpler
    structure – but without tool support, Alice and Bob will need to do it manually!
    We also want to enforce consistency between the logs and the actual sets of available
    files: for each log entry, it should be easy to extract the complete set of files
    that were current at the time the entry was made.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在推送另一个版本变得有点复杂，因为我们需要合并日志。这比Java文件更容易做，因为日志具有更简单的结构 - 但是没有工具支持，Alice和Bob将需要手动完成！我们还希望在日志和实际可用文件集之间强制保持一致性：对于每个日志条目，应该很容易提取在该条目制作时当前的完整文件集。
- en: 'But with logs, all sorts of useful operations are enabled. We can look at the
    log for just a particular file: a view of the log restricted to those changes
    that involved modifying some file. We can also use the log to figure out which
    change contributed each line of code, or, even better, which person contributed
    each line, so we know who to complain to when the code doesn’t work. This sort
    of operation would be tedious to do manually; the automated operation in version
    control systems is called *annotate* (or, unfortunately, *blame*).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有了日志，就可以实现各种有用的操作。我们可以查看特定文件的日志：限制为涉及修改某些文件的更改的日志视图。我们还可以使用日志来确定每行代码的贡献者，甚至更好的是，确定每行代码的贡献者，这样当代码不起作用时我们就知道要向谁抱怨。这种操作手动执行将会很繁琐；版本控制系统中的自动操作称为*annotate*（或者不幸地称为*blame*）。
- en: Multiple branches
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个分支
- en: It sometimes makes sense for a subset of the developers to go off and work on
    a *branch*, a parallel code universe for, say, experimenting with a new feature.
    The other developers don’t want to pull in the new feature until it is done, even
    if several coordinated versions are created in the meantime. Even a single developer
    can find it useful to create a branch, for the same reasons that Alice was originally
    using the cloud server despite working alone.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员的子集来说，有时候他们会分支出去工作，即一个并行的代码宇宙，用于尝试新功能。其他开发人员不希望在新功能完成之前拉取新功能，即使在此期间创建了几个协调的版本。即使是单个开发人员也可能会发现创建分支很有用，原因与最初使用云服务器的Alice相同。
- en: In general, it will be useful to have many shared places for exchanging project
    state. There may be multiple branch locations at once, each shared by several
    programmers. With the right set-up, any programmer can pull from or push to any
    location, creating serious flexibility in cooperation patterns.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有许多共享位置用于交换项目状态将是有用的。可能会有多个分支位置同时存在，每个位置由几位程序员共享。通过正确的设置，任何程序员都可以从任何位置拉取或推送，从而在合作模式中创造出严肃的灵活性。
- en: The shocking conclusion
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 令人震惊的结论
- en: 'Of course, it turns out we haven’t invented anything here: [Git](http://git-scm.com)
    does all these things for you, and so do many other version control systems.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，事实证明我们在这里并没有发明任何东西：[Git](http://git-scm.com)为您完成所有这些工作，许多其他版本控制系统也是如此。
- en: Distributed vs. centralized
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式与集中式
- en: '| Dan |  | Carol |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 丹 |  | 卡罗尔 |'
- en: '|   |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: '| Cloud |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 云 |'
- en: '|   |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: '| Alice |  | Bob |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 |  | 鲍勃 |'
- en: Traditional *centralized* version control systems like CVS and [Subversion](http://subversion.apache.org/)
    do a subset of the things we’ve imagined above. They support a collaboration graph
    – who’s sharing what changes with whom – with one master server and copies that
    only communicate with the master.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 像CVS和[Subversion](http://subversion.apache.org/)这样的传统*集中式*版本控制系统只做了我们上面想象的一部分。它们支持协作图谱
    - 谁与谁共享了什么变化 - 有一个主服务器和只与主服务器通信的副本。
- en: In a centralized system, everyone must share their work to and from the master
    repository. Changes are safely stored *in version control* if they are *in the
    master repository*, because that’s the only repository.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式系统中，每个人都必须与主仓库进行工作共享。如果更改存储在*版本控制*中，那么它们就是*在主仓库*中安全存储的，因为那是唯一的仓库。
- en: '| Dan |    | Carol |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 丹 |    | 卡罗尔 |'
- en: '|     |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|     |'
- en: '| Cloud |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 云 |'
- en: '|   |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: '| Alice |    | Bob |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 |    | 鲍勃 |'
- en: In contrast, *distributed* version control systems like [Git](http://git-scm.com)
    and [Mercurial](https://mercurial.selenic.com) allow all sorts of different collaboration
    graphs, where teams and subsets of teams can experiment easily with alternate
    versions of code and history, merging versions together as they are determined
    to be good ideas.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，像[Git](http://git-scm.com)和[Mercurial](https://mercurial.selenic.com)这样的*分布式*版本控制系统允许各种不同的协作图谱，团队和团队的子集可以轻松尝试代码和历史的替代版本，并在确定是个好主意时将版本合并在一起。
- en: In a distributed system, all repositories are created equal, and it’s up to
    users to assign them different roles. Different users might share their work to
    and from different repos, and the team must decide what it means for a change
    to be *in version control*. If the change is stored in just a single programmer’s
    repo, do they still need to share it with a designated collaborator or specific
    server before the rest of the team considers it official?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，所有仓库都是平等创建的，用户可以为它们分配不同的角色。不同的用户可能与不同的仓库共享工作，并且团队必须决定什么样的更改才算是*在版本控制中*。如果更改仅存储在单个程序员的仓库中，他们是否仍然需要与指定的合作者或特定服务器共享它，以便团队的其他成员将其视为官方更改？
- en: reading exercises
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: More equal(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更加平等(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Version control terminology
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制术语
- en: '**Repository**: a local or remote store of the versions in our project'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：我们项目中版本的本地或远程存储'
- en: '**Working copy**: a local, editable copy of our project that we can work on'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作副本**：我们可以在其上进行工作的本地可编辑副本项目'
- en: '**File**: a single file in our project'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**：我们项目中的单个文件'
- en: '**Version** or **revision**: a record of the contents of our project at a point
    in time'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**或**修订**：项目内容在某个时间点的记录'
- en: '**Change** or **diff**: the difference between two versions'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更**或**差异**：两个版本之间的差异'
- en: '**Head**: the current version'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头**：当前版本'
- en: Features of a version control system
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制系统的特点
- en: '**Reliable**: keep versions around for as long as we need them; allow backups'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：在我们需要的时间内保留版本；允许备份'
- en: '**Multiple files**: track versions of a project, not single files'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个文件**：跟踪项目的版本，而不是单个文件'
- en: '**Meaningful versions**: what were the changes, why were they made?'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有意义的版本**：有何更改，为何进行更改？'
- en: '**Revert**: restore old versions, in whole or in part'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复**：恢复旧版本，全部或部分'
- en: '**Compare versions**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较版本**'
- en: '**Review history**: for the whole project or individual files'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看历史记录**：针对整个项目或个别文件'
- en: '**Not just for code**: prose, images, …'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不仅仅用于代码**：散文，图片，...'
- en: 'It should **allow multiple people to work together**:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该**允许多人一起工作**：
- en: '**Merge**: combine versions that diverged from a common previous version'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合并**：合并自共同之前版本分叉出的版本'
- en: '**Track responsibility**: who made that change, who touched that line of code?'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪责任**：谁做出了那个更改，谁碰了那行代码？'
- en: '**Work in parallel**: allow one programmer to work on their own for a while
    (without giving up version control)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行工作**：允许一个程序员一段时间内独立工作（不放弃版本控制）'
- en: '**Work-in-progress**: allow multiple programmers to share unfinished work (without
    disrupting others, without giving up version control)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作进行中**：允许多个程序员共享未完成的工作（不会干扰其他人，也不会放弃版本控制）'
- en: Git
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git
- en: '![](../Images/87b570f0480736496827cc0b40c857e7.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/87b570f0480736496827cc0b40c857e7.jpg)'
- en: The version control system we’ll use in 6.005 is [Git](http://git-scm.com).
    It’s powerful and worth learning. But Git’s user interface can be terribly frustrating.
    What is Git’s user interface?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在6.005中将使用的版本控制系统是[Git](http://git-scm.com)。它很强大，值得学习。但Git的用户界面可能会让人非常沮丧。Git的用户界面是什么？
- en: '**In 6.005, we will use Git on the command line.** The command line is a fact
    of life, ubiquitous because it is so powerful.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在6.005中，我们将在命令行上使用Git。**命令行是生活中的一个事实，因为它非常强大。'
- en: The command line can make it very difficult to see what is going on in your
    repositories. You may find [SourceTree](http://www.sourcetreeapp.com) (shown on
    the right) for Mac & Windows useful. On any platform, [gitk](http://git-scm.com/docs/gitk)
    can give you a basic Git GUI. Ask Google for other suggestions.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行可能会使您很难看到存储库中发生的情况。你可能会发现[SourceTree](http://www.sourcetreeapp.com)（右侧显示）对Mac和Windows很有用。在任何平台上，[gitk](http://git-scm.com/docs/gitk)可以为您提供基本的Git
    GUI。询问Google获取其他建议。
- en: 'An important note about tools for Git:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Git工具的重要说明：
- en: Eclipse has built-in support for Git. If you follow the [problem set instructions](../../psets/ps0/),
    Eclipse will know your project is in Git and will show you helpful icons. We do
    not recommend using the Eclipse Git UI to make changes, commit, etc., and course
    staff may not be able to help you with problems.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse内置支持Git。如果你按照[问题集说明](../../psets/ps0/)操作，Eclipse将知道你的项目在Git中，并会显示有用的图标��我们不建议使用Eclipse
    Git UI进行更改、提交等操作，课程工作人员可能无法帮助您解决问题。
- en: '[GitHub](http://github.com/) makes desktop apps for Mac and Windows. Because
    the GitHub app changes how some Git operations work, if you use the GitHub app,
    course staff will not be able to help you.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub](http://github.com/)为Mac和Windows制作了桌面应用程序。由于GitHub应用程序改变了一些Git操作的工作方式，如果你使用GitHub应用程序，课程工作人员将无法帮助你。'
- en: Getting started with Git
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用Git
- en: 'On the [Git](http://git-scm.com) website, you can find two particularly useful
    resources:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Git](http://git-scm.com)网站上，你可以找到两个特别有用的资源：
- en: '[*Pro Git*](http://git-scm.com/book) documents everything you might need to
    know about Git.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*Pro Git*](http://git-scm.com/book)记录了关于Git的所有你可能需要了解的内容。'
- en: The [Git command reference](http://git-scm.com/docs) can help with the syntax
    of Git commands.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Git命令参考](http://git-scm.com/docs)可以帮助理解Git命令的语法。'
- en: You’ve already completed **[PS0](../../psets/ps0/#clone)** and the **[Getting
    Started intro to Git](../../getting-started/#git)**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了**[PS0](../../psets/ps0/#clone)**和**[入门Git介绍](../../getting-started/#git)**。
- en: The Git object graph
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git对象图
- en: 'Read: [*Pro Git* 1.3: Git Basics](http://git-scm.com/book/en/v2/Getting-Started-Git-Basics)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '阅读：[*Pro Git* 1.3: Git Basics](http://git-scm.com/book/en/v2/Getting-Started-Git-Basics)'
- en: 'That reading introduces the three pieces of a Git repo: `.git` directory, working
    directory, and staging area.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该阅读介绍了Git存储库的三个部分：`.git`目录、工作目录和暂存区。
- en: 'All of the operations we do with Git — clone, add, commit, push, log, merge,
    … — are operations on a graph data structure that stores all of the versions of
    files in our project, and all the log entries describing those changes. The **Git
    object graph** is stored in the `.git` directory of your local repository. Another
    copy of the graph, e.g. for PS0, is on Athena in:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Git进行的所有操作——克隆、添加、提交、推送、日志、合并等——都是对存储项目中所有文件版本和描述这些更改的所有日志条目的图形数据结构的操作。**Git对象图**存储在本地存储库的`.git`目录中。例如，PS0的图形的另一个副本存储在Athena中：
- en: '`/mit/6.005/git/fa16/psets/ps0/[your username].git`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`/mit/6.005/git/fa16/psets/ps0/[your username].git`'
- en: Copy an object graph with `git clone`
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`git clone`复制对象图
- en: How do you get the object graph from Athena to your local machine in order to
    start working on the problem set? **`git clone`** copies the graph.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将Athena上的对象图复制到本地计算机以开始解决问题集？**`git clone`**复制图形。
- en: 'Suppose your username is `bitdiddle`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的用户名是`bitdiddle`：
- en: '`git clone ssh://.../psets/ps0/bitdiddle.git ps0`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone ssh://.../psets/ps0/bitdiddle.git ps0`'
- en: 'Hover or tap on each step to update the diagram below:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停或点击每个步骤以更新下面的图表：
- en: Create an empty local directory `ps0`, and `ps0/.git`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的本地目录`ps0`和`ps0/.git`。
- en: Copy the object graph from `ssh://.../psets/ps0/bitdiddle.git` into `ps0/.git`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象图从`ssh://.../psets/ps0/bitdiddle.git`复制到`ps0/.git`。
- en: '**Check out** the current version of the **`master` branch**.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查看**当前版本的**`master`分支**。'
- en: 'Diagram for highlighted step:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示步骤的图表：
- en: '![](../Images/b678e7e1dea8e326dbd0cc06be9f1df8.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b678e7e1dea8e326dbd0cc06be9f1df8.jpg)'
- en: 'We still haven’t explained what’s in the object graph. But before we do that,
    let’s understand step 3 of `git clone`: check out the current version of the `master`
    branch.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有解释对象图中有什么。但在我们这样做之前，让我们了解一下`git clone`的第三步：检出`master`分支的当前版本。
- en: The object graph is stored on disk in a convenient and efficient structure for
    performing Git operations, but not in a format we can easily use. In [Alice’s
    invented version control scheme](#inventing_version_control), the current version
    of `Hello.java` was just called `Hello.java` because she needed to be able to
    edit it normally. In Git, we obtain normal copies of our files by *checking them
    out* from the object graph. These are the files we see and edit in Eclipse.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对象图以方便且高效的结构存储在磁盘上，用于执行 Git 操作，但不是我们可以轻松使用的格式。在[爱丽丝发明的版本控制方案](#inventing_version_control)中，`Hello.java`的当前版本只是称为`Hello.java`，因为她需要能够正常编辑它。在
    Git 中，我们通过*检出*它们从对象图中获取我们文件的正常副本。这些是我们在 Eclipse 中看到和编辑的文件。
- en: We also decided above that it might be useful to support [multiple *branches*
    in the version history](#multiple_branches). Multiple branches are essential for
    large teams working on long-term projects. To keep things simple in 6.005, we
    will not use branches and we don’t recommend that you create any. Every Git repo
    comes with a default branch called `master`, and all of our work will be on the
    `master` branch.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还决定可能支持[版本历史中的多个*分支*](#multiple_branches)可能很有用。对于长期项目的大团队来说，多个分支是必不可少的。为了在6.005中保持简单，我们不会使用分支，也不建议你创建任何分支。每个
    Git 仓库都带有一个名为`master`的默认分支，我们所有的工作都将在`master`分支上进行。
- en: So step 2 of `git clone` gets us an object graph, and step 3 gets us a **working
    directory** full of files we can edit, starting from the current version of the
    project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone` 的第二步给我们一个对象图，第三步给我们一个充满文件的**工作目录**，我们可以从项目的当前版本开始进行编辑。'
- en: Let’s finally dive into that object graph!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最终深入研究一下对象图！
- en: 'Clone an example repo: **`https://github.com/mit6005/fa16-ex05-hello-git.git`**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆一个示例仓库：**`https://github.com/mit6005/fa16-ex05-hello-git.git`**
- en: 'Using commands from [Getting Started](../../getting-started/#git) or [*Pro
    Git* 2.3: Viewing the Commit History](http://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History),
    or by using a tool like SourceTree, explain the history of this little project
    to yourself.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[入门指南](../../getting-started/#git)中的命令或[*Pro Git* 2.3：查看提交历史](http://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History)中的命令，或使用像
    SourceTree 这样的工具，向自己解释一下这个小项目的历史。
- en: 'Here’s the output of [`git lol`](../../getting-started/#config-git) for this
    example repository:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个示例仓库的 [`git lol`](../../getting-started/#config-git) 的输出：
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The history of a Git project is a [**directed acyclic graph**](http://en.wikipedia.org/wiki/Directed_acyclic_graph)
    (DAG). The history graph is the backbone of the full object graph stored in `.git`,
    so let’s focus on it for a minute.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Git 项目的历史是一个[**有向无环图**](http://en.wikipedia.org/wiki/Directed_acyclic_graph)（DAG）。历史图是存储在`.git`中的完整对象图的骨架，所以让我们专注一分钟。
- en: '![](../Images/25abd569a317b82518b3087da6480528.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/25abd569a317b82518b3087da6480528.jpg)'
- en: 'Each node in the history graph is a **commit** a.k.a. **version** a.k.a. **revision**
    of the project: a complete snapshot of all the files in the project at that point
    in time. You may recall from our [earlier reading](../../getting-started/#getting_the_history_of_the_repository)
    that each commit is identified by a unique ID, displayed as a hexadecimal number.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 历史图中的每个节点都是项目的**提交**，也称为**版本**，也称为**修订版**：项目在那个时间点的所有文件的完整快照。你可能还记得我们之前的阅读中提到，每个提交都由一个唯一的标识符标识，显示为十六进制数。
- en: 'Except for the initial commit, each commit has a pointer to its **parent**
    commit. For example, commit `1255f4e` has parent `41c4b8f`: this means `41c4b8f`
    happened first, then `1255f4e`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始提交之外，每个提交都有一个指向其**父提交**的指针。例如，提交`1255f4e`的父提交是`41c4b8f`：这意味着`41c4b8f`先发生，然后是`1255f4e`。
- en: 'Some commits have the same parent: they are versions that diverged from a common
    previous version. And some commits have two parents: they are versions that tie
    divergent histories back together.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一些提交具有相同的父提交：它们是从共同的先前版本分叉出来的版本。而一些提交具有两个父提交：它们是将分歧的历史重新连接在一起的版本。
- en: A branch — remember `master` will be our only branch for now — is just a name
    that points to a commit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分支 —— 记住现在只有`master`分支 —— 只是一个指向提交的名称。
- en: Finally, HEAD points to our current commit — almost. We also need to remember
    which branch we’re working on. So HEAD points to the current branch, which points
    to the current commit.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，HEAD 指向我们当前的提交 — 几乎。我们还需要记住我们正在工作的分支。因此 HEAD 指向当前分支，当前分支指向当前提交。
- en: Check your understanding…
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的理解…
- en: reading exercises
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: HEAD count(missing answer)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: HEAD 计数（缺失答案）
- en: (missing explanation)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: (missing answer)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）
- en: (missing explanation)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: First impression(missing answer)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一印象（缺失答案）
- en: (missing explanation)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Graph-ical
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: Choose all the correct answers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有正确的答案。
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Around and around(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 循环往复（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: What else is in the object graph?
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有什么在对象图中？
- en: The history graph is the backbone of the full object graph. What else is in
    there?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 历史图是完整对象图的主干。还有什么在里面？
- en: '![](../Images/148f747fdadb44cd81e2fcca34727efb.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/148f747fdadb44cd81e2fcca34727efb.jpg)'
- en: Each commit is a snapshot of our entire project, which Git represents with a
    **tree** node. For a project of any reasonable size, most of the files *won’t*
    change in any given revision. Storing redundant copies of the files would be wasteful,
    so Git doesn’t do that.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个提交都是我们整个项目的快照，Git 用一个 **树** 节点表示。对于任何合理大小的项目，大多数文件 *不会* 在任何给定的修订中更改。存储文件的冗余副本将是浪费的，因此
    Git 不会这样做。
- en: Instead, the Git object graph stores each version of an individual file *once*,
    and allows multiple commits to *share* that one copy. To the left is a more complete
    rendering of the Git object graph for our example.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Git 对象图仅一次存储每个文件的每个版本，并允许多个提交 *共享* 该一份副本。左侧是我们示例的 Git 对象图的更完整的渲染。
- en: Keep this picture in the back of your mind, because it’s a wonderful example
    of the sharing enabled by *immutable data types*, which we’re going to discuss
    a few classes from now.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个画面，因为它是*不可变数据类型*所启用的共享的精彩例子，我们将在几个类之后讨论。
- en: Each commit also has log data — who, when, short log message, etc. — not shown
    in the diagram.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个提交还有日志数据 —— 谁、何时、简短的日志消息等 —— 在图表中未显示。
- en: Add to the object graph with `git commit`
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用 `git commit` 添加到对象图中
- en: How do we add new commits to the history graph? **`git commit`** creates a new
    commit.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将新的提交添加到历史图中？**`git commit`** 创建一个新的提交。
- en: In some alternate universe, `git commit` might create a new commit based on
    the current contents of your working directory. So if you edited `Hello.java`
    and then did `git commit`, the snapshot would include your changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个替代宇宙中，`git commit` 可能会根据你的工作目录中当前内容创建一个新的提交。所以如果你编辑了 `Hello.java` 然后执行 `git
    commit`，那么快照将包括你的更改。
- en: 'We’re not in that universe; in our universe, Git uses that third and final
    piece of the repository: the **staging area** (a.k.a. the **index**, which is
    only a useful name to know because sometimes it shows up in documentation).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在那个宇宙中；在我们的宇宙中，Git 使用存储库的第三个和最后一个部分：**暂存区**（又称为**索引**，这只是一个有用的名称，因为有时它会出现在文档中）。
- en: 'The staging area is like a proto-commit, a commit-in-progress. Here’s how we
    use the staging area and **`git add`** to build up a new snapshot, which we then
    cast in stone using **`git commit`**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 暂存区就像是一个原型提交，一个正在进行中的提交。这是我们如何使用暂存区和 **`git add`** 来构建一个新的快照，然后使用 **`git commit`**
    来确定它的方式：
- en: Modify `hello.txt`, `git add hello.txt`, `git commit`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `hello.txt`，`git add hello.txt`，`git commit`
- en: 'Hover or tap on each step to update the diagram, and to see the output of `git
    status` at each step:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标悬停或轻触每个步骤以更新图表，并查看每个步骤中 `git status` 的输出：
- en: If we haven’t made any changes yet, then the working directory, staging area,
    and HEAD commit are all identical.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还没有做出任何更改，那么工作目录、暂存区和 HEAD 提交都是相同的。
- en: Make a change to a file. For example, let’s edit `hello.txt`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件。例如，让我们编辑 `hello.txt`。
- en: Other changes might be creating a new file, or deleting a file.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他更改可能包括创建一个新文件，或删除一个文件。
- en: '**Stage** those changes using `git add`.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阶段** 这些更改使用 `git add`。'
- en: Create a new commit out of all the staged changes using `git commit`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git commit` 创建一个包含所有已暂存更改的新提交。
- en: '![](../Images/a75b7711efba2027df60e00296c8176a.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a75b7711efba2027df60e00296c8176a.jpg)'
- en: '[PRE1]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Use **`git status`** frequently to keep track of whether you have no changes,
    unstaged changes, or staged changes; and whether you have new commits in your
    local repository that haven’t been pushed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 经常使用**`git status`**来跟踪你是否没有更改、未暂存的更改或已暂存的更改；以及你的本地仓库中是否有尚未推送的新提交。
- en: reading exercises
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Classy
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅
- en: The Java compiler compiles `.java` files into `.class` files.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器将`.java`文件编译成`.class`文件。
- en: (missing answer)(missing answer)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Take the stage(missing answer)(missing answer)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 登台（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Upstaged
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上台
- en: Suppose we have a repo and there are *changes staged for commit*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个仓库，并且有*准备提交的更改*。
- en: We run `git commit` (with no fancy arguments).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行`git commit`（没有花哨的参数）。
- en: (missing answer)(missing answer)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)(missing answer)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Downplayed
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 轻描淡写
- en: Suppose we start at version A of our project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从项目的版本A开始。
- en: In version B, we make some changes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本B中，我们做了一些更改。
- en: Then in version C, we make exactly the inverse changes we made in version B.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在版本C中，我们做了与版本B中相反的更改。
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Sequences, trees, and graphs
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列、树和图形
- en: 'When you’re working independently, on a single machine, the DAG of your version
    history will usually look like a sequence: commit 1 is the parent of commit 2
    is the parent of commit 3…'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当你独立工作时，在单台机器上，你的版本历史的DAG通常看起来像一个序列：提交1是提交2的父提交，提交2是提交3的父提交…
- en: There are three programmers involved in the history of our example repository.
    Two of them – Alyssa and Ben – made changes “at the same time.” In this case,
    “at the same time” doesn’t mean precisely contemporaneous. Instead, it means they
    made two different *new* versions based on the same *previous* version, just as
    [Alice made version 5L and 5D on her laptop and desktop](#inventing_version_control).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例仓库的历史中涉及三位程序员。其中两位 – Alyssa 和 Ben – “同时”做出了更改。在这种情况下，“同时”并不是指完全同时。相反，它意味着他们基于相同的*之前*版本制作了两个不同的*新*版本，就像[Alice在她的笔记本电脑和台式机上制作了版本5L和5D](#inventing_version_control)一样。
- en: 'When multiple commits share the same parent commit, our history DAG changes
    from a sequence to a tree: it branches apart. Notice that a branch in the history
    of the project doesn’t require anyone to create a new Git branch, merely that
    we start from the same commit and work in parallel on different copies of the
    repository:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个提交共享相同的父提交时，我们的历史DAG从序列变为树：它分支开来。请注意，项目历史中的一个分支并不需要任何人创建新的Git分支，只是我们从相同的提交开始，并在仓库的不同副本上并行工作：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, the history DAG changes from tree- to graph-shaped when the branching
    changes are merged together:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当分支更改合并在一起时，历史DAG从树形变为图形：
- en: '[PRE6]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How is it that changes are merged together? First we’ll need to understand how
    history is shared between different users and repositories.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更改是如何合并在一起的？首先，我们需要了解如何在不同用户和仓库之间共享历史。
- en: Send & receive object graphs with `git push` & `git pull`
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`git push`和`git pull`发送和接收对象图形
- en: 'We can send new commits to a remote repository using **`git push`**:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**`git push`**将新提交发送到远程仓库：
- en: '`git push origin master`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`git push origin master`'
- en: 'Hover or tap on each step to update the diagram:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停或点击每个步骤以更新图表：
- en: When we clone a repository, we obtain a copy of the history graph.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们克隆一个仓库时，我们获得了历史图的副本。
- en: Git remembers where we cloned from as a **remote repository** called **`origin`**.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Git记住了我们克隆的位置作为名为**`origin`**的**远程仓库**。
- en: Using `git commit`, we add new commits to the local history on the `master`
    branch.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git commit`，我们将新提交添加到`master`分支的本地历史中。
- en: To send those changes back to the `origin` remote, use `git push origin master`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这些更改发送回`origin`远程仓库，请使用`git push origin master`。
- en: '![](../Images/b7bf364c0562d841336c4977e71b7337.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b7bf364c0562d841336c4977e71b7337.jpg)'
- en: And we receive new commits using **`git pull`**. Note that `git pull`, in addition
    to fetching new parts of the object graph, also updates the working copy by checking
    out the latest version (just like `git clone` checked out a working copy to start
    with).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**`git pull`**接收新提交。请注意，`git pull`除了获取对象图的新部分外，还通过检出最新版本来更新工作副本（就像`git clone`一开��检出工作副本一样）。
- en: Merging
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并
- en: 'Now, let’s examine what happens when changes occur in parallel:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看当更改并行发生时会发生什么：
- en: Create and commit `hello.scm` and `hello.rb` in parallel
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 并行创建和提交 `hello.scm` 和 `hello.rb`
- en: 'Hover or tap on each step to update the diagram:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停或点击每个步骤以更新图表：
- en: Both Alyssa and Ben **clone** the repository with two commits (`41c4b8f` and
    `1255f4e`).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alyssa 和 Ben 都**克隆**了包含两个提交（`41c4b8f` 和 `1255f4e`）的仓库。
- en: Alyssa creates `hello.scm` and **commits** her change as `6400936`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alyssa 创建了 `hello.scm` 并将她的更改提交为 `6400936`。
- en: At the same time, Ben creates `hello.rb` and **commits** his change as `82e049e`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此同时，Ben 创建了 `hello.rb` 并将他的更改提交为 `82e049e`。
- en: At this point, both of their changes only exist in their local repositories.
    In each repo, `master` now points to a different commit.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，他们两人的更改仅存在于各自的本地仓库中。在每个仓库中，`master` 现在指向一个不同的提交。
- en: Let’s suppose Alyssa is the first to **push** her change up to Athena.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 Alyssa 是第一个把她的更改**推送**到 Athena 的人。
- en: 'What happens if Ben tries to push now? The push will be rejected: if the server
    updates `master` to point to Ben’s commit, Alyssa’s commit will disappear from
    the project history!'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Ben 现在尝试推送会发生什么？推送将被拒绝：如果服务器将 `master` 更新为 Ben 的提交，则 Alyssa 的提交将从项目历史中消失！
- en: Ben must **merge** his changes with Alyssa’s.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ben 必须与 Alyssa 合并他的更改。
- en: 'To perform the merge, he **pulls** her commit from Athena, which does two things:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了执行合并，他从 Athena **拉取**她的提交，这样做了两件事：
- en: (a) Downloads new commits into Ben’s repository’s object graph
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （a）下载新提交到 Ben 的仓库对象图中
- en: '(b) Merges Ben’s history with Alyssa’s, creating a new commit (`3e62e60`) that
    joins together the disparate histories. This commit is a snapshot like any other:
    a snapshot of the repository with both of their changes applied.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （b）将 Ben 的历史与 Alyssa 的合并，创建一个新的提交（`3e62e60`），将不同的历史连接在一起。这个提交像任何其他提交一样是一个快照：一个应用了他们两人更改的仓库的快照。
- en: Now Ben can `git push`, because no history will go missing when he does.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Ben 可以 `git push`，因为当他这样做时不会丢失任何历史记录。
- en: And Alyssa can `git pull` to obtain Ben’s work.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alyssa 可以使用 `git pull` 获取 Ben 的工作。
- en: '![](../Images/b0cb60124809c62730dd0d3ff0cbebc5.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b0cb60124809c62730dd0d3ff0cbebc5.jpg)'
- en: In this example, Git was able to merge Alyssa’s and Ben’s changes automatically,
    because they each modified different files. If both of them had edited the *same
    parts of the same files*, Git would report a **merge conflict**. Ben would have
    to manually weave their changes together before committing the merge. All of this
    is discussed in the [Getting Started section on merges, merging, and merge conflicts](../../getting-started/#merges).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Git 能够自动合并 Alyssa 和 Ben 的更改，因为他们分别修改了不同的文件。如果他们两个都编辑了*相同文件的相同部分*，Git
    将报告**合并冲突**。在提交合并之前，Ben 必须手动将他们的更改编织在一起。所有这些都在[入门部分的合并、合并和合并冲突](../../getting-started/#merges)中讨论过。
- en: reading exercises
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Merge
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 合并
- en: 'Alice and Bob both start with the same Java file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 和 Bob 都从相同的 Java 文件开始：
- en: '[PRE7]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Alice changes `greet(..)`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '| Alice 更改 `greet(..)`：'
- en: '[PRE8]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Bob changes `greeting()`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '| Bob 更改 `greeting()`：'
- en: '[PRE9]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Dangerous Merge Ahead
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 危险的合并前景
- en: 'Same starting program:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的起始程序：
- en: '[PRE10]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Alice changes `greeting()`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '| Alice 更改 `greeting()`：'
- en: '[PRE11]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| Bob changes where the comma appears:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '| Bob 更改逗号的位置：'
- en: '[PRE12]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Continue Merging
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 继续合并
- en: 'Same starting program:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的起始程序：
- en: '[PRE13]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alice changes `greet(..)` to return instead of print:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 将 `greet(..)` 改为返回而不是打印：
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Bob creates a new file, `Main.java`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 创建了一个新文件，`Main.java`：
- en: '[PRE15]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Why do commits look like diffs?
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么提交看起来像差异？
- en: 'We’ve defined a commit as a snapshot of our entire project, but if you ask
    Git, it doesn’t seem to see things that way:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把一个提交定义为我们整个项目的快照，但如果你问 Git，它似乎并不这样看待事情：
- en: '[PRE16]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Git is assuming that most of our project does not change in any given commit,
    so showing only the differences will be more useful. Almost all the time, that’s
    true.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Git 假设我们项目的大部分在任何给定的提交中都不会改变，因此只显示差异将更有用。几乎所有时候，这是正确的。
- en: 'But we can ask Git to show us what was in the repo at a particular commit:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以要求 Git 显示给我们特定提交时存储库中的内容：
- en: '[PRE17]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Yes, the addition of a `:` completely changes the meaning of that command.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，添加一个 `:` 完全改变了该命令的含义。
- en: 'We can also see what was in a particular file in that commit:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看该提交中特定文件的内容：
- en: '[PRE18]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is one of the simplest ways you can use Git to recover from a disaster:
    ask it to `git show` you the contents of a now-broken file at some earlier version
    when the file was OK.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以使用 Git 从灾难中恢复的最简单的方法之一：要求它 `git show` 你在文件出现问题之前的某个早期版本时文件是正常的时候的内容。
- en: We’ll practice some disaster recovery commands in class.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在课堂上练习一些灾难恢复命令。
- en: Version control and the big three
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制与三大重要思想
- en: How does version control relate to the three big ideas of 6.005?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制与 6.005 的三个重要思想有何关系？
- en: Safe from bugs
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 免受错误的影响
- en: find when and where something broke
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 找到什么时候以及在哪里出了问题
- en: look for other, similar mistakes
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找其他类似的错误
- en: gain confidence that code hasn’t changed accidentally
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 获得代码没有意外更改的信心
- en: Easy to understand
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 易于理解
- en: why was a change made?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么做出了改变？
- en: what else was changed at the same time?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一时间还改变了什么？
- en: who can I ask about this code?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以问谁有关于这段代码的问题？
- en: Ready for change
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为变化做好准备
- en: all about managing and organizing changes
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 管理和组织变更的全部内容
- en: accept and integrate changes from other developers
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接受并集成其他开发人员的变更
- en: isolate speculative work on branches
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 分支上的 speculative 工作隔离开来
