- en: 'Reading 13: Interfaces'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 13：接口
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 免于错误 | 易于理解 | 为变化做好准备 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确的，未来也正确。 | 与未来的程序员清晰沟通，包括未来的你。 | 设计以适应变化而无需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: 'The topic of today’s class is interfaces: separating the interface of an abstract
    data type from its implementation, and using Java `interface` types to enforce
    that separation.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天课程的主题是接口：将抽象数据类型的接口与其实现分离，并使用 Java 的 `interface` 类型来强制执行该分离。
- en: After today’s class, you should be able to define ADTs with interfaces, and
    write classes that implement interfaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的课程结束后，你应该能够使用接口定义 ADTs，并编写实现接口的类。
- en: Interfaces
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,interfaces/rEFM6lvEQsY)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,interfaces/rEFM6lvEQsY)'
- en: Java’s `interface` is a useful language mechanism for expressing an abstract
    data type. An interface in Java is a list of method signatures, but no method
    bodies. A class *implements* an interface if it declares the interface in its
    `implements` clause, and provides method bodies for all of the interface’s methods.
    So one way to define an abstract data type in Java is as an interface, with its
    implementation as a class implementing that interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 `interface` 是一种表达抽象数据类型的有用语言机制。在 Java 中，接口是方法签名的列表，但没有方法体。如果类在其 `implements`
    子句中声明了接口，并为接口的所有方法提供了方法体，那么该类就 *实现* 了该接口。因此，在 Java 中定义抽象数据类型的一种方式是将其作为一个接口，其实现作为实现该接口的类。
- en: One advantage of this approach is that the interface specifies the contract
    for the client and nothing more. The interface is all a client programmer needs
    to read to understand the ADT. The client can’t create inadvertent dependencies
    on the ADT’s rep, because instance variables can’t be put in an interface at all.
    The implementation is kept well and truly separated, in a different class altogether.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优点是接口为客户端指定了合同，而不再有其他。接口是客户端程序员需要阅读以了解 ADT 的全部内容。客户端不能对 ADT 的 rep 产生无意的依赖，因为实例变量根本不能放在接口中。实现被完全保持分离，完全在另一个类中。
- en: Another advantage is that multiple different representations of the abstract
    data type can co-exist in the same program, as different classes implementing
    the interface. When an abstract data type is represented just as a single class,
    without an interface, it’s harder to have multiple representations. In the [`MyString`
    example from *Abstract Data Types*](../11-abstract-data-types/#example_different_representations_for_strings),
    `MyString` was a single class. We explored two different representations for `MyString`,
    but we couldn’t have both representations for the ADT in the same program.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，抽象数据类型的多种不同表示可以在同一程序中共存，作为实现接口的不同类。当抽象数据类型仅表示为单个类时，没有接口，很难拥有多种表示。在 *Abstract
    Data Types* 的 [`MyString` 示例](../11-abstract-data-types/#example_different_representations_for_strings)
    中，`MyString` 是一个单独的类。我们探索了 `MyString` 的两种不同表示，但不能在同一程序中同时使用 ADT 的这两种表示。
- en: Java’s static type checking allows the compiler to catch many mistakes in implementing
    an ADT’s contract. For instance, it is a compile-time error to omit one of the
    required methods, or to give a method the wrong return type. Unfortunately, the
    compiler doesn’t check for us that the code adheres to the specs of those methods
    that are written in documentation comments.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的静态类型检查允许编译器捕获许多在实现 ADT 合同时的错误。例如，省略一个必需的方法或给出错误的返回类型都会导致编译时错误。不幸的是，编译器不会检查代码是否符合文档注释中编写的这些方法的规范。
- en: For the details of how to define interfaces in Java, consult the [Java Tutorials
    section on interfaces](http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在 Java 中定义接口的详细信息，请参阅 [Java 教程中关于接口的部分](http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)。
- en: reading exercises
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Java interfaces
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java 接口
- en: 'Consider this Java interface and Java class, which are intended to implement
    an immutable set data type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个 Java 接口和 Java 类，它们旨在实现不可变的集合数据类型：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The line labeled `A` is a problem because Java interfaces can’t have constructors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 `A` 的这行是一个问题，因为 Java 接口不能有构造函数。
- en: (missing answer)(missing answer)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: The line labeled `B` is a problem because `Set` mentions `ArraySet`, but `ArraySet`
    also mentions `Set`, which is circular.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`B`的线是一个问题，因为`Set`提到了`ArraySet`，但`ArraySet`也提到了`Set`，这是循环的。
- en: (missing answer)(missing answer)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: The line labeled `B` is a problem because it isn’t representation-independent.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`B`的线是一个问题，因为它不是表示独立的。
- en: (missing answer)(missing answer)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '`ArraySet` doesn’t correctly implement `Set` because it’s missing the `contains()`
    method.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArraySet`未正确实现`Set`，因为缺少`contains()`方法。'
- en: (missing answer)(missing answer)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '`ArraySet` doesn’t correctly implement `Set` because it includes a method that
    `Set` doesn’t have.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArraySet`未正确实现`Set`，因为它包含一个`Set`没有的方法。'
- en: (missing answer)(missing answer)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '`ArraySet` doesn’t correctly implement `Set` because `ArraySet` is mutable
    while `Set` is immutable.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArraySet`未正确实现`Set`，因为`ArraySet`是可变的，而`Set`是不可变的。'
- en: (missing answer)(missing answer)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Subtypes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类型
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,subtypes/rHQxjghbGY4)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,subtypes/rHQxjghbGY4)'
- en: 'Recall that a *type* is a set of values. The Java [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    type is defined by an interface. If we think about all possible `List` values,
    none of them are `List` objects: we cannot create instances of an interface. Instead,
    those values are all `ArrayList` objects, or `LinkedList` objects, or objects
    of another class that implements `List`. A *subtype* is simply a subset of the
    *supertype*: `ArrayList` and `LinkedList` are subtypes of `List`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，*类型*是一组值。Java [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    类型由一个接口定义。如果我们考虑所有可能的`List`值，那么它们都不是`List`对象：我们无法创建接口的实例。相反，这些值都是`ArrayList`对象，或`LinkedList`对象，或实现`List`的另一个类的对象。*子类型*只是*超类型*的子集：`ArrayList`和`LinkedList`是`List`的子类型。
- en: '“B is a subtype of A” means “every B is an A.” In terms of specifications:
    “every B satisfies the specification for A.”'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “B是A的子类型”意味着“每个B都是A。”就规范而言：“每个B都满足A的规范。”
- en: 'That means B is only a subtype of A if B’s specification is at least as strong
    as A’s specification. When we declare a class that implements an interface, the
    Java compiler enforces part of this requirement automatically: for example, it
    ensures that every method in A appears in B, with a compatible type signature.
    Class B cannot implement interface A without implementing all of the methods declared
    in A.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着只有当B的规范至少与A的规范一样强大时，B才是A的子类型。当我们声明一个类来实现一个接口时，Java编译器会自动强制执行此要求的一部分：例如，它确保A中的每个方法都以兼容的类型签名出现在B中。类B不能实现接口A而不实现A中声明的所有方法。
- en: 'But the compiler cannot check that we haven’t weakened the specification in
    other ways: strengthening the precondition on some inputs to a method, weakening
    a postcondition, weakening a guarantee that the interface abstract type advertises
    to clients. If you declare a subtype in Java — implementing an interface is our
    current focus — then you must ensure that the subtype’s spec is at least as strong
    as the supertype’s.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是编译器无法检查我们是否以其他方式削弱了规范：增强某些输入方法的前置条件，减弱后置条件，减弱接口抽象类型向客户端广告的保证。如果你在Java中声明一个子类型
    - 实现接口是我们当前的重点 - 那么你必须确保子类型的规范至少与超类型的规范一样强大。
- en: reading exercises
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Immutable shapes
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变形状
- en: 'Let’s define an interface for rectangles:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为矩形定义一个接口：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It follows that every square is a rectangle:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个正方形都是一个矩形：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Does `ImmutableSquare.getWidth()` satisfy the spec of `ImmutableRectangle.getWidth()`?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableSquare.getWidth()`是否满足`ImmutableRectangle.getWidth()`的规范？'
- en: (missing answer)(missing answer)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: Does `ImmutableSquare.getHeight()` satisfy the spec of `ImmutableRectangle.getHeight()`?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableSquare.getHeight()`是否满足`ImmutableRectangle.getHeight()`的规范？'
- en: (missing answer)(missing answer)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: Does the whole `ImmutableSquare` spec satisfy the `ImmutableRectangle` spec?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`ImmutableSquare`规范是否满足`ImmutableRectangle`规范？
- en: (missing answer)(missing answer)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Mutable shapes
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可变形状
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Surely every square is still a rectangle?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每个正方形仍然是一个矩形吗？
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For each possible `MutableSquare.setSize(..)` implementation below, is it a
    valid implementation?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的每个可能的`MutableSquare.setSize(..)`实现，它是否是一个有效的实现？
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <select class="form-control"><option>No – stronger precondition</option>,<option>Yes
    – weaker precondition</option>,<option>Yes – stronger postcondition</option>,<option>No
    – weaker postcondition</option>,<option>Specifications are incomparable</option></select>(missing
    answer)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>否 – 前置条件更强</option>,<option>是 – 前置条件更弱</option>,<option>是
    – 后置条件更强</option>,<option>否 – 后置条件更弱</option>,<option>规格不可比较</option></select>（缺失答案）
- en: (missing explanation)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <select class="form-control"><option>No – stronger precondition</option>,<option>Yes
    – weaker precondition</option>,<option>Yes – stronger postcondition</option>,<option>No
    – weaker postcondition</option>,<option>Specifications are incomparable</option></select>(missing
    answer)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>否 – 前置条件更强</option>,<option>是 – 前置条件更弱</option>,<option>是
    – 后置条件更强</option>,<option>否 – 后置条件更弱</option>,<option>规格不可比较</option></select>（缺失答案）
- en: (missing explanation)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <select class="form-control"><option>No – stronger precondition</option>,<option>Yes
    – weaker precondition</option>,<option>Yes – stronger postcondition</option>,<option>No
    – weaker postcondition</option>,<option>Specifications are incomparable</option></select>(missing
    answer)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>否 – 前置条件更强</option>,<option>是 – 前置条件更弱</option>,<option>是
    – 后置条件更强</option>,<option>否 – 后置条件更弱</option>,<option>规格不可比较</option></select>（缺失答案）
- en: (missing explanation)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <select class="form-control"><option>No – stronger precondition</option>,<option>Yes
    – weaker precondition</option>,<option>Yes – stronger postcondition</option>,<option>No
    – weaker postcondition</option>,<option>Specifications are incomparable</option></select>(missing
    answer)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>否 – 前置条件更强</option>,<option>是 – 前置条件更弱</option>,<option>是
    – 后置条件更强</option>,<option>否 – 后置条件更弱</option>,<option>规格不可比较</option></select>（缺失答案）
- en: (missing explanation)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: 'Example: `MyString`'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例如：`MyString`
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,example_mystring/yZiA4P1Yks8)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,example_mystring/yZiA4P1Yks8)'
- en: 'Let’s revisit [`MyString`](../11-abstract-data-types/#example_different_representations_for_strings).
    Using an interface instead of a class for the ADT, we can support multiple implementations:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视[`MyString`](../11-abstract-data-types/#example_different_representations_for_strings)。使用抽象数据类型的接口而不是类，我们可以支持多种实现：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ll skip the static `valueOf` method and come back to it in a minute. Instead,
    let’s go ahead using a different technique from our [toolbox of ADT concepts in
    Java](../11-abstract-data-types/#realizing_adt_concepts_in_java): constructors.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过静态的 `valueOf` 方法，一会儿再回来。而是，让我们使用 Java 中[抽象数据类型概念工具箱](../11-abstract-data-types/#realizing_adt_concepts_in_java)中的不同技术：构造函数。
- en: 'Here’s our first implementation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个实现：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And here’s the optimized implementation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是优化后的实现：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compare these classes to the [implementations of `MyString` in *Abstract Data
    Types*](../11-abstract-data-types/#example_different_representations_for_strings).
    Notice how the code that previously appeared in static `valueOf` methods now appears
    in the constructors, slightly changed to refer to the rep of `this`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些类与[*抽象数据类型*中 `MyString` 的实现](../11-abstract-data-types/#example_different_representations_for_strings)进行比较。注意以前出现在静态
    `valueOf` 方法中的代码现在出现在构造函数中，稍作更改以引用 `this` 的表示。
- en: 'Also notice the use of [`@Override`](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).
    This annotation informs the compiler that the method must have the same signature
    as one of the methods in the interface we’re implementing. But since the compiler
    already checks that we’ve implemented all of the interface methods, the primary
    value of `@Override` here is for readers of the code: it tells us to look for
    the spec of that method in the interface. Repeating the spec wouldn’t be DRY,
    but saying nothing at all makes the code harder to understand.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还要注意使用[`@Override`](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html)。此注解通知编译器，该方法必须与我们正在实现的接口中的某个方法具有相同的签名。但由于编译器已经检查我们已实现了所有接口方法，因此在这里
    `@Override` 的主要价值是给代码的读者：它告诉我们在接口中查找该方法的规范。重复规范不符合 DRY 原则，但完全不说则使代码难以理解。
- en: And notice the private empty constructors we use to make new instances in `substring(..)`
    before we fill in their reps with data. We didn’t have to write these empty constructors
    before because Java provides them by default when we don’t declare any others.
    Adding the constructors that take `boolean b` means we have to declare the empty
    constructors explicitly.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意我们在`substring(..)`中使用的私有空构造函数，之后我们填充它们的表示数据。以前我们不需要编写这些空构造函数，因为当我们没有声明其他构造函数时，Java会默认提供它们。添加带有`boolean
    b`的构造函数意味着我们必须显式声明空构造函数。
- en: 'Now that we know good ADTs scrupulously [preserve their own invariants](../12-abstraction-functions-rep-invariants/#invariants),
    these do-nothing constructors are a **bad** pattern: they don’t assign any values
    to the rep, and they certainly don’t establish any invariants. We should strongly
    consider revising the implementation. Since `MyString` is immutable, a starting
    point would be making all the fields `final`.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们知道良好的ADT严谨地[保持它们自己的不变式](../12-abstraction-functions-rep-invariants/#invariants)，这些无所作为的构造函数是一个**坏**模式：它们不为rep分配任何值，当然也不建立任何不变式。我们应该认真考虑修改实现。由于`MyString`是不可变的，一个起点是使所有字段都是`final`的。
- en: 'How will clients use this ADT? Here’s an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将如何使用此ADT？这里是一个例子：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code looks very similar to the code we write to use the Java collections
    classes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来与我们编写用于使用Java集合类的代码非常相似：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unfortunately, this pattern **breaks the abstraction barrier** we’ve worked
    so hard to build between the abstract type and its concrete representations. Clients
    must know the name of the concrete representation class. Because interfaces in
    Java cannot contain constructors, they must directly call one of the concrete
    class’ constructors. The spec of that constructor won’t appear anywhere in the
    interface, so there’s no static guarantee that different implementations will
    even provide the same constructors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种模式**破坏了我们努力构建的抽象屏障**，即抽象类型与其具体表示之间的抽象屏障。客户端必须知道具体表示类的名称。因为Java中的接口不能包含构造函数，所以它们必须直接调用其中一个具体类的构造函数。该构造函数的规范不会出现在接口的任何地方，因此没有静态保证不同的实现甚至会提供相同的构造函数。
- en: 'Fortunately, (as of Java 8) interfaces *are* allowed to contain static methods,
    so we can implement the creator operation `valueOf` as a static factory method
    in the interface `MyString`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，（截至Java 8）接口 *允许* 包含静态方法，因此我们可以在接口`MyString`中将创建操作`valueOf`实现为静态工厂方法：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now a client can use the ADT without breaking the abstraction barrier:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端可以在不破坏抽象屏障的情况下使用ADT：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: reading exercises
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Code review
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查
- en: 'Let’s review the code for `FastMyString`. Which of these are useful criticisms:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`FastMyString`的代码。哪些是有用的批评：
- en: I wish the abstraction function was documented
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望抽象函数被记录下来
- en: (missing answer)(missing answer)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: I wish the representation invariant was documented
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望表示不变式被记录下来
- en: (missing answer)(missing answer)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: I wish the rep fields were `final` so they could not be reassigned
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望rep字段是`final`的，这样它们就不能被重新赋值
- en: (missing answer)(missing answer)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: I wish the private constructor was public so clients could use it to construct
    empty strings
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望私有构造函数是公共的，这样客户端就可以使用它来构造空字符串
- en: (missing answer)(missing answer)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: I wish the `charAt` specification did not expose that the rep contains individual
    characters
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望`charAt`规范不暴露rep包含单个字符的事实
- en: (missing answer)(missing answer)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: I wish the `charAt` implementation behaved more helpfully when `i` is greater
    than the length of the string
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望`charAt`的实现在`i`大于字符串长度时表现得更有帮助
- en: (missing answer)(missing answer)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: 'Example: Generic `Set<E>`'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：泛型`Set<E>`
- en: Java’s collection classes provide a good example of the idea of separating interface
    and implementation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Java的集合类提供了一个很好的示例，即将接口和实现分离的思想。
- en: 'Let’s consider as an example one of the ADTs from the Java collections library,
    `Set`. `Set` is the ADT of finite sets of elements of some other type `E`. Here
    is a simplified version of the `Set` interface:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Java集合库中的一个ADT为例，`Set`。`Set`是某种其他类型`E`的元素的有限集的ADT。这是`Set`接口的简化版本：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Set` is an example of a *generic type*: a type whose specification is in terms
    of a placeholder type to be filled in later. Instead of writing separate specifications
    and implementations for `Set<String>`, `Set<Integer>`, and so on, we design and
    implement one `Set<E>`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 是 *泛型类型* 的一个示例：其规范是以稍后填充的占位符类型来定义的类型。我们设计并实现了一个 `Set<E>`，而不是为 `Set<String>`、`Set<Integer>`
    等分别编写规范和实现。'
- en: 'We can match Java interfaces with our classification of ADT operations, starting
    with a creator:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Java 接口与我们对 ADT 操作的分类相匹配，从创建者开始：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `make` operation is implemented as a static factory method. Clients will
    write code like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 操作被实现为静态工厂方法。客户端将编写如下代码：'
- en: '`Set<String> strings = Set.make();`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set<String> strings = Set.make();`'
- en: and the compiler will understand that the new `Set` is a set of `String` objects.
    (We write `<E>` at the front of this signature because `make` is a static method.
    It needs its own generic type parameter, separate from the `E` we’re using in
    instance method specs.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会理解新的 `Set` 是 `String` 对象的集合。（我们在此签名的前面写 `<E>`，因为 `make` 是一个静态方法。它需要自己的泛型类型参数，与我们在实例方法规范中使用的
    `E` 不同。）
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next we have two observer methods. Notice how the specs are in terms of our
    abstract notion of a set; it would be malformed to mention the details of any
    particular implementation of sets with particular private fields. These specs
    should apply to any valid implementation of the set ADT.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有两个观察者方法。注意规范是以我们抽象的集合概念为基础的；提及特定实现集合的任何细节以及特定私有字段将是格式不正确的。这些规范应适用于集合 ADT
    的任何有效实现。
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The story for these mutators is basically the same as for the observers. We
    still write specs at the level of our abstract model of sets.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些修改器的情况基本与观察者的情况相同。我们仍然在集合的抽象模型级别编写规范。
- en: 'In the Java Tutorials, read these pages:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 教程中，阅读以下页面：
- en: '[Lesson: Interfaces](http://docs.oracle.com/javase/tutorial/collections/interfaces/)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[教程：接口](http://docs.oracle.com/javase/tutorial/collections/interfaces/)'
- en: '[The Set Interface](http://docs.oracle.com/javase/tutorial/collections/interfaces/set.html)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Set 接口](http://docs.oracle.com/javase/tutorial/collections/interfaces/set.html)'
- en: '[Set Implementations](http://docs.oracle.com/javase/tutorial/collections/implementations/set.html)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[集合实现](http://docs.oracle.com/javase/tutorial/collections/implementations/set.html)'
- en: '[The List Interface](http://docs.oracle.com/javase/tutorial/collections/interfaces/list.html)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列表接口](http://docs.oracle.com/javase/tutorial/collections/interfaces/list.html)'
- en: '[List Implementations](http://docs.oracle.com/javase/tutorial/collections/implementations/list.html)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列表实现](http://docs.oracle.com/javase/tutorial/collections/implementations/list.html)'
- en: reading exercises
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Collection interfaces & implementations
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 集合接口和实现
- en: Assume the following lines of code are run in sequence, and that any lines of
    code that don’t compile are simply commented out so that the rest of the code
    can compile.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下代码行按顺序运行，并且任何不能编译的代码行都被简单地注释掉，以便其余代码可以编译。
- en: The code uses two methods from [`Collections`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html),
    so you might need to consult their documentation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了 [`Collections`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html)
    的两个方法，因此您可能需要查阅其文档。
- en: Choose the most specific answer to each question.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个问题选择最具体的答案。
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`set` now points to:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 现在指向：'
- en: <select class="form-control"><option>a HashSet object</option>,<option>an object
    that implements the Set interface</option>,<option>null</option>,<option>this
    line won’t compile</option></select>(missing answer)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>一个 HashSet 对象</option>，<option>实现 Set 接口的对象</option>，<option>null</option>，<option>此行不会编译</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`set` now points to:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 现在指向：'
- en: <select class="form-control"><option>a HashSet object</option>,<option>a Collections
    object</option>,<option>an object that implements the Set interface</option>,<option>null</option>,<option>this
    line won’t compile</option></select>(missing answer)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>一个 HashSet 对象</option>，<option>一个 Collections
    对象</option>，<option>实现 Set 接口的对象</option>，<option>null</option>，<option>此行不会编译</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`set` now points to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 现在指向：'
- en: <select class="form-control"><option>a HashSet object</option>,<option>a Collections
    object</option>,<option>an object that implements the Set interface</option>,<option>null</option>,<option>this
    line won’t compile</option></select>(missing answer)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>一个 HashSet 对象</option>，<option>一个 Collections
    对象</option>，<option>实现 Set 接口的对象</option>，<option>null</option>，<option>此行不会编译</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`set` now points to:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 现在指向：'
- en: <select class="form-control"><option>a HashSet object</option>,<option>a Set
    object</option>,<option>an object that implements the Set interface</option>,<option>null</option>,<option>this
    line won’t compile</option></select>(missing answer)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>一个 HashSet 对象</option>,<option>一个 Set 对象</option>,<option>一个实现
    Set 接口的对象</option>,<option>null</option>,<option>这行代码无法编译</option></select>(缺少答案)
- en: (missing explanation)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`set` now points to:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 现在指向：'
- en: <select class="form-control"><option>a HashSet object</option>,<option>an object
    that implements the Set interface</option>,<option>an object that implements the
    List interface</option>,<option>null</option>,<option>this line won’t compile</option></select>(missing
    answer)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>一个 HashSet 对象</option>,<option>一个实现 Set
    接口的对象</option>,<option>一个实现 List 接口的对象</option>,<option>null</option>,<option>这行代码无法编译</option></select>(缺少答案)
- en: (missing explanation)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[data:text/html,<style>body { font-family: "Helvetica Neue", Helvetica, Arial,
    sans-serif; }</style>Click a method name to see its Javadoc here.](data:text/html,<style>body
    { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }</style>Click
    a method name to see its Javadoc here.)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击方法名称以在此处查看其 Javadoc](text/html,<style>body { font-family: "Helvetica Neue",
    Helvetica, Arial, sans-serif; }</style>点击方法名称以在此处查看其 Javadoc)'
- en: Implementing Generic Interfaces
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现泛型接口
- en: Suppose we want to implement the generic `Set<E>` interface above. We can either
    write a non-generic implementation that replaces `E` with a specific type, or
    a generic implementation that keeps the placeholder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现上面的泛型 `Set<E>` 接口。我们可以编写一个非泛型实现，将 `E` 替换为特定类型，或者编写一个保留占位符的泛型实现。
- en: '**Generic interface, non-generic implementation.** Let’s implement `Set<E>`
    for a *particular* type `E`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型接口，非泛型实现。** 让我们为 *特定* 类型 `E` 实现 `Set<E>`。'
- en: 'In [*Abstraction Functions & Rep Invariants*](../12-abstraction-functions-rep-invariants/#rep_invariant_and_abstraction_function)
    we looked at `CharSet`, which represents a set of characters. The [example code
    for `CharSet`](https://github.com/mit6005/fa16-ex12-adt-examples/tree/master/src/charset)
    includes a generic [`Set` interface](https://github.com/mit6005/fa16-ex12-adt-examples/blob/master/src/charset/Set.java)
    and each of the implementations `CharSet1`/`2`/`3` declare:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*抽象函数与表示不变量*](../12-abstraction-functions-rep-invariants/#rep_invariant_and_abstraction_function)
    中，我们看到了 `CharSet`，它表示字符集。 [`CharSet` 的示例代码](https://github.com/mit6005/fa16-ex12-adt-examples/tree/master/src/charset)
    包括一个泛型 [`Set` 接口](https://github.com/mit6005/fa16-ex12-adt-examples/blob/master/src/charset/Set.java)，以及每个实现
    `CharSet1`/`2`/`3` 声明：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When the interface mentions placeholder type `E`, the `CharSet` implementations
    replace `E` with `Character`. For example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当接口提到占位符类型 `E` 时，`CharSet` 实现会将 `E` 替换为 `Character`。例如：
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The representations used by `CharSet1`/`2`/`3` are not suited for representing
    sets of arbitrary-type elements. The `String` reps, for example, cannot represent
    a `Set<Integer>` without careful work to define a new rep invariant and abstraction
    function that handles multi-digit numbers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharSet1`/`2`/`3` 使用的表示法不适合表示任意类型元素的集合。例如，`String` 表示法不能表示 `Set<Integer>`，除非仔细定义新的表示不变量和处理多位数字的抽象函数。'
- en: '**Generic interface, generic implementation.** We can also implement the generic
    `Set<E>` interface without picking a type for `E`. In that case, we write our
    code blind to the actual type that clients will choose for `E`. Java’s [`HashSet`](http://docs.oracle.com/javase/8/docs/api/?java/util/HashSet.html)
    does that for `Set`. Its declaration looks like:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型接口，泛型实现。** 我们还可以实现泛型 `Set<E>` 接口，而不选择 `E` 的类型。在这种情况下，我们的代码是盲目的，无法知道客户端将为
    `E` 选择的实际类型。Java 的 [`HashSet`](http://docs.oracle.com/javase/8/docs/api/?java/util/HashSet.html)
    就是这样做的。它的声明看起来像这样：'
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A generic implementation can only rely on details of the placeholder types that
    are included in the interface’s specification. We’ll see in a future reading how
    `HashSet` relies on methods that every type in Java is required to implement —
    and only on those methods, because it can’t rely on methods declared in any specific
    type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型实现只能依赖于包含在接口规范中的占位符类型的细节。在未来的阅读中，我们会看到 `HashSet` 依赖于 Java 中每种类型都必须实现的方法 ——
    仅仅是这些方法，因为它不能依赖于任何特定类型声明的方法。
- en: Why Interfaces?
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用接口？
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,why_interfaces/hqCFnF0NjLs)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,why_interfaces/hqCFnF0NjLs)'
- en: Interfaces are used pervasively in real Java code. Not every class is associated
    with an interface, but there are a few good reasons to bring an interface into
    the picture.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在真实的Java代码中被广泛使用。并非每个类都与接口相关，但有几个很好的理由将接口引入其中。
- en: '**Documentation for both the compiler and for humans**. Not only does an interface
    help the compiler catch ADT implementation bugs, but it is also much more useful
    for a human to read than the code for a concrete implementation. Such an implementation
    intersperses ADT-level types and specs with implementation details.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为编译器和人类编写的文档**。接口不仅帮助编译器捕捉ADT实现错误，而且对于人类阅读比具体实现的代码更有用。这样的实现将ADT级别的类型和规范与实现细节交替排列。'
- en: '**Allowing performance trade-offs**. Different implementations of the ADT can
    provide methods with very different performance characteristics. Different applications
    may work better with different choices, but we would like to code these applications
    in a way that is representation-independent. From a correctness standpoint, it
    should be possible to drop in any new implementation of a key ADT with simple,
    localized code changes.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许性能权衡**。ADT的不同实现可以提供具有非常不同性能特征的方法。不同的应用程序可能与不同的选择更好地配合，但我们希望以表示无关的方式编写这些应用程序。从正确性的角度来看，应该可以通过简单的局部代码更改插入任何新的ADT关键实现。'
- en: '**Optional methods**. `List` from the Java standard library marks all mutator
    methods as optional. By building an implementation that does not support these
    methods, we can provide immutable lists. Some operations are hard to implement
    with good enough performance on immutable lists, so we want mutable implementations,
    too. Code that doesn’t call mutators can be written to work automatically with
    either kind of list.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选方法**。Java标准库中的`List`将所有变异方法标记为可选的。通过构建不支持这些方法的实现，我们可以提供不可变列表。一些操作很难在不可变列表上实现足够好的性能，因此我们也希望有可变实现。不调用变异器的代码可以自动适用于任一种列表。'
- en: '**Methods with intentionally underdetermined specifications**. An ADT for finite
    sets could leave unspecified the element order one gets when converting to a list.
    Some implementations might use slower method implementations that manage to keep
    the set representation in some sorted order, allowing quick conversion to a sorted
    list. Other implementations might make many methods faster by not bothering to
    support conversion to sorted lists.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故意未确定规范的方法**。有限集合的ADT可能会在将其转换为列表时未指定元素顺序。一些实现可能使用较慢的方法实现，以保持集合表示在某种排序顺序中，从而实现快速转换为排序列表。其他实现可能通过不支持转换为排序列表来使许多方法更快。'
- en: '**Multiple views of one class**. A Java class may implement multiple interfaces.
    For instance, a user interface widget displaying a drop-down list is natural to
    view as both a widget and a list. The class for this widget could implement both
    interfaces. In other words, we don’t implement an ADT multiple times just because
    we are choosing different data structures; we may make multiple implementations
    because many different sorts of objects may also be seen as special cases of the
    ADT, among other useful perspectives.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个类的多个视图**。一个Java类可以实现多个接口。例如，显示下拉列表的用户界面小部件自然可以视为小部件和列表。这个小部件的类可以实现两个接口。换句话说，我们不是因为选择不同的数据结构而多次实现ADT；我们可能会进行多次实现，因为许多不同类型的对象也可以被视为ADT的特殊情况，以及其他有用的视角。'
- en: '**More and less trustworthy implementations**. Another reason to implement
    an interface multiple times might be that it is easy to build a simple implementation
    that you believe is correct, while you can work harder to build a fancier version
    that is more likely to contain bugs. You can choose implementations for applications
    based on how bad it would be to get bitten by a bug.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更可信和不太可信的实现**。实现接口多次的另一个原因可能是很容易构建一个简单的实现，你相信它是正确的，而你可以更努力地构建一个更复杂的版本，更有可能包含错误。你可以根据受到错误影响的严重程度选择应用的实现。'
- en: Realizing ADT Concepts in Java
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中实现ADT概念
- en: 'We’ve now completed our [Java toolbox of ADT concepts](../11-abstract-data-types/#realizing_adt_concepts_in_java)
    from the first ADTs reading:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们从第一个ADTs阅读中获得的[Java ADT概念工具箱](../11-abstract-data-types/#realizing_adt_concepts_in_java)：
- en: '| ADT concept | Ways to do it in Java | Examples |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| ADT概念 | 在Java中实现的方式 | 示例 |'
- en: '| Abstract data type | Single class | [`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 抽象数据类型 | 单个类 | [`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    |'
- en: '| Interface + class(es) | [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    and [`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 接口 + 类(es) | [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    和 [`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)
    |'
- en: '| Enum | [`DayOfWeek`](http://docs.oracle.com/javase/8/docs/api/?java/time/DayOfWeek.html)
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | [`DayOfWeek`](http://docs.oracle.com/javase/8/docs/api/?java/time/DayOfWeek.html)
    |'
- en: '| Creator operation | Constructor | [`ArrayList()`](http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--)
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 创建者操作 | 构造函数 | [`ArrayList()`](http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--)
    |'
- en: '| Static (factory) method | [`Collections.<wbr>singletonList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-),
    [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 静态（工厂）方法 | [`Collections.<wbr>singletonList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-),
    [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)
    |'
- en: '| Constant | [`BigInteger.ZERO`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO)
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | [`BigInteger.ZERO`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO)
    |'
- en: '| Observer operation | Instance method | [`List.get()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-)
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 观察者操作 | 实例方法 | [`List.get()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-)
    |'
- en: '| Static method | [`Collections.max()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-)
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | [`Collections.max()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-)
    |'
- en: '| Producer operation | Instance method | [`String.trim()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--)
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 生产者操作 | 实例方法 | [`String.trim()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--)
    |'
- en: '| Static method | [`Collections.<wbr>unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | [`Collections.<wbr>unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    |'
- en: '| Mutator operation | Instance method | [`List.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-)
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 修改器操作 | 实例方法 | [`List.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-)
    |'
- en: '| Static method | [`Collections.copy()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-)
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | [`Collections.copy()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-)
    |'
- en: '| Representation | `private` fields |  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 表示 | `private` 字段 |  |'
- en: reading exercises
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: 'Suppose you have an abstract data type for rational numbers, similar to [the
    one we discussed in *Abstraction Functions & Rep Invariants*](../12-abstraction-functions-rep-invariants/#documenting_the_af_ri_and_safety_from_rep_exposure),
    which is currently represented as a Java class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个类似于[我们在*抽象函数和表示不变性*中讨论的](../12-abstraction-functions-rep-invariants/#documenting_the_af_ri_and_safety_from_rep_exposure)的有理数的抽象数据类型，它当前被表示为一个
    Java 类：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You decide to change `RatNum` to a Java interface instead, along with an implementation
    class called `IntFraction`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定将 `RatNum` 改为一个 Java 接口，同时还有一个名为 `IntFraction` 的实现类：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For each piece of code below from the old `RatNum` class, identify it and decide
    where it should go in the new interface—plus—implementation-class design.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面旧的 `RatNum` 类中的每一段代码，请确认它的身份，并决定它应该放在新的接口加实现类设计中的何处。
- en: Interface + implementation 1
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 + 实现 1
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 此代码片段是：（选中所有适用项）(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案) | 应该放在：(缺少答案)(缺少答案)(缺少答案)
    |'
- en: (missing explanation)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Interface + implementation 2
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 + 实现 2
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 此代码片段是：（选中所有适用项）(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案) | 应该放在：(缺少答案)(缺少答案)(缺少答案)
    |'
- en: (missing explanation)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Interface + implementation 3
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 + 实现 3
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 这段代码是：（选择所有适用项）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案） | 它应该放在：（缺失答案）（缺失答案）（缺失答案）
    |'
- en: (missing explanation)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Interface + implementation 4
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 + 实现 4
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 这段代码是：（选择所有适用项）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案） | 它应该放在：（缺失答案）（缺失答案）（缺失答案）
    |'
- en: (missing explanation)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Interface + implementation 5
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 + 实现 5
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 这段代码是：（选择所有适用项）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案） | 它应该放在：（缺失答案）（缺失答案）（缺失答案）
    |'
- en: (missing explanation)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Interface + implementation 6
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 + 实现 6
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 这段代码是：（选择所有适用项）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案） | 它应该放在：（缺失答案）（缺失答案）（缺失答案）
    |'
- en: (missing explanation)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: Java interfaces help us formalize the idea of an abstract data type as a set
    of operations that must be supported by a type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Java接口帮助我们将抽象数据类型的概念正式化为一组必须由类型支持的操作。
- en: This helps make our code…
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于使我们的代码……
- en: '**Safe from bugs.** An ADT is defined by its operations, and interfaces do
    just that. When clients use an interface type, static checking ensures that they
    only use methods defined by the interface. If the implementation class exposes
    other methods — or worse, has visible representation — the client can’t accidentally
    see or depend on them. When we have multiple implementations of a data type, interfaces
    provide static checking of the method signatures.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全免受错误。** ADT由其操作定义，接口正是如此。当客户端使用接口类型时，静态检查确保他们仅使用接口定义的方法。如果实现类暴露其他方法 — 或者更糟糕的是，有可见的表示
    — 客户端无法意外看到或依赖它们。当我们有多个数据类型的实现时，接口提供方法签名的静态检查。'
- en: '**Easy to understand.** Clients and maintainers know exactly where to look
    for the specification of the ADT. Since the interface doesn’t contain instance
    fields or implementations of instance methods, it’s easier to keep details of
    the implementation out of the specifications.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解。** 客户端和维护者确切地知道在哪里查找ADT的规范。由于接口不包含实例字段或实例方法的实现，因此更容易将实现的细节排除在规范之外。'
- en: '**Ready for change.** We can easily add new implementations of a type by adding
    classes that implement interface. If we avoid constructors in favor of static
    factory methods, clients will only see the interface. That means we can switch
    which implementation class clients are using without changing their code at all.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备好变化。** 我们可以通过添加实现接口的类来轻松添加类型的新实现。如果我们避免构造函数而使用静态工厂方法，客户端将只看到接口。这意味着我们可以在不改变客户端代码的情况下切换客户端使用的实现类。'
