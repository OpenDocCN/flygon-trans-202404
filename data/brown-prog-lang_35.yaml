- en: 35Glossary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 35术语表
- en: ☞ bandwidth
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 带宽
- en: The bandwidth between two network nodes is the quantity of data that can be
    transferred in a unit of time between the nodes.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两个网络节点之间的带宽是在单位时间内可以在节点之间传输的数据量。
- en: ☞ cache
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 缓存
- en: 'A cache is an instance of a [☛ space-time tradeoff](#%28elem._glossary-space-time._tradeoff%29):
    it trades space for time by using the space to avoid recomputing an answer. The
    act of using a cache is called caching. The word “cache” is often used loosely;
    I use it only for information that can be perfectly reconstructed even if it were
    lost: this enables a program that needs to reverse the trade—<wbr>i.e., use less
    space in return for more time—<wbr>to do so safely, knowing it will lose no information
    and thus not sacrifice correctness.'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 缓存是[☛ 空间-时间折衷](#%28elem._glossary-space-time._tradeoff%29)的一个实例：它通过使用空间来避免重新计算答案，从而以时间换取空间。使用缓存的行为称为缓存。“缓存”这个词经常被泛泛地使用；我只用它来指代即使丢失了也可以完全重建的信息：这使得一个需要反向进行折衷的程序——即，以更少的空间换取更多时间的程序——可以安全地这样做，因为它不会丢失任何信息，因此不会损害正确性。
- en: ☞ coinduction
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 共同归纳
- en: Coinduction is a proof principle for mathematical structures that are equipped
    with methods of observation rather than of construction. Conversely, functions
    over inductive data take them apart; functions over coinductive data construct
    them. The [classic tutorial](http://www.cs.ru.nl/~bart/PAPERS/JR.pdf) on the topic
    will be useful to mathematically sophisticated readers.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 共同归纳是一种数学结构的证明原理，这些结构配备有观察方法而不是构造方法。相反，对归纳数据的函数会将其拆分；对共同归纳数据的函数会构造它们。关于这个主题的[经典教程](http://www.cs.ru.nl/~bart/PAPERS/JR.pdf)对数学上精通的读者很有用。
- en: ☞ idempotence
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 幂等性
- en: An idempotent operator is one whose repeated application to any value in its
    domain yields the same result as a single application (note that this implies
    the range is a subset of the domain). Thus, a function \(f\) is idempotent if,
    for all \(x\) in its domain, \(f(f(x)) = f(x)\) (and by induction this holds for
    additional applications of \(f\)).
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 幂等运算符是一种反复应用于其定义域中的任何值都会产生与单个应用相同结果的运算符（请注意，这意味着范围是定义域的子集）。因此，函数 \(f\) 如果对其定义域中的所有
    \(x\) 都成立 \(f(f(x)) = f(x)\) （通过归纳法，这也适用于 \(f\) 的额外应用）。
- en: ☞ invariants
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 不变量
- en: Invariants are assertions about programs that are intended to always be true
    (“in-vary-ant”—<wbr>never varying). For instance, a sorting routine may have as
    an invariant that the list it returns is sorted.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不变量是关于程序的断言，旨在始终为真（“不变的”—<wbr>从不变化）。例如，排序例程可能具有的不变量是返回的列表已排序。
- en: ☞ latency
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 延迟
- en: The latency between two network nodes is the time it takes for packets to get
    between the nodes.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两个网络节点之间的延迟是数据包在节点之间传输所需的时间。
- en: ☞ metasyntactic variable
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 元句法变量
- en: A metasyntactic variable is one that lives outside the language, and ranges
    over a fragment of syntax. For instance, if I write “for expressions e1 and e2,
    the sum e1 + e2”, I do not mean the programmer literally wrote “e1” in the program;
    rather I am using e1 to refer to whatever the programmer might write on the left
    of the addition sign. Therefore, e1 is metasyntax.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 元句法变量是存在于语言之外的变量，并且范围限定在语法片段之内。例如，如果我写道“对于表达式 e1 和 e2，求和 e1 + e2”，我并不是指程序员在程序中真正写了“e1”；而是我使用
    e1 来引用程序员可能在加法符号左边写的任何内容。因此，e1 是元语法。
- en: ☞ packed representation
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 紧凑表示
- en: At the machine level, a packed representation is one that ignores traditional
    alignment boundaries (in older or smaller machines, bytes; on most contemporary
    machines, words) to let multiple values fit inside or even spill over the boundary.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在机器级别，紧凑表示是指忽略传统的对齐边界（在旧的或较小的机器上为字节；在大多数现代机器上为字）以便让多个值适应或甚至溢出边界。
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For instance, say we wish to store a vector of four values, each of which represents
    one of four options. A traditional representation would store one value per alignment
    boundary, thereby consuming four units of memory. A packed representation would
    recognize that each value requires two bits, and four of them can fit into eight
    bits, so a single byte can hold all four values. Suppose instead we wished to
    store four values representing five options each, therefore requiring three bits
    for each value. A byte- or word-aligned representation would not fundamentally
    change, but the packed representation would use two bytes to store the twelve
    bits, even permitting the third value’s three bytes to be split across a byte
    boundary.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，假设我们希望存储一个包含四个值的向量，每个值代表四个选项中的一个。传统表示法会在每个对齐边界存储一个值，因此会消耗四个内存单元。紧凑表示法会意识到每个值需要两位，四个值可以放入八位中，因此一个字节可以容纳所有四个值。假设我们希望存储四个值，每个值代表五个选项，因此每个值需要三位。字节或字对齐的表示方式不会发生根本性变化，但紧凑表示法会使用两个字节来存储十二位，甚至允许第三个值的三个字节跨越字节边界。
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Of course, packed representations have a cost. Extracting the values requires
    more careful and complex operations. Thus, they represent a classic [☛ space-time
    tradeoff](#%28elem._glossary-space-time._tradeoff%29): using more time to shrink
    space consumption. More subtly, packed representations can confound certain run-time
    systems that may have expected data to be aligned.'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，紧凑表示法也有成本。提取值需要更加谨慎和复杂的操作。因此，它们代表了经典的[☛ 空间-时间权衡](#%28elem._glossary-space-time._tradeoff%29)：使用更多时间来缩小空间消耗。更微妙的是，紧凑表示法可能会使某些运行时系统困惑，因为它们可能期望数据被对齐。
- en: ☞ parsing
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 解析
- en: 'Parsing is, very broadly speaking, the act of converting content in one kind
    of structured input into content in another. The structures could be very similar,
    but usually they are quite different. Often, the input format is simple while
    the output format is expected to capture rich information about the content of
    the input. For instance, the input might be a linear sequence of chacters on an
    input stream, and the output might be expected to be a rich, tree-structured according
    to some datatype: most program and natural-language parsers are faced with this
    task.'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解析广义上讲是将一种结构化输入内容转换为另一种内容的行为。这些结构可能非常相似，但通常它们是完全不同的。通常，输入格式很简单，而输出格式则预计捕捉输入内容的丰富信息。例如，输入可能是输入流上的字符线性序列，而输出可能预计是根据某种数据类型的丰富、树形结构：大多数程序和自然语言解析器都面临这个任务。
- en: ☞ reduction
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 简化
- en: Reduction is a relationship between a pair of situations—<wbr>problems, functions,
    data structures, etc.—<wbr>where one is defined in terms of the other. A reduction
    R is a function from situations of the form P to ones of the form Q if, for every
    instance of P, R can construct an instance of Q such that it preserves the meaning
    of P. Note that the converse strictly does not need to hold.
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简化是一对情况（问题、函数、数据结构等）之间的关系，其中一个是根据另一个定义的。简化 R 是一个从形式为 P 的情况到形式为 Q 的情况的函数，如果对于
    P 的每个实例，R 都可以构造一个保留 P 意义的 Q 实例。请注意，反之不一定成立。
- en: ☞ space-time tradeoff
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 空间-时间权衡
- en: 'Suppose you have an expensive computation that always produces the same answer
    for a given set of inputs. Once you have computed the answer once, you now have
    a choice: store the answer so that you can simply look it up when you need it
    again, or throw it away and re-compute it the next time. The former uses more
    space, but saves time; the latter uses less space, but consumes more time. This,
    at its heart, is the space-time tradeoff. Memoization [REF], using a [☛ cache](#%28elem._glossary-cache%29),
    environments ([From Substitution to Environments](Interpreting_Functions.html#%28part._subst-to-env%29)),
    etc. are all instances of it.'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你有一个昂贵的计算，对于给定的一组输入总是产生相同的答案。一旦你计算出答案，你现在有一个选择：存储答案，这样当你再次需要时可以简单地查找它，或者丢弃它，下次重新计算。前者使用更多空间，但节省时间；后者使用更少空间，但消耗更多时间。这就是空间-时间权衡的核心。记忆化[REF]，使用[☛
    缓存](#%28elem._glossary-cache%29)，环境（[从替换到环境](Interpreting_Functions.html#%28part._subst-to-env%29)），等等都是其实例。
- en: ☞ type variable
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 类型变量
- en: Type variables are identifiers in the type language that (usually) range over
    actual types.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类型变量是类型语言中的标识符，通常涵盖实际类型。
- en: ☞ wire format
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ☞ 传输格式
- en: A notation used to transmit data across, as opposed to within, a closed platform
    (such as a virtual machine). These are usually expected to be relatively simple
    because they must be implemented in many languages and on weak processes. They
    are also expected to be unambiguous to aid simple, fast, and correct parsing.
    Popular examples include XML [REF], JSON [REF], and s-expressions [REF].
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于跨越而不是在封闭平台（如虚拟机）内部传输数据的一种表示法。这些表示法通常被期望相对简单，因为它们必须在许多语言和弱进程上实现。它们还应该是明确的，以帮助简单、快速和正确的解析。流行的例子包括
    XML [REF]、JSON [REF] 和 s-表达式 [REF]。
