- en: 11Interactive Games as Reactive Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 互动游戏作为反应系统
- en: '|     [11.1 About Reactive Animations](#%28part._.About_.Reactive_.Animations%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [11.1 关于反应式动画](#%28part._.About_.Reactive_.Animations%29) |'
- en: '|     [11.2 Preliminaries](#%28part._.Preliminaries%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [11.2 前提条件](#%28part._.Preliminaries%29) |'
- en: '|     [11.3 Version: Airplane Moving Across the Screen](#%28part._.Version__.Airplane_.Moving_.Across_the_.Screen%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [11.3 版本：飞机横穿屏幕移动](#%28part._.Version__.Airplane_.Moving_.Across_the_.Screen%29)
    |'
- en: '|       [11.3.1 Updating the World State](#%28part._.Updating_the_.World_.State%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [11.3.1 更新世界状态](#%28part._.Updating_the_.World_.State%29) |'
- en: '|       [11.3.2 Displaying the World State](#%28part._.Displaying_the_.World_.State%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [11.3.2 显示世界状态](#%28part._.Displaying_the_.World_.State%29) |'
- en: '|       [11.3.3 Observing Time (and Combining the Pieces)](#%28part._.Observing_.Time__and_.Combining_the_.Pieces_%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [11.3.3 观察时间（以及组合各部分）](#%28part._.Observing_.Time__and_.Combining_the_.Pieces_%29)
    |'
- en: '|     [11.4 Version: Wrapping Around](#%28part._.Version__.Wrapping_.Around%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|     [11.4 版本：环绕](#%28part._.Version__.Wrapping_.Around%29) |'
- en: '|     [11.5 Version: Descending](#%28part._.Version__.Descending%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|     [11.5 版本：下降](#%28part._.Version__.Descending%29) |'
- en: '|       [11.5.1 Moving the Airplane](#%28part._.Moving_the_.Airplane%29) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [11.5.1 移动飞机](#%28part._.Moving_the_.Airplane%29) |'
- en: '|       [11.5.2 Drawing the Scene](#%28part._.Drawing_the_.Scene%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|       [11.5.2 绘制场景](#%28part._.Drawing_the_.Scene%29) |'
- en: '|       [11.5.3 Finishing Touches](#%28part._.Finishing_.Touches%29) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [11.5.3 收尾工作](#%28part._.Finishing_.Touches%29) |'
- en: '|     [11.6 Version: Responding to Keystrokes](#%28part._.Version__.Responding_to_.Keystrokes%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|     [11.6 版本：响应按键](#%28part._.Version__.Responding_to_.Keystrokes%29) |'
- en: '|     [11.7 Version: Landing](#%28part._.Version__.Landing%29) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|     [11.7 版本：着陆](#%28part._.Version__.Landing%29) |'
- en: '|     [11.8 Version: A Fixed Balloon](#%28part._.Version__.A_.Fixed_.Balloon%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|     [11.8 版本：一个固定的气球](#%28part._.Version__.A_.Fixed_.Balloon%29) |'
- en: '|     [11.9 Version: Keep Your Eye on the Tank](#%28part._.Version__.Keep_.Your_.Eye_on_the_.Tank%29)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|     [11.9 版本：留意油箱](#%28part._.Version__.Keep_.Your_.Eye_on_the_.Tank%29)
    |'
- en: '|     [11.10 Version: The Balloon Moves, Too](#%28part._.Version__.The_.Balloon_.Moves__.Too%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|     [11.10 版本：气球也在移动](#%28part._.Version__.The_.Balloon_.Moves__.Too%29)
    |'
- en: '|     [11.11 Version: One, Two, ..., Ninety-Nine Luftballons!](#%28part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_%29)
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|     [11.11 版本：一，二，......，九十九个气球！](#%28part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_%29)
    |'
- en: In this tutorial we’re going to write a little interactive game. The game won’t
    be sophisticated, but it’ll have all the elements you need to build much richer
    games of your own.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将编写一个小型交互式游戏。 游戏不会很复杂，但它将具有构建自己更丰富游戏所需的所有元素。
- en: 'Imagine we have an airplane coming in to land. It’s unfortunately trying to
    do so amidst a hot-air balloon festival, so it naturally wants to avoid colliding
    with any (moving) balloons. In addition, there is both land and water, and the
    airplane needs to alight on land. We might also equip it with limited amounts
    of fuel to complete its task. Here are some animations of the game:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们有一架飞机要着陆。 不幸的是，它正试图在一个热气球节期间这样做，所以自然而然地想要避免与任何（移动的）气球相撞。此外，既有陆地又有水域，飞机需要在陆地上降落。我们可能还会为其配备有限的燃料来完成任务。以下是游戏的一些动画：
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v9-success.swf](http://world.cs.brown.edu/1/projects/flight-lander/v9-success.swf)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v9-success.swf](http://world.cs.brown.edu/1/projects/flight-lander/v9-success.swf)'
- en: The airplane comes in to land succcessfully.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 飞机成功着陆。
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v9-collide.swf](http://world.cs.brown.edu/1/projects/flight-lander/v9-collide.swf)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v9-collide.swf](http://world.cs.brown.edu/1/projects/flight-lander/v9-collide.swf)'
- en: Uh oh—<wbr>the airplane collides with a balloon!
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 噢——<wbr>飞机与气球相撞！
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v9-sink.swf](http://world.cs.brown.edu/1/projects/flight-lander/v9-sink.swf)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v9-sink.swf](http://world.cs.brown.edu/1/projects/flight-lander/v9-sink.swf)'
- en: Uh oh—<wbr>the airplane lands in the water!
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 噢——<wbr>飞机降落在水里！
- en: 'By the end, you will have written all the relevant portions of this program.
    Your program will: animate the airplane to move autonomously; detect keystrokes
    and adjust the airplane accordingly; have multiple moving balloons; detect collisions
    between the airplane and balloons; check for landing on water and land; and account
    for the use of fuel. Phew: that’s a lot going on! Therefore, we won’t write it
    all at once; instead, we’ll build it up bit-by-bit. But we’ll get there by the
    end.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到最后，你将编写这个程序的所有相关部分。你的程序将：使飞机自主移动；检测按键并相应调整飞机；有多个移动的气球；检测飞机和气球之间的碰撞；检查是否降落在水和陆地上；并考虑燃料的使用。哦，这涉及到很多事情！因此，我们不会一次性写完所有内容；相反，我们将逐步构建。但最终我们会完成的。
- en: 11.1About Reactive Animations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1关于反应性动画
- en: 'We are writing a program with two important interactive elements: it is an
    animation, meaning it gives the impression of motion, and it is reactive, meaning
    it responds to user input. Both of these can be challenging to program, but Pyret
    provides a simple mechanism that accommodates both and integrates well with other
    programming principles such as testing. We will learn about this as we go along.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写一个具有两个重要交互元素的程序：它是一个动画，意味着它给人以运动的印象，它是反应性的，意味着它对用户输入做出响应。这两者都可能很难编程，但
    Pyret 提供了一个简单的机制，可以同时适应这两者，并与其他编程原则（如测试）很好地集成。我们将在学习过程中了解这一点。
- en: 'The key to creating an animation is the Movie Principle. Even in the most sophisticated
    movie you can watch, there is no motion (indeed, the very term “movie”—<wbr>short
    for “moving picture”—<wbr>is a clever bit of false advertising). Rather, there
    is just a sequence of still images shown in rapid succession, relying on the human
    brain to create the impression of motion. We are going to exploit the same idea:
    our animations will consist of a sequence of individual images, and we will ask
    Pyret to show these in rapid succession. We will then see how reactivity folds
    into the same process.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动画的关键是电影原理。即使在你观看的最复杂的电影中，也没有运动（事实上，“电影”这个术语——<wbr>缩写为“moving picture”——<wbr>是一个巧妙的虚假广告）。相反，只是一系列快速连续显示的静止图像，依靠人类大脑产生运动的印象。我们将利用相同的想法：我们的动画将由一系列单独的图像组成，我们将要求
    Pyret 快速连续显示这些图像。然后我们将看到反应性如何融入同一过程中。
- en: 11.2Preliminaries
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2准备工作
- en: 'To begin with, we should inform Pyret that we plan to make use of both images
    and animations. We load the libraries as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该告诉 Pyret 我们打算使用图像和动画。我们加载库如下：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tells Pyret to load to these two libraries and bind the results to the
    corresponding names, I and W. Thus, all image operations are obtained from I and
    animation operations from W.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Pyret 加载这两个库并将结果绑定到相应的名称 I 和 W。因此，所有图像操作都来自 I，动画操作来自 W。
- en: '11.3Version: Airplane Moving Across the Screen'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3版本：飞机横穿屏幕移动
- en: 'We will start with the simplest version: one in which the airplane moves horizontally
    across the screen. Watch this video:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的版本开始：飞机在屏幕上水平移动。观看这个视频：
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v1.swf](http://world.cs.brown.edu/1/projects/flight-lander/v1.swf)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v1.swf](http://world.cs.brown.edu/1/projects/flight-lander/v1.swf)'
- en: First, here’s an image of an airplane:Have fun finding your preferred airplane
    image! But don’t spend too long on it, because we’ve still got a lot of work to
    do.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一架飞机的图像：找到你喜欢的飞机图像！但不要花太多时间在上面，因为我们还有很多工作要做。
- en: '[http://world.cs.brown.edu/1/clipart/airplane-small.png](http://world.cs.brown.edu/1/clipart/airplane-small.png)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/clipart/airplane-small.png](http://world.cs.brown.edu/1/clipart/airplane-small.png)'
- en: 'We can tell Pyret to load this image and give it a name as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以告诉 Pyret 加载这个图像并给它一个名称如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Henceforth, when we refer to AIRPLANE, it will always refer to this image. (Try
    it out in the interactions area!)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们提到飞机时，它将始终指代这个图像。（在交互区域试试吧！）
- en: Now look at the video again. Watch what happens at different points in time.
    What stays the same, and what changes? What’s common is the water and land, which
    stay the same. What changes is the (horizontal) position of the airplane.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再看一次视频。观察不同时间点发生的事情。什么保持不变，什么发生了变化？共同之处是水和陆地，它们保持不变。发生变化的是飞机的（水平）位置。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The World State consists of everything that changes. Things that stay the same
    do not need to get recorded in the World State.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 世界状态包括一切变化的事物。保持不变的事物不需要记录在世界状态中。
- en: 'We can now define our first World State:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的第一个世界状态：
- en: World Definition
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 世界定义
- en: The World State is a number, representing the x-position of the airplane.
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 世界状态是一个数字，表示飞机的x位置。
- en: Observe something important above.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上面的一些重要事项。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When we record a World State, we don’t capture only the type of the values,
    but also their intended meaning.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们记录世界状态时，我们不仅捕获值的类型，还捕获它们的预期含义。
- en: 'Now we have a representation of the core data, but to generate the above animation,
    we still have to do several things:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了核心数据的表示，但是要生成上述动画，我们仍然需要做一些事情：
- en: Ask to be notified of the passage of time.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求在时间流逝时通知您。
- en: As time passes, correspondingly update the World State.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着时间的推移，相应地更新世界状态。
- en: Given an updated World State, produce the corresponding visual display.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定更新的世界状态，生成相应的视觉显示。
- en: This sounds like a lot! Fortunately, Pyret makes this much easier than it sounds.
    We’ll do these in a slightly different order than listed above.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是很多！幸运的是，Pyret使这比听起来容易得多。我们将以略有不同的顺序进行这些操作，而不是按照上面列出的顺序。
- en: 11.3.1Updating the World State
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 更新世界状态
- en: As we’ve noted, the airplane doesn’t actually “move”. Rather, we can ask Pyret
    to notify us every time a clock ticks ([REF]). If on each tick we place the airplane
    in an appropriately different position, and the ticks happen often enough, we
    will get the impression of motion.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所指出的，飞机实际上并没有“移动”。相反，我们可以要求Pyret在每次时钟滴答（[REF]）时通知我们。如果在每个滴答中我们以适当不同的位置放置飞机，并且滴答发生得足够频繁，我们将得到运动的印象。
- en: 'Because the World State consists of just the airplane’s x-position, to move
    it to the right, we simply increment its value. Let’s first give this constant
    distance a name:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因为世界状态只包括飞机的x位置，所以要将其向右移动，我们只需增加其值。让我们首先给这个恒定的距离起个名字：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will need to write a function that reflects this movement. Let’s first write
    some test cases:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要编写一个反映此移动的函数。让我们首先编写一些测试用例：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The function’s definition is now clear:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数的定义很清楚了：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And sure enough, Pyret will confirm that this function passes all of its tests.Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，Pyret将确认此函数是否通过了其所有测试。注意
- en: 'If you have prior experience programming animations and reactive programs,
    you will immediately notice an important difference: it’s easy to test parts of
    your program in Pyret!'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您有编程动画和响应式程序的先验经验，您会立即注意到一个重要的区别：在Pyret中很容易测试程序的各个部分！
- en: 11.3.2Displaying the World State
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 显示世界状态
- en: 'Now we’re ready to draw the game’s visual output. We produce an image that
    consists of all the necessary components. It first helps to define some constants
    representing the visual output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备绘制游戏的视觉输出。我们生成一个包含所有必要组件的图像。首先帮助定义一些表示视觉输出的常量：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using these, we can create a blank canvas, and overlay rectangles representing
    water and land:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些，我们可以创建一个空白画布，并覆盖表示水和陆地的矩形：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Examine the value of BACKGROUND in the interactions area to confirm that it
    looks right.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 检查交互区域中背景的值，以确认它看起来是否正确。
- en: Do Now!
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The reason we divide by two when placing BASE is because Pyret puts the middle
    of the image at the given location. Remove the division and see what happens to
    the resulting image.
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们放置基地时，将其除以二是因为Pyret将图像的中心放在给定的位置。删除该除法，看看结果图像会发生什么。
- en: 'Now that we know how to get our background, we’re ready to place the airplane
    on it. The expression to do so looks roughly like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何获得我们的背景了，我们准备将飞机放在上面。执行此操作的表达式大致如下：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'but what x position do we use? Actually, that’s just what the World State represents!
    So we create a function out of this expression:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们要使用什么x位置呢？实际上，这就是世界状态所代表的！所以我们根据这个表达式创建一个函数：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 11.3.3Observing Time (and Combining the Pieces)
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 观察时间（并组合这些部分）
- en: 'Finally, we’re ready to put these pieces together. We invoke a function called
    big-bang, which creates animations. big-bang needs to be given an initial World
    State as well as handlers that tell it how to react. Specifying on-tick tells
    Pyret to run a clock and, every time the clock ticks (roughly thirty times a second),
    invoke the associated handler. The to-draw handler is used by Pyret to refresh
    the visual display. Thus:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备将这些部分组合在一起。我们调用一个名为big-bang的函数，它创建动画。 big-bang需要提供一个初始世界状态以及告诉它如何反应的处理程序。指定on-tick告诉Pyret运行一个时钟，并且每次时钟滴答（大约每秒三十次）时调用相关的处理程序。
    to-draw处理程序由Pyret用于刷新可视显示。因此：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: creates a running program where the airplane flies across the background!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个运行程序，飞机在背景中飞行！
- en: That’s it! We’ve created our first animation. Now that we’ve gotten all the
    preliminaries out of the way, we can go about enhancing it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们创建了我们的第一个动画。既然我们已经把所有的准备工作都做好了，我们可以开始增强它了。
- en: Exercise
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want the airplane to appear to move faster, what can you change?
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你希望飞机看起来移动得更快，你可以改变什么？
- en: '11.4Version: Wrapping Around'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4版本：环绕
- en: 'When you run the preceding program, you’ll notice that after a while, the airplane
    just disappears. This is because it has gone past the right edge of the screen;
    it is still being “drawn”, but in a location that you cannot see. That’s not very
    useful!Also, after a long while you might get an error because the computer is
    being asked to draw the airplane at a location beyond what the graphics system
    can manage. Instead, when the airplane is about to go past the right edge of the
    screen, we’d like it to reappear on the left by a corresponding amount: “wrapping
    around”, as it were.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行上述程序时，你会注意到过了一会儿，飞机就消失了。这是因为它已经超过了屏幕的右边缘；它仍在“被绘制”，但是在你看不到的位置。这不太有用！另外，过了一段时间后，您可能会收到错误提示，因为计算机要求在图形系统无法管理的位置绘制飞机。相反，当飞机即将超过屏幕的右边缘时，我们希望它以相应的量重新出现在左边：“环绕”，如同。
- en: 'Here’s the video for this version:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此版本的视频：
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v2.swf](http://world.cs.brown.edu/1/projects/flight-lander/v2.swf)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v2.swf](http://world.cs.brown.edu/1/projects/flight-lander/v2.swf)'
- en: Let’s think about what we need to change. Clearly, we need to modify the function
    that updates the airplane’s location, since this must now reflect our decision
    to wrap around. But the task of how to draw the airplane doesn’t need to change
    at all! Similarly, the definition of the World State does not need to change,
    either.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想想我们需要改变什么。显然，我们需要修改更新飞机位置的函数，因为现在这必须反映我们决定循环的决定。但是绘制飞机的任务根本不需要改变！同样，世界状态的定义也不需要改变。
- en: 'Therefore, we only need to modify move-airplane-x-on-tick. The function num-modulo
    does exactly what we need. That is, we want the x-location to always be modulo
    the width of the scene:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要修改move-airplane-x-on-tick。函数num-modulo正是我们需要的。也就是说，我们希望x位置始终对场景的宽度取模：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that, instead of copying the content of the previous definition we can
    simply reuse it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以简单地重用上一个定义的内容，而不是复制它的内容：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'which makes our intent clearer: compute whatever position we would have had
    before, but adapt the coordinate to remain within the scene’s width.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们的意图更加清晰：计算我们之前可能有的任何位置，但适应坐标以保持在场景宽度内。
- en: 'Well, that’s a proposed re-definition. Be sure to test this function thoroughly:
    it’s tricker than you might think! Have you thought about all the cases? For instance,
    what happens if the airplane is half-way off the right edge of the screen?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个提出的重新定义。一定要彻底测试这个函数：它比你想的要棘手！你考虑过所有情况吗？例如，如果飞机正好在屏幕右边缘的一半怎么办？
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to leave move-airplane-x-on-tick unchanged and perform the modular
    arithmetic in place-airplane-x instead. We choose not to do that for the following
    reason. In this version, we really do think of the airplane as circling around
    and starting again from the left edge (imagine the world is a cylinder...). Thus,
    the airplane’s x-position really does keep going back down. If instead we allowed
    the World State to increase monotonically, then it would really be representing
    the total distance traveled, contradicting our definition of the World State.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以保持不变move-airplane-x-on-tick并在place-airplane-x中执行模数运算。我们选择不这样做的原因如下。在这个版本中，我们真的认为飞机是在周围盘旋并从左边缘重新开始（想象世界是一个圆柱体...）。因此，飞机的x位置确实会不断回落。如果相反地，我们允许世界状态单调增加，那么它实际上将表示已行进的总距离，这与我们对世界状态的定义相矛盾。
- en: '11.5Version: Descending'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5版本：下降
- en: 'Of course, we need our airplane to move in more than just one dimension: to
    get to the final game, it must both ascend and descend as well. For now, we’ll
    focus on the simplest version of this, which is a airplane that continuously descends.
    Here’s a video:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要我们的飞机在更多的维度上移动：为了到达最终的游戏，它必须上升和下降。现在，我们将专注于这个最简单的版本，即持续下降的飞机。这是一个视频：
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v3.swf](http://world.cs.brown.edu/1/projects/flight-lander/v3.swf)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v3.swf](http://world.cs.brown.edu/1/projects/flight-lander/v3.swf)'
- en: Let’s again consider individual frames of this video. What’s staying the same?
    Once again, the water and the land. What’s changing? The position of the airplane.
    But, whereas before the airplane moved only in the x-dimension, now it moves in
    both x and y. That immediately tells us that our definition of the World State
    is inadequate, and must be modified.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑这个视频的各个帧。什么是不变的？再次是水和陆地。什么在变化？飞机的位置。但是，以前飞机只在x维度移动，现在它在x和y两个维度上移动。这立即告诉我们，我们对世界状态的定义是不充分的，必须修改。
- en: 'We therefore define a new structure to hold this pair of data:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义一个新的结构来保存这对数据：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Given this, we can revise our definition:World Definition
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以修改我们的定义：世界定义
- en: The World State is a posn, representing the x-position and y-position of the
    airplane on the screen.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 世界状态是一个位置，表示飞机在屏幕上的x位置和y位置。
- en: 11.5.1Moving the Airplane
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动飞机
- en: 'First, let’s consider move-airplane-wrapping-x-on-tick. Previously our airplane
    moved only in the x-direction; now we want it to descend as well, which means
    we must add something to the current y value:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑move-airplane-wrapping-x-on-tick。以前我们的飞机只在x方向移动；现在我们希望它也下降，这意味着我们必须向当前y值添加一些内容：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s write some test cases for the new function. Here’s one:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为新函数编写一些测试用例。这是其中一个：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another way to write the test would be:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写测试的方法是：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Which method of writing tests is better? Both! They each offer different advantages:'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪种编写测试的方法更好？都好！它们各自提供不同的优势：
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The former method has the benefit of being very concrete: there’s no question
    what you expect, and it demonstrates that you really can compute the desired answer
    from first principles.'
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一种方法的好处在于非常具体：你期望什么没有疑问，并且它表明你确实可以从第一原理计算出所需的答案。
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The latter method has the advantage that, if you change the constants in your
    program (such as the rate of descent), seemingly correct tests do not suddenly
    fail. That is, this form of testing is more about the relationships between things
    rather than their precise values.
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后一种方法的优势在于，如果您更改程序中的常量（例如下降速率），看似正确的测试不会突然失败。也就是说，这种形式的测试更多地涉及事物之间的关系，而不是它们的精确值。
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There is one more choice available, which often combines the best of both worlds:
    write the answer as concretely as possible (the former style), but using constants
    to compute the answer (the advantage of the latter style). For instance:'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有另一种选择，通常结合了两种方法的优点：尽可能具体地编写答案（前一种风格），但使用常量来计算答案（后一种风格的优势）。例如：
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Exercise
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before you proceed, have you written enough test cases? Are you sure? Have you,
    for instance, tested what should happen when the airplane is near the edge of
    the screen in either or both dimensions? We thought not—<wbr>go back and write
    more tests before you proceed!
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在继续之前，你写了足够的测试用例吗？你确定吗？例如，你测试过飞机在屏幕边缘时应该发生什么情况吗？我们觉得没有 —— 在继续之前回去写更多的测试吧！
- en: 'Using the design recipe, now define move-airplane-xy-on-tick. You should end
    up with something like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计配方，现在定义move-airplane-xy-on-tick。你应该得到类似这样的东西：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that we have reused the existing function for the x-dimension and, correspondingly,
    created a helper for the y dimension:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们重新使用了现有函数的x维度，并相应地为y维度创建了一个辅助函数：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This may be slight overkill for now, but it does lead to a cleaner separation
    of concerns, and makes it possible for the complexity of movement in each dimension
    to evolve independently while keeping the code relatively readable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这可能有点过分，但它确实导致了责任分离的更清晰，使得每个维度的运动复杂性可以独立演变，同时保持代码相对可读性。
- en: 11.5.2Drawing the Scene
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制场景
- en: 'We have to also examine and update place-airplane-x. Our earlier definition
    placed the airplane at an arbitrary y-coordinate; now we have to take the y-coordinate
    from the World State: fun place-airplane-xy(w): I.place-image(AIRPLANE, w.x, w.y,
    BACKGROUND) end Notice that we can’t really reuse the previous definition because
    it hard-coded the y-position, which we must now make a parameter.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还必须检查并更新place-airplane-x。我们之前的定义将飞机放在一个任意的y坐标上；现在我们必须从世界状态中取得y坐标：fun place-airplane-xy(w):
    I.place-image(AIRPLANE, w.x, w.y, BACKGROUND) end 请注意，我们实际上不能重用以前的定义，因为它硬编码了y位置，而我们现在必须将其作为参数。'
- en: 11.5.3Finishing Touches
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完善细节
- en: 'Are we done? It would seem so: we’ve examined all the procedures that consume
    and produce World State and updated them appropriately. Actually, we’re forgetting
    one small thing: the initial World State given to big-bang! If we’ve changed the
    definition of World State, then we need to reconsider this parameter, too. (We
    also need to pass the new handlers rather than the old ones.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了吗？看起来是这样：我们已经检查了所有消耗和产生世界状态的过程，并相应地更新了它们。实际上，我们忘了一件小事：big-bang给出的初始世界状态！如果我们改变了世界状态的定义，那么我们也需要重新考虑这个参数。（我们还需要传递新的处理程序而不是旧的处理程序。）
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exercise
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s a little unsatisfactory to have the airplane truncated by the screen. You
    can use I.image-width and I.image-height to obtain the dimensions of an image,
    such as the airplane. Use these to ensure the airplane fits entirely within the
    screen for the initial scene, and similarly in move-airplane-xy-on-tick.
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 飞机被屏幕截断有点不尽如人意。您可以使用 I.image-width 和 I.image-height 获取图像（如飞机）的尺寸。在初始场景中确保飞机完全适合屏幕，并在
    move-airplane-xy-on-tick 中同样如此。
- en: '11.6Version: Responding to Keystrokes'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6版本：响应按键
- en: 'Now that we have the airplane descending, there’s no reason it can’t ascend
    as well. Here’s a video:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让飞机下降，它也没有理由不能上升。这是一个视频：
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v4.swf](http://world.cs.brown.edu/1/projects/flight-lander/v4.swf)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v4.swf](http://world.cs.brown.edu/1/projects/flight-lander/v4.swf)'
- en: 'We’ll use the keyboard to control its motion: specifically, the up-key will
    make it move up, while the down-key will make it descend even faster. This is
    easy to support using what we already know: we just need to provide one more handler
    using W.on-key. This handler takes two arguments: the first is the current value
    of the world, while the second is a representation of which key was pressed. For
    the purposes of this program, the only key values we care about are "up" and "down".'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用键盘来控制它的运动：具体来说，按下上键将使其向上移动，而按下下键将使其更快地下降。使用我们已经知道的知识很容易支持这一点：我们只需要使用 W.on-key
    提供另一个处理程序。这个处理程序接受两个参数：第一个是世界的当前值，第二个是表示按下的键的表示。对于这个程序来说，我们关心的唯一键值是 "up" 和 "down"。
- en: 'Let’s define a constant representing how much distance a key represents:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个常量来表示按键代表多少距离：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can define a function that alter’s the airplane’s position by that distance
    depending on which key is pressed:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义一个函数，根据按下的键的不同改变飞机的位置：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Do Now!
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就去做吧！
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this function definition contain
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么这个函数定义包含
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: as its last condition?
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为它的最后一个条件？
- en: Notice that if we receive any key other than the two we expect, we leave the
    World State as it was; from the user’s perspective, this has the effect of just
    ignoring the keystroke. Remove this last clause, press some other key, and watch
    what happens!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们收到的键不是我们期望的两个键之一，我们将保持世界状态不变；从用户的角度来看，这就等效于忽略按键。删除这最后一条子句，按下其他键，看看会发生什么！
- en: No matter what you choose, be sure to test this! Can the airplane drift off
    the top of the screen? How about off the screen at the bottom? Can it overlap
    with the land or water?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择什么，一定要测试一下！飞机会不会漂移到屏幕的顶部？底部的屏幕呢？它会与陆地或水重叠吗？
- en: 'Once we’ve written and thoroughly tested this function, we simply need to ask
    Pyret to use it to handle keystrokes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写并彻底测试了这个函数，我们只需要要求 Pyret 使用它来处理按键：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now your airplane moves not only with the passage of time but also in response
    to your keystrokes. You can keep it up in the air forever!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的飞机不仅随着时间的流逝而移动，还会对你的按键作出响应。你可以让它永远保持在空中！
- en: '11.7Version: Landing'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7版本：着陆
- en: 'Remember that the objective of our game is to land the airplane, not to keep
    it airborne indefinitely. That means we need to detect when the airplane reaches
    the land or water level and, when it does, terminate the animation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们游戏的目标是让飞机着陆，而不是让它无限期地保持在空中。这意味着我们需要检测飞机何时达到陆地或水平面，并在达到时终止动画：
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v5.swf](http://world.cs.brown.edu/1/projects/flight-lander/v5.swf)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v5.swf](http://world.cs.brown.edu/1/projects/flight-lander/v5.swf)'
- en: 'First, let’s try to characterize when the animation should halt. This means
    writing a function that consumes the current World State and produces a boolean
    value: true if the animation should halt, false otherwise. This requires a little
    arithmetic based on the airplane’s size:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试描述动画何时应该停止。这意味着编写一个函数，接受当前的世界状态并产生一个布尔值：如果动画应该停止，则为 true，否则为 false。这需要一点基于飞机大小的算术：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also inform Pyret to use this predicate to automatically halt the animation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以告诉 Pyret 使用这个谓词自动停止动画：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Exercise
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you test this, you’ll see it isn’t quite right because it doesn’t take
    account of the size of the airplane’s image. As a result, the airplane only halts
    when it’s half-way into the land or water, not when it first touches down. Adjust
    the formula so that it halts upon first contact.
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你测试这个时，你会发现它不太正确，因为它没有考虑到飞机图像的大小。结果，飞机只有在进入陆地或水域一半时才会停止，而不是在第一次接触时停止。调整公式，使其在第一次接触时停止。
- en: Exercise
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend this so that the airplane rolls for a while upon touching land, decelerating
    according to the laws of physics.
  id: totrans-176
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将此扩展，使飞机在接触陆地后滚动一段时间，根据物理定律减速。
- en: Exercise
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose the airplane is actually landing at a secret subterranean airbase. The
    actual landing strip is actually below ground level, and opens up only when the
    airplane comes in to land. That means, after landing, only the parts of the airplane
    that stick above ground level would be visible. Implement this. As a hint, consider
    modifying place-airplane-xy.
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设飞机实际上正在降落到一个秘密的地下空军基地。实际的着陆跑道实际上在地面以下，并且只有当飞机着陆时才会打开。这意味着，着陆后，只有突出地面以上的飞机部分才会可见。实现这个。作为提示，考虑修改
    place-airplane-xy。
- en: '11.8Version: A Fixed Balloon'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8版本：一个固定的气球
- en: 'Now let’s add a balloon to the scene. Here’s a video of the action:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在场景中添加一个气球。这是一个动作的视频：
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v6.swf](http://world.cs.brown.edu/1/projects/flight-lander/v6.swf)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v6.swf](http://world.cs.brown.edu/1/projects/flight-lander/v6.swf)'
- en: 'Notice that while the airplane moves, everything else—<wbr>including the balloon—<wbr>stays
    immobile. Therefore, we do not need to alter the World State to record the balloon’s
    position. All we need to do is alter the conditions under which the program halts:
    effectively, there is one more situation under which it terminates, and that is
    a collision with the balloon.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当飞机移动时，一切都——包括气球——保持静止。因此，我们不需要改变世界状态来记录气球的位置。我们需要做的只是改变程序终止的条件：实际上，有一种情况下它会终止，那就是与气球碰撞。
- en: 'When does the game halt? There are now two circumstances: one is contact with
    land or water, and the other is contact with the balloon. The former remains unchanged
    from what it was before, so we can focus on the latter.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏何时终止？现在有两种情况：一种是与陆地或水域接触，另一种是与气球接触。前者与之前的情况相同，因此我们可以专注于后者。
- en: 'Where is the balloon, and how do we represent where it is? The latter is easy
    to answer: that’s what posns are good for. As for the former, we can decide where
    it is:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 气球在哪里，我们如何表示它在哪里？后者很容易回答：这就是 posns 的用处。至于前者，我们可以决定它在哪里：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'or we can let Pyret pick a random position:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以让 Pyret 选择一个随机位置：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exercise
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Improve the random placement of the balloon so that it is in credible spaces
    (e.g., not submerged).
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 改进气球的随机放置，使其位于可信的空间（例如，不要被淹没）。
- en: 'Given a position for the balloon, we just need to detect collision. One simple
    way is as follows: determine whether the distance between the airplane and the
    balloon is within some threshold:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 给定气球的位置，我们只需要检测碰撞。一种简单的方法是：确定飞机和气球之间的距离是否在某个阈值内：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'where COLLISION-THRESHOLD is some suitable constant computed based on the sizes
    of the airplane and balloon images. (For these particular images, 75 works pretty
    well.)What is distance? It consumes two posns and determines the Euclidean distance
    between them:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 COLLISION-THRESHOLD 是根据飞机和气球图像的大小计算出的某个合适的常数。（对于这些特定图像，75效果非常好。）距离是什么？它接受两个
    posns 并确定它们之间的欧几里德距离：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we have to weave together the two termination conditions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将两个终止条件编织在一起：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'and use it instead:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用它代替：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Do Now!
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see how to write game-ends more concisely?
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你看到如何更简洁地编写游戏结束了吗？
- en: 'Here’s another version:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个版本：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '11.9Version: Keep Your Eye on the Tank'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.9版本：保持眼睛在油箱上
- en: Now we’ll introduce the idea of fuel. In our simplified world, fuel isn’t necessary
    to descend—<wbr>gravity does that automatically—<wbr>but it is needed to climb.
    We’ll assume that fuel is counted in whole number units, and every ascension consumes
    one unit of fuel. When you run out of fuel, the program no longer response to
    the up-arrow, so you can no longer avoid either the balloon or water.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍燃料的概念。在我们简化的世界中，燃料不是下降所必需的—<wbr>重力会自动做到—<wbr>但它是爬升所需的。我们假设燃料以整数单位计数，并且每次上升都会消耗一单位的燃料。当你耗尽燃料时，程序不再响应向上箭头，因此你将无法避开气球或水。
- en: In the past, we’ve looked at still images of the game video to determine what
    is changing and what isn’t. For this version, we could easily place a little gauge
    on the screen to show the quantity of fuel left. However, we don’t on purpose,
    to illustrate a principle.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们曾查看游戏视频的静止图像，以确定什么在变化，什么不在变化。对于这个版本，我们可以很容易地在屏幕上放置一个小表来显示剩余燃料的数量。但我们故意没有这样做，以说明一个原则。
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can’t always determine what is fixed and what is changing just by looking
    at the image. You have to also read the problem statement carefully, and think
    about it in depth.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不能仅仅通过观察图像来确定什么是固定的，什么是变化的。你还必须仔细阅读问题陈述，并深入思考。
- en: 'It’s clear from our description that there are two things changing: the position
    of the airplane and the quantity of fuel left. Therefore, the World State must
    capture the current values of both of these. The fuel is best represented as a
    single number. However, we do need to create a new structure to represent the
    combination of these two.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的描述中可以清楚地看出，有两件事情在变化：飞机的位置和剩余燃料的数量。因此，世界状态必须捕捉这两者的当前值。燃料最好表示为一个单一的数字。然而，我们确实需要创建一个新的结构来表示这两者的组合。
- en: World Definition
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 世界定义
- en: The World State is a structure representing the airplane’s current position
    and the quantity of fuel left.
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 世界状态是一个表示飞机当前位置和剩余燃料量的结构。
- en: 'Concretely, we will use this structure:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将使用这个结构：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Exercise
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We could have also defined the World to be a structure consisting of three
    components: the airplane’s x-position, the airplane’s y-position, and the quantity
    of fuel. Why do we choose to use the representation above?'
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们也可以将世界定义为由三个组件组成的结构：飞机的 x 位置，飞机的 y 位置和燃料的数量。为什么我们选择使用上面的表示形式？
- en: We can again look at each of the parts of the program to determine what can
    stay the same and what changes. Concretely, we must focus on the functions that
    consume and produce Worlds.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次查看程序的每个部分，以确定什么可以保持不变，什么需要改变。具体来说，我们必须关注消耗和产生世界的函数。
- en: 'On each tick, we consume a world and compute one. The passage of time does
    not consume any fuel, so this code can remain unchanged, other than having to
    create a structure containing the current amount of fuel. Concretely:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个滴答声中，我们消耗一个世界并计算一个世界。时间的流逝不消耗任何燃料，因此这段代码可以保持不变，除了必须创建一个包含当前燃料量的结构之外。具体来说：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, the function that responds to keystrokes clearly needs to take into
    account how much fuel is left:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，响应按键的功能明显需要考虑剩余燃料的多少：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Exercise
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Updating the function that renders a scene. Recall that the world has two fields;
    one of them corresponds to what we used to draw before, and the other isn’t being
    drawn in the output.
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更新渲染场景的函数。请记住，世界有两个字段；其中一个对应于我们以前绘制的内容，而另一个不会在输出中显示。
- en: Exercise
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend your program to draw a fuel gauge.
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扩展你的程序以绘制燃料表。
- en: '11.10Version: The Balloon Moves, Too'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.10 版本：气球也移动了。
- en: 'Until now we’ve left our balloon immobile. Let’s now make the game more interesting
    by letting the balloon move, as this video shows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的气球一直是静止的。让我们通过让气球移动来使游戏更加有趣，正如这个视频所示：
- en: '[http://world.cs.brown.edu/1/projects/flight-lander/v8.swf](http://world.cs.brown.edu/1/projects/flight-lander/v8.swf)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://world.cs.brown.edu/1/projects/flight-lander/v8.swf](http://world.cs.brown.edu/1/projects/flight-lander/v8.swf)'
- en: Obviously, the balloon’s location needs to also become part of the World State.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，气球的位置也需要成为世界状态的一部分。
- en: World Definition
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 世界定义
- en: The World State is a structure representing the plane’s current position, the
    balloon’s current position, and the quantity of fuel left.
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 世界状态是一个表示飞机当前位置、气球当前位置和剩余燃料量的结构。
- en: 'Here is a representation of the world state:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是世界状态的表示：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this definition, we obviously need to re-write all our previous definitions.
    Most of this is quite routine relative to what we’ve seen before. The only detail
    we haven’t really specified is how the balloon is supposed to move: in what direction,
    at what speed, and what to do at the edges. We’ll let you use your imagination
    for this one! (Remember that the closer the balloon is to land, the harder it
    is to safely land the plane.)We thus have to modify:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，我们显然需要重新编写我们所有以前的定义。相对于我们之前看到的内容，这大部分是相当例行的。我们真正没有详细说明的唯一细节是气球应该如何移动：向什么方向、以多快的速度以及在边缘时该怎么做。我们将让你自己想象一下！（记住，气球越靠近陆地，安全着陆飞机就越困难。）因此，我们必须修改：
- en: The background image (to remove the static balloon).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景图像（去除静态气球）。
- en: The drawing handler (to draw the balloon at its position).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制处理程序（用于在其位置绘制气球）。
- en: The timer handler (to move the balloon as well as the airplane).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时处理程序（移动气球以及飞机）。
- en: The key handler (to construct world data that leaves the balloon unchanged).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键处理程序（构造使气球保持不变的世界数据）。
- en: The termination condition (to account for the balloon’s dynamic location).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止条件（考虑到气球的动态位置）。
- en: Exercise
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify each of the above functions, along with their test cases.
  id: totrans-245
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改上述每个函数及其测试用例。
- en: '11.11Version: One, Two, ..., Ninety-Nine Luftballons!'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.11版本：一个，两个，……，九十九个彩色气球！
- en: Finally, there’s no need to limit ourselves to only one balloon. How many is
    right? Two? Three? Ten? ... Why fix any one number? It could be a balloon festival!![](../Images/b215747783cfd450a745d171bb0bb796.jpg)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们没有必要限制自己只有一个气球。多少个合适？两个？三个？十个？……为什么要固定任何一个数字？它可以是一个气球节日！[](../Images/b215747783cfd450a745d171bb0bb796.jpg)
- en: Albuquerque Balloon Fiesta
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔伯克基气球节
- en: Similarly, many games have levels that become progressively harder; we could
    do the same, letting the number of balloons be part of what changes across levels.
    However, there is conceptually no big difference between having two balloons and
    five; the code to control each balloon is essentially the same.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，许多游戏有逐渐变难的关卡；我们也可以这样做，让气球数量成为跨级别变化的一部分。然而，拥有两个气球和五个气球在概念上没有太大区别；控制每个气球的代码本质上是相同的。
- en: 'We need to represent a collection of balloons. We can use a list to represent
    them. Thus:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要表示一系列气球。我们可以使用列表来表示它们。因此：
- en: World Definition
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 世界定义
- en: The World State is a structure representing the plane’s current position, a
    list of balloon positions, and the quantity of fuel left.
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 世界状态是一个表示飞机当前位置、气球位置列表和剩余燃料数量的结构。
- en: You should now use the design recipe for lists of structures to rewrite the
    functions. Notice that you’ve already written the function to move one balloon.
    What’s left?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该使用结构列表的设计方案重写这些函数。注意，你已经编写了移动一个气球的函数。还剩下什么？
- en: Apply the same function to each balloon in the list.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对列表中的每个气球应用相同的函数。
- en: Determine what to do if two balloons collide.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定两个气球碰撞时该怎么办。
- en: For now, you can avoid the latter problem by placing each balloon sufficiently
    spread apart along the x-dimension and letting them move only up and down.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以通过沿 x 维度充分分开放置每个气球并让它们只能上下移动来避免后一个问题。
- en: Exercise
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduce a concept of wind, which affects balloons but not the airplane. Afer
    random periods of time, the wind blows with random speed and direction, causing
    the ballooons to move laterally.
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 引入风的概念，它影响气球但不影响飞机。在随机时间段后，风以随机速度和方向吹动，导致气球横向移动。
