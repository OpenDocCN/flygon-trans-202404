- en: '"Why use F#?" in one page'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一页上了解“为什么使用 F#？”
- en: Although F# is great for specialist areas such as scientific or data analysis,
    it is also an excellent choice for enterprise development. Here are five good
    reasons why you should consider using F# for your next project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 F# 在科学或数据分析等专业领域表现出色，但它也是企业开发的一个极好选择。以下是您考虑在下一个项目中使用 F# 的五个好理由。
- en: '![](glyphicons_030_pencil.png) Conciseness'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '![](glyphicons_030_pencil.png) 简洁性'
- en: F# is not cluttered up with [coding "noise"](fvsc-sum-of-squares.html) such
    as curly brackets, semicolons and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: F# 没有被 [编码的“噪音”](fvsc-sum-of-squares.html) 所混淆，例如花括号、分号等。
- en: You almost never have to specify the type of an object, thanks to a powerful
    [type inference system](conciseness-type-inference.html).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于强大的 [类型推断系统](conciseness-type-inference.html)，你几乎不需要指定对象的类型。
- en: And, compared with C#, it generally takes [fewer lines of code](fvsc-download.html)
    to solve the same problem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 相比，通常需要 [更少的代码行](fvsc-download.html) 来解决相同的问题。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](glyphicons_343_thumbs_up.png) Convenience'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '![](glyphicons_343_thumbs_up.png) 便利性'
- en: Many common programming tasks are much simpler in F#. This includes things like
    creating and using [complex type definitions](conciseness-type-definitions.html),
    doing [list processing](conciseness-extracting-boilerplate.html), [comparison
    and equality](convenience-types.html), [state machines](designing-with-types-representing-states.html),
    and much more.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的编程任务在 F# 中都要简单得多。这包括创建和使用 [复杂的类型定义](conciseness-type-definitions.html)，进行
    [列表处理](conciseness-extracting-boilerplate.html)，[比较和相等性](convenience-types.html)，[状态机](designing-with-types-representing-states.html)等等。
- en: And because functions are first class objects, it is very easy to create powerful
    and reusable code by creating functions that have [other functions as parameters](conciseness-extracting-boilerplate.html),
    or that [combine existing functions](conciseness-functions-as-building-blocks.html)
    to create new functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是第一类对象，通过创建具有 [其他函数作为参数的函数](conciseness-extracting-boilerplate.html)，或者
    [组合现有函数](conciseness-functions-as-building-blocks.html) 来创建新功能非常容易实现强大且可重用的代码。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](glyphicons_150_check.png) Correctness'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '![](glyphicons_150_check.png) 正确性'
- en: F# has a [powerful type system](correctness-type-checking.html) which prevents
    many common errors such as [null reference exceptions](the-option-type.html#option-is-not-null).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: F# 拥有 [强大的类型系统](correctness-type-checking.html)，可以防止许多常见错误，如 [空引用异常](the-option-type.html#option-is-not-null)。
- en: Values are [immutable by default](correctness-immutability.html), which prevents
    a large class of errors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，值是 [不可变的](correctness-immutability.html)，这可以防止大量的错误。
- en: In addition, you can often encode business logic using the [type system](correctness-exhaustive-pattern-matching.html)
    itself in such a way that it is actually [impossible to write incorrect code](designing-for-correctness.html)
    or mix up [units of measure](units-of-measure.html), greatly reducing the need
    for unit tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以经常使用 [类型系统](correctness-exhaustive-pattern-matching.html) 对业务逻辑进行编码，使得编写不正确的代码或混淆
    [度量单位](units-of-measure.html) 实际上变得 [不可能](designing-for-correctness.html)，从而大大减少了单元测试的需求。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](glyphicons_054_clock.png) Concurrency'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '![](glyphicons_054_clock.png) 并发性'
- en: F# has a number of built-in libraries to help when more than one thing at a
    time is happening. Asynchronous programming is [very easy](concurrency-async-and-parallel.html),
    as is parallelism.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: F# 有许多内置库可以帮助处理同时发生的多个事情。异步编程 [非常容易](concurrency-async-and-parallel.html)，并行编程也是如此。
- en: F# also has a built-in [actor model](concurrency-actor-model.html), and excellent
    support for event handling and [functional reactive programming](concurrency-reactive.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: F# 还具有内置的 [actor 模型](concurrency-actor-model.html)，以及出色的事件处理和 [函数式响应式编程](concurrency-reactive.html)
    支持。
- en: And of course, because data structures are immutable by default, sharing state
    and avoiding locks is much easier.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于数据结构默认是不可变的，因此共享状态和避免锁定要容易得多。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](glyphicons_280_settings.png) Completeness'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '![](glyphicons_280_settings.png) 完备性'
- en: Although it is a functional language at heart, F# does support other styles
    which are not 100% pure, which makes it much easier to interact with the non-pure
    world of web sites, databases, other applications, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本质上是一种函数式语言，F# 也支持其他不是 100% 纯粹的风格，这使得它与非纯净的网站、数据库、其他应用程序等进行交互变得更加容易。
- en: In particular, F# is designed as a hybrid functional/OO language, so it can
    do [virtually everything that C# can do](completeness-anything-csharp-can-do.html).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，F# 被设计为一种混合函数式/OO语言，因此它可以做 [几乎和 C# 一样的事情](completeness-anything-csharp-can-do.html)。
- en: Of course, F# is [part of the .NET ecosystem](completeness-seamless-dotnet-interop.html),
    which gives you seamless access to all the third party .NET libraries and tools.
    It runs on most platforms, including Linux and smart phones (via Mono and the
    new .NET Core).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，F# 是 [.NET 生态系统的一部分](completeness-seamless-dotnet-interop.html)，这使您可以无缝访问所有第三方
    .NET 库和工具。它可以在大多数平台上运行，包括 Linux 和智能手机（通过 Mono 和新的 .NET Core）。
- en: Finally, it is well integrated with Visual Studio (Windows) and Xamarin (Mac),
    which means you get a great IDE with IntelliSense support, a debugger, and many
    plug-ins for unit tests, source control, and other development tasks. Or on Linux,
    you can use the MonoDevelop IDE instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它与 Visual Studio（Windows）和 Xamarin（Mac）很好地集成，这意味着您可以获得一个带有 IntelliSense 支持、调试器和许多插件用于单元测试、源代码控制和其他开发任务的优秀
    IDE。或者在 Linux 上，您可以使用 MonoDevelop IDE。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The "Why Use F#?" series
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “为什么使用 F#？”系列
- en: The following series of posts demonstrates each of these F# benefits, using
    standalone snippets of F# code (and often with C# code for comparison).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列文章演示了 F# 的每个优势，使用独立的 F# 代码片段（通常与 C# 代码进行比较）。
- en: '[Introduction to the ''Why use F#'' series](why-use-fsharp-intro.html). An
    overview of the benefits of F#'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么使用 F# 系列介绍](why-use-fsharp-intro.html)。F# 的好处概述'
- en: '[F# syntax in 60 seconds](fsharp-in-60-seconds.html). A very quick overview
    on how to read F# code'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[60秒内了解 F# 语法](fsharp-in-60-seconds.html)。如何快速浏览 F# 代码'
- en: '[Comparing F# with C#: A simple sum](fvsc-sum-of-squares.html). In which we
    attempt to sum the squares from 1 to N without using a loop'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用 F# 比较 C#: 简单求和](fvsc-sum-of-squares.html)。在这里我们尝试对从 1 到 N 的平方求和而不使用循环'
- en: '[Comparing F# with C#: Sorting](fvsc-quicksort.html). In which we see that
    F# is more declarative than C#, and we are introduced to pattern matching.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用 F# 比较 C#: 排序](fvsc-quicksort.html)。在这里我们看到 F# 比 C# 更具声明性，并且介绍了模式匹配。'
- en: '[Comparing F# with C#: Downloading a web page](fvsc-download.html). In which
    we see that F# excels at callbacks, and we are introduced to the ''use'' keyword'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用 F# 比较 C#: 下载网页](fvsc-download.html)。在这里我们看到 F# 擅长回调，并介绍了“use”关键字'
- en: '[Four Key Concepts](key-concepts.html). The concepts that differentiate F#
    from a standard imperative language'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[四个关键概念](key-concepts.html)。区分 F# 与标准命令式语言的概念'
- en: '[Conciseness](conciseness-intro.html). Why is conciseness important?'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简洁性](conciseness-intro.html)。为什么简洁性很重要？'
- en: '[Type inference](conciseness-type-inference.html). How to avoid getting distracted
    by complex type syntax'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型推断](conciseness-type-inference.html)。如何避免被复杂的类型语法分散注意力'
- en: '[Low overhead type definitions](conciseness-type-definitions.html). No penalty
    for making new types'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[低开销的类型定义](conciseness-type-definitions.html)。创建新类型没有任何惩罚'
- en: '[Using functions to extract boilerplate code](conciseness-extracting-boilerplate.html).
    The functional approach to the DRY principle'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用函数提取样板代码](conciseness-extracting-boilerplate.html)。DRY 原则的函数式方法'
- en: '[Using functions as building blocks](conciseness-functions-as-building-blocks.html).
    Function composition and mini-languages make code more readable'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数用作构建块](conciseness-functions-as-building-blocks.html)。函数组合和迷你语言使代码更易读'
- en: '[Pattern matching for conciseness](conciseness-pattern-matching.html). Pattern
    matching can match and bind in a single step'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用于简洁性的模式匹配](conciseness-pattern-matching.html)。模式匹配可以在一步中匹配和绑定'
- en: '[Convenience](convenience-intro.html). Features that reduce programming drudgery
    and boilerplate code'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[便利性](convenience-intro.html)。减少编程枯燥和样板代码的特性'
- en: '[Out-of-the-box behavior for types](convenience-types.html). Immutability and
    built-in equality with no coding'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型的即插即用行为](convenience-types.html)。不需要编码的不可变性和内置相等性'
- en: '[Functions as interfaces](convenience-functions-as-interfaces.html). OO design
    patterns can be trivial when functions are used'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数用作接口](convenience-functions-as-interfaces.html)。当使用函数时，OO 设计模式可以变得微不足道'
- en: '[Partial Application](convenience-partial-application.html). How to fix some
    of a function''s parameters'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[部分应用](convenience-partial-application.html)。如何固定函数的一些参数'
- en: '[Active patterns](convenience-active-patterns.html). Dynamic patterns for powerful
    matching'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[活动模式](convenience-active-patterns.html)。强大匹配的动态模式'
- en: '[Correctness](correctness-intro.html). How to write ''compile time unit tests'''
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正确性](correctness-intro.html)。如何编写“编译时单元测试”'
- en: '[Immutability](correctness-immutability.html). Making your code predictable'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[不可变性](correctness-immutability.html)。使��的代码可预测'
- en: '[Exhaustive pattern matching](correctness-exhaustive-pattern-matching.html).
    A powerful technique to ensure correctness'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[穷尽模式匹配](correctness-exhaustive-pattern-matching.html)。确保正确性的强大技术'
- en: '[Using the type system to ensure correct code](correctness-type-checking.html).
    In F# the type system is your friend, not your enemy'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用类型系统确保正确的代码](correctness-type-checking.html)。在 F# 中，类型系统是你的朋友，而不是敌人'
- en: '[Worked example: Designing for correctness](designing-for-correctness.html).
    How to make illegal states unrepresentable'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：为正确性设计](designing-for-correctness.html)。如何使非法状态不可表示'
- en: '[Concurrency](concurrency-intro.html). The next major revolution in how we
    write software?'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[并发性](concurrency-intro.html)。我们编写软件的下一个重大革命？'
- en: '[Asynchronous programming](concurrency-async-and-parallel.html). Encapsulating
    a background task with the Async class'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[异步编程](concurrency-async-and-parallel.html)。使用 Async 类封装后台任务'
- en: '[Messages and Agents](concurrency-actor-model.html). Making it easier to think
    about concurrency'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消息和代理](concurrency-actor-model.html)。让并发思考变得更容易'
- en: '[Functional Reactive Programming](concurrency-reactive.html). Turning events
    into streams'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数式响应式编程](concurrency-reactive.html)。将事件转化为流'
- en: '[Completeness](completeness-intro.html). F# is part of the whole .NET ecosystem'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[完整性](completeness-intro.html)。F# 是整个 .NET 生态系统的一部分'
- en: '[Seamless interoperation with .NET libraries](completeness-seamless-dotnet-interop.html).
    Some convenient features for working with .NET libraries'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[与 .NET 库无缝互操作](completeness-seamless-dotnet-interop.html)。与 .NET 库一起工作的一些便利功能'
- en: '[Anything C# can do...](completeness-anything-csharp-can-do.html). A whirlwind
    tour of object-oriented code in F#'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C# 能做的任何事情...](completeness-anything-csharp-can-do.html)。在 F# 中进行面向对象编程的快速浏览'
- en: '[Why use F#: Conclusion](why-use-fsharp-conclusion.html).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么使用 F#：结论](why-use-fsharp-conclusion.html)。'
