- en: An introduction to property-based testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性基本测试简介
- en: An introduction to property-based testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性基本测试简介
- en: This post is part of the [F# Advent Calendar in English 2014](https://sergeytihon.wordpress.com/2014/11/24/f-advent-calendar-in-english-2014/)
    project. Check out all the other great posts there! And special thanks to Sergey
    Tihon for organizing this.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这篇文章是[F# Advent Calendar in English 2014](https://sergeytihon.wordpress.com/2014/11/24/f-advent-calendar-in-english-2014/)项目的一部分。去那里查看所有其他精彩的帖子！特别感谢Sergey
    Tihon组织这个项目。
- en: '*UPDATE: I did a talk on property-based testing based on these posts. [Slides
    and video here.](http://fsharpforfunandprofit.com/pbt/)*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新：我根据这些帖子做了一个关于属性基本测试的演讲。[幻灯片和视频在这里。](http://fsharpforfunandprofit.com/pbt/)'
- en: 'Let''s start with a discussion that I hope never to have:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个我希望永远不要发生的讨论开始：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But seriously, my imaginary co-worker''s complaint has some validity: **How
    many tests are enough?**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但是说真的，我的想象中的同事的抱怨有些合理：**多少测试才够？**
- en: So now imagine that rather than being a developer, you are a test engineer who
    is responsible for testing that the "add" function is implemented correctly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在想象一下，你不是一名开发人员，而是一名负责测试“add”函数是否正确实现的测试工程师。
- en: Unfortunately for you, the implementation is being written by a burned-out,
    always lazy and often malicious programmer, who I will call *The Enterprise Developer
    From Hell*, or "EDFH". (The EDFH has a [cousin who you might have heard of](https://en.wikipedia.org/wiki/Bastard_Operator_From_Hell)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，该实现是由一位疲惫不堪、总是懒惰而且经常恶意的程序员编写的，我将其称为*地狱企业开发者*，简称“EDFH”。（EDFH有一个[你可能听说过的表兄弟](https://en.wikipedia.org/wiki/Bastard_Operator_From_Hell)）。
- en: You are practising test-driven-development, enterprise-style, which means that
    you write a test, and then the EDFH implements code that passes the test.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在练习企业级的测试驱动开发，这意味着你编写一个测试，然后EDFH实现通过测试的代码。
- en: 'So you start with a test like this (using vanilla NUnit style):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你从一个像这样的测试开始（使用原始的NUnit风格）：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The EDFH then implements the `add` function like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，EDFH像这样实现`add`函数：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And your test passes!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试通过了！
- en: When you complain to the EDFH, they say that they are doing TDD properly, and
    only [writing the minimal code that will make the test pass](http://www.typemock.com/test-driven-development-tdd/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向EDFH抱怨时，他们说他们正在正确地进行TDD，只[编写最小的代码来使测试通过](http://www.typemock.com/test-driven-development-tdd/)。
- en: 'Fair enough. So you write another test:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 说得有道理。所以你又写了一个测试：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The EDFH then changes the implementation of the `add` function to this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，EDFH将`add`函数的实现更改为这样：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you again complain to the EDFH, they point out that this approach is actually
    a best practice. Apparently it's called ["The Transformation Priority Premise"](http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次向EDFH抱怨时，他们指出这种方法实际上是最佳实践。显然，这被称为["变换优先原则"](http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html)。
- en: At this point, you start thinking that the EDFH is being malicious, and that
    this back-and-forth could go on forever!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你开始认为EDFH是恶意的，这种来回可能会永远持续下去！
- en: Beating the malicious programmer
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打败恶意程序员
- en: So the question is, what kind of test could you write so that a malicious programmer
    could not create an incorrect implementation, even if they wanted to?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题是，你可以写什么样的测试，以至于一个恶意的程序员即使想要也无法创建一个不正确的实现？
- en: Well, you could start with a much larger list of known results, and mix them
    up a bit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你可以从一个更大的已知结果列表开始，然后再稍微混合一下。
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But the EDFH is tireless, and will update the implementation to include all
    of these cases as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是EDFH是不知疲倦的，将更新实现以包括所有这些情况。
- en: A much better approach is to generate random numbers and use those for inputs,
    so that a malicious programmer could not possibly know what to do in advance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是生成随机数并将其用于输入，以便恶意程序员无法提前知道该怎么做。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the test looks like this, then the EDFH will be *forced* to implement the
    `add` function correctly!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试看起来像这样，那么EDFH将被*迫*正确实现`add`函数！
- en: One final improvement -- the EDFH might just get lucky and have picked numbers
    that work by chance, so let's repeat the random number test a number of times,
    say 100 times.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个改进--EDFH可能只是走运，选出的数字碰巧有效，所以让我们重复随机数测试多次，比如说100次。
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So now we're done!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们完成了！
- en: Or are we?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们？
- en: Property based testing
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性基本测试
- en: There's just one problem. In order to test the `add` function, you're making
    use of the `+` function. In other words, you are using one implementation to test
    another.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个问题。为了测试`add`函数，你正在使用`+`函数。换句话说，你正在使用一个实现来测试另一个实现。
- en: In some cases that is acceptable (see the use of "test oracles" in a following
    post), but in general, it's a bad idea to have your tests duplicate the code that
    you are testing! It's a waste of time and effort, and now you have two implementations
    to build and keep up to date.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下这是可以接受的（请参见后面一篇文章中“测试预言”的用法），但一般来说，让你的测试重复你正在测试的代码是一个坏主意！这是浪费时间和精力，现在你有两个实现要构建和维护。
- en: So if you can't test by using `+`, how *can* you test?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能通过使用`+`来测试，那么*如何*测试呢？
- en: The answer is to create tests that focus on the *properties* of the function
    -- the "requirements". These properties should be things that are true for *any*
    correct implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是创建专注于函数的*属性*--“要求”的测试。这些属性应该是*任何*正确实现都为真的事情。
- en: So let's think about what the properties of an `add` function are.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们思考一下`add`函数的属性是什么。
- en: One way of getting started is to think about how `add` differs from other similar
    functions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开始的一种方法是思考`add`与其他类似函数的不同之处。
- en: So for example, what is the difference between `add` and `subtract`? Well, for
    `subtract`, the order of the parameters makes a difference, while for `add` it
    doesn't.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`add`和`subtract`之间有什么区别？对于`subtract`，参数的顺序很重要，而对于`add`则不是。
- en: So there's a good property to start with. It doesn't depend on addition itself,
    but it does eliminate a whole class of incorrect implementations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个很好的起点属性。它不依赖于加法本身，但它消除了一整类不正确的实现。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's a good start, but it doesn't stop the EDFH. The EDFH could still implement
    `add` using `x * y` and this test would pass!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的开始，但这并不能阻止EDFH。EDFH仍然可以使用`x * y`来实现`add`，而这个测试会通过！
- en: So now what about the difference between `add` and `multiply`? What does addition
    really mean?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在`add`和`multiply`之间的区别是什么？加法真正意味着什么？
- en: 'We could start by testing with something like this, which says that `x + x`
    should the same as `x * 2`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从类似这样的测试开始，即`x + x`应该等于`x * 2`：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But now we are assuming the existence of multiplication! Can we define a property
    that *only* depends on `add` itself?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们假设了乘法的存在！我们能定义一个*仅*依赖于`add`本身的属性吗？
- en: One very useful approach is to see what happens when the function is repeated
    more than once. That is, what if you `add` and then `add` to the result of that?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的方法是看看当函数重复多次时会发生什么。也就是说，如果你先`add`然后再对结果进行`add`会怎样？
- en: 'That leads to the idea that two `add 1`s is the same as one `add 2`. Here''s
    the test:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了两个`add 1`等于一个`add 2`的想法。这是测试：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's great! `add` works perfectly with this test, while `multiply` doesn't.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！`add`与这个测试完美配合，而`multiply`则不行。
- en: However, note that the EDFH could still implement `add` using `y - x` and this
    test would pass!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，EDFH仍然可以使用`y - x`来实现`add`，而这个测试会通过！
- en: Luckily, we have the "parameter order" test above as well. So the combination
    of both of these tests should narrow it down so that there is only one correct
    implementation, surely?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们上面还有“参数顺序”测试。因此这两个测试的结合应该将其缩小到只有一个正确的实现，对吧？
- en: 'After submitting this test suite we find out the EDFH has written an implementation
    that passes both these tests. Let''s have a look:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 提交了这个测试套件后，我们发现EDFH编写了一个通过这两个测试的实现。让我们看看：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Aarrghh! What happened? Where did our approach go wrong?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 啊啊啊！发生了什么？我们的方法错在哪里了？
- en: Well, we forgot to force the implementation to actually use the random numbers
    we were generating!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我们忘记了强制实现实际使用我们生成的随机数！
- en: So we need to ensure that the implementation does indeed *do* something with
    the parameters that are passed into it. We're going to have to check that the
    result is somehow connected to the input in a specific way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要确保实现确实*使用*传递给它的参数。我们将不得不检查结果与输入以特定方式相关联。
- en: Is there a trivial property of `add` that we know the answer to without reimplementing
    our own version?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否知道`add`的一个微不足道的特性，而无需重新实现我们自己的版本就能得到答案？
- en: Yes!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！
- en: What happens when you add zero to a number? You always get the same number back.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将零加到一个数字时会发生什么？你总是得到相同的数字。
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So now we have a set of properties that can be used to test any implementation
    of `add`, and that force the EDFH to create a correct implementation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一组属性，可以用来测试`add`的任何实现，并强制EDFH创建一个正确的实现：
- en: Refactoring the common code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构通用代码
- en: There's quite a bit of duplicated code in these three tests. Let's do some refactoring.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个测试中有相当多的重复代码。让我们做些重构。
- en: First, we'll write a function called `propertyCheck` that does the work of generating
    100 pairs of random ints.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个名为`propertyCheck`的函数，该函数将生成100对随机整数。
- en: '`propertyCheck` will also need a parameter for the property itself. This will
    be a function that takes two ints and returns a bool:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`propertyCheck`还将需要一个用于属性本身的参数。这将是一个接受两个整数并返回布尔值的函数：'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this in place, we can redefine one of the tests by pulling out the property
    into a separate function, like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基础，我们可以通过将属性提取到一个单独的函数中来重新定义一个测试，就像这样：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can also do the same thing for the other two properties.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对其他两个属性做同样的事情。
- en: 'After the refactoring, the complete code looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重构之后，完整的代码如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Reviewing what we have done so far
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾我们到目前为止所做的工作
- en: 'We have defined a set of properties that any implementation of `add` should
    satisfy:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了任何`add`实现都应满足的一组属性：
- en: The parameter order doesn't matter ("commutativity" property)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数顺序无关紧要（“交换性”属性）
- en: Doing `add` twice with 1 is the same as doing `add` once with 2
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用1两次进行`add`与一次用2进行`add`是相同的
- en: Adding zero does nothing ("identity" property)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加零什么也不做（“单位元”属性）
- en: What's nice about these properties is that they work with *all* inputs, not
    just special magic numbers. But more importantly, they show us the core essence
    of addition.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的好处在于它们适用于*所有*输入，而不仅仅是特殊的魔法数字。但更重要的是，它们向我们展示了加法的核心本质。
- en: In fact, you can take this approach to the logical conclusion and actually *define*
    addition as anything that has these properties.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以将这种方法推到逻辑的极致，实际上*定义*加法为具有这些属性的任何东西。
- en: This is exactly what mathematicians do. If you look up [addition on Wikipedia](https://en.wikipedia.org/wiki/Addition#Properties),
    you'll see that it is defined entirely in terms of commutativity, associativity,
    identity, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是数学家所做的。如果你查阅 [维基百科上的加法](https://en.wikipedia.org/wiki/Addition#Properties)，你会看到它完全是根据可交换性、结合性、单位元等来定义的。
- en: You'll note that in our experiment, we missed defining "associativity", but
    instead created a weaker property (`x+1+1 = x+2`). We'll see later that the EDFH
    can indeed write a malicious implementation that satisfies this property, and
    that associativity is better.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的实验中，我们错过了定义“结合性”，而是创建了一个更弱的属性（`x+1+1 = x+2`）。我们稍后将看到，EDFH确实可以编写一个满足此属性的恶意实现，并且结合性更好。
- en: Alas, it's hard to get properties perfect on the first attempt, but even so,
    by using the three properties we came up with, we have got a much higher confidence
    that the implementation is correct, and in fact, we have learned something too
    -- we have understood the requirements in a deeper way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，第一次尝试很难完美地得到属性，但即使如此，通过使用我们提出的三个属性，我们对实现的正确性有了更高的信心，实际上，我们也学到了一些东西——我们更深入地理解了要求。
- en: Specification by properties
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性规范
- en: A collection of properties like this can be considered a *specification*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的一组属性可以被视为*规范*。
- en: Historically, unit tests, as well as being functional tests, have been [used
    as a sort of specification](https://en.wikipedia.org/wiki/Unit_testing#Documentation)
    as well. But an approach to specification using properties instead of tests with
    "magic" data is an alternative which I think is often shorter and less ambiguous.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，单元测试除了是功能测试外，还被 [用作一种规范的一种方式](https://en.wikipedia.org/wiki/Unit_testing#Documentation)。但是，使用属性而不是带有“魔法”数据的测试的规范方法是一种我认为通常更短且更少歧义的替代方法。
- en: You might be thinking that only mathematical kinds of functions can be specified
    this way, but in future posts, we'll see how this approach can be used to test
    web services and databases too.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为只有数学类型的函数才能以这种方式进行规范，但在未来的文章中，我们将看到这种方法如何用于测试Web服务和数据库。
- en: Of course, not every business requirement can be expressed as properties like
    this, and we must not neglect the social component of software development. [Specification
    by example](https://en.wikipedia.org/wiki/Specification_by_example) and domain
    driven design can play a valuable role when working with non-technical customers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非每个业务需求都可以像这样表示为属性，我们也不应忽视软件开发的社交组成部分。[例如规范](https://en.wikipedia.org/wiki/Specification_by_example)和领域驱动设计在与非技术客户合作时可以发挥重要作用。
- en: You also might be thinking that designing all these properties is a lot of work
    -- and you'd be right! It is the hardest part. In a follow-up post, I'll present
    some tips for coming up with properties which might reduce the effort somewhat.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能也在考虑设计所有这些属性是很多工作--您是对的！这是最困难的部分。在���续帖子中，我将提供一些有助于减少工作量的属性设计提示。
- en: But even with the extra effort involved upfront (the technical term for this
    activity is called "thinking about the problem", by the way) the overall time
    saved by having automated tests and unambigous specifications will more than pay
    for the upfront cost later.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在前期涉及额外的努力（这种活动的技术术语叫做“思考问题”）后，通过拥有自动化测试和明确的规范来节省的整体时间将远远超过后期的前期成本。
- en: In fact, the arguments that are used to promote the benefits of unit testing
    can equally well be applied to property-based testing! So if a TDD fan tells you
    that they don't have the time to come up with property-based tests, then they
    might not be looking at the big picture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，用来宣传单元测试好处的论点同样适用于基于属性的测试！因此，如果一个TDD粉丝告诉你他们没有时间想出基于属性的测试，那么他们可能没有看到全局。
- en: Introducing QuickCheck and FsCheck
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入QuickCheck和FsCheck
- en: 'We have implemented our own property checking system, but there are quite a
    few problems with it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了自己的属性检查系统，但存在一些问题：
- en: It only works with integer functions. It would be nice if we could use the same
    approach for functions that had string parameters, or in fact any type of parameter,
    including ones we defined ourselves.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只适用于整数函数。如果我们可以对具有字符串参数的函数或实际上任何类型的参数（包括我们自己定义的参数）使用相同的方法就好了。
- en: It only works with two parameter functions (and we had to ignore one of them
    for the `adding1TwiceIsAdding2OnceProperty` and `identity` properties). It would
    be nice if we could use the same approach for functions with any number of parameters.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只适用于具有两个参数的函数（我们不得不忽略其中一个参数对于`adding1TwiceIsAdding2OnceProperty`和`identity`属性）。如果我们可以对具有任意数量参数的函数使用相同的方法就好了。
- en: When there is a counter-example to the property, we don't know what it is! Not
    very helpful when the tests fail!
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性存在反例时，我们不知道是什么！当测试失败时并不是很有帮助！
- en: There's no logging of the random numbers that we generated, and there's no way
    to set the seed, which means that we can't debug and reproduce errors easily.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们生成的随机数没有记录，也没有设置种子的方法，这意味着我们无法轻松调试和重现错误。
- en: It's not configurable. For example, we can't easily change the number of loops
    from 100 to something else.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不可配置。例如，我们不能轻松地将循环次数从100更改为其他值。
- en: It would be nice if there was a framework that did all that for us!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个框架可以为我们做所有这些就好了！
- en: Thankfully there is! The ["QuickCheck"](https://en.wikipedia.org/wiki/QuickCheck)
    library was originally developed for Haskell by Koen Claessen and John Hughes,
    and has been ported to many other languages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是有的！["QuickCheck"](https://en.wikipedia.org/wiki/QuickCheck)库最初是由Koen Claessen和John
    Hughes为Haskell开发的，并已移植到许多其他语言。
- en: The version of QuickCheck used in F# (and C# too) is the excellent ["FsCheck"](https://fsharp.github.io/FsCheck/)
    library created by Kurt Schelfthout. Although based on the Haskell QuickCheck,
    it has some nice additional features, including integration with test frameworks
    such as NUnit and xUnit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#（以及C#）中使用的QuickCheck版本是由Kurt Schelfthout创建的优秀的["FsCheck"](https://fsharp.github.io/FsCheck/)库。虽然基于Haskell
    QuickCheck，但它具有一些不错的附加功能，包括与NUnit和xUnit等测试框架的集成。
- en: So let's look at how FsCheck would do the same thing as our homemade property-testing
    system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看FsCheck如何执行与我们自制的属性测试系统相同的操作。
- en: Using FsCheck to test the addition properties
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FsCheck测试加法属性
- en: First, you need to install FsCheck and load the DLL (FsCheck can be a bit finicky
    -- see the bottom of this page for instructions and troubleshooting).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装FsCheck并加载DLL（FsCheck可能有点挑剔--请参阅本页底部的说明和故障排除）。
- en: 'The top of your script file should look something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您的脚本文件顶部应该看起来像这样：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once FsCheck is loaded, you can use `Check.Quick` and pass in any "property"
    function. For now, let's just say that a "property" function is any function (with
    any parameters) that returns a boolean.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了 FsCheck，你可以使用`Check.Quick`并传入任何“属性”函数。暂时来说，让我们说“属性”函数是任何返回布尔值的函数（带有任何参数）。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you check one of the properties interactively, say with `Check.Quick commutativeProperty`,
    you''ll see the message:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你交互式地检查其中一个属性，比如使用`Check.Quick commutativeProperty`，你会看到消息：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using FsCheck to find unsatified properties
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 FsCheck 找到不满足的属性
- en: Let's see what happens when we have a malicious implementation of `add`. In
    the code below, the EDFH implements `add` as multiplication!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们有一个恶意实现的`add`时会发生什么。在下面的代码中，EDFH 将`add`实现为乘法！
- en: That implementation *will* satisfy the commutative property, but what about
    the `adding1TwiceIsAdding2OnceProperty`?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那个实现*将*满足交换性质，但`adding1TwiceIsAdding2OnceProperty`呢？
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result from FsCheck is:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 FsCheck 的结果是：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That means that using `1` as the input to `adding1TwiceIsAdding2OnceProperty`
    will result in `false`, which you can easily see that it does.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着将`1`作为`adding1TwiceIsAdding2OnceProperty`的输入将导致`false`，你可以很容易地看到它确实是这样的。
- en: The return of the malicious EDFH
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恶意 EDFH 的返回
- en: By using random testing, we have made it harder for a malicious implementor.
    They will have to change tactics now!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ��过使用随机测试，我们让恶意实现者变得更难。他们现在必须改变策略了！
- en: 'The EDFH notes that we are still using some magic numbers in the `adding1TwiceIsAdding2OnceProperty`
    -- namely 1 and 2, and decides to create an implementation that exploits this.
    They''ll use a correct implementation for low input values and an incorrect implementation
    for high input values:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: EDFH 注意到我们在`adding1TwiceIsAdding2OnceProperty`中仍在使用一些魔法数字 -- 即1和2，并决定创建一个利用这一点的实现。他们将为低输入值使用正确的实现，而对于高输入值则使用不正确的实现：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Oh no! If we retest all our properties, they all pass now!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不！如果我们重新测试所有的属性，它们现在都通过了！
- en: That'll teach us to use magic numbers in our tests!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将教会我们在测试中不要使用魔法数字！
- en: What's the alternative? Well, let's steal from the mathematicians and create
    an associative property test.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方案是什么？嗯，让我们从数学家那里借鉴，创建一个关联属性测试。
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Aha! Now we get a falsification:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！现在我们得到了一个证伪：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That means that using `(8+2)+10` is not the same as `8+(2+10)`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用`(8+2)+10`不等于`8+(2+10)`。
- en: Note that not only has FsCheck found some inputs that break the property, but
    it has found a lowest example. It knows that the inputs `8,2,9` pass but going
    one higher (`8,2,10`) fails. That's very nice!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，FsCheck 不仅找到了一些破坏属性的输入，而且找到了一个最小的例子。它知道输入`8,2,9`是通过的，但再增加一个（`8,2,10`）就失败了。这非常好！
- en: 'Understanding FsCheck: Generators'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 FsCheck：生成器
- en: Now that we have used FsCheck for real, let's pause and have a look at how it
    works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经真正使用了 FsCheck，让我们暂停一下，看看它是如何工作的。
- en: The first thing that FsCheck does is generate random inputs for you. This is
    called "generation", and for each type, there is an associated generator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: FsCheck 首先为你生成随机输入。这称为“生成”，对于每种类型，都有一个关联的生成器。
- en: 'For example, to generate a list of sample data, you use the generator along
    with two parameters: the number of elements in the list and a "size". The precise
    meaning of "size" depends on the type being generated and the context. Examples
    of things "size" is used for are: the maximum value of an int; the length of a
    list; the depth of a tree; etc.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要生成一个样本数据列表，你使用生成器以及两个参数：列表中的元素数量和一个“大小”。 “大小”的确切含义取决于正在生成的类型和上下文。 “大小”用于的示例包括：int
    的最大值；列表的长度；树的深度；等等。
- en: 'Here''s some code that generates ints:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些生成整数的代码：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, the ints are not generated uniformly, but clustered around
    zero. You can see this for yourself with a little code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，整数并不是均匀生成的，而是聚集在零附近。你可以用一点代码自己看到这一点：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result is something like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果类似于这样：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see that most of the values are in the center (0 is generated 181 times,
    1 is generated 104 times), and the outlying values are rare (10 is generated only
    3 times).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到大多数值都在中心（0生成了181次，1生成了104次），而边缘值很少（10只生成了3次）。
- en: You can repeat with larger samples too. This one generates 10000 elements in
    the range [-30,30]
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用更大的样本重复。这个例子在范围[-30,30]内生成了10000个元素
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are plenty of other generator functions available as well as `Gen.sample`
    (more documentation [here](https://fsharp.github.io/FsCheck/TestData.html)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的生成器函数可用，以及`Gen.sample`（更多文档请参见[这里](https://fsharp.github.io/FsCheck/TestData.html)）。
- en: 'Understanding FsCheck: Generating all sorts of types automatically'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 FsCheck：自动生成各种类型
- en: What's great about the generator logic is that it will automatically generate
    compound values as well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器逻辑的精妙之处在于它还会自动生成复合值。
- en: 'For example, here is a generator for a tuple of three ints:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个包含三个整数的元组的生成器：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once you have a generator for a base type, `option` and `list` generators follow.
    Here is a generator for `int option`s:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了基本类型的生成器，`option`和`list`的生成器就会跟随。这里是一个`int option`的生成器：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And here is a generator for `int list`s:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`int list`的生成器：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And of course you can generate random strings too!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然你也可以生成随机字符串！
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The best thing is that the generator will work with your own user-defined types
    too!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最棒的是，生成器也适用于你自己定义的用户类型！
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here's one that generates a user-defined record type containing another user-defined
    type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个生成包含另一个用户定义类型的用户定义记录类型的生成器。
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are ways to have more fine-grained control over how your types are generated,
    but that will have to wait for another post!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以更精细地控制你的类型是如何生成的，但这将等待另一篇文章！
- en: 'Understanding FsCheck: Shrinking'
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 FsCheck：收缩
- en: Creating minimum counter-examples is one of the cool things about QuickCheck-style
    testing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建最小的反例是 QuickCheck 风格测试的一大亮点。
- en: How does it do this?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何做到这一点的？
- en: 'There are two parts to the process that FsCheck uses:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: FsCheck 使用的过程有两个部分：
- en: First it generates a sequence of random inputs, starting small and getting bigger.
    This is the "generator" phase as described above.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先它生成一系列随机输入，从小到大。这是上面描述的“生成器”阶段。
- en: If any inputs cause the property to fail, it starts "shrinking" the first parameter
    to find a smaller number. The exact process for shrinking varies depending on
    the type (and you can override it too), but let's say that for numbers, they get
    smaller in a sensible way.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何输入导致属性失败，它会开始“收缩”第一个参数以找到一个更小的数字。收缩的确切过程取决于类型（你也可以覆盖它），但让我们说对于数字来说，它们以一种明智的方式变小。
- en: 'For example, let''s say that you have a silly property `isSmallerThan80`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个愚蠢的属性`isSmallerThan80`：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You have generated random numbers and found that then property fails for `100`,
    and you want to try a smaller number. `Arb.shrink` will generate a sequence of
    ints, all of which are smaller than 100. Each one of these is tried with the property
    in turn until the property fails again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经生成了随机数，并发现属性对`100`失败了，你想尝试一个更小的数字。`Arb.shrink`将生成一系列小于100的整数。每一个都会依次用于属性，直到属性再次失败。
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For each element in the list, test the property against it until you find another
    failure:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对列表中的每个元素，对其进行属性测试，直到找到另一个失败：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The property failed with `88`, so shrink again using that as a starting point:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 属性在`88`失败了，所以再次从那里开始收缩：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The property failed with `83` now, so shrink again using that as a starting
    point:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '属性现在在`83`失败了，所以再次从那里开始收缩： '
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The property failed with `81`, so shrink again using that as a starting point:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 属性在`81`失败了，所以再次从那里开始收缩：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After this point, shrinking on 80 doesn't work -- no smaller value will be found.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点之后，对80的收缩不起作用 -- 不会找到更小的值。
- en: In this case then, FsCheck will report that `80` falsifies the property and
    that 4 shrinks were needed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，FsCheck 将报告`80`使属性失效，并且需要4次收缩。
- en: 'Just as with generators, FsCheck will generate shrink sequences for almost
    any type:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生成器一样，FsCheck 几乎可以为任何类型生成收缩序列：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And, as with generators, there are ways to customize how shrinking works if
    needed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成器一样，如果需要，有方法可以自定义收缩的工作方式。
- en: 'Configuring FsCheck: Changing the number of tests'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 FsCheck：更改测试次数
- en: I mentioned a silly property `isSmallerThan80` -- let's see how FsCheck does
    with it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了一个愚蠢的属性`isSmallerThan80` -- 让我们看看 FsCheck 如何处理它。
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Oh dear! FsCheck didn't find a counter-example!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，糟糕！FsCheck 没有找到反例！
- en: At this point, we can try a few things. First, we can try increasing the number
    of tests.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以尝试一些事情。首先，我们可以尝试增加测试次数。
- en: We do this by changing the default ("Quick") configuration. There is a field
    called `MaxTest` that we can set. The default is 100, so let's increase it to
    1000.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过更改默认（“Quick”）配置来实现这一点。有一个称为`MaxTest`的字段，我们可以设置它。默认值为100，所以让我们将其增加到1000。
- en: Finally, to use a specific config, you'll need to use `Check.One(config,property)`
    rather than just `Check.Quick(property)`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要使用特定配置，你需要使用`Check.One(config,property)`而不仅仅是`Check.Quick(property)`。
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Oops! FsCheck didn''t find a counter-example with 1000 tests either! Let''s
    try once more with 10000 tests:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！FsCheck 也没有在 1000 次测试中找到反例！让我们再试一次，进行 10000 次测试：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Ok, so we finally got it to work. But why did it take so many tests?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，最终我们让它工作了。但为什么需要这么多测试？
- en: 'The answer lies in some other configuration settings: `StartSize` and `EndSize`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在其他一些配置设置中：`StartSize` 和 `EndSize`。
- en: Remember that the generators start with small numbers and gradually increase
    them. This is controlled by the `StartSize` and `EndSize` settings. By default,
    `StartSize` is 1 and `EndSize` is 100\. So at the end of the test, the "size"
    parameter to the generator will be 100.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，生成器从小数字开始逐渐增加。这由`StartSize`和`EndSize`设置控制。默认情况下，`StartSize`为 1，`EndSize`为
    100。因此，在测试结束时，生成器的“大小”参数将为 100。
- en: But, as we saw, even if the size is 100, very few numbers are generated at the
    extremes. In this case it means that numbers greater than 80 are unlikely to be
    generated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们所看到的，即使大小为 100，极端情况下也很少生成数字。在这种情况下，这意味着大于 80 的数字不太可能被生成。
- en: So let's change the `EndSize` to something larger and see what happens!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们将`EndSize`更改为更大的值，看看会发生什么！
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That's more like it! Only 21 tests needed now rather than 8660 tests!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样！现在只需要 21 次测试，而不是 8660 次测试！
- en: 'Configuring FsCheck: Verbose mode and logging'
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 FsCheck：详细模式和日志记录
- en: I mentioned that one of the benefits of FsCheck over a home-grown solution is
    the logging and reproducibility, so let's have a look at that.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到 FsCheck 相对于自制解决方案的一个好处是日志记录和可重现性，让我们来看看。
- en: We'll tweak the malicious implementation to have a boundary of `25`. Let's see
    how FsCheck detects this boundary via logging.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调整恶意实现的边界为`25`。让我们看看 FsCheck 如何通过日志检测到这个边界。
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The result is:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Again, FsCheck has found that `25` is the exact boundary point quite quickly.
    But how did it do it?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，FsCheck 很快发现`25`是确切的边界点。但它是如何做到的呢？
- en: 'First, the simplest way to see what FsCheck is doing is to use "verbose" mode.
    That is, use `Check.Verbose` rather than `Check.Quick`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看 FsCheck 的操作最简单的方法是使用“verbose”模式。也就是说，使用`Check.Verbose`而不是`Check.Quick`：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When do this, you'll see an output like that shown below. I've added all the
    comments to explain the various elements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，你将看到如下所示的输出。我已添加了所有注释以解释各个元素。
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This display takes up a lot of space! Can we make it more compact?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个显示占用了很多空间！我们能让它更加紧凑吗？
- en: Yes -- you can control how each test and shrink is displayed by writing your
    own custom functions, and telling FsCheck to use them via its `Config` structure.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 是的 -- 你可以通过编写自定义函数来控制每个测试和收缩的显示方式，并通过其`Config`结构告诉 FsCheck 使用它们。
- en: These functions are generic, and the list of parameters is represented by a
    list of unknown length (`obj list`). But since I know I am testing a three parameter
    property I can hard-code a three-element list parameter and print them all on
    one line.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数是通用的，参数列表由一个未知长度的列表（`obj list`）表示。但由于我知道我正在测试一个三参数属性，我可以硬编码一个三元素列表参数，并将它们都打印在一行上。
- en: The configuration also has a slot called `Replay` which is normally `None`,
    which means that each run will be different.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 配置还有一个名为`Replay`的槽，通常为`None`，这意味着每次运行都会不同。
- en: If you set `Replay` to `Some seed`, then the test will be replayed exactly the
    same way. The seed looks like `StdGen (someInt,someInt)` and is printed on each
    run, so if you want to preserve a run all you need to do is paste that seed into
    the config.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`Replay`设置为`Some seed`，则测试将以完全相同的方式重播。种子看起来像`StdGen (someInt,someInt)`，并在每次运行时打印，因此如果要保留运行，只需将该种子粘贴到配置中即可。
- en: And again, to use a specific config, you'll need to use `Check.One(config,property)`
    rather than just `Check.Quick(property)`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，要使用特定配置，你需要使用`Check.One(config,property)`而不仅仅是`Check.Quick(property)`。
- en: Here's the code with the default tracing functions changed, and the replay seed
    set explicitly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码，其中默认的跟踪函数已更改，并且回放种子已明确设置。
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is now much more compact, and looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出更加紧凑，看起来像这样：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So there you go -- it's quite easy to customize the FsCheck logging if you need
    to.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果需要，定制 FsCheck 日志是相当容易的。
- en: Let's look at how the shrinking was done in detail. The last set of inputs (46,-4,50)
    was false, so shrinking started.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看如何进行收缩。最后一组输入（46，-4，50）是错误的，因此开始收缩。
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ll loop through the list `[0; 23; 35; 41; 44; 45]` stopping at the first
    element that causes the property to fail:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将循环遍历列表`[0; 23; 35; 41; 44; 45]`，在导致属性失败的第一个元素处停止：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first element that caused a failure was `x=35`, as part of the inputs `(35,
    -4, 50)`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 导致失败的第一个元素是`x=35`，作为输入`(35, -4, 50)`的一部分。
- en: 'So now we start at 35 and shrink that:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从 35 开始缩小：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first element that caused a failure was now `x=27`, as part of the inputs
    `(27, -4, 50)`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 导致失败的第一个元素现在是`x=27`，作为输入`(27, -4, 50)`的一部分。
- en: 'So now we start at 27 and keep going:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从 27 开始继续：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: At this point, `x=25` is as low as you can go. None of its shrink sequence caused
    a failure. So we're finished with the `x` parameter!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`x=25`是您可以达到的最低点。它的缩小序列中没有一个导致失败。所以我们已经完成了`x`参数！
- en: Now we just repeat this process with the `y` parameter
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需重复这个过程与`y`参数
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: At this point, `y=1` is as low as you can go. None of its shrink sequence caused
    a failure. So we're finished with the `y` parameter!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`y=1`是您可以达到的最低点。它的缩小序列中没有一个导致失败。所以我们已经完成了`y`参数！
- en: Finally, we repeat this process with the `z` parameter
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重复这个过程与`z`参数
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: And now we're finished with all the parameters!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有的参数！
- en: The final counter-example after shrinking is `(25,1,26)`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小后的最终反例是`(25,1,26)`。
- en: Adding pre-conditions
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加前提条件
- en: Let's say that we have a new idea for a property to check. We'll create a property
    called `addition is not multiplication` which will help to stop any malicious
    (or even accidental) mixup in the implementations.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个新的想法要检查的属性。我们将创建一个名为`addition is not multiplication`的属性，这将有助于阻止实现中的任何恶意（甚至是意外）混淆。
- en: 'Here''s our first attempt:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一次尝试：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Bt when we run this test, we get a failure!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们运行这个测试时，我们得到了一个失败！
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Well duh, obviously `0+0` and `0*0` are equal. But how can we tell FsCheck to
    ignore just those inputs and leave all the other ones alone?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，显然`0+0`和`0*0`是相等的。但我们如何告诉 FsCheck 忽略这些输入，而保留其他所有输入？
- en: This is done via a "condition" or filter expression that is prepended to the
    property function using `==>` (an operator defined by FsCheck).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用`==>`（由 FsCheck 定义的运算符）将“条件”或过滤表达式添加到属性函数之前完成的。
- en: 'Here''s an example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The new property is `additionIsNotMultiplication_withPreCondition` and can be
    passed to `Check.Quick` just like any other property.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 新属性是`additionIsNotMultiplication_withPreCondition`，可以像任何其他属性一样传递给`Check.Quick`。
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Oops! We forgot another case! Let''s fix up our precondition again:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！我们忘记了另一个情况！让我们再次修复我们的前提条件：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And now this works.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个方法有效了。
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This kind of precondition should only be used if you want to filter out a small
    number of cases.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在想要过滤掉少数情况时，才应该使用这种前提条件。
- en: If most of the inputs will be invalid, then this filtering will be expensive.
    In this case there is a better way to do it, which will be discussed in a future
    post.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大多数输入都是无效的，那么这种过滤将会很昂贵。在这种情况下，有一种更好的方法，将在未来的帖子中讨论。
- en: The FsCheck documentation has more on how you can tweak properties [here](https://fsharp.github.io/FsCheck/Properties.html).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: FsCheck 文档中有更多关于如何调整属性的信息[在这里](https://fsharp.github.io/FsCheck/Properties.html)。
- en: Naming convention for properties
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性的命名约定
- en: These properties functions have a different purpose from "normal" functions,
    so how should we name them?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性函数的目的与“正常”函数不同，那么我们应该如何命名它们？
- en: In the Haskell and Erlang world, properties are given a `prop_` prefix by convention.
    In the .NET world, it is more common to use a suffix like `AbcProperty`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 和 Erlang 世界中，按照惯例，属性以`prop_`前缀开头。在 .NET 世界中，更常见的是使用类似`AbcProperty`的后缀。
- en: Also, in F# we have namespaces, modules, and attributes (like `[<Test>]`) that
    we can use to organize properties and distinguish them from other functions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 F# 中，我们有命名空间、模块和属性（如`[<Test>]`），我们可以使用它们来组织属性并将其与其他函数区分开。
- en: Combining multiple properties
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合多个属性
- en: Once you have a set of properties, you can combine them into a group (or even,
    gasp, a *specification*!), by adding them as static members of a class type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一组属性，您可以将它���组合成一个组（甚至，啧啧，一个*规范*！），通过将它们作为类类型的静态成员添加。
- en: You can then do `Check.QuickAll` and pass in the name of the class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以执行`Check.QuickAll`并传入类的名称。
- en: 'For example, here are our three addition properties:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是我们的三个加法属性：
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And here''s the corresponding static class to be used with `Check.QuickAll`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是与`Check.QuickAll`一起使用的相应静态类：
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Combining property-based tests with example-based tests
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将基于属性的测试与基于示例的测试结合起来
- en: At the beginning of this post, I was dismissive of tests that used "magic" numbers
    to test a very small part of the input space.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文的开头，我对使用“魔术”数字来测试输入空间的非常小部分的测试持否定态度。
- en: However, I do think that example-based tests have a role that complements property-based
    tests.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我认为基于示例的测试与基于属性的测试相辅相成。
- en: An example-based test is often easier to understand because it is less abstract,
    and so provides a good entry point and documentation in conjuction with the properties.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 基于示例的测试通常更容易理解，因为它不太抽象，因此与属性一起提供了很好的入口点和文档。
- en: 'Here''s an example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using FsCheck from NUnit
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 NUnit 使用 FsCheck
- en: You can use FsCheck from NUnit and other test frameworks, with an extra plugin
    (e.g. `FsCheck.NUnit` for Nunit).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 FsCheck 进行 NUnit 和其他测试框架，只需使用额外的插件（例如 `FsCheck.NUnit` 用于 NUnit）。
- en: Rather than marking a test with `Test` or `Fact`, you use the `Property` attribute.
    And unlike normal tests, these tests can have parameters!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将测试标记为 `Test` 或 `Fact`，您可以使用 `Property` 属性。与普通测试不同，这些测试可以有参数！
- en: Here's an example of some tests.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些测试的示例。
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, you can change the configuration for each test (such as `Verbose`
    and `EndSize`) via properties of the annotation.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以通过注解的属性更改每个测试的配置（例如 `Verbose` 和 `EndSize`）。
- en: And the `QuietOnSuccess` flag is available to make FsCheck compatible with standard
    test frameworks, which are silent on success and only show messages if something
    goes wrong.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `QuietOnSuccess` 标志可用于使 FsCheck 与标准测试框架兼容，这些框架在成功时保持沉默，仅在出现问题时显示消息。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this post I've introduced you to the basics of property-based checking.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我向您介绍了基于属性的检查的基础知识。
- en: 'There''s much more to cover though! In future posts I will cover topics such
    as:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当然还有更多内容需要涵盖！在未来的文章中，我将涵盖诸如：
- en: '**[How to come up with properties that apply to your code](property-based-testing-2)**.
    The properties don''t have to be mathematical. We''ll look at more general properties
    such as inverses (for testing serialization/deserialization), idempotence (for
    safe handling of multiple updates or duplicate messages), and also look at test
    oracles.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[如何提出适用于您的代码的属性](property-based-testing-2)**。属性不一定是数学的。我们将查看更一般的属性，例如反演（用于测试序列化/反序列化）、幂等性（用于安全处理多次更新或重复消息），以及测试预言。'
- en: '**How to create your own generators and shrinkers**. We''ve seen that FsCheck
    can generate random values nicely. But what about values with constraints such
    as positive numbers, or valid email addresses, or phone numbers. FsCheck gives
    you the tools to build your own.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何创建你自己的生成器和收缩器**。我们已经看到了 FsCheck 能够很好地生成随机值。但是，对于诸如正数、有效电子邮件地址或电话号码等约束条件的值，该怎么办呢？FsCheck
    为您提供了构建自己的工具。'
- en: '**How to do model-based testing**, and in particular, how to test for concurrency
    issues.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何进行基于模型的测试**，特别是如何测试并发问题。'
- en: I've also introduced the notion of an evil malicious programmer. You might think
    that such a malicious programmer is unrealistic and over-the-top.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我还介绍了一个邪恶的恶意程序员的概念。你可能认为这样的恶意程序员是不现实和过火的。
- en: But in many cases *you* act like an unintentionally malicious programmer. You
    happily create a implementation that works for some special cases, but doesn't
    work more generally, not out of evil intent, but out of unawareness and blindness.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在许多情况下，*您*表现得像一个无意中的恶意程序员。您愉快地创建一个只适用于一些特殊情况但在更一般情况下却无法正常工作的实现，这并非出于恶意，而是出于无意识和盲目。
- en: Like fish unaware of water, we are often unaware of the assumptions we make.
    Property-based testing can force us to become aware of them.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像鱼对水毫无所知一样，我们经常对自己所做的假设毫不知情。基于属性的测试可以迫使我们意识到这些假设。
- en: Until next time -- happy testing!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 下次再见 —— 愉快的测试！
- en: '*The code samples used in this post are [available on GitHub](https://github.com/swlaschin/PropertyBasedTesting/blob/master/part1.fsx)*.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文中使用的代码示例可在 [GitHub 上找到](https://github.com/swlaschin/PropertyBasedTesting/blob/master/part1.fsx)*。'
- en: '**Want more? I have written [a follow up post on choosing properties for property-based
    testing](http://fsharpforfunandprofit.com/posts/property-based-testing-2/)**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**想要了解更多吗？我写了[一篇关于选择属性进行基于属性的测试的后续文章](http://fsharpforfunandprofit.com/posts/property-based-testing-2/)。**'
- en: '*UPDATE: I did a talk on property-based testing based on these posts. [Slides
    and video here.](http://fsharpforfunandprofit.com/pbt/)*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新：我做了一个基于这些文章的基于属性的测试的演讲。[幻灯片和视频在此处。](http://fsharpforfunandprofit.com/pbt/)*'
- en: 'Appendix: Installing and troubleshooting FsCheck'
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录：安装和故障排除 FsCheck
- en: The easiest way to make FsCheck available to you is to create an F# project
    and add the NuGet package "FsCheck.NUnit". This will install both FsCheck and
    NUnit in the `packages` directory.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让 FsCheck 对您可用的最简单方法是创建一个 F# 项目并添加 NuGet 包 "FsCheck.NUnit"。这将在 `packages` 目录中安装
    FsCheck 和 NUnit。
- en: 'If you are using a FSX script file for interactive development, you''ll need
    to load the DLLs from the appropriate package location, like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 FSX 脚本文件进行交互式开发，你需要从适当的包位置加载 DLL，像这样：
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, test that FsCheck is working correctly by running the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过运行以下命令来测试 FsCheck 是否正常工作：
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you get no errors, then everything is good.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现错误，那么一切都很顺利。
- en: 'If you *do* get errors, it''s probably because you are on an older version
    of Visual Studio. Upgrade to VS2013 or failing that, do the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*确实*出现错误，那可能是因为你使用的是较旧版本的 Visual Studio。升级到 VS2013，或者如果失败了，执行以下操作：
- en: First make sure you have the latest F# core installed ([currently 3.1](https://stackoverflow.com/questions/20332046/correct-version-of-fsharp-core)).
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先确保你已经安装了最新的 F# 核心（[目前是 3.1](https://stackoverflow.com/questions/20332046/correct-version-of-fsharp-core)）。
- en: Make sure your that your `app.config` has the [appropriate binding redirects](http://blog.ploeh.dk/2014/01/30/how-to-use-fsharpcore-430-when-all-you-have-is-431/).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的`app.config`文件有[适当的绑定重定向](http://blog.ploeh.dk/2014/01/30/how-to-use-fsharpcore-430-when-all-you-have-is-431/)。
- en: Make sure that your NUnit assemblies are being referenced locally rather than
    from the GAC.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的 NUnit 程序集是从本地引用而不是从全局程序集缓存（GAC）引用的。
- en: These steps should ensure that compiled code works.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤应该可以确保编译后的代码正常工作。
- en: 'With F# interactive, it can be trickier. If you are not using VS2013, you might
    run into errors such as `System.InvalidCastException: Unable to cast object of
    type ''Arrow''`.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 F# 交互式环境可能会更加棘手。如果你没有使用 VS2013，可能会遇到诸如`System.InvalidCastException: Unable
    to cast object of type ''Arrow''`的错误。'
- en: The best cure for this is to upgrade to VS2013! Failing that, you can use an
    older version of FsCheck, such as 0.9.2 (which I have tested successfully with
    VS2012)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解决方法是升级到 VS2013！如果不行，你可以使用较旧版本的 FsCheck，比如 0.9.2（我已经成功地在 VS2012 中测试过）。
