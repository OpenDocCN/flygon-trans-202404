- en: Ten reasons not to use a statically typed functional programming language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十个不使用静态类型函数式编程语言的理由
- en: Ten reasons not to use a statically typed functional programming language
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十个不使用静态类型函数式编程语言的理由
- en: Are you fed up with all the hype about functional programming? Me too! I thought
    I'd rant about some reasons why sensible people like us should stay away from
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否对所有关于函数式编程的炒作感到厌倦？我也是！我想抱怨一些像我们这样理智的人应该远离它的原因。
- en: '[Just to be clear, when I say "statically typed functional programming language",
    I mean languages that also include things such as type inference, immutability
    by default, and so on. In practice, this means Haskell and the ML-family (including
    OCaml and F#).]'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[我想明确指出，当我说“静态类型函数式编程语言”时，我指的是还包括诸如类型推断、默认不可变性等内容的语言。实际上，这意味着Haskell和ML系列（包括OCaml和F＃）。]'
- en: 'Reason 1: I don''t want to follow the latest fad'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个原因：我不想追随最新的潮流
- en: Like most programmers, I'm naturally conservative and I dislike learning new
    things. That's why I picked a career in IT.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数程序员一样，我天生保守，不喜欢学习新东西。这就是为什么我选择了IT职业。
- en: I don't jump on the latest bandwagon just because all the "cool kids" are doing
    it -- I wait until things have matured and I can get some perspective.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会因为所有“酷毙了的小孩”都在做某件事而跟风——我会等到事情成熟，我可以获得一些清晰的看法。
- en: To me, functional programming just hasn't been around long enough to convince
    me that it is here to stay.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，函数式编程还没有存在足够长的时间来说服我它是值得信赖的。
- en: Yes, I suppose some pedants will claim that [ML](http://en.wikipedia.org/wiki/ML_\(programming_language\))
    and [Haskell](http://en.wikipedia.org/wiki/Haskell_\(programming_language\)) have
    been around almost as long as old favorites like Java and PHP, but I only heard
    of Haskell recently, so that argument doesn't wash with me.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我想有些古板的人可能会声称[ML](http://en.wikipedia.org/wiki/ML_\(programming_language\))和[Haskell](http://en.wikipedia.org/wiki/Haskell_\(programming_language\))已经存在了几乎和Java和PHP等老牌语言一样长的时间，但我最近才听说Haskell，所以这个论点对我来说并不成立。
- en: And look at the baby of the bunch, [F#](http://fsharp.org/). It's only seven
    years old, for Pete's sake! Sure, that may be a long time to a geologist, but
    in internet time, seven years is just the blink of an eye.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些新人中最年轻的[F#](http://fsharp.org/)。它只有七岁，天哪！当然，对于地质学家来说，七年可能是很长的时间，但在互联网时间里，七年只是一眨眼的工夫。
- en: So, all told, I would definitely take the cautious approach and wait a few decades
    to see if this functional programming thing sticks around or whether it is just
    a flash in the pan.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总的来说，我肯定会采取谨慎的态度，等待几十年，看看这个函数式编程的东西是否会持续存在，或者它只是昙花一现。
- en: 'Reason 2: I get paid by the line'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个原因：我按行数计费
- en: I don't know about you, but the more lines of code I write, the more productive
    I feel. If I can churn out 500 lines of code in a day, that's a job well done.
    My commits are big, and my boss can see that I've been busy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你是怎么想的，但我写的代码行数越多，我就感到越有生产力。如果我一天可以输出500行代码，那就是干得好。我的提交很大，我的老板可以看到我一直很忙。
- en: But when I [compare code](fvsc-sum-of-squares.html) written in a functional
    language with a good old C-like language, there's so much less code that it scares
    me.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我[比较](fvsc-sum-of-squares.html)用函数式语言编写的代码和一个好老的类C语言时，代码量就少得多，这让我感到害怕。
- en: 'I mean, just look at this code written in a familiar language:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，看看用熟悉的语言编写的这段代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'and compare it with this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其与此进行比较：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's 17 lines vs. only 2 lines. [Imagine that difference multiplied over a
    whole project!](http://fpbridge.co.uk/why-fsharp.html#conciseness)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 17行对比仅2行。[想象一下这种差异在整个项目中被放大的情况！](http://fpbridge.co.uk/why-fsharp.html#conciseness)
- en: If I did use this approach, my productivity would drop drastically. I'm sorry
    -- I just can't afford it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我采用这种方法，我的生产力将急剧下降。很抱歉——我实在承受不起。
- en: 'Reason 3: I love me some curly braces'
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三个原因：我喜欢大括号
- en: And that's another thing. What's up with all these languages that get rid of
    curly braces. How can they call themselves real programming languages?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有另一件事。那些去掉大括号的语言到底怎么回事？他们怎么能称自己为真正的编程语言？
- en: I'll show you what I mean. Here's a code sample with familiar curly braces.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我会向你展示我说的是什么意思。这里是一个用熟悉的大括号编写的代码示例。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And here's some similar code, but without curly braces.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些类似的代码，但没有大括号。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Look at the difference! I don't know about you, but I find the second example
    a bit disturbing, as if something important is missing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个差异！我不知道你是怎么想的，但我觉得第二个例子有点让人不安，好像缺少了一些重要的东西。
- en: To be honest, I feel a bit lost without the guidance that curly braces give
    me.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，没有花括号给予我的指导，我感到有点迷失。
- en: 'Reason 4: I like to see explicit types'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理由 4：我喜欢看到显式类型
- en: Proponents of functional languages claim that type inference makes the code
    cleaner because you don't have to clutter your code with type declarations all
    the time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言的支持者声称，类型推断使代码更清晰，因为你不必一直在代码中添加类型声明。
- en: Well, as it happens, I *like* to see type declarations. I feel uncomfortable
    if I don't know the exact type of every parameter. That's why [Java](http://steve-yegge.blogspot.co.uk/2006/03/execution-in-kingdom-of-nouns.html)
    is my favorite language.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，碰巧我*喜欢*看到类型声明。如果我不知道每个参数的确切类型，我会感到不舒服。这就是为什么 [Java](http://steve-yegge.blogspot.co.uk/2006/03/execution-in-kingdom-of-nouns.html)
    是我最喜欢的语言。
- en: Here's a function signature for some ML-ish code. There are no type declarations
    needed and all types are inferred automatically.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些类似 ML 代码的函数签名。不需要类型声明，所有类型都会自动推断。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And here's the function signature for similar code in C#, with explicit type
    declarations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 C# 中类似代码的函数签名，带有显式类型声明。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I may be in the minority here, but I like the second version much better. It's
    important to me to know that the return is of type `IEnumerable<IGrouping<TKey,
    TSource>>`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我可能是少数人，但我更喜欢第二个版本。对我来说，知道返回的类型是 `IEnumerable<IGrouping<TKey, TSource>>`
    很重要。
- en: Sure, the compiler will type check this for you and warn you if there is a type
    mismatch. But why let the compiler do the work when your brain can do it instead?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，编译器会为你检查类型并在类型不匹配时提醒你。但是为什么要让编译器做这个工作，当你的大脑可以做到呢？
- en: Ok, I admit that if you do use generics, and lambdas, and functions that return
    functions, and all the other newfangled stuff, then yes, your type declarations
    can get really hairy and complex. And it gets really hard to type them properly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我承认如果你确实使用了泛型，和 lambda 表达式，以及返回函数的函数，以及所有其他新潮的东西，那么是的，你的类型声明会变得非常复杂和复杂。并且很难正确地输入它们。
- en: But I have an easy fix for that -- don't use generics and don't pass around
    functions. Your signatures will be much simpler.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我有一个简单的解决方法 -- 不要使用泛型，也不要传递函数。你的签名会简单得多。
- en: 'Reason 5: I like to fix bugs'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理由 5：我喜欢修复 bug
- en: To me, there's nothing quite like the thrill of the hunt -- finding and killing
    a nasty bug. And if the bug is in a production system, even better, because I'll
    be a hero as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，没有什么能比得上发现和消灭一个讨厌的 bug 的刺激。如果 bug 出现在生产系统中，那就更好，因为这样我还会成为一个英雄。
- en: But [I've read](https://web.archive.org/web/20130918053426/http://www.simontylercousins.net/journal/2013/3/7/why-bugs-dont-like-f.html)
    that in statically typed functional languages, it is much harder to introduce
    bugs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是[我读到](https://web.archive.org/web/20130918053426/http://www.simontylercousins.net/journal/2013/3/7/why-bugs-dont-like-f.html)在静态类型的函数式语言中，引入
    bug 要困难得多。
- en: That's a bummer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是个令人沮丧的事情。
- en: 'Reason 6: I live in the debugger'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理由 6：我生活在调试器中
- en: And talking of bug fixing, I spend most of my day in the debugger, stepping
    through code. Yes, I know I should be using unit tests, but easier said than done,
    OK?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到修复 bug，我大部分时间都在调试器中度过，逐步执行代码。是的，我知道我应该使用单元测试，但说起来容易，做起来难，好吗？
- en: Anyway, apparently with these statically typed functional languages, [if your
    code compiles, it usually works](http://www.haskell.org/haskellwiki/Why_Haskell_just_works).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，显然使用这些静态类型的函数式语言，[如果你的代码编译通过，它通常就能工作](http://www.haskell.org/haskellwiki/Why_Haskell_just_works)。
- en: I'm told that you do have to spend a lot of time up front getting the types
    to match up, but once that is done and it compiles successfully, there is nothing
    to debug. Where's the fun in that?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我被告知你必须花费大量时间来确保类型匹配，但是一旦完成了，代码编译成功后，就没有什么需要调试的了。那有什么乐趣呢？
- en: Which brings me to...
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想到...
- en: 'Reason 7: I don''t want to think about every little detail'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理由 7：我不想考虑每一个细节
- en: All this matching up types and making sure everything is perfect sounds tiring
    to me.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配类型和确保一切完美听起来对我来说很累人。
- en: In fact, I hear that you are forced to think about all the possible edge cases,
    and all the possible error conditions, and every other thing that could go wrong.
    And you have to do this at the beginning -- you can't be lazy and postpone it
    till later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我听说你被迫考虑所有可能的边界情况，所有可能的错误条件，以及其他任何可能出错的事情。而且你必须在一开始就做到这一点 -- 你不能偷懒，把它推迟到以后。
- en: I'd much rather get everything (mostly) working for the happy path, and then
    fix bugs as they come up.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我宁愿先让一切（大部分）按照正常路径工作，然后在问题出现时修复错误。
- en: 'Reason 8: I like to check for nulls'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理由8：我喜欢检查空值
- en: I'm very conscientious about [checking for nulls](http://stackoverflow.com/questions/7585493/null-parameter-checking-in-c-sharp)
    on every method. It gives me great satisfaction to know that my code is completely
    bulletproof as a result.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常注意在每个方法上[检查空值](http://stackoverflow.com/questions/7585493/null-parameter-checking-in-c-sharp)。因此，知道我的代码完全无懈可击让我感到非常满足。
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Haha! Just kidding! Of course I can't be bothered to put null-checking code
    everywhere. I'd never get any real work done.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！开玩笑！我当然不会费心到处放置空值检查代码。我永远不会完成任何真正的工作。
- en: But I've only ever had to deal with one bad crash caused by a NPE. And the business
    didn't lose too much money during the few weeks I spent looking for the problem.
    So I'm not sure why this is such a [big deal](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但我只遇到过一次由NPE引起的严重崩溃。在我花了几个星期寻找问题期间，企业并没有损失太多钱。所以我不确定为什么这是一个[大问题](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)。
- en: 'Reason 9: I like to use design patterns everywhere'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理由9：我喜欢在任何地方使用设计模式
- en: I first read about design patterns in the [Design Patterns book](http://www.amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/0596007124)
    (for some reason it's referred to as the Gang of Four book, but I'm not sure why),
    and since then I have been diligent in using them at all times for all problems.
    It certainly makes my code look serious and "enterprise-y", and it impresses my
    boss.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先在[设计模式书籍](http://www.amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/0596007124)中了解到设计模式（由于某种原因它被称为四人帮书，但我不确定原因），自那以后，我一直努力在所有问题上都使用它们。这确实让我的代码看起来严肃而“企业化”，并且让我的老板印象深刻。
- en: But I don't see any mention of patterns in functional design. How can you get
    useful stuff done without Strategy, AbstractFactory, Decorator, Proxy, and so
    on?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但我没有看到函数式设计中提到模式。你怎么可能在没有Strategy、AbstractFactory、Decorator、Proxy等的情况下完成有用的工作？
- en: Perhaps the functional programmers are not aware of them?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或许函数式程序员不知道它们的存在？
- en: 'Reason 10: It''s too mathematical'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理由10：这太数学化了
- en: Here's some more code for calculating the sum of squares. This is *way* too
    hard to understand because of all the weird symbols in it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用于计算平方和的代码。由于其中所有奇怪的符号，这太难理解了。
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Oops, sorry! My mistake. That was [J code](http://en.wikipedia.org/wiki/J_\(programming_language\)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕，抱歉！我的错。那是[J 语言](http://en.wikipedia.org/wiki/J_\(programming_language\))。
- en: But I do hear that functional programs use strange symbols like `<*>` and `>>=`
    and obscure concepts called "monads" and "functors".
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但我听说函数式程序使用奇怪的符号像`<*>`和`>>=`以及名为“monads”和“functors”的模糊概念。
- en: I don't know why the functional people couldn't stick with things I already
    know -- obvious symbols like `++` and `!=` and easy concepts such as "inheritance"
    and "polymorphism".
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么函数式的人们不能坚持我已经了解的事物——明显的符号像`++`和`!=`以及易于理解的概念如“继承”和“多态性”。
- en: 'Summary: I don''t get it'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结：我不明白
- en: You know what. I don't get it. I don't get why functional programming is useful.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗。我不明白。我不明白函数式编程有什么用处。
- en: What I'd really like is for someone to just show me some [real benefits on a
    single page](index2.html), instead of giving me too much information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我真正想要的是，有人能够在[单个页面上展示一些真正的好处](index2.html)，而不是给我太多信息。
- en: 'UPDATE: So now I''ve read the "everything you need to know on one page" page.
    But it''s too short and simplistic for me.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 更新：所以现在我已经阅读了“一个页面上你需要知道的一切”的页面。但对我来说太简短和简单了。
- en: I'm really looking for something with a bit more depth -- [something](designing-for-correctness.html)
    I can [get](designing-with-types.html) my teeth [into](computation-expressions-intro.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的想要一些更深入的东西——[一些](designing-for-correctness.html)我能够[深入研究](designing-with-types.html)的东西[。](computation-expressions-intro.html)
- en: And no, don't say that I should read [tutorials](http://learnyouahaskell.com/),
    and [play with examples](http://www.tryfsharp.org/Learn), and write my own code.
    I just want to grok it without doing all of that work.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不，不要说我应该阅读[教程](http://learnyouahaskell.com/)，并且[尝试示例](http://www.tryfsharp.org/Learn)，以及编写自己的代码。我只是想要理解它而不必做所有这些工作。
- en: I don't want to have to [change the way I think](https://web.archive.org/web/20140118170751/http://dave.fayr.am/posts/2011-08-19-lets-go-shopping.html)
    just to learn a new paradigm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想要为了学习新范例而[改变我的思维方式](https://web.archive.org/web/20140118170751/http://dave.fayr.am/posts/2011-08-19-lets-go-shopping.html)。
