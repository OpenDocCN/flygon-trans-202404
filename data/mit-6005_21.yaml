- en: 'Reading 21: Sockets & Networking'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读书21：套接字与网络
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 软件在6.005中
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 安全免于错误 | 易于理解 | 准备好变化 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确，未来也正确。 | 与未来的程序员（包括未来的自己）清晰沟通。 | 设计以容纳变化而不必重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: In this reading we examine *client/server communication* over the network using
    the *socket* abstraction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们使用*套接字*抽象来检查网络上的*客户端/服务器通信*。
- en: Network communication is inherently concurrent, so building clients and servers
    will require us to reason about their concurrent behavior and to implement them
    with thread safety. We must also design the *wire protocol* that clients and servers
    use to communicate, just as we design the operations that clients of an ADT use
    to work with it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通信本质上是并发的，因此构建客户端和服务器将要求我们思考它们的并发行为，并以线程安全的方式实现它们。我们还必须设计客户端和服务器用于通信的*通信协议*，就像我们设计ADT的客户端使用的操作一样。
- en: 'Some of the operations with sockets are *blocking*: they block the progress
    of a thread until they can return a result. Blocking makes writing some code easier,
    but it also foreshadows a new class of concurrency bugs we’ll soon contend with
    in depth: deadlocks.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些套接字操作是*阻塞*的：它们会阻塞线程的进度，直到能够返回结果。阻塞使得编写某些代码更容易，但它也预示着一个新的并发错误类别，我们将很快深入讨论：死锁。
- en: Client/server design pattern
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器设计模式
- en: In this reading (and in the problem set) we explore the **client/server design
    pattern** for communication with message passing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文（以及问题集）中，我们探讨了用于消息传递的**客户端/服务器设计模式**以进行通信。
- en: 'In this pattern there are two kinds of processes: clients and servers. A client
    initiates the communication by connecting to a server. The client sends requests
    to the server, and the server sends replies back. Finally, the client disconnects.
    A server might handle connections from many clients concurrently, and clients
    might also connect to multiple servers.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，有两种类型的进程：客户端和服务器。客户端通过连接到服务器来启动通信。客户端向服务器发送请求，服务器发送回复。最后，客户端断开连接。服务器可能会同时处理来自许多客户端的连接，客户端也可能连接到多个服务器。
- en: 'Many Internet applications work this way: web browsers are clients for web
    servers, an email program like Outlook is a client for a mail server, etc.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网应用程序都是这样工作的：网页浏览器是web服务器的客户端，像Outlook这样的邮件程序是邮件服务器的客户端，等等。
- en: On the Internet, client and server processes are often running on different
    machines, connected only by the network, but it doesn’t have to be that way —
    the server can be a process running on the same machine as the client.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，客户端和服务器进程通常在不同的机器上运行，只通过网络连接，但不一定非要这样 — 服务器可以是在与客户端相同的机器上运行的进程。
- en: Network sockets
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络套接字
- en: IP addresses
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP地址
- en: 'A network interface is identified by an [IP address](http://en.wikipedia.org/wiki/IP_address).
    IPv4 addresses are 32-bit numbers written in four 8-bit parts. For example (as
    of this writing):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络接口由一个[IP地址](http://en.wikipedia.org/wiki/IP_address)标识。IPv4地址是32位数，写成四个8位部分。例如（截至本文撰写时）：
- en: '`18.9.22.69` is the IP address of a MIT web server. Every address whose [first
    octet is `18`](http://en.wikipedia.org/wiki/List_of_assigned_/8_IPv4_address_blocks)
    is on the MIT network.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`18.9.22.69`是MIT网页服务器的IP地址。每个[第一个八位组是`18`](http://en.wikipedia.org/wiki/List_of_assigned_/8_IPv4_address_blocks)的地址都在MIT网络上。'
- en: '`18.9.25.15` is the address of a MIT incoming email handler.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`18.9.25.15`是MIT的入站邮件处理程序的地址。'
- en: '`173.194.123.40` is the address of a Google web server.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`173.194.123.40`是一个谷歌网页服务器的地址。'
- en: '`127.0.0.1` is the [loopback](http://en.wikipedia.org/wiki/Loopback) or [localhost](http://en.wikipedia.org/wiki/Localhost)
    address: it always refers to the local machine. Technically, any address whose
    first octet is `127` is a loopback address, but `127.0.0.1` is standard.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1`是[环回](http://en.wikipedia.org/wiki/Loopback)或[本地主机](http://en.wikipedia.org/wiki/Localhost)地址：它始终指向本地机器。从技术上讲，任何第一个八位组是`127`的地址都是环回地址，但`127.0.0.1`是标准的。'
- en: You can [ask Google for your current IP address](https://www.google.com/search?q=my+ip).
    In general, as you carry around your laptop, every time you connect your machine
    to the network it can be assigned a new IP address.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向谷歌[查询你的当前IP地址](https://www.google.com/search?q=my+ip)。一般来说，当你携带着你的笔记本电脑四处移动时，每次将你的机器连接到网络时，它都可以被分配一个新的IP地址。
- en: Hostnames
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主机名
- en: '[Hostnames](http://en.wikipedia.org/wiki/Hostname) are names that can be translated
    into IP addresses. A single hostname can map to different IP addresses at different
    times; and multiple hostnames can map to the same IP address. For example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[主机名](http://en.wikipedia.org/wiki/Hostname)是可以转换为 IP 地址的名称。单个主机名可以在不同时间映射到不同的
    IP 地址；多个主机名可以映射到同一个 IP 地址。例如：'
- en: '`web.mit.edu` is the name for MIT’s web server. You can translate this name
    to an IP address yourself using `dig`, `host`, or `nslookup` on the command line,
    e.g.:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web.mit.edu` 是 MIT 网页服务器的名称。你可以使用命令行上的 `dig`、`host` 或 `nslookup` 自己将此名称翻译为
    IP 地址，例如：'
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`dmz-mailsec-scanner-4.mit.edu` is the name for one of MIT’s spam filter machines
    responsible for handling incoming email.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dmz-mailsec-scanner-4.mit.edu` 是 MIT 的垃圾邮件过滤器机器之一，负责处理传入的电子邮件。'
- en: '`google.com` is exactly what you think it is. Try using one of the commands
    above to find `google.com`’s IP address. What do you see?'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.com` 就是你想象的那样。尝试使用上面的其中一条命令找到 `google.com` 的 IP 地址。你看到了什么？'
- en: '`localhost` is a name for `127.0.0.1`. When you want to talk to a server running
    on your own machine, talk to `localhost`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost` 是 `127.0.0.1` 的名称。当你想要与自己机器上运行的服务器通信时，请与 `localhost` 通信。'
- en: Translation from hostnames to IP addresses is the job of the [Domain Name System
    (DNS)](http://en.wikipedia.org/wiki/Domain_Name_System). It’s super cool, but
    not part of our discussion today.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名到 IP 地址的转换是 [域名系统（DNS）](http://en.wikipedia.org/wiki/Domain_Name_System)的工作。它非常酷，但不是我们今天讨论的内容的一部分。
- en: Port numbers
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口号
- en: A single machine might have multiple server applications that clients wish to
    connect to, so we need a way to direct traffic on the same network interface to
    different processes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单台机器可能有多个客户端希望连接到的服务器应用程序，因此我们需要一种将同一网络接口上的流量定向到不同进程的方法。
- en: Network interfaces have multiple [ports](http://en.wikipedia.org/wiki/Port_(computer_networking))
    identified by a 16-bit number from 0 (which is reserved, so we effectively start
    at 1) to 65535.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 网络接口有多个由 0（保留，因此我们实际上从 1 开始）到 65535 的 16 位数字标识的[端口](http://en.wikipedia.org/wiki/Port_(computer_networking))。
- en: 'A server process binds to a particular port — it is now **listening** on that
    port. Clients have to know which port number the server is listening on. There
    are some [well-known ports](http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports)
    which are reserved for system-level processes and provide standard ports for certain
    services. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器进程绑定到特定的端口 —— 现在它在该端口上**监听**。客户端必须知道服务器正在监听的端口号。有一些[众所周知的端口](http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports)保留用于系统级进程，并为某些服务提供标准端口。例如：
- en: Port 22 is the standard SSH port. When you connect to `athena.dialup.mit.edu`
    using SSH, the software automatically uses port 22.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口 22 是标准的 SSH 端口。当你使用 SSH 连接到 `athena.dialup.mit.edu` 时，软件会自动使用端口 22。
- en: Port 25 is the standard email server port.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口 25 是标准的电子邮件服务器端口。
- en: Port 80 is the standard web server port. When you connect to the URL `http://web.mit.edu`
    in your web browser, it connects to `18.9.22.69` on port 80.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口 80 是标准的网络服务器端口。当你在网络浏览器中连接到 URL `http://web.mit.edu` 时，它连接到端口 80 上的 `18.9.22.69`。
- en: When the port is not a standard port, it is specified as part of the address.
    For example, the URL `http://128.2.39.10:9000` refers to port 9000 on the machine
    at `128.2.39.10`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当端口不是标准端口时，它被指定为地址的一部分。例如，URL `http://128.2.39.10:9000` 指的是位于 `128.2.39.10`
    的机器上的端口 9000。
- en: When a client connects to a server, that outgoing connection also uses a port
    number on the client’s network interface, usually chosen at random from the available
    *non*-well-known ports.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接到服务器时，出站连接也使用客户端网络接口上的端口号，通常从可用的*非*-众所周知的端口中随机选择。
- en: Network sockets
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络套接字
- en: A [**socket**](http://en.wikipedia.org/wiki/Network_socket) represents one end
    of the connection between client and server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[**套接字**](http://en.wikipedia.org/wiki/Network_socket)表示客户端和服务器之间连接的一端。'
- en: A **listening socket** is used by a server process to wait for connections from
    remote clients.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监听套接字**由服务器进程用于等待来自远程客户端的连接。'
- en: In Java, use [`ServerSocket`](http://docs.oracle.com/javase/8/docs/api/?java/net/ServerSocket.html)
    to make a listening socket, and use its [`accept`](http://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html#accept--)
    method to listen to it.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Java 中，使用 [`ServerSocket`](http://docs.oracle.com/javase/8/docs/api/?java/net/ServerSocket.html)
    创建一个监听套接字，并使用它的 [`accept`](http://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html#accept--)
    方法监听它。
- en: A **connected socket** can send and receive messages to and from the process
    on the other end of the connection. It is identified by both the local IP address
    and port number plus the remote address and port, which allows a server to differentiate
    between concurrent connections from different IPs, or from the same IP on different
    remote ports.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**连接的套接字**可以与连接另一端的进程发送和接收消息。它由本地IP地址和端口号以及远程地址和端口号标识，这使得服务器可以区分来自不同IP的并发连接，或者来自同一IP的不同远程端口。
- en: In Java, clients use a [`Socket`](http://docs.oracle.com/javase/8/docs/api/?java/net/Socket.html)
    constructor to establish a socket connection to a server. Servers obtain a connected
    socket as a `Socket` object returned from `ServerSocket.accept`.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Java中，客户端使用[`Socket`](http://docs.oracle.com/javase/8/docs/api/?java/net/Socket.html)构造函数来建立与服务器的套接字连接。服务器从`ServerSocket.accept`返回的`Socket`对象中获取一个连接的套接字。
- en: I/O
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O
- en: Buffers
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区
- en: The data that clients and servers exchange over the network is sent in chunks.
    These are rarely just byte-sized chunks, although they might be. The sending side
    (the client sending a request or the server sending a response) typically writes
    a large chunk (maybe a whole string like “HELLO, WORLD!” or maybe 20 megabytes
    of video data). The network chops that chunk up into packets, and each packet
    is routed separately over the network. At the other end, the receiver reassembles
    the packets together into a stream of bytes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器在网络上交换的数据是以块的形式发送的。这些块很少只是字节大小的块，尽管可能是。发送方（发送请求的客户端或发送响应的服务器）通常会写入一个大块（也许是一个整个字符串，比如“HELLO,
    WORLD!”，或者是20兆字节的视频数据）。网络将该块切成数据包，每个数据包单独在网络上路由。在另一端，接收方将数据包重新组装成字节流。
- en: The result is a bursty kind of data transmission — the data may already be there
    when you want to read them, or you may have to wait for them to arrive and be
    reassembled.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一种突发的数据传输方式——当您想要读取数据时，数据可能已经存在，或者您可能需要等待它们到达并重新组装。
- en: When data arrive, they go into a **buffer**, an array in memory that holds the
    data until you read it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据到达时，它们进入一个**缓冲区**，这是一个在内存中保存数据直到您读取它的数组。
- en: reading exercises
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取练习
- en: Client server socket buffer*
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端服务器套接字缓冲区*
- en: You’re developing a new web server program on your own laptop. You start the
    server running on port 8080.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在自己的笔记本电脑上开发一个新的Web服务器程序。您在端口8080上启动服务器运行。
- en: 'Fill in the blanks for the URL you should visit in your web browser to talk
    to your server:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 填写应在Web浏览器中访问的URL以与服务器通信：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <select class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(missing
    answer)<select class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(missing
    answer)<select class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(missing
    answer)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(缺失答案)<select
    class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(缺失答案)<select
    class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(缺失答案)
- en: (missing explanation)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Address hostname network stuffer*(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 地址主机名网络填充物*(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: '* see [***What if Dr. Seuss Did Technical Writing?***](http://web.mit.edu/adorai/www/seuss-technical-writing.html),
    although the issue described in the first stanza is no longer relevant with the
    obsolescence of floppy disk drives'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '* 参见[***如果苏斯博士从事技术写作会怎样？***](http://web.mit.edu/adorai/www/seuss-technical-writing.html)，尽管第一节中描述的问题随着软盘驱动器的过时已不再相关。'
- en: Streams
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流
- en: The data going into or coming out of a socket is a [**stream**](http://en.wikipedia.org/wiki/Stream_(computing))
    of bytes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 进入或离开套接字的数据是字节的[**流**](http://en.wikipedia.org/wiki/Stream_(computing))。
- en: 'In Java, [`InputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/InputStream.html)
    objects represent sources of data flowing into your program. For example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，[`InputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/InputStream.html)对象代表流入程序的数据源。例如：
- en: Reading from a file on disk with a [`File­Input­Stream`](http://docs.oracle.com/javase/8/docs/api/?java/io/FileInputStream.html)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 [`File­Input­Stream`](http://docs.oracle.com/javase/8/docs/api/?java/io/FileInputStream.html)
    从磁盘上的文件读取。
- en: User input from [`System.in`](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#in)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 [`System.in`](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#in)
    的用户输入。
- en: Input from a network socket
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自网络套接字的输入。
- en: '[`OutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/OutputStream.html)
    objects represent data sinks, places we can write data to. For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[`OutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/OutputStream.html)
    对象代表数据的汇集地，我们可以将数据写入其中。例如：'
- en: '[`FileOutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/FileOutputStream.html)
    for saving to files'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`FileOutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/FileOutputStream.html)
    用于保存到文件。'
- en: '[`System.out`](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out)
    is a [`PrintStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/PrintStream.html),
    an `OutputStream` that prints readable representations of various types'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`System.out`](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out)
    是一个 [`PrintStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/PrintStream.html)，是一个打印各种类型可读表示的
    `OutputStream`。'
- en: Output to a network socket
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出到网络套接字。
- en: 'In the Java Tutorials, read:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java教程中，阅读：
- en: '[I/O Streams](http://docs.oracle.com/javase/tutorial/essential/io/streams.html)
    up to and including *I/O from the Command Line* (8 pages)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I/O Streams](http://docs.oracle.com/javase/tutorial/essential/io/streams.html)
    包括 *从命令行进行I/O*（8页）。'
- en: With sockets, remember that the *output* of one process is the *input* of another
    process. If Alice and Bob have a socket connection, Alice has an output stream
    that flows to Bob’s input stream, and *vice versa*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于套接字，请记住一个进程的 *输出* 是另一个进程的 *输入*。如果Alice和Bob有一个套接字连接，那么Alice有一个输出流流向Bob的输入流，*反之亦然*。
- en: Blocking
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞。
- en: '**Blocking** means that a thread waits (without doing further work) until an
    event occurs. We can use this term to describe methods and method calls: if a
    method is a **blocking method**, then a call to that method can **block**, waiting
    until some event occurs before it returns to the caller.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻塞** 意味着线程等待（而不是继续工作），直到事件发生。我们可以用这个术语来描述方法和方法调用：如果一个方法是 **阻塞方法**，那么对该方法的调用可能会
    **阻塞**，等待某些事件发生后才返回给调用者。'
- en: 'Socket input/output streams exhibit blocking behavior:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字的输入/输出流表现出阻塞行为：
- en: When an incoming socket’s buffer is empty, calling `read` blocks until data
    are available.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传入套接字的缓冲区为空时，调用 `read` 将阻塞，直到数据可用。
- en: When the destination socket’s buffer is full, calling `write` blocks until space
    is available.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当目标套接字的缓冲区已满时，调用 `write` 将阻塞，直到有空间可用。
- en: Blocking is very convenient from a programmer’s point of view, because the programmer
    can write code as if the `read` (or `write`) call will always work, no matter
    what the timing of data arrival. If data (or for `write`, space) is already available
    in the buffer, the call might return very quickly. But if the read or write can’t
    succeed, the call **blocks**. The operating system takes care of the details of
    delaying that thread until `read` or `write` *can* succeed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，阻塞非常方便，因为程序员可以编写代码，仿佛 `read`（或 `write`）调用总是有效的，不管数据到达的时间如何。如果缓冲区中已经有数据（或者对于
    `write`，有空间），那么调用可能会非常快速地返回。但是如果读取或写入不能成功，调用将**阻塞**。操作系统会处理延迟线程直到 `read` 或 `write`
    *可以*成功的细节。
- en: Blocking happens throughout concurrent programming, not just in [I/O](http://en.wikipedia.org/wiki/Input/output)
    (communication into and out of a process, perhaps over a network, or to/from a
    file, or with the user on the command line or a GUI, …). Concurrent modules don’t
    work in lockstep, like sequential programs do, so they typically have to wait
    for each other to catch up when coordinated action is required.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞发生在整个并发编程过程中，不仅仅是在[I/O](http://en.wikipedia.org/wiki/Input/output)（进程之间的通信，可能通过网络，或者到/从文件，或者与用户在命令行或GUI上的交互等）中。并发模块不像顺序程序那样一步一步地工作，因此当需要协调行动时，它们通常必须等待对方赶上。
- en: 'We’ll see in the next reading that this waiting gives rise to the second major
    kind of bug (the first was race conditions) in concurrent programming: **deadlock**,
    where modules are waiting for each other to do something, so none of them can
    make any progress. But that’s for next time.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一篇阅读中看到，这种等待会引发并发编程中的第二种主要错误（第一种是竞争条件）：**死锁**，其中模块等待对方执行某些操作，因此它们都无法取得任何进展。但这是下次的话题。
- en: Using network sockets
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用网络套接字。
- en: 'Make sure you’ve read about [streams](#streams) at the Java Tutorial link above,
    then read about network sockets:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经阅读了上面Java教程链接中关于[流](#streams)的内容，然后再阅读关于网络套接字的内容：
- en: 'In the Java Tutorials, read:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java教程中，阅读：
- en: '[All About Sockets](http://docs.oracle.com/javase/tutorial/networking/sockets/index.html)
    (4 pages)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[套接字的一切](http://docs.oracle.com/javase/tutorial/networking/sockets/index.html)（4页）'
- en: This reading describes everything you need to know about creating server- and
    client-side sockets and writing to and reading from their I/O streams.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇阅读介绍了关于创建服务器端和客户端套接字以及写入和读取它们的I/O流的一切知识。
- en: On the second page
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在第二页
- en: 'The example uses a syntax we haven’t seen: the [try-with-resources](http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)
    statement. This statement has the form:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用了我们没有见过的语法：[try-with-resources](http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)语句。该语句的形式为：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the last page
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在最后一页
- en: Notice how both `ServerSocket.accept()` and `in.readLine()` are *blocking*.
    This means that the server will need a *new thread* to handle I/O with each new
    client. While the client-specific thread is working with that client (perhaps
    blocked in a read or a write), another thread (perhaps the main thread) is blocked
    waiting to `accept` a new connection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`ServerSocket.accept()`和`in.readLine()`都是*阻塞*的。这意味着服务器将需要一个*新线程*来处理每个新客户端的I/O。当客户端特定的线程正在与该客户端交互（可能在读取或写入时被阻塞），另一个线程（可能是主线程）正在等待`accept`一个新连接。
- en: Unfortunately, their multithreaded Knock Knock Server implementation creates
    that new thread by *subclassing `Thread`*. That’s *not* the recommended strategy.
    Instead, create a new class that implements `Runnable`, or [use an anonymous `Runnable`](../19-concurrency/anonymous-runnable/)
    that calls a method where that client connection will be handled until it’s closed.
    Don’t use ~~`extends Thread`~~. And while subclassing was popular when the Java
    API was designed, we don’t discuss or recommend it at all because it has many
    downsides.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，他们的多线程Knock Knock服务器实现通过*子类化`Thread`*来创建新线程。这不是推荐的策略。相反，创建一个实现`Runnable`的新类，或者[使用匿名`Runnable`](../19-concurrency/anonymous-runnable/)调用一个方法，在那里处理客户端连接直到关闭。不要使用~~`extends
    Thread`~~。虽然在Java API设计时子类化很流行，但我们不讨论或推荐它，因为它有很多缺点。
- en: reading exercises
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Network sockets 1
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字 1
- en: Alice has a connected socket with Bob. How does she send a message to Bob?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝与鲍勃有一个连接的套接字。她如何向鲍勃发送消息？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Network sockets 2
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字 2
- en: Which of these is it necessary for a client to know in order to connect to and
    communicate with a server?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端为了连接和与服务器通信，有必要了解这些哪些内容？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Echo echo echo echo
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 回声回声回声回声
- en: In the [EchoClient](http://docs.oracle.com/javase/tutorial/displayCode.html?code=http://docs.oracle.com/javase/tutorial/networking/sockets/examples/EchoClient.java)
    example, which of these might *block*?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在[EchoClient](http://docs.oracle.com/javase/tutorial/displayCode.html?code=http://docs.oracle.com/javase/tutorial/networking/sockets/examples/EchoClient.java)示例中，哪些可能*阻塞*？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: And in [EchoServer](http://docs.oracle.com/javase/tutorial/displayCode.html?code=http://docs.oracle.com/javase/tutorial/networking/sockets/examples/EchoServer.java),
    which of these might *block*?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在[EchoServer](http://docs.oracle.com/javase/tutorial/displayCode.html?code=http://docs.oracle.com/javase/tutorial/networking/sockets/examples/EchoServer.java)中，哪些可能*阻塞*？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Block block block block
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞 阻塞 阻塞 阻塞
- en: 'Since `BufferedReader.readLine()` is a *blocking* method, which of these is
    true:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BufferedReader.readLine()`是一个*阻塞*方法，以下哪个是正确的：
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Wire protocols
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线路协议
- en: Now that we have our client and server connected up with sockets, what do they
    pass back and forth over those sockets?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过套接字连接了客户端和服务器，它们之间通过这些套接字传递什么？
- en: A **protocol** is a set of messages that can be exchanged by two communicating
    parties. A **wire protocol** in particular is a set of messages represented as
    byte sequences, like `hello world` and `bye` (assuming we’ve agreed on a way to
    encode those characters into bytes).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**是两个通信方可以交换的消息集合。特别是**线路协议**是一组以字节序列表示的消息，比如`hello world`和`bye`（假设我们已经同意了一种将这些字符编码成字节的方式）。'
- en: Many Internet applications use simple ASCII-based wire protocols. You can use
    a program called Telnet to check them out.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网应用程序使用简单的基于 ASCII 的线路协议。你可以使用一个名为 Telnet 的程序来查看它们。
- en: Telnet client
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Telnet 客户端
- en: '`telnet` is a utility that allows you to make a direct network connection to
    a listening server and communicate with it via a terminal interface. Linux and
    Mac OS X should have `telnet` installed by default.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`telnet`是一个实用程序，允许你直接连接到一个监听服务器并通过终端界面与其通信。Linux 和 Mac OS X 应该默认安装了`telnet`。'
- en: Windows users should first check if telnet is installed by running the command
    `telnet` on the command line.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户应该首先通过在命令行上运行`telnet`命令来检查 telnet 是否已安装。
- en: If you do not have `telnet`, you can install it via Control Panel → Programs
    and Features → Turn Windows features on/off → Telnet client. However, this version
    of `telnet` may be very hard to use. If it does not show you what you’re typing,
    you will need to [turn on the `localecho` option](https://technet.microsoft.com/en-us/library/c.aspx).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有安装`telnet`，可以通过控制面板 → 程序和功能 → 打开或关闭 Windows 功能 → Telnet 客户端进行安装。然而，这个版本的`telnet`可能会非常难用。如果它不显示你正在输入的内容，你需要[打开`localecho`选项](https://technet.microsoft.com/en-us/library/c.aspx)。
- en: 'A better alternative is PuTTY: [download `putty.exe`](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).
    To connect using PuTTY, enter a hostname and port, select Connection type: Raw,
    and Close window on exit: Never. The last option will prevent the window from
    disappearing as soon as the server closes its end of the connection.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更好的选择是 PuTTY：[下载`putty.exe`](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html)。使用
    PuTTY 进行连接时，输入主机名和端口，选择连接类型：原始，以及在退出时关闭窗口：从不。最后一个选项将防止窗口在服务器关闭连接端时立即消失。
- en: 'Let’s look at some examples of wire protocols:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些线路协议的示例：
- en: HTTP
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP
- en: '[Hypertext Transfer Protocol (HTTP)](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)
    is the language of the World Wide Web. We already know that port 80 is the well-known
    port for speaking HTTP to web servers, so let’s talk to one on the command line.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[超文本传输协议（HTTP）](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)是万维网的语言。我们已经知道端口
    80 是向 Web 服务器发出 HTTP 请求的常用端口，所以让我们在命令行上与一个通信。'
- en: 'You''ll be using Telnet on the problem set, so try these out now. User input
    is shown in **green**, and for input to the telnet connection, newlines (pressing
    enter) are shown with **↵**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在问题集中使用 Telnet，所以现在试试这些吧。用户输入显示为**绿色**，Telnet 连接的输入使用**↵**表示新行（按回车键）：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `GET` command gets a web page. The `/` is the path of the page you want
    on the site. So this command fetches the page at `http://www.eecs.mit.edu:80/`.
    Since 80 is the default port for HTTP, this is equivalent to visiting [http://www.eecs.mit.edu/](http://www.eecs.mit.edu/)
    in your web browser. The result is HTML code that your browser renders to display
    the EECS homepage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`命令获取一个网页。`/`是网站上你想要的页面的路径。所以这个命令获取了`http://www.eecs.mit.edu:80/`页面。由于
    80 是 HTTP 的默认端口，这相当于在你的 Web 浏览器中访问[http://www.eecs.mit.edu/](http://www.eecs.mit.edu/)。结果是
    HTML 代码，你的浏览器渲染以显示 EECS 主页。'
- en: 'Internet protocols are defined by [RFC specifications](http://en.wikipedia.org/wiki/Request_for_Comments)
    (RFC stands for “request for comment”, and some RFCs are eventually adopted as
    standards). [RFC 1945](http://tools.ietf.org/html/rfc1945) defined HTTP version
    1.0, and was superseded by HTTP 1.1 in [RFC 2616](http://tools.ietf.org/html/rfc2616).
    So for many web sites, you might need to speak HTTP 1.1 if you want to talk to
    them. For example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议由[RFC 规范](http://en.wikipedia.org/wiki/Request_for_Comments)定义（RFC 代表“请求评论”，一些
    RFC 最终被采纳为标准）。[RFC 1945](http://tools.ietf.org/html/rfc1945)定义了 HTTP 1.0 版，并被[RFC
    2616](http://tools.ietf.org/html/rfc2616)中的 HTTP 1.1 所取代。所以对于许多网站，如果你想与它们交流，你可能需要使用
    HTTP 1.1。例如：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, your request must end with a blank line. HTTP version 1.1 requires
    the client to specify some extra information (called headers) with the request,
    and the blank line signals the end of the headers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你的请求必须以一个空行结束。HTTP 1.1 要求客户端在请求中指定一些额外信息（称为头部），而空行表示头部的结束。
- en: 'You will also more than likely find that telnet does not exit after making
    this request — this time, the server keeps the connection open so you can make
    another request right away. To quit Telnet manually, type the escape character
    (probably `Ctrl`-`]`) to bring up the `telnet>` prompt, and type `quit`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会发现，在发出请求后，telnet并没有退出 — 这次，服务器保持连接打开，这样你可以立即发出另一个请求。要手动退出Telnet，请键入转义字符（可能是`Ctrl`-`]`）以显示`telnet>`提示符，然后键入`quit`：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: SMTP
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SMTP
- en: '[Simple Mail Transfer Protocol (SMTP)](http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol)
    is the protocol for sending email (different protocols are used for client programs
    that retrieve email from your inbox). Because the email system was designed in
    a time before spam, modern email communication is fraught with traps and heuristics
    designed to prevent abuse. But we can still try to speak SMTP. Recall that the
    well-known SMTP port is 25, and `dmz-mailsec-scanner-4.mit.edu` was the name of
    a MIT email handler.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[简单邮件传输协议（SMTP）](http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol)是用于发送电子邮件的协议（用于从收件箱检索电子邮件的客户端程序使用不同的协议）。因为电子邮件系统是在垃圾邮件出现之前设计的，现代电子邮件通信充满了旨在防止滥用的陷阱和启发式方法。但我们仍然可以尝试使用SMTP。请记住，众所周知的SMTP端口是25，`dmz-mailsec-scanner-4.mit.edu`是MIT的一个电子邮件处理程序的名称。'
- en: 'You’ll need to fill in *your-IP-address-here* and *your-username-here*, and
    the ↵ indicate newlines for clarity. This will only work if you’re on MITnet,
    and even then your mail might be rejected for looking suspicious:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要填写*your-IP-address-here*和*your-username-here*，↵表示换行以便清晰显示。只有当你在MITnet上时才能正常工作，即使如此，你的邮件可能因看起来可疑而被拒绝：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SMTP is quite chatty in comparison to HTTP, providing some human-readable instructions
    like `continue. finished with "\r\n.\r\n"` to tell us how to terminate our message
    content.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP相比，SMTP相当啰嗦，提供一些人类可读的指令，比如`continue. finished with "\r\n.\r\n"`告诉我们如何终止消息内容。
- en: Designing a wire protocol
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计线路协议
- en: 'When designing a wire protocol, apply the same rules of thumb you use for designing
    the operations of an abstract data type:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计线路协议时，应用设计抽象数据类型操作时使用的相同经验法则：
- en: Keep the number of different messages **small**. It’s better to have a few commands
    and responses that can be combined rather than many complex messages.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持不同消息的数量**少**。最好有一些可以组合的简单命令和响应，而不是许多复杂的消息。
- en: Each message should have a well-defined purpose and **coherent** behavior.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条消息应该有明确定义的目的和**连贯**行为。
- en: The set of messages must be **adequate** for clients to make the requests they
    need to make and for servers to deliver the results.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息集必须足够**充分**，以便客户端发出需要的请求，服务器交付结果。
- en: Just as we demand representation independence from our types, we should aim
    for **platform-independence** in our protocols. HTTP can be spoken by any web
    server and any web browser on any operating system. The protocol doesn’t say anything
    about how web pages are stored on disk, how they are prepared or generated by
    the server, what algorithms the client will use to render them, etc.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们要求类型具有表示独立性一样，我们应该在协议中追求**平台独立性**。HTTP可以被任何操作系统上的任何Web服务器和任何Web浏览器使用。协议不涉及Web页面如何存储在磁盘上，它们如何由服务器准备或生成，客户端将使用什么算法来呈现它们���等。
- en: 'We can also apply the three big ideas in this class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这节课中应用三个重要的想法：
- en: '**Safe from bugs**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误的影响**'
- en: The protocol should be easy for clients and servers to generate and parse. Simpler
    code for reading and writing the protocol (whether written with a parser generator
    like ANTLR, with regular expressions, etc.) will have fewer opportunities for
    bugs.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议应该易于客户端和服务器生成和解析。使用解析器生成器（如ANTLR）、正则表达式等编写的读取和写入协议的简单代码将减少错误的机会。
- en: Consider the ways a broken or malicious client or server could stuff garbage
    data into the protocol to break the process on the other end.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑破坏或恶意客户端或服务器可能将垃圾数据插入协议以破坏另一端过程的方式。
- en: 'Email spam is one example: when we spoke SMTP above, the mail server asked
    *us* to say who was sending the email, and there’s nothing in SMTP to prevent
    us from lying outright. We’ve had to build systems on top of SMTP to try to stop
    spammers who lie about `From:` addresses.'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电子邮件垃圾邮件就是一个例子：当我们上面使用SMTP时，邮件服务器要求*我们*说出谁发送了电子邮件，而SMTP中没有任何内容可以阻止我们彻底撒谎。我们不得不在SMTP之上构建系统，以尝试阻止谎称`From:`地址的垃圾邮件发送者。
- en: Security vulnerabilities are a more serious example. For example, protocols
    that allow a client to send requests with arbitrary amounts of data require careful
    handling on the server to avoid running out of buffer space, [or worse](http://en.wikipedia.org/wiki/Buffer_overflow).
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安全漏洞是一个更严重的例子。例如，允许客户端发送具有任意数量数据的请求的协议需要服务器小心处理，以避免耗尽缓冲区空间，[或更糟](http://en.wikipedia.org/wiki/Buffer_overflow)。
- en: '**Easy to understand**: for example, choosing a text-based protocol means that
    we can debug communication errors by reading the text of the client/server exchange.
    It even allows us to speak the protocol “by hand” as we saw above.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**：例如，选择文本协议意味着我们可以通过阅读客户端/服务器交换的文本来调试通信错误。甚至允许我们像上面看到的那样手动“说”协议。'
- en: '**Ready for change**: for example, HTTP includes the ability to specify a version
    number, so clients and servers can agree with one another which version of the
    protocol they will use. If we need to make changes to the protocol in the future,
    older clients or servers can continue to work by announcing the version they will
    use.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备好改变**：例如，HTTP包括指定版本号的能力，因此客户端和服务器可以互相协商他们将使用的协议版本。如果我们需要在将来对协议进行更改，较旧的客户端或服务器可以继续通过宣布他们将使用的版本来工作。'
- en: '[**Serialization**](http://en.wikipedia.org/wiki/Serialization) is the process
    of transforming data structures in memory into a format that can be easily stored
    or transmitted (not the same as [serializability from *Thread Safety*](../20-thread-safety/#serializability)).
    Rather than invent a new format for serializing your data between clients and
    servers, use an existing one. For example, [JSON (JavaScript Object Notation)](http://en.wikipedia.org/wiki/JSON)
    is a simple, widely-used format for serializing basic values, arrays, and maps
    with string keys.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[**序列化**](http://en.wikipedia.org/wiki/Serialization)是将内存中的数据结构转换为可以轻松存储或传输的格式的过程（与[*线程安全*](../20-thread-safety/#serializability)中的可序列化性不同）。与发明一个新的格式来在客户端和服务器之间序列化您的数据不同，使用现有的格式。例如，[JSON（JavaScript对象表示法）](http://en.wikipedia.org/wiki/JSON)是一种简单、广泛使用的格式，用于序列化基本值、数组和具有字符串键的映射。'
- en: Specifying a wire protocol
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定一个线路协议
- en: In order to precisely define for clients & servers what messages are allowed
    by a protocol, use a grammar.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确地为客户端和服务器定义协议允许的消息，使用一个语法。
- en: 'For example, here is a very small part of the HTTP 1.1 request grammar from
    [RFC 2616 section 5](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是来自[RFC 2616第5节](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)的HTTP
    1.1请求语法的一个非常小的部分：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the grammar, we can see that in this example request from earlier:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法，我们可以看到在这个早期的请求示例中：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`GET` is the `method`: we’re asking the server to get a page for us.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 是 `method`：我们要求服务器为我们获取一个页面。'
- en: '`/aboutmit/` is the `request-uri`: the description of what we want to get.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/aboutmit/` 是 `request-uri`：描述我们想要获取的内容。'
- en: '`HTTP/1.1` is the `http-version`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP/1.1` 是 `http-version`。'
- en: '`Host: web.mit.edu` is some kind of header — we would have to examine the rules
    for each of the `...-header` options to discover which one.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host: web.mit.edu` 是某种标题 — 我们需要检查每个 `...-header` 选项的规则，以确定哪一个是。'
- en: 'And we can see why we had to end the request with a blank line: since a single
    `request` can have multiple headers that end in CRLF (newline), we have another
    CRLF at the end to finish the `request`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到为什么我们必须以一个空行结束请求：因为一个`request`可以有多个以CRLF（换行符）结尾的头部，我们在末尾有另一个CRLF来结束`request`。
- en: We don’t have any `message-body` — and since the server didn’t wait to see if
    we would send one, presumably that only applies for other kinds of requests.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有任何`message-body` — 而且由于服务器没有等待看我们是否会发送一个，可以推断这只适用于其他类型的请求。
- en: 'The grammar is not enough: it fills a similar role to method signatures when
    defining an ADT. We still need the specifications:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是不够的：它填补了在定义ADT时的方法签名的类似角色。我们仍然需要规范：
- en: '**What are the preconditions of a message?** For example, if a particular field
    in a message is a string of digits, is any number valid? Or must it be the ID
    number of a record known to the server?'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息的前提条件是什么？** 例如，如果消息中的特定字段是一串数字，任何数字都有效吗？还是必须是服务器已知的记录的ID号？'
- en: Under what circumstances can a message be sent? Are certain messages only valid
    when sent in a certain sequence?
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在什么情况下可以发送消息？某些消息只有在特定顺序发送时才有效吗？
- en: '**What are the postconditions?** What action will the server take based on
    a message? What server-side data will be mutated? What reply will the server send
    back to the client?'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后置条件是什么？**服务器将根据消息采取什么行动？服务器端数据将发生什么变化？服务器将向客户端发送什么回复？'
- en: reading exercises
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Wire protocols 1
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 传输协议 1
- en: Which of the following tools could you use to speak HTTP with a web server?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些工具可以用来与 Web 服务器通信？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Wire protocols 2
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 传输协议 2
- en: Consider this example wire protocol, specified using two grammars…
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个示例的传输协议，使用两个语法规则来指定……
- en: '**Messages from the client to the server**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端发送到服务器的消息**'
- en: The client can turn lights, identified by numerical IDs, on and off. The client
    can also request help.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以打开和关闭由数字 ID 标识的灯。客户端还可以请求帮助。
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Messages from the server to the client**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器发送到客户端的消息**'
- en: The server can report the status of the lights and provides arbitrary help messages.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以报告灯的状态并提供任意的帮助消息。
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll use ↵ to represent a newline.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 ↵ 来表示换行符。
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Testing client/server code
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试客户端/服务器代码
- en: Remember that [concurrency is hard to test and debug](../19-concurrency/#concurrency_is_hard_to_test_and_debug).
    We can’t reliably reproduce race conditions, and the network adds a source of
    latency that is entirely beyond our control. You need to design for concurrency
    and argue carefully for the correctness of your code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，[并发测试和调试很困难](../19-concurrency/#concurrency_is_hard_to_test_and_debug)。我们无法可靠地重现竞争条件，而且网络增加了一个完全超出我们控制范围的延迟源。你需要设计并仔细论证代码的正确性。
- en: Separate network code from data structures and algorithms
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将网络代码与数据结构和算法分开
- en: Most of the ADTs in your client/server program don’t need to rely on networking.
    Make sure you specify, test, and implement them as separate components that are
    safe from bugs, easy to understand, and ready for change — in part because they
    don’t involve any networking code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的客户端/服务器程序中，大多数 ADT 不需要依赖网络。确保您将它们指定、测试和实现为独立的组件，这些组件不容易出错，易于理解，并且准备好进行更改——部分原因是因为它们不涉及任何网络代码。
- en: If those ADTs will need to be used concurrently from multiple threads (for example,
    threads handling different client connections), our next reading will discuss
    your options. Otherwise, use the [thread safety strategies of confinement, immutability,
    and existing threadsafe data types](../20-thread-safety/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那些 ADT 需要从多个线程并发使用（例如，处理不同客户端连接的线程），我们下一步的阅读将讨论您的选择。否则，请使用[封装、不可变性和现有线程安全数据类型的线程安全策略](../20-thread-safety/)。
- en: Separate socket code from stream code
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将套接字代码与流代码分开
- en: A function or module that needs to read from and write to a socket may only
    need access to the input/output streams, not to the socket itself. This design
    allows you to test the module by connecting it to streams that don’t come from
    a socket.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 需要从套接字读取和写入的函数或模块可能只需要访问输入/输出流，而不需要访问套接字本身。这种设计允许您通过连接到不来自套接字的流来测试该模块。
- en: 'Two useful Java classes for this are [`ByteArray­InputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/ByteArrayInputStream.html)
    and [`ByteArray­OutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/ByteArrayOutputStream.html).
    Suppose we want to test this method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的的两个有用的 Java 类是[`ByteArray­InputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/ByteArrayInputStream.html)和[`ByteArray­OutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/ByteArrayOutputStream.html)。假设我们要测试这个方法：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The method is normally used with a socket:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通常与套接字一起使用：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the case conversion is a function we implement, it should already be specified,
    tested, and implemented separately. But now we can also test the read/write behavior
    of `upperCaseLine`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大小写转换是我们实现的一个函数，那么它应该已经被指定、测试和单独实现了。但现在我们还可以测试`upperCaseLine`的读/写行为：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this test, `inBytes` and `outBytes` are [**test stubs**](../03-testing/#unit_testing_and_stubs).
    To isolate and test just `upperCaseLine`, we replace the components it normally
    depends on (input/output streams from a socket) with components that satisfy the
    same spec but have canned behavior: an input stream with fixed input, and an output
    stream that stores the output in memory.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，`inBytes` 和 `outBytes` 是[**测试桩**](../03-testing/#unit_testing_and_stubs)。为了隔离并测试
    `upperCaseLine`，我们用满足相同规范但具有固定行为的组件（一个具有固定输入的输入流，以及将输出存储在内存中的输出流）替换它通常依赖的组件（来自套接字的输入/输出流）。
- en: Testing strategies for more complex modules might use a **mock object** to simulate
    the behavior of a real client or server by producing entire canned sequences of
    interaction and asserting the correctness of each message received from the other
    component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂模块的测试策略可能会使用**模拟对象**来模拟真实客户端或服务器的行为，通过生成整个预定义的交互序列并断言从另一个组件接收到的每条消息的正确性。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In the *client/server design pattern*, concurrency is inevitable: multiple
    clients and multiple servers are connected on the network, sending and receiving
    messages simultaneously, and expecting timely replies. A server that *blocks*
    waiting for one slow client when there are other clients waiting to connect to
    it or to receive replies will not make those clients happy. At the same time,
    a server that performs incorrect computations or returns bogus results because
    of concurrent modification to shared mutable data by different clients will not
    make anyone happy.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在*客户端/服务器设计模式*中，并发是不可避免的：多个客户端和多个服务器连接在网络上，同时发送和接收消息，并期望及时回复。一个服务器如果因为等待一个慢速客户端而*阻塞*，而其他客户端正在等待连接或接收回复，那么这个服务器将无法让这些客户端满意。同时，一个服务器如果因为不同客户端对共享可变数据的并发修改而执行不正确的计算或返回虚假结果，也不会让任何人满意。
- en: All the challenges of making our multi-threaded code **safe from bugs**, **easy
    to understand**, and **ready for change** apply when we design network clients
    and servers. These processes run concurrently with one another (often on different
    machines), and any server that wants to talk to multiple clients concurrently
    (or a client that wants to talk to multiple servers) must manage that multi-threaded
    communication.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计网络客户端和服务器时，使我们的多线程代码**免受错误**、**易于理解**和**为变更做好准备**的所有挑战都适用。这些进程同时运行（通常在不同的机器上），任何想要同时与多个客户端通信的服务器（或想要同时与多个服务器通信的客户端）都必须管理这种多线程通信。
