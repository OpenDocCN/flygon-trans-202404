- en: Chapter 2\. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 入门
- en: This chapter is an introduction to Scheme for programmers who are new to the
    language. You will get more from this chapter if you are sitting in front of an
    interactive Scheme system, trying out the examples as you go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是为那些对该语言不熟悉的程序员介绍 Scheme 的。如果你坐在一个交互式 Scheme 系统前，尝试着一边阅读示例一边实践，你会从本章中获得更多。
- en: After reading this chapter and working the exercises, you should be able to
    start using Scheme. You will have learned the syntax of Scheme programs and how
    they are executed, along with how to use simple data structures and control mechanisms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章并完成练习后，你应该能够开始使用 Scheme。你将学会 Scheme 程序的语法以及它们是如何执行的，以及如何使用简单的数据结构和控制机制。
- en: Section 2.1\. Interacting with Scheme
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2.1节 与 Scheme 交互
- en: Most Scheme systems provide an interactive programming environment that simplifies
    program development and experimentation. The simplest interaction with Scheme
    follows a "read-evaluate-print" cycle. A program (often called a *read-evaluate-print
    loop*, or REPL) reads each expression you type at the keyboard, evaluates it,
    and prints its value.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Scheme 系统提供了一个简化程序开发和实验的交互式编程环境。与 Scheme 的最简单交互遵循一个“读取-求值-打印”循环。一个程序（通常称为
    *读取-求值-打印循环*，或 REPL）读取你在键盘上输入的每个表达式，对其进行求值，并打印其值。
- en: 'With an interactive Scheme system, you can type an expression at the keyboard
    and see its value immediately. You can define a procedure and apply it to arguments
    to see how it works. You can even type in an entire program consisting of a set
    of procedure definitions and test it without leaving the system. When your program
    starts getting longer, it will be more convenient to type it into a file (using
    a text editor), load the file and test it interactively. In most Scheme systems,
    a file may be loaded with the nonstandard procedure `load`, which takes a string
    argument naming the file. Preparing your program in a file has several advantages:
    you have a chance to compose your program more carefully, you can correct errors
    without retyping the program, and you can retain a copy for later use. Most Scheme
    implementations treat expressions loaded from a file the same as expressions typed
    at the keyboard.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交互式 Scheme 系统，你可以在键盘上输入一个表达式并立即看到其值。你可以定义一个过程并将其应用于参数以查看其工作原理。甚至可以键入一个由一组过程定义组成的整个程序，并在不离开系统的情况下进行测试。当你的程序变得更长时，将其键入到一个文件中（使用文本编辑器）并进行交互式加载和测试会更方便。在大多数
    Scheme 系统中，可以使用非标准过程 `load` 加载文件，该过程接受一个字符串参数命名文件。将程序准备在文件中具有几个优点：你有机会更加仔细地组织你的程序，可以在不重新键入程序的情况下纠正错误，并且可以保留一份副本以供以后使用。大多数
    Scheme 实现将从文件加载的表达式视为从键盘输入的表达式。
- en: While Scheme provides various input and output procedures, the REPL takes care
    of reading expressions and printing their values. This frees you to concentrate
    on writing your program without worrying about how its results will be displayed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Scheme 提供了各种输入和输出过程，但 REPL 负责读取表达式并打印它们的值。这使你可以专注于编写程序，而不必担心其结果将如何显示。
- en: The examples in this chapter and in the rest of the book follow a regular format.
    An expression you might type from your keyboard is given first, possibly spanning
    several lines. The value of the expression is given after the ![<graphic>](ch2_0.gif),
    to be read as "evaluates to." The ![<graphic>](ch2_0.gif) is omitted for definitions
    and when the value of an expression is unspecified.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分的示例遵循一种常规格式。首先给出你可能从键盘输入的表达式，可能跨越几行。表达式的值在 ![<graphic>](ch2_0.gif)
    之后给出，可读为“求值为”。对于定义和表达式值未指定的情况，会省略 ![<graphic>](ch2_0.gif)。
- en: The example programs are formatted in a style that "looks nice" and conveys
    the structure of the program. The code is easy to read because the relationship
    between each expression and its subexpressions is clearly shown. Scheme ignores
    indentation and line breaks, however, so there is no need to follow a particular
    style. The important thing is to establish one style and keep to it. Scheme sees
    each program as if it were on a single line, with its subexpressions ordered from
    left to right.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 示例程序采用一种“看起来不错”并传达程序结构的样式进行格式化。代码易于阅读，因为每个表达式与其子表达式之间的关系清晰显示。然而，Scheme 忽略缩进和换行，因此无需遵循特定的样式。重要的是要建立一种样式并坚持下去。Scheme
    将每个程序视为在一行上，其子表达式从左到右排序。
- en: If you have access to an interactive Scheme system, it might be a good idea
    to start it up now and type in the examples as you read. One of the simplest Scheme
    expressions is a string constant. Try typing `"Hi Mom!"` (including the double
    quotes) in response to the prompt. The system should respond with `"Hi Mom!"`;
    the value of any constant is the constant itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以访问交互式Scheme系统，现在启动它并在阅读时输入示例可能是个好主意。最简单的Scheme表达式之一是字符串常量。尝试在提示符下键入`"Hi Mom!"`（包括双引号）。系统应该以`"Hi Mom!"`作为响应；任何常量的值都是常量本身。
- en: '`"Hi Mom!" ![<graphic>](ch2_0.gif) "Hi Mom!"`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`"Hi Mom!" ![<graphic>](ch2_0.gif) "Hi Mom!"`'
- en: Here is a set of expressions, each with Scheme's response. They are explained
    in later sections of this chapter, but for now use them to practice interacting
    with Scheme.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一组表达式，每个表达式都有Scheme的响应。它们在本章的后面部分有解释，但现在可以用它们来练习与Scheme的交互。
- en: '`"hello" ![<graphic>](ch2_0.gif) "hello"'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`"hello" ![<graphic>](ch2_0.gif) "hello"'
- en: 42 ![<graphic>](ch2_0.gif) 42
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 42 ![<graphic>](ch2_0.gif) 42
- en: 22/7 ![<graphic>](ch2_0.gif) 22/7
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 22/7 ![<graphic>](ch2_0.gif) 22/7
- en: 3.141592653 ![<graphic>](ch2_0.gif) 3.141592653
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 3.141592653 ![<graphic>](ch2_0.gif) 3.141592653
- en: + ![<graphic>](ch2_0.gif) #<procedure>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: + ![<graphic>](ch2_0.gif) #<procedure>
- en: (+ 76 31) ![<graphic>](ch2_0.gif) 107
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 76 31) ![<graphic>](ch2_0.gif) 107
- en: (* -12 10) ![<graphic>](ch2_0.gif) -120
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: (* -12 10) ![<graphic>](ch2_0.gif) -120
- en: '''(a b c d) ![<graphic>](ch2_0.gif) (a b c d)`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '''(a b c d) ![<graphic>](ch2_0.gif) (a b c d)`'
- en: Be careful not to miss any single quotes ( `'` ), double quotes, or parentheses.
    If you left off a single quote in the last expression, you probably received a
    message indicating that an exception has occurred. Just try again. If you left
    off a closing parenthesis or double quote, the system might still be waiting for
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心不要漏掉任何单引号（`'`），双引号或括号。如果您在最后一个表达式���漏掉了一个单引号，您可能会收到指示发生异常的消息。只需再试一次。如果您漏掉了一个闭括号或双引号，系统可能仍在等待它。
- en: Here are a few more expressions to try. You can try to figure out on your own
    what they mean or wait to find out later in the chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的表达式供尝试。您可以尝试自己弄清楚它们的含义，或者等待在本章后面找出。
- en: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
- en: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
- en: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
- en: (cons (car '(a b c))
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car '(a b c))
- en: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)`
- en: As you can see, Scheme expressions may span more than one line. The Scheme system
    knows when it has an entire expression by matching double quotes and parentheses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Scheme表达式可能跨越多行。Scheme系统通过匹配双引号和括号来确定何时具有完整表达式。
- en: Next, let's try defining a procedure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试定义一个过程。
- en: '`(define square'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define square'
- en: (lambda (n)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (* n n)))`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: (* n n)))`
- en: The procedure `square` computes the square *n*² of any number *n*. We say more
    about the expressions that make up this definition later in this chapter. For
    now it suffices to say that `define` establishes variable bindings, `lambda` creates
    procedures, and `*` names the multiplication procedure. Note the form of these
    expressions. All structured forms are enclosed in parentheses and written in *prefix
    notation*, i.e., the operator precedes the arguments. As you can see, this is
    true even for simple arithmetic operations such as `*`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`square`计算任何数字*n*的平方*n*²。我们稍后会详细介绍构成此定义的表达式。目前，可以说`define`建立变量绑定，`lambda`创建过程，`*`命名乘法过程。请注意这些表达式的形式。所有结构化形式都用括号括起来，并以*前缀表示法*编写，即运算符在参数之前。正如您所见，即使是简单的算术运算，如`*`，这也是正确的。
- en: Try using `square`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`square`。
- en: '`(square 5) ![<graphic>](ch2_0.gif) 25'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`(square 5) ![<graphic>](ch2_0.gif) 25'
- en: (square -200) ![<graphic>](ch2_0.gif) 40000
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: (square -200) ![<graphic>](ch2_0.gif) 40000
- en: (square 0.5) ![<graphic>](ch2_0.gif) 0.25
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: (square 0.5) ![<graphic>](ch2_0.gif) 0.25
- en: (square -1/2) ![<graphic>](ch2_0.gif) 1/4`
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: (square -1/2) ![<graphic>](ch2_0.gif) 1/4`
- en: Even though the next definition is short, you might enter it into a file. Let's
    assume you call the file "reciprocal.ss."
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 即使下一个定义很简短，您可能会将其输入到文件中。假设您将文件命名为"reciprocal.ss"。
- en: '`(define reciprocal'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define reciprocal'
- en: (lambda (n)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (= n 0)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0)
- en: '"oops!"'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '"oops!"'
- en: (/ 1 n))))`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 1 n))))`
- en: This procedure, `reciprocal`, computes the quantity 1/*n* for any number *n*
    ≠ 0. For *n* = 0, `reciprocal` returns the string `"oops!"`. Return to Scheme
    and try loading your file with the procedure `load`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程`reciprocal`计算任何数字*n* ≠ 0的1/*n*的数量。对于*n* = 0，`reciprocal`返回字符串`"oops!"`。返回到Scheme并尝试使用`load`加载您的文件。
- en: '`(load "reciprocal.ss")`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`(load "reciprocal.ss")`'
- en: Finally, try using the procedure we have just defined.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试使用我们刚刚定义的过程。
- en: '`(reciprocal 10) ![<graphic>](ch2_0.gif) 1/10'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocal 10) ![<graphic>](ch2_0.gif) 1/10`'
- en: (reciprocal 1/10) ![<graphic>](ch2_0.gif) 10
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocal 1/10) ![<graphic>](ch2_0.gif) 10`'
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) "oops!"
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocal 0) ![<graphic>](ch2_0.gif) "oops!"`'
- en: (reciprocal (reciprocal 1/10)) ![<graphic>](ch2_0.gif) 1/10`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocal (reciprocal 1/10)) ![<graphic>](ch2_0.gif) 1/10`'
- en: In the next section we will discuss Scheme expressions in more detail. Throughout
    this chapter, keep in mind that your Scheme system is one of the most useful tools
    for learning Scheme. Whenever you try one of the examples in the text, follow
    it up with your own examples. In an interactive Scheme system, the cost of trying
    something out is relatively small---usually just the time to type it in.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地讨论Scheme表达式。在本章中，请记住，你的Scheme系统是学习Scheme最有用的工具之一。每当你尝试文本中的示例之一时，请跟上你自己的示例。在交互式Scheme系统中，尝试某事的成本相对较小---通常只是输入的时间。
- en: Section 2.2\. Simple Expressions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2.2节。简单表达式
- en: The simplest Scheme expressions are constant data objects, such as strings,
    numbers, symbols, and lists. Scheme supports other object types, but these four
    are enough for many programs. We saw some examples of strings and numbers in the
    preceding section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的Scheme表达式是常量数据对象，如字符串、数字、符号和列表。Scheme支持其他对象类型，但这四种对于许多程序已经足够了。在前一节中，我们看到了一些字符串和数字的示例。
- en: Let's discuss numbers in a little more detail. Numbers are constants. If you
    enter a number, Scheme echoes it back to you. The following examples show that
    Scheme supports several types of numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微详细讨论一下数字。数字是常量数据对象。如果你输入一个数字，Scheme会将其回显给你。以下示例显示了Scheme支持几种类型的数字。
- en: '`123456789987654321 ![<graphic>](ch2_0.gif) 123456789987654321'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`123456789987654321 ![<graphic>](ch2_0.gif) 123456789987654321`'
- en: 3/4 ![<graphic>](ch2_0.gif) 3/4
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`3/4 ![<graphic>](ch2_0.gif) 3/4`'
- en: 2.718281828 ![<graphic>](ch2_0.gif) 2.718281828
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`2.718281828 ![<graphic>](ch2_0.gif) 2.718281828`'
- en: 2.2+1.1i ![<graphic>](ch2_0.gif) 2.2+1.1i`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`2.2+1.1i ![<graphic>](ch2_0.gif) 2.2+1.1i`'
- en: Scheme numbers include exact and inexact integer, rational, real, and complex
    numbers. Exact integers and rational numbers have arbitrary precision, i.e., they
    can be of arbitrary size. Inexact numbers are usually represented internally using
    IEEE standard floating-point representations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme数字包括精确和非精确的整数、有理数、实数和复数。精确整数和有理数具有任意精度，即它们可以是任意大小。非精确数通常使用IEEE标准浮点表示内部表示。
- en: Scheme provides the names `+`, `-`, `*`, and `/` for the corresponding arithmetic
    procedures. Each procedure accepts two numeric arguments. The expressions below
    are called *procedure applications*, because they specify the application of a
    procedure to a set of arguments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme为相应的算术过程提供了`+`、`-`、`*`和`/`的名称。每个过程接受两个数值参数。下面的表达式称为*过程应用*，因为它们指定了将过程应用于一组参数。
- en: '`(+ 1/2 1/2) ![<graphic>](ch2_0.gif) 1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ 1/2 1/2) ![<graphic>](ch2_0.gif) 1`'
- en: (- 1.5 1/2) ![<graphic>](ch2_0.gif) 1.0
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`(- 1.5 1/2) ![<graphic>](ch2_0.gif) 1.0`'
- en: (* 3 1/2) ![<graphic>](ch2_0.gif) 3/2
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`(* 3 1/2) ![<graphic>](ch2_0.gif) 3/2`'
- en: (/ 1.5 3/4) ![<graphic>](ch2_0.gif) 2.0`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`(/ 1.5 3/4) ![<graphic>](ch2_0.gif) 2.0`'
- en: Scheme employs prefix notation even for common arithmetic operations. Any procedure
    application, whether the procedure takes zero, one, two, or more arguments, is
    written as `(*procedure* *arg* ...)`. This regularity simplifies the syntax of
    expressions; one notation is employed regardless of the operation, and there are
    no complicated rules regarding the precedence or associativity of operators.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme甚至对于常见的算术操作也采用前缀表示法。任何过程应用，无论过程接受零个、一个、两个还是更多参数，都写为`(*procedure* *arg*
    ...) `。这种规则简化了表达式的语法；无论操作是什么，都使用一种表示法，并且没有关于运算符的优先级或结合性的复杂规则。
- en: Procedure applications may be nested, in which case the innermost values are
    computed first. We can thus nest applications of the arithmetic procedures given
    above to evaluate more complicated formulas.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 过程应用可以嵌套，此时最内层的值首先计算。因此，我们可以嵌套上述算术过程的应用来评估更复杂的公式。
- en: '`(+ (+ 2 2) (+ 2 2)) ![<graphic>](ch2_0.gif) 8'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ (+ 2 2) (+ 2 2)) ![<graphic>](ch2_0.gif) 8`'
- en: (- 2 (* 4 1/3)) ![<graphic>](ch2_0.gif) 2/3
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`(- 2 (* 4 1/3)) ![<graphic>](ch2_0.gif) 2/3`'
- en: (* 2 (* 2 (* 2 (* 2 2)))) ![<graphic>](ch2_0.gif) 32
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`(* 2 (* 2 (* 2 (* 2 2)))) ![<graphic>](ch2_0.gif) 32`'
- en: (/ (* 6/7 7/2) (- 4.5 1.5)) ![<graphic>](ch2_0.gif) 1.0`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`(/ (* 6/7 7/2) (- 4.5 1.5)) ![<graphic>](ch2_0.gif) 1.0`'
- en: These examples demonstrate everything you need to use Scheme as a four-function
    desk calculator. While we will not discuss them in this chapter, Scheme supports
    many other arithmetic procedures. Now might be a good time to turn to Section [6.4](objects.html#g110)
    and experiment with some of them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了你需要将 Scheme 用作四则运算台式计算器的一切。虽然我们不会在本章讨论它们，但 Scheme 支持许多其他算术过程。现在可能是时候转到第[6.4](objects.html#g110)节，并尝试一些其他算术过程了。
- en: Simple numeric objects are sufficient for many tasks, but sometimes aggregate
    data structures containing two or more values are needed. In many languages, the
    basic aggregate data structure is the array. In Scheme, it is the *list*. Lists
    are written as sequences of objects surrounded by parentheses. For instance, `(1 2 3 4 5)`
    is a list of numbers, and `("this" "is" "a" "list")` is a list of strings. Lists
    need not contain only one type of object, so `(4.2 "hi")` is a valid list containing
    a number and a string. Lists may be nested (may contain other lists), so `((1 2) (3 4))`
    is a valid list with two elements, each of which is a list of two elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的数字对象对于许多任务已经足够了，但有时需要包含两个或更多值的聚合数据结构。在许多语言中，基本的聚合数据结构是数组。在 Scheme 中，它是*列表*。列表被写成用括号括起来的对象序列。例如，`(1 2 3 4 5)`是一个数字列表，而`("this" "is" "a" "list")`是一个字符串列表。列表不必只包含一种类型的对象，因此`(4.2 "hi")`是一个包含数字和字符串的有效列表。列表可以嵌套（可以包含其他列表），因此`((1 2) (3 4))`是一个包含两个元素的有效列表，每个元素都是一个包含两个元素的列表。
- en: You might notice that lists look just like procedure applications and wonder
    how Scheme tells them apart. That is, how does Scheme distinguish between a list
    of objects, `(*obj[1]* *obj[2]* ...)`, and a procedure application, `(*procedure* *arg* ...)`?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到列表看起来就像过程应用程序，并想知道 Scheme 如何区分它们。也就是说，Scheme 如何区分对象列表 `(*obj[1]* *obj[2]* ...)`
    和过程应用程序 `(*procedure* *arg* ...)`？
- en: In some cases, the distinction might seem obvious. The list of numbers `(1 2 3 4 5)`
    could hardly be confused with a procedure application, since 1 is a number, not
    a procedure. So, the answer might be that Scheme looks at the first element of
    the list or procedure application and makes its decision based on whether that
    first element is a procedure or not. This answer is not good enough, since we
    might even want to treat a valid procedure application such as `(+ 3 4)` as a
    list. The answer is that we must tell Scheme explicitly to treat a list as data
    rather than as a procedure application. We do this with `quote`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，区分可能看起来很明显。数字列表`(1 2 3 4 5)`几乎不可能与过程应用程序混淆，因为1是一个数字，不是一个过程。因此，答案可能是 Scheme
    查看列表或过程应用程序的第一个元素，并根据该第一个元素是过程还是其他内容做出决定。但这个答案还不够好，因为我们甚至可能希望将一个有效的过程应用程序，如`(+ 3 4)`，视为列表。答案是我们必须明确告诉
    Scheme 将列表视为数据而不是过程应用程序。我们用`quote`来做到这一点。
- en: '`(quote (1 2 3 4 5)) ![<graphic>](ch2_0.gif) (1 2 3 4 5)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`(quote (1 2 3 4 5)) ![<graphic>](ch2_0.gif) (1 2 3 4 5)'
- en: (quote ("this" "is" "a" "list")) ![<graphic>](ch2_0.gif) ("this" "is" "a" "list")
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: (quote ("this" "is" "a" "list")) ![<graphic>](ch2_0.gif) ("this" "is" "a" "list")
- en: (quote (+ 3 4)) ![<graphic>](ch2_0.gif) (+ 3 4)`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (quote (+ 3 4)) ![<graphic>](ch2_0.gif) (+ 3 4)`
- en: The `quote` forces the list to be treated as data. Try entering the above expressions
    without the quote; you will likely receive a message indicating that an exception
    has occurred for the first two and an incorrect answer (`7`) for the third.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote`强制将列表视为数据。尝试在没有引号的情况下输入上述表达式；你可能会收到一个消息，指示前两个表达式发生了异常，第三个表达式得到了一个错误的答案（`7`）。'
- en: Because `quote` is required fairly frequently in Scheme code, Scheme recognizes
    a single quotation mark ( `'` ) preceding an expression as an abbreviation for
    `quote`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 Scheme 代码中经常需要`quote`，Scheme 将在表达式前面加上单引号（`'`）识别为`quote`的缩写。
- en: '`''(1 2 3 4) ![<graphic>](ch2_0.gif) (1 2 3 4)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`''(1 2 3 4) ![<graphic>](ch2_0.gif) (1 2 3 4)'
- en: '''((1 2) (3 4)) ![<graphic>](ch2_0.gif) ((1 2) (3 4))'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '''((1 2) (3 4)) ![<graphic>](ch2_0.gif) ((1 2) (3 4))'
- en: '''(/ (* 2 -1) 3) ![<graphic>](ch2_0.gif) (/ (* 2 -1) 3)`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '''(/ (* 2 -1) 3) ![<graphic>](ch2_0.gif) (/ (* 2 -1) 3)`'
- en: Both forms are referred to as `quote` expressions. We often say an object is
    *quoted* when it is enclosed in a `quote` expression.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种形式都被称为`quote`表达式。当一个对象被包含在`quote`表达式中时，我们经常说该对象被*引用*。
- en: A `quote` expression is *not* a procedure application, since it inhibits the
    evaluation of its subexpression. It is an entirely different syntactic form. Scheme
    supports several other syntactic forms in addition to procedure applications and
    `quote` expressions. Each syntactic form is evaluated differently. Fortunately,
    the number of different syntactic forms is small. We will see more of them later
    in this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote` 表达式*不是*过程应用，因为它阻止了其子表达式的评估。这是一个完全不同的语法形式。Scheme 支持除了过程应用和 `quote` 表达式之外的几种其他语法形式。每种语法形式的评估方式都不同。幸运的是，不同的语法形式数量很少。我们将在本章后面看到更多。'
- en: Not all `quote` expressions involve lists. Try the following expression with
    and without the `quote` wrapper.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的 `quote` 表达式都涉及列表。尝试以下表达式，带有和不带有 `quote` 包装。
- en: '`(quote hello) ![<graphic>](ch2_0.gif) hello`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`(quote hello) ![<graphic>](ch2_0.gif) hello`'
- en: The symbol `hello` must be quoted in order to prevent Scheme from treating `hello`
    as a *variable*. Symbols and variables in Scheme are similar to symbols and variables
    in mathematical expressions and equations. When we evaluate the mathematical expression
    1 - *x* for some value of *x*, we think of *x* as a variable. On the other hand,
    when we consider the algebraic equation *x*² - 1 = (*x* - 1)(*x* + 1), we think
    of *x* as a symbol (in fact, we think of the whole equation symbolically). Just
    as quoting a list tells Scheme to treat a parenthesized form as a list rather
    than as a procedure application, quoting an identifier tells Scheme to treat the
    identifier as a symbol rather than as a variable. While symbols are commonly used
    to represent variables in symbolic representations of equations or programs, symbols
    may also be used, for example, as words in the representation of natural language
    sentences.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `hello` 必须被引用，以防止 Scheme 将 `hello` 视为*变量*。在 Scheme 中，符号和变量类似于数学表达式和方程中的符号和变量。当我们评估数学表达式
    1 - *x* 时，我们将 *x* 视为变量。另一方面，当我们考虑代数方程 *x*² - 1 = (*x* - 1)(*x* + 1) 时，我们将 *x*
    视为符号（实际上，我们将整个方程符号化）。就像引用列表告诉 Scheme 将括号形式视为列表而不是过程应用一样，引用标识符告诉 Scheme 将标识符视为符号而不是变量。虽然符号通常用于代表方程或程序的符号表示中的变量，但符号也可以用作自然语言句子表示中的单词，例如。
- en: You might wonder why applications and variables share notations with lists and
    symbols. The shared notation allows Scheme programs to be represented as Scheme
    data, simplifying the writing of interpreters, compilers, editors, and other tools
    in Scheme. This is demonstrated by the Scheme interpreter given in Section [12.7](examples.html#g187),
    which is itself written in Scheme. Many people believe this to be one of the most
    important features of Scheme.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么应用程序和变量与列表和符号共享符号。共享符号使得 Scheme 程序可以被表示为 Scheme 数据，简化了在 Scheme 中编写解释器、编译器、编辑器和其他工具的过程。这一点在第
    [12.7](examples.html#g187) 节中给出的 Scheme 解释器中有所体现，该解释器本身就是用 Scheme 编写的。许多人认为这是
    Scheme 中最重要的特性之一。
- en: Numbers and strings may be quoted, too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和字符串也可以被引用。
- en: '`''2 ![<graphic>](ch2_0.gif) 2'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`''2 ![<graphic>](ch2_0.gif) 2'
- en: '''2/3 ![<graphic>](ch2_0.gif) 2/3'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '''2/3 ![<graphic>](ch2_0.gif) 2/3'
- en: (quote "Hi Mom!") ![<graphic>](ch2_0.gif) "Hi Mom!"`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (quote "Hi Mom!") ![<graphic>](ch2_0.gif) "Hi Mom!"`
- en: Numbers and strings are treated as constants in any case, however, so quoting
    them is unnecessary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，数字和字符串在任何情况下都被视为常量，因此引用它们是不必要的。
- en: 'Now let''s discuss some Scheme procedures for manipulating lists. There are
    two basic procedures for taking lists apart: `car` and `cdr` (pronounced *could-er*).
    `car` returns the first element of a list, and `cdr` returns the remainder of
    the list. (The names "car" and "cdr" are derived from operations supported by
    the first computer on which a Lisp language was implemented, the IBM 704.) Each
    requires a nonempty list as its argument.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一些用于操作列表的 Scheme 过程。有两个基本过程用于拆分列表：`car` 和 `cdr`（发音为 *could-er*）。`car`
    返回列表的第一个元素，`cdr` 返回列表的其余部分。（名称 "car" 和 "cdr" 源自第一台实现 Lisp 语言的计算机 IBM 704 支持的操作。）每个过程都需要一个非空列表作为其参数。
- en: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
- en: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
- en: (cdr '(a)) ![<graphic>](ch2_0.gif) ()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a)) ![<graphic>](ch2_0.gif) ()
- en: (car (cdr '(a b c))) ![<graphic>](ch2_0.gif) b
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (car (cdr '(a b c))) ![<graphic>](ch2_0.gif) b
- en: (cdr (cdr '(a b c))) ![<graphic>](ch2_0.gif) (c)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr (cdr '(a b c))) ![<graphic>](ch2_0.gif) (c)
- en: (car '((a b) (c d))) ![<graphic>](ch2_0.gif) (a b)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (car '((a b) (c d))) ![<graphic>](ch2_0.gif) (a b)
- en: (cdr '((a b) (c d))) ![<graphic>](ch2_0.gif) ((c d))`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '((a b) (c d))) ![<graphic>](ch2_0.gif) ((c d))`
- en: The first element of a list is often called the "car" of the list, and the rest
    of the list is often called the "cdr" of the list. The cdr of a list with one
    element is `()`, the *empty list*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的第一个元素通常称为列表的“car”，列表的其余部分通常称为列表的“cdr”。具有一个元素的列表的cdr是`()`，即*empty list*。
- en: The procedure `cons` constructs lists. It takes two arguments. The second argument
    is usually a list, and in that case `cons` returns a list.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`cons`构建列表。它接受两个参数。第二个参数通常是一个列表，在这种情况下`cons`返回一个列表。
- en: '`(cons ''a ''()) ![<graphic>](ch2_0.gif) (a)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons ''a ''()) ![<graphic>](ch2_0.gif) (a)'
- en: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
- en: (cons 'a (cons 'b (cons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (cons 'a (cons 'b (cons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
- en: (cons '(a b) '(c d)) ![<graphic>](ch2_0.gif) ((a b) c d)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (cons '(a b) '(c d)) ![<graphic>](ch2_0.gif) ((a b) c d)
- en: (car (cons 'a '(b c))) ![<graphic>](ch2_0.gif) a
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: (car (cons 'a '(b c))) ![<graphic>](ch2_0.gif) a
- en: (cdr (cons 'a '(b c))) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr (cons 'a '(b c))) ![<graphic>](ch2_0.gif) (b c)
- en: (cons (car '(a b c))
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car '(a b c))
- en: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)
- en: (cons (car '(a b c))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car '(a b c))
- en: (cdr '(a b c))) ![<graphic>](ch2_0.gif) (a b c)`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a b c))) ![<graphic>](ch2_0.gif) (a b c)`
- en: Just as "car" and "cdr" are often used as nouns, "cons" is often used as a verb.
    Creating a new list by adding an element to the beginning of a list is referred
    to as *consing* the element onto the list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如“car”和“cdr”经常用作名词一样，“cons”经常用作动词。通过在列表开头添加元素来创建新列表被称为*consing*该元素到列表上。
- en: Notice the word "usually" in the description of `cons`'s second argument. The
    procedure `cons` actually builds *pairs*, and there is no reason that the cdr
    of a pair must be a list. A list is a sequence of pairs; each pair's cdr is the
    next pair in the sequence.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`cons`第二个参数描述中的“通常”一词。实际上，过程`cons`构建*对*，一个对的cdr不一定是列表。列表是一系列对；每个对的cdr是序列中的下一个对。
- en: '![<graphic>](ch2_1.gif)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch2_1.gif)'
- en: The cdr of the last pair in a *proper list* is the empty list. Otherwise, the
    sequence of pairs forms an *improper list*. More formally, the empty list is a
    proper list, and any pair whose cdr is a proper list is a proper list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*proper list*中最后一对的cdr是空列表。否则，一系列对形成一个*improper list*。更正式地说，空列表是proper list，任何cdr是proper
    list的对也是proper list。'
- en: An improper list is printed in *dotted-pair notation*, with a period, or *dot*,
    preceding the final element of the list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: improper list以*dotted-pair notation*打印，列表的最后一个元素之前有一个句点或*dot*。
- en: '`(cons ''a ''b) ![<graphic>](ch2_0.gif) (a . b)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons ''a ''b) ![<graphic>](ch2_0.gif) (a . b)'
- en: (cdr '(a . b)) ![<graphic>](ch2_0.gif) b
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a . b)) ![<graphic>](ch2_0.gif) b
- en: (cons 'a '(b . c)) ![<graphic>](ch2_0.gif) (a b . c)`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (cons 'a '(b . c)) ![<graphic>](ch2_0.gif) (a b . c)`
- en: Because of its printed notation, a pair whose cdr is not a list is often called
    a *dotted pair*. Even pairs whose cdrs are lists can be written in dotted-pair
    notation, however, although the printer always chooses to write proper lists without
    dots.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其打印表示法，cdr不是列表的对通常被称为*dotted pair*。然而，即使cdr是列表的对也可以用dotted-pair表示法写出，尽管打印机总是选择不带点的方式写出proper
    list。
- en: '`''(a . (b . (c . ()))) ![<graphic>](ch2_0.gif) (a b c)`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`''(a . (b . (c . ()))) ![<graphic>](ch2_0.gif) (a b c)`'
- en: The procedure `list` is similar to `cons`, except that it takes an arbitrary
    number of arguments and always builds a proper list.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`list`类似于`cons`，不同之处在于它接受任意数量的参数并始终构建proper list。
- en: '`(list ''a ''b ''c) ![<graphic>](ch2_0.gif) (a b c)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list ''a ''b ''c) ![<graphic>](ch2_0.gif) (a b c)'
- en: (list 'a) ![<graphic>](ch2_0.gif) (a)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (list 'a) ![<graphic>](ch2_0.gif) (a)
- en: (list) ![<graphic>](ch2_0.gif) ()`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (list) ![<graphic>](ch2_0.gif) ()`
- en: Section [6.3](objects.html#g109) provides more information on lists and the
    Scheme procedures for manipulating them. This might be a good time to turn to
    that section and familiarize yourself with the other procedures given there.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第[6.3](objects.html#g109)节提供了有关列表和Scheme程序操作列表的更多信息。现在可能是一个好时机转到该部分，并熟悉那里提供的其他程序。
- en: Exercise 2.2.1
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.2.1
- en: Convert the following arithmetic expressions into Scheme expressions and evaluate
    them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下算术表达式转换为Scheme表达式并计算。
- en: '| *  a*. | 1.2 × (2 - 1/3) + -8.7 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| *  a*. | 1.2 × (2 - 1/3) + -8.7 |'
- en: '| *  b*. | (2/3 + 4/9) ÷ (5/11 - 4/3) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| *  b*. | (2/3 + 4/9) ÷ (5/11 - 4/3) |'
- en: '| *  c*. | 1 + 1 ÷ (2 + 1 ÷ (1 + 1/2)) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| *  c*. | 1 + 1 ÷ (2 + 1 ÷ (1 + 1/2)) |'
- en: '| *  d*. | 1 × -2 × 3 × -4 × 5 × -6 × 7 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| *  d*. | 1 × -2 × 3 × -4 × 5 × -6 × 7 |'
- en: Exercise 2.2.2
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.2.2
- en: Experiment with the procedures `+`, `-`, `*`, and `/` to determine Scheme's
    rules for the type of value returned by each when given different types of numeric
    arguments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用过程`+`、`-`、`*`和`/`来确定当给定不同类型的数值参数时，Scheme 返回的值类型规则。
- en: Exercise 2.2.3
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.3
- en: Determine the values of the following expressions. Use your Scheme system to
    verify your answers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 确定以下表达式的值。使用你的 Scheme 系统验证你的答案。
- en: '| *  a*. | `(cons ''car ''cdr)` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| *  a*. | `(cons ''car ''cdr)` |'
- en: '| *  b*. | `(list ''this ''(is silly))` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| *  b*. | `(list ''this ''(is silly))` |'
- en: '| *  c*. | `(cons ''is ''(this silly?))` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| *  c*. | `(cons ''is ''(this silly?))` |'
- en: '| *  d*. | `(quote (+ 2 3))` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| *  d*. | `(quote (+ 2 3))` |'
- en: '| *  e*. | `(cons ''+ ''(2 3))` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| *  e*. | `(cons ''+ ''(2 3))` |'
- en: '| *  f*. | `(car ''(+ 2 3))` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| *  f*. | `(car ''(+ 2 3))` |'
- en: '| *  g*. | `(cdr ''(+ 2 3))` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| *  g*. | `(cdr ''(+ 2 3))` |'
- en: '| *  h*. | `cons` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| *  h*. | `cons` |'
- en: '| *  i*. | `(quote cons)` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| *  i*. | `(quote cons)` |'
- en: '| *  j*. | `(quote (quote cons))` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| *  j*. | `(quote (quote cons))` |'
- en: '| *  k*. | `(car (quote (quote cons)))` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| *  k*. | `(car (quote (quote cons)))` |'
- en: '| *  l*. | `(+ 2 3)` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| *  l*. | `(+ 2 3)` |'
- en: '| *  m*. | `(+ ''2 ''3)` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| *  m*. | `(+ ''2 ''3)` |'
- en: '| *  n*. | `(+ (car ''(2 3)) (car (cdr ''(2 3))))` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| *  n*. | `(+ (car ''(2 3)) (car (cdr ''(2 3))))` |'
- en: '| *  o*. | `((car (list + - * /)) 2 3)` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| *  o*. | `((car (list + - * /)) 2 3)` |'
- en: Exercise 2.2.4
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.4
- en: '`(car (car ''((a b) (c d))))` yields `a`. Determine which compositions of `car`
    and `cdr` applied to `((a b) (c d))` yield `b`, `c`, and `d`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car (car ''((a b) (c d))))` 得到 `a`。确定应用于 `((a b) (c d))` 的 `car` 和 `cdr`
    的哪些组合得到 `b`、`c` 和 `d`。'
- en: Exercise 2.2.5
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.5
- en: Write a Scheme expression that evaluates to the following internal list structure.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个 Scheme 表达式，使其求值为以下内部列表结构。
- en: '![<graphic>](ch2_2.gif)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch2_2.gif)'
- en: Exercise 2.2.6
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.6
- en: Draw the internal list structure produced by the expression below.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制下面表达式产生的内部列表结构。
- en: '`(cons 1 (cons ''(2 . ((3) . ())) (cons ''(()) (cons 4 5))))`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons 1 (cons ''(2 . ((3) . ())) (cons ''(()) (cons 4 5))))`'
- en: Exercise 2.2.7
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.7
- en: The behavior of `(car (car (car '((a b) (c d)))))` is undefined because `(car '((a b) (c d)))`
    is `(a b)`, `(car '(a b))` is `a`, and `(car 'a)` is undefined. Determine all
    legal compositions of `car` and `cdr` applied to `((a b) (c d))`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car (car (car ''((a b) (c d)))))` 的行为是未定义的，因为 `(car ''((a b) (c d)))` 是 `(a b)`，`(car ''(a b))`
    是 `a`，而 `(car ''a)` 是未定义的。确定应用于 `((a b) (c d))` 的所有合法 `car` 和 `cdr` 的组合。'
- en: Exercise 2.2.8
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.8
- en: Try to explain how Scheme expressions are evaluated. Does your explanation cover
    the last example in Exercise [2.2.3](start.html#g9)?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解释 Scheme 表达式是如何求值的。你的解释是否涵盖了练习 [2.2.3](start.html#g9) 中的最后一个例子？
- en: Section 2.3\. Evaluating Scheme Expressions
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2.3 节。求值 Scheme 表达式
- en: 'Let''s turn to a discussion of how Scheme evaluates the expressions you type.
    We have already established the rules for constant objects such as strings and
    numbers: the object itself is the value. You have probably also worked out in
    your mind a rule for evaluating procedure applications of the form `(*procedure* *arg[1]* ... *arg[n]*)`.
    Here, `*procedure*` is an expression representing a Scheme procedure, and `*arg[1]* ... *arg[n]*`
    are expressions representing its arguments. One possibility is the following.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下 Scheme 如何评估你输入的表达式。我们已经建立了对于常量对象（如字符串和数字）的规则：对象本身就是值。你可能也已经在脑海中想出了一条规则，用于评估形式为
    `(*procedure* *arg[1]* ... *arg[n]*)` 的过程应用。在这里，`*procedure*` 是表示 Scheme 过程的表���式，`*arg[1]* ... *arg[n]*`
    是表示其参数的表达式。一种可能性是以下内容。
- en: Find the value of `*procedure*`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到 `*procedure*` 的值。
- en: Find the value of `*arg[1]*`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到 `*arg[1]*` 的值。
- en: '![<graphic>](ch2_3.gif)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<graphic>](ch2_3.gif)'
- en: Find the value of `*arg[n]*`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到`*arg[n]*`的值。
- en: Apply the value of `*procedure*` to the values of `*arg[1]* ... *arg[n]*`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`*procedure*`的值应用于`*arg[1]* ... *arg[n]*`的值。
- en: For example, consider the simple procedure application `(+ 3 4)`. The value
    of `+` is the addition procedure, the value of 3 is the number 3, and the value
    of 4 is the number 4. Applying the addition procedure to 3 and 4 yields 7, so
    our value is the object 7.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑简单的过程应用 `(+ 3 4)`。`+` 的值是加法过程，3 的值是数字 3，4 的值是数字 4。将加法过程应用于 3 和 4 得到 7，因此我们的值是对象
    7。
- en: By applying this process at each level, we can find the value of the nested
    expression `(* (+ 3 4) 2)`. The value of `*` is the multiplication procedure,
    the value of `(+ 3 4)` we can determine to be the number 7, and the value of 2
    is the number 2. Multiplying 7 by 2 we get 14, so our answer is 14.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个级别应用这个过程，我们可以找到嵌套表达式 `(* (+ 3 4) 2)` 的值。`*` 的值是乘法过程，`(+ 3 4)` 我们可以确定为数字
    7，2 的值是数字 2。将 7 乘以 2 得到 14，因此我们的答案是 14。
- en: This rule works for procedure applications but not for `quote` expressions because
    the subexpressions of a procedure application are evaluated, whereas the subexpression
    of a `quote` expression is not. The evaluation of a `quote` expression is more
    similar to the evaluation of constant objects. The value of a `quote` expression
    of the form `(quote *object*)` is simply `*object*`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则适用于过程应用，但不适用于`quote`表达式，因为过程应用的子表达式被评估，而`quote`表达式的子表达式不被评估。`quote`表达式的评估更类似于常量对象的评估。形式为`(quote *object*)`的`quote`表达式的值简单地是`*object*`。
- en: Constant objects, procedure applications, and `quote` expressions are only three
    of the many syntactic forms provided by Scheme. Fortunately, only a few of the
    other syntactic forms need to be understood directly by a Scheme programmer; these
    are referred to as *core* syntactic forms. The remaining syntactic forms are *syntactic
    extensions* defined, ultimately, in terms of the core syntactic forms. We will
    discuss the remaining core syntactic forms and a few syntactic extensions in the
    remaining sections of this chapter. Section [3.1](further.html#g50) summarizes
    the core syntactic forms and introduces the syntactic extension mechanism.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 常量对象、过程应用和`quote`表达式只是 Scheme 提供的许多语法形式中的三种。幸运的是，只有少数其他语法形式需要 Scheme 程序员直接理解；这些被称为*核心*语法形式。其余的语法形式是*语法扩展*，最终以核心语法形式的术语定义。我们将在本章的剩余部分讨论其余的核心语法形式和一些语法扩展。第 [3.1](further.html#g50)
    节总结了核心语法形式并介绍了语法扩展机制。
- en: Before we go on to more syntactic forms and procedures, two points related to
    the evaluation of procedure applications are worthy of note. First, the process
    given above is overspecified, in that it requires the subexpressions to be evaluated
    from left to right. That is, `*procedure*` is evaluated before `*arg[1]*`, `*arg[1]*`
    is evaluated before `*arg[2]*`, and so on. This need not be the case. A Scheme
    evaluator is free to evaluate the expressions in any order---left to right, right
    to left, or any other sequential order. In fact, the subexpressions may be evaluated
    in different orders for different applications, even in the same implementation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论更多的语法形式和过程之前，有两个与过程应用的评估相关的要点值得注意。首先，上述给出的过程是过度规定的，因为它要求从左到右评估子表达式。也就是说，`*procedure*`在`*arg[1]*`之前被评估，在`*arg[1]*`之前`*arg[2]*`被评估，依此类推。这不一定是必要的。Scheme
    评估器可以自由地以任何顺序评估表达式---从左到右、从右到左或任何其他顺序。实际上，即使在同一个实现中，不同的应用可能以不同的顺序评估子表达式。
- en: The second point is that `*procedure*` is evaluated in the same way as `*arg[1]* ... *arg[n]*`.
    While `*procedure*` is often a variable that names a particular procedure, this
    need not be the case. Exercise [2.2.3](start.html#g9) had you determine the value
    of the expression `((car (list + - * /)) 2 3)`. Here, `*procedure*` is `(car (list + - * /))`.
    The value of `(car (list + - * /))` is the addition procedure, just as if `*procedure*`
    were simply the variable `+`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要点是`*procedure*`的评估方式与`*arg[1]* ... *arg[n]*`相同。虽然`*procedure*`通常是一个命名特定过程的变量，但这不一定是情况。练习 [2.2.3](start.html#g9)
    让你确定表达式的值`((car (list + - * /)) 2 3)`。在这里，`*procedure*`是`(car (list + - * /))`。`(car (list + - * /))`的值是加法过程，就像`*procedure*`只是变量`+`一样。
- en: Exercise 2.3.1
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.3.1
- en: Write down the steps necessary to evaluate the expression below.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 写下评估下面表达式所需的步骤。
- en: '`((car (cdr (list + - * /))) 17 5)`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`((car (cdr (list + - * /))) 17 5)`'
- en: Section 2.4\. Variables and Let Expressions
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2.4 节 变量和 Let 表达式
- en: Suppose `*expr*` is a Scheme expression that contains a variable `*var*`. Suppose,
    additionally, that we would like `*var*` to have the value `*val*` when we evaluate
    `*expr*`. For example, we might like `x` to have the value 2 when we evaluate
    `(+ x 3)`. Or, we might want `y` to have the value 3 when we evaluate `(+ 2 y)`.
    The following examples demonstrate how to do this using Scheme's `let` syntactic
    form.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`*expr*`是一个包含变量`*var*`的 Scheme 表达式。另外假设，当我们评估`*expr*`时，我们希望`*var*`具有值`*val*`。例如，当我们评估`(+ x 3)`时，我们可能希望`x`的值为2。或者，当我们评估`(+ 2 y)`时，我们可能想要`y`的值为3。以下示例演示了如何使用
    Scheme 的`let`语法形式来实现这一点。
- en: '`(let ((x 2))'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ((x 2))'
- en: (+ x 3)) ![<graphic>](ch2_0.gif) 5
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x 3)) ![<graphic>](ch2_0.gif) 5
- en: (let ((y 3))
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (let ((y 3))
- en: (+ 2 y)) ![<graphic>](ch2_0.gif) 5
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 2 y)) ![<graphic>](ch2_0.gif) 5
- en: (let ((x 2) (y 3))
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: (let ((x 2) (y 3))
- en: (+ x y)) ![<graphic>](ch2_0.gif) 5`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x y)) ![<graphic>](ch2_0.gif) 5`
- en: The `let` syntactic form includes a list of variable-expression pairs, along
    with a sequence of expressions referred to as the *body* of the `let`. The general
    form of a `let` expression is
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`语法形式包括一个变量-表达式对的列表，以及一系列被称为`let`主体的表达式。`let`表达式的一般形式是'
- en: '`(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: We say the variables are *bound* to the values by the `let`. We refer to variables
    bound by `let` as `let`-*bound* variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说变量被`let`绑定到值。我们将被`let`绑定的变量称为`let`-*bound*变量。
- en: A `let` expression is often used to simplify an expression that would contain
    two identical subexpressions. Doing so also ensures that the value of the common
    subexpression is computed only once.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`表达式经常用于简化一个包含两个相同子表达式的表达式。这样做还确保了公共子表达式的值只计算一次。'
- en: '`(+ (* 4 4) (* 4 4)) ![<graphic>](ch2_0.gif) 32'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ (* 4 4) (* 4 4)) ![<graphic>](ch2_0.gif) 32'
- en: (let ((a (* 4 4))) (+ a a)) ![<graphic>](ch2_0.gif) 32`
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: (let ((a (* 4 4))) (+ a a)) ![<graphic>](ch2_0.gif) 32`
- en: Brackets are often used in place of parentheses to delimit the bindings of a
    `let` expression.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号经常用于代替括号来界定`let`表达式的绑定。
- en: '`(let ([list1 ''(a b c)] [list2 ''(d e f)])'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([list1 ''(a b c)] [list2 ''(d e f)])'
- en: (cons (cons (car list1)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (cons (car list1)
- en: (car list2))
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: (car list2))
- en: (cons (car (cdr list1))
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car (cdr list1))
- en: (car (cdr list2))))) ![<graphic>](ch2_0.gif) ((a . d) b . e)`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: (car (cdr list2))))) ![<graphic>](ch2_0.gif) ((a . d) b . e)`
- en: Scheme treats forms enclosed in brackets just like forms enclosed in parentheses.
    An open bracket must be matched by a close bracket, and an open parenthesis must
    be matched by a close parenthesis. We use brackets for `let` (and, as we'll see,
    several other standard syntactic forms) to improve readability, especially when
    we might otherwise have two or more consecutive open parentheses.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme将方括号括起来的形式视为与括号括起来的形式相同。开放的方括号必须与闭合的方括号匹配，开放的括号必须与闭合的括号匹配。我们使用方括号来表示`let`（以及，正如我们将看到的，几个其他标准的语法形式）以提高可读性，特别是当我们可能会有两个或更多连续的开放括号时。
- en: Since expressions in the first position of a procedure application are evaluated
    no differently from other expressions, a `let`-bound variable may be used there
    as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过程应用中的第一个位置的表达式与其他表达式没有区别，因此`let`绑定的变量也可以在那里使用。
- en: '`(let ([f +])'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([f +])'
- en: (f 2 3)) ![<graphic>](ch2_0.gif) 5
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: (f 2 3)) ![<graphic>](ch2_0.gif) 5
- en: (let ([f +] [x 2])
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f +] [x 2])
- en: (f x 3)) ![<graphic>](ch2_0.gif) 5
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: (f x 3)) ![<graphic>](ch2_0.gif) 5
- en: (let ([f +] [x 2] [y 3])
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f +] [x 2] [y 3])
- en: (f x y)) ![<graphic>](ch2_0.gif) 5`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: (f x y)) ![<graphic>](ch2_0.gif) 5`
- en: The variables bound by `let` are visible only within the body of the `let`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 被`let`绑定的变量只在`let`的主体中可见。
- en: '`(let ([+ *])'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([+ *）'
- en: (+ 2 3)) ![<graphic>](ch2_0.gif) 6
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 2 3)) ![<graphic>](ch2_0.gif) 6
- en: (+ 2 3) ![<graphic>](ch2_0.gif) 5`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 2 3) ![<graphic>](ch2_0.gif) 5`
- en: This is fortunate, because we would not want the value of `+` to be the multiplication
    procedure everywhere.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是幸运的，因为我们不希望`+`的值在任何地方都是乘法过程。
- en: It is possible to nest `let` expressions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以嵌套`let`表达式。
- en: '`(let ([a 4] [b -3])'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([a 4] [b -3])'
- en: (let ([a-squared (* a a)]
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([a-squared (* a a)]
- en: '[b-squared (* b b)])'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[b-squared (* b b)])'
- en: (+ a-squared b-squared))) ![<graphic>](ch2_0.gif) 25`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (+ a-squared b-squared))) ![<graphic>](ch2_0.gif) 25`
- en: When nested `let` expressions bind the same variable, only the binding created
    by the inner `let` is visible within its body.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌套的`let`表达式绑定相同的变量时，只有内部`let`创建的绑定在其主体中可见。
- en: '`(let ([x 1])'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 1])'
- en: (let ([x (+ x 1)])
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (+ x 1)])
- en: (+ x x))) ![<graphic>](ch2_0.gif) 4`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x x))) ![<graphic>](ch2_0.gif) 4`
- en: The outer `let` expression binds `x` to 1 within its body, which is the second
    `let` expression. The inner `let` expression binds `x` to `(+ x 1)` within its
    body, which is the expression `(+ x x)`. What is the value of `(+ x 1)`? Since
    `(+ x 1)` appears within the body of the outer `let` but not within the body of
    the inner `let`, the value of `x` must be 1 and hence the value of `(+ x 1)` is
    2. What about `(+ x x)`? It appears within the body of both `let` expressions.
    Only the inner binding for `x` is visible, so `x` is 2 and `(+ x x)` is 4.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 外部的`let`表达式在其主体中将`x`绑定为1，这是第二个`let`表达式。内部的`let`表达式在其主体中将`x`绑定为`(+ x 1)`，这是表达式`(+ x x)`。`(+ x 1)`的值是多少？由于`(+ x 1)`出现在外部`let`的主体中，但没有出现在内部`let`的主体中，因此`x`的值必须是1，因此`(+ x 1)`的值是2。那么`(+ x x)`呢？它出现在两个`let`表达式的主体中。只有内部的`x`绑定是可见的，所以`x`是2，`(+ x x)`是4。
- en: The inner binding for `x` is said to *shadow* the outer binding. A `let`-bound
    variable is visible everywhere within the body of its `let` expression except
    where it is shadowed. The region where a variable binding is visible is called
    its *scope*. The scope of the first `x` in the example above is the body of the
    outer `let` expression minus the body of the inner `let` expression, where it
    is shadowed by the second `x`. This form of scoping is referred to as *lexical
    scoping*, since the scope of each binding can be determined by a straightforward
    textual analysis of the program.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 内部对`x`的绑定被称为*遮蔽*外部的绑定。`let`绑定的变量在其`let`表达式的主体中到处可见，除了被遮蔽的地方。变量绑定可见的区域称为其*作用域*。上面示例中第一个`x`的作用域是外部`let`表达式的主体减去内部`let`表达式的主体，在那里被第二个`x`遮蔽。这种作用域形式称为*词法作用域*，因为每个绑定的作用域可以通过对程序进行简单的文本分析来确定。
- en: Shadowing may be avoided by choosing different names for variables. The expression
    above could be rewritten so that the variable bound by the inner `let` is `new-x`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 遮蔽可以通过为变量选择不同的名称来避免。上面的表达式可以重写，使内部`let`绑定的变量为`new-x`。
- en: '`(let ([x 1])'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 1])'
- en: (let ([new-x (+ x 1)])
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([new-x (+ x 1)])
- en: (+ new-x new-x))) ![<graphic>](ch2_0.gif) 4`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (+ new-x new-x))) ![<graphic>](ch2_0.gif) 4`
- en: Although choosing different names can sometimes prevent confusion, shadowing
    can help prevent the accidental use of an "old" value. For example, with the original
    version of the preceding example, it would be impossible for us to mistakenly
    refer to the outer `x` within the body of the inner `let`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管选择不同的名称有时可以防止混淆，但遮蔽可以帮助防止意外使用“旧”值。例如，在前面示例的原始版本中，我们无法在内部`let`的主体中错误地引用外部的`x`。
- en: Exercise 2.4.1
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.4.1
- en: Rewrite the following expressions, using `let` to remove common subexpressions
    and to improve the structure of the code. Do not perform any algebraic simplifications.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 重写以下表达式，使用`let`去除公共子表达式并改善代码结构。不要进行任何代数简化。
- en: '| *  a*. | `(+ (- (* 3 a) b) (+ (* 3 a) b))` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| *  a*. | `(+ (- (* 3 a) b) (+ (* 3 a) b))` |'
- en: '| *  b*. | `(cons (car (list a b c)) (cdr (list a b c)))` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| *  b*. | `(cons (car (list a b c)) (cdr (list a b c)))` |'
- en: Exercise 2.4.2
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.4.2
- en: Determine the value of the following expression. Explain how you derived this
    value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '确定以下表达式的值。解释您是如何得出这个值的。 '
- en: '`(let ([x 9])'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 9])'
- en: (* x
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (* x
- en: (let ([x (/ x 3)])
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (/ x 3)])
- en: (+ x x))))`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x x))))`
- en: Exercise 2.4.3
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.4.3
- en: Rewrite the following expressions to give unique names to each different `let`-bound
    variable so that none of the variables is shadowed. Verify that the value of your
    expression is the same as that of the original expression.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 重写以下表达式，为每个不同的`let`绑定的变量提供唯一的名称，以便没有任何变量被遮蔽。验证您的表达式的值与原始表达式的值相同。
- en: '| *  a*. | `(let ([x ''a] [y ''b])   (list (let ([x ''c]) (cons x y))'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '| *  a*. | `(let ([x ''a] [y ''b])   (list (let ([x ''c]) (cons x y))'
- en: (let ([y 'd]) (cons x y))))` |
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([y 'd]) (cons x y))))` |
- en: '| *  b*. | `(let ([x ''((a b) c)])   (cons (let ([x (cdr x)])'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '| *  b*. | `(let ([x ''((a b) c)])   (cons (let ([x (cdr x)])'
- en: (car x))
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (car x))
- en: (let ([x (car x)])
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (car x)])
- en: (cons (let ([x (cdr x)])
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (let ([x (cdr x)])
- en: (car x))
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: (car x))
- en: (cons (let ([x (car x)])
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (let ([x (car x)])
- en: x)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: x)
- en: (cdr x))))))` |
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr x))))))` |
- en: Section 2.5\. Lambda Expressions
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2.5节。Lambda表达式
- en: In the expression `(let ([x (* 3 4)]) (+ x x))`, the variable `x` is bound to
    the value of `(* 3 4)`. What if we would like the value of `(+ x x)` where `x`
    is bound to the value of `(/ 99 11)`? Where `x` is bound to the value of `(- 2 7)`?
    In each case we need a different `let` expression. When the body of the `let`
    is complicated, however, having to repeat it can be inconvenient.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式`(let ([x (* 3 4)]) (+ x x))`中，变量`x`绑定到`(* 3 4)`的值。如果我们想要`x`绑定到`(/ 99 11)`的值时`(+ x x)`的值是多少？当`x`绑定到`(- 2 7)`的值时呢？在每种情况下，我们都需要一个不同的`let`表达式。然而，当`let`的主体复杂时，不得不重复它可能会不方便。
- en: Instead, we can use the syntactic form `lambda` to create a new procedure that
    has `x` as a parameter and has the same body as the `let` expression.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用语法形式`lambda`来创建一个新的过程，该过程以`x`为参数，并具有与`let`表达式相同的主体。
- en: '`(lambda (x) (+ x x)) ![<graphic>](ch2_0.gif) #<procedure>`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (x) (+ x x)) ![<graphic>](ch2_0.gif) #<procedure>`'
- en: The general form of a `lambda` expression is
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`表达式的一般形式是'
- en: '`(lambda (*var* ...) *body[1]* *body[2]* ...)`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (*var* ...) *body[1]* *body[2]* ...)`'
- en: The variables `*var* ...` are the *formal parameters* of the procedure, and
    the sequence of expressions `*body[1]* *body[2]* ...` is its body. (Actually,
    the true general form is somewhat more general than this, as you will see later.)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`*var* ...`是过程的*形式参数*，表达式序列`*body[1]* *body[2]* ...`是其主体。（实际上，真正的一般形式比这略微更一般，稍后你会看到。）
- en: A procedure is just as much an object as a number, string, symbol, or pair.
    It does not have any meaningful printed representation as far as Scheme is concerned,
    however, so this book uses the notation `#<procedure>` to show that the value
    of an expression is a procedure.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 过程与数字、字符串、符号或对一样都是对象。然而，就Scheme而言，它没有任何有意义的打印表示，因此本书使用符号`#<procedure>`来显示表达式的值是一个过程。
- en: The most common operation to perform on a procedure is to apply it to one or
    more values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对过程执行的最常见操作是将其应用于一个或多个值。
- en: '`((lambda (x) (+ x x)) (* 3 4)) ![<graphic>](ch2_0.gif) 24`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`((lambda (x) (+ x x)) (* 3 4)) ![<graphic>](ch2_0.gif) 24`'
- en: This is no different from any other procedure application. The procedure is
    the value of `(lambda (x) (+ x x))`, and the only argument is the value of `(* 3 4)`,
    or 12. The argument values, or *actual parameters*, are bound to the formal parameters
    within the body of the `lambda` expression in the same way as `let`-bound variables
    are bound to their values. In this case, `x` is bound to 12, and the value of
    `(+ x x)` is 24. Thus, the result of applying the procedure to the value 12 is
    24.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这与任何其他过程应用没有区别。过程是`(lambda (x) (+ x x))`的值，唯一的参数是`(* 3 4)`的值，即12。参数值或*实际参数*与`lambda`表达式的主体内的形式参数绑定方式与`let`绑定的变量与其值的绑定方式相同。在这种情况下，`x`绑定到12，`(+ x x)`的值为24。因此，将该过程应用于值12的结果为24。
- en: Because procedures are objects, we can establish a procedure as the value of
    a variable and use the procedure more than once.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因为过程是对象，我们可以将过程建立为变量的值，并多次使用该过程。
- en: '`(let ([double (lambda (x) (+ x x))])'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([double (lambda (x) (+ x x))])`'
- en: (list (double (* 3 4))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (list (double (* 3 4))
- en: (double (/ 99 11))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: (double (/ 99 11))
- en: (double (- 2 7)))) ![<graphic>](ch2_0.gif) (24 18 -10)`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: (double (- 2 7)))) ![<graphic>](ch2_0.gif) (24 18 -10)`
- en: Here, we establish a binding for `double` to a procedure, then use this procedure
    to double three different values.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为`double`建立一个过程的绑定，然后使用该过程来将三个不同的值加倍。
- en: The procedure expects its actual parameter to be a number, since it passes the
    actual parameter on to `+`. In general, the actual parameter may be any sort of
    object. Consider, for example, a similar procedure that uses `cons` instead of
    `+`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 过程期望其实际参数为数字，因为它将实际参数传递给`+`。一般来说，实际参数可以是任何类型的对象。例如，考虑一个类似的过程，它使用`cons`而不是`+`。
- en: '`(let ([double-cons (lambda (x) (cons x x))])'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([double-cons (lambda (x) (cons x x))])`'
- en: (double-cons 'a)) ![<graphic>](ch2_0.gif) (a . a)`
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (double-cons 'a)) ![<graphic>](ch2_0.gif) (a . a)`
- en: Noting the similarity between `double` and `double-cons`, you should not be
    surprised to learn that they may be collapsed into a single procedure by adding
    an additional argument.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`double`和`double-cons`之间的相似性，你可能不会感到惊讶地发现它们可以通过添加额外的参数合并为单个过程。
- en: '`(let ([double-any (lambda (f x) (f x x))])'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([double-any (lambda (f x) (f x x))])`'
- en: (list (double-any + 13)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: (list (double-any + 13)
- en: (double-any cons 'a))) ![<graphic>](ch2_0.gif) (26 (a . a))`
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: (double-any cons 'a))) ![<graphic>](ch2_0.gif) (26 (a . a))`
- en: This demonstrates that procedures may accept more than one argument and that
    arguments passed to a procedure may themselves be procedures.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明过程可以接受多个参数，并且传递给过程的参数本身可以是过程。
- en: As with `let` expressions, `lambda` expressions become somewhat more interesting
    when they are nested within other `lambda` or `let` expressions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与`let`表达式一样，当`lambda`表达式嵌套在其他`lambda`或`let`表达式中时，它们变得更加有趣。
- en: '`(let ([x ''a])'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x ''a])`'
- en: (let ([f (lambda (y) (list x y))])
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda (y) (list x y))])`
- en: (f 'b))) ![<graphic>](ch2_0.gif) (a b)`
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: (f 'b))) ![<graphic>](ch2_0.gif) (a b)`
- en: The occurrence of `x` within the `lambda` expression refers to the `x` outside
    the `lambda` that is bound by the outer `let` expression. The variable `x` is
    said to *occur free* in the `lambda` expression or to be a *free variable* of
    the `lambda` expression. The variable `y` does not occur free in the `lambda`
    expression since it is bound by the `lambda` expression. A variable that occurs
    free in a `lambda` expression should be bound, e.g., by an enclosing `lambda`
    or `let` expression, unless the variable is (like the names of primitive procedures)
    bound outside of the expression, as we discuss in the following section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`表达式中的`x`出现在外部`let`表达式绑定的`lambda`外部的`x`中。变量`x`被称为`lambda`表达式中的自由出现，或者是`lambda`表达式的自由变量。变量`y`在`lambda`表达式中不是自由出现，因为它被`lambda`表达式绑定。在`lambda`表达式中自由出现的变量应该被绑定，例如，通过封闭的`lambda`或`let`表达式，除非变量（如原始过程的名称）在表达式外部绑定，正如我们在下一节中讨论的那样。'
- en: What happens when the procedure is applied somewhere outside the scope of the
    bindings for variables that occur free within the procedure, as in the following
    expression?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当过程应用在超出过程内自由发生的变量绑定范围的地方时，会发生什么，就像下面的表达式一样？
- en: '`(let ([f (let ([x ''sam])'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([f (let ([x ''sam])`'
- en: (lambda (y z) (list x y z)))])
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (y z) (list x y z)))])
- en: (f 'i 'am)) ![<graphic>](ch2_0.gif) (sam i am)`
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: (f 'i 'am)) ![<graphic>](ch2_0.gif) (sam i am)`
- en: The answer is that the same bindings that were in effect when the procedure
    was created are in effect again when the procedure is applied. This is true even
    if another binding for `x` is visible where the procedure is applied.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当过程被应用时，创建过程时有效的相同绑定再次生效。即使在应用过程的地方可见另一个`x`的绑定，这也是正确的。
- en: '`(let ([f (let ([x ''sam])'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([f (let ([x ''sam])`'
- en: (lambda (y z) (list x y z)))])
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (y z) (list x y z)))])
- en: (let ([x 'not-sam])
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 'not-sam])
- en: (f 'i 'am))) ![<graphic>](ch2_0.gif) (sam i am)`
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: (f 'i 'am))) ![<graphic>](ch2_0.gif) (sam i am)`
- en: In both cases, the value of `x` within the procedure named `f` is `sam`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，过程`f`中的`x`的值为`sam`。
- en: Incidentally, a `let` expression is nothing more than the direct application
    of a `lambda` expression to a set of argument expressions. For example, the two
    expressions below are equivalent.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`let`表达式只不过是将`lambda`表达式直接应用于一组参数表达式。例如，下面的两个表达式是等价的。
- en: '`(let ([x ''a]) (cons x x))` ≡ `((lambda (x) (cons x x)) ''a)`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x ''a]) (cons x x))` ≡ `((lambda (x) (cons x x)) ''a)`'
- en: In fact, a `let` expression is a syntactic extension defined in terms of `lambda`
    and procedure application, which are both core syntactic forms. In general, any
    expression of the form
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`let`表达式是一个以`lambda`和过程应用为基础定义的语法扩展，在一般情况下，任何形式为
- en: '`(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: is equivalent to the following.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于以下内容。
- en: '`((lambda (*var* ...) *body[1]* *body[2]* ...)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`((lambda (*var* ...) *body[1]* *body[2]* ...)`'
- en: '*expr* ...)`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*expr* ...)`'
- en: See Section [3.1](further.html#g50) for more about core forms and syntactic
    extensions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于核心形式和语法扩展的信息，请参见第[3.1](further.html#g50)节。
- en: 'As mentioned above, the general form of `lambda` is a bit more complicated
    than the form we saw earlier, in that the formal parameter specification, `(*var* ...)`,
    need not be a proper list, or indeed even a list at all. The formal parameter
    specification can be in any of the following three forms:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，`lambda`的一般形式比我们之前看到的形式稍微复杂一些，因为形式参数规范`(*var* ...)`不一定是一个正确的列表，甚至根本不是一个列表。形式参数规范可以是以下三种形式之一：
- en: a proper list of variables, `(*var[1]* ... *var[n]*)`, such as we have already
    seen,
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正确的变量列表，`(*var[1]* ... *var[n]*)`，就像我们已经看到的那样，
- en: a single variable, `*var[r]*`, or
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一变量，`*var[r]*`，或
- en: an improper list of variables, `(*var[1]* ... *var[n]* . *var[r]*)`.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不正确的变量列表，`(*var[1]* ... *var[n]* . *var[r]*)`。
- en: In the first case, exactly *n* actual parameters must be supplied, and each
    variable is bound to the corresponding actual parameter. In the second, any number
    of actual parameters is valid; all of the actual parameters are put into a single
    list and the single variable is bound to this list. The third case is a hybrid
    of the first two cases. At least *n* actual parameters must be supplied. The variables
    `*var[1]* ... *var[n]*` are bound to the corresponding actual parameters, and
    the variable `*var[r]*` is bound to a list containing the remaining actual parameters.
    In the second and third cases, `*var[r]*` is sometimes referred to as a "rest"
    parameter because it holds the rest of the actual parameters beyond those that
    are individually named.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，必须提供精确的*n*个实际参数，并且每个变量都绑定到相应的实际参数。在第二种情况下，任何数量的实际参数都是有效的；所有实际参数都被放入单个列表中，单个变量被绑定到此列表。第三种情况是前两种情况的混合。至少必须提供*n*个实际参数。变量`*var[1]* ... *var[n]*`被绑定到相应的实际参数，变量`*var[r]*`被绑定到包含剩余实际参数的列表。在第二种和第三种情况下，`*var[r]*`有时被称为“剩余”参数，因为它保存除了那些单独命名的参数之外的其余实际参数。
- en: Let's consider a few examples to help clarify the more general syntax of `lambda`
    expressions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些例子，以帮助澄清`lambda`表达式的更一般语法。
- en: '`(let ([f (lambda x x)])'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([f (lambda x x)])'
- en: (f 1 2 3 4)) ![<graphic>](ch2_0.gif) (1 2 3 4)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: (f 1 2 3 4)) ![<graphic>](ch2_0.gif) (1 2 3 4)
- en: (let ([f (lambda x x)])
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda x x)])
- en: (f)) ![<graphic>](ch2_0.gif) ()
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: (f)) ![<graphic>](ch2_0.gif) ()
- en: (let ([g (lambda (x . y) (list x y))])
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([g (lambda (x . y) (list x y))])
- en: (g 1 2 3 4)) ![<graphic>](ch2_0.gif) (1 (2 3 4))
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: (g 1 2 3 4)) ![<graphic>](ch2_0.gif) (1 (2 3 4))
- en: (let ([h (lambda (x y . z) (list x y z))])
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([h (lambda (x y . z) (list x y z))])
- en: (h 'a 'b 'c 'd)) ![<graphic>](ch2_0.gif) (a b (c d))`
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: (h 'a 'b 'c 'd)) ![<graphic>](ch2_0.gif) (a b (c d))`
- en: In the first two examples, the procedure named `f` accepts any number of arguments.
    These arguments are automatically formed into a list to which the variable `x`
    is bound; the value of `f` is this list. In the first example, the arguments are
    1, 2, 3, and 4, so the answer is `(1 2 3 4)`. In the second, there are no arguments,
    so the answer is the empty list `()`. The value of the procedure named `g` in
    the third example is a list whose first element is the first argument and whose
    second element is a list containing the remaining arguments. The procedure named
    `h` is similar but separates out the second argument. While `f` accepts any number
    of arguments, `g` must receive at least one and `h` must receive at least two.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个示例中，名为`f`的过程接受任意数量的参数。这些参数自动形成一个列表，变量`x`绑定到这个列表；`f`的值是这个列表。在第一个示例中，参数是1、2、3和4，因此答案是`(1 2 3 4)`。在第二个示例中，没有参数，因此答案是空列表`()`。第三个示例中，名为`g`的过程的值是一个列表，其第一个元素是第一个参数，其第二个元素是包含其余参数的列表。名为`h`的过程类似，但分离出第二个参数。虽然`f`接受任意数量的参数，但`g`必须至少接收一个，而`h`必须至少接收两个。
- en: Exercise 2.5.1
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.5.1
- en: Determine the values of the expressions below.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 确定下面表达式的值。
- en: '| *  a*. | `(let ([f (lambda (x) x)])   (f ''a))` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| *  a*. | `(let ([f (lambda (x) x)])   (f ''a))` |'
- en: '| *  b*. | `(let ([f (lambda x x)])   (f ''a))` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| *  b*. | `(let ([f (lambda x x)])   (f ''a))` |'
- en: '| *  c*. | `(let ([f (lambda (x . y) x)])   (f ''a))` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| *  c*. | `(let ([f (lambda (x . y) x)])   (f ''a))` |'
- en: '| *  d*. | `(let ([f (lambda (x . y) y)])   (f ''a))` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| *  d*. | `(let ([f (lambda (x . y) y)])   (f ''a))` |'
- en: Exercise 2.5.2
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.5.2
- en: How might the primitive procedure `list` be defined?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 原始过程`list`如何定义？
- en: Exercise 2.5.3
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.5.3
- en: List the variables that occur free in each of the `lambda` expressions below.
    Do not omit variables that name primitive procedures such as `+` or `cons`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 列出每个下面的`lambda`表达式中出现的自由变量。不要漏掉命名为`+`或`cons`等原始过程的变量。
- en: '| *  a*. | `(lambda (f x) (f x))` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| *  a*. | `(lambda (f x) (f x))` |'
- en: '| *  b*. | `(lambda (x) (+ x x))` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| *  b*. | `(lambda (x) (+ x x))` |'
- en: '| *  c*. | `(lambda (x y) (f x y))` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| *  c*. | `(lambda (x y) (f x y))` |'
- en: '| *  d*. | `(lambda (x)   (cons x (f x y)))` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| *  d*. | `(lambda (x)   (cons x (f x y)))` |'
- en: '| *  e*. | `(lambda (x)   (let ([z (cons x y)])'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '| *  e*. | `(lambda (x)   (let ([z (cons x y)])'
- en: (x y z)))` |
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: (x y z)))` |
- en: '| *  f*. | `(lambda (x)   (let ([y (cons x y)])'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '| *  f*. | `(lambda (x)   (let ([y (cons x y)])'
- en: (x y z)))` |
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: (x y z)))` |
- en: Section 2.6\. Top-Level Definitions
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2.6节。顶级定义
- en: The variables bound by `let` and `lambda` expressions are not visible outside
    the bodies of these expressions. Suppose you have created an object, perhaps a
    procedure, that must be accessible anywhere, like `+` or `cons`. What you need
    is a *top-level definition*, which may be established with `define`. Top-level
    definitions, which are supported by most interactive Scheme systems, are visible
    in every expression you enter, except where shadowed by another binding.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 由`let`和`lambda`表达式绑定的变量在这些表达式的主体之外是不可见的。假设您已经创建了一个对象，也许是一个过程，必须在任何地方都可以访问，就像`+`或`cons`一样。您需要的是一个*顶层定义*，可以用`define`来建立。大多数交互式Scheme系统支持顶层定义，在您输入的每个表达式中都可见，除非被另一个绑定遮蔽。
- en: Let's establish a top-level definition of the `double-any` procedure of the
    last section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为上一节的`double-any`过程建立一个顶层定义。
- en: '`(define double-any'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define double-any'
- en: (lambda (f x)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f x)
- en: (f x x)))`
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: (f x x)))`
- en: The variable `double-any` now has the same status as `cons` or the name of any
    other primitive procedure. We can use `double-any` as if it were a primitive procedure.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`double-any`现在具有与`cons`或任何其他原始过程名称相同的状态。我们可以像使用原始过程一样使用`double-any`。
- en: '`(double-any + 10) ![<graphic>](ch2_0.gif) 20'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`(double-any + 10) ![<graphic>](ch2_0.gif) 20'
- en: (double-any cons 'a) ![<graphic>](ch2_0.gif) (a . a)`
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: (double-any cons 'a) ![<graphic>](ch2_0.gif) (a . a)`
- en: A top-level definition may be established for any object, not just for procedures.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为任何对象建立顶层定义，而不仅仅是过程。
- en: '`(define sandwich "peanut-butter-and-jelly")'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define sandwich "peanut-butter-and-jelly")'
- en: sandwich ![<graphic>](ch2_0.gif) "peanut-butter-and-jelly"`
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: sandwich ![<graphic>](ch2_0.gif) "peanut-butter-and-jelly"`
- en: Most often, though, top-level definitions are used for procedures.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，顶层定义用于过程。
- en: As suggested above, top-level definitions may be shadowed by `let` or `lambda`
    bindings.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，顶层定义可能会被`let`或`lambda`绑定遮蔽。
- en: '`(define xyz ''(x y z))'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define xyz ''(x y z))'
- en: (let ([xyz '(z y x)])
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([xyz '(z y x)])
- en: xyz) ![<graphic>](ch2_0.gif) (z y x)`
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: xyz) ![<graphic>](ch2_0.gif) (z y x)`
- en: Variables with top-level definitions act almost as if they were bound by a `let`
    expression enclosing all of the expressions you type.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 具有顶层定义的变量几乎就像被`let`表达式绑定的变量一样，包围您键入的所有表达式。
- en: Given only the simple tools you have read about up to this point, it is already
    possible to define some of the primitive procedures provided by Scheme and described
    later in this book. If you completed the exercises from the last section, you
    should already know how to define `list`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭您到目前为止所读的简单工具，就已经可以定义Scheme提供的一些原始过程，并在本书后面描述。如果您完成了上一节的练习，您应该已经知道如何定义`list`。
- en: '`(define list (lambda x x))`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define list (lambda x x))`'
- en: Also, Scheme provides the abbreviations `cadr` and `cddr` for the compositions
    of `car` with `cdr` and `cdr` with `cdr`. That is, `(cadr *list*)` is equivalent
    to `(car (cdr *list*))`, and, similarly, `(cddr *list*)` is equivalent to `(cdr (cdr *list*))`.
    They are easily defined as follows.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Scheme提供了`cadr`和`cddr`的缩写，用于`car`与`cdr`的组合和`cdr`与`cdr`的组合。也就是说，`(cadr *list*)`等同于`(car (cdr *list*))`，类似地，`(cddr *list*)`等同于`(cdr (cdr *list*))`。它们可以很容易地定义如下。
- en: '`(define cadr'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define cadr'
- en: (lambda (x)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (car (cdr x))))
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: (car (cdr x))))
- en: (define cddr
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: (define cddr
- en: (lambda (x)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (cdr (cdr x))))`
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr (cdr x))))`
- en: '`(cadr ''(a b c)) ![<graphic>](ch2_0.gif) b'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cadr ''(a b c)) ![<graphic>](ch2_0.gif) b'
- en: (cddr '(a b c)) ![<graphic>](ch2_0.gif) (c)`
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: (cddr '(a b c)) ![<graphic>](ch2_0.gif) (c)`
- en: Any definition `(define *var* *expr*)` where `*expr*` is a `lambda` expression
    can be written in a shorter form that suppresses the `lambda`. The exact syntax
    depends upon the format of the `lambda` expression's formal parameter specifier,
    i.e., whether it is a proper list of variables, a single variable, or an improper
    list of variables. A definition of the form
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 任何定义`(define *var* *expr*)`，其中`*expr*`是一个`lambda`表达式，都可以用更短的形式来写，省略`lambda`。确切的语法取决于`lambda`表达式的形式参数规范的格式，即它是一个变量的适当列表，一个单一变量，还是一个不适当的变量列表。形式如下
- en: '`(define *var[0]*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define *var[0]*'
- en: (lambda (*var[1]* ... *var[n]*)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (*var[1]* ... *var[n]*)
- en: '*e[1]* *e[2]* ...))`'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*e[1]* *e[2]* ...))`'
- en: may be abbreviated
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 可以缩写
- en: '`(define (*var[0]* *var[1]* ... *var[n]*)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (*var[0]* *var[1]* ... *var[n]*)'
- en: '*e[1]* *e[2]* ...)`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*e[1]* *e[2]* ...)`'
- en: while
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当
- en: '`(define *var[0]*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define *var[0]*'
- en: (lambda *var[r]*
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda *var[r]*
- en: '*e[1]* *e[2]* ...))`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*e[1]* *e[2]* ...))`'
- en: may be abbreviated
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 可以缩写
- en: '`(define (*var[0]* . *var[r]*)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (*var[0]* . *var[r]*)'
- en: '*e[1]* *e[2]* ...)`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*e[1]* *e[2]* ...)`'
- en: and
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '`(define *var[0]*'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define *var[0]*'
- en: (lambda (*var[1]* ... *var[n]* . *var[r]*)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (*var[1]* ... *var[n]* . *var[r]*)
- en: '*e[1]* *e[2]* ...))`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*e[1]* *e[2]* ...))`'
- en: may be abbreviated
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 可以缩写
- en: '`(define (*var[0]* *var[1]* ... *var[n]* . *var[r]*)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (*var[0]* *var[1]* ... *var[n]* . *var[r]*)'
- en: '*e[1]* *e[2]* ...)`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*e[1]* *e[2]* ...)`'
- en: For example, the definitions of `cadr` and `list` might be written as follows.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`cadr`和`list`的定义可能如下所示。
- en: '`(define (cadr x)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (cadr x)'
- en: (car (cdr x)))
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: (car (cdr x)))
- en: (define (list . x) x)`
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: (define (list . x) x)`
- en: This book does not often employ this alternative syntax. Although it is shorter,
    it tends to mask the reality that procedures are not intimately tied to variables,
    or names, as they are in many other languages. This syntax is often referred to,
    somewhat pejoratively, as the "defun" syntax for `define`, after the `defun` form
    provided by Lisp languages in which procedures are more closely tied to their
    names.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不经常使用这种替代语法。虽然它更短，但它倾向于掩盖一个事实，即过程与变量或名称并不像许多其他语言中那样紧密联系。这种语法通常被有些贬义地称为“defun”语法，指的是Lisp语言提供的`define`后的`defun`形式，其中过程与它们的名称更紧密地联系在一起。
- en: Top-level definitions make it easier for us to experiment with a procedure interactively
    because we need not retype the procedure each time it is used. Let's try defining
    a somewhat more complicated variation of `double-any`, one that turns an "ordinary"
    two-argument procedure into a "doubling" one-argument procedure.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层定义使我们更容易通过交互式方式尝试一个过程，因为每次使用时无需重新键入该过程。让我们尝试定义一个稍微复杂一点的`double-any`变体，将一个“普通”的两参数过程转换为一个“加倍”的一参数过程。
- en: '`(define doubler'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define doubler'
- en: (lambda (f)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f)
- en: (lambda (x) (f x x))))`
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) (f x x))))`
- en: '`doubler` accepts one argument, `f`, which must be a procedure that accepts
    two arguments. The procedure returned by `doubler` accepts one argument, which
    it uses for both arguments in an application of `f`. We can define, with `doubler`,
    the simple `double` and `double-cons` procedures of the last section.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`doubler`接受一个参数`f`，必须是一个接受两个参数的过程。`doubler`返回的过程接受一个参数，它将该参数用于`f`的应用的两个参数。我们可以使用`doubler`定义上一节中的简单`double`和`double-cons`过程。'
- en: '`(define double (doubler +))'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define double (doubler +))'
- en: (double 13/2) ![<graphic>](ch2_0.gif) 13
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: (double 13/2) ![<graphic>](ch2_0.gif) 13
- en: (define double-cons (doubler cons))
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: (define double-cons (doubler cons))
- en: (double-cons 'a) ![<graphic>](ch2_0.gif) (a . a)`
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: (double-cons 'a) ![<graphic>](ch2_0.gif) (a . a)`
- en: We can also define `double-any` with `doubler`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`doubler`定义`double-any`。
- en: '`(define double-any'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define double-any'
- en: (lambda (f x)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f x)
- en: ((doubler f) x)))`
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ((doubler f) x)))`
- en: Within `double` and `double-cons`, `f` has the appropriate value, i.e., `+`
    or `cons`, even though the procedures are clearly applied outside the scope of
    `f`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在`double`和`double-cons`中，`f`具有适当的值，即`+`或`cons`，即使这些过程明显是在`f`的作用域之外应用的。
- en: What happens if you attempt to use a variable that is not bound by a `let` or
    `lambda` expression and that does not have a top-level definition? Try using the
    variable `i-am-not-defined` to see what happens.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用一个未被`let`或`lambda`表达式绑定的变量，并且没有顶层定义时会发生什么？尝试使用变量`i-am-not-defined`看看会发生什么。
- en: '`(i-am-not-defined 3)`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`(i-am-not-defined 3)`'
- en: Most Scheme systems print a message indicating that an unbound- or undefined-variable
    exception has occurred.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Scheme系统会打印一条消息，指示发生了未绑定或未定义变量的异常。
- en: The system should not, however, complain about the appearance of an undefined
    variable within a `lambda` expression, until and unless the resulting procedure
    is applied. The following should *not* cause an exception, even though we have
    not yet established a top-level definition of `proc2`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，系统不应该在`lambda`表达式中出现未定义变量时发出投诉，直到结果过程被应用为止。即使我们尚未建立`proc2`的顶层定义，以下内容也*不*应该引发异常。
- en: '`(define proc1'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define proc1'
- en: (lambda (x y)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (proc2 y x)))`
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: (proc2 y x)))`
- en: If you try to apply `proc1` before defining `proc2`, you should get a undefined
    exception message. Let's give `proc2` a top-level definition and try `proc1`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在定义`proc2`之前尝试应用`proc1`，应该会收到一个未定义异常消息。让我们给`proc2`一个顶层定义并尝试`proc1`。
- en: '`(define proc2 cons)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define proc2 cons)'
- en: (proc1 'a 'b) ![<graphic>](ch2_0.gif) (b . a)`
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: (proc1 'a 'b) ![<graphic>](ch2_0.gif) (b . a)`
- en: When you define `proc1`, the system accepts your promise to define `proc2`,
    and does not complain unless you use `proc1` before defining `proc2`. This allows
    you to define procedures in any order you please. This is especially useful when
    you are trying to organize a file full of procedure definitions in a way that
    makes your program more readable. It is necessary when two procedures defined
    at top level depend upon each other; we will see some examples of this later.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义`proc1`时，系统接受您承诺定义`proc2`，并且除非在定义`proc2`之前使用`proc1`，否则不会抱怨。这使您可以以任何顺序定义过程。当两个在顶层定义的过程相互依赖时，这是必要的；稍后我们将看到一些示例。
- en: Exercise 2.6.1
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.6.1
- en: What would happen if you were to type
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您键入什么会发生
- en: '`(double-any double-any double-any)`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`(double-any double-any double-any)`'
- en: given the definition of `double-any` from the beginning of this section?
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于本节开头`double-any`的定义，您会得到什么结果？
- en: Exercise 2.6.2
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.6.2
- en: A more elegant (though possibly less efficient) way to define `cadr` and `cddr`
    than given in this section is to define a procedure that composes two procedures
    to create a third. Write the procedure `compose`, such that `(compose *p[1]* *p[2]*)`
    is the composition of `*p[1]*` and `*p[2]*` (assuming both take one argument).
    That is, `(compose *p[1]* *p[2]*)` should return a new procedure of one argument
    that applies `*p[1]*` to the result of applying `*p[2]*` to the argument. Use
    `compose` to define `cadr` and `cddr`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`cadr`和`cddr`的更优雅（尽管可能效率较低）的方法是定义一个组合两个过程以创建第三个过程的过程。编写`compose`过程，使得`(compose *p[1]* *p[2]*)`是`*p[1]*`和`*p[2]*`的组合（假设两者都接受一个参数）。也就是说，`(compose *p[1]* *p[2]*)`应返回一个应用`*p[1]*`到应用`*p[2]*`到参数的结果的新过程。使用`compose`来定义`cadr`和`cddr`。
- en: Exercise 2.6.3
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.6.3
- en: Scheme also provides `caar`, `cdar`, `caaar`, `caadr`, and so on, with any combination
    of up to four `a`'s (representing `car`) and `d`'s (representing `cdr`) between
    the `c` and the `r` (see Section [6.3](objects.html#g109)). Define each of these
    with the `compose` procedure of the preceding exercise.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme还提供了`caar`、`cdar`、`caaar`、`caadr`等，其中`c`和`r`之间的最多四个`a`（代表`car`）和`d`（代表`cdr`）的任意组合（参见第[6.3节](objects.html#g109)）。使用前面练习中的`compose`过程定义每个。
- en: Section 2.7\. Conditional Expressions
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2.7节 条件表达式
- en: So far we have considered expressions that perform a given task unconditionally.
    Suppose that we wish to write the procedure `abs`. If its argument *x* is negative,
    `abs` returns -*x*; otherwise, it returns *x*. The most straightforward way to
    write `abs` is to determine whether the argument is negative and if so negate
    it, using the `if` syntactic form.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑了无条件执行给定任务的表达式。假设我们希望编写过程`abs`。如果它的参数*x*为负数，`abs`返回-*x*；否则，返回*x*。编写`abs`最直接的方法是确定参数是否为负数，如果是，则使用`if`语法形式对其取反。
- en: '`(define abs'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define abs'
- en: (lambda (n)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (< n 0)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< n 0)
- en: (- 0 n)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: (- 0 n)
- en: n)))
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: n)))
- en: (abs 77) ![<graphic>](ch2_0.gif) 77
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: (abs 77) ![<graphic>](ch2_0.gif) 77
- en: (abs -77) ![<graphic>](ch2_0.gif) 77`
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: (abs -77) ![<graphic>](ch2_0.gif) 77`
- en: An `if` expression has the form `(if *test* *consequent* *alternative*)`, where
    `*consequent*` is the expression to evaluate if `*test*` is true and `*alternative*`
    is the expression to evaluate if `*test*` is false. In the expression above, `*test*`
    is `(< n 0)`, `*consequent*` is `(- 0 n)`, and `*alternative*` is `n`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`if`表达式的形式为`(if *test* *consequent* *alternative*)`，其中`*consequent*`是在`*test*`为真时要评估的表达式，`*alternative*`是在`*test*`为假时要评估的表达式。在上面的表达式中，`*test*`是`(< n 0)`，`*consequent*`是`(- 0 n)`，`*alternative*`是`n`。
- en: The procedure `abs` could be written in a variety of other ways. Any of the
    following are valid definitions of `abs`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`abs`可以以多种其他方式编写。以下任何一种都是`abs`的有效定义。
- en: '`(define abs'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define abs'
- en: (lambda (n)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (>= n 0)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: (if (>= n 0)
- en: n
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: n
- en: (- 0 n))))
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: (- 0 n))))
- en: (define abs
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: (define abs
- en: (lambda (n)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (not (< n 0))
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: (if (not (< n 0))
- en: n
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: n
- en: (- 0 n))))
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: (- 0 n))))
- en: (define abs
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: (define abs
- en: (lambda (n)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (or (> n 0) (= n 0))
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: (if (or (> n 0) (= n 0))
- en: n
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: n
- en: (- 0 n))))
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: (- 0 n))))
- en: (define abs
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: (define abs
- en: (lambda (n)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (= n 0)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0)
- en: '0'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (if (< n 0)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< n 0)
- en: (- 0 n)
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: (- 0 n)
- en: n))))
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: n))))
- en: (define abs
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: (define abs
- en: (lambda (n)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: ((if (>= n 0) + -)
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ((if (>= n 0) + -)
- en: '0'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: n)))`
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: n)))`
- en: The first of these definitions asks if `n` is greater than or equal to zero,
    inverting the test. The second asks if `n` is not less than zero, using the procedure
    `not` with `<`. The third asks if `n` is greater than zero or `n` is equal to
    zero, using the syntactic form `or`. The fourth treats zero separately, though
    there is no benefit in doing so. The fifth is somewhat tricky; `n` is either added
    to or subtracted from zero, depending upon whether `n` is greater than or equal
    to zero.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义中的第一个询问`n`是否大于或等于零，翻转了测试。第二个询问`n`是否不小于零，使用了带有`<`的`not`过程。第三个询问`n`是否大于零或`n`是否等于零，使用了语法形式`or`。第四个将零单独处理，尽管这样做没有好处。第五个有点棘手；`n`要么加到零上，要么从零中减去，这取决于`n`是否大于或等于零。
- en: Why is `if` a syntactic form and not a procedure? In order to answer this, let's
    revisit the definition of `reciprocal` from the first section of this chapter.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`if`是一个语法形式而不是一个过程？为了回答这个问题，让我们重新访问本章第一节中`reciprocal`的定义。
- en: '`(define reciprocal'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define reciprocal'
- en: (lambda (n)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (= n 0)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0)
- en: '"oops!"'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '"哎呀！"'
- en: (/ 1 n))))`
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 1 n))))`
- en: The second argument to the division procedure should not be zero, since the
    result is mathematically undefined. Our definition of `reciprocal` avoids this
    problem by testing for zero before dividing. Were `if` a procedure, its arguments
    (including `(/ 1 n)`) would be evaluated before it had a chance to choose between
    the consequent and alternative. Like `quote`, which does not evaluate its only
    subexpression, `if` does not evaluate all of its subexpressions and so cannot
    be a procedure.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 除数过程的第二个参数不应为零，因为在数学上结果是未定义的。我们的`reciprocal`定义通过在除法之前测试零来避免这个问题。如果`if`是一个过程，它的参数（包括`(/ 1 n)`）将在它选择后件和替代项之前被评估。就像`quote`不评估它的唯一子表达式一样，`if`不评估它的所有子表达式，因此不能是一个过程。
- en: The syntactic form `or` operates in a manner similar to `if`. The general form
    of an `or` expression is `(or *expr* ...)`. If there are no subexpressions, i.e.,
    the expression is simply `(or)`, the value is false. Otherwise, each `*expr*`
    is evaluated in turn until either (a) one of the expressions evaluates to true
    or (b) no more expressions are left. In case (a), the value is true; in case (b),
    the value is false.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 语法形式`or`的操作方式类似于`if`。`or`表达式的一般形式是`(or *expr* ...)`。如果没有子表达式，即表达式只是`(or)`，则值为假。否则，每个`*expr*`依次被评估，直到（a）其中一个表达式评估为真或（b）没有更多表达式。在情况（a）中，值为真；在情况（b）中，值为假。
- en: To be more precise, in case (a), the value of the `or` expression is the value
    of the last subexpression evaluated. This clarification is necessary because there
    are many possible true values. Usually, the value of a test expression is one
    of the two objects `#t`, for true, or `#f`, for false.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，在情况（a）中，`or`表达式的值是最后一个被评估的子表达式的值。这一澄清是必要的，因为有许多可能的真值。通常，测试表达式的值是两个对象之一，`#t`表示真，`#f`表示假。
- en: '`(< -1 0) ![<graphic>](ch2_0.gif) #t'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`(< -1 0) ![<graphic>](ch2_0.gif) #t'
- en: (> -1 0) ![<graphic>](ch2_0.gif) #f`
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: (> -1 0) ![<graphic>](ch2_0.gif) #f`
- en: Every Scheme object, however, is considered to be either true or false by conditional
    expressions and by the procedure `not`. Only `#f` is considered false; all other
    objects are considered true.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个Scheme对象在条件表达式和`not`过程中被视为真或假。只有`#f`被视为假；所有其他对象被视为真。
- en: '`(if #t ''true ''false) ![<graphic>](ch2_0.gif) true'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`(if #t ''true ''false) ![<graphic>](ch2_0.gif) true'
- en: (if #f 'true 'false) ![<graphic>](ch2_0.gif) false
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: (if #f 'true 'false) ![<graphic>](ch2_0.gif) false
- en: (if '() 'true 'false) ![<graphic>](ch2_0.gif) true
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: (if '() 'true 'false) ![<graphic>](ch2_0.gif) true
- en: (if 1 'true 'false) ![<graphic>](ch2_0.gif) true
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: (if 1 'true 'false) ![<graphic>](ch2_0.gif) true
- en: (if '(a b c) 'true 'false) ![<graphic>](ch2_0.gif) true
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: (if '(a b c) 'true 'false) ![<graphic>](ch2_0.gif) true
- en: (not #t) ![<graphic>](ch2_0.gif) #f
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: (not #t) ![<graphic>](ch2_0.gif) #f
- en: (not "false") ![<graphic>](ch2_0.gif) #f
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: (not "false") ![<graphic>](ch2_0.gif) #f
- en: (not #f) ![<graphic>](ch2_0.gif) #t
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: (not #f) ![<graphic>](ch2_0.gif) #t
- en: (or) ![<graphic>](ch2_0.gif) #f
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: (or) ![<graphic>](ch2_0.gif) #f
- en: (or #f) ![<graphic>](ch2_0.gif) #f
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: (or #f) ![<graphic>](ch2_0.gif) #f
- en: (or #f #t) ![<graphic>](ch2_0.gif) #t
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: (或 #f #t) ![<graphic>](ch2_0.gif) #t
- en: (or #f 'a #f) ![<graphic>](ch2_0.gif) a`
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: (or #f 'a #f) ![<graphic>](ch2_0.gif) a`
- en: The `and` syntactic form is similar in form to `or`, but an `and` expression
    is true if all its subexpressions are true, and false otherwise. In the case where
    there are no subexpressions, i.e., the expression is simply `(and)`, the value
    is true. Otherwise, the subexpressions are evaluated in turn until either no more
    subexpressions are left or the value of a subexpression is false. The value of
    the `and` expression is the value of the last subexpression evaluated.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 语法形式在形式上类似于 `or`，但是 `and` 表达式在其所有子表达式都为真时为真，否则为假。在没有子表达式的情况下，即表达式只是`(and)`时，值为真。否则，逐个评估子表达式，直到没有更多子表达式或子表达式的值为假。`and`
    表达式的值是最后一个评估的子表达式的值。'
- en: Using `and`, we can define a slightly different version of `reciprocal`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `and`，我们可以定义一个稍微不同版本的 `reciprocal`。
- en: '`(define reciprocal'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define reciprocal'
- en: (lambda (n)
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (and (not (= n 0))
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (= n 0))
- en: (/ 1 n))))
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 1 n))))
- en: (reciprocal 3) ![<graphic>](ch2_0.gif) 1/3
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocal 3) ![<graphic>](ch2_0.gif) 1/3
- en: (reciprocal 0.5) ![<graphic>](ch2_0.gif) 2.0
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocal 0.5) ![<graphic>](ch2_0.gif) 2.0
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) #f`
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocal 0) ![<graphic>](ch2_0.gif) #f`
- en: In this version, the value is `#f` if `n` is zero and `1/n` otherwise.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，如果`n`为零，则值为`#f`，否则为`1/n`。
- en: The procedures `=`, `<`, `>`, `<=`, and `>=` are called *predicates*. A predicate
    is a procedure that answers a specific question about its arguments and returns
    one of the two values `#t` or `#f`. The names of most predicates end with a question
    mark ( `?` ); the common numeric procedures listed above are exceptions to this
    rule. Not all predicates require numeric arguments, of course. The predicate `null?`
    returns true if its argument is the empty list `()` and false otherwise.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`=`, `<`, `>`, `<=`, 和 `>=` 被称为*谓词*。谓词是一个关于其参数的特定问题的过程，并返回`#t`或`#f`中的一个值。大多数谓词的名称以问号（`?`）结尾；上面列出的常见数值过程是这一规则的例外。当然，并非所有谓词都需要数值参数。谓词`null?`返回真，如果其参数是空列表`()`，否则返回假。
- en: '`(null? ''()) ![<graphic>](ch2_0.gif) #t'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`(null? ''()) ![<graphic>](ch2_0.gif) #t'
- en: (null? 'abc) ![<graphic>](ch2_0.gif) #f
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: (null? 'abc) ![<graphic>](ch2_0.gif) #f
- en: (null? '(x y z)) ![<graphic>](ch2_0.gif) #f
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: (null? '(x y z)) ![<graphic>](ch2_0.gif) #f
- en: (null? (cdddr '(x y z))) ![<graphic>](ch2_0.gif) #t`
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: (null? (cdddr '(x y z))) ![<graphic>](ch2_0.gif) #t`
- en: The procedure `cdr` must not be passed anything other than a pair, and an exception
    is raised when this happens. Common Lisp, however, defines `(cdr '())` to be `()`.
    The following procedure, `lisp-cdr`, is defined using `null?` to return `()` if
    its argument is `()`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 过程 `cdr` 不能接受除了一对之外的任何东西，当发生这种情况时会引发异常。然而，Common Lisp 将 `(cdr '())` 定义为 `()`。下面的过程
    `lisp-cdr` 使用 `null?` 定义，如果其参数是 `()`，则返回 `()`。
- en: '`(define lisp-cdr'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define lisp-cdr'
- en: (lambda (x)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (if (null? x)
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? x)
- en: '''()'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cdr x))))
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr x))))
- en: (lisp-cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: (lisp-cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
- en: (lisp-cdr '(c)) ![<graphic>](ch2_0.gif) ()
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: (lisp-cdr '(c)) ![<graphic>](ch2_0.gif) ()
- en: (lisp-cdr '()) ![<graphic>](ch2_0.gif) ()`
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: (lisp-cdr '()) ![<graphic>](ch2_0.gif) ()`
- en: Another useful predicate is `eqv?`, which requires two arguments. If the two
    arguments are equivalent, `eqv?` returns true. Otherwise, `eqv?` returns false.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的谓词是 `eqv?`，它需要两个参数。如果两个参数是等价的，`eqv?` 返回真。否则，`eqv?` 返回假。
- en: '`(eqv? ''a ''a) ![<graphic>](ch2_0.gif) #t'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eqv? ''a ''a) ![<graphic>](ch2_0.gif) #t'
- en: (eqv? 'a 'b) ![<graphic>](ch2_0.gif) #f
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 'a 'b) ![<graphic>](ch2_0.gif) #f
- en: (eqv? #f #f) ![<graphic>](ch2_0.gif) #t
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #f #f) ![<graphic>](ch2_0.gif) #t
- en: (eqv? #t #t) ![<graphic>](ch2_0.gif) #t
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #t #t) ![<graphic>](ch2_0.gif) #t
- en: (eqv? #f #t) ![<graphic>](ch2_0.gif) #f
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #f #t) ![<graphic>](ch2_0.gif) #f
- en: (eqv? 3 3) ![<graphic>](ch2_0.gif) #t
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 3 3) ![<graphic>](ch2_0.gif) #t
- en: (eqv? 3 2) ![<graphic>](ch2_0.gif) #f
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 3 2) ![<graphic>](ch2_0.gif) #f
- en: (let ([x "Hi Mom!"])
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x "Hi Mom!"])
- en: (eqv? x x)) ![<graphic>](ch2_0.gif) #t
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? x x)) ![<graphic>](ch2_0.gif) #t
- en: (let ([x (cons 'a 'b)])
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (cons 'a 'b)])
- en: (eqv? x x)) ![<graphic>](ch2_0.gif) #t
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? x x)) ![<graphic>](ch2_0.gif) #t
- en: (eqv? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch2_0.gif) #f`
- en: As you can see, `eqv?` returns true if the arguments are the same symbol, boolean,
    number, pair, or string. Two pairs are not the same by `eqv?` if they are created
    by different calls to `cons`, even if they have the same contents. Detailed equivalence
    rules for `eqv?` are given in Section [6.2](objects.html#g108).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果参数是相同的符号、布尔值、数字、对或字符串，`eqv?` 返回真。如果两个对是由不同的 `cons` 调用创建的，则它们不会被 `eqv?`
    视为���同，即使它们具有相同的内容。`eqv?` 的详细等价规则在第[6.2](objects.html#g108)节中给出。
- en: Scheme also provides a set of *type predicates* that return true or false depending
    on the type of the object, e.g., `pair?`, `symbol?`, `number?`, and `string?`.
    The predicate `pair?`, for example, returns true only if its argument is a pair.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme还提供了一组*类型谓词*，根据对象的类型返回真或假，例如，`pair?`，`symbol?`，`number?`和`string?`。例如，谓词`pair?`仅在其参数为对时返回真。
- en: '`(pair? ''(a . c)) ![<graphic>](ch2_0.gif) #t'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`(pair? ''(a . c)) ![<graphic>](ch2_0.gif) #t'
- en: (pair? '(a b c)) ![<graphic>](ch2_0.gif) #t
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? '(a b c)) ![<graphic>](ch2_0.gif) #t
- en: (pair? '()) ![<graphic>](ch2_0.gif) #f
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? '()) ![<graphic>](ch2_0.gif) #f
- en: (pair? 'abc) ![<graphic>](ch2_0.gif) #f
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? 'abc) ![<graphic>](ch2_0.gif) #f
- en: (pair? "Hi Mom!") ![<graphic>](ch2_0.gif) #f
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? "Hi Mom!") ![<graphic>](ch2_0.gif) #f
- en: (pair? 1234567890) ![<graphic>](ch2_0.gif) #f`
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? 1234567890) ![<graphic>](ch2_0.gif) #f`
- en: Type predicates are useful for deciding if the argument passed to a procedure
    is of the appropriate type. For example, the following version of `reciprocal`
    checks first to see that its argument is a number before testing against zero
    or performing the division.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 类型谓词对于决定传递给过程的参数是否为适当类型很有用。例如，下面的`reciprocal`版本首先检查其参数是否为数字，然后再测试是否为零或执行除法。
- en: '`(define reciprocal'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define reciprocal'
- en: (lambda (n)
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (and (number? n) (not (= n 0)))
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: (if (and (number? n) (not (= n 0)))
- en: (/ 1 n)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 1 n)
- en: '"oops!")))'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '"oops!")))'
- en: (reciprocal 2/3) ![<graphic>](ch2_0.gif) 3/2
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocal 2/3) ![<graphic>](ch2_0.gif) 3/2
- en: (reciprocal 'a) ![<graphic>](ch2_0.gif) "oops!"`
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocal 'a) ![<graphic>](ch2_0.gif) "oops!"`
- en: By the way, the code that uses `reciprocal` must check to see that the returned
    value is a number and not a string. To relieve the caller of this obligation,
    it is usually preferable to report the error, using `assertion-violation`, as
    follows.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，使用`reciprocal`的代码必须检查返回值是否为数字而不是字符串。为了减轻调用者的责任，通常最好报告错误，使用`assertion-violation`，如下所示。
- en: '`(define reciprocal'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define reciprocal'
- en: (lambda (n)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (and (number? n) (not (= n 0)))
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: (if (and (number? n) (not (= n 0)))
- en: (/ 1 n)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 1 n)
- en: (assertion-violation 'reciprocal
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: (assertion-violation 'reciprocal
- en: '"improper argument"'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '"improper argument"'
- en: n))))
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: n))))
- en: (reciprocal .25) ![<graphic>](ch2_0.gif) 4.0
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocal .25) ![<graphic>](ch2_0.gif) 4.0
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) *exception in reciprocal: improper argument 0*
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocal 0) ![<graphic>](ch2_0.gif) *exception in reciprocal: improper argument 0*
- en: (reciprocal 'a) ![<graphic>](ch2_0.gif) *exception in reciprocal: improper argument a*`
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocal 'a) ![<graphic>](ch2_0.gif) *exception in reciprocal: improper argument a*`
- en: The first argument to `assertion-violation` is a symbol identifying where the
    message originates, the second is a string describing the error, and the third
    and subsequent arguments are "irritants" to be included with the error message.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertion-violation`的第一个参数是标识消息来源的符号，第二个参数是描述错误的字符串，第三个及后续参数是要包含在错误消息中的"irritants"。'
- en: Let's look at one more conditional expression, `cond`, that is often useful
    in place of `if`. `cond` is similar to `if` except that it allows multiple test
    and alternative expressions. Consider the following definition of `sign`, which
    returns `-1` for negative inputs, `+1` for positive inputs, and `0` for zero.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个条件表达式`cond`，通常在`if`的位置使用很有用。`cond`类似于`if`，不同之处在于它允许多个测试和替代表达式。考虑下面的`sign`定义，它对负输入返回`-1`，对正输入返回`+1`，对零返回`0`。
- en: '`(define sign'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define sign'
- en: (lambda (n)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (< n 0)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< n 0)
- en: '-1'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '-1'
- en: (if (> n 0)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: (if (> n 0)
- en: '+1'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '+1'
- en: 0))))`
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 0))))`
- en: '`(sign -88.3) ![<graphic>](ch2_0.gif) -1'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`(sign -88.3) ![<graphic>](ch2_0.gif) -1'
- en: (sign 0) ![<graphic>](ch2_0.gif) 0
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: (sign 0) ![<graphic>](ch2_0.gif) 0
- en: (sign 333333333333) ![<graphic>](ch2_0.gif) 1
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: (sign 333333333333) ![<graphic>](ch2_0.gif) 1
- en: (* (sign -88.3) (abs -88.3)) ![<graphic>](ch2_0.gif) -88.3`
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: (* (sign -88.3) (abs -88.3)) ![<graphic>](ch2_0.gif) -88.3`
- en: The two `if` expressions may be replaced by a single `cond` expression as follows.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`if`表达式可以被单个`cond`表达式替换，如下所示。
- en: '`(define sign'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define sign'
- en: (lambda (n)
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (cond
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(< n 0) -1]'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[(< n 0) -1]'
- en: '[(> n 0) +1]'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[(> n 0) +1]'
- en: '[else 0])))`'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[else 0])))`'
- en: A `cond` expression usually takes the form
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond`表达式通常采用以下形式'
- en: '`(cond (*test* *expr*) ... (else *expr*))`'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cond (*test* *expr*) ... (else *expr*))`'
- en: though the `else` clause may be omitted. This should be done only when there
    is no possibility that all the tests will fail, as in the new version of `sign`
    below.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`else`子句可以省略。只有在所有测试都不可能失败时才应这样做，就像下面的`sign`新版本一样。
- en: '`(define sign'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define sign'
- en: (lambda (n)
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (cond
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(< n 0) -1]'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '[(< n 0) -1]'
- en: '[(> n 0) +1]'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[(> n 0) +1]'
- en: '[(= n 0) 0])))`'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '[(= n 0) 0])))`'
- en: These definitions of `sign` do not depend on the order in which the tests are
    performed, since only one of the tests can be true for any value of `n`. The following
    procedure computes the tax on a given amount of income in a progressive tax system
    with breakpoints at 10,000, 20,000, and 30,000 dollars.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对`sign`的定义不依赖于测试执行的顺序，因为对于任何`n`的值，只有一个测试可以为真。下面的过程计算在具有 10,000、20,000 和 30,000
    美元分界点的渐进税制下的给定收入的税金。
- en: '`(define income-tax'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define income-tax'
- en: (lambda (income)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (income)
- en: (cond
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(<= income 10000) (* income .05)]'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '[(<= income 10000) (* income .05)]'
- en: '[(<= income 20000) (+ (* (- income 10000) .08) 500.00)]'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '[(<= income 20000) (+ (* (- income 10000) .08) 500.00)]'
- en: '[(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '[(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]'
- en: '[else (+ (* (- income 30000) .21) 2600.00)])))`'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (+ (* (- income 30000) .21) 2600.00)])))`'
- en: '`(income-tax 5000) ![<graphic>](ch2_0.gif) 250.0'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`(income-tax 5000) ![<graphic>](ch2_0.gif) 250.0'
- en: (income-tax 15000) ![<graphic>](ch2_0.gif) 900.0
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: (income-tax 15000) ![<graphic>](ch2_0.gif) 900.0
- en: (income-tax 25000) ![<graphic>](ch2_0.gif) 1950.0
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: (income-tax 25000) ![<graphic>](ch2_0.gif) 1950.0
- en: (income-tax 50000) ![<graphic>](ch2_0.gif) 6800.0`
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: (income-tax 50000) ![<graphic>](ch2_0.gif) 6800.0`
- en: In this example, the order in which the tests are performed, left to right (top
    to bottom), is significant.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，测试执行的顺序，从左到右（从上到下），是重要的。
- en: Exercise 2.7.1
  id: totrans-591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.7.1
- en: Define the predicate `atom?`, which returns true if its argument is not a pair
    and false if it is.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 定义谓词`atom?`，如果其参数不是一对则返回true，否则返回false。
- en: Exercise 2.7.2
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.7.2
- en: The procedure `length` returns the length of its argument, which must be a list.
    For example, `(length '(a b c))` is 3. Using `length`, define the procedure `shorter`,
    which returns the shorter of two list arguments. Have it return the first list
    if they have the same length.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`length`返回其参数的长度，该参数必须是一个列表。例如，`(length '(a b c))`是3。使用`length`，定义过程`shorter`，它返回两个列表参数中较短的一个。如果它们的长度相同，则返回第一个列表。
- en: '`(shorter ''(a b) ''(c d e)) ![<graphic>](ch2_0.gif) (a b)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '`(shorter ''(a b) ''(c d e)) ![<graphic>](ch2_0.gif) (a b)'
- en: (shorter '(a b) '(c d)) ![<graphic>](ch2_0.gif) (a b)
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: (shorter '(a b) '(c d)) ![<graphic>](ch2_0.gif) (a b)
- en: (shorter '(a b) '(c)) ![<graphic>](ch2_0.gif) (c)`
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: (shorter '(a b) '(c)) ![<graphic>](ch2_0.gif) (c)`
- en: Section 2.8\. Simple Recursion
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2.8 节。简单的递归
- en: 'We have seen how we can control whether or not expressions are evaluated with
    `if`, `and`, `or`, and `cond`. We can also perform an expression more than once
    by creating a procedure containing the expression and invoking the procedure more
    than once. What if we need to perform some expression repeatedly, say for all
    the elements of a list or all the numbers from one to ten? We can do so via recursion.
    Recursion is a simple concept: the application of a procedure from within that
    procedure. It can be tricky to master recursion at first, but once mastered it
    provides expressive power far beyond ordinary looping constructs.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何通过`if`、`and`、`or`和`cond`来控制表达式是否被求值。我们还可以通过创建包含表达式的过程并多次调用该过程来多次执行一个表达式。如果我们需要重复执行一些表达式，例如对列表的所有元素或从一到十的所有数字怎么办？我们可以通过递归来实现。递归是一个简单的概念：在过程内部应用该过程。起初掌握递归可能有些棘手，但一旦掌握，它提供的表现力远远超出了普通的循环结构。
- en: A *recursive procedure* is a procedure that applies itself. Perhaps the simplest
    recursive procedure is the following, which we will call `goodbye`.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归过程*是一个应用自身的过程。也许最简单的递归过程是以下过程，我们将其称为`goodbye`。'
- en: '`(define goodbye'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define goodbye'
- en: (lambda ()
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (goodbye)))
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: (goodbye)))
- en: (goodbye) ![<graphic>](ch2_0.gif)`
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: (goodbye) ![<graphic>](ch2_0.gif)`
- en: This procedure takes no arguments and simply applies itself immediately. There
    is no value after the ![<graphic>](ch2_0.gif) because `goodbye` never returns.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程不需要任何参数，只是立即应用它自己。在![<graphic>](ch2_0.gif)后没有值，因为`goodbye`永远不会返回。
- en: Obviously, to make practical use out of a recursive procedure, we must have
    some way to terminate the recursion. Most recursive procedures should have at
    least two basic elements, a *base case* and a *recursion step*. The base case
    terminates the recursion, giving the value of the procedure for some base argument.
    The recursion step gives the value in terms of the value of the procedure applied
    to a different argument. In order for the recursion to terminate, the different
    argument must be closer to the base argument in some way.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，要使递归过程实用，我们必须有一种方法来终止递归。大多数递归过程应该至少有两个基本要素，一个*基本情形*和一个*递归步骤*。基本情形终止递归，为某个基本参数给出过程的值。递归步骤给出了基于将过程应用于不同参数的值。为了使递归终止，不同的参数必须在某种方式上更接近基本参数。
- en: Let's consider the problem of finding the length of a proper list recursively.
    We need a base case and a recursion step. The logical base argument for recursion
    on lists is nearly always the empty list. The length of the empty list is zero,
    so the base case should give the value zero for the empty list. In order to become
    closer to the empty list, the natural recursion step involves the cdr of the argument.
    A nonempty list is one element longer than its cdr, so the recursion step gives
    the value as one more than the length of the cdr of the list.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑递归地找到proper list的长度的问题。我们需要一个基本情况和一个递归步骤。关于列表递归的逻辑基本参数几乎总是空列表。空列表的长度为零，因此基本情况应该为空列表给出值零。为了更接近空列表，自然的递归步骤涉及参数的cdr。非空列表比其cdr多一个元素，因此递归步骤给出的值比列表的cdr的长度多一个。
- en: '`(define length'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define length'
- en: (lambda (ls)
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (if (null? ls)
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '0'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (+ (length (cdr ls)) 1))))`
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (length (cdr ls)) 1))))`
- en: '`(length ''()) ![<graphic>](ch2_0.gif) 0'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`(length ''()) ![<graphic>](ch2_0.gif) 0'
- en: (length '(a)) ![<graphic>](ch2_0.gif) 1
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: (length '(a)) ![<graphic>](ch2_0.gif) 1
- en: (length '(a b)) ![<graphic>](ch2_0.gif) 2`
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: (length '(a b)) ![<graphic>](ch2_0.gif) 2`
- en: The `if` expression asks if the list is empty. If so, the value is zero. This
    is the base case. If not, the value is one more than the length of the cdr of
    the list. This is the recursion step.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`表达式询问列表是否为空。如果是，值为零。这是基本情况。如果不是，值为列表的cdr的长度加一。这是递归步骤。'
- en: 'Many Scheme implementations allow you to trace the execution of a procedure
    to see how it operates. In Chez Scheme, for example, one way to trace a procedure
    is to type `(trace *name*)`, where `*name*` is the name of a procedure you have
    defined at top level. If you trace `length` as defined above and pass it the argument
    `''(a b c d)`, you should see something like this:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Scheme实现允许您跟踪过程的执行，以查看其操作方式。例如，在Chez Scheme中，跟踪过程的一种方法是键入`(trace *name*)`，其中`*name*`是您在顶层定义的过程的名称。如果您跟踪上面定义的`length`并将其传递给参数`'(a b c d)`，您应该看到类似以下内容：
- en: '`|(length (a b c d))'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '`|(length (a b c d))'
- en: '| (length (b c d))'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '| (length (b c d))'
- en: '| |(length (c d))'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '| |(length (c d))'
- en: '| | (length (d))'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '| | (length (d))'
- en: '| | |(length ())'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '| | |(length ())'
- en: '| | |0'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '| | |0'
- en: '| | 1'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '| | 1'
- en: '| |2'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '| |2'
- en: '| 3'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3'
- en: '|4`'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '|4`'
- en: The indentation shows the nesting level of the recursion; the vertical lines
    associate applications visually with their values. Notice that on each application
    of `length` the list gets smaller until it finally reaches `()`. The value at
    `()` is 0, and each outer level adds 1 to arrive at the final value.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进显示了递归的嵌套级别；竖线将应用与其值在视觉上关联起来。请注意，在每次`length`的应用中，列表都会变小，直到最终达到`()`。`()`处的值为0，每个外层级别都会加1以到达最终值。
- en: Let's write a procedure, `list-copy`, that returns a copy of its argument, which
    must be a list. That is, `list-copy` returns a new list consisting of the elements
    (but not the pairs) of the old list. Making a copy might be useful if either the
    original list or the copy might be altered via `set-car!` or `set-cdr!`, which
    we discuss later.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个过程`list-copy`，它返回其参数的副本，该参数必须是一个列表。也就是说，`list-copy`返回一个由旧列表的元素（但不是对）组成的新列表。如果原始列表或副本可能通过`set-car!`或`set-cdr!`进行更改，那么制作副本可能很有用，我们稍后会讨论这一点。
- en: '`(list-copy ''()) ![<graphic>](ch2_0.gif) ()'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list-copy ''()) ![<graphic>](ch2_0.gif) ()'
- en: (list-copy '(a b c)) ![<graphic>](ch2_0.gif) (a b c)`
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: (list-copy '(a b c)) ![<graphic>](ch2_0.gif) (a b c)`
- en: See if you can define `list-copy` before studying the definition below.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究下面的定义之前，看看你能否定义`list-copy`。
- en: '`(define list-copy'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define list-copy'
- en: (lambda (ls)
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (if (null? ls)
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons (car ls)
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car ls)
- en: (list-copy (cdr ls))))))`
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: (list-copy (cdr ls))))))`
- en: The definition of `list-copy` is similar to the definition of `length`. The
    test in the base case is the same, `(null? ls)`. The value in the base case is
    `()`, however, not 0, because we are building up a list, not a number. The recursive
    call is the same, but instead of adding one, `list-copy` conses the car of the
    list onto the value of the recursive call.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`list-copy`的定义与`length`的定义类似。基本情况中的测试相同，为`(null? ls)`。基本情况中的值为`()`，而不是0，因为我们正在构建一个列表，而不是一个数字。递归调用相同，但是`list-copy`不是加一，而是将列表的car连接到递归调用的值上。'
- en: There is no reason why there cannot be more than one base case. The procedure
    `memv` takes two arguments, an object and a list. It returns the first sublist,
    or *tail*, of the list whose car is equal to the object, or `#f` if the object
    is not found in the list. The value of `memv` may be used as a list or as a truth
    value in a conditional expression.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由不能有多个基本情况。`memv`过程接受两个参数，一个对象和一个列表。它返回第一个子列表，或者*尾部*，其car等于对象，如果在列表中找不到对象，则返回`#f`。`memv`的值可以用作列表或条件表达式中的真值。
- en: '`(define memv'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define memv'
- en: (lambda (x ls)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x ls)
- en: (cond
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? ls) #f]'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? ls) #f]'
- en: '[(eqv? (car ls) x) ls]'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eqv? (car ls) x) ls]'
- en: '[else (memv x (cdr ls))])))`'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (memv x (cdr ls))])))`'
- en: '`(memv ''a ''(a b b d)) ![<graphic>](ch2_0.gif) (a b b d)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`(memv ''a ''(a b b d)) ![<graphic>](ch2_0.gif) (a b b d)'
- en: (memv 'b '(a b b d)) ![<graphic>](ch2_0.gif) (b b d)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: (memv 'b '(a b b d)) ![<graphic>](ch2_0.gif) (b b d)
- en: (memv 'c '(a b b d)) ![<graphic>](ch2_0.gif) #f
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: (memv 'c '(a b b d)) ![<graphic>](ch2_0.gif) #f
- en: (memv 'd '(a b b d)) ![<graphic>](ch2_0.gif) (d)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: (memv 'd '(a b b d)) ![<graphic>](ch2_0.gif) (d)
- en: (if (memv 'b '(a b b d))
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: (if (memv 'b '(a b b d))
- en: '"yes"'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '"yes"'
- en: '"no") ![<graphic>](ch2_0.gif) "yes"`'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '"no") ![<graphic>](ch2_0.gif) "yes"`'
- en: Here there are two conditions to check, hence the use of `cond`. The first cond
    clause checks for the base value of `()`; no object is a member of `()`, so the
    answer is `#f`. The second clause asks if the car of the list is the object, in
    which case the list is returned, being the first tail whose car contains the object.
    The recursion step just continues down the list.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个条件要检查，因此使用了`cond`。第一个cond子句检查`()`的基本值；没有对象是`()`的成员，所以答案是`#f`。第二个子句询问列表的car是否是对象，如果是，则返回列表，即第一个包含对象的car的尾部。递归步骤只是继续向下遍历列表。
- en: There may also be more than one recursion case. Like `memv`, the procedure `remv`
    defined below takes two arguments, an object and a list. It returns a new list
    with all occurrences of the object removed from the list.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有多个递归情况。就像`memv`一样，下面定义的`remv`过程接受两个参数，一个对象和一个列表。它返回一个新列表，其中移除了列表中的所有对象。
- en: '`(define remv'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define remv'
- en: (lambda (x ls)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x ls)
- en: (cond
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? ls) ''()]'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? ls) ''()]'
- en: '[(eqv? (car ls) x) (remv x (cdr ls))]'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eqv? (car ls) x) (remv x (cdr ls))]'
- en: '[else (cons (car ls) (remv x (cdr ls)))])))`'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (cons (car ls) (remv x (cdr ls)))])))`'
- en: '`(remv ''a ''(a b b d)) ![<graphic>](ch2_0.gif) (b b d)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`(remv ''a ''(a b b d)) ![<graphic>](ch2_0.gif) (b b d)'
- en: (remv 'b '(a b b d)) ![<graphic>](ch2_0.gif) (a d)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: (remv 'b '(a b b d)) ![<graphic>](ch2_0.gif) (a d)
- en: (remv 'c '(a b b d)) ![<graphic>](ch2_0.gif) (a b b d)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: (remv 'c '(a b b d)) ![<graphic>](ch2_0.gif) (a b b d)
- en: (remv 'd '(a b b d)) ![<graphic>](ch2_0.gif) (a b b)`
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: (remv 'd '(a b b d)) ![<graphic>](ch2_0.gif) (a b b)`
- en: 'This definition is similar to the definition of `memv` above, except `remv`
    does not quit once it finds the element in the car of the list. Rather, it continues,
    simply ignoring the element. If the element is not found in the car of the list,
    `remv` does the same thing as `list-copy` above: it conses the car of the list
    onto the recursive value.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与上面的`memv`定义类似，不同之处在于`remv`在找到列表的car中的元素后不会停止。相反，它会继续，简单地忽略该元素。如果在列表的car中找不到元素，`remv`会像上面的`list-copy`一样做同样的事情：将列表的car连接到递归值上。
- en: Up to now, the recursion has been only on the cdr of a list. It is sometimes
    useful, however, for a procedure to recur on the car as well as the cdr of the
    list. The procedure `tree-copy` defined below treats the structure of pairs as
    a tree rather than as a list, with the left subtree being the car of the pair
    and the right subtree being the cdr of the pair. It performs a similar operation
    to `list-copy`, building new pairs while leaving the elements (leaves) alone.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，递归仅在列表的cdr上进行。然而，有时候，一个过程需要在列表的car和cdr上进行递归。下面定义的`tree-copy`过程将对对的结构视为树而不是列表���左子树是对的car，右子树是对的cdr。它执行类似于`list-copy`的操作，构建新的对，同时保留元素（叶子）不变。
- en: '`(define tree-copy'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define tree-copy'
- en: (lambda (tr)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (tr)
- en: (if (not (pair? tr))
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: (if (not (pair? tr))
- en: tr
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: tr
- en: (cons (tree-copy (car tr))
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (tree-copy (car tr))
- en: (tree-copy (cdr tr))))))`
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: (tree-copy (cdr tr))))))`
- en: '`(tree-copy ''((a . b) . c)) ![<graphic>](ch2_0.gif) ((a . b) . c)`'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`(tree-copy ''((a . b) . c)) ![<graphic>](ch2_0.gif) ((a . b) . c)`'
- en: The natural base argument for a tree structure is anything that is not a pair,
    since the recursion traverses pairs rather than lists. The recursive step in this
    case is *doubly recursive*, finding the value recursively for the car as well
    as the cdr of the argument.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构的自然基本参数是任何不是对的东西，因为递归遍历对而不是列表。在这种情况下，递归步骤是*双重递归*，递归地找到参数的car和cdr的值。
- en: At this point, readers who are familiar with other languages that provide special
    iteration constructs, e.g., *while* or *for* loops, might wonder whether similar
    constructs are required in Scheme. Such constructs are unnecessary; iteration
    in Scheme is expressed more clearly and succinctly via recursion. Recursion is
    more general and eliminates the need for the variable assignments required by
    many other languages' iteration constructs, resulting in code that is more reliable
    and easier to follow. Some recursion is essentially iteration and executes as
    such; Section [3.2](further.html#g55) has more to say about this. Often, there
    is no need to make a distinction, however. Concentrate instead on writing clear,
    concise, and correct programs.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，熟悉其他提供特殊迭代结构的语言的读者，例如*while*或*for*循环，可能会想知道Scheme中是否需要类似的结构。这些结构是不必要的；在Scheme中，通过递归更清晰、更简洁地表达迭代。递归更通用，消除了许多其他语言迭代结构所需的变量赋值，导致代码更可靠、更易于理解。一些递归本质上是迭代并执行为此；第[3.2](further.html#g55)节有更多相关内容。然而，通常不需要区分。相反，专注于编写清晰、简洁和正确的程序。
- en: Before we leave the topic of recursion, let's consider a special form of repetition
    called *mapping*. Consider the following procedure, `abs-all`, that takes a list
    of numbers as input and returns a list of their absolute values.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开递归的话题之前，让我们考虑一种称为*映射*的特殊重复形式。考虑以下过程`abs-all`，它以数字列表作为输入并返回它们的绝对值列表。
- en: '`(define abs-all'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define abs-all'
- en: (lambda (ls)
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (if (null? ls)
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons (abs (car ls))
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (abs (car ls))
- en: (abs-all (cdr ls))))))`
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: (abs-all (cdr ls))))))`
- en: '`(abs-all ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`(abs-all ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
- en: This procedure forms a new list from the input list by applying the procedure
    `abs` to each element. We say that `abs-all` *maps* `abs` over the input list
    to produce the output list. Mapping a procedure over a list is a fairly common
    thing to do, so Scheme provides the procedure `map`, which maps its first argument,
    a procedure, over its second, a list. We can use `map` to define `abs-all`.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程通过将过程`abs`应用于每个元素从输入列表中形成新列表。我们说`abs-all` *映射* `abs` 到输入列表以产生输出列表。在列表上映射一个过程是一件相当常见的事情，因此Scheme提供了`map`过程，它将其第一个参数，一个过程，映射到其第二个参数，一个列表上。我们可以使用`map`来定义`abs-all`。
- en: '`(define abs-all'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define abs-all'
- en: (lambda (ls)
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (map abs ls)))`
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: (map abs ls)))`
- en: We really do not need `abs-all`, however, since the corresponding direct application
    of `map` is just as short and perhaps clearer.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们实际上并不需要`abs-all`，因为直接应用`map`的对应方式同样简短，也许更清晰。
- en: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
- en: Of course, we can use `lambda` to create the procedure argument to `map`, e.g.,
    to square the elements of a list of numbers.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用`lambda`来创建`map`的过程参数，例如，对数字列表进行平方。
- en: '`(map (lambda (x) (* x x))'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`(map (lambda (x) (* x x))'
- en: '''(1 -3 -5 7)) ![<graphic>](ch2_0.gif) (1 9 25 49)`'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 -3 -5 7)) ![<graphic>](ch2_0.gif) (1 9 25 49)`'
- en: We can map a multiple-argument procedure over multiple lists, as in the following
    example.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多参数过程映射到多个列表上，就像下面的例子一样。
- en: '`(map cons ''(a b c) ''(1 2 3)) ![<graphic>](ch2_0.gif) ((a . 1) (b . 2) (c . 3))`'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '`(map cons ''(a b c) ''(1 2 3)) ![<graphic>](ch2_0.gif) ((a . 1) (b . 2) (c . 3))`'
- en: The lists must be of the same length, and the procedure should accept as many
    arguments as there are lists. Each element of the output list is the result of
    applying the procedure to corresponding members of the input list.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 列表必须具有相同的长度，并且过程应接受与列表数量相同的参数。输出列表的每个元素是将过程应用于输入列表的相应成员的结果。
- en: Looking at the first definition of `abs-all` above, you should be able to derive,
    before studying it, the following definition of `map1`, a restricted version of
    `map` that maps a one-argument procedure over a single list.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下上面`abs-all`的第一个定义，你应该能在学习之前推导出`map1`的以下定义，这是`map`的一个受限版本，将一个单参数过程映射到一个列表上。
- en: '`(define map1'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define map1'
- en: (lambda (p ls)
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p ls)
- en: (if (null? ls)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons (p (car ls))
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (p (car ls))
- en: (map1 p (cdr ls))))))`
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: (map1 p (cdr ls))))))`
- en: '`(map1 abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '`(map1 abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
- en: All we have done is to replace the call to `abs` in `abs-all` with a call to
    the new parameter `p`. A definition of the more general `map` is given in Section [5.4](control.html#g100).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的一切只是用新参数`p`替换了`abs-all`中对`abs`的调用。更一般的`map`的定义在第[5.4](control.html#g100)节中给出。
- en: Exercise 2.8.1
  id: totrans-706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.8.1
- en: Describe what would happen if you switched the order of the arguments to `cons`
    in the definition of `tree-copy`.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 描述如果在 `tree-copy` 的 `cons` 定义中交换参数的顺序会发生什么。
- en: Exercise 2.8.2
  id: totrans-708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.8.2
- en: Consult Section [6.3](objects.html#g109) for the description of `append` and
    define a two-argument version of it. What would happen if you switched the order
    of the arguments in the call to `append` within your definition of `append`?
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考第 [6.3](objects.html#g109) 节中 `append` 的描述，并定义其二元版本。如果在对 `append` 的调用中交换参数的顺序会发生什么？
- en: Exercise 2.8.3
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.8.3
- en: Define the procedure `make-list`, which takes a nonnegative integer `*n*` and
    an object and returns a new list, `*n*` long, each element of which is the object.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 定义过程 `make-list`，它接受一个非负整数 `*n*` 和一个对象，并返回一个新列表，长为 `*n*`，每个元素都是该对象。
- en: '`(make-list 7 ''()) ![<graphic>](ch2_0.gif) (() () () () () () ())`'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '`(make-list 7 ''()) ![<graphic>](ch2_0.gif) (() () () () () () ())`'
- en: '[*Hint*: The base test should be `(= *n* 0)`, and the recursion step should
    involve `(- *n* 1)`. Whereas `()` is the natural base case for recursion on lists,
    0 is the natural base case for recursion on nonnegative integers. Similarly, subtracting
    1 is the natural way to bring a nonnegative integer closer to 0.]'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '[*提示*：基本测试应该是 `(= *n* 0)`，而递归步骤应该涉及 `(- *n* 1)`。虽然 `()` 是列表递归的自然基本情况，但是0是非负整数递归的自然基本情况。同样，减去1是将非负整数逼近0的自然方法。]'
- en: Exercise 2.8.4
  id: totrans-714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.8.4
- en: The procedures `list-ref` and `list-tail` return the *n*th element and *n*th
    tail of a list *ls*.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 过程 `list-ref` 和 `list-tail` 返回列表 *ls* 的第 *n* 个元素和第 *n* 个尾部。
- en: '`(list-ref ''(1 2 3 4) 0) ![<graphic>](ch2_0.gif) 1'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list-ref ''(1 2 3 4) 0) ![<graphic>](ch2_0.gif) 1'
- en: (list-tail '(1 2 3 4) 0) ![<graphic>](ch2_0.gif) (1 2 3 4)
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: (list-tail '(1 2 3 4) 0) ![<graphic>](ch2_0.gif) (1 2 3 4)
- en: (list-ref '(a short (nested) list) 2) ![<graphic>](ch2_0.gif) (nested)
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: (list-ref '(a short (nested) list) 2) ![<graphic>](ch2_0.gif) (nested)
- en: (list-tail '(a short (nested) list) 2) ![<graphic>](ch2_0.gif) ((nested) list)`
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: (list-tail '(a short (nested) list) 2) ![<graphic>](ch2_0.gif) ((nested) list)`
- en: Define both procedures.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 分别定义这两个过程。
- en: Exercise 2.8.5
  id: totrans-721
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.8.5
- en: 'Exercise [2.7.2](start.html#g31) had you use `length` in the definition of
    `shorter`, which returns the shorter of its two list arguments, or the first if
    the two have the same length. Write `shorter` without using `length`. [*Hint*:
    Define a recursive helper, `shorter?`, and use it in place of the length comparison.]'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 [2.7.2](start.html#g31) 要求你在定义 `shorter` 时使用 `length`，该函数返回两个列表中较短的一个，如果两个列表长度相同，则返回第一个。不使用
    `length` 定义 `shorter`。[*提示*：定义一个递归辅助函数 `shorter?`，并在长度比较的地方使用它。]
- en: Exercise 2.8.6
  id: totrans-723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.8.6
- en: 'All of the recursive procedures shown so far have been directly recursive.
    That is, each procedure directly applies itself to a new argument. It is also
    possible to write two procedures that use each other, resulting in indirect recursion.
    Define the procedures `odd?` and `even?`, each in terms of the other. [*Hint*:
    What should each return when its argument is 0?]'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所展示的递归过程都是直接递归的。也就是说，每个过程直接将自己应用于一个新的参数。还可以编写两个相互使用的过程，从而实现间接递归。分别以 `odd?`
    和 `even?` 的方式定义这两个过程。[*提示*：当参数为0时，每个过程应该返回什么？]
- en: '`(even? 17) ![<graphic>](ch2_0.gif) #f'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`(even? 17) ![<graphic>](ch2_0.gif) #f'
- en: (odd? 17) ![<graphic>](ch2_0.gif) #t`
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '(odd? 17) ![<graphic>](ch2_0.gif) #t`'
- en: Exercise 2.8.7
  id: totrans-727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.8.7
- en: Use `map` to define a procedure, `transpose`, that takes a list of pairs and
    returns a pair of lists as follows.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map` 定义一个名为 `transpose` 的过程，该过程接受一对列表，并返回一对列表，如下所示。
- en: '`(transpose ''((a . 1) (b . 2) (c . 3))) ![<graphic>](ch2_0.gif) ((a b c) 1 2 3)`'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '`(transpose ''((a . 1) (b . 2) (c . 3))) ![<graphic>](ch2_0.gif) ((a b c) 1
    2 3)`'
- en: '[*Hint*: `((a b c) 1 2 3)` is the same as `((a b c) . (1 2 3))`.]'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '[*提示*：`((a b c) 1 2 3)` 和 `((a b c) . (1 2 3))` 是相同的。]'
- en: Section 2.9\. Assignment
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2.9 节。赋值
- en: Although many programs can be written without them, assignments to top-level
    variables or `let`-bound and `lambda`-bound variables are sometimes useful. Assignments
    do not create new bindings, as with `let` or `lambda`, but rather change the values
    of existing bindings. Assignments are performed with `set!`.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多程序可以在没有它们的情况下编写，但对顶层变量或 `let` 绑定和 `lambda` 绑定的赋值有时很有用。赋值不会创建新的绑定，如 `let`
    或 `lambda` 那样，而是改变现有绑定的值。赋值使用 `set!` 执行。
- en: '`(define abcde ''(a b c d e))'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define abcde ''(a b c d e))'
- en: abcde ![<graphic>](ch2_0.gif) (a b c d e)
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: abcde ![<graphic>](ch2_0.gif)（a b c d e）
- en: (set! abcde (cdr abcde))
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: (set! abcde (cdr abcde))
- en: abcde ![<graphic>](ch2_0.gif) (b c d e)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: abcde ![<graphic>](ch2_0.gif)（b c d e）
- en: (let ([abcde '(a b c d e)])
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([abcde '(a b c d e)])
- en: (set! abcde (reverse abcde))
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: (set! abcde (reverse abcde))
- en: abcde) ![<graphic>](ch2_0.gif) (e d c b a)`
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: abcde) ![<graphic>](ch2_0.gif)（e d c b a）
- en: Many languages require the use of assignments to initialize local variables,
    separate from the declaration or binding of the variables. In Scheme, all local
    variables are given a value immediately upon binding. Besides making the separate
    assignment to initialize local variables unnecessary, it ensures that the programmer
    cannot forget to initialize them, a common source of errors in most languages.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言要求使用赋值来初始化本地变量，与变量的声明或绑定分开。在 Scheme 中，所有本地变量在绑定时立即赋值。除了使单独的赋值初始化本地变量变得不必要外，它还确保程序员不会忘记初始化它们，这是大多数语言中常见的错误来源。
- en: In fact, most of the assignments that are either necessary or convenient in
    other languages are both unnecessary and inconvenient in Scheme, since there is
    typically a clearer way to express the same algorithm without assignments. One
    common practice in some languages is to sequence expression evaluation with a
    series of assignments, as in the following procedure that finds the roots of a
    quadratic equation.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在 Scheme 中，大多数在其他语言中既必要又方便的赋值在 Scheme 中既不必要又不方便，因为通常有一种更清晰的方式来表达相同的算法而不需要赋值。在某些语言中的一种常见做法是通过一系列赋值来顺序计算表达式的值，就像下面这个找到二次方程根的过程一样。
- en: '`(define quadratic-formula'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define quadratic-formula'
- en: (lambda (a b c)
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (a b c)
- en: (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
- en: (set! minusb (- 0 b))
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: (set! minusb (- 0 b))
- en: (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
- en: (set! divisor (* 2 a))
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: (set! divisor (* 2 a))
- en: (set! root1 (/ (+ minusb radical) divisor))
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: (set! root1 (/ (+ minusb radical) divisor))
- en: (set! root2 (/ (- minusb radical) divisor))
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: (set! root2 (/ (- minusb radical) divisor))
- en: (cons root1 root2))))`
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: (cons root1 root2))))`
- en: The roots are computed according to the well-known quadratic formula,
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 根据众所周知的二次方程公式计算根，
- en: '![<graphic>](ch2_4.gif)'
  id: totrans-752
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch2_4.gif)'
- en: which yields the solutions to the equation 0 = *ax*² + *bx* + *c*. The `let`
    expression in this definition is employed solely to establish the variable bindings,
    corresponding to the declarations required in other languages. The first three
    assignment expressions compute subpieces of the formula, namely -*b*, ![<graphic>](ch2_5.gif),
    and 2*a*. The last two assignment expressions compute the two roots in terms of
    the subpieces. A pair of the two roots is the value of `quadratic-formula`. For
    example, the two roots of 2*x*² - 4*x* - 6 are *x* = 3 and *x* = -1.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式给出了方程 0 = *ax*² + *bx* + *c* 的解。在这个定义中，`let` 表达式仅用于建立变量绑定，对应于其他语言中所需的声明。前三个赋值表达式计算了公式的子部分，即
    -*b*、![<graphic>](ch2_5.gif) 和 2*a*。最后两个赋值表达式根据子部分计算了两个根。两个根的一对是 `quadratic-formula`
    的值。例如，2*x*² - 4*x* - 6 的两个根是 *x* = 3 和 *x* = -1。
- en: '`(quadratic-formula 2 -4 -6) ![<graphic>](ch2_0.gif) (3 . -1)`'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '`(quadratic-formula 2 -4 -6) ![<graphic>](ch2_0.gif) (3 . -1)`'
- en: The definition above works, but it can be written more clearly without the assignments,
    as shown below.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的定义有效，但可以更清晰地写成没有赋值的形式，如下所示。
- en: '`(define quadratic-formula'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define quadratic-formula'
- en: (lambda (a b c)
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (a b c)
- en: (let ([minusb (- 0 b)]
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([minusb (- 0 b)]
- en: '[radical (sqrt (- (* b b) (* 4 (* a c))))]'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '[radical (sqrt (- (* b b) (* 4 (* a c))))]'
- en: '[divisor (* 2 a)])'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '[divisor (* 2 a)])'
- en: (let ([root1 (/ (+ minusb radical) divisor)]
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([root1 (/ (+ minusb radical) divisor)]
- en: '[root2 (/ (- minusb radical) divisor)])'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '[root2 (/ (- minusb radical) divisor)])'
- en: (cons root1 root2)))))`
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: (cons root1 root2)))))`
- en: In this version, the `set!` expressions are gone, and we are left with essentially
    the same algorithm. By employing two `let` expressions, however, the definition
    makes clear the dependency of `root1` and `root2` on the values of `minusb`, `radical`,
    and `divisor`. Equally important, the `let` expressions make clear the *lack*
    of dependencies among `minusb`, `radical`, and `divisor` and between `root1` and
    `root2`.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，`set!` 表达式消失了，我们留下的基本上是相同的算法。然而，通过使用两个 `let` 表达式，这个定义清楚地表明了 `root1` 和
    `root2` 对于 `minusb`、`radical` 和 `divisor` 的值的依赖关系。同样重要的是，`let` 表达式清楚地表明了 `minusb`、`radical`
    和 `divisor` 之间以及 `root1` 和 `root2` 之间的 *缺乏* 依赖关系。
- en: Assignments do have some uses in Scheme, otherwise the language would not support
    them. Consider the following version of `cons` that counts the number of times
    it is called, storing the count in a variable named `cons-count`. It uses `set!`
    to increment the count; there is no way to achieve the same behavior without assignments.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值在 Scheme 中确实有一些用途，否则语言就不会支持它们。��虑下面这个计算 `cons` 被调用次数并将计数存储在名为 `cons-count`
    的变量中的版本。它使用 `set!` 来增加计数；没有办法在没有赋值的情况下实现相同的行为。
- en: '`(define kons-count 0)'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define kons-count 0)'
- en: (define kons
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: (define kons
- en: (lambda (x y)
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (set! kons-count (+ kons-count 1))
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: (set! kons-count (+ kons-count 1))
- en: (cons x y)))
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: (cons x y)))
- en: (kons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: (kons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
- en: kons-count ![<graphic>](ch2_0.gif) 1
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: kons-count ![<graphic>](ch2_0.gif) 1
- en: (kons 'a (kons 'b (kons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: (kons 'a (kons 'b (kons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
- en: kons-count ![<graphic>](ch2_0.gif) 4`
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: kons-count ![<graphic>](ch2_0.gif) 4`
- en: 'Assignments are commonly used to implement procedures that must maintain some
    internal state. For example, suppose we would like to define a procedure that
    returns 0 the first time it is called, 1 the second time, 2 the third time, and
    so on indefinitely. We could write something similar to the definition of `cons-count`
    above:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值通常用于实现必须维护一些内部状态的过程。例如，假设我们想要定义一个过程，第一次调用它时返回0，第二次返回1，第三次返回2，依此类推。我们可以编写类似于上面`cons-count`定义的内容：
- en: '`(define next 0)'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define next 0)'
- en: (define count
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: (define count
- en: (lambda ()
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (let ([v next])
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([v next])
- en: (set! next (+ next 1))
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: (set! next (+ next 1))
- en: v)))
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: v)))
- en: (count) ![<graphic>](ch2_0.gif) 0
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: (count) ![<graphic>](ch2_0.gif) 0
- en: (count) ![<graphic>](ch2_0.gif) 1`
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: (count) ![<graphic>](ch2_0.gif) 1`
- en: 'This solution is somewhat undesirable in that the variable `next` is visible
    at top level even though it need not be. Since it is visible at top level, any
    code in the system can change its value, perhaps inadvertently affecting the behavior
    of `count` in a subtle way. We can solve this problem by `let`-binding `next`
    outside of the `lambda` expression:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案有些不理想，因为变量`next`在顶层可见，即使它不需要。由于它在顶层可见，系统中的任何代码都可以更改其值，可能无意中影响`count`的行为。我们可以通过在`lambda`表达式之外`let`-绑定`next`来解决这个问题：
- en: '`(define count'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define count'
- en: (let ([next 0])
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([next 0])
- en: (lambda ()
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (let ([v next])
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([v next])
- en: (set! next (+ next 1))
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: (set! next (+ next 1))
- en: v))))`
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: v))))`
- en: The latter solution also generalizes easily to provide multiple counters, each
    with its own local counter. The procedure `make-counter`, defined below, returns
    a new counting procedure each time it is called.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种解决方案也很容易推广，以提供具有自己本地计数器的多个计数器。下面定义的过程`make-counter`在每次调用时返回一个新的计数过程。
- en: '`(define make-counter'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define make-counter'
- en: (lambda ()
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (let ([next 0])
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([next 0])
- en: (lambda ()
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (let ([v next])
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([v next])
- en: (set! next (+ next 1))
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: (set! next (+ next 1))
- en: v)))))`
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: v)))))`
- en: Since `next` is bound inside of `make-counter` but outside of the procedure
    returned by `make-counter`, each procedure it returns maintains its own unique
    counter.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`next`绑定在`make-counter`内部，但在`make-counter`返回的过程之外，每个由它返回的过程都维护着自己独特的计数器。
- en: '`(define count1 (make-counter))'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define count1 (make-counter))'
- en: (define count2 (make-counter))
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: (define count2 (make-counter))
- en: (count1) ![<graphic>](ch2_0.gif) 0
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: (count1) ![<graphic>](ch2_0.gif) 0
- en: (count2) ![<graphic>](ch2_0.gif) 0
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: (count2) ![<graphic>](ch2_0.gif) 0
- en: (count1) ![<graphic>](ch2_0.gif) 1
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: (count1) ![<graphic>](ch2_0.gif) 1
- en: (count1) ![<graphic>](ch2_0.gif) 2
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: (count1) ![<graphic>](ch2_0.gif) 2
- en: (count2) ![<graphic>](ch2_0.gif) 1`
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: (count2) ![<graphic>](ch2_0.gif) 1`
- en: If a state variable must be shared by more than one procedure defined at top
    level, but we do not want the state variable to be visible at top level, we can
    use `let` to bind the variable and `set!` to make the procedures visible at top
    level.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态变量必须由多个在顶层定义的过程共享，但我们不希望状态变量在顶层可见，我们可以使用`let`绑定变量，并使用`set!`使过程在顶层可见。
- en: '`(define shhh #f)'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define shhh #f)'
- en: (define tell #f)
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: (define tell #f)
- en: (let ([secret 0])
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([secret 0])
- en: (set! shhh
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: (set! shhh
- en: (lambda (message)
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (message)
- en: (set! secret message)))
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: (set! secret message)))
- en: (set! tell
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: (set! tell
- en: (lambda ()
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: secret)))
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: secret)))
- en: (shhh "sally likes harry")
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: (shhh "sally likes harry")
- en: (tell) ![<graphic>](ch2_0.gif) "sally likes harry"
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: (tell) ![<graphic>](ch2_0.gif) "sally likes harry"
- en: secret ![<graphic>](ch2_0.gif) *exception: variable secret is not bound*`
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: secret ![<graphic>](ch2_0.gif) *异常：变量secret未绑定*`
- en: Variables must be defined before they can be assigned, so we define `shhh` and
    `tell` to be `#f` initially. (Any initial value would do.) We'll see this structure
    again in Section [3.5](further.html#g79) and a better way to structure code like
    this as a library in Section [3.6](further.html#g84).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 变量必须在分配之前定义，所以我们将`shhh`和`tell`定义为初始值为`#f`。（任何初始值都可以。）我们将在第 [3.5](further.html#g79) 节再次看到这种结构，并在第 [3.6](further.html#g84) 节中看到如何更好地将这样的代码结构化为库。
- en: Local state is sometimes useful for caching computed values or allowing a computation
    to be evaluated *lazily*, i.e., only once and only on demand. The procedure `lazy`
    below accepts a *thunk*, or zero-argument procedure, as an argument. Thunks are
    often used to "freeze" computations that must be delayed for some reason, which
    is exactly what we need to do in this situation. When passed a thunk `*t*`, `lazy`
    returns a new thunk that, when invoked, returns the value of invoking `*t*`. Once
    computed, the value is saved in a local variable so that the computation need
    not be performed again. A boolean flag is used to record whether `*t*` has been
    invoked and its value saved.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 本地状态有时对于缓存计算值或允许计算*惰性*（即，仅一次且仅在需要时）非常有用。下面的`lazy`过程接受一个*thunk*或零参数过程作为参数。 Thunks经常用于“冻结”必须由于某种原因延迟的计算，这正是我们在这种情况下需要做的。当传递一个thunk
    `*t*`时，`lazy`返回一个新的thunk，当调用时，返回调用`*t*`的值。一旦计算完成，该值将保存在本地变量中，以便无需再次执行计算。使用布尔标志记录`*t*`是否已被调用以及其值是否已保存。
- en: '`(define lazy'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define lazy'
- en: (lambda (t)
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (t)
- en: (let ([val #f] [flag #f])
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([val #f] [flag #f])
- en: (lambda ()
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (if (not flag)
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: (if (not flag)
- en: (begin (set! val (t))
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: (begin (set! val (t))
- en: (set! flag #t)))
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: (set! flag #t)))
- en: val))))`
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: val))))`
- en: The syntactic form `begin`, used here for the first time, evaluates its subexpressions
    in sequence from left to right and returns the value of the last subexpression,
    like the body of a `let` or `lambda` expression. We also see that the `*alternative*`
    subexpression of an `if` expression can be omitted. This should be done only when
    the value of the `if` is discarded, as it is in this case.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里首次使用的语法形式`begin`按顺序从左到右评估其子表达式，并返回最后一个子表达式的值，就像`let`或`lambda`表达式的主体一样。我们还看到`if`表达式的`*alternative*`子表达式可以省略。只有在`if`的值被丢弃时才应该这样做，就像在这种情况下一样。
- en: Lazy evaluation is especially useful for values that require considerable time
    to compute. By delaying the evaluation, we might avoid computing the value altogether,
    and by saving the value, we avoid computing it more than once.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值对于需要较长时间计算的值特别有用。通过延迟评估，我们可能完全避免计算该值，并通过保存该值，我们避免多次计算它。
- en: The operation of `lazy` can best be illustrated by printing a message from within
    a thunk passed to `lazy`.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy`的操作最好通过在传递给`lazy`的thunk中打印消息来进行说明。'
- en: '`(define p'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define p'
- en: (lazy (lambda ()
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: (lazy (lambda ()
- en: (display "Ouch!")
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: (display "哎呀！")
- en: (newline)
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: (newline)
- en: '"got me")))`'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '"got me")))`'
- en: The first time `p` is invoked, the message `Ouch!` is printed and the string
    `"got me"` is returned. Thereafter, `"got me"` is returned but the message is
    not printed. The procedures `display` and `newline` are the first examples of
    explicit input/output we have seen; `display` prints the string without quotation
    marks, and `newline` prints a newline character.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '第一次调用`p`时，将打印消息`哎呀！`并返回字符串`"got me"`。此后，将返回`"got me"`，但不会打印消息。`display`和`newline`过程是我们看到的显式输入/输出的第一个示例；`display`打印字符串而不带引号，`newline`打印换行符。 '
- en: 'To further illustrate the use of `set!`, let''s consider the implementation
    of stack objects whose internal workings are not visible on the outside. A stack
    object accepts one of four *messages*: `empty?`, which returns `#t` if the stack
    is empty; `push!`, which adds an object to the top of the stack; `top`, which
    returns the object on the top of the stack; and `pop!`, which removes the object
    on top of the stack. The procedure `make-stack` given below creates a new stack
    each time it is called in a manner similar to `make-counter`.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明`set!`的用法，让我们考虑堆栈对象的实现，其内部工作在外部不可见。堆栈对象接受四种*消息*之一：`empty?`，如果堆栈为空则返回`#t`；`push!`，将对象添加到堆栈顶部；`top`，返回堆栈顶部的对象；和`pop!`，移除堆栈顶部的对象。下面给出的`make-stack`过程每次调用时都创建一个新的堆栈，类似于`make-counter`。
- en: '`(define make-stack'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define make-stack'
- en: (lambda ()
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (let ([ls '()])
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls '()])
- en: (lambda (msg . args)
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (msg . args)
- en: (cond
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(eqv? msg ''empty?) (null? ls)]'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eqv? msg ''empty?) (null? ls)]'
- en: '[(eqv? msg ''push!) (set! ls (cons (car args) ls))]'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eqv? msg ''push!) (set! ls (cons (car args) ls))]'
- en: '[(eqv? msg ''top) (car ls)]'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eqv? msg ''top) (car ls)]'
- en: '[(eqv? msg ''pop!) (set! ls (cdr ls))]'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eqv? msg ''pop!) (set! ls (cdr ls))]'
- en: '[else "oops"])))))`'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '[else "糟糕"])))))`'
- en: Each stack is stored as a list bound to the variable `ls`; `set!` is used to
    change this binding for `push!` and `pop!`. Notice that the argument list of the
    inner `lambda` expression uses the improper list syntax to bind `args` to a list
    of all arguments but the first. This is useful here because in the case of `empty?`,
    `top`, and `pop!` there is only one argument (the message), but in the case of
    `push!` there are two (the message and the object to push onto the stack).
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 每个堆栈存储为绑定到变量`ls`的列表；`set!`用于更改此绑定以进行`push!`和`pop!`。请注意，内部`lambda`表达式的参数列表使用不正确的列表语法将`args`绑定到除第一个参数之外的所有参数列表。这在这里很有用，因为在`empty?`、`top`和`pop!`的情况下只有一个参数（消息），但在`push!`的情况下有两个参数（消息和要推送到堆栈上的对象）。
- en: '`(define stack1 (make-stack))'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define stack1 (make-stack))'
- en: (define stack2 (make-stack))
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: (define stack2 (make-stack))
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.giff) (#t #t)
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.giff) (#t #t)
- en: (stack1 'push! 'a)
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: (stack1 'push! 'a)
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#f #t)
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#f #t)
- en: (stack1 'push! 'b)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: (stack1 'push! 'b)
- en: (stack2 'push! 'c)
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: (stack2 'push! 'c)
- en: (stack1 'top) ![<graphic>](ch2_0.gif) b
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: (stack1 'top) ![<graphic>](ch2_0.gif) b
- en: (stack2 'top) ![<graphic>](ch2_0.gif) c
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: (stack2 'top) ![<graphic>](ch2_0.gif) c
- en: (stack1 'pop!)
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: (stack1 'pop!)
- en: (stack1 'top) ![<graphic>](ch2_0.gif) a
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: (stack1 'top) ![<graphic>](ch2_0.gif) a
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#f #f)
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#f #f)
- en: (stack1 'pop!)
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: (stack1 'pop!)
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#t #f)`
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#t #f)`
- en: As with the counters created by `make-counter`, the state maintained by each
    stack object is directly accessible only within the object. Each reference or
    change to this state is made explicitly by the object itself. One important benefit
    is that we can change the internal structure of the stack, perhaps to use a vector
    (see Section [6.9](objects.html#g115)) instead of a list to hold the elements,
    without changing its external behavior. Because the behavior of the object is
    known abstractly (not operationally), it is known as an *abstract object*. See
    Section [12.8](examples.html#g193) for more about creating abstract objects.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 与`make-counter`创建的计数器一样，每个堆栈对象维护的状态仅在对象内部直接可访问。对此状态的每个引用或更改都由对象本身显式进行。一个重要的好处是，我们可以更改堆栈的内部结构，也许是为了使用向量（参见第[6.9节](objects.html#g115)），而不是列表来保存元素，而不改变其外部行为。因为对象的行为是以抽象方式知道的（不是操作方式），所以它被称为*抽象对象*。有关创建抽象对象的更多信息，请参见第[12.8节](examples.html#g193)。
- en: In addition to changing the values of variables, we can also change the values
    of the car and cdr fields of a pair, using the procedures `set-car!` and `set-cdr!`.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改变量的值外，我们还可以使用过程`set-car!`和`set-cdr!`更改对的car和cdr字段的值。
- en: '`(define p (list 1 2 3))'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define p (list 1 2 3))'
- en: (set-car! (cdr p) 'two)
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! (cdr p) 'two)
- en: p ![<graphic>](ch2_0.gif) (1 two 3)
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: p ![<graphic>](ch2_0.gif) (1 two 3)
- en: (set-cdr! p '())
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! p '())
- en: p ![<graphic>](ch2_0.gif) (1)`
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: p ![<graphic>](ch2_0.gif) (1)`
- en: We can use these operators to define a queue data type, which is like a stack
    except that new elements are added at one end and extracted from the other. The
    following queue implementation uses a *tconc* structure. A tconc consists of a
    nonempty list and a header. The header is a pair whose car points to the first
    pair (head) of the list and whose cdr points to the last pair (end) of the list.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些运算符定义队列数据类型，它类似于堆栈，只是新元素被添加到一端并从另一端提取。下面的队列实现使用了一个*tconc*结构。tconc由一个非空列表和一个头部组成。头部是一个对，其car指向列表的第一个对（头部），其cdr指向列表的最后一个对（end）。
- en: '![<graphic>](ch2_6.gif)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch2_6.gif)'
- en: The last element of the list is a placeholder and not considered part of the
    queue.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的最后一个元素是一个占位符，不被视为队列的一部分。
- en: 'Four operations on queues are defined below: `make-queue`, which constructs
    a queue; `putq!`, which adds an element to the end of a queue; `getq`, which retrieves
    the element at the front of a queue; and `delq!`, which removes the element at
    the front of a queue.'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 四个队列操作如下定义：`make-queue`，构造队列；`putq!`，将元素添加到队列的末尾；`getq`，检索队列前端的元素；以及`delq!`，移除队列前端的元素。
- en: '`(define make-queue'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define make-queue'
- en: (lambda ()
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (let ([end (cons 'ignored '())])
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([end (cons 'ignored '())])
- en: (cons end end))))
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: (cons end end))))
- en: (define putq!
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: (define putq!
- en: (lambda (q v)
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (q v)
- en: (let ([end (cons 'ignored '())])
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([end (cons 'ignored '())])
- en: (set-car! (cdr q) v)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! (cdr q) v)
- en: (set-cdr! (cdr q) end)
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! (cdr q) end)
- en: (set-cdr! q end))))
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! q end))))
- en: (define getq
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: (define getq
- en: (lambda (q)
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (q)
- en: (car (car q))))
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: (car (car q))))
- en: (define delq!
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: (define delq!
- en: (lambda (q)
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (q)
- en: (set-car! q (cdr (car q)))))`
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! q (cdr (car q)))))`
- en: All are simple operations except for `putq!`, which modifies the end pair to
    contain the new value and adds a new end pair.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都很简单，除了`putq!`，它修改最后一对以包含新值，并添加一个新的末尾对。
- en: '`(define myq (make-queue))'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define myq (make-queue))'
- en: (putq! myq 'a)
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: (putq! myq 'a)
- en: (putq! myq 'b)
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: (putq! myq 'b)
- en: (getq myq) ![<graphic>](ch2_0.gif) a
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: (getq myq) ![<graphic>](ch2_0.gif) a
- en: (delq! myq)
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: (delq! myq)
- en: (getq myq) ![<graphic>](ch2_0.gif) b
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: (getq myq) ![<graphic>](ch2_0.gif) b
- en: (delq! myq)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: (delq! myq)
- en: (putq! myq 'c)
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: (putq! myq 'c)
- en: (putq! myq 'd)
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: (putq! myq 'd)
- en: (getq myq) ![<graphic>](ch2_0.gif) c
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: (getq myq) ![<graphic>](ch2_0.gif) c
- en: (delq! myq)
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: (delq! myq)
- en: (getq myq) ![<graphic>](ch2_0.gif) d`
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: (getq myq) ![<graphic>](ch2_0.gif) d`
- en: Exercise 2.9.1
  id: totrans-905
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9.1
- en: 'Modify `make-counter` to take two arguments: an initial value for the counter
    to use in place of 0 and an amount to increment the counter by each time.'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`make-counter`以接受两个参数：计数器的初始值，用于替代0，以及每次增加计数器的数量。
- en: Exercise 2.9.2
  id: totrans-907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9.2
- en: Look up the description of `case` in Section [5.3](control.html#g99). Replace
    the `cond` expression in `make-stack` with an equivalent `case` expression. Add
    `mt?` as a second name for the `empty?` message.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅第[5.3](control.html#g99)节中关于`case`的描述。用等效的`case`表达式替换`make-stack`中的`cond`表达式。将`mt?`作为`empty?`消息的第二个名称添加。
- en: Exercise 2.9.3
  id: totrans-909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9.3
- en: Modify the `stack` object to allow the two messages `ref` and `set!`. `(*stack* 'ref *i*)`
    should return the `*i*`th element from the top of the stack; `(*stack* 'ref 0)`
    should be equivalent to `(*stack* 'top)`. `(*stack* 'set! *i* *v*)` should change
    the `*i*`th element from the top of the stack to `*v*`.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`stack`对象以允许两条消息`ref`和`set!`。`(*stack* 'ref *i*)`应返回栈顶第`*i*`个元素；`(*stack* 'ref 0)`应等同于`(*stack* 'top)`。`(*stack* 'set! *i* *v*)`应将栈顶第`*i*`个元素更改为`*v*`。
- en: '`(define stack (make-stack))'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define stack (make-stack))'
- en: (stack 'push! 'a)
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'push! 'a)
- en: (stack 'push! 'b)
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'push! 'b)
- en: (stack 'push! 'c)
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'push! 'c)
- en: (stack 'ref 0) ![<graphic>](ch2_0.gif) c
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'ref 0) ![<graphic>](ch2_0.gif) c
- en: (stack 'ref 2) ![<graphic>](ch2_0.gif) a
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'ref 2) ![<graphic>](ch2_0.gif) a
- en: (stack 'set! 1 'd)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'set! 1 'd)
- en: (stack 'ref 1) ![<graphic>](ch2_0.gif) d
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'ref 1) ![<graphic>](ch2_0.gif) d
- en: (stack 'top) ![<graphic>](ch2_0.gif) c
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'top) ![<graphic>](ch2_0.gif) c
- en: (stack 'pop!)
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'pop!)
- en: (stack 'top) ![<graphic>](ch2_0.gif) d`
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: (stack 'top) ![<graphic>](ch2_0.gif) d`
- en: '[*Hint*: Use `list-ref` to implement `ref` and `list-tail` with `set-car!`
    to implement `set!`.]'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '[*提示*：使用`list-ref`来实现`ref`，使用`list-tail`和`set-car!`来实现`set!`。]'
- en: Exercise 2.9.4
  id: totrans-923
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9.4
- en: Scheme supports *vectors* as well as lists. Like lists, vectors are aggregate
    objects that contain other objects. Unlike lists, vectors have a fixed size and
    are laid out in one flat block of memory, typically with a header containing the
    length of the vector, as in the ten-element vector below.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme支持*向量*以及列表。像列表一样，向量是包含其他对象的聚合对象。与列表不同，向量具有固定大小，并且通常以一个扁平的内存块布局，其中包含向量长度的头部，如下面的十个元素向量所示。
- en: '![<graphic>](ch2_7.gif)'
  id: totrans-925
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch2_7.gif)'
- en: This makes vectors more suitable for applications needing fast access to any
    element of the aggregate but less suitable for applications needing data structures
    that grow and shrink as needed.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得向量更适合需要快速访问聚合的任何元素的应用程序，但不太适合需要根据需要增长和收缩的数据结构的应用程序。
- en: Look up the basic vector operations in Section [6.9](objects.html#g115) and
    reimplement the `stack` object to use a vector instead of a list to hold the stack
    contents. Include the `ref` and `set!` messages of Exercise [2.9.3](start.html#g43).
    Have the new `make-stack` accept a size argument *n* and make the vector length
    *n*, but do not otherwise change the external (abstract) interface.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅第[6.9](objects.html#g115)节中关于基本向量操作的内容，并重新实现`stack`对象，使用向量而不是列表来保存栈内容。包括练习[2.9.3](start.html#g43)中的`ref`和`set!`消息。让新的`make-stack`接受一个大小参数*n*，并使向量长度为*n*，但不要改变外部（抽象）接口。
- en: Exercise 2.9.5
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9.5
- en: Define a predicate, `emptyq?`, for determining if a queue is empty. Modify `getq`
    and `delq!` to raise an exception when an empty queue is found, using `assertion-violation`.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 为确定队列是否为空定义一个谓词`emptyq?`。修改`getq`和`delq!`，当发现空队列时引发异常，使用`assertion-violation`。
- en: Exercise 2.9.6
  id: totrans-930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9.6
- en: In the queue implementation, the last pair in the encapsulated list is a placeholder,
    i.e., it never holds anything useful. Recode the queue operators to avoid this
    wasted pair. Make sure that the series of queue operations given earlier works
    with the new implementation. Which implementation do you prefer?
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列实现中，封装列表中的最后一对是一个占位符，即它从不保存任何有用的内容。��新编码队列操作以避免这种浪费的对。确保早期给出的一系列队列操作在新实现中能够正常工作。您更喜欢哪种实现？
- en: Exercise 2.9.7
  id: totrans-932
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9.7
- en: Using `set-cdr!`, it is possible to create *cyclic lists*. For example, the
    following expression evaluates to a list whose car is the symbol `a` and whose
    cdr is the list itself.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set-cdr!`，可以创建*循环列表*。例如，以下表达式求值为一个其car为符号`a`，cdr为列表本身的列表。
- en: '`(let ([ls (cons ''a ''())])'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([ls (cons ''a ''())])'
- en: (set-cdr! ls ls)
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! ls ls)
- en: ls)`
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: ls)`
- en: What happens when you enter the above expression during an interactive Scheme
    session? What will the implementation of `length` on page [42](start.html#defn:simplelength)
    do when given a cyclic list? What does the built-in `length` primitive do?
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式Scheme会话中输入上述表达式会发生什么？当给出一个循环列表时，页面[42](start.html#defn:simplelength)上的`length`实现会做什么？内置的`length`原语做什么？
- en: Exercise 2.9.8
  id: totrans-938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.9.8
- en: Define the predicate `list?`, which returns `#t` if its argument is a proper
    list and `#f` otherwise (see Section [6.3](objects.html#g109)). It should return
    `#f` for cyclic lists as well as for lists terminated by objects other than `()`.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 定义谓词`list?`，如果其参数是一个正确的列表则返回`#t`，否则返回`#f`（参见第[6.3](objects.html#g109)节）。对于循环列表以及以除`()`之外的对象终止的列表，它应该返回`#f`。
- en: '`(list? ''()) ![<graphic>](ch2_0.gif) #t'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list? ''()) ![<graphic>](ch2_0.gif) #t'
- en: (list? '(1 2 3)) ![<graphic>](ch2_0.gif) #t
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: (list? '(1 2 3)) ![<graphic>](ch2_0.gif) #t
- en: (list? '(a . b)) ![<graphic>](ch2_0.gif) #f
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: (list? '(a . b)) ![<graphic>](ch2_0.gif) #f
- en: (list? (let ([ls (cons 'a '())])
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: (list? (let ([ls (cons 'a '())])
- en: (set-cdr! ls ls)
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! ls ls)
- en: ls)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: ls)) ![<graphic>](ch2_0.gif) #f`
- en: 'First write a simplified version of `list?` that does not handle cyclic lists,
    then extend this to handle cyclic lists correctly. Revise your definition until
    you are satisfied that it is as clear and concise as possible. [*Hint*: Use the
    following "hare and tortoise" algorithm to detect cycles. Define a recursive help
    procedure of two arguments, the hare and the tortoise. Start both the hare and
    the tortoise at the beginning of the list. Have the hare advance by two cdrs each
    time the tortoise advances by one cdr. If the hare catches the tortoise, there
    must be a cycle.]'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编写一个简化版本的`list?`，不处理循环列表，然后扩展到正确处理循环列表。修改你的定义，直到你满意为止，确保尽可能清晰简洁。[*提示*：使用以下“乌龟和兔子”算法来检测循环。定义一个带有两个参数的递归辅助过程，即乌龟和兔子。让乌龟和兔子同时从列表的开头开始。每次乌龟前进一个cdr时，兔子前进两个cdr。如果兔子追上乌龟，那么一定存在循环。]
