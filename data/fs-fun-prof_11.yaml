- en: The "Understanding F# types" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “理解 F# 类型”系列
- en: F# is not just about functions; the powerful type system is another key ingredient.
    And just as with functions, understanding the type system is critical to being
    fluent and comfortable in the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: F# 不仅仅是关于函数；强大的类型系统是另一个关键因素。就像函数一样，理解类型系统对于流畅和舒适地使用这种语言至关重要。
- en: In addition to the common .NET types. F# has some other types that are very
    common in functional languages but not available in imperative languages like
    C# or Java.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的 .NET 类型外。F# 还有一些其他在函数式语言中非常常见但在命令式语言（如 C# 或 Java）中不可用的类型。
- en: This series introduces these types and how to use them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列介绍了这些类型以及如何使用它们。
- en: '[Understanding F# types: Introduction](types-intro.html). A new world of types.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解 F# 类型：介绍](types-intro.html)。一种新的类型世界。'
- en: '[Overview of types in F#](overview-of-types-in-fsharp.html). A look at the
    big picture.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F# 类型概述](overview-of-types-in-fsharp.html)。放眼全局。'
- en: '[Type abbreviations](type-abbreviations.html). Also known as aliases.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型缩写](type-abbreviations.html)。也称为别名。'
- en: '[Tuples](tuples.html). Multiplying types together.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[元组](tuples.html)。将类型相乘。'
- en: '[Records](records.html). Extending tuples with labels.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[记录](records.html)。用标签扩展元组。'
- en: '[Discriminated Unions](discriminated-unions.html). Adding types together.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[辨别联合](discriminated-unions.html)。将类型加在一起。'
- en: '[The Option type](the-option-type.html). And why it is not null or nullable.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选项类型](the-option-type.html)。以及它为什么不是 null 或可空的。'
- en: '[Enum types](enum-types.html). Not the same as a union type.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举类型](enum-types.html)。与联合类型不同。'
- en: '[Built-in .NET types](cli-types.html). Ints, strings, bools, etc.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内置 .NET 类型](cli-types.html)。整数、字符串、布尔等。'
- en: '[Units of measure](units-of-measure.html). Type safety for numerics.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[度量单位](units-of-measure.html)。数字的类型安全。'
- en: '[Understanding type inference](type-inference.html). Behind the magic curtain.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解类型推断](type-inference.html)。在魔幕幕后。'
- en: 'Understanding F# types: Introduction'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 F# 类型：介绍
- en: 'Understanding F# types: Introduction'
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 F# 类型：介绍
- en: '*NOTE: Before reading this series, I suggest that you read the ["thinking functionally"](thinking-functionally.html)
    and ["expressions and syntax"](expressions-and-syntax.html) series as a prerequisite.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：在阅读本系列之前，我建议您作为先决条件阅读 ["以函数方式思考"](thinking-functionally.html) 和 ["表达式和语法"](expressions-and-syntax.html)
    系列。*'
- en: F# is not just about functions; the powerful type system is another key ingredient.
    And just as with functions, understanding the type system is critical to being
    fluent and comfortable in the language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: F# 不仅仅是关于函数；强大的类型系统是另一个关键因素。就像函数一样，理解类型系统对于流畅和舒适地使用这种语言至关重要。
- en: 'Now, so far we have seen some basic types that can be used as input and output
    to functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些基本类型，可以用作函数的输入和输出：
- en: Primitive types such as `int`, `float`, `string`, and `bool`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型如 `int`、`float`、`string` 和 `bool`
- en: Simple function types such as `int->int`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的函数类型，比如 `int->int`
- en: The `unit` type
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unit` 类型'
- en: Generic types.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型。
- en: None of these types should be unfamiliar. Analogues of these are available in
    C# and other imperative languages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型都不应该陌生。它们的类比在 C# 和其他命令式语言中都有。
- en: But in this series we are going to introduce some new kinds of types that are
    very common in functional languages but uncommon in imperative languages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个系列中，我们将介绍一些在函数式语言中非常常见但在命令式语言中不常见的新类型。
- en: 'The extended types we will look at in this series are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本系列中看到的扩展类型有：
- en: Tuples
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Records
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Unions
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合
- en: The Option type
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项类型
- en: Enum types
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型
- en: For all these types, we will discuss both the abstract principles and the details
    of how to use them in practice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些类型，我们将讨论抽象原则以及如何在实践中使用它们的细节。
- en: Lists and other recursive data types are also very important types, but there
    is so much to say about them that they will need their own series!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和其他递归数据类型也是非常重要的类型，但是关于它们有太多要说的内容，它们将需要它们自己的系列！
- en: Overview of types in F#
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 类型概述
- en: Overview of types in F#
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 类型概述
- en: Before we dive into all the specific types, let's look at the big picture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究所有具体类型之前，让我们先来看一下全局视角。
- en: What are types for?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型的用途是什么？
- en: If you are coming from an object-oriented design background, one of the paradigm
    shifts involved in "thinking functionally" is to change how you think about types.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象的设计背景，那么“以函数方式思考”的一个范式转变就是改变你对类型的思考方式。
- en: A well designed object-oriented program will have a strong focus on behavior
    rather than data, so it will use a lot of polymorphism, either using "duck-typing"
    or explicit interfaces, and will try to avoid having explicit knowledge of the
    actual concrete classes being passed around.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的面向对象程序将更加关注行为而不是数据，因此它将大量使用多态性，要么使用"鸭子类型"，要么使用显式接口，并且会尽量避免对传递的实际具体类的明确了解。
- en: A well designed functional program, on the other hand, will have a strong focus
    on *data types* rather than behavior. F# puts much more emphasis on designing
    types correctly than an imperative language such as C#, and many of the examples
    in this series and later series will focus on creating and refining type definitions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个设计良好的函数式程序将更加关注*数据类型*而不是行为。F#比命令式语言如C#更加注重正确设计类型，本系列和后续系列中的许多示例将侧重于创建和完善类型定义。
- en: 'So what is a type? Types are surprisingly hard to define. One definition from
    a well known textbook says:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是类型？类型其实很难定义。一本著名教材的定义是：
- en: '"A type system is a tractable syntactic method of proving the absence of certain
    program behaviors by classifying phrases according to the kinds of values they
    compute"'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"类型系统是一种可控的句法方法，通过根据它们计算的值的种类对短语进行分类，来证明某些程序行为的缺失"'
- en: '*(Benjamin Pierce, Types and Programming Languages)*'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*(本杰明·皮尔斯，《类型与编程语言》)*'
- en: 'Ok, that definition is a bit technical. So let''s turn it around -- what do
    we use types for in practice? In the context of F#, you can think of types as
    being used in two main ways:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那个定义有点技术性。那么让我们换个角度来看 -- 在实践中我们用类型做什么？在F#的背景下，你可以将类型用于两种主要方式：
- en: Firstly, as an *annotation to a value* that allows certain checks to be made,
    especially at compile time. In other words, types allow you to have "compile time
    unit tests".
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，作为*值的注释*，允许进行某些检查，尤其是在编译时。换句话说，类型允许你进行"编译时单元测试"。
- en: Second, as *domains* for functions to act upon. That is, a type is a sort of
    data modeling tool that allows you to represent a real world domain in your code.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，作为*函数操作的领域*。也就是说，类型是一种数据建模工具，允许你在代码中表示现实世界的领域。
- en: These two definitions interact. The better the type definitions reflect the
    real-world domain, the better they will statically encode the business rules.
    And the better they statically encode the business rules, the better the "compile
    time unit tests" work. In the ideal scenario, if your program compiles, then it
    really is correct!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义相互作用。类型定义越能反映现实世界的领域，它们就越能静态编码业务规则。而它们越能静态编码业务规则，"编译时单元测试"就越好用。在理想情况下，如果你的程序编译通过，那么它就是正确的！
- en: What kinds of types are there?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有哪些类型？
- en: 'F# is a hybrid language, so it has a mixture of types: some from its functional
    background, and some from its object-oriented background.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: F#是一种混合语言，因此它具有来自其函数式背景的一些类型，也有来自其面向对象背景的一些类型。
- en: 'Generally, the types in F# can be grouped into the following categories:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，F#中的类型可以分为以下几类：
- en: '**Common .NET types**. These are types that conform to the .NET Common Language
    Infrastructure (CLI), and which are easily portable to every .NET language.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见的.NET类型**。这些类型符合.NET公共语言基础设施（CLI），并且可以轻松移植到每种.NET语言。'
- en: '**F# specific types**. These are types that are part of the F# language and
    are designed for pure functional programming.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F#特定类型**。这些是F#语言的一部分，专为纯函数式编程而设计。'
- en: 'If you are familiar with C#, you will know all the CLI types. They include:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉C#，你会了解所有CLI类型。它们包括：
- en: Built-in value types (int, bool, etc).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置值类型（int，bool等）。
- en: Built-in reference types (string, etc).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置引用类型（字符串等）。
- en: User-defined value types (enum and struct).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的值类型（枚举和结构体）。
- en: Classes and interfaces
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和接口
- en: Delegates
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托
- en: Arrays
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: 'The F# specific types include:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: F#特定类型包括：
- en: '[Function types](function-values-and-simple-values.html) (not the same as delegates
    or C# lambdas)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数类型](function-values-and-simple-values.html)（不同于委托或C# lambda）'
- en: '[The unit type](how-types-work-with-functions.html#unit-type)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[单元类型](how-types-work-with-functions.html#unit-type)'
- en: '[Tuples](tuples.html) (now part of .NET 4.0)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[元组](tuples.html)（现在是.NET 4.0的一部分）'
- en: '[Records](records.html)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[记录](records.html)'
- en: '[Discriminated Unions](discriminated-unions.html)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[辨别联合](discriminated-unions.html)'
- en: '[Option types](the-option-type.html)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选项类型](the-option-type.html)'
- en: Lists (not the same as the .NET List class)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表（不同于.NET List类）
- en: 'I strongly recommend that when creating new types you stick with the F# specific
    types rather than using classes. They have a number of advantages over the CLI
    types, such as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议在创建新类型时，你坚持使用 F# 特定的类型，而不是使用类。它们比 CLI 类型有很多优势，例如：
- en: They are immutable
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的
- en: They cannot be null
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能为null
- en: They have built-in structural equality and comparison
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有内置的结构相等性和比较
- en: They have built-in pretty printing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有内置的漂亮打印
- en: Sum and Product types
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 和与积类型
- en: 'The key to understanding the power of types in F# is that most new types are
    constructed by from other types using two basic operations: **sum** and **product**.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 F# 中类型的威力的关键在于，大多数新类型都是通过使用两种基本操作：**和**和**积**，从其他类型构造出来的。
- en: 'That is, in F# you can define new types almost as if you were doing algebra:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在 F# 中，你可以几乎像做代数一样定义新类型：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I will hold off explaining what **sum** and **product** mean in practice until
    we get to the detailed discussion of tuples (products) and discriminated union
    (sum) types later in this series.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会等到在本系列后面详细讨论元组（乘积）和判别联合（和）类型时，再解释“和”和“积”在实践中是什么意思。
- en: The key point is that an infinite number of new types can be made by combining
    existing types together using these "product" and "sum" methods in various ways.
    Collectively these are called "algebraic data types" or ADTs (not to be confused
    with *abstract data types*, also called ADTs). Algebraic data types can be used
    to model anything, including lists, trees, and other recursive types.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，通过以各种方式使用这些“乘积”和“和”方法组合现有类型，可以制作无限数量的新类型。这些集体称为“代数数据类型”或ADT（不要与*抽象数据类型*混淆，也称为ADT）。代数数据类型可用于模拟任何内容，包括列表、树和其他递归类型。
- en: The sum or "union" types, in particular, are very valuable, and once you get
    used to them, you will find them indispensible!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是和类型或“联合”类型非常有价值，一旦你习惯了它们，你会发现它们是不可或缺的！
- en: How types are defined
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型的定义方式
- en: 'Every type definition is similar, even though the specific details may vary.
    All type definitions start with a "`type`" keyword, followed by an identifier
    for the type, followed by any generic type parameters, followed by the definition.
    For example, here are some type definitions for a variety of types:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型定义都是相似的，尽管具体细节可能有所不同。所有类型定义都以"`type`"关键字开头，后跟类型的标识符，后跟任何泛型类型参数，后跟定义。例如，这里是一些各种类型的类型定义：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we said in a [previous post](function-signatures.html), there is a special
    syntax for defining new types that is different from the normal expression syntax.
    So do be aware of this difference.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[上一篇文章](function-signatures.html)中所说的，定义新类型有一个与常规表达式语法不同的特殊语法。所以要注意这种区别。
- en: Types can *only* be declared in namespaces or modules. But that doesn't mean
    you always have to create them at the top level -- you can create types in nested
    modules if you need to hide them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类型只能在命名空间或模块中声明。但这并不意味着你总是必须在顶层创建它们 - 如果需要隐藏它们，你可以在嵌套模块中创建类型。
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Types *cannot* be declared inside functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类型不能在函数内声明。
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Constructing and deconstructing types
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造和解构类型
- en: After a type is defined, instances of the type are created using a "constructor"
    expression that often looks quite similar to the type definition itself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型后，使用“构造函数”表达式创建类型的实例，这种表达式通常与类型定义本身非常相似。
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What is interesting is that the *same* "constructor" syntax is also used to
    "deconstruct" the type when doing pattern matching:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在进行模式匹配时，*相同的*“构造函数”语法也用于“解构”类型：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you read through this series, pay attention to how the constructors are used
    in both ways.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读本系列时，请注意构造函数在两种方式中的使用。
- en: Field guide to the "type" keyword
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于“type”关键字的实用指南
- en: The same "type" keyword is used to define all the F# types, so they can all
    look very similar if you are new to F#. Here is a quick list of these types and
    how to tell the difference between them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的“type”关键字来定义所有 F# 类型，因此如果你对 F# 还不熟悉，它们看起来都很相似。这里是这些类型的快速列表以及如何区分它们的方法。
- en: '| Type | Example | Distinguishing features |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 示例 | 特点 |'
- en: '| **Abbrev (Alias)** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **缩写（别名）** |'
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| Uses equal sign only. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 只使用等号。 |'
- en: '| **Tuple** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **元组** |'
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Always available to be used and are not explicitly defined with the `type`
    keyword. Usage indicated by comma (with optional parentheses). |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 总是可用且不使用`type`关键字显式定义。使用逗号（可选括号）指示用法。 |'
- en: '| **Record** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **记录** |'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Curly braces. Uses semicolon to separate fields. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 花括号。使用分号分隔字段。 |'
- en: '| **Discriminated Union** |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **判别联合** |'
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| Vertical bar character. Uses "of" for types. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 竖线字符。使用“of”表示类型。 |'
- en: '| **Enum** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **枚举** |'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Similar to Unions, but uses equals and an int value |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 类似于联合，但使用 equals 和一个 int 值 |'
- en: '| **Class** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **类** |'
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| Has function-style parameter list after name for use as constructor. Has
    "member" keyword.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '| 在名称后面有函数风格的参数列表，用作构造函数。具有“member”关键字。'
- en: Has "new" keyword for secondary constructors. |
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 具有“new”关键字用于次要构造函数。 |
- en: '| **Interface** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **接口** |'
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| Same as class but all members are abstract. Abstract members have colon and
    type signature rather than a concrete implementation. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 与类相同，但所有成员都是抽象的。抽象成员具有冒号和类型签名，而不是具体实现。 |'
- en: '| **Struct** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **结构** |'
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| Has "struct" keyword. Uses "val" to define fields.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '| 具有“struct”关键字。使用“val”定义字段。'
- en: Can have constructor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有构造函数。
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Type abbreviations
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型缩写
- en: Type abbreviations
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型缩写
- en: Let's start with the simplest type definition, a type abbreviation or alias.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的类型定义开始，即类型缩写或别名。
- en: 'It has the form:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它的形式为：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where "existing type" can be any type: one of the basic types we have already
    seen, or one of the extended types we will be seeing soon.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其中“现有类型”可以是任何类型：我们已经看过的基本类型之一，或者我们即将看到的扩展类型之一。
- en: 'Some examples:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And so on -- pretty straightforward.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推 -- 非常简单明了。
- en: Type abbreviations are useful to provide documentation and avoid writing a signature
    repeatedly. In the above examples, `ComplexNumber` and `AdditionFunction` demonstrate
    this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类型缩写对于提供文档和避免重复编写签名很有用。在上面的例子中，`ComplexNumber` 和 `AdditionFunction` 就展示了这一点。
- en: Another use is to provide some degree of decoupling between the usage of a type
    and the actual implementation of a type. In the above examples, `ProductCode`
    and `CustomerId` demonstrate this. I could easily change `CustomerId` to be a
    string without changing (most of) my code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用途是在类型的使用和实际实现之间提供一定程度的解耦。在上面的例子中，`ProductCode` 和 `CustomerId` 就展示了这一点。我可以很容易地将
    `CustomerId` 更改为字符串而不需要改变（大部分）我的代码。
- en: 'However, one thing is to note is that this really is just an alias or abbreviation;
    you are not actually creating a new type. So if I define a function that I explicitly
    say is an `AdditionFunction`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的一点是，这实际上只是一个别名或缩写；你并没有真正创建一个新类型。因此，如果我定义一个明确表示为 `AdditionFunction` 的函数：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: the compiler will erase the alias and return a plain `int->int->int` as the
    function signature.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将擦除别名并返回一个普通的 `int->int->int` 作为函数签名。
- en: 'In particular, there is no true encapsulation. I could use an explicit `int`
    anywhere I used a `CustomerId` and the compiler would not complain. And if I had
    attempted to create safe versions of entity ids such as this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，没有真正的封装。我可以在任何地方使用 `CustomerId` 的地方使用显式的 `int`，编译器也不会抱怨。如果我尝试创建类似于这样的实体
    id 的安全版本：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: then I would be disappointed. There would be nothing preventing me from using
    an `OrderId` in place of a `CustomerId` and vice versa. To get true encapsulated
    types like this, we will need to use single case union types, as described in
    a later post.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我会感到失望。没有任何东西阻止我在 `CustomerId` 的位置使用 `OrderId`，反之亦然。要获得真正的封装类型，我们需要使用单例联合类型，如后面的文章中所述。
- en: Tuples
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: We're ready for our first extended type -- the tuple.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好使用我们的第一个扩展类型 -- 元组。
- en: Let's start by stepping back again and looking at a type such as "int". As we
    hinted at before, rather than thinking of "int" as a abstract thing, you can think
    of it as concrete collection of all its possible values, namely the set {...,-3,
    -2, -1, 0, 2, 3, ...}.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次退后一步，看看像“int”这样的类型。正如我们之前暗示的，与其将“int”视为抽象的东西，不如将其视为所有可能值的具体集合，即集合 {...,-3,
    -2, -1, 0, 2, 3, ...}。
- en: 'So next, imagine two copies of this "int" collection. We can "multiply" them
    together by taking the Cartesian product of them; that is, making a new list of
    objects by picking every possible combination of the two "int" lists, as shown
    below:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，想象一下这个“int”集合的两个副本。我们可以通过取它们的笛卡尔积来“相乘”它们；也就是说，通过从这两个“int”列表的每个可能组合中选择，生成一个新的对象列表，如下所示：
- en: '![int*int tuple](tuple_int_int.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![int*int 元组](tuple_int_int.png)'
- en: 'As we have already seen, these pairs are called tuples in F#. And now you can
    see why they have the type signature that they do. In this example, the "int times
    int" type is called "`int * int`", and the star symbol means "multiply" of course!
    The valid instances of this new type are all the pairs: (-2,2),(-1,0), (2,2) and
    so on.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，F# 中将这些对称称为元组。现在你可以看到它们具有的类型签名的原因了。在这个例子中，“int 乘 int” 类型称为 "`int *
    int`"，星号符号当然表示“乘”！这种新类型的有效实例是所有的对：(-2,2)，(-1,0)，(2,2)等等。
- en: 'Let''s see how they might be used in practice:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们可能在实践中如何使用：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now if you evaluate the code above you will see that the types of t1 and t2
    are `int*int` as expected.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你评估上面的代码，你会发现 t1 和 t2 的类型如预期的那样是 `int*int`。
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This "product" approach can be used to make tuples out of any mixture of types.
    Here is one for "int times bool".
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“乘积”方法可以用来将任何混合类型制作成元组。这是一个“int 乘 bool”的示例。
- en: '![int*bool tuple](tuple_int_bool.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![int*bool tuple](tuple_int_bool.png)'
- en: And here is the usage in F#. The tuple type above has the signature "`int*bool`".
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在 F# 中的使用情况。上面的元组类型具有签名 "`int*bool`"。
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Strings can be used as well, of course. The universe of all possible strings
    is very large, but conceptually it is the same thing. The tuple type below has
    the signature "`string*int`".
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以使用字符串。所有可能的字符串的宇宙非常大，但从概念上讲，它是相同的东西。下面的元组类型具有签名 "`string*int`"。
- en: '![string*int tuple](tuple_str_int.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![string*int tuple](tuple_str_int.png)'
- en: 'Test the usage and signatures:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用和签名：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And there is no reason to stop at multiplying just two types together. Why not
    three? Or four? For example, here is the type `int * bool * string`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由只停留在将两种类型相乘。为什么不是三个？或者四个？例如，这是类型 `int * bool * string`。
- en: '![int*bool*string tuple](tuple_int_bool_str.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![int*bool*string tuple](tuple_int_bool_str.png)'
- en: 'Test the usage and signatures:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用和签名：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Generic tuples
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型元组
- en: Generics can be used in tuples too.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型也可以用于元组中。
- en: '![''a*''b tuple](tuple_a_b.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![''a*''b tuple](tuple_a_b.png)'
- en: 'The usage is normally associated with functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通常与函数相关联：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And the function signature is:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名是：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: which means that "`genericTupleFn`" takes a generic tuple `('a * 'b)` and returns
    a `unit`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 "`genericTupleFn`" 接受一个通用元组 `('a * 'b)` 并返回一个 `unit`。
- en: Tuples of complex types
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂类型的元组
- en: 'Any kind of type can be used in a tuple: other tuples, classes, function types,
    etc. Here are some examples:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的类型都可以在元组中使用：其他元组、类、函数类型等。以下是一些示例：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Key points about tuples
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于元组的关键点
- en: 'Some key things to know about tuples are:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 了解元组的一些关键事项：
- en: A particular instance of a tuple type is a *single object*, similar to a two-element
    array in C#, say. When using them with functions they count as a *single* parameter.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组类型的特定实例是一个 *单一对象*，类似于 C# 中的两个元素数组。当与函数一起使用时，它们计为一个 *单一* 参数。
- en: Tuple types cannot be given explicit names. The "name" of the tuple type is
    determined by the combination of types that are multiplied together.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组类型不能被赋予明确的名称。元组类型的“名称”由相乘在一起的类型组合确定。
- en: The order of the multiplication is important. So `int*string` is not the same
    tuple type as `string*int`.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法的顺序很重要。所以 `int*string` 不是与 `string*int` 相同的元组类型。
- en: The comma is the critical symbol that defines tuples, not the parentheses. You
    can define tuples without the parentheses, although it can sometimes be confusing.
    In F#, if you see a comma, it is probably part of a tuple.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逗号是定义元组的关键符号，而不是括号。你可以在没有括号的情况下定义元组，尽管有时会令人困惑。在 F# 中，如果你看到逗号，它可能是元组的一部分。
- en: These points are very important -- if you don't understand them you will get
    confused quite quickly!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点非常重要--如果你不理解它们，你很快就会感到困惑！
- en: 'And it is worth re-iterating the point made in [previous posts](defining-functions.html):
    *don''t mistake tuples for multiple parameters in a function*.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次强调在[以前的帖子](defining-functions.html)中提到的一点：*不要把元组误认为函数中的多个参数*。
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Making and matching tuples
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作和匹配元组
- en: The tuple types in F# are somewhat more primitive than the other extended types.
    As you have seen, you don't need to explicitly define them, and they have no name.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，元组类型比其他扩展类型要原始一些。正如你所见，你不需要明确地定义它们，它们没有名字。
- en: It is easy to make a tuple -- just use a comma!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 制作元组很容易--只需使用逗号！
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And as we have seen, to "deconstruct" a tuple, use the same syntax:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，要“解构”一个元组，使用相同的语法：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When pattern matching like this, you must have the same number of elements,
    otherwise you will get an error:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样模式匹配时，必须具有相同数量的元素，否则会出错：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you don't need some of the values, you can use the "don't care" symbol (the
    underscore) as a placeholder.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要一些值，可以使用“不关心”的符号（下划线）作为占位符。
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you might guess, a two element tuple is commonly called a "pair" and a three
    element tuple is called a "triple" and so on. In the special case of pairs, there
    are functions `fst` and `snd` which extract the first and second element.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，两个元素的元组通常被称为“对”，三个元素的元组称为“三元组”，依此类推。在对的特殊情况下，有`fst`和`snd`函数，分别提取第一个和第二个元素。
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: They only work on pairs. Trying to use `fst` on a triple will give an error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它们仅适用于对。尝试在三元组上使用`fst`将导致错误。
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using tuples in practice
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实践中使用元组
- en: Tuples have a number of advantages over other more complex types. They can be
    used on the fly because they are always available without being defined, and thus
    are perfect for small, temporary, lightweight structures.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 元组比其他更复杂的类型具有许多优点。它们可以在需要时即用即得，因为它们始终可用而无需定义，因此非常适合用于小型、临时的、轻量级的结构。
- en: Using tuples for returning multiple values
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用元组返回多个值
- en: It is a common scenario that you want to return two values from a function rather
    than just one. For example, in the `TryParse` style functions, you want to return
    (a) whether the value was parsed and (b) if parsed, what the parsed value was.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 常见情况是，你希望从函数中返回两个值而不仅仅是一个。例如，在`TryParse`样式函数中，你希望返回（a）值是否已解析和（b）如果已解析，则解析的值是什么。
- en: 'Here is an implementation of `TryParse` for integers (assuming it did not already
    exist, of course):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个整数的`TryParse`实现（当然，假设它之前不存在）：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here''s another simple example that returns a pair of numbers:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个简单的示例，返回一对数字：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating tuples from other tuples
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从其他元组创建元组
- en: As with most F# values, tuples are immutable and the elements within them cannot
    be assigned to. So how do you change a tuple? The short answer is that you can't
    -- you must always create a new one.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 F# 值一样，元组是不可变的，其中的元素不能被赋值。那么你如何改变一个元组呢？简短的答案是你不能 -- 你必须始终创建一个新的元组。
- en: 'Say that you need to write a function that, given a tuple, adds one to each
    element. Here''s an obvious implementation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要编写一个函数，给定一个元组，对每个元素加一。这是一个显而易见的实现：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This seems a bit long winded -- is there a more compact way? Yes, because you
    can deconstruct a tuple directly in the parameters of a function, so that the
    function becomes a one liner:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有点冗长 -- 有没有更紧凑的方法？有，因为你可以直接在函数的参数中解构一个元组，使得函数变成一行：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Equality
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等性
- en: 'Tuples have an automatically defined equality operation: two tuples are equal
    if they have the same length and the values in each slot are equal.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 元组具有自动定义的相等操作：如果两个元组具有相同的长度，并且每个插槽中的值相等，则它们相等。
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Trying to compare tuples of different lengths is a type error:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试比较不同长度的元组是一种类型错误：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the types in each slot must be the same as well:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插槽中的类型也必须相同：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tuples also have an automatically defined hash value based on the values in
    the tuple, so that tuples can be used as dictionary keys without problems.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 元组还具有基于元组中的值自动定义的哈希值，因此可以毫无问题地将元组用作字典键。
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tuple representation
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组表示
- en: And as noted in a [previous post](convenience-types.html), tuples have a nice
    default string representation, and can be serialized easily.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[先前的帖子](convenience-types.html)中指出的，元组具有良好的默认字符串表示形式，并且可以轻松序列化。
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Records
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: Records
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: As we noted in the previous post, plain tuples are useful in many cases. But
    they have some disadvantages too. Because all tuple types are pre-defined, you
    can't distinguish between a pair of floats used for geographic coordinates say,
    vs. a similar tuple used for complex numbers. And when tuples have more than a
    few elements, it is easy to get confused about which element is in which place.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一篇文章中指出的，普通元组在许多情况下都很有用。但它们也有一些缺点。因为所有元组类型都是预定义的，你无法区分用于地理坐标的一对浮点数，例如，与用于复数的类似元组。当元组具有多个元素时，很容易混淆哪个元素在哪个位置。
- en: In these situations, what you would like to do is *label* each slot in the tuple,
    which will both document what each element is for and force a distinction between
    tuples made from the same types.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你想做的是为元组中的每个插槽*标记*，这样既会记录每个元素的用途，又会强制对相同类型的元组进行区分。
- en: Enter the "record" type. A record type is exactly that, a tuple where each element
    is labeled.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 进入“记录”类型。记录类型就是这样一个元组，其中每个元素都带有标签。
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A record type has the standard preamble: `type [typename] =` followed by curly
    braces. Inside the curly braces is a list of `label: type` pairs, separated by
    semicolons (remember, all lists in F# use semicolon separators -- commas are for
    tuples).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '记录类型有标准的前导部分：`type [typename] =`后跟花括号。花括号内是一组`label: type`对，用分号分隔（记住，F#中所有列表都使用分号分隔符
    -- 逗号用于元组）。'
- en: 'Let''s compare the "type syntax" for a record type with a tuple type:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较记录类型和元组类型的"类型语法"：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the record type, there is no "multiplication", just a list of labeled types.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录类型中，没有"乘法"，只有一组带标签的类型。
- en: Relational database theory uses a similar "record type" concept. In the relational
    model, a relation is a (possibly empty) finite set of tuples all having the same
    finite set of attributes. This set of attributes is familiarly referred to as
    the set of column names.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库理论使用类似的"记录类型"概念。在关系模型中，关系是具有相同有限属性集的所有元组的（可能为空的）有限集。这组属性通常被称为列名集。
- en: Making and matching records
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和匹配记录
- en: To create a record value, use a similar format to the type definition, but using
    equals signs after the labels. This is called a "record expression."
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建记录值，使用与类型定义类似的格式，但在标签后使用等号。这被称为"记录表达式"。
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And to "deconstruct" a record, use the same syntax:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要"解构"记录，使用相同的语法：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As always, if you don't need some of the values, you can use the underscore
    as a placeholder; or more cleanly, just leave off the unwanted label altogether.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，如果你不需要某些值，可以使用下划线作为占位符；或者更干净地，直接省略不需要的标签。
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you just need a single property, you can use dot notation rather than pattern
    matching.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要一个属性，可以使用点符号而不是模式匹配。
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that you can leave a label off when deconstructing, but not when constructing:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解构时可以省略一个标签，但构造时不行：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: One of the most noticeable features of record types is use of curly braces.
    Unlike C-style languages, curly braces are rarely used in F# -- only for records,
    sequences, computation expressions (of which sequences are a special case), and
    object expressions (creating implementations of interfaces on the fly). These
    other uses will be discussed later.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型最引人注目的特点之一是使用花括号。与C风格语言不同，F#中很少使用花括号 -- 只用于记录、序列、计算表达式（其中序列是一种特殊情况）和对象表达式（即实时创建接口实现）。这些其他用法将在后面讨论。
- en: Label order
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签顺序
- en: 'Unlike tuples, the order of the labels is not important. So the following two
    values are the same:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组不同，标签的顺序并不重要。因此，以下两个值是相同的：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Naming conflicts
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名冲突
- en: In the examples above, we could construct a record by just using the label names
    "`lat`" and "`long`". Magically, the compiler knew what record type to create.
    (Well, in truth, it was not really that magical, as only one record type had those
    exact labels.)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可以通过仅使用标签名"`lat`"和"`long`"来构建一个记录。神奇的是，编译器知道要创建哪种记录类型。（事实上，并不是真的那么神奇，因为只有一个记录类型具有这些确切的标签。）
- en: 'But what happens if there are two record types with the same labels? How can
    the compiler know which one you mean? The answer is that it can''t -- it will
    use the most recently defined type, and in some cases, issue a warning. Try evaluating
    the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果有两个具有相同标签的记录类型会发生什么？编译器如何知道你指的是哪一个？答案是它不知道 -- 它将使用最近定义的类型，并在某些情况下发出警告。尝试评估以下内容：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'What type is `p`? Answer: `Person2`, which was the last type defined with those
    labels.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`的类型是什么？答案是`Person2`，这是最后一个使用这些标签定义的类型。'
- en: And if you try to deconstruct, you will get a warning about ambiguous field
    labels.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试解构，将会收到关于模糊字段标签的警告。
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How can you fix this? Simply by adding the type name as a qualifier to at least
    one of the labels.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解决这个问题？只需将类型名称作为至少一个标签的限定符即可。
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If needed, you can even add a fully qualified name (with namespace). Here's
    an example using [modules](organizing-functions.html).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，甚至可以添加完全限定的名称（带有命名空间）。以下是使用[模块](organizing-functions.html)的示例。
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Of course, if you can ensure there is only one version in the local namespace,
    you can avoid having to do this at all.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果可以确保本地命名空间中只有一个版本，你可以完全避免这样做。
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The moral of the story is that when defining record types, you should try to
    use unique labels if possible, otherwise you will get ugly code at best, and unexpected
    behavior at worst.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的寓意是，在定义记录类型时，尽量使用唯一的标签，否则最好会得到丑陋的代码，最坏会得到意想不到的行为。
- en: Note that in F#, unlike some other functional languages, two types with exactly
    the same structural definition are not the same type. This is called a "nominal"
    type system, where two types are only equal if they have the same name, as opposed
    to a "structural" type system, where definitions with identical structures will
    be the same type regardless of what they are called.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 F# 中，与其他一些函数式语言不同，具有完全相同结构定义的两种类型并不相同。这被称为“名义”类型系统，其中仅当它们具有相同名称时，两种类型才相等，而不是“结构”类型系统，其中具有相同结构的定义无论被称为什么都是相同类型。
- en: Using records in practice
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实践中使用记录
- en: How can we use records? Let us count the ways...
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用记录？让我们数一数...
- en: Using records for function results
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于函数结果的记录
- en: 'Just like tuples, records are useful for passing back multiple values from
    a function. Let''s revisit the tuple examples described earlier, rewritten to
    use records instead:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就像元组一样，记录对于从函数传递多个值很有用。让我们重新审视之前描述的元组示例，改用记录来编写：
- en: '[PRE55]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can see that having explicit labels in the return value makes it much easier
    to understand (of course, in practice we would probably use an `Option` type,
    discussed later).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，返回值中有明确的标签，这使得理解变得容易得多（当然，在实践中，我们可能会使用稍后讨论的`Option`类型）。
- en: 'And here''s the word and letter count example using records rather than tuples:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用记录而不是元组的单词和字母计数示例：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Creating records from other records
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从其他记录创建记录
- en: Again, as with most F# values, records are immutable and the elements within
    them cannot be assigned to. So how do you change a record? Again the answer is
    that you can't -- you must always create a new one.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，与大多数 F# 值一样，记录是不可变的，其中的元素不能被分配。那么你如何改变一个记录？答案仍然是你不能--你必须始终创建一个新的记录。
- en: 'Say that you need to write a function that, given a `GeoCoord` record, adds
    one to each element. Here it is:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要编写一个函数，给定一个 `GeoCoord` 记录，将每个元素加一。这就是它的样子：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'But again you can simplify by deconstructing directly in the parameters of
    a function, so that the function becomes a one liner:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你也可以通过直接解构函数的参数来简化，这样函数就变成了一行：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'or depending on your taste, you can also use dot notation to get the properties:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 或者根据你的口味，你也可以使用点表示法来获取属性：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In many cases, you just need to tweak one or two fields and leave all the others
    alone. To make life easier, there is a special syntax for this common case, the
    "`with`" keyword. You start with the original value, followed by "with" and then
    the fields you want to change. Here are some examples:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你只需调整一个或两个字段，而不是其他所有字段。为了让生活更轻松，这种常见情况有一个特殊的语法，即“`with`”关键字。你从原始值开始，然后跟着
    "with"，然后是你想要更改的字段。以下是一些示例：
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The technical term for "with" is a copy-and-update record expression.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: “with”的技术术语是复制和更新记录表达式。
- en: Record equality
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录相等性
- en: 'Like tuples, records have an automatically defined equality operation: two
    records are equal if they have the same type and the values in each slot are equal.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 像元组一样，记录有一个自动定义的相等操作：如果两个记录具有相同类型，并且每个插槽中的值相等，则它们相等。
- en: And records also have an automatically defined hash value based on the values
    in the record, so that records can be used as dictionary keys without problems.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 记录还具有基于记录中的值自动生成的哈希值，因此记录可以无问题地用作字典键。
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Record representation
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录表示
- en: As noted in a [previous post](convenience-types.html), records have a nice default
    string representation, and can be serialized easily. But unlike tuples, the `ToString()`
    representation is unhelpful.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[先前的帖子](convenience-types.html)中所述，记录具有很好的默认字符串表示形式，并且可以轻松序列化。但与元组不同，`ToString()`
    表示形式不太有用。
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Sidebar: %A vs. %O in print format strings'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 侧边栏：在打印格式字符串中使用 %A vs. %O
- en: 'We just saw that print format specifiers `%A` and `%O` produce very different
    results for the same record:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，打印格式说明符 `%A` 和 `%O` 对于相同的记录产生非常不同的结果：
- en: '[PRE63]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: So why the difference?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么会有差异呢？
- en: '`%A` prints the value using the same pretty printer that is used for interactive
    output. But `%O` uses `Object.ToString()`, which means that if the `ToString`
    method is not overridden, `%O` will give the default (and generally unhelpful)
    output. So in general, you should try to use `%A` to `%O` where possible, because
    the core F# types do have pretty-printing by default.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`%A` 使用与交互式输出相同的漂亮打印程序打印值。但是 `%O` 使用 `Object.ToString()`，这意味着如果未重写 `ToString`
    方法，`%O` 将给出默认（通常不太有用）的输出。因此，通常情况下，应尽可能使用 `%A` 到 `%O`，因为核心 F# 类型默认具有漂亮打印。'
- en: But note that the F# "class" types do *not* have a standard pretty printed format,
    so `%A` and `%O` are equally uncooperative unless you override `ToString`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，F#“类”类型并*不*具有标准的漂亮打印格式，因此`%A`和`%O`同样不合作，除非您重写`ToString`。
- en: Discriminated Unions
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鉴别联合
- en: Discriminated Unions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鉴别联合
- en: Tuples and records are examples of creating new types by "multiplying" existing
    types together. At the beginning of the series, I mentioned that the other way
    of creating new types was by "summing" existing types. What does this mean?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和记录是通过将现有类型“相乘”而创建新类型的示例。在系列开始时，我提到创建新类型的另一种方式是通过“求和”现有类型。这是什么意思？
- en: 'Well, let''s say that we want to define a function that works with integers
    OR booleans, maybe to convert them into strings. But we want to be strict and
    not accept any other type (such as floats or strings). Here''s a diagram of such
    as function:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，假设我们想要定义一个函数，它可以处理整数或布尔值，也许是将它们转换为字符串。但是我们想要严格一些，不接受任何其他类型（比如浮点数或字符串）。以下是这样一个函数的示意图：
- en: '![function from int union bool](fun_int_union_bool.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![从整数联合布尔值到函数](fun_int_union_bool.png)'
- en: How could we represent the domain of this function?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何表示此函数的定义域？
- en: What we need is a type that represents all possible integers PLUS all possible
    booleans.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种类型，它代表所有可能的整数加上所有可能的布尔值。
- en: '![int union bool](int_union_bool.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![整数联合布尔值](int_union_bool.png)'
- en: In other words, a "sum" type. In this case the new type is the "sum" of the
    integer type plus the boolean type.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，是“和”类型。在这种情况下，新类型是整数类型加布尔类型的“和”。
- en: In F#, a sum type is called a "discriminated union" type. Each component type
    (called a *union case*) must be tagged with a label (called a *case identifier*
    or *tag*) so that they can be told apart ("discriminated"). The labels can be
    any identifier you like, but must start with an uppercase letter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，求和类型称为“鉴别联合”类型。每个组件类型（称为*联合情况*）必须标记有一个标签（称为*情况标识符*或*标签*），以便它们可以被区分开来（“鉴别”）。标签可以是您喜欢的任何标识符，但必须以大写字母开头。
- en: 'Here''s how we might define the type above:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何定义上述类型的方式：
- en: '[PRE64]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The "I" and the "B" are just arbitrary labels; we could have used any other
    labels that were meaningful.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: “I”和“B”只是任意的标签；我们可以使用任何其他有意义的标签。
- en: 'For small types, we can put the definition on one line:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型类型，我们可以将定义放在一行上：
- en: '[PRE65]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The component types can be any other type you like, including tuples, records,
    other union types, and so on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 组件类型可以是您喜欢的任何其他类型，包括元组、记录、其他联合类型等等。
- en: '[PRE66]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can even have types that are recursive, that is, they refer to themselves.
    This is typically how tree structures are defined. Recursive types will be discussed
    in more detail shortly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以拥有递归类型，即它们引用自身。这通常是树结构如何定义的。稍后将更详细地讨论递归类型。
- en: Sum types vs. C++ unions and VB variants
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求和类型与 C++ 的联合和 VB 的变体
- en: At first glance, a sum type might seem similar to a union type in C++ or a variant
    type in Visual Basic, but there is a key difference. The union type in C++ is
    not type-safe and the data stored in the type can be accessed using any of the
    possible tags. An F# discriminated union type is safe, and the data can only be
    accessed one way. It really is helpful to think of it as a sum of two types (as
    shown in the diagram), rather than as just an overlay of data.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，求和类型可能似乎类似于 C++ 中的联合类型或 Visual Basic 中的变体类型，但是有一个关键区别。C++ 中的联合类型不是类型安全的，存储在类型中的数据可以使用任何可能的标签访问。F#
    鉴别联合类型是安全的，数据只能以一种方式访问。将其视为两种类型的总和（如图所示），而不仅仅是数据的覆盖，这确实有助于理解。
- en: Key points about union types
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合类型的关键点
- en: 'Some key things to know about union types are:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 关于联合类型的一些关键事项是：
- en: 'The vertical bar is optional before the first component, so that the following
    definitions are all equivalent, as you can see by examining the output of the
    interactive window:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直线条在第一个组件之前是可选的，因此以下定义都是等效的，您可以通过检查交互式窗口的输出来验证：
- en: '[PRE67]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The tags or labels must start with an uppercase letter. So the following will
    give an error:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签或标签必须以大写字母开头。因此，以下将会报错：
- en: '[PRE68]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Other named types (such as `Person` or `IntOrBool`) must be pre-defined outside
    the union type. You can''t define them "inline" and write something like this:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他命名类型（如`Person`或`IntOrBool`）必须在联合类型之外预先定义。您不能“内联”定义它们并写入类似以下的内容：
- en: '[PRE69]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: or
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE70]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The labels can be any identifier, including the names of the component type
    themselves, which can be quite confusing if you are not expecting it. For example,
    if the `Int32` and `Boolean` types (from the `System` namespace) were used instead,
    and the labels were named the same, we would have this perfectly valid definition:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签可以是任何标识符，包括组件类型本身的名称，如果你没有预料到的话，可能会相当令人困惑。例如，如果使用`System`命名空间中的`Int32`和`Boolean`类型，并且标签被命名为相同，那么我们将有以下完全有效的定义：
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This "duplicate naming" style is actually quite common, because it documents
    exactly what the component types are.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“重复命名”的风格实际上非常常见，因为它准确记录了组件类型是什么。
- en: Constructing a value of a union type
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造联合类型的值
- en: 'To create a value of a union type, you use a "constructor" that refers to only
    one of the possible union cases. The constructor then follows the form of the
    definition, using the case label as if it were a function. In the `IntOrBool`
    example, you would write:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建联合类型的值，您使用一个“构造函数”，该构造函数只引用可能的联合案例中的一个。然后，构造函数遵循定义的形式，使用案例标签就像它是一个函数一样。在`IntOrBool`的例子中，您会写：
- en: '[PRE72]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The resulting value is printed out with the label along with the component
    type:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 结果值与标签一起打印出来以及组件类型：
- en: '[PRE73]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If the case constructor has more than one "parameter", you construct it in
    the same way that you would call a function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果案例构造函数有多个“参数”，则构造方式与调用函数相同：
- en: '[PRE74]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The case constructors for union types are normal functions, so you can use
    them anywhere a function is expected. For example, in `List.map`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型的案例构造函数是普通函数，因此您可以在期望函数的任何位置使用它们。例如，在`List.map`中：
- en: '[PRE75]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Naming conflicts
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名冲突
- en: If a particular case has a unique name, then the type to construct will be unambiguous.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定案例具有唯一名称，则构造的类型将是明确的。
- en: But what happens if you have two types which have cases with the same labels?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果您有两种类型，它们具有相同标签的案例会发生什么？
- en: '[PRE76]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In this case, the last one defined is generally used:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通常使用最后一个定义的：
- en: '[PRE77]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'But it is much better to explicitly qualify the type, as shown:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 但最好明确指定类型，如下所示：
- en: '[PRE78]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And if the types come from different modules, you can use the module name as
    well:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型来自不同的模块，您也可以使用模块名称：
- en: '[PRE79]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Matching on union types
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对联合类型进行匹配
- en: 'For tuples and records, we have seen that "deconstructing" a value uses the
    same model as constructing it. This is also true for union types, but we have
    a complication: which case should we deconstruct?'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对于元组和记录，我们已经看到“解构”值使用与构造它相同的模型。对于联合类型也是如此，但我们有一个复杂的问题：我们应该解构哪个案例？
- en: This is exactly what the "match" expression is designed for. As you should now
    realize, the match expression syntax has parallels to how a union type is defined.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是“匹配”表达式的设计目的。正如您现在应该意识到的那样，匹配表达式语法与联合类型的定义方式有相似之处。
- en: '[PRE80]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let''s analyze what is going on here:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这里发生了什么：
- en: Each "branch" of the overall match expression is a pattern expression that is
    designed to match the corresponding case of the union type.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个总匹配表达式的“分支”都是设计用来匹配联合类型对应案例的模式表达式。
- en: The pattern starts with the tag for the particular case, and then the rest of
    the pattern deconstructs the type for that case in the usual way.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式从特定案例的标签开始，然后模式的其余部分以通常的方式解构该案例的类型。
- en: The pattern is followed by an arrow "->" and then the code to execute.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式后跟一个箭头“->”，然后是要执行的代码。
- en: Empty cases
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空案例
- en: 'The label for a union case does not have to have to have any type after it.
    The following are all valid union types:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 联合案例的标签之后不必有任何类型。以下都是有效的联合类型：
- en: '[PRE81]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If *all* the cases are empty, then we have an "enum style" union:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*所有*案例都是空的，那么我们有一个“枚举样式”的联合：
- en: '[PRE82]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note that this "enum style" union is *not* the same as a true C# enum type,
    discussed later.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种“枚举样式”的联合与真正的C#枚举类型不同，稍后将进行讨论。
- en: 'To create an empty case, just use the label as a constructor without any parameters:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空案例，只需使用标签作为构造函数而不带任何参数：
- en: '[PRE83]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Single cases
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个案例
- en: Sometimes it is useful to create union types with only one case. This might
    be seem useless, because you don't seem to be adding value. But in fact, this
    a very useful practice that can enforce type safety*.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 有时创建只有一个案例的联合类型是有用的。这可能看起来毫无用处，因为似乎没有增加价值。但事实上，这是一个非常有用的实践，可以强制执行类型安全*。
- en: '[* And in a future series we''ll see that, in conjuction with module signatures,
    single case unions can also help with data hiding and capability based security.]'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[* 并且在未来的系列中，我们将看到，与模块签名一起，单个案例的联合类型还可以帮助数据隐藏和基于能力的安全性。]'
- en: For example, let's say that we have customer ids and order ids which are both
    represented by integers, but that they should never be assigned to each other.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有客户id和订单id，它们都由整数表示，但它们永远不应该互相赋值。
- en: 'As we saw before, a type alias approach will not work, because an alias is
    just a synonym and doesn''t create a distinct type. Here''s how you might try
    to do it with aliases:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，类型别名的方法不起作用，因为别名只是一个同义词，不会创建一个不同的类型。这是你可能尝试使用别名的方法：
- en: '[PRE84]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: But even though I explicitly annotated the `orderId` parameter to be of type
    `OrderId`, I can't ensure that customer ids are not accidentally passed in.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使我明确地注释了`orderId`参数为`OrderId`类型，我也无法保证客户端id不会被意外地传递进来。
- en: On the other hand, if we create simple union types, we can easily enforce the
    type distinctions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们创建简单的联合类型，我们可以轻松地强制执行类型区分。
- en: '[PRE85]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This approach is feasible in C# and Java as well, but is rarely used because
    of the overhead of creating and managing the special classes for each type. In
    F# this approach is lightweight and therefore quite common.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在C#和Java中也是可行的，但很少使用，因为为每种类型创建和管理特殊类的开销很大。在F#中，这种方法是轻量级的，因此相当常见。
- en: A convenient thing about single case union types is you can pattern match directly
    against a value without having to use a full `match-with` expression.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 单成员联合类型的一个方便之处是你可以直接对值进行模式匹配，而不必使用完整的`match-with`表达式。
- en: '[PRE86]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: But a common "gotcha" is that in some cases, the pattern match must have parens
    around it, otherwise the compiler will think you are defining a function!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 但一个常见的“坑”是，在某些情况下，模式匹配必须用括号括起来，否则编译器会认为你正在定义一个函数！
- en: '[PRE87]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Similarly, if you ever do need to create an enum-style union type with a single
    case, you will have to start the case with a vertical bar in the type definition;
    otherwise the compiler will think you are creating an alias.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你确实需要创建一个只有一个成员的枚举风格的联合类型，你将不得不在类型定义中的成员前加上一个竖线；否则编译器会认为你正在创建一个别名。
- en: '[PRE88]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Union equality
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合相等性
- en: 'Like other core F# types, union types have an automatically defined equality
    operation: two unions are equal if they have the same type and the same case and
    the values for that case is equal.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他核心的F#类型一样，联合类型有一个自动定义的相等操作：如果两个联合类型具有相同的类型和相同的成员，那么它们是相等的，对于该成员的值是相等的。
- en: '[PRE89]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Union representation
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合表示
- en: Union types have a nice default string representation, and can be serialized
    easily. But unlike tuples, the ToString() representation is unhelpful.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型有一个很好的默认字符串表示，可以很容易地进行序列化。但与元组不同，ToString()表示是没有帮助的。
- en: '[PRE90]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The Option type
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option类型
- en: The Option type
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option类型
- en: Now let's look at a particular union type, the Option type. It is so common
    and so useful that it is actually built into the language.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个特定的联合类型，Option类型。它是如此常见和有用，以至于它实际上是内建于语言中的。
- en: You have already seen the option type discussed in passing, but let's go back
    to basics and understand how it fits into the type system.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在路过中看到了Option类型的讨论，但让我们回到基础，了解它如何适应类型系统。
- en: 'A very common situation is when you want to represent missing or invalid values.
    Using a diagram, the domain would look like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的情况是当你想要表示缺失或无效的值时。使用图表，该域看起来像这样：
- en: '![int option](int_option.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![int option](int_option.png)'
- en: Obviously this calls for some kind of union type!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 显然这需要某种联合类型！
- en: 'In F#, it is called the `Option` type, and is defined as union type with two
    cases: `Some` and `None`. A similar type is common in functional languages: OCaml
    and Scala also call it `Option`, while Haskell calls it `Maybe`.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，它被称为`Option`类型，并被定义为具有两个成员的联合类型：`Some`和`None`。类似的类型在函数式语言中很常见：OCaml和Scala也称之为`Option`，而Haskell称之为`Maybe`。
- en: 'Here is a definition:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个定义：
- en: '[PRE91]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'IMPORTANT: if you evaluate this in the interactive window, be sure to reset
    the session afterwards, so that the built-in type is restored.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：如果你在交互式窗口中评估这个，请务必在之后重置会话，以便恢复内置类型。
- en: 'The option type is used in the same way as any union type in construction,
    by specifying one of the two cases, the `Some` case or the `None` case:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: Option类型的使用方式与构造中的任何联合类型相同，通过指定两种情况之一来实现，即`Some`情况或`None`情况：
- en: '[PRE92]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'and when pattern matching, as with any union type, you must always match all
    the cases:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行模式匹配时，与任何联合类型一样，你必须始终匹配所有的成员：
- en: '[PRE93]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'When defining a type that references the Option type, you must specify the
    generic type to use. You can do this in an explicit way, with angle brackets,
    or use the built-in "`option`" keyword which comes after the type. The following
    examples are identical:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义引用 Option 类型的类型时，必须指定要使用的泛型类型。你可以以显式方式使用尖括号，也可以使用内置的“`option`”关键字，该关键字位于类型之后。以下示例是相同的：
- en: '[PRE94]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Using the Option type
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Option 类型
- en: The option type is widely used in the F# libraries for values that might be
    missing or otherwise invalid.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 选项类型在 F# 库中广泛用于可能丢失或无效的值。
- en: For example, the `List.tryFind` function returns an option, with the `None`
    case used indicate that nothing matches the search predicate.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`List.tryFind`函数返回一个选项，其中`None`用于指示没有匹配搜索谓词的情况。
- en: '[PRE95]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Let''s revisit the same example we used for tuples and records, and see how
    options might be used instead:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下我们用于元组和记录的相同示例，并看看如何改为使用选项：
- en: '[PRE96]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Of these three approaches, the "option" version is generally preferred; no new
    types need to be defined and for simple cases, the meaning of `None` is obvious
    from the context.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种方法中，“选项”版本通常是首选的；不需要定义新类型，对于简单的情况，`None`的含义从上下文中是明显的。
- en: '*NOTE: The `tryParseOption` code is just an example. A similar function `tryParse`
    is built into the .NET core libraries and should be used instead.*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：`tryParseOption`代码只是一个示例。类似的函数`tryParse`内置在.NET核心库中，应该使用它。*'
- en: Option equality
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项的等式
- en: Like other union types, option types have an automatically defined equality
    operation
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他联合类型一样，选项类型有一个自动定义的等式操作。
- en: '[PRE97]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Option representation
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Option 表示
- en: Option types have a nice default string representation, and unlike other union
    types, the `ToString()` representation is also nice.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Option 类型有一个很好的默认字符串表示，与其他联合类型不同，`ToString()`表示也很好。
- en: '[PRE98]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Options are not just for primitive types
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项不仅适用于基本类型
- en: The F# option is a true first class type (it's just a normal union type, after
    all). You can use it with *any* type. For example, you can have an option of a
    complex type like Person, or a tuple type like `int*int`, or a function type like
    `int->bool`, or even an option of an option type.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: F#选项是真正的一流类型（毕竟它只是一个普通的联合类型）。你可以将其与*任何*类型一起使用。例如，你可以有一个复杂类型的选项，比如 Person，或者一个元组类型，比如`int*int`，或者一个函数类型，比如`int->bool`，甚至是一个选项的选项类型。
- en: '[PRE99]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How the Option type should not be used
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Option 类型不应该被使用的方式
- en: The option type has functions such as `IsSome`, `IsNone` and `Value`, which
    allow you to access the "wrapped" value without doing pattern matching. Don't
    use them! Not only it is not idiomatic, but it is dangerous and can cause exceptions.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 选项类型有函数，比如`IsSome`，`IsNone`和`Value`，它们允许你在不进行模式匹配的情况下访问“包装”值。不要使用它们！不仅不符合惯用法，而且很危险，可能会引发异常。
- en: 'Here is how not to do it:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不正确的做法：
- en: '[PRE100]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here is how to do it properly:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的做法：
- en: '[PRE101]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The pattern matching approach also forces you to think about and document what
    happens in the `None` case, which you might easily overlook when using `IsSome`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配方法还会让你思考和记录发生在`None`情况下的情况，当使用`IsSome`时，你可能会轻易忽视这一点。
- en: The Option module
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Option 模块
- en: If you are doing a lot of pattern matching on options, look into the `Option`
    module, as it has some useful helper functions like `map`, `bind`, `iter` and
    so on.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在选项上进行大量模式匹配，请查看`Option`模块，因为它有一些有用的辅助函数，比如`map`，`bind`，`iter`等。
- en: 'For example, say that I want to multiply the value of an option by 2 if it
    is valid. Here''s the pattern matching way:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我想要将选项的值乘以2（如果有效）。这是模式匹配的方式：
- en: '[PRE102]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'And here''s a more compact version written using `Option.map`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Option.map`编写的更紧凑的版本如下：
- en: '[PRE103]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Or perhaps I want to multiply the value of an option by 2 if it is valid but
    return 0 if it is `None`. Here''s the pattern matching way:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我想要将选项的值乘以2（如果有效），但如果它是`None`，则返回0。这是模式匹配的方式：
- en: '[PRE104]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'And here''s the same thing as a one-liner using `Option.fold`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Option.fold`的一行代码示例：
- en: '[PRE105]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In simple cases like the one above, the `defaultArg` function can be used as
    well.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在像上面那样简单的情况下，也可以使用`defaultArg`函数。
- en: '[PRE106]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Option vs. Null vs. Nullable
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Option vs. Null vs. Nullable
- en: The option type often causes confusion to people who are used to dealing with
    nulls and nullables in C# and other languages. This section will try to clarify
    the differences.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于在C#和其他语言中处理空值和可空类型的人们，选项类型经常会引起混淆。本节将尝试澄清其中的区别。
- en: Type safety of Option vs. null
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Option vs. null 的类型安全性
- en: In a language like C# or Java, "null" means a reference or pointer to an object
    that doesn't exist. The "null" has *exactly the same type* as the object, so you
    can't tell from the type system that you have a null.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C# 或 Java 这样的语言中，"null"表示一个指向不存在对象的引用或指针。"null"与对象*完全相同的类型*，因此你无法从类型系统中知道你有一个
    null。
- en: For example, in the C# code below we create two string variables, one with a
    valid string and one with a null string.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的 C# 代码中，我们创建了两个字符串变量，一个带有有效字符串，一个带有空字符串。
- en: '[PRE107]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This compiles perfectly, of course. The compiler cannot tell the difference
    between the two variables. The `null` is exactly the same type as the valid string,
    so all the `System.String` methods and properties can be used on it, including
    the `Length` property.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会完美编译。编译器无法区分这两个变量。`null`与有效字符串完全相同的类型，因此所有`System.String`的方法和属性都可以在其上使用，包括`Length`属性。
- en: Now, we know that this code will fail by just looking at it, but the compiler
    can't help us. Instead, as we all know, you have to tediously test for nulls constantly.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道这段代码只要看一眼就会失败，但编译器却帮不了我们。相反，正如我们都知道的那样，你必须不断地繁琐地测试 null。
- en: Now let's look at the nearest F# equivalent of the C# example above. In F#,
    to indicate missing data, you would use an option type and set it to `None`. (In
    this artificial example we have to use an ugly explicitly typed `None` -- normally
    this would not be necessary.)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看上面 C# 示例的最接近的 F# 等价物。在 F# 中，要表示缺失数据，你会使用一个选项类型并将其设置为`None`。（在这个人工示例中，我们不得不使用一个难看的显式类型的`None`--通常这是不必要的。）
- en: '[PRE108]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In the F# version, we get a *compile-time* error immediately. The `None` is
    *not* a string, it's a different type altogether, so you can't call `Length` on
    it directly. And to be clear, `Some [string]` is *also* not the same type as `string`,
    so you can't call `Length` on it either!
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 版本中，我们立即得到一个*编译时*错误。`None`不是一个字符串，它是完全不同的类型，所以你不能直接调用`Length`。而且要明确，`Some
    [string]`也不是与`string`相同的类型，所以你也不能对其调用`Length`！
- en: So if `Option<string>` is not a string, but you want to do something with the
    string it (might) contain, you are forced to have to pattern match on it (assuming
    you don't do bad things as described earlier).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果`Option<string>`不是一个字符串，但你想对它（可能）包含的字符串做一些事情，你就被迫不得不对它进行模式匹配（假设你不像前面描述的那样做坏事）。
- en: '[PRE109]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: You always have to pattern match, because given a value of type `Option<string>`,
    you can't tell whether it is Some or None.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是必须模式匹配，因为给定类型为`Option<string>`的值，你无法判断它是 Some 还是 None。
- en: In just the same way `Option<int>` is not the same type as `int`, `Option<bool>`
    is not the same type as `bool`, and so on.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Option<int>`不是`int`的相同类型一样，`Option<bool>`也不是`bool`的相同类型，等等。
- en: 'To summarize the critical points:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 总结关键点：
- en: The type "`string option`" is not at all the same type as "`string`". You cannot
    cast from `string option` to `string` -- they do not have the same properties.
    A function that works with `string` will not work with `string option`, and vice
    versa. So the type system will prevent any errors.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型"`string option`"与"`string`"完全不同。你不能从`string option`转换为`string`--它们没有相同的属性。一个使用`string`的函数将无法使用`string
    option`，反之亦然。因此，类型系统将防止任何错误。
- en: On the other hand, a "null string" in C# is exactly the same type as "string".
    You cannot tell them apart at compile time, only at run time. A "null string"
    appears to have all the same properties and functions as a valid string, except
    that your code will blow up when you try to use it!
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，C# 中的"null 字符串"与"string"完全相同的类型。你无法在编译时区分它们，只能在运行时。一个"null 字符串"看起来具有与有效字符串相同的所有属性和函数，除了当你尝试使用它时，你的代码将会崩溃！
- en: Nulls vs. missing data
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nulls vs. 缺失数据
- en: A "null" as used in C# is completely different from the concept of "missing"
    data, which is a valid part of modeling any system in any language.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中使用的"null"与"缺失"数据的概念完全不同，后者是任何语言中模拟系统的一个有效部分。
- en: In a true functional language there can be a concept of missing data, but there
    can be no such thing as "null", because the concepts of "pointers" or "uninitialized
    variables" do not exist in the functional way of thinking.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正的函数式语言中，可能会有缺失数据的概念，但是不可能有"null"这样的东西，因为"指针"或"未初始化变量"的概念在函数式思维方式中是不存在的。
- en: 'For example, consider a value bound to the result of an expression like this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑绑定到此表达式结果的值：
- en: '[PRE110]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How can that value ever be uninitialized, or become null, or even become any
    other value at all?
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 那个值如何能够未初始化，或变为 null，或者甚至变为任何其他值？
- en: Unfortunately, additional confusion has been caused because in some cases API
    designers have used null to indicate the concept of "missing" data as well! For
    example, the .NET library method `StreamReader.ReadLine` returns null to indicate
    that there is no more data in a file.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于在某些情况下 API 设计者使用 null 表示“缺失”数据的概念，因此造成了额外的混淆！例如，.NET 库方法 `StreamReader.ReadLine`
    返回 null 表示文件中没有更多数据。
- en: F# and null
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F# 和 null
- en: F# is not a pure functional language, and has to interact with the .NET languages
    that *do* have the concept of null. Therefore, F# does include a `null` keyword
    in its design, but makes it hard to use and treats it as an abnormal value.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: F# 不是一个纯粹的函数式语言，并且必须与*有*空概念的 .NET 语言进行交互。因此，F# 在设计中包含了一个 `null` 关键字，但是将其用作异常值并且难以使用。
- en: As a general rule, nulls are never created in "pure" F#, but only by interacting
    with the .NET libraries or other external systems.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 通常规则是，在“纯”F#中永远不会创建空值，而只会通过与 .NET 库或其他外部系统进行交互来创建。
- en: 'Here are some examples:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE111]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In these cases, it is good practice to immediately check for nulls and convert
    them into an option type!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，立即检查空值并将其转换为选项类型是很好的实践！
- en: '[PRE112]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: And on occasion, you may need to pass a null to an external library. You can
    do this using the `null` keyword as well.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要向外部库传递一个 null。你也可以使用 `null` 关键字来做到这一点。
- en: Option vs. Nullable
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Option vs. Nullable
- en: In addition to null, C# has the concept of a Nullable type, such as `Nullable<int>`,
    which seems similar to the option type. So what's the difference?
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 null 外，C# 还有 Nullable 类型的概念，比如 `Nullable<int>`，它看起来类似于选项类型。那么有什么区别呢？
- en: The basic idea is the same, but Nullable is much weaker. It only works on value
    types such as `Int` and `DateTime`, not on reference types such as strings or
    classes or functions. You can't nest Nullables, and they don't have much special
    behavior.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是相同的，但 Nullable 要弱得多。它仅适用于值类型，如`Int`和`DateTime`，而不适用于引用类型，如字符串或类或函数。你不能嵌套
    Nullables，并且它们没有太多的特殊行为。
- en: On the other hand, the F# option is a true first class type and can be used
    consistently across all types in the same way. (See the examples above in the
    "Options are not just for primitive types" section.)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，F# 的 option 是一个真正的一级类型，并且可以在相同的方式下一致地在所有类型中使用。（请参见上面“选项不仅适用于原始类型”一节中的示例。）
- en: Enum types
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举类型
- en: Enum types
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举类型
- en: The enum type in F# is the same as the enum type in C#. Its definition is superficially
    just like that of a union type, but there are many non-obvious differences to
    be aware of.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的枚举类型与 C# 中的枚举类型相同。它的定义在表面上就像是联合类型的定义，但是有许多非明显的区别需要注意。
- en: Defining enums
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义枚举
- en: To define an enum you use exactly the same syntax as a union type with empty
    cases, except that you must specify a constant value for each case, and the constants
    must all be of the same type.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义枚举，你使用与空情况的联合类型完全相同的语法，只是必须为每个情况指定一个常量值，并且常量必须都是相同类型的。
- en: '[PRE113]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Strings are not allowed, only ints or compatible types such bytes and chars:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许使用字符串，只允许使用 int 或兼容的类型，如字节和字符：
- en: '[PRE114]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Union types require that their cases start with an uppercase letter. This is
    not required for enums.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型要求它们的情况以大写字母开头。这对枚举不是必需的。
- en: '[PRE115]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Just as with C#, you can use the FlagsAttribute for bit flags:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 C# 中一样，你可以为位标志使用 FlagsAttribute：
- en: '[PRE116]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Constructing enums
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造枚举
- en: 'Unlike union types, to construct an enum you *must always* use a qualified
    name:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 与联合类型不同，要构造枚举，你*必须始终*使用限定名称：
- en: '[PRE117]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You can also cast to and from the underlying int type:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将其转换为基本 int 类型并从中转换：
- en: '[PRE118]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: You can even create values that are not on the enumerated list at all.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以创建根本不在枚举列表中的值。
- en: '[PRE119]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'And, unlike unions, you can use the BCL Enum functions to enumerate and parse
    values, just as with C#. For example:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 与联合类型不同，你可以使用 BCL Enum 函数枚举和解析值，就像在 C# 中一样。例如：
- en: '[PRE120]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Matching enums
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配枚举
- en: 'To match an enum you must again *always* use a qualified name:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配枚举，你必须再次*始终*使用限定名称：
- en: '[PRE121]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Both unions and enums will warn if you have not covered all known cases when
    pattern matching:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式匹配时，如果没有涵盖所有已知情况，联合类型和枚举都会发出警告：
- en: '[PRE122]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: One important difference between unions and enums is that can you make the compiler
    happy about exhaustive pattern matching by listing all the union types.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型和枚举之间的一个重要区别是，通过列出所有联合类型，你可以使编译器满意地进行全面的模式匹配。
- en: 'Not so for enums. It is possible to create an enum not on the predeclared list,
    and try to match with it, and get a runtime exception, so the compiler will warn
    you even if you have explicitly listed all the known enums:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型则不同。可能会创建一个不在预定义列表中的枚举，并尝试匹配它，导致运行时异常，因此即使你明确列出了所有已知的枚举，编译器也会警告你：
- en: '[PRE123]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The only way to fix this is to add a wildcard to the bottom of the cases, to
    handle enums outside the predeclared range.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题的唯一方法是在`cases`的底部添加一个通配符，以处理预定义范围之外的枚举。
- en: '[PRE124]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Summary
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In general, you should prefer discriminated union types over enums, unless you
    really need to have an `int` value associated with them, or you are writing types
    that need to be exposed to other .NET languages.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该优先选择判别联合类型而不是枚举，除非你真的需要将一个`int`值与它们关联，或者你正在编写需要暴露给其他.NET语言的类型。
- en: Built-in .NET types
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置.NET类型
- en: Built-in .NET types
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置.NET类型
- en: In this post we'll take a quick look at how F# handles the [standard types that
    are built into .NET](http://msdn.microsoft.com/en-us/library/hfa3fa08%28VS.80%29.aspx).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将快速了解 F# 如何处理[内置于.NET中的标准类型](http://msdn.microsoft.com/en-us/library/hfa3fa08%28VS.80%29.aspx)。
- en: Literals
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文字
- en: F# uses the same syntax for literals that C# does, with a few exceptions.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: F# 使用与 C# 相同的文字语法，但有一些例外。
- en: 'I''ll divide the built-in types into the following groups:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我将内置类型分为以下几组：
- en: miscellaneous types (`bool`, `char`, etc. )
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种类型（`bool`，`char`等）
- en: string types
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串类型
- en: integer types (`int`, `uint` and `byte`, etc)
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型（`int`，`uint`和`byte`等）
- en: float types (`float`, `decimal`, etc)
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点类型（`float`，`decimal`等）
- en: pointer types (`IntPtr`, etc)
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针类型（`IntPtr`等）
- en: The following tables list the primitive types, with their F# keywords, their
    suffixes if any, an example, and the corresponding .NET CLR type.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了原始类型，包括它们的 F# 关键字，如果有的话，它们的后缀，一个示例，以及相应的.NET CLR类型。
- en: Miscellaneous types
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 各种类型
- en: '|  | Object | Unit | Bool | Char (Unicode) | Char (Ascii) |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '|  | 对象 | 单元 | 布尔 | 字符（Unicode） | 字符（Ascii） |'
- en: '| Keyword | obj | unit | bool | char | byte |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | obj | unit | bool | char | byte |'
- en: '| Suffix |  |  |  |  | B |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| 后缀 |  |  |  |  | B |'
- en: '| Example | let o = obj() | let u = () | true false | ''a'' | ''a''B |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | let o = obj() | let u = () | true false | ''a'' | ''a''B |'
- en: '| .NET Type | Object | (no equivalent) | Boolean | Char | Byte |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| .NET类型 | 对象 | (无等价项) | 布尔 | 字符 | 字节 |'
- en: Object and unit are not really .NET primitive types, but I have included them
    for the sake of completeness.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和单元实际上并不是.NET原始类型，但出于完整性考虑，我已经包含它们。
- en: String types
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串类型
- en: '|  | String (Unicode) | Verbatim string (Unicode) | Triple quoted string (Unicode)
    | String (Ascii) |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '|  | 字符串（Unicode） | 逐字字符串（Unicode） | 三引号字符串（Unicode） | 字符串（Ascii） |'
- en: '| Keyword | string | string | string | byte[] |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | 字符串 | 字符串 | 字符串 | 字节数组 |'
- en: '| Suffix |  |  |  |  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| 后缀 |  |  |  |  |'
- en: '| Example | "first\nsecond line" | @"C:\name" | """can "contain"" special chars"""
    | "aaa"B |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | "第一行\n第二行" | @"C:\name" | """可以包含""特殊字符""" | "aaa"B |'
- en: '| .NET Type | String | String | String | Byte[] |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| .NET类型 | 字符串 | 字符串 | 字符串 | 字节数组 |'
- en: 'The usual special characters can be used inside normal strings, such as `\n`,
    `\t`, `\\`, etc. Quotes must be escaped with a backslash: `\''` and `\"`.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通字符串中可以使用通常的特殊字符，如`\n`，`\t`，`\\`等。引号必须用反斜杠转义：`\'`和`\"`。
- en: In verbatim strings, backslashes are ignored (good for Windows filenames and
    regex patterns). But quotes need to be doubled.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在逐字字符串中，反斜杠会被忽略（适用于Windows文件名和正则表达式模式）。但引号需要加倍。
- en: Triple-quoted strings are new in VS2012\. They are useful because special characters
    do not need to be escaped at all, and so they can handle embedded quotes nicely
    (great for XML).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 三引号字符串在 VS2012 中是新功能。它们非常有用，因为根本不需要转义特殊字符，因此可以很好地处理嵌入的引号（对 XML 非常有用）。
- en: Integer types
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数类型
- en: '|  | 8 bit (Signed) | 8 bit (Unsigned) | 16 bit (Signed) | 16 bit (Unsigned)
    | 32 bit (Signed) | 32 bit (Unsigned) | 64 bit (Signed) | 64 bit (Unsigned) |
    Unlimited precision |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  | 8位（有符号） | 8位（无符号） | 16位（有符号） | 16位（无符号） | 32位（有符号） | 32位（无符号） | 64位（有符号）
    | 64位（无符号） | 无限精度 |'
- en: '| Keyword | sbyte | byte | int16 | uint16 | int | uint32 | int64 | uint64 |
    bigint |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | sbyte | byte | int16 | uint16 | int | uint32 | int64 | uint64 | bigint
    |'
- en: '| Suffix | y | uy | s | us |  | u | L | UL | I |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| 后缀 | y | uy | s | us |  | u | L | UL | I |'
- en: '| Example | 99y | 99uy | 99s | 99us | 99 | 99u | 99L | 99UL | 99I |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 99y | 99uy | 99s | 99us | 99 | 99u | 99L | 99UL | 99I |'
- en: '| .NET Type | SByte | Byte | Int16 | UInt16 | Int32 | UInt32 | Int64 | UInt64
    | BigInteger |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| .NET类型 | SByte | Byte | Int16 | UInt16 | Int32 | UInt32 | Int64 | UInt64
    | BigInteger |'
- en: '`BigInteger` is available in all versions of F#. From .NET 4 it is included
    as part of the .NET base library.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInteger` 在所有版本的 F# 中都可用。从 .NET 4 开始，它作为.NET基础库的一部分包含在内。'
- en: Integer types can also be written in hex and octal.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型也可以用十六进制和八进制表示。
- en: The hex prefix is `0x`. So `0xFF` is hex for 255\.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制前缀是`0x`。所以`0xFF`是255的十六进制表示。
- en: The octal prefix is `0o`. So `0o377` is octal for 255.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八进制前缀是`0o`。所以`0o377`是255的八进制表示。
- en: Floating point types
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点类型
- en: '|  | 32 bit floating point | 64 bit (default) floating point | High precision
    floating point |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|  | 32位浮点 | 64位（默认）浮点 | 高精度浮点 |'
- en: '| Keyword | float32, single | float, double | decimal |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | float32, single | float, double | decimal |'
- en: '| Suffix | f |  | m |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| 后缀 | f |  | m |'
- en: '| Example | 123.456f | 123.456 | 123.456m |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 123.456f | 123.456 | 123.456m |'
- en: '| .NET Type | Single | Double | Decimal |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| .NET 类型 | 单精度 | 双精度 | 十进制 |'
- en: Note that F# natively uses `float` instead of `double`, but both can be used.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，F#本地使用`float`而不是`double`，但两者都可以使用。
- en: Pointer types
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针类型
- en: '|  | Pointer/handle (signed) | Pointer/handle (unsigned) |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '|  | 指针/句柄（有符号） | 指针/句柄（无符号） |'
- en: '| Keyword | nativeint | unativeint |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | nativeint | unativeint |'
- en: '| Suffix | n | un |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| 后缀 | n | un |'
- en: '| Example | 0xFFFFFFFFn | 0xFFFFFFFFun |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 0xFFFFFFFFn | 0xFFFFFFFFun |'
- en: '| .NET Type | IntPtr | UIntPtr |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| .NET 类型 | IntPtr | UIntPtr |'
- en: Casting between built-in primitive types
  id: totrans-561
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置原始类型之间的转换
- en: '*Note: this section only covers casting of primitive types. For casting between
    classes see the series on [object-oriented programming](casting.md).*'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：本节仅涵盖原始类型的转换。有关类之间转换，请参阅[面向对象编程](casting.md)系列文章。*'
- en: There is no direct "cast" syntax in F#, but there are helper functions to cast
    between types. These helper functions have the same name as the type (you can
    see them in the `Microsoft.FSharp.Core` namespace).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中没有直接的“转换”语法，但有助手函数用于在类型之间进行转���。这些辅助函数与类型同名（您可以在`Microsoft.FSharp.Core`命名空间中看到它们）。
- en: 'So for example, in C# you might write:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在C#中，您可能会这样写：
- en: '[PRE125]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In F# the equivalent would be:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，等效的写法是：
- en: '[PRE126]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In F# there are only casting functions for numeric types. In particular, there
    is no cast for bool, and you must use `Convert` or similar.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，只有数值类型的转换函数。特别是，没有bool的转换，您必须使用`Convert`或类似的方法。
- en: '[PRE127]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Boxing and unboxing
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 盒装和拆箱
- en: Just as in C# and other .NET languages, the primitive int and float types are
    value objects, not classes. Although this is normally transparent, there are certain
    occasions where it can be an issue.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在C#和其他.NET语言中一样，原始的int和float类型是值对象，而不是类。虽然这通常是透明的，但在某些情况下可能会出现问题。
- en: First, lets look at the transparent case. In the example below, we define a
    function that takes a parameter of type `Object`, and simply returns it. If we
    pass in an `int`, it is silently boxed into an object, as can be seen from the
    test code, which returns an `object` not an `int`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看透明的情况。在下面的示例中，我们定义了一个函数，该函数接受一个`Object`类型的参数，并简单地返回它。如果我们传入一个`int`，它会被悄悄地装箱成一个对象，可以从测试代码中看到，返回的是一个`object`而不是`int`。
- en: '[PRE128]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The fact that `result` is an object, not an int, can cause type errors if you
    are not careful. For example, the result cannot be directly compared with the
    original value:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`是一个对象而不是int，如果不小心会导致类型错误。例如，结果不能直接与原始值进行比较：'
- en: '[PRE129]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'To work with this situation, and other similar ones, you can convert a primitive
    type to an object directly, by using the `box` keyword:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况以及其他类似情况，您可以直接将原始类型转换为对象，使用`box`关键字：
- en: '[PRE130]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: To convert an object back to an primitive type, use the `unbox` keyword, but
    unlike `box`, you must either supply a specific type to unbox to, or be sure that
    the compiler has enough information to make an accurate type inference.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 要将对象转换回原始类型，请使用`unbox`关键字，但与`box`不同，您必须提供要解除包装的特定类型，或者确保编译器具有足够的信息来进行准确的类型推断。
- en: '[PRE131]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: So the comparison example above could also be done with `unbox`. No explicit
    type annotation is needed because it is being compared with an int.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，上面的比较示例也可以使用`unbox`来完成。不需要显式类型注释，因为它正在与int进行比较。
- en: '[PRE132]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'A common problem occurs if you do not specify enough type information -- you
    will encounter the infamous "Value restriction" error, as shown below:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有指定足够的类型信息，就会遇到臭名昭著的“值限制”错误，如下所示：
- en: '[PRE133]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The solution is to reorder the code to help the type inference, or when all
    else fails, add an explicit type annotation. See [the post on type inference for
    more tips](type-inference.html#troubleshooting-summary).
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是重新排列代码以帮助类型推断，或者在一切都失败时，添加显式类型注释。查看[type inference](type-inference.html#troubleshooting-summary)中关于类型推断的更多提示。
- en: Boxing in combination with type detection
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与类型检测结合的盒装
- en: 'Let''s say that you want to have a function that matches based on the type
    of the parameter, using the `:?` operator:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要根据参数的类型进行匹配的函数，可以使用`:?`运算符：
- en: '[PRE134]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Unfortunately, this code will fail to compile, with the following error:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码将无法编译，出现以下错误：
- en: '[PRE135]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The message tells you the problem: "runtime type tests are not allowed on some
    types".'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 该消息告诉您问题：“一些类型上不允许运行时类型测试”。
- en: 'The answer is to "box" the value which forces it into a reference type, and
    then you can type check it:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是“箱”值，这将其强制转换为引用类型，然后您可以对其进行类型检查：
- en: '[PRE136]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Units of measure
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 度量单位
- en: Units of measure
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 度量单位
- en: As we mentioned [earlier in the "why use F#?" series](correctness-type-checking.html#units-of-measure),
    F# has a very cool feature which allows you to add extra unit-of-measure information
    to as metadata to numeric types.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在“为什么使用F#？”系列中提到的，F#具有一个非常酷的功能，允许您向数字类型添加额外的度量单位信息作为元数据。
- en: The F# compiler will then make sure that only numerics with the same unit-of-measure
    can be combined. This can be very useful to stop accidental mismatches and to
    make your code safer.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，F#编译器将确保只有具有相同度量单位的数字可以组合。 这对于防止意外不匹配并使您的代码更安全非常有用。
- en: Defining units of measure
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义度量单位
- en: 'A unit of measure definition consists of the attribute `[<Measure>]`, followed
    by the `type` keyword and then a name. For example:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 一个度量单位定义由属性`[<Measure>]`组成，后跟`type`关键字，然后是名称。 例如：
- en: '[PRE137]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Often you will see the whole definition written on one line instead:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 通常您会看到整个定义都写在一行上：
- en: '[PRE138]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Once you have a definition, you can associate a measure type with a numeric
    type by using angle brackets with measure name inside:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了一个定义，您可以通过在度量名称内使用尖括号将度量类型与数值类型关联起来：
- en: '[PRE139]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'You can even combine measures within the angle brackets to create compound
    measures:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在尖括号中组合度量以创建复合度量：
- en: '[PRE140]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Derived units of measure
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 派生的度量单位
- en: If you use certain combinations of units a lot, you can define a *derived* measure
    and use that instead.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常使用某些单位的组合，可以定义一个*派生*度量，并改用它。
- en: '[PRE141]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: SI units and constants
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 国际单位制和常数
- en: 'If you are using the units-of-measure for physics or other scientific applications,
    you will definitely want to use the SI units and related constants. You don''t
    need to define all these yourself! These are predefined for you and available
    as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用物理学或其他科学应用的单位，您肯定会想使用国际单位制（SI）单位和相关常数。 您不需要自己定义所有这些！ 这些已经为您预定义，并且可以按如下方式使用：
- en: In F# 3.0 and higher (which shipped with Visual Studio 2012), these are built
    into the core F# libraries in the `Microsoft.FSharp.Data.UnitSystems.SI` namespace
    (see the [MSDN page](http://msdn.microsoft.com/en-us/library/hh289707.aspx)).
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在F# 3.0及更高版本（随Visual Studio 2012一起提供）中，这些功能内置在核心F#库中的`Microsoft.FSharp.Data.UnitSystems.SI`命名空间中（请参阅[MSDN页面](http://msdn.microsoft.com/en-us/library/hh289707.aspx)）。
- en: In F# 2.0 (which shipped with Visual Studio 2010), you will have to install
    the F# powerpack to get them. (The F# powerpack is on Codeplex at [http://fsharppowerpack.codeplex.com](http://fsharppowerpack.codeplex.com)).
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在F# 2.0（随Visual Studio 2010一起提供）中，您必须安装F# powerpack才能获得它们。 （F# powerpack位于Codeplex上的[http://fsharppowerpack.codeplex.com](http://fsharppowerpack.codeplex.com)）。
- en: Type checking and type inference
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型检查和类型推断
- en: The units-of-measure are just like proper types; you get static checking *and*
    type inference.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 度量单位就像合适的类型一样； 您会获得静态检查*和*类型推断。
- en: '[PRE142]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And of course, when using them, the type checking is strict:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当使用它们时，类型检查是严格的：
- en: '[PRE143]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Type annotations
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型注释
- en: If you want to be explicit in specifying a unit-of-measure type annotation,
    you can do so in the usual way. The numeric type must have angle brackets with
    the unit-of-measure.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在指定单位量类型注释时明确，您可以按照通常的方式这样做。 数值类型必须具有带有度量单位的尖括号。
- en: '[PRE144]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Combining units of measure with multiplication and division
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用乘法和除法结合度量单位
- en: The compiler understands how units of measure transform when individual values
    are multiplied or divided.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个值相乘或相除时，编译器了解度量单位如何转换。
- en: For example, in the following, the `speed` value has been automatically given
    the measure `<m/sec>`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下示例中，`speed`值已自动赋予度量`<m/sec>`。
- en: '[PRE145]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Look at the types of the `acceleration` and `force` values above to see other
    examples of how this works.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看上面的`acceleration`和`force`值的类型，以查看此功能的其他示例。
- en: Dimensionless values
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无量纲值
- en: A numeric value without any specific unit of measure is called *dimensionless*.
    If you want to be explicit that a value is dimensionless, you can use the measure
    called `1`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何特定计量单位的数值称为*无量纲*。如果你想明确表示一个值是无量纲的，可以使用称为`1`的度量。
- en: '[PRE146]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Mixing units of measure with dimensionless values
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合计量单位和无量纲值
- en: Note that you cannot *add* a dimensionless value to a value with a unit of measure,
    but you can *multiply or divide* by dimensionless values.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能*将*一个无量纲值加到带有计量单位的值上，但你可以*乘或除*无量纲值。
- en: '[PRE147]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: But see the section on "generics" below for an alternative approach.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请参阅下面关于“通用”部分，了解另一种方法。
- en: Conversion between units
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单位之间的转换
- en: What if you need to convert between units?
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在单位之间进行转换怎么办？
- en: It's straightforward. You first need to define a conversion value that uses
    *both* units, and then multiply the source value by the conversion factor.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。你首先需要定义一个使用*两种*单位的转换值，然后将源数值乘以转换因子。
- en: 'Here''s an example with feet and inches:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个关于英尺和英寸的例子：
- en: '[PRE148]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'And here''s an example with temperature:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个关于温度的例子：
- en: '[PRE149]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The compiler correctly inferred the signature of the conversion function.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器正确地推断了转换函数的签名。
- en: '[PRE150]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Note that the constant `32.0<degF>` was explicitly annotated with the `degF`
    so that the result would be in `degF` as well. If you leave off this annotation,
    the result is a plain float, and the function signature changes to something much
    stranger! Try it and see:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，常数`32.0<degF>`被明确标注为`degF`，以便结果也是`degF`。如果你省略这个注释，结果将是一个普通的浮点数，函数签名会变得更加奇怪！试一试看看：
- en: '[PRE151]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Conversion between dimensionless values and unit-of-measure values
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无量纲值和计量单位值之间的转换
- en: To convert from a dimensionless numeric value to a value with a measure type,
    just multiply it by one, but with the one annotated with the appropriate unit.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 要将无量纲数值转换为带有度量类型的值，只需将其乘以一个，但是这个一个要用适当单位标注的一个。
- en: '[PRE152]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: And to convert the other way, either divide by one, or multiply with the inverse
    unit.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行反向转换，要么除以一个，要么乘以倒数单位。
- en: '[PRE153]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The above methods are type safe, and will cause errors if you try to convert
    the wrong type.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法是类型安全的，如果你尝试转换错误的类型，将会导致错误。
- en: 'If you don''t care about type checking, you can do the conversion with the
    standard casting functions instead:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不关心类型检查，你可以使用标准的强制转换函数进行转换：
- en: '[PRE154]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Generic units of measure
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用计量单位
- en: Often, we want to write functions that will work with any value, no matter what
    unit of measure is associated with it.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望编写的函数能够处理任何值，无论与之关联的计量单位是什么。
- en: For example, here is our old friend `square`. But when we try to use it with
    a unit of measure, we get an error.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是我们的老朋友`square`。但是当我们尝试将其与计量单位一起使用时，我们会得到一个错误。
- en: '[PRE155]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: What can we do? We don't want to specify a particular unit of measure, but on
    the other hand we must specify *something*, because the simple definition above
    doesn't work.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做什么呢？我们不想指定特定的计量单位，但另一方面我们必须指定*某些东西*，因为上面的简单定义不起作用。
- en: The answer is to use *generic* units of measure, indicated with an underscore
    where the measure name normally is.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用*通用*计量单位，用下划线表示通常的度量名称的地方。
- en: '[PRE156]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Now the `square` function works as desired, and you can see that the function
    signature has used the letter `'u` to indicate a generic unit of measure. And
    also note that the compiler has inferred that the return value is of type "unit
    squared".
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`square`函数按预期工作，你可以看到函数签名使用了字母`'u`来表示通用计量单位。还要注意编译器已经推断出返回值的类型为“单位平方”。
- en: '[PRE157]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Indeed, you can specify the generic type using letters as well if you like:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你愿意，你也可以使用字母指定通用类型：
- en: '[PRE158]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'You may need to use letters sometimes to explicitly indicate that the units
    are the same:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要使用字母明确指示单位相同：
- en: '[PRE159]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Using generic measures with lists
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表的通用度量衡
- en: 'You cannot always use a measure directly. For example, you cannot define a
    list of feet directly:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接使用度量衡。例如，你不能直接定义一个英尺列表：
- en: '[PRE160]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Instead, you have to use the "multiply by one" trick mentioned above:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你必须使用上面提到的“乘以一个”的技巧：
- en: '[PRE161]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Using generic measures for constants
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通用度量衡来表示常数
- en: Multiplication by constants is OK (as we saw above), but if you try to do addition,
    you will get an error.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以常数是可以的（正如我们上面看到的），但如果你尝试进行加法，你将会得到一个错误。
- en: '[PRE162]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The fix is to add a generic type to the constant, like this:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 修复的方法是向常数添加一个通用类型，就像这样：
- en: '[PRE163]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: A similar situation occurs when passing in constants to a higher order function
    such as `fold`.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 当将常量传递给高阶函数（例如`fold`）时，会出现类似的情况。
- en: '[PRE164]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Issues with generic measures with functions
  id: totrans-677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数的通用措施时可能会遇到的问题
- en: There are some cases where type inference fails us. For example, let's try to
    create a simple `add1` function that uses units.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，类型推断会失败。例如，让我们尝试创建一个简单的`add1`函数，该函数使用单位。
- en: '[PRE165]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The warning message has the clue. The input parameter `n` has no measure, so
    the measure for `1<_>` will always be ignored. The `add1` function does not have
    a unit of measure so when you try to call it with a value that does have a measure,
    you get an error.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 警告信息中给出了线索。输入参数`n`没有度量，因此`1<_>`的度量将始终被忽略。`add1`函数没有计量单位，因此当您尝试使用具有计量单位的值调用它时，会出现错误。
- en: 'So maybe the solution is to explicitly annotate the measure type, like this:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 所以也许解决方案是明确注释计量单位类型，就像这样：
- en: '[PRE166]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: But no, you get the same warning FS0064 again.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 但不，你又收到了相同的警告 FS0064。
- en: Maybe we can replace the underscore with something more explicit such as `1.0<'u>`?
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 或许我们可以用更明确的内容替换下划线，比如`1.0<'u>'`？
- en: '[PRE167]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: But this time we get a compiler error!
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次我们收到了编译器错误！
- en: 'The answer is to use one of the helpful utility functions in the LanguagePrimitives
    module: `FloatWithMeasure`, `Int32WithMeasure`, etc.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是使用语言原语模块中的一个有用的实用程序函数：`FloatWithMeasure`、`Int32WithMeasure`等等。
- en: '[PRE168]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'And for generic ints, you can use the same approach:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通用整数，您可以使用相同的方法：
- en: '[PRE169]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Using generic measures with type definitions
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类型定义的通用措施
- en: That takes care of functions. What about when we need to use a unit of measure
    in a type definition?
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数已经没问题了。当我们需要在类型定义中使用计量单位时怎么办？
- en: 'Say we want to define a generic coordinate record that works with an unit of
    measure. Let''s start with a naive approach:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想定义一个可以使用计量单位的通用坐标记录。让我们从一个简单的方法开始：
- en: '[PRE170]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'That didn''t work, so what about adding the measure as a type parameter:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不起作用，那么把度量作为类型参数添加进去呢：
- en: '[PRE171]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'That didn''t work either, but the error message tells us what to do. Here is
    the final, correct version, using the `Measure` attribute:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 这也没用，但错误消息告诉我们该怎么做。这是最终的、正确的版本，使用了`Measure`属性：
- en: '[PRE172]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: In some cases, you might need to define more than one measure. In the following
    example, the currency exchange rate is defined as the ratio of two currencies,
    and so needs two generic measures to be defined.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要定义多于一个度量。在以下示例中，货币汇率定义为两种货币的比率，因此需要定义两个通用度量。
- en: '[PRE173]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: And of course, you can mix regular generic types with unit of measure types.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以将常规通用类型与计量单位类型混合使用。
- en: 'For example, a product price might consist of a generic product type, plus
    a price with a currency:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，产品价格可能由通用产品类型加上带有货币的价格组成：
- en: '[PRE174]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Units of measure at runtime
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单位度量在运行时
- en: An issue that you may run into is that units of measure are not part of the
    .NET type system.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的一个问题是，单位度量不是 .NET 类型系统的一部分。
- en: F# does stores extra metadata about them in the assembly, but this metadata
    is only understood by F#.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: F# 在程序集中存储有关它们的额外元数据，但这些元数据只能被 F# 理解。
- en: This means that there is no (easy) way at runtime to determine what unit of
    measure a value has, nor any way to dynamically assign a unit of measure at runtime.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在运行时没有（简单的）方法确定一个值具有什么单位度量，也没有任何动态分配单位度量的方法。
- en: It also means that there is no way to expose units of measure as part of a public
    API to another .NET language (except other F# assemblies).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着没有办法将计量单位作为公共 API 的一部分暴露给另一个 .NET 语言（除了其他 F# 程序集）。
- en: Understanding type inference
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型推断
- en: Understanding type inference
  id: totrans-710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型推断
- en: 'Before we finish with types, let''s revisit type inference: the magic that
    allows the F# compiler to deduce what types are used and where. We have seen this
    happen through all the examples so far, but how does it work and what can you
    do if it goes wrong?'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束类型相关内容之前，让我们重新思考类型推断：这种神奇的功能允许 F# 编译器推断出使用了什么类型以及在何处使用了。到目前为止，我们已经通过所有的示例看到了这种情况，但它是如何工作的，如果出错了该怎么办呢？
- en: How does type inference work?
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断是如何工作的？
- en: It does seem to be magic, but the rules are mostly straightforward. The fundamental
    logic is based on an algorithm often called "Hindley-Milner" or "HM" (more accurately
    it should be called "Damas-Milner's Algorithm W"). If you want to know the details,
    go ahead and Google it.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来确实像是魔法，但规则大多是简单明了的。基本逻辑基于一种通常称为“Hindley-Milner”或“HM”的算法（更准确地说应该称为“Damas-Milner的算法W”）。如果你想了解详情，请继续搜索。
- en: I do recommend that you take some time to understand this algorithm so that
    you can "think like the compiler" and troubleshoot effectively when you need to.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你花点时间来理解这个算法，这样你就可以像编译器一样思考，并在需要时进行有效的故障排除。
- en: 'Here are some of the rules for determine the types of simple and function values:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是确定简单和函数值类型的一些规则：
- en: Look at the literals
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看字面量
- en: Look at the functions and other values something interacts with
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看函数和其他值的交互情况
- en: Look at any explicit type constraints
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看任何显式的类型约束
- en: If there are no constraints anywhere, automatically generalize to generic types
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何地方都没有约束，自动泛化为通用类型
- en: Let's look at each of these in turn.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次看看每一个。
- en: Look at the literals
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看字面量
- en: The literals give the compiler a clue to the context. As we have seen, the type
    checking is very strict; ints and floats are not automatically cast to the other.
    The benefit of this is that the compiler can deduce types by looking at the literals.
    If the literal is an `int` and you are adding "x" to it, then "x" must be an int
    as well. But if the literal is a `float` and you are adding "x" to it, then "x"
    must be a float as well.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量为编译器提供了上下文线索。正如我们所见，类型检查非常严格；整数和浮点数不会自动转换为另一种类型。这样做的好处是编译器可以通过查看字面量来推断类型。如果字面量是一个`int`，而你又在其上加上了"x"，那么"x"也必须是一个int。但是如果字面量是一个`float`，而你又在其上加上了"x"，那么"x"也必须是一个float。
- en: 'Here are some examples. Run them and see their signatures in the interactive
    window:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例。运行它们并在交互窗口中查看它们的签名：
- en: '[PRE175]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Look at the functions and other values it interacts with
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看它所交互的函数和其他值
- en: If there are no literals anywhere, the compiler tries to work out the types
    by analyzing the functions and other values that they interact with. In the cases
    below, the "`indirect`" function calls a function that we do know the types for,
    which gives us the information to deduce the types for the "`indirect`" function
    itself.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何地方都没有字面量，编译器会试图通过分析函数和其他值之间的交互来推断类型。在下面的情况中，“`indirect`”函数调用了一个我们已经知道类型的函数，这给了我们推断“`indirect`”函数本身类型的信息。
- en: '[PRE176]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: And of course assignment counts as an interaction too. If x is a certain type,
    and y is bound (assigned) to x, then y must be the same type as x.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 当然赋值也算作一种交互。如果x是某种类型，而y被绑定（赋值）给x，那么y必须和x是相同的类型。
- en: '[PRE177]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Other interactions might be control structures, or external libraries
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 其他交互可能是控制结构，或者外部库
- en: '[PRE178]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Look at any explicit type constraints or annotations
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看任何显式的类型约束或注释
- en: If there are any explicit type constraints or annotations specified, then the
    compiler will use them. In the case below, we are explicitly telling the compiler
    that "`inferInt2`" takes an `int` parameter. It can then deduce that the return
    value for "`inferInt2`" is also an `int`, which in turn implies that "`inferIndirectInt2`"
    is of type int->int.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何显式的类型约束或注释指定，编译器将使用它们。在下面的例子中，我们明确告诉编译器“`inferInt2`”接受一个`int`参数。然后它可以推断出“`inferInt2`”的返回值也是一个`int`，这又意味着“`inferIndirectInt2`”的类型是int->int。
- en: '[PRE179]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Note that the formatting codes in `printf` statements count as explicit type
    constraints too!
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`printf`语句中的格式化代码也算作显式的类型约束！
- en: '[PRE180]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Automatic generalization
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动泛化
- en: If after all this, there are no constraints found, the compiler just makes the
    types generic.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 如果经过所有这些步骤后，没有找到约束，编译器就会将类型变为泛型。
- en: '[PRE181]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: It works in all directions!
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它可以在各个方向上运作！
- en: The type inference works top-down, bottom-up, front-to-back, back-to-front,
    middle-out, anywhere there is type information, it will be used.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断可以自上而下，自下而上，从前到后，从后到前，从中间到外围，任何有类型信息的地方都会被使用。
- en: Consider the following example. The inner function has a literal, so we know
    that it returns an `int`. And the outer function has been explicitly told that
    it returns a `string`. But what is the type of the passed in "`action`" function
    in the middle?
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的例子。内部函数有一个字面量，所以我们知道它返回一个`int`。而外部函数已经明确告诉它返回一个`string`。但中间传入的“`action`”函数的类型是什么呢？
- en: '[PRE182]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The type inference would work something like this:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断的工作方式大致如下：
- en: '`1` is an `int`'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`是一个`int`'
- en: Therefore `x+1` must be an `int`, therefore `x` must be an `int`
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此`x+1`必须是一个`int`，因此`x`也必须是一个`int`
- en: Therefore `innerFn` must be `int->int`
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此`innerFn`必须是`int->int`
- en: Next, `(innerFn 2)` returns an `int`, therefore "`action`" takes an `int` as
    input.
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，`(innerFn 2)`返回一个`int`，因此“`action`”以一个`int`作为输入。
- en: The output of `action` is the return value for `outerFn`, and therefore the
    output type of `action` is the same as the output type of `outerFn`.
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`的输出是`outerFn`的返回值，因此`action`的输出类型与`outerFn`的输出类型相同。'
- en: The output type of `outerFn` has been explicitly constrained to `string`, therefore
    the output type of `action` is also `string`.
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outerFn`的输出类型已经明确约束为`string`，因此`action`的输出类型也是`string`。'
- en: Putting this together, we now know that the `action` function has signature
    `int->string`
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 综合起来，我们现在知道`action`函数的签名是`int->string`
- en: 'And finally, therefore, the compiler deduces the type of `outerFn` as:'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，因此，编译器推断`outerFn`的类型为：
- en: '[PRE183]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Elementary, my dear Watson!
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ���本的，我亲爱的华生！
- en: The compiler can do deductions worthy of Sherlock Holmes. Here's a tricky example
    that will test how well you have understood everything so far.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以进行像夏洛克·福尔摩斯一样的推断。这是一个棘手的例子，将测试你到目前为止对所有内容的理解程度。
- en: 'Let''s say we have a `doItTwice` function that takes any input function (call
    it "`f`") and generates a new function that simply does the original function
    twice in a row. Here''s the code for it:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`doItTwice`函数，它接受任何输入函数（称之为"`f`"）并生成一个新函数，简单地连续两次执行原始函数。以下是其代码：
- en: '[PRE184]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'As you can see, it composes `f` with itself. So in other words, it means: "do
    f", then "do f" on the result of that.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它将`f`与自身组合。换句话说，它的意思是：“执行f”，然后在该结果上再次执行f。
- en: Now, what could the compiler possibly deduce about the signature of `doItTwice`?
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器可能推断出`doItTwice`的签名是什么？
- en: Well, let's look at the signature of "`f`" first. The output of the first call
    to "`f`" is also the input to the second call to "`f`". So therefore the output
    and input of "`f`" must be the same type. So the signature of `f` must be `'a
    -> 'a`. The type is generic (written as 'a) because we have no other information
    about it.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们先看一下"`f`"的签名。第一次调用"`f`"的输出也是第二次调用"`f`"的输入。因此"`f`"的输出和输入必须是相同类型。所以`f`的签名必须是`'a
    -> 'a`。类型是泛型的（写作'a），因为我们没有其他关于它的信息。
- en: 'So going back to `doItTwice` itself, we now know it takes a function parameter
    of `''a -> ''a`. But what does it return? Well, here''s how we deduce it, step
    by step:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到`doItTwice`本身，我们现在知道它接受一个函数参数`'a -> 'a`。但是它返回什么？好吧，让我们逐步推断：
- en: First, note that `doItTwice` generates a function, so must return a function
    type.
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，注意`doItTwice`生成一个函数，因此必须返回一个函数类型。
- en: The input to the generated function is the same type as the input to first call
    to "`f`"
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成函数的输入与第一次调用"`f`"的输入类型相同
- en: The output of the generated function is the same type as the output of the second
    call to "`f`"
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成函数的输出类型与第二次调用"`f`"的输出类型相同
- en: So the generated function must also have type `'a -> 'a`
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，生成的函数也必须具有类型`'a -> 'a`
- en: Putting it all together, `doItTwice` has a domain of `'a -> 'a` and a range
    of `'a -> 'a`, so therefore its signature must be `('a -> 'a) -> ('a -> 'a)`.
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 综合起来，`doItTwice`的定义域是`'a -> 'a`，值域是`'a -> 'a`，因此其签名必须是`('a -> 'a) -> ('a ->
    'a)`。
- en: Is your head spinning yet? You might want to read it again until it sinks in.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 你的头晕了吗？你可能需要再读一遍，直到理解为止。
- en: Quite a sophisticated deduction for one line of code. Luckily the compiler does
    all this for us. But you will need to understand this kind of thing if you have
    problems and you have to determine what the compiler is doing.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一行代码来说，这是相当复杂的推断。幸运的是，编译器为我们做了所有这些。但是如果你遇到问题并且需要确定编译器在做什么，你就需要理解这种情况。
- en: Let's test it! It's actually much simpler to understand in practice than it
    is in theory.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下！实际上，在实践中比在理论中更容易理解。
- en: '[PRE185]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Hopefully, that makes more sense now.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在更清楚了。
- en: Things that can go wrong with type inference
  id: totrans-772
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断可能出错的情况
- en: 'The type inference isn''t perfect, alas. Sometimes the compiler just doesn''t
    have a clue what to do. Again, understanding what is happening will really help
    you stay calm instead of wanting to kill the compiler. Here are some of the main
    reasons for type errors:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，类型推断并不完美。有时编译器根本不知道该怎么做。再次弄清楚发生了什么将真正帮助你保持冷静，而不是想要杀死编译器。以下是类型错误的主要原因之一：
- en: Declarations out of order
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明顺序错乱
- en: Not enough information
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息不足
- en: Overloaded methods
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载方法
- en: Quirks of generic numeric functions
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型数字函数的怪癖
- en: Declarations out of order
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明顺序错乱
- en: A basic rule is that you must declare functions before they are used.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本规则是必须在使用之前声明函数。
- en: 'This code fails:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码失败了：
- en: '[PRE186]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'But this is ok:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 但这没关系：
- en: '[PRE187]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: And unlike C#, in F# the order of file compilation is important, so do make
    sure the files are being compiled in the right order. (In Visual Studio, you can
    change the order from the context menu).
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#不同，在F#中文件编译的顺序很重要，因此请确保文件按正确顺序编译。（在Visual Studio中，您可以从上下文菜单中更改顺序）。
- en: Recursive or simultaneous declarations
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归或同时声明
- en: A variant of the "out of order" problem occurs with recursive functions or definitions
    that have to refer to each other. No amount of reordering will help in this case
    -- we need to use additional keywords to help the compiler.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数或需要相互引用的定义也会出现“顺序不当”的问题的变体。在这种情况下，无论如何重新排序都无济于事--我们需要使用额外的关键字来帮助编译器。
- en: 'When a function is being compiled, the function identifier is not available
    to the body. So if you define a simple recursive function, you will get a compiler
    error. The fix is to add the "rec" keyword as part of the function definition.
    For example:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被编译时，函数标识符对于函数体是不可用的。因此，如果定义一个简单的递归函数，您将会得到一个编译器错误。解决方法是在函数定义的一部分中添加“rec”关键字。例如：
- en: '[PRE188]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Here''s the fixed version with "rec fib" added to indicate it is recursive:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是添加了“rec fib”以指示其为递归的修正版本：
- en: '[PRE189]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: A similar "`let rec ? and`" syntax is used for two functions that refer to each
    other. Here is a very contrived example that fails if you do not have the "`rec`"
    keyword.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 用于相互引用的两个函数的类似“`let rec ? and`”语法。这里是一个非常牵强的例子，如果没有“`rec`”关键字，它将失败。
- en: '[PRE190]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: The "`and`" keyword can also be used to declare simultaneous types in a similar
    way.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: “`and`”关键字也可以用于以类似方式声明同时类型。
- en: '[PRE191]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Fixed version:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 修正版本：
- en: '[PRE192]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Not enough information
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息不足
- en: Sometimes, the compiler just doesn't have enough information to determine a
    type. In the following example, the compiler doesn't know what type the `Length`
    method is supposed to work on. But it can't make it generic either, so it complains.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，编译器仅仅没有足够的信息来确定一个类型。在下面的例子中，编译器不知道`Length`方法应该作用在什么类型上。但它也不能使其泛型化，因此会报错。
- en: '[PRE193]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: These kinds of error can be fixed with explicit annotations.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这类错误可以通过显式注释来修复。
- en: '[PRE194]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Occasionally there does appear to be enough information, but still the compiler
    doesn't seem to recognize it. For example, it's obvious to a human that the `List.map`
    function (below) is being applied to a list of strings, so why does `x.Length`
    cause an error?
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 有时似乎有足够的信息，但编译器似乎仍然无法识别。例如，对于下面的`List.map`函数，人类很明显知道它被应用于一个字符串列表，那么为什么`x.Length`会导致错误呢？
- en: '[PRE195]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The reason is that the F# compiler is currently a one-pass compiler, and so
    information later in the program is ignored if it hasn't been parsed yet. (The
    F# team have said that it is possible to make the compiler more sophisticated,
    but it would work less well with Intellisense and might produce more unfriendly
    and obscure error messages. So for now, we will have to live with this limitation.)
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是F#编译器目前是一次性编译器，因此如果程序后面的信息尚未被解析，它将被忽略。（F#团队表示可以使编译器更复杂，但这将使Intellisense的效果变差，并可能产生更不友好和晦涩的错误消息。因此，目前我们必须接受这种限制。）
- en: 'So in cases like this, you can always explicitly annotate:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，您总是可以显式注释：
- en: '[PRE196]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: But another, more elegant way that will often fix the problem is to rearrange
    things so the known types come first, and the compiler can digest them before
    it moves to the next clause.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一种更优雅的解决方法通常可以解决问题，即重新排列事物，使已知类型首先出现，编译器可以在移动到下一个子句之前对其进行处理。
- en: '[PRE197]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Functional programmers strive to avoid explicit type annotations, so this makes
    them much happier!
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序员努力避免显式类型注释，因此这让他们感到更加快乐！
- en: This technique can be used more generally in other areas as well; a rule of
    thumb is to try to put the things that have "known types" earlier than things
    that have "unknown types".
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也可以更广泛地应用在其他领域；一个经验法则是尝试将具有“已知类型”的事物放在具有“未知类型”的事物之前。
- en: Overloaded methods
  id: totrans-811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载方法
- en: When calling an external class or method in .NET, you will often get errors
    due to overloading.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中调用外部类或方法时，由于重载，通常会出现错误。
- en: In many cases, such as the concat example below, you will have to explicitly
    annotate the parameters of the external function so that the compiler knows which
    overloaded method to call.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，例如下面的连接示例，您将不得不显式注释外部函数的参数，以便编译器知道调用哪个重载方法。
- en: '[PRE198]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Sometimes the overloaded methods have different argument names, in which case
    you can also give the compiler a clue by naming the arguments. Here is an example
    for the `StreamReader` constructor.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 有时重载的方法具有不同的参数名称，这种情况下，你也可以通过为参数命名来给编译器一个线索。这里是`StreamReader`构造函数的一个示例。
- en: '[PRE199]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Quirks of generic numeric functions
  id: totrans-817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用数值函数的怪癖
- en: 'Numeric functions can be somewhat confusing. There often appear generic, but
    once they are bound to a particular numeric type, they are fixed, and using them
    with a different numeric type will cause an error. The following example demonstrates
    this:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 数值函数可能有些令人困惑。它们通常看起来是通用的，但一旦绑定到特定的数值类型，它们就是固定的，使用不同的数值类型将导致错误。以下示例演示了这一点：
- en: '[PRE200]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: There is a way round this for numeric types using the "inline" keyword and "static
    type parameters". I won't discuss these concepts here, but you can look them up
    in the F# reference at MSDN.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值类型，有一种绕过方法，使用"inline"关键字和"static type parameters"。我不会在这里讨论这些概念，但你可以在MSDN的F#参考资料中查找。
- en: '"Not enough information" troubleshooting summary'
  id: totrans-821
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"信息不足"故障排除摘要'
- en: 'So to summarize, the things that you can do if the compiler is complaining
    about missing types, or not enough information, are:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果编译器抱怨缺少类型或信息不足，你可以做的事情有：
- en: Define things before they are used (this includes making sure the files are
    compiled in the right order)
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用之前定义事物（包括确保文件按正确顺序编译）
- en: Put the things that have "known types" earlier than things that have "unknown
    types". In particular, you might be able reorder pipes and similar chained functions
    so that the typed objects come first.
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将具有"已知类型"的内容放在具有"未知类型"的内容之前。特别是，你可以重新排列管道和类似的链式函数，使得带类型的对象先出现。
- en: Annotate as needed. One common trick is to add annotations until everything
    works, and then take them away one by one until you have the minimum needed. Do
    try to avoid annotating if possible. Not only is it not aesthetically pleasing,
    but it makes the code more brittle. It is a lot easier to change types if there
    are no explicit dependencies on them.
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要添加注释。一个常见的技巧是添加注释直到一切正常运行，然后逐个删除直到只剩下必需的。尽量避免添加注释。不仅不美观，而且会使代码更脆弱。如果没有明确的依赖关系，更容易更改类型。
- en: Debugging type inference issues
  id: totrans-826
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试类型推断问题
- en: Once you have ordered and annotated everything, you will probably still get
    type errors, or find that functions are less generic than expected. With what
    you have learned so far, you should have the tools to determine why this happened
    (although it can still be painful).
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对所有内容进行了排序和注释，你可能仍然会遇到类型错误，或者发现函数不如预期的那么通用。根据你目前学到的知识，你应该有能力确定为什么会发生这种情况（尽管这可能仍然令人痛苦）。
- en: 'For example:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE201]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'In this example, we have a chain of functions. The bottom level function is
    definitely generic, but what about the top level one? Well often, we might expect
    it be generic but instead it is not. In this case we have:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一系列函数。底层函数肯定是通用的，但顶层函数呢？通常，我们可能期望它是通用的，但实际上并不是。在这种情况下，我们有：
- en: '[PRE202]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: What went wrong? The answer is in the midlevel function. The `%s` on z forced
    it be a string, which forced y and then x to be strings too.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 出了什么问题？答案在中间函数中。z上的`%s`强制它成为一个字符串，这导致y和然后x也成为字符串。
- en: 'Now this is a pretty obvious example, but with thousands of lines of code,
    a single line might be buried away that causes an issue. One thing that can help
    is to look at all the signatures; in this case the signatures are:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个非常明显的例子，但是在成千上万行的代码中，可能会有一个导致问题的隐藏行。一个有用的方法是查看所有的签名；在这种情况下，签名是：
- en: '[PRE203]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: When you find a signature that is unexpected you know that it is the guilty
    party. You can then drill down into it and repeat the process until you find the
    problem.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现一个意外的签名时，你知道它是罪魁祸首。然后你可以深入研究并重复这个过程，直到找到问题。
