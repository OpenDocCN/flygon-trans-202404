- en: Chapter 4\. Procedures and Variable Bindings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。过程和变量绑定
- en: 'Procedures and variable bindings are the fundamental building blocks of Scheme
    programs. This chapter describes the small set of syntactic forms whose primary
    purpose is to create procedures and manipulate variable bindings. It begins with
    the two most fundamental building blocks of Scheme programs: variable references
    and `lambda` expressions, and continues with descriptions of the variable binding
    and assignment forms such as `define`, `letrec`, `let-values`, and `set!`.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过程和变量绑定是Scheme程序的基本构建块。本章描述了一小组主要用于创建过程和操作变量绑定的语法形式。它从Scheme程序的两个最基本的构建块开始：变量引用和`lambda`表达式，并继续描述变量绑定和赋值形式，如`define`、`letrec`、`let-values`和`set!`。
- en: Various other forms that bind or assign variables for which the binding or assignment
    is not the primary purpose (such as named `let`) are found in Chapter [5](control.html#g96).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其他各种绑定或赋值变量的形式，其绑定或赋值不是主要目的（如命名的`let`），可在第[5](control.html#g96)章中找到。
- en: Section 4.1\. Variable References
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4.1节。变量引用
- en: '**syntax**: `*variable*`'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`*variable*`'
- en: '**returns:** the value of `*variable*`'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** `*variable*`的值'
- en: Any identifier appearing as an expression in a program is a variable if a visible
    variable binding for the identifier exists, e.g., the identifier appears within
    the scope of a binding created by `define`, `lambda`, `let`, or some other variable-binding
    construct.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中作为表达式出现的任何标识符，如果存在可见的变量绑定，则是一个变量，例如，该标识符出现在由`define`、`lambda`、`let`或其他变量绑定构造创建的绑定的范围内。
- en: '`list ![<graphic>](ch2_0.gif) #<procedure>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`list ![<graphic>](ch2_0.gif) #<procedure>'
- en: (define x 'a)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: (define x 'a)
- en: (list x x) ![<graphic>](ch2_0.gif) (a a)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: (list x x) ![<graphic>](ch2_0.gif) (a a)
- en: (let ([x 'b])
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 'b])
- en: (list x x)) ![<graphic>](ch2_0.gif) (b b)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: (list x x)) ![<graphic>](ch2_0.gif) (b b)
- en: (let ([let 'let]) let) ![<graphic>](ch2_0.gif) let`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([let 'let]) let) ![<graphic>](ch2_0.gif) let`
- en: It is a syntax violation for an identifier reference to appear within a `library`
    form or top-level program if it is not bound as a variable, keyword, record name,
    or other entity. Since the scope of the definitions in a `library`, top-level
    program, `lambda`, or other local body is the entire body, it is not necessary
    for the definition of a variable to appear before its first reference appears,
    as long as the reference is not actually evaluated until the definition has been
    completed. So, for example, the reference to `g` within the definition of `f`
    below
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`library`形式或顶层程序中出现标识符引用，且未绑定为变量、关键字、记录名称或其他实体，则这是语法违例。由于`library`、顶层程序、`lambda`或其他局部主体中定义的范围是整个主体，因此变量的定义不必出现在其第一次引用之前，只要引用在定义完成之前实际上不被评估即可。因此，例如，下面`f`的定义中对`g`的引用
- en: '`(define f'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define f'
- en: (lambda (x)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (g x)))
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: (g x)))
- en: (define g
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (define g
- en: (lambda (x)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (+ x x)))`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x x)))`
- en: is okay, but the reference to `g` in the definition of `q` below is not.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 是可以的，但下面`q`的定义中对`g`的引用则不行。
- en: '`(define q (g 3))'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define q (g 3))'
- en: (define g
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (define g
- en: (lambda (x)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (+ x x)))`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x x)))`
- en: Section 4.2\. Lambda
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4.2节。Lambda
- en: '**syntax**: `(lambda *formals* *body[1]* *body[2]* ...)`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(lambda *formals* *body[1]* *body[2]* ...)`'
- en: '**returns:** a procedure'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个过程'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: The `lambda` syntactic form is used to create procedures. Any operation that
    creates a procedure or establishes local variable bindings is ultimately defined
    in terms of `lambda` or `case-lambda`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`语法形式用于创建过程。任何创建过程或建立局部变量绑定的操作最终都是以`lambda`或`case-lambda`来定义的。'
- en: The variables in `*formals*` are the formal parameters of the procedure, and
    the sequence of subforms `*body[1]* *body[2]* ...` is its body.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`*formals*`中的变量是过程的形式参数，子形式序列`*body[1]* *body[2]* ...`是其主体。'
- en: The body may begin with a sequence of definitions, in which case the bindings
    created by the definitions are local to the body. If definitions are present,
    the keyword bindings are used and discarded while expanding the body, and the
    body is expanded into a `letrec*` expression formed from the variable definitions
    and the remaining expressions, as described on page [292](syntax.html#body-expansion).
    The remainder of this description of `lambda` assumes that this transformation
    has taken place, if necessary, so that the body is a sequence of expressions without
    definitions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正文以一系列定义开始，则由定义创建的绑定仅在正文中局部有效。如果存在定义，则在展开正文时使用并且丢弃关键字绑定，将正文展开为由变量定义和剩余表达式形成的`letrec*`表达式，如[292](syntax.html#body-expansion)页所述。`lambda`的描述的其余部分假定如果需要，已经进行了这种转换，以便正文是一系列不带定义的表达式。
- en: When the procedure is created, the bindings of all variables occurring free
    within the body, excluding the formal parameters, are retained with the procedure.
    Subsequently, whenever the procedure is applied to a sequence of actual parameters,
    the formal parameters are bound to the actual parameters, the retained bindings
    are restored, and the body is evaluated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建过程时，保留在正文中自由出现的所有变量的绑定，不包括形式参数，与该过程一起。随后，每当将过程应用于一系列实际参数时，形式参数绑定到实际参数，恢复保留的绑定，并评估正文。
- en: Upon application, the formal parameters defined by `*formals*` are bound to
    the actual parameters as follows.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用时，由`*formals*`定义的形式参数绑定到实际参数如下。
- en: If `*formals*` is a proper list of variables, e.g., `(x y z)`, each variable
    is bound to the corresponding actual parameter. An exception with condition type
    `&assertion` is raised if too few or too many actual parameters are supplied.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`*formals*`是变量的适当列表，例如`(x y z)`，则每个变量都绑定到相应的实际参数。如果提供的实际参数太少或太多，则引发条件类型为`&assertion`的异常。
- en: If `*formals*` is a single variable (not in a list), e.g., `z`, it is bound
    to a list of the actual parameters.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`*formals*`是单个变量（不在列表中），例如`z`，则它绑定到实际参数的列表。
- en: If `*formals*` is an improper list of variables terminated by a variable, e.g.,
    `(x y . z)`, each variable but the last is bound to the corresponding actual parameter.
    The last variable is bound to a list of the remaining actual parameters. An exception
    with condition type `&assertion` is raised if too few actual parameters are supplied.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`*formals*`是以变量结尾的不规则列表，例如`(x y . z)`，则除最后一个变量外，每个变量都绑定到相应的实际参数。最后一个变量绑定到剩余的实际参数列表。如果提供的实际参数太少，则引发条件类型为`&assertion`的异常。
- en: When the body is evaluated, the expressions in the body are evaluated in sequence,
    and the procedure returns the values of the last expression.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估正文时，按顺序评估正文中的表达式，并且过程返回最后一个表达式的值。
- en: Procedures do not have a printed representation in the usual sense. Scheme systems
    print procedures in different ways; this book uses the notation `#<procedure>`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 过程在通常意义上没有打印表示。 Scheme系统以不同的方式打印过程； 本书使用符号`#<procedure>`。
- en: '`(lambda (x) (+ x 3)) ![<graphic>](ch2_0.gif) #<procedure>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (x) (+ x 3)) ![<graphic>](ch2_0.gif) #<procedure>'
- en: ((lambda (x) (+ x 3)) 7) ![<graphic>](ch2_0.gif) 10
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (x) (+ x 3)) 7) ![<graphic>](ch2_0.gif) 10
- en: ((lambda (x y) (* x (+ x y))) 7 13) ![<graphic>](ch2_0.gif) 140
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (x y) (* x (+ x y))) 7 13) ![<graphic>](ch2_0.gif) 140
- en: ((lambda (f x) (f x x)) + 11) ![<graphic>](ch2_0.gif) 22
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (f x) (f x x)) + 11) ![<graphic>](ch2_0.gif) 22
- en: ((lambda () (+ 3 4))) ![<graphic>](ch2_0.gif) 7
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda () (+ 3 4))) ![<graphic>](ch2_0.gif) 7
- en: ((lambda (x . y) (list x y))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (x . y) (list x y))
- en: 28 37) ![<graphic>](ch2_0.gif) (28 (37))
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 28 37) ![<graphic>](ch2_0.gif) (28 (37))
- en: ((lambda (x . y) (list x y))
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (x . y) (list x y))
- en: 28 37 47 28) ![<graphic>](ch2_0.gif) (28 (37 47 28))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 28 37 47 28) ![<graphic>](ch2_0.gif) (28 (37 47 28))
- en: ((lambda (x y . z) (list x y z))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (x y . z) (list x y z))
- en: 1 2 3 4) ![<graphic>](ch2_0.gif) (1 2 (3 4))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3 4) ![<graphic>](ch2_0.gif) (1 2 (3 4))
- en: ((lambda x x) 7 13) ![<graphic>](ch2_0.gif) (7 13)`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda x x) 7 13) ![<graphic>](ch2_0.gif) (7 13)`
- en: Section 4.3\. Case-Lambda
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4.3节。Case-Lambda
- en: A Scheme `lambda` expression always produces a procedure with a fixed number
    of arguments or with an indefinite number of arguments greater than or equal to
    a certain number. In particular,
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme `lambda`表达式始终生成具有固定数量的参数或具有大于或等于某个数量的不确定数量的参数的过程。 特别地，
- en: '`(lambda (*var[1]* ... *var[n]*) *body[1]* *body[2]* ...)`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (*var[1]* ... *var[n]*) *body[1]* *body[2]* ...)`'
- en: accepts exactly `*n*` arguments,
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接受`*n*`个参数，
- en: '`(lambda *r* *body[1]* *body[2]* ...)`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda *r* *body[1]* *body[2]* ...)`'
- en: accepts zero or more arguments, and
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接受零个或多个参数，并且
- en: '`(lambda (*var[1]* ... *var[n]* . *r*) *body[1]* *body[2]* ...)`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (*var[1]* ... *var[n]* . *r*) *body[1]* *body[2]* ...)`'
- en: accepts `*n*` or more arguments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接受`*n*`个或更多参数。
- en: '`lambda` cannot directly produce, however, a procedure that accepts, say, either
    two or three arguments. In particular, procedures that accept optional arguments
    are not supported directly by `lambda`. The latter form of `lambda` shown above
    can be used, in conjunction with length checks and compositions of `car` and `cdr`,
    to implement procedures with optional arguments, though at the cost of clarity
    and efficiency.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`不能直接生成一个接受两个或三个参数的过程。特别是，接受可选参数的过程不能直接由`lambda`支持。上面显示的后一种`lambda`形式可以与长度检查和`car`和`cdr`的组合一起使用，以实现具有可选参数的过程，尽管这会牺牲清晰度和效率。'
- en: The `case-lambda` syntactic form directly supports procedures with optional
    arguments as well as procedures with fixed or indefinite numbers of arguments.
    `case-lambda` is based on the `lambda*` syntactic form introduced in the article
    "A New Approach to Procedures with Variable Arity" [[11](bibliography.html#g229)].
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`case-lambda`语法形式直接支持具有可选参数以及具有固定或不定数量参数的过程。`case-lambda`基于文章"A New Approach
    to Procedures with Variable Arity" [[11](bibliography.html#g229)]中介绍的`lambda*`语法形式。'
- en: '**syntax**: `(case-lambda *clause* ...)`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(case-lambda *clause* ...)`'
- en: '**returns:** a procedure'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：一个过程'
- en: '**libraries:** `(rnrs control)`, `(rnrs)`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs control)`，`(rnrs)`'
- en: A `case-lambda` expression consists of a set of clauses, each resembling a `lambda`
    expression. Each `*clause*` has the form below.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`case-lambda`表达式由一组类似于`lambda`表达式的子句组成。每个`*clause*`的形式如下。
- en: '`[*formals* *body[1]* *body[2]* ...]`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`[*formals* *body[1]* *body[2]* ...]`'
- en: The formal parameters of a clause are defined by `*formals*` in the same manner
    as for a `lambda` expression. The number of arguments accepted by the procedure
    value of a `case-lambda` expression is determined by the numbers of arguments
    accepted by the individual clauses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 子句的形式参数由`*formals*`以与`lambda`表达式相同的方式定义。`case-lambda`表达式的过程值接受的参数数量由各个子句接受的参数数量确定。
- en: When a procedure created with `case-lambda` is invoked, the clauses are considered
    in order. The first clause that accepts the given number of actual parameters
    is selected, the formal parameters defined by its `*formals*` are bound to the
    corresponding actual parameters, and the body is evaluated as described for `lambda`
    above. If `*formals*` in a clause is a proper list of identifiers, then the clause
    accepts exactly as many actual parameters as there are formal parameters (identifiers)
    in `*formals*`. As with a `lambda` `*formals*`, a `case-lambda` clause `*formals*`
    may be a single identifier, in which case the clause accepts any number of arguments,
    or an improper list of identifiers terminated by an identifier, in which case
    the clause accepts any number of arguments greater than or equal to the number
    of formal parameters excluding the terminating identifier. If no clause accepts
    the number of actual parameters supplied, an exception with condition type `&assertion`
    is raised.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`case-lambda`创建的过程被调用时，子句按顺序考虑。选择接受给定实际参数数量的第一个子句，其由`*formals*`定义的形式参数绑定到相应的实际参数，并且该体按照上述`lambda`的描述进行评估。如果子句中的`*formals*`是标识符的适当列表，则该子句接受与`*formals*`中的形式参数（标识符）数量相同的实际参数。与`lambda`的`*formals*`一样，`case-lambda`子句的`*formals*`可以是单个标识符，此时该子句接受任意数量的参数，或者是由标识符终止的不适当的标识符列表，此时该子句接受大于或等于形式参数数量的参数数量，不包括终止标识符。如果没有子句接受提供的实际参数数量，则会引发一个带有条件类型`&assertion`的异常。
- en: The following definition for `make-list` uses `case-lambda` to support an optional
    fill parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`make-list`定义使用`case-lambda`来支持一个可选的填充参数。
- en: '`(define make-list'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define make-list'
- en: (case-lambda
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: (case-lambda
- en: '[(n) (make-list n #f)]'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[(n) (make-list n #f)]'
- en: '[(n x)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[(n x)'
- en: (do ([n n (- n 1)] [ls '() (cons x ls)])
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([n n (- n 1)] [ls '() (cons x ls)])
- en: ((zero? n) ls))]))`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ((zero? n) ls))]))
- en: 'The `substring` procedure may be extended with `case-lambda` to accept either
    no `*end*` index, in which case it defaults to the end of the string, or no `*start*`
    and `*end*` indices, in which case `substring` is equivalent to `string-copy`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring`过程可以通过`case-lambda`扩展，以接受没有`*end*`索引的情况，此时默认为字符串的末尾，或者没有`*start*`和`*end*`索引的情况，此时`substring`等同于`string-copy`：'
- en: '`(define substring1'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define substring1'
- en: (case-lambda
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (case-lambda
- en: '[(s) (substring1 s 0 (string-length s))]'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[(s) (substring1 s 0 (string-length s))]'
- en: '[(s start) (substring1 s start (string-length s))]'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[(s start) (substring1 s start (string-length s))]'
- en: '[(s start end) (substring s start end)]))`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[(s start end) (substring s start end)]))`'
- en: 'It is also possible to default the `*start*` index rather than the `*end*`
    index when only one index is supplied:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当只提供一个索引时，默认可以将`*start*`索引而不是`*end*`索引设置为默认值：
- en: '`(define substring2'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define substring2'
- en: (case-lambda
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (case-lambda
- en: '[(s) (substring2 s 0 (string-length s))]'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[(s) (substring2 s 0 (string-length s))]'
- en: '[(s end) (substring2 s 0 end)]'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[(s end) (substring2 s 0 end)]'
- en: '[(s start end) (substring s start end)]))`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[(s start end) (substring s start end)]))`'
- en: 'It is even possible to require that both or neither of the `*start*` and `*end*`
    indices be supplied, simply by leaving out the middle clause:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以要求`*start*`和`*end*`索引都提供或都不提供，只需省略中间子句：
- en: '`(define substring3'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define substring3'
- en: (case-lambda
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (case-lambda
- en: '[(s) (substring3 s 0 (string-length s))]'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[(s) (substring3 s 0 (string-length s))]'
- en: '[(s start end) (substring s start end)]))`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[(s start end) (substring s start end)]))`'
- en: Section 4.4\. Local Binding
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4.4节。局部绑定
- en: '**syntax**: `(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: '**returns:** the values of the final body expression'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 最终体表达式的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`let` establishes local variable bindings. Each variable `*var*` is bound to
    the value of the corresponding expression `*expr*`. The body of the `let`, in
    which the variables are bound, is the sequence of subforms `*body[1]* *body[2]* ...`
    and is processed and evaluated like a `lambda` body.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`用于建立局部变量绑定。每个变量`*var*`绑定到相应表达式`*expr*`的值。`let`的体，其中变量绑定，是子形式的序列`*body[1]* *body[2]* ...`，并且像`lambda`体一样被处理和计算。'
- en: The forms `let`, `let*`, `letrec`, and `letrec*` (the others are described after
    `let`) are similar but serve slightly different purposes. With `let`, in contrast
    with `let*`, `letrec`, and `letrec*`, the expressions `*expr* ...` are all outside
    the scope of the variables `*var* ...`. Also, in contrast with `let*` and `letrec*`,
    no ordering is implied for the evaluation of the expressions `*expr* ...`. They
    may be evaluated from left to right, from right to left, or in any other order
    at the discretion of the implementation. Use `let` whenever the values are independent
    of the variables and the order of evaluation is unimportant.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`、`let*`、`letrec`和`letrec*`（其他描述在`let`之后）的形式类似，但用途略有不同。与`let*`、`letrec`和`letrec*`相比，`let`中的表达式`*expr* ...`都不在变量`*var* ...`的作用域内。此外，与`let*`和`letrec*`相比，不暗示表达式`*expr* ...`的评估顺序。它们可以按照任意顺序由实现自行决定从左到右、从右到左或以其他任何顺序进行评估。只有当值与变量无关且评估顺序不重要时才使用`let`。'
- en: '`(let ([x (* 3.0 3.0)] [y (* 4.0 4.0)])'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x (* 3.0 3.0)] [y (* 4.0 4.0)])'
- en: (sqrt (+ x y))) ![<graphic>](ch2_0.gif) 5.0
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (sqrt (+ x y))) ![<graphic>](ch2_0.gif) 5.0
- en: (let ([x 'a] [y '(b c)])
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 'a] [y '(b c)])
- en: (cons x y)) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (cons x y)) ![<graphic>](ch2_0.gif) (a b c)
- en: (let ([x 0] [y 1])
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 0] [y 1])
- en: (let ([x y] [y x])
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x y] [y x])
- en: (list x y))) ![<graphic>](ch2_0.gif) (1 0)`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: (list x y))) ![<graphic>](ch2_0.gif) (1 0)`
- en: The following definition of `let` shows the typical derivation of `let` from
    `lambda`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`的以下定义显示了从`lambda`到`let`的典型推导。'
- en: '`(define-syntax let'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax let'
- en: (syntax-rules ()
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ ((x e) ...) b1 b2 ...)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ((x e) ...) b1 b2 ...)'
- en: ((lambda (x ...) b1 b2 ...) e ...)]))`
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (x ...) b1 b2 ...) e ...)]))`
- en: Another form of `let`, *named* `let`, is described in Section [5.4](control.html#g100),
    and a definition of the full `let` can be found on page [312](syntax.html#defn:let).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种形式的`let`，*命名*为`let`，在第[5.4](control.html#g100)节中描述，并且完整`let`的定义可在第[312](syntax.html#defn:let)页找到。
- en: '**syntax**: `(let* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(let* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: '**returns:** the values of the final body expression'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 最终体表达式的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`let*` is similar to `let` except that the expressions `*expr* ...` are evaluated
    in sequence from left to right, and each of these expressions is within the scope
    of the variables to the left. Use `let*` when there is a linear dependency among
    the values or when the order of evaluation is important.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`let*`类似于`let`，不同之处在于表达式`*expr* ...`按从左到右的顺序依次计算，并且每个表达式都在左侧变量的作用域内。当值之间存在线性依赖或计算顺序重要时，请使用`let*`。'
- en: '`(let* ([x (* 5.0 5.0)]'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let* ([x (* 5.0 5.0)]'
- en: '[y (- x (* 4.0 4.0))])'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[y (- x (* 4.0 4.0))])'
- en: (sqrt y)) ![<graphic>](ch2_0.gif) 3.0
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (sqrt y)) ![<graphic>](ch2_0.gif) 3.0
- en: (let ([x 0] [y 1])
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 0] [y 1])
- en: (let* ([x y] [y x])
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ([x y] [y x])
- en: (list x y))) ![<graphic>](ch2_0.gif) (1 1)`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (list x y))) ![<graphic>](ch2_0.gif) (1 1)`
- en: Any `let*` expression may be converted to a set of nested `let` expressions.
    The following definition of `let*` demonstrates the typical transformation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`let*`表达式都可以转换为一组嵌套的`let`表达式。以下对`let*`的定义展示了典型的转换。
- en: '`(define-syntax let*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax let*'
- en: (syntax-rules ()
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ () e1 e2 ...)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ () e1 e2 ...)'
- en: (let () e1 e2 ...)]
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (let () e1 e2 ...)]
- en: '[(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)'
- en: (let ((x1 v1))
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (let ((x1 v1))
- en: (let* ((x2 v2) ...) e1 e2 ...))]))`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ((x2 v2) ...) e1 e2 ...))]))`
- en: '**syntax**: `(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: '**returns:** the values of the final body expression'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：最终主体表达式的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs base)`，`(rnrs)`'
- en: '`letrec` is similar to `let` and `let*`, except that all of the expressions
    `*expr* ...` are within the scope of all of the variables `*var* ...`. `letrec`
    allows the definition of mutually recursive procedures.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`letrec`类似于`let`和`let*`，不同之处在于所有表达式`*expr* ...`都在所有变量`*var* ...`的作用域内。`letrec`允许定义相互递归的过程。'
- en: '`(letrec ([sum (lambda (x)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ([sum (lambda (x)'
- en: (if (zero? x)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (if (zero? x)
- en: '0'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (+ x (sum (- x 1)))))])
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x (sum (- x 1)))))])
- en: (sum 5)) ![<graphic>](ch2_0.gif) 15`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (sum 5)) ![<graphic>](ch2_0.gif) 15`
- en: The order of evaluation of the expressions `*expr* ...` is unspecified, so a
    program must not evaluate a reference to any of the variables bound by the `letrec`
    expression before all of the values have been computed. (Occurrence of a variable
    within a `lambda` expression does not count as a reference, unless the resulting
    procedure is applied before all of the values have been computed.) If this restriction
    is violated, an exception with condition type `&assertion` is raised.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对表达式`*expr* ...`的评估顺序是未指定的，因此程序在计算所有值之前不能评估`letrec`表达式中绑定的任何变量的引用。 （变量在`lambda`表达式中的出现不算作引用，除非生成的过程在计算所有值之前被应用。）如果违反此限制，将引发带条件类型`&assertion`的异常。
- en: An `*expr*` should not return more than once. That is, it should not return
    both normally and via the invocation of a continuation obtained during its evaluation,
    and it should not return twice via two invocations of such a continuation. Implementations
    are not required to detect a violation of this restriction, but if they do, an
    exception with condition type `&assertion` is raised.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`*expr*`不应该返回多次。也就是说，在其评估过程中，它不应该正常返回和通过调用其获得的延续返回，也不应该通过两次调用这样的延续返回两次。实现不需要检测此限制的违反，但如果检测到，将引发带有条件类型`&assertion`的异常。
- en: Choose `letrec` over `let` or `let*` when there is a circular dependency among
    the variables and their values and when the order of evaluation is unimportant.
    Choose `letrec*` over `letrec` when there is a circular dependency and the bindings
    need to be evaluated from left to right.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量及其值之间存在循环依赖且评估顺序不重要时，选择`letrec`而不是`let`或`let*`。当存在循环依赖并且需要从左到右评估绑定时，选择`letrec*`而不是`letrec`。
- en: A `letrec` expression of the form
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`letrec`表达式的形式'
- en: '`(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: may be expressed in terms of `let` and `set!` as
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用`let`和`set!`来表达
- en: '`(let ((*var* #f) ...)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ((*var* #f) ...)'
- en: (let ((*temp* *expr*) ...)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: (let ((*temp* *expr*) ...)
- en: (set! *var* *temp*) ...
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: (set! *var* *temp*) ...
- en: (let () *body[1]* *body[2]* ...)))`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: (let () *body[1]* *body[2]* ...)))`
- en: where `*temp* ...` are fresh variables, i.e., ones that do not already appear
    in the `letrec` expression, one for each `(*var* *expr*)` pair. The outer `let`
    expression establishes the variable bindings. The initial value given each variable
    is unimportant, so any value suffices in place of `#f`. The bindings are established
    first so that `*expr* ...` may contain occurrences of the variables, i.e., so
    that the expressions are computed within the scope of the variables. The middle
    `let` evaluates the values and binds them to the temporary variables, and the
    `set!` expressions assign each variable to the corresponding value. The inner
    `let` is present in case the body contains internal definitions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`*temp* ...`是新变量，即在`letrec`表达式中尚未出现的变量，每个`(*var* *expr*)`对应一个变量。外部`let`表达式建立变量绑定。每个变量的初始值并不重要，因此在`#f`的位置上任何值都可以。首先建立绑定，以便`*expr* ...`可以包含变量的出现，即在变量的作用域内计算表达式。中间的`let`评估值并将其绑定到临时变量，`set!`表达式将每个变量分配给相应的值。内部的`let`存在是为了防止主体包含内部定义。
- en: A definition of `letrec` that uses this transformation is shown on page [310](syntax.html#defn:letrec).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种转换的`letrec`的定义在第[310](syntax.html#defn:letrec)页上显示。
- en: This transformation does not enforce the restriction that the `*expr*` expressions
    must not evaluate any references of or assignments to the variables. More elaborate
    transformations that enforce this restriction and actually produce more efficient
    code are possible [[31](bibliography.html#g249)].
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此转换不强制`*expr*`表达式不能评估任何对变量的引用或赋值的限制。可以进行更复杂的转换，以强制执行此限制并实际生成更有效的代码 [[31](bibliography.html#g249)]。
- en: '**syntax**: `(letrec* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(letrec* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: '**returns:** the values of the final body expression'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值:** 最终body表达式的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`，`(rnrs)`'
- en: '`letrec*` is similar to `letrec`, except that `letrec*` evaluates `*expr* ...`
    in sequence from left to right. While programs must still not evaluate a reference
    to any `*var*` before the corresponding `*expr*` has been evaluated, references
    to `*var*` may be evaluated any time thereafter, including during the evaluation
    of the `*expr*` of any subsequent binding.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`letrec*`类似于`letrec`，不同之处在于`letrec*`按从左到右的顺序评估`*expr* ...`。虽然程序仍然不能在相应的`*expr*`被评估之前评估对任何`*var*`的引用，但对`*var*`的引用可以在此后的任何时间评估，包括在任何后续绑定的`*expr*`的评估过程中。'
- en: A `letrec*` expression of the form
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个形式为`letrec*`的表达式
- en: '`(letrec* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: may be expressed in terms of `let` and `set!` as
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用`let`和`set!`来表达
- en: '`(let ((*var* #f) ...)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ((*var* #f) ...)'
- en: (set! *var* *expr*) ...
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (set! *var* *expr*) ...
- en: (let () *body[1]* *body[2]* ...))`
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (let () *body[1]* *body[2]* ...))`
- en: The outer `let` expression creates the bindings, each assignment evaluates an
    expression and immediately sets the corresponding variable to its value, in sequence,
    and the inner let evaluates the body. `let` is used in the latter case rather
    than `begin` since the body may include internal definitions as well as expressions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 外部的`let`表达式创建了绑定，每个赋值都评估一个表达式并立即将相应的变量设置为其值，按顺序进行，内部的let评估body。在后一种情况下使用`let`而不是`begin`，因为body可能包括内部定义以及表达式。
- en: '`(letrec* ([sum (lambda (x)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec* ([sum (lambda (x)'
- en: (if (zero? x)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (if (zero? x)
- en: '0'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (+ x (sum (- x 1)))))]
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x (sum (- x 1)))))]
- en: '[f (lambda () (cons n n-sum))]'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[f (lambda () (cons n n-sum))]'
- en: '[n 15]'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[n 15]'
- en: '[n-sum (sum n)])'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[n-sum (sum n)])'
- en: (f)) ![<graphic>](ch2_0.gif) (15 . 120)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (f)) ![<graphic>](ch2_0.gif) (15 . 120)
- en: (letrec* ([f (lambda () (lambda () g))]
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (letrec* ([f (λ () (λ () g))]
- en: '[g (f)])'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[g (f)]'
- en: (eq? (g) g)) ![<graphic>](ch2_0.gif) #t
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (eq? (g) g)) ![<graphic>](ch2_0.gif) #t
- en: (letrec* ([g (f)]
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (letrec* ([g (λ () (λ () g))]
- en: '[f (lambda () (lambda () g))])'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[f (lambda () (lambda () g))])'
- en: (eq? (g) g)) ![<graphic>](ch2_0.gif) *exception: attempt to reference undefined variable f*`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (eq? (g) g)) ![<graphic>](ch2_0.gif) *异常：尝试引用未定义的变量f*`
- en: Section 4.5\. Multiple Values
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4.5节。多值
- en: '**syntax**: `(let-values ((*formals* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(let-values ((*formals* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: '**syntax**: `(let*-values ((*formals* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(let*-values ((*formals* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: '**returns:** the values of the final body expression'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值:** 最终body表达式的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`，`(rnrs)`'
- en: '`let-values` is a convenient way to receive multiple values and bind them to
    variables. It is structured like `let` but permits an arbitrary formals list (like
    `lambda`) on each left-hand side. `let*-values` is similar but performs the bindings
    in left-to-right order, as with `let*`. An exception with condition type `&assertion`
    is raised if the number of values returned by an `*expr*` is not appropriate for
    the corresponding `*formals*`, as described in the entry for `lambda` above. A
    definition of `let-values` is given on page [310](syntax.html#fullletvalues).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`let-values`是接收多个值并将它们绑定到变量的便捷方式。它的结构类似于`let`，但允许在每个左侧都有一个任意的形式列表（类似于`lambda`）。`let*-values`类似，但按从左到右的顺序执行绑定，就像`let*`一样。如果由`*expr*`返回的值的数量不适合相应的`*formals*`，则会引发带有条件类型`&assertion`的异常，如上面`lambda`条目中所述。`let-values`的定义在第[310](syntax.html#fullletvalues)页上给出。'
- en: '`(let-values ([(a b) (values 1 2)] [c (values 1 2 3)])'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let-values ([(a b) (values 1 2)] [c (值 1 2 3)])'
- en: (list a b c)) ![<graphic>](ch2_0.gif) (1 2 (1 2 3))
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (list a b c)) ![<graphic>](ch2_0.gif) (1 2 (1 2 3))
- en: (let*-values ([(a b) (values 1 2)] [(a b) (values b a)])
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (let*-values ([(a b) (values 1 2)] [(a b) (values b a)])
- en: (list a b)) ![<graphic>](ch2_0.gif) (2 1)`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: (list a b)) ![<graphic>](ch2_0.gif) (2 1)`
- en: Section 4.6\. Variable Definitions
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4.6节。变量定义
- en: '**syntax**: `(define *var* *expr*)`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(define *var* *expr*)`'
- en: '**syntax**: `(define *var*)`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(define *var*)`'
- en: '**syntax**: `(define (*var[0]* *var[1]* ...) *body[1]* *body[2]* ...)`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(define (*var[0]* *var[1]* ...) *body[1]* *body[2]* ...)`'
- en: '**syntax**: `(define (*var[0]* . *var[r]*) *body[1]* *body[2]* ...)`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(define (*var[0]* . *var[r]*) *body[1]* *body[2]* ...)`'
- en: '**syntax**: `(define (*var[0]* *var[1]* *var[2]* ... . *var[r]*) *body[1]* *body[2]* ...)`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(define (*var[0]* *var[1]* *var[2]* ... . *var[r]*) *body[1]* *body[2]* ...)`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs base)`，`(rnrs)`'
- en: In the first form, `define` creates a new binding of `*var*` to the value of
    `*expr*`. The `*expr*` should not return more than once. That is, it should not
    return both normally and via the invocation of a continuation obtained during
    its evaluation, and it should not return twice via two invocations of such a continuation.
    Implementations are not required to detect a violation of this restriction, but
    if they do, an exception with condition type `&assertion` is raised.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种形式中，`define`创建一个新的将`*var*`绑定到`*expr*`值的绑定。`*expr*`不应返回多次。也就是说，在其评估期间，它不应正常返回并通过调用期间获得的延续调用两次而正常返回。实现不需要检测此限制的违反，但如果检测到，则引发具有条件类型`&assertion`的异常。
- en: The second form is equivalent to `(define *var* *unspecified*)`, where `*unspecified*`
    is some unspecified value. The remaining are shorthand forms for binding variables
    to procedures; they are identical to the following definition in terms of `lambda`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式等同于`(define *var* *unspecified*)`，其中`*unspecified*`是某个未指定的值。其余的是将变量绑定到过程的速记形式；它们与`lambda`中的以下定义相同。
- en: '`(define *var*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define *var*'
- en: (lambda *formals*
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda *formals*
- en: '*body[1]* *body[2]* ...))`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*body[1]* *body[2]* ...))`'
- en: where `*formals*` is `(*var[1]* ...)`, `*var[r]*`, or `(*var[1]* *var[2]* ... . *var[r]*)`
    for the third, fourth, and fifth `define` formats.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`*formals*`为`(*var[1]* ...)`，`*var[r]*`或第三个，第四个和第五个`define`格式的`(*var[1]* *var[2]* ... . *var[r]*)`。
- en: Definitions may appear at the front of a `library` body, anywhere among the
    forms of a top-level-program body, and at the front of a `lambda` or `case-lambda`
    body or the body of any form derived from `lambda`, e.g., `let`, or `letrec*`.
    Any body that begins with a sequence of definitions is transformed during macro
    expansion into a `letrec*` expression as described on page [292](syntax.html#body-expansion).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定义可以出现在`library`主体的前面，在顶级程序主体的任何形式之间的任何位置，以及在`lambda`或`case-lambda`主体或任何形式的主体中，例如`lambda`，`let`或`letrec*`的派生主体。以一系列定义开始的任何主体在宏扩展期间转换为`letrec*`表达式，如第[292](syntax.html#body-expansion)页所述。
- en: Syntax definitions may appear along with variable definitions wherever variable
    definitions may appear; see Chapter [8](syntax.html#g133).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 语法定义可以与变量定义一起出现，无论变量定义何时出现；参见第[8](syntax.html#g133)章。
- en: '`(define x 3)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define x 3)'
- en: x ![<graphic>](ch2_0.gif) 3
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: x ![<graphic>](ch2_0.gif) 3
- en: (define f
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (define f
- en: (lambda (x y)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (* (+ x y) 2)))
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: (* (+ x y) 2)))
- en: (f 5 4) ![<graphic>](ch2_0.gif) 18
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: (f 5 4) ![<graphic>](ch2_0.gif) 18
- en: (define (sum-of-squares x y)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: (define (sum-of-squares x y)
- en: (+ (* x x) (* y y)))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (* x x) (* y y)))
- en: (sum-of-squares 3 4) ![<graphic>](ch2_0.gif) 25
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: (sum-of-squares 3 4) ![<graphic>](ch2_0.gif) 25
- en: (define f
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: (define f
- en: (lambda (x)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (+ x 1)))
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x 1)))
- en: (let ([x 2])
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 2])
- en: (define f
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: (define f
- en: (lambda (y)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (y)
- en: (+ y x)))
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: (+ y x)))
- en: (f 3)) ![<graphic>](ch2_0.gif) 5
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (f 3)) ![<graphic>](ch2_0.gif) 5
- en: (f 3) ![<graphic>](ch2_0.gif) 4`
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (f 3) ![<graphic>](ch2_0.gif) 4`
- en: A set of definitions may be grouped by enclosing them in a `begin` form. Definitions
    grouped in this manner may appear wherever ordinary variable and syntax definitions
    may appear. They are treated as if written separately, i.e., without the enclosing
    `begin` form. This feature allows syntactic extensions to expand into groups of
    definitions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一组定义可以通过将它们封装在`begin`形式中来分组。以这种方式分组的定义可以出现在普通变量和语法定义可以出现的任何地方。它们被视为分开编写，即不带有封装的`begin`形式。此功能允许语法扩展扩展为定义组。
- en: '`(define-syntax multi-define-syntax'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax multi-define-syntax'
- en: (syntax-rules ()
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ (var expr) ...)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (var expr) ...)'
- en: (begin
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (define-syntax var expr)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax var expr)
- en: '...)]))'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '...)]))'
- en: (let ()
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: (let ()
- en: (define plus
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: (define plus
- en: (lambda (x y)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (if (zero? x)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (if (zero? x)
- en: y
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: (plus (sub1 x) (add1 y)))))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: (plus (sub1 x) (add1 y)))))
- en: (multi-define-syntax
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: (multi-define-syntax
- en: (add1 (syntax-rules () [(_ e) (+ e 1)]))
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: (add1 (syntax-rules () [(_ e) (+ e 1)]))
- en: (sub1 (syntax-rules () [(_ e) (- e 1)])))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: (sub1 (syntax-rules () [(_ e) (- e 1)])))
- en: (plus 7 8)) ![<graphic>](ch2_0.gif) 15`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (plus 7 8)) ![<graphic>](ch2_0.gif) 15`
- en: Many implementations support an interactive "top level" in which variable and
    other definitions may be entered interactively or loaded from files. The behavior
    of these top-level definitions is outside the scope of the Revised⁶ Report, but
    as long as top-level variables are defined before any references or assignments
    to them are evaluated, the behavior is consistent across most implementations.
    So, for example, the reference to `g` in the top-level definition of `f` below
    is okay if `*g*` is not already defined, and `g` is assumed to name a variable
    to be defined at some later point.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实现支持交互式的“顶层”，其中变量和其他定义可以交互输入或从文件加载。这些顶层定义的行为超出了修订⁶报告的范围，但只要在评估任何引用或分配之前定义顶层变量，大多数实现的行为是一致的。因此，例如，下面
    `f` 的顶层定义中对 `g` 的引用是可以的，如果 `*g*` 尚未定义，并且假定 `g` 是一个稍后要定义的变量。
- en: '`(define f'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define f'
- en: (lambda (x)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (g x)))`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (g x)))`
- en: If this is then followed by a definition of `g` before `f` is evaluated, the
    assumption that `g` would be defined as a variable is proven correct, and a call
    to `f` works as expected.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果随后在评估 `f` 之前定义了 `g`，则假设 `g` 将被定义为一个变量的假设是正确的，并且对 `f` 的调用按预期工作。
- en: '`(define g'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define g'
- en: (lambda (x)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (+ x x)))
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x x)))
- en: (f 3) ![<graphic>](ch2_0.gif) 6`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: (f 3) ![<graphic>](ch2_0.gif) 6`
- en: If `g` were defined instead as the keyword for a syntactic extension, the assumption
    that `g` would be bound as a variable is proven false, and if `f` is not redefined
    before it is invoked, the implementation is likely to raise an exception.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `g` 被定义为语法扩展的关键字，那么假设 `g` 会被绑定为一个变量是错误的，如果在调用之前 `f` 没有被重新定义，那么实现很可能会引发异常。
- en: Section 4.7\. Assignment
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4.7 节。赋值
- en: '**syntax**: `(set! *var* *expr*)`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `(set! *var* *expr*)`'
- en: '**returns:** unspecified'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 未指定'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`, `(rnrs)`'
- en: '`set!` does not establish a new binding for `*var*` but rather alters the value
    of an existing binding. It first evaluates `*expr*`, then assigns `*var*` to the
    value of `*expr*`. Any subsequent reference to `*var*` within the scope of the
    altered binding evaluates to the new value.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`set!` 并不为 `*var*` 建立新的绑定，而是改变现有绑定的值。它首先评估 `*expr*`，然后将 `*var*` 分配给 `*expr*`
    的值。在修改后的绑定范围内，对 `*var*` 的任何后续引用都会评估为新值。'
- en: Assignments are not employed as frequently in Scheme as in most other languages,
    but they are useful for implementing state changes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scheme 中，赋值并不像大多数其他语言那样频繁使用，但对于实现状态变化很有用。
- en: '`(define flip-flop'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define flip-flop'
- en: (let ([state #f])
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([state #f])
- en: (lambda ()
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! state (not state))
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: (set! state (not state))
- en: state)))
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: state)))
- en: (flip-flop) ![<graphic>](ch2_0.gif) #t
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: (flip-flop) ![<graphic>](ch2_0.gif) #t
- en: (flip-flop) ![<graphic>](ch2_0.gif) #f
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: (flip-flop) ![<graphic>](ch2_0.gif) #f
- en: (flip-flop) ![<graphic>](ch2_0.gif) #t`
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: (flip-flop) ![<graphic>](ch2_0.gif) #t`
- en: Assignments are also useful for caching values. The example below uses a technique
    called *memoization*, in which a procedure records the values associated with
    old input values so it need not recompute them, to implement a fast version of
    the otherwise exponential doubly recursive definition of the Fibonacci function
    (see page [69](further.html#fibonacci)).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值还可用于缓存值。下面的示例使用一种称为 *记忆化* 的技术，其中一个过程记录与旧输入值相关联的值，因此无需重新计算它们，以实现对斐波那契函数的指数双递归定义的快速版本（参见第 [69](further.html#fibonacci) 页）。
- en: '`(define memoize'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define memoize'
- en: (lambda (proc)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (proc)
- en: (let ([cache '()])
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([cache '()])
- en: (lambda (x)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (cond
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(assq x cache) => cdr]'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[(assq x cache) => cdr]'
- en: '[else'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[否则'
- en: (let ([ans (proc x)])
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([ans (proc x)])
- en: (set! cache (cons (cons x ans) cache))
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: (set! cache (cons (cons x ans) cache))
- en: ans)])))))
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ans)])))))
- en: (define fibonacci
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: (define fibonacci
- en: (memoize
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (记忆化
- en: (lambda (n)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (< n 2)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< n 2)
- en: '1'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))
- en: (fibonacci 100) ![<graphic>](ch2_0.gif) 573147844013817084101`
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 100) ![<graphic>](ch2_0.gif) 573147844013817084101`
