- en: '31Mutation: Structures and Variables'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 31Mutation：结构和变量
- en: '|     [31.1 Separating Meaning from Notation](#%28part._mutation-notation%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [31.1 将含义与符号分离](#%28part._mutation-notation%29) |'
- en: '|     [31.2 Mutation and Closures](#%28part._.Mutation_and_.Closures%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [31.2 变异和闭包](#%28part._.Mutation_and_.Closures%29) |'
- en: '|     [31.3 Mutable Structures](#%28part._.Mutable_.Structures%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [31.3 可变结构](#%28part._.Mutable_.Structures%29) |'
- en: '|       [31.3.1 Extending the Language Representation](#%28part._.Extending_the_.Language_.Representation%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.1 扩展语言表示](#%28part._.Extending_the_.Language_.Representation%29)
    |'
- en: '|       [31.3.2 The Interpretation of Boxes](#%28part._.The_.Interpretation_of_.Boxes%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.2 方框的解释](#%28part._.The_.Interpretation_of_.Boxes%29) |'
- en: '|       [31.3.3 Can the Environment Help?](#%28part._.Can_the_.Environment_.Help_%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.3 环境是否有助于？](#%28part._.Can_the_.Environment_.Help_%29) |'
- en: '|       [31.3.4 Welcome to the Store](#%28part._.Welcome_to_the_.Store%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.4 欢迎来到商店](#%28part._.Welcome_to_the_.Store%29) |'
- en: '|       [31.3.5 Interpreting Boxes](#%28part._store-passing-style%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.5 解释方框](#%28part._store-passing-style%29) |'
- en: '|       [31.3.6 Implementing Mutation: Subtleties and Variations](#%28part._.Implementing_.Mutation__.Subtleties_and_.Variations%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.6 实现变异：微妙和变化](#%28part._.Implementing_.Mutation__.Subtleties_and_.Variations%29)
    |'
- en: '|     [31.4 Variables](#%28part._mut-vars%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|     [31.4 变量](#%28part._mut-vars%29) |'
- en: '|       [31.4.1 The Syntax of Variable Assignment](#%28part._.The_.Syntax_of_.Variable_.Assignment%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [31.4.1 变量赋值的语法](#%28part._.The_.Syntax_of_.Variable_.Assignment%29)
    |'
- en: '|       [31.4.2 Interpreting Variables](#%28part._interp-vars%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|       [31.4.2 解释变量](#%28part._interp-vars%29) |'
- en: '|       [31.4.3 Reference Parameter Passing](#%28part._reference-param%29)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|       [31.4.3 引用参数传递](#%28part._reference-param%29) |'
- en: '|     [31.5 The Design of Stateful Language Operations](#%28part._design-of-state-ops%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|     [31.5 有状态语言操作的设计](#%28part._design-of-state-ops%29) |'
- en: '|     [31.6 Typing State](#%28part._typing-state%29) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|     [31.6 键入状态](#%28part._typing-state%29) |'
- en: '|       [31.6.1 Mutation and Polymorphism](#%28part._.Mutation_and_.Polymorphism%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|       [31.6.1 变异和多态](#%28part._.Mutation_and_.Polymorphism%29) |'
- en: '|       [31.6.2 Typing the Initial Value](#%28part._.Typing_the_.Initial_.Value%29)
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|       [31.6.2 键入初始值](#%28part._.Typing_the_.Initial_.Value%29) |'
- en: 31.1Separating Meaning from Notation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31.1将含义与符号分离
- en: Which of these is the same?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中哪一个是相同的？
- en: f = 3
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: f = 3
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: o.f = 3
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: o.f = 3
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: f = 3
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: f = 3
- en: 'Assuming all three are in Java, the first and third could behave exactly like
    each other or exactly like the second: it all depends on whether f is a local
    identifier (such as a parameter) or a field of the object (i.e., the code is really
    this.f = 3).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这三者都在Java中，则第一种和第三种可能会完全像第二种一样，也可能会完全像第二种一样：这完全取决于f是局部标识符（例如参数）还是对象的字段（即，代码实际上是this.f
    = 3）。
- en: 'In either case, we are asking the evaluator to permanently change the value
    bound to f. This has important implications for other observers. Until now, for
    a given set of inputs, a computation always returned the same value. Now, the
    answer depends on when it was invoked: above, it depends on whether it was invoked
    before or after the value of f was changed. The introduction of time has profound
    effects on predicting the behavior of programs.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一情况下，我们都要求评估器永久更改绑定到f的值。 这对其他观察者有重要的影响。 到目前为止，对于给定的输入集，计算总是返回相同的值。 现在，答案取决于何时调用它：在上面，它取决于在f的值更改之前还是之后调用了它。
    时间的引入对于预测程序行为具有深远的影响。
- en: However, there are really two quite different notions of change buried in the
    uniform syntax above. Changing the value of a field (o.f = 3 or this.f = 3) is
    extremely different from changing that of an identifier (f = 3 where f is bound
    as a parameter or a local inside the method, not by the object). We will explore
    these in turn. We’ll tackle fields below, and return to identifiers in [Variables](#%28part._mut-vars%29).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在上述统一语法中实际上有两种完全不同的变化概念。 更改字段的值（o.f = 3或this.f = 3）与更改标识符的值极为不同（f = 3其中f是方法内的参数或本地绑定，而不是由对象绑定）。
    我们将依次探讨这些。 我们将在下面处理字段，并在[变量](#%28part._mut-vars%29)中返回标识符。
- en: 'To study both these features, we will as usual write interpreters. However,
    to make sure we expose their essence, we will write these interpreters without
    the use of state. That is, we will do something quite remarkable: write mutation-free
    interpreters that faithfully mimic languages with mutation. The key to this will
    be a special pattern of passing information around in a computation.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究这两个特性，我们通常会编写解释器。然而，为了确保我们暴露它们的本质，我们将写这些解释器而不使用状态。也就是说，我们将做一些非常了不起的事情：编写无突变的解释器，其忠实地模拟了具有突变的语言。这其中的关键是一种特殊的计算中传递信息的模式。
- en: 31.2Mutation and Closures
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31.2突变和闭包
- en: 'Before we proceed, make sure you’ve understood boxes ([A Canonical Mutable
    Structure](State__Change__and_More_Equality.html#%28part._mutable-structures%29)),
    and especially the interaction between mutation and closures ([Interaction of
    Mutation with Closures: Counters](State__Change__and_More_Equality.html#%28part._state-closures-counter%29)).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们继续之前，请确保你已经理解了boxes（[A Canonical Mutable Structure](State__Change__and_More_Equality.html#%28part._mutable-structures%29)），特别是突变和闭包之间的交互（[Interaction
    of Mutation with Closures: Counters](State__Change__and_More_Equality.html#%28part._state-closures-counter%29)）。'
- en: 'The interaction with closures (and their first-cousin, objects [REF]) is particularly
    subtle. Consider the following situation:This example was described to me by Corky
    Cartwright. you are writing a GUI program to implement a calculator. The GUI element
    corresponding to each calculator button needs a callback—<wbr>essentially a closure—<wbr>that,
    when invoked, will report that that particular button was pressed. Therefore,
    it is tempting to initialize this as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与闭包（及其近亲对象[REF]）的交互尤其微妙。考虑以下情况：这个例子是由Corky Cartwright描述给我的。你正在编写一个GUI程序来实现一个计算器。与每个计算器按钮对应的GUI元素需要一个回调——实质上是一个闭包——当调用时，它将报告该特定按钮被按下。因此，很容易这样初始化：
- en: '| for(var i = 0; i < 10; i++) { |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| for(var i = 0; i < 10; i++) { |'
- en: '|   button[i] = function() { return i; } |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|   button[i] = function() { return i; } |'
- en: '| } |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: 'This pseudo-code translates with minimal change to any number of languages,
    with and without static types, ranging from Python to Swift. (Assume button has
    been initialized appropriately.)Notice that the closures created above all have
    i in their environment. Now let us try to inspect the behavior of these closures:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪代码几乎不需要任何改变就可以转换成任意数量的语言，包括有静态类型和没有静态类型的语言，从Python到Swift都可以。（假设button已经被适当初始化。）请注意，上面创建的所有闭包都在它们的环境中具有i。现在让我们试着检查这些闭包的行为：
- en: '| for(var i = 0; i < 10; i++) { |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| for(var i = 0; i < 10; i++) { |'
- en: '|   println(button[i]()) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|   println(button[i]()) |'
- en: '| } |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: That is, we extract the ith closure from button and apply it to no arguments.
    This evaluates the return i statement.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们从button中提取第i个闭包，并将其应用到无参数上。这会评估返回i语句。
- en: 'We might have liked this to produce the sequence of values 0, 1, 2, and so
    on through to 9. In fact, however, it produces ten outputs, all the same: 10.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望这会产生0、1、2等值的序列，一直到9。但实际上，它产生了十个相同的输出：10。
- en: Do Now!
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why? How would you fix this?
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你看明白了吗？你会如何修复这个问题？
- en: The problem is that i in the for loop is allocated only once. Therefore, all
    the closures share the same i. Because that value had to become 10 for the for
    loop to terminate, all the closures report the value 10.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于for循环中的i只分配一次。因此，所有的闭包共享相同的i。因为那个值必须变成10才能让for循环终止，所以所有的闭包都报告值为10。
- en: With traditional for loops, there is no obvious way out of this problem. This
    seemingly confusing behavior often confounds programmers new to languages that
    make extensive use of closures. Because they cannot change the behavior of for
    loops, many languages have introduced new versions of for (or new keywords inside
    for) to address this problem. The solution is always to allocate a fresh i on
    each iteration, so that each closure is over a different variable; the looping
    construct copies the previous value of i as the initial value of the new one before
    applying the updater (in this case, i++) and then performing the comparison and
    loop body.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的for循环，这个问题并没有明显的解决方法。这种看似令人困惑的行为经常让那些刚接触闭包语言的程序员感到困惑。因为他们无法改变for循环的行为，所以许多语言都引入了新版本的for（或者for内部的新关键字）来解决这个问题。解决方案始终是在每次迭代时分配一个新的i，这样每个闭包就都是对不同的变量进行操作；循环结构会将上一个i的值复制为新的i的初始值，然后应用更新器（在本例中为i++），然后执行比较和循环体。
- en: 'Observe that when programming functionally, the desired behavior comes for
    free. For instance:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数式编程时，期望的行为是免费的。例如：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is easier to see why the definition of funs works by writing the use of
    map more explicitly:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|     Box<Integer> b1 = new Box<Integer>(1); |'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Thus, we can see that on each iteration the outer lam(i): ... is applied, allocating
    a new i, which is the one closed over by the inner lam(): ....'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 setboxC 表达式中，盒位置和其新值都是表达式。后者并不奇怪，但前者可能会。这意味着我们可以在相应的 Pyret 中编写这样的程序：
- en: 31.3Mutable Structures
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '| where: |'
- en: 'Equipped with these examples, let us now return to adding mutation to the language
    in the form of mutable structures (which are also a good basis for mutable objects
    [REF]). Besides mutable structures themselves, note that we must sometimes perform
    mutation in groups (e.g., removing money from one bank account and depositing
    it in another). Therefore, it is useful to be able to sequence a group of mutable
    operations. We will call this begin: it evaluates its sub-terms terms in order
    and returns the value of the last one.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 装备了这些例子，现在让我们回到以可变结构的形式向语言添加突变（这也是可变对象的一个很好的基础[REF]）。
- en: Exercise
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|   index(l, 0)!{v : 1} |'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does it matter whether begin evaluates its sub-terms in some particular,
    specified order?
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|   l = [list: b0, b1] |'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter what this order is?
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| public static void main (String[] args) { |'
- en: Exercise
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个顺序很重要吗？
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define begin by desugaring into let (and hence into anonymous functions).
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|   b1 = box(1) |'
- en: 'This is an excellent illustration of the non-canonical nature of desguaring.
    We’ve chosen to add to the core a construct that is certainly not necessary. If
    our goal was to shrink the size of the interpreter—<wbr>perhaps at some cost to
    the size of the input program—<wbr>we would not make this choice. But our goal
    here is to understand key ideas in languages, so we choose the combination of
    features that will be most instructive. Even though it is possible to eliminate
    begin as syntactic sugar, it will prove extremely useful for understanding how
    mutation works. Therefore, we will add a simple, two-term version of sequencing
    (seqC) to the core. In turn, because our core language is becoming unwieldy, we
    will drop Boolean values and conditional values except where their presence makes
    things more interesting: and it does not here.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解糖非规范性质的一个很好的例证。我们选择向核心添加一个构造，这个构造确实是不必要的。如果我们的目标是缩小解释器的大小—<wbr>也许以某种对输入程序大小的代价—<wbr>我们不会做出这个选择。但我们这里的目标是理解语言中的关键思想，因此我们选择组合最具教学意义的功能。即使可以消除
    begin 作为语法糖，但它将证明对理解突变的工作方式非常有用。因此，我们将向核心添加一个简单的两项版本的序列（seqC）。反过来，由于我们的核心语言变得难以操纵，我们将放弃布尔值和条件值，除非它们的存在使事情更有趣：在这里并不是。
- en: 31.3.1Extending the Language Representation
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 funs 的定义写得更加明确以更好地理解其工作原理是更容易的：
- en: 'First, let’s extend our core language datatype:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们扩展我们的核心语言数据类型：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Observe that in a setboxC expression, both the box position and its new value
    are expressions. The latter is unsurprising, but the former might be. It means
    we can write programs such as this in corresponding Pyret:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可变结构本身之外，注意我们有时必须以组的形式执行突变（例如，从一个银行账户中取钱并将其存入另一个账户）。因此，能够按顺序对一组可变操作进行排序是很有用的。我们将其称为开始：它按顺序评估其子项项，并返回最后一个的值。
- en: '| fun make-box-list(): |'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: 为什么开始要按特定的顺序评估其子项项呢？
- en: '|   b0 = box(0) |'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| end |'
- en: '|   b1 = box(1) |'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: 练习
- en: '|   l = [list: b0, b1] |'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '因此，我们可以看到，在每次迭代中，外部 lam(i): ... 被应用，分配一个新的 i，这是内部 lam(): ... 所闭合的 i。'
- en: '|   index(l, 0)!{v : 1} |'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   l = make-box-list() |'
- en: '|   index(l, 1)!{v : 2} |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '这将评估为一个包含 1 和第二个包含 2 的盒子列表。注意，在每个突变语句中，我们都使用了一个复杂的表达式—<wbr>例如，index(l, 0)—<wbr>而不是一个字面值或标识符来获取盒子并进行突变（!{v
    : 1}）。这正是类似于 Java 的语言，其中可以（在某种类型上采取自由）编写'
- en: '|   l |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   b0 = box(0) |'
- en: '| where: |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| fun make-box-list(): |'
- en: '|   l = make-box-list() |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: 31.3 可变结构
- en: '|   index(l, 0)!v is 1 |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   index(l, 0)!v is 1 |'
- en: '|   index(l, 1)!v is 2 |'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     Box<Integer> b0 = new Box<Integer>(0); |'
- en: '| end |'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: 31.3.1 扩展语言表示
- en: 'This evaluates to a list of boxes, the first containing 1 and the second 2.
    Observe that in each of the mutation statements, we are using a complex expression—<wbr>e.g.,
    index(l, 0)—<wbr>rather than a literal or an identifier to obtain the box before
    mutating it (!{v : 1}). the first argument to the This is precisely analogous
    to languages like Java, where one can (taking some type liberties) write'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|   index(l, 1)!v is 2 |'
- en: '| public static void main (String[] args) { |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   index(l, 1)!{v : 2} |'
- en: '|     Box<Integer> b0 = new Box<Integer>(0); |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: 练习
- en: '|     Box<Integer> b1 = new Box<Integer>(1); |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: 通过将 begin 解糖为 let（因此解糖为匿名函数）来定义 begin。
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|   l |'
- en: '|     ArrayList<Box<Integer>> l = new ArrayList<Box<Integer>>(); |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|     ArrayList<Box<Integer>> l = new ArrayList<Box<Integer>>(); |'
- en: '|     l.add(b0); |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|     l.add(b0); |'
- en: '|     l.add(b1); |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|     l.add(b1); |'
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|     l.get(0).set(1); |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|     l.get(0).set(1); |'
- en: '|     l.get(1).set(2); |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|     l.get(1).set(2); |'
- en: '| } |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: Notice that l.get(0) is a compound expression being used to find the appropriate
    box, and evaluates to the box object on which set is invoked.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意l.get(0)是一个复合表达式，用于找到适当的盒子，并评估为调用set的盒子对象。
- en: For convenience, we will assume that we have implemented desguaring to provide
    us with (a) let and (b) if necessary, more than two terms in a sequence (which
    can be desugared into nested sequences). We will also sometimes write expressions
    in the original Pyret syntax, both for brevity (because the core language terms
    can grow quite large and unwieldy) and so that you can run these same terms in
    Pyret and observe what answers they produce. As this implies, we are taking the
    behavior in Pyret—<wbr>which mutable structures are similar in behavior to those
    of just about every mainstream language with mutable objects and structures—<wbr>as
    the reference behavior.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将假设我们已经实现了解糖以提供（a）let和（b）如果需要，一个序列中超过两个术语的解糖（可以解糖为嵌套序列）。我们有时也会用原始的Pyret语法编写表达式，既为了简洁（因为核心语言术语可能会变得相当庞大和笨重），也为了让你能够在Pyret中运行相同的术语并观察它们产生的答案。正如这意味着的那样，我们正在以Pyret中的行为为参考行为，其中可变结构的行为类似于几乎所有主流语言中可变对象和结构的行为。
- en: 31.3.2The Interpretation of Boxes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.2盒子的解释
- en: First, because we’ve introduced a new kind of value, the box, we have to update
    the set of values:<mut-str-value/1> ::=
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为我们引入了一种新的值，即盒子，我们必须更新值的集合：<mut-str-value/1> ::=
- en: '|   data Value: |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|   data Value: |'
- en: '|     &#124; numV(n :: Number) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; numV(n :: Number) |'
- en: '|     &#124; closV(f :: ExprC%(is-fdC), e :: Env) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; closV(f :: ExprC%(is-fdC), e :: Env) |'
- en: '|     &#124; boxV(v :: Value) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; boxV(v :: Value) |'
- en: '|   end |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: Now let’s begin by reproducing our current interpreter:<mut-str-interp/1> ::=
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始重现我们当前的解释器：<mut-str-interp/1> ::=
- en: '|   fun interp(e :: ExprC, nv :: Env) -> Value: |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|   fun interp(e :: ExprC, nv :: Env) -> Value: |'
- en: '|     cases (ExprC) e: |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|     cases (ExprC) e: |'
- en: '|       &#124; numC(n) => numV(n) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; numC(n) => numV(n) |'
- en: '|       &#124; plusC(l, r) => plus-v(interp(l, nv), interp(r, nv)) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; plusC(l, r) => plus-v(interp(l, nv), interp(r, nv)) |'
- en: '|       &#124; multC(l, r) => mult-v(interp(l, nv), interp(r, nv)) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; multC(l, r) => mult-v(interp(l, nv), interp(r, nv)) |'
- en: '|       &#124; idC(s) => lookup(s, nv) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; idC(s) => lookup(s, nv) |'
- en: '|       &#124; fdC(_, _) => closV(e, nv) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; fdC(_, _) => closV(e, nv) |'
- en: '|       &#124; appC(f, a) => |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; appC(f, a) => |'
- en: '|         clos = interp(f, nv) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|         clos = interp(f, nv) |'
- en: '|         arg-val = interp(a, nv) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|         arg-val = interp(a, nv) |'
- en: '|         interp(clos.f.body, |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|         interp(clos.f.body, |'
- en: '|           xtnd-env(bind(clos.f.arg, arg-val), clos.e)) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|           xtnd-env(bind(clos.f.arg, arg-val), clos.e)) |'
- en: '|       [<mut-str-interp/1-boxC>](#%28elem._mut-str-interp%2F1-box.C%29) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/1-boxC>](#%28elem._mut-str-interp%2F1-box.C%29) |'
- en: '|       [<mut-str-interp/1-unboxC>](#%28elem._mut-str-interp%2F1-unbox.C%29)
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/1-unboxC>](#%28elem._mut-str-interp%2F1-unbox.C%29)
    |'
- en: '|       [<mut-str-interp/1-seqC>](#%28elem._mut-str-interp%2F1-seq.C%29) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/1-seqC>](#%28elem._mut-str-interp%2F1-seq.C%29) |'
- en: '|     end |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: (You’ll soon see why the setboxC case is missing.)Two of these cases should
    be easy. When we’re given a box expression, we simply evaluate the content and
    return it wrapped in a boxV:<mut-str-interp/1-boxC> ::=
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (很快你就会明白为什么缺少setboxC的情况。这两种情况应该很容易。当我们得到一个盒子表达式时，我们只需评估内容并将其包装在盒子V中返回：<mut-str-interp/1-boxC>
    ::=
- en: '|   &#124; boxC(v) => boxV(interp(v, nv)) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; boxC(v) => boxV(interp(v, nv)) |'
- en: Similarly, extracting a value from a box is easy:<mut-str-interp/1-unboxC> ::=
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，从盒子中提取值很容易：<mut-str-interp/1-unboxC> ::=
- en: '|   &#124; unboxC(b) => interp(b, nv).v |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; unboxC(b) => interp(b, nv).v |'
- en: By now, you should be constructing a healthy set of test cases to make sure
    these behave as you’d expect.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该正在构建一组健康的测试用例，以确保它们的行为符合你的期望。
- en: Of course, we haven’t done any hard work yet. All the interesting behavior is,
    presumably, hidden in the treatment of setboxC. It may therefore surprise you
    that we’re going to look at seqC first instead (and you’ll see why we included
    it in the core).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还没有做任何艰苦的工作。所有有趣的行为，大概都隐藏在setboxC的处理中。因此，也许会让你惊讶的是，我们将首先看seqC而不是setboxC（你将看到为什么我们将其包含在核心中）。
- en: Let’s take the most natural implementation of a sequence of two instructions:<mut-str-interp/1-seqC>
    ::=
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用最自然的两条指令序列的实现：<mut-str-interp/1-seqC> ::=
- en: '|   &#124; seqC(b1, b2) => |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; seqC(b1, b2) => |'
- en: '|     b1-value = interp(b1, nv) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|     b1-value = interp(b1, nv) |'
- en: '|     b2-value = interp(b2, nv) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|     b2-value = interp(b2, nv) |'
- en: '|     b2-value |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|     b2-value |'
- en: 'That is, we evaluate the first term, then the second, and return the result
    of the second.You should immediately spot something troubling. We bound the result
    of evaluating the first term, but didn’t subsequently do anything with it. That’s
    okay: presumably the first term contained a mutation expression of some sort,
    and its value is uninteresting. Thus, an equivalent implementation might be this:<mut-str-interp/1-seqC/2>
    ::='
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，我们先评估第一个表达式，然后再评估第二个，并返回第二个的结果。你应该立即发现了一些令人不安的地方。我们绑定了评估第一个表达式的结果，但随后没有对其进行任何操作。没关系：可能第一个表达式包含了某种变异表达式，它的值是无趣的。因此，等价的实现可能是这样的：<mut-str-interp/1-seqC/2>
    ::=
- en: '|   &#124; seqC(b1, b2) => |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; seqC(b1, b2) => |'
- en: '|     interp(b1, nv) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b1, nv) |'
- en: '|     interp(b2, nv) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b2, nv) |'
- en: Not only is this slightly dissatisfying in that it just uses Pyret’s sequential
    behavior, it can’t possibly be right! This can only work only if the result of
    the mutation is being stored somewhere. But because our interpreter only computes
    values and does not perform any mutation itself—<wbr>because that would be cheating—<wbr>any
    mutations in interp(b1, nv) are completely lost. This is obviously not what we
    want. (And therefore, we’re not going to even attempt to define what to do in
    the setbox case.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅略显不满，因为它只使用了 Pyret 的顺序行为，而且肯定是错误的！只有当变异的结果被存储在某个地方时，这才能起作用。但是因为我们的解释器只计算值，并且不执行任何变异本身——因为那样就是作弊——interp(b1,
    nv) 中的任何变异都完全丢失了。这显然不是我们想要的。（因此，我们甚至不打算定义在 setbox 情况下该怎么办。）
- en: 31.3.3Can the Environment Help?
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.3 环境能起到帮助作用吗？
- en: 'Here is an input example that can help:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以帮助的输入示例：
- en: '| (let ([b (box 0)]) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (begin (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|   (begin (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|                 (set-box! b (+ 1 (unbox b)))) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|                 (set-box! b (+ 1 (unbox b)))) |'
- en: '|          (unbox b))) |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|          (unbox b))) |'
- en: In Racket, this evaluates to 2.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中，这个求值结果为 2。
- en: Exercise
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Represent this expression in ExprC.
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 ExprC 中表示此表达式。
- en: Let’s consider the evaluation of the inner sequence. In both cases, the expression
    (the representation of (set-box! ...)) is exactly identical. Yet something is
    changing underneath, because this causes the value of the box to go from 0 to
    2! We can “see” this even more clearly if instead we evaluate
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑内部序列的评估。在两种情况下，表达式（即 (set-box! ...) 的表示）完全相同。但是底层发生了一些变化，因为这导致箱子的值从 0 变为
    2！如果我们改为评估以下表达式，我们可以更清楚地“看到”这一点
- en: '| (let ([b (box 0)]) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (+ (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|   (+ (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|             (unbox b)) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|             (unbox b)) |'
- en: '|      (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|      (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|             (unbox b)))) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|             (unbox b)))) |'
- en: which evaluates to 3. Here, the two calls to interp in the rule for addition
    are evaluating exactly the same textual expression in both cases. Yet somehow
    the effects from the left branch of the addition are being felt in the right branch.Spukhafte
    Fernwirkung.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估为 3。在这里，对加法规则中的两次 interp 调用在两种情况下都评估完全相同的文本表达式。但是不知何故，左分支的效果在右分支中产生了影响。远程神秘作用。
- en: If the interpreter is being given precisely the same expression, how can it
    possibly avoid producing precisely the same answer? The most obvious way is if
    the interpreter’s other parameter, the environment, were somehow different. As
    of now the exact same environment is sent to both both branches of the sequence
    and both arms of the addition, so our interpreter—<wbr>which produces the same
    output every time on a given input—<wbr>cannot possibly produce the answers we
    want.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解释器被给予完全相同的表达式，它如何可能避免产生完全相同的答案？最明显的方法是，如果解释器的另一个参数，即环境，在某种程度上是不同的。到目前为止，完全相同的环境被发送到序列的两个分支和加法的两个分支，因此我们的解释器——在给定输入时每次产生相同的输出——无法产生我们想要的答案。
- en: 'Here is what we know so far:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所知道的是：
- en: We must somehow make sure the interpreter is fed different arguments on calls
    that are expected to potentially produce different results.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保解释器在调用时得到不同的参数，以期望产生不同的结果。
- en: We must return from the interpreter some record of the mutations made when evaluating
    its argument expression.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须返回解释器在评估其参数表达式时所做的变异的记录。
- en: 'Because the expression is what it is, the first point suggests that we might
    try to use the environment to reflect the differences between invocations. In
    turn, the second point suggests that each invocation of the interpreter should
    also return the environment, so it can be passed to the next invocation. So the
    interpreter should presumably be modified to return both the value and an updated
    environment. That is, the interpreter consumes an expression and environment;
    it evaluates in that environment, updating it as it proceeds; when the expression
    is done evaluating, the interpreter returns the answer (as it did before), along
    with an updated environment, which in turn is sent to the next invocation of the
    interpreter. And the treatment of setboxC would somehow impact the environment
    to reflect the mutation.Before we dive into the implementation, however, we should
    consider the consequences of such a change. The environment already serves an
    important purpose: it holds deferred substitutions. In that respect, it already
    has a precise semantics—<wbr>given by substitution—<wbr>and we must be careful
    to not alter that. One consequence of its tie to substitution is that it is also
    the repository of lexical scope information. If we were to allow the extended
    environment escape from one branch of addition and be used in the other, for instance,
    consider the impact on the equivalent of the following program:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因为表达式是什么样子的，第一个观点表明我们可以尝试使用环境来反映调用之间的差异。反过来，第二个观点表明解释器的每次调用也应该返回环境，以便可以传递给下一次调用。因此，解释器应该被修改为同时返回值和更新后的环境。也就是说，解释器接受一个表达式和环境；它在该环境中进行评估，并随着过程的进行更新它；当表达式完成评估时，解释器返回答案（就像以前一样），以及一个更新后的环境，然后将其发送到解释器的下一次调用。而且，对setboxC的处理应该以某种方式影响环境以反映变化。然而，在我们深入实施之前，我们应该考虑这种变化的后果。环境已经发挥了重要作用：它保存了延迟替换。在这方面，它已经具有了精确的语义——由替换给出——我们必须小心不要改变它。与替换的联系的一个结果是它也是词法作用域信息的存储库。例如，如果我们允许扩展环境从一个加法分支逃逸并在另一个分支中使用，那么考虑以下程序的等效物的影响：
- en: '| (+ (let ([b (box 0)]) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| (+ (let ([b (box 0)]) |'
- en: '|      1) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|      1) |'
- en: '|    b) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|    b) |'
- en: 'It should be evident that this program has an error: b in the right branch
    of the addition is unbound (the scope of the b in the left branch ends with the
    closing of the let—<wbr>if this is not evident, desugar the above expression to
    use functions). But the extended environment at the end of interpreting the let
    clearly has b bound in it.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个程序有一个错误：加法的右分支中的b是未绑定的（左分支中b的作用域在let结束时结束——如果这不明显，请将上述表达式去糖以使用函数）。但在解释let结束时，扩展环境中明显有b绑定。
- en: Exercise
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work out the above problem in detail and make sure you understand it.
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 详细解决上述问题并确保你理解它。
- en: You could try various other related proposals, but they are likely to all have
    similar failings. For instance, you may decide that, because the problem has to
    do with additional bindings in the environment, you will instead remove all added
    bindings in the returned environment. Sounds attractive? Did you remember we have
    closures?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试各种其他相关的提案，但它们很可能都存在类似的缺陷。例如，你可能会决定，由于问题涉及到环境中的附加绑定，你将在返回的环境中删除所有添加的绑定。听起来不错？你还记得我们有闭包吗？
- en: Exercise
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Consider the representation of the following program:'
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑以下程序的表示：
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| (let ([a (box 1)]) |'
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([a (box 1)]) |'
- en: '|   (let ([f (fun x (+ x (unbox a)))]) |'
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([f (fun x (+ x (unbox a)))]) |'
- en: '|     (begin |'
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|     （开始 |'
- en: '|       (set-box! a 2) |'
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (set-box! a 2) |'
- en: '|       (f 10)))) |'
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (f 10)))) |'
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What problems does this example cause?
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个例子引起了什么问题？
- en: Rather, we should note that while the constraints described above are all valid,
    the solution we proposed is not the only one. Observe that neither condition actually
    requires the environment to be the responsible agent. Indeed, it is quite evident
    that the environment cannot be the principal agent. We need something else.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该注意到，虽然上述描述的约束都是有效的，但我们提出的解决方案并不是唯一的解决方案。请注意，实际上，这两个条件都不要求环境成为负责的代理。事实上，很明显环境不能是主要的代理。我们需要其他东西。
- en: 31.3.4Welcome to the Store
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.4欢迎来到商店
- en: The preceding discussion tells us that we need two repositories to accompany
    the expression, not one. One of them, the environment, continues to be responsible
    for maintaining lexical scope. But the environment cannot directly map identifiers
    to their value, because the value might change. Instead, something else needs
    to be responsible for maintaining the dynamic state of mutated boxes. This latter
    data structure is called the store.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的讨论告诉我们，我们需要两个存储库来陪伴表达式，而不是一个。其中一个，环境，继续负责维护词法范围。但环境不能直接将标识符映射到它们的值，因为值可能会改变。相反，需要有其他东西负责维护突变框的动态状态。这后一个数据结构称为存储器。
- en: 'Like the environment, the store is a partial map. Its domain could be any abstract
    set of names, but it is natural to think of these as numbers, meant to stand for
    memory locations. This is because the store in the semantics maps directly onto
    (abstracted) physical memory in the machine, which is traditionally addressed
    by numbers. Thus the environment maps names to locations, and the store maps locations
    to values:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 像环境一样，存储器是一个部分映射。其定义域可以是任何抽象名称集合，但自然地将其视为数字，表示内存位置。这是因为语义中的存储器直接映射到（抽象化的）机器物理内存，传统上由数字地址寻址。因此，环境将名称映射到位置，而存储器将位置映射到值：
- en: '[PRE3]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ll also equip ourselves with a function to look up values in the store,
    just as we already have one for the environment (which now returns locations instead):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将配备一个函数来在存储器中查找值，就像我们已经为环境配备了一个函数一样（它现在返回位置而不是值）：
- en: '[PRE4]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercise
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fill in the bodies of lookup and fetch.
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 填写查找和提取的主体。
- en: With this, we can refine our notion of values to the correct one:<mut-str-value>
    ::=
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以将值的概念精确化为正确的：<mut-str-value> ::=
- en: '|   data Value: |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|   data Value: |'
- en: '|     &#124; numV(n :: Number) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; numV(n :: Number) |'
- en: '|     &#124; closV(f :: ExprC, e :: Env) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; closV(f :: ExprC, e :: Env) |'
- en: '|     &#124; boxV(l :: Number) |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; boxV(l :: Number) |'
- en: '|   end |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: 31.3.5Interpreting Boxes
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.5解释框箱
- en: 'Now we have something that the interpreter can return, updated, reflecting
    mutations during the evaluation of the expression, without having to change the
    environment in any way. Because a function can return only one value, we will
    use an ad hoc object with two fields: v for the value (which will (effectively)
    be the same as the one the interpreter originally returned), and st for the (potentially)
    updated store. We will use the following helper function to assemble the result:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了解释器可以返回的东西，经过更新，反映了在表达式评估过程中的突变，而不需要以任何方式更改环境。因为函数只能返回一个值，我们将使用一个具有两个字段的特设对象：v用于值（它将（有效地）与解释器最初返回的值相同），st用于（潜在地）更新的存储器。我们将使用以下辅助函数来组装结果：
- en: '[PRE5]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exercise
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we say “effectively” and “potentially” above?
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么我们在上面说“有效地”和“潜在地”？
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hint for “effectively”: look at closures.'
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “有效地”的提示：看闭包。
- en: Thus our interpreter becomes:<mut-str-interp> ::=
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的解释器变成了：<mut-str-interp> ::=
- en: '|   fun interp(e :: ExprC, nv :: Env, st :: Store): |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|   fun interp(e :: ExprC, nv :: Env, st :: Store): |'
- en: '|     cases (ExprC) e: |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|     cases (ExprC) e: |'
- en: '|       [<mut-str-interp/numC>](#%28elem._mut-str-interp%2Fnum.C%29) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/numC>](#%28elem._mut-str-interp%2Fnum.C%29) |'
- en: '|       [<mut-str-interp/plusC>](#%28elem._mut-str-interp%2Fplus.C%29) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/plusC>](#%28elem._mut-str-interp%2Fplus.C%29) |'
- en: '|       [<mut-str-interp/idC>](#%28elem._mut-str-interp%2Fid.C%29) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/idC>](#%28elem._mut-str-interp%2Fid.C%29) |'
- en: '|       [<mut-str-interp/fdC>](#%28elem._mut-str-interp%2Ffd.C%29) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/fdC>](#%28elem._mut-str-interp%2Ffd.C%29) |'
- en: '|       [<mut-str-interp/appC>](#%28elem._mut-str-interp%2Fapp.C%29) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/appC>](#%28elem._mut-str-interp%2Fapp.C%29) |'
- en: '|       [<mut-str-interp/boxC>](#%28elem._mut-str-interp%2Fbox.C%29) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/boxC>](#%28elem._mut-str-interp%2Fbox.C%29) |'
- en: '|       [<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29) |'
- en: '|       [<mut-str-interp/setboxC>](#%28elem._mut-str-interp%2Fsetbox.C%29)
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/setboxC>](#%28elem._mut-str-interp%2Fsetbox.C%29)
    |'
- en: '|       [<mut-str-interp/seqC>](#%28elem._mut-str-interp%2Fseq.C%29) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/seqC>](#%28elem._mut-str-interp%2Fseq.C%29) |'
- en: '|     end |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: The easiest one to dispatch is numbers. Remember that we have to return the
    store reflecting all mutations that happened while evaluating the given expression.
    Because a number is a constant, no mutations could have happened, so the returned
    store is the same as the one passed in:<mut-str-interp/numC> ::=
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易分配的是数字。记住，我们必须返回反映在评估给定表达式时发生的所有突变的存储。因为数字是一个常数，所以不可能发生突变，所以返回的存储与传入的存储相同：<mut-str-interp/numC>
    ::=
- en: '|   &#124; numC(n) => ret(numV(n), st) |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; numC(n) => ret(numV(n), st) |'
- en: A similar argument applies to closure creation; observe that we are speaking
    of the creation, not use, of closures:<mut-str-interp/fdC> ::=
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于闭包的创建也适用类似的论点；请注意我们正在讨论闭包的创建，而不是使用：<mut-str-interp/fdC> ::=
- en: '|   &#124; fdC(_, _) => ret(closV(e, nv), st) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; fdC(_, _) => ret(closV(e, nv), st) |'
- en: Identifiers are almost as straightforward, though if you are simplistic, you’ll
    get a type error that will alert you that to obtain a value, you must now look
    up both in the environment and in the store:<mut-str-interp/idC> ::=
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符几乎和数字一样简单，但是如果你太简单化了，你会得到一个类型错误，提示你要获取一个值，你现在必须在环境和存储中查找：<mut-str-interp/idC>
    ::=
- en: '|   &#124; idC(s) => ret(fetch(lookup(s, nv), st), st) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; idC(s) => ret(fetch(lookup(s, nv), st), st) |'
- en: Notice how lookup and fetch compose to produce the same result that lookup alone
    produced before.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意查找和提取如何组合以产生与之前仅使用查找产生的相同结果。
- en: Now things get interesting.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得有趣起来了。
- en: Let’s take sequencing. Clearly, we need to interpret the two terms.<mut-str-interp/seqC/alt>
    ::=
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈序列。显然，我们需要解释这两个项。<mut-str-interp/seqC/alt> ::=
- en: '|   &#124; seqC(b1, b2) => |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; seqC(b1, b2) => |'
- en: '|     interp(b1, nv, st) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b1, nv, st) |'
- en: '|     interp(b2, nv, st) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b2, nv, st) |'
- en: Oh, but wait. The whole point was to evaluate the second term in the store returned
    by the first one—<wbr>otherwise there would have been no point to all these changes.
    Therefore, instead we must evaluate the first term, capture the resulting store,
    and use it to evaluate the second. (Evaluating the first term also yields its
    value, but sequencing ignores this value and assumes the first term was run purely
    for its potential mutations.) Thus:<mut-str-interp/seqC> ::=
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，等等。整个重点是评估由第一个返回的存储中的第二项——否则所有这些变化就没有意义。因此，相反地，我们必须评估第一项，捕获结果存储，并使用它来评估第二项。（评估第一项还产生它的值，但是顺序忽略了这个值，并假定第一项纯粹是为了其潜在的突变而运行。）因此：<mut-str-interp/seqC>
    ::=
- en: '|   &#124; seqC(b1, b2) => |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; seqC(b1, b2) => |'
- en: '|     b1-value = interp(b1, nv, st) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|     b1-value = interp(b1, nv, st) |'
- en: '|     interp(b2, nv, b1-value.st) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b2, nv, b1-value.st) |'
- en: 'This says to interpret the first term: interp(b1, nv, st); name the resulting
    value, which contains v and st fields, b1-value; and evaluate the second term
    in the store from the first: interp(b2, nv, b1-value.st). The result will be the
    value and store returned by the second term, which is what we expect. The fact
    that the first term’s effect is only on the store can be read from the code because
    we never use b1-value.v.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要解释第一项：interp(b1, nv, st)；给产生的值，其中包含v和st字段，命名为b1-value；并在第一个存储中评估第二项：interp(b2,
    nv, b1-value.st)。结果将是第二项返回的值和存储，这是我们预期的。因为我们从未使用b1-value.v，所以第一项的影响仅仅是在存储上，这可以从代码中看出。
- en: Do Now!
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Spend a moment contemplating the code above. You’ll soon need to adjust your
    eyes to read this pattern fluently.
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 花一会儿时间思考上面的代码。你很快就需要调整你的眼睛来流畅地阅读这种模式。
- en: Now let’s move on to the binary arithmetic primitives. These are similar to
    sequencing in that they have two sub-terms, but in this case we really do care
    about the value from each branch. As usual, we’ll look at only plusC since multC
    is virtually identical.<mut-str-interp/plusC> ::=
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论二进制算术原语。这些与序列相似，因为它们有两个子项，但在这种情况下，我们确实关心每个分支的值。像往常一样，我们只看plusC，因为multC几乎相同。<mut-str-interp/plusC>
    ::=
- en: '|   &#124; plusC(l, r) => |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; plusC(l, r) => |'
- en: '|     lv = interp(l, nv, st) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|     lv = interp(l, nv, st) |'
- en: '|     rv = interp(r, nv, lv.st) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|     rv = interp(r, nv, lv.st) |'
- en: '|     ret(plus-v(lv.v, rv.v), rv.st) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|     ret(plus-v(lv.v, rv.v), rv.st) |'
- en: Observe that we’ve repeated the pattern because we have two sub-expressions
    to evaluate whose values we want to use. Thus the first store (lv.st) is used
    to interpret the second expression, and the overall result returns that of the
    second (rv.st).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们重复了这个模式，因为我们有两个子表达式要评估，我们希望使用它们的值。因此，第一个存储（lv.st）用于解释第二个表达式，并且总体结果返回第二个表达式的结果（rv.st）。
- en: 'Here’s an important distinction. When we evaluate a term, we usually use the
    same environment for all its sub-terms in accordance with the scoping rules of
    the language. The environment thus flows in a recursive-descent pattern. In contrast,
    the store is threaded: rather than using the same store in all branches, we take
    the store from one branch and pass it on to the next, and take the result and
    send it back out. This pattern is called store-passing style.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的区别。当我们评估一个术语时，通常根据语言的作用域规则为其所有子术语使用相同的环境。因此，环境以递归下降模式流动。相反，存储是经过线程化的：我们不是在所有分支中使用相同的存储，而是从一个分支获取存储，然后传递给下一个分支，并将结果发送回去。这种模式称为存储传递风格。
- en: 'Now the penny drops. We see that store-passing style is our secret ingredient:
    it enables the environment to preserve lexical scope while still giving a binding
    structure that can reflect changes. Our intution told us that the environment
    had to somehow participate in obtaining different results for the same syntactic
    expression, and we can now see how it does: not directly, by itself changing,
    but indirectly, by referring to the store, which updates. Now we only need to
    see how the store itself “changes”.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都水到渠成了。我们看到，传递存储的风格是我们的秘密武器：它使环境能够保留词法范围，同时仍然提供可以反映更改的绑定结构。我们的直觉告诉我们，环境必须以某种方式参与获取相同语法表达式的不同结果，现在我们可以看到它是如何做到的：不是直接通过自身更改，而是间接地通过引用存储，然后更新。现在我们只需要看看存储本身是如何“改变”的。
- en: 'Let’s begin with boxing. To store a value in a box, we have to first allocate
    a new place in the store where its value will reside. The value corresponding
    to a box will then remember this location, for use in box mutation. To obtain
    a fresh value each time, we will use the stateful counter example we have seen
    earlier ([Interaction of Mutation with Closures: Counters](State__Change__and_More_Equality.html#%28part._state-closures-counter%29)):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从盒子开始。要将值存储在盒子中，我们首先必须在存储中分配一个新的位置，该值将驻留在其中。然后，与盒子对应的值将记住此位置，以供盒子变异时使用。为了每次都能获得新值，我们将使用我们之前见过的有状态计数器示例（[突变与闭包的相互作用：计数器](State__Change__and_More_Equality.html#%28part._state-closures-counter%29）：
- en: '[PRE6]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Given this, we can now define the interpretation of box creation:<mut-str-interp/boxC>
    ::=
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以定义盒子创建的解释：<mut-str-interp/boxC> ::=
- en: '|   &#124; boxC(v) => |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; boxC(v) => |'
- en: '|     val = interp(v, nv, st) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|     val = interp(v, nv, st) |'
- en: '|     loc = new-loc() |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|     loc = new-loc() |'
- en: '|     ret(boxV(loc), |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|     ret(boxV(loc), |'
- en: '|       xtnd-sto(cell(loc, val.v), st)) |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|       xtnd-sto(cell(loc, val.v), st)) |'
- en: Do Now!
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that we have relied above on new-loc, which is itself implemented in
    terms of boxes! This is outright cheating. How would you modify the interpreter
    so that we no longer need mutation for this little bit of state?
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，我们在上面依赖了new-loc，它本身是基于盒子实现的！这是彻头彻尾的作弊。您将如何修改解释器，以便我们不再需要突变来处理这一小段状态？
- en: 'To eliminate new-loc, the simplest option would be to add another parameter
    to and return value from the interpreter, representing the largest address used
    so far. Every operation that allocates in the store would return an incremented
    address, while all others would return it unchanged. In other words, this is precisely
    another application of the store-passing pattern. Writing the interpreter this
    way would make it extremely unwieldy and might obscure the more important use
    of store-passing for the store itself, which is why we have not done so. However,
    it is important to make sure that we can: that’s what tells us that we are not
    reliant on state to add state to the language.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要消除new-loc，最简单的选项是向解释器添加另一个参数，并从解释器返回值，表示到目前为止使用的最大地址。每个在存储中分配的操作都将返回一个递增的地址，而所有其他操作都将保持不变。换句话说，这正是存储传递模式的另一个应用。以这种方式编写解释器将使其非常笨重，并可能掩盖更重要的存储传递模式的使用，这就是我们没有这样做的原因。但是，重要的是要确保我们可以做到：这告诉我们，我们不依赖状态来向语言添加状态。
- en: Now that boxes are recording the location in memory, getting the value corresponding
    to them is easy.<mut-str-interp/unboxC> ::=
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在盒子记录了内存中的位置，获取与之对应的值就很容易了。<mut-str-interp/unboxC> ::=
- en: '|   &#124; unboxC(b) => |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; unboxC(b) => |'
- en: '|     val = interp(b, nv, st) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|     val = interp(b, nv, st) |'
- en: '|     ret(fetch(val.v.l, val.st), val.st) |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|     ret(fetch(val.v.l, val.st), val.st) |'
- en: It’s the same pattern we saw before, where we have to use fetch to obtain the
    actual value residing at that location. Note that we are relying on Racket to
    halt with an error if the underlying value isn’t actually a boxV; otherwise it
    would be dangerous to not check, since this would be tantamount to dereferencing
    arbitrary memory [REF memory safety].
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的模式相同，我们必须使用fetch来获取实际驻留在该位置的值。请注意，我们依赖于Racket在底层值实际上不是boxV时出错停止；否则，不检查将是危险的，因为这等同于对任意内存进行解引用[REF
    memory safety]。
- en: Let’s now see how to update the value held in a box. First we have to evaluate
    the box expression to obtain a box, and the value expression to obtain the new
    value to store in it. The box’s value is going to be a boxV holding a location.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何更新盒子中保存的值。首先，我们必须评估盒子表达式以获得一个盒子，以及值表达式以获得要存储在其中的新值。盒子的值将是一个包含位置的盒子V。
- en: In principle we want to “change”, or override, the value at that location in
    the store. We can do this in two ways.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们希望“更改”或覆盖存储中该位置的值。我们可以通过两种方式实现这一点。
- en: One is to traverse the store, find the old binding for that location, and replace
    it with the new one, copying all the other store bindings unchanged.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中一个是遍历存储，找到该位置的旧绑定，并用新的替换它，同时保持所有其他存储绑定不变。
- en: The other, lazier, option is to simply extend the store with a new binding for
    that location, which works provided we always obtain the most recent binding for
    a location (which is how lookup works in the environment, so fetch can do the
    same in the store).Observe that this latter option forces us to commit to lists
    rather than to sets.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个更懒惰的选择是简单地为该位置扩展存储，这在我们总是获得位置的最新绑定时有效（这就是环境中查找的工作方式，因此获取可以在存储中执行相同的操作）。请注意，后一种选择迫使我们承诺使用列表而不是集合。
- en: The code below is written to be independent of these options:<mut-str-interp/setboxC>
    ::=
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是独立于这些选项的编写：<mut-str-interp/setboxC> ::=
- en: '|   &#124; setboxC(b, v) => |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; setboxC(b, v) => |'
- en: '|     b-val = interp(b, nv, st) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|     b-val = interp(b, nv, st) |'
- en: '|     v-val = interp(v, nv, b-val.st) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|     v-val = interp(v, nv, b-val.st) |'
- en: '|     ret(v-val.v, |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|     ret(v-val.v, |'
- en: '|       xtnd-sto(cell(b-val.v.l, v-val.v), v-val.st)) |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|       xtnd-sto(cell(b-val.v.l, v-val.v), v-val.st)) |'
- en: If we’ve implemented xtnd-sto as link above, we’ve actually taken the lazier
    (and slightly riskier, because of its dependence on the implementation of fetch)
    option.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像上面的链接一样实现了xtnd-sto，实际上我们已经采取了更懒惰的（稍微更危险，因为它依赖于fetch实现）选择。
- en: Exercise
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the other version of store alteration, whereby we update an existing
    binding and thereby avoid multiple bindings for a location in the store.
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现存储更改的另一版本，通过更新现有绑定来避免在存储中为位置创建多个绑定。
- en: Exercise
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When we look for a location to override the value stored at it, can the location
    fail to be present? If so, write a program that demonstrates this. If not, explain
    what invariant of the interpreter prevents this from happening.
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们寻找要覆盖其存储的值的位置时，该位置可能不存在吗？如果是这样，请编写一个演示此情况的程序。如果不是，请解释解释器的不变性防止这种情况发生。
- en: 'Alright, we’re now done with everything other than application! Most of application
    should already be familiar: evaluate the function position, evaluate the argument
    position, interpret the closure body in an extension of the closure’s environment...but
    how do stores interact with this?<mut-str-interp/appC> ::='
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，除了应用程序之外，我们现在已经完成了一切！大部分应用程序应该已经很熟悉了：评估函数位置，评估参数位置，在扩展闭包环境中解释闭包体...但存储如何与此交互？<mut-str-interp/appC>
    ::=
- en: '|   &#124; appC(f, a) => |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; appC(f, a) => |'
- en: '|     clos = interp(f, nv, st) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|     clos = interp(f, nv, st) |'
- en: '|     clos-v :: Value = clos.v |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|     clos-v :: Value = clos.v |'
- en: '|     clos-st :: Store = clos.st |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|     clos-st :: Store = clos.st |'
- en: '|     arg-val = interp(a, nv, clos-st) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|     arg-val = interp(a, nv, clos-st) |'
- en: '|     [<mut-str-interp/appC/core>](#%28elem._mut-str-interp%2Fapp.C%2Fcore%29)
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|     [<mut-str-interp/appC/core>](#%28elem._mut-str-interp%2Fapp.C%2Fcore%29)
    |'
- en: Let’s start by thinking about extending the closure environment. The name we’re
    extending it with is obviously the name of the function’s formal parameter. But
    what location do we bind it to? To avoid any confusion with already-used locations
    (a confusion we will explicitly introduce later!—<wbr>[Reference Parameter Passing](#%28part._reference-param%29)),
    let’s just allocate a new location. This location is used in the environment,
    and the value of the argument resides at this location in the store:<mut-str-interp/appC/core>
    ::=
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑扩展闭包环境开始。我们要扩展的名称显然是函数形式参数的名称。但我们将它绑定到哪个位置呢？为了避免与已使用位置混淆（我们稍后将明确介绍的混淆！—<wbr>[参考参数传递](#%28part._reference-param%29)），让我们只分配一个新位置。此位置在环境中使用，并且参数的值驻留在存储器中的此位置：<mut-str-interp/appC/core>
    ::=
- en: '|   new-loc = new-loc() |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|   new-loc = new-loc() |'
- en: '|   interp(clos-v.f.body, |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|   interp(clos-v.f.body, |'
- en: '|     xtnd-env(bind(clos-v.f.arg, new-loc), clos-v.e), |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|     xtnd-env(bind(clos-v.f.arg, new-loc), clos-v.e), |'
- en: '|     xtnd-sto(cell(new-loc, arg-val.v), arg-val.st)) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|     xtnd-sto(cell(new-loc, arg-val.v), arg-val.st)) |'
- en: 'Because we have not said the function parameter is mutable, there is no real
    need to have implemented procedure calls this way. We could instead have followed
    the same strategy as before. Indeed, observe that the mutability of this location
    will never be used: only setboxC changes what’s in an existing store location
    (the xtnd-sto above is technically a store initialization), and then only when
    they are referred to by boxVs, but no box is being allocated above.You could call
    this the useless app store. However, we have chosen to implement application this
    way for uniformity, and to reduce the number of cases we’d have to handle.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有说函数参数是可变的，所以没有必要以这种方式实现过程调用。我们可以像以前一样遵循相同的策略。事实上，观察到这个位置的可变性永远不会被使用：只有setboxC改变了已存在存储位置中的内容（上面的xtnd-sto在技术上是一个存储器初始化），而且只有在它们被boxVs引用时才这样做，但上面没有分配任何盒子。你可以称之为无用的应用存储器。然而，我们选择以这种方式实现应用程序是为了统一性，并减少我们需要处理的情况的数量。
- en: Exercise
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s a useful exercise to try to limit the use of store locations only to boxes.
    How many changes would you need to make?
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试将存储位置的使用限制在盒子中是一种有用的练习。你需要做多少改变？
- en: '31.3.6Implementing Mutation: Subtleties and Variations'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.6实现突变：微妙和变化
- en: Even though we’ve finished the implementation, there are still many subtleties
    and insights to discuss.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经完成了实现，仍然有许多微妙之处和见解需要讨论。
- en: 'Implicit in our implementation is a subtle and important decision: the order
    of evaluation. For instance, why did we not implement addition thus?'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现中的一个微妙而重要的决定是评估顺序。例如，为什么我们没有这样实现加法呢？
- en: <mut-str-interp/plusC/alt> ::=
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <mut-str-interp/plusC/alt> ::=
- en: '|   &#124; plusC(l, r) => |'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|   &#124; plusC(l, r) => |'
- en: '|     rv = interp(r, nv, st) |'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|     rv = interp(r, nv, st) |'
- en: '|     lv = interp(l, nv, rv.st) |'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|     lv = interp(l, nv, rv.st) |'
- en: '|     ret(plus-v(lv.v, rv.v), lv.st) |'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|     ret(plus-v(lv.v, rv.v), lv.st) |'
- en: 'It would have been perfectly consistent to do so. Similarly, embodied in the
    pattern of store-passing is the decision to evaluate the function position before
    the argument. Observe that:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做也完全一致。同样，存储传递模式中体现出的是在评估函数位置之前评估参数的决定。观察到：
- en: Previously, we delegated such decisions to the underlying language implementation.
    Now, store-passing has forced us to sequentialize the computation, and hence make
    this decision ourselves (whether we realized it or not).
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以前，我们将这些决定委托给底层语言实现。现在，传递存储已经迫使我们将计算序列化，并因此自行做出这个决定（无论我们是否意识到了这一点）。
- en: Even more importantly, this decision is now a semantic one. Before there were
    mutations, one branch of an addition, for instance, could not affect the value
    produced by the other branch.The only effect they could have was halting with
    an error or failing to terminate—<wbr>which, to be sure, are certainly observable
    effects, but at a much more gross level. A program would not terminate with two
    different answers depending on the order of evaluation. Because each branch can
    have mutations that impact the value of the other, we must choose some order so
    that programmers can predict what their program is going to do! Being forced to
    write a store-passing interpreter has made this clear.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更重要的是，这个决定现在是一个语义决定。在没有变异之前，例如，加法的一个分支不能影响另一个分支产生的值。它们唯一的影响是停止并出现错误或���法终止——<wbr>这确实是可观察的效果，但在更粗略的层面上。程序不会因为评估顺序的不同而以两个不同的答案终止。因为每个分支都可能有影响其他分支值的变异，所以我们必须选择某种顺序，以便程序员可以预测他们的程序将要做什么！被迫编写一个传递存储的解释器已经让这一点变得清楚。
- en: Observe that in the application rule, we are passing along the dynamic store,
    i.e., the one resulting from evaluating both function and argument. This is precisely
    the opposite of what we said to do with the environment. This distinction is critical.
    The store is, in effect, “dynamically scoped”, in that it reflects the history
    of the computation, not its lexical shape. Because we are already using the term
    “scope” to refer to the bindings of identifiers, however, it would be confusing
    to say “dynamically scoped” to refer to the store. Instead, we simply say that
    it is persistent.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在应用规则中，我们传递了动态存储，即从评估函数和参数得到的存储。这恰恰与我们对环境的要求相反。这种区别至关重要。存储实际上是“动态作用域的”，因为它反映了计算的历史，而不是其词法形状。然而，由于我们已经使用术语“作用域”来指代标识符的绑定，因此说“动态作用域”来指代存储会令人困惑。相反，我们只是说它是持久的。
- en: 'Languages sometimes dangerously conflate these two. In C, for instance, values
    bound to local identifiers are allocated (by default) on the stack. However, the
    stack matches the environment, and hence disappears upon completion of the call.
    If the call, however, returned references to any of these values, these references
    are now pointing to unused or even overridden memory: a genuine source of serious
    errors in C programs. The problem is that programmers want the values themselves
    to persist; but the storage for those values has been conflated with that for
    identifiers, who come and go with lexical scope.'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时语言会危险地混淆这两者。例如，在C语言中，绑定到本地标识符的值（默认情况下）是在堆栈上分配的。然而，堆栈与环境匹配，因此在调用完成后会消失。然而，如果调用返回对这些值的引用，这些引用现在指向未使用或甚至被覆盖的内存：这是C程序中严重错误的真正来源。问题在于程序员希望值本身保持持久；但是为这些值分配的存储与标识符的存储混为一谈，后者随着词法范围的出现和消失而变化。
- en: 'We have already discussed how there are two strategies for overriding the store:
    to simply extend it (and rely on fetch to extract the newest one) or to “search-and-replace”.
    The latter strategy has the virtue of not holding on to useless store bindings
    that will can never be obtained again.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经讨论了覆盖存储的两种策略：简单地扩展它（并依赖于提取最新存储的fetch）或“搜索和替换”。后一种策略的优点是不保留永远无法再次获得的无用存储绑定。
- en: 'However, this does not cover all the wasted memory. Over time, we cease to
    be able to access some boxes entirely: e.g., if they are bound to only one identifier,
    and that identifier is no longer in scope. These locations are called garbage.
    Thinking more conceptually, garbage locations are those whose elimination does
    not have any impact on the value produced by a program. There are many strategies
    for automatically identifying and reclaiming garbage locations, usually called
    garbage collection [REF].'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这并不能覆盖所有浪费的内存。随着时间的推移，我们将无法访问某些盒子：例如，如果它们仅绑定到一个标识符，而该标识符不再在作用域内。这些位置被称为垃圾。从更概念上来看，垃圾位置是那些消除对程序产生的值没有任何影响的位置。通常有许多自动识别和回收垃圾位置的策略，通常称为垃圾收集[REF]。
- en: It’s very important to evaluate every expression position and thread the store
    that results from it. Consider, for instance, this alternate implementation of
    unboxC (compare with [<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29)):<mut-str-interp/unboxC/alt-1>
    ::=
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个表达式位置进行评估并穿插结果存储非常重要。例如，考虑unboxC的另一种实现（与[<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29)进行比较）：<mut-str-interp/unboxC/alt-1>
    ::=
- en: '|   &#124; unboxC(b) => |'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|   &#124; unboxC(b) => |'
- en: '|     val = interp(b, nv, st) |'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|     val = interp(b, nv, st) |'
- en: '|     ret(fetch(val.v.l, st), val.st) |'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|     ret(fetch(val.v.l, st), val.st) |'
- en: Did you notice? We fetched the location from st, not val.st. But st reflects
    mutations up to but before the evaluation of the unboxC expression, not any within
    it. Could there possibly be any? Mais oui!
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你注意到了吗？我们从`st`而不是`val.st`中提取了位置。但是`st`反映了`unboxC`表达式评估之前但在其中之前的突变，而不是其中的任何突变。可能有吗？当然有！
- en: '| (let ([b (box 0)]) |'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (unbox (begin (set-box! b 1) |'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|   (unbox (begin (set-box! b 1) |'
- en: '|                 b))) |'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|                 b))) |'
- en: With the incorrect code above, this would evaluate to 0 rather than 1.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述错误的代码中，这将评估为0而不是1。
- en: Here’s another, similar, error (again compare with [<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29)):<mut-str-interp/unboxC/alt-2>
    ::=
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是另一个类似的错误（再次与[<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29)比较）：<mut-str-interp/unboxC/alt-2>
    ::=
- en: '|   &#124; unboxC(b) => |'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|   &#124; unboxC(b) => |'
- en: '|     val = interp(b, nv, st) |'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|     val = interp(b, nv, st) |'
- en: '|     ret(fetch(val.v.l, val.st), st) |'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|     ret(fetch(val.v.l, val.st), st) |'
- en: How do we break this? In the end we’re returning the old store, the one before
    any mutations in the unboxC happened. Thus, we just need the outside context to
    depend on one of them.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何打破这个？最后我们返回旧存储，即在`unboxC`中的任何突变之前的存储。因此，我们只需要外部上下文依赖于其中一个。
- en: '| (let ([b (box 0)]) |'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (+ (unbox (begin (set-box! b 1) |'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|   (+ (unbox (begin (set-box! b 1) |'
- en: '|                    b)) |'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|                    b)) |'
- en: '|      (unbox b))) |'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|      (unbox b))) |'
- en: This should evaluate to 2, but because the store being returned is one where
    b’s location is bound to the representation of 0, the result is 1.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该评估为2，但因为返回的存储是一个其中`b`的位置绑定到0的表示，所以结果是1。
- en: If we combined both bugs above—<wbr>i.e., using st twice in the last line instead
    of s-a twice—<wbr>this expression would evaluate to 0 rather than 2.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们将上述两个错误结合起来——即，在最后一行中两次使用`st`而不是两次使用`s-a`——这个表达式将评估为0而不是2。
- en: Exercise
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go through the interpreter; replace every reference to an updated store with
    a reference to one before update; make sure your test cases catch all the introduced
    errors!
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过解释器；将每个对更新后存储的引用替换为对更新前存储的引用；确保你的测试用例捕获所有引入的错误！
- en: 'Observe that these uses of “old” stores enable us to perform a kind of time
    travel: because mutation introduces a notion of time, these enable us to go back
    in time to when the mutation had not yet occurred. This sounds both interesting
    and perverse; does it have any use?'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意这些对“旧”存储的使用使我们能够执行一种时间旅行：因为突变引入了时间的概念，所以这使我们能够回到突变尚未发生的时间。这听起来既有趣又反常；它有用吗？
- en: 'It does! Imagine that instead of directly mutating the store, we introduce
    the idea of a journal of intended updates to the store. The journal flows in a
    threaded manner just like the real store itself. Some instruction creates a new
    journal; after that, all lookups first check the journal, and only if the journal
    cannot find a binding for a location is it looked for in the actual store. There
    are two other new instructions: one to discard the journal (i.e., travel back
    in time), and the other to commit it (i.e., all of its edits get applied to the
    real store).'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它确实做到了！想象一下，我们不是直接突变存储，而是引入了一个关于存储预期更新的日志的概念。日志以与真实存储本身完全相同的线程方式流动。某些指令创建一个新的日志；在那之后，所有查找首先检查日志，只有当日志找不到位置的绑定时才在实际存储中查找。还有两个新指令：一个是丢弃日志（即，回到过去），另一个是提交日志（即，所有编辑都应用于实际存储）。
- en: This is the essence of software transactional memory. Each thread maintains
    its own journal. Thus, one thread does not see the edits made by the other before
    committing (because each thread sees only its own journal and the global store,
    but not the journals of other threads). At the same time, each thread gets its
    own consistent view of the world (it sees edits it made, because these are recorded
    in the journal). If the transaction ends successfully, all threads atomically
    see the updated global store. If the transaction aborts, the discarded journal
    takes with it all changes and the state of the thread reverts (modulo global changes
    committed by other threads).
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是软件事务内存的本质。每个线程维护自己的日志。因此，一个线程在提交之前不会看到其他线程所做的编辑（因为每个线程只看到自己的日志和全局存储，而不看其他线程的日志）。同时，每个线程都得到了自己一致的世界视图（它看到了自己所做的编辑，因为这些编辑记录在日志中）。如果事务成功结束，所有线程都会原子地看到更新后的全局存储。如果事务中止，则丢弃的日志会带走所有更改，线程的状态会恢复（除了其他线程提交的全局更改）。
- en: Software transactional memory offers one of the most sensible approaches to
    tackling the difficulties of multi-threaded programming, if we insist on programming
    with shared mutable state. Because most computers have only one global store,
    however, maintaining the journals can be expensive, and much effort goes into
    optimizing them. As an alternative, some hardware architectures have begun to
    provide direct support for transactional memory by making the creation, maintenance,
    and commitment of journals as efficient as using the global store, removing one
    important barrier to the adoption of this idea.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 软件事务内存提供了解决多线程编程困难的最明智方法之一，如果我们坚持使用共享可变状态进行编程。然而，由于大多数计算机只有一个全局存储器，因此维护日志可能会很昂贵，而且需要大量的工作来对其进行优化。作为一种替代方案，一些硬件架构已经开始通过提供直接支持事务内存来使创建、维护和提交日志像使用全局存储一样高效，消除了采用这一想法的一个重要障碍。
- en: Exercise
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Augment the language with the journal features of software transactional memory.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 增加语言的软件事务内存日志功能。
- en: Exercise
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An alternate implementation strategy is to have the environment map names to
    boxed Values. We don’t do it here because it: (a) would be cheating, (b) wouldn’t
    tell us how to implement the same feature in a language without boxes, (c) doesn’t
    necessarily carry over to other mutation operations, and (d) most of all, doesn’t
    really give us insight into what is happening here.'
  id: totrans-339
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一种实现策略是将环境映射名称到装箱的值。我们在这里不这样做是因为：(a) 这将是作弊，(b) 不会告诉我们如何在没有装箱的语言中实现相同的功能，(c)
    不一定适用于其他变异操作，以及 (d) 最重要的是，这并没有真正让我们了解这里发生了什么。
- en: ''
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is nevertheless useful to understand, not least because you may find it a
    useful strategy to adopt when implementing your own language. Therefore, alter
    the implementation to obey this strategy. Do you still need store-passing style?
    Why or why not?
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如此，理解这一点仍然是有用的，至少因为当您实现自己的语言时，您可能会发现这是一个有用的策略。因此，修改实现以遵守这一策略。您是否仍然需要存储传递样式？为什么或为什么不？
- en: 31.4Variables
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31.4变量
- en: 'Now that we’ve got structure mutation worked out, let’s consider the other
    case: variable mutation. We have already discussed ([From Identifiers to Variables](State__Change__and_More_Equality.html#%28part._mutable-variables%29))
    our choice of terminology, and seen examplse of their use in Pyret. In particular,
    Whereas other languages overload the mutation syntax, as we have seen ([Separating
    Meaning from Notation](#%28part._mutation-notation%29)), in Pyret they are kept
    distinct: ! mutates fields of objects while := mutates variables. This forces
    Pyret programmers to confront the distinction we introduced at the beginning of
    [Separating Meaning from Notation](#%28part._mutation-notation%29). We will, of
    course, sidestep these syntactic issues in our core language by using different
    constructs for boxes and for variables.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了结构变异，让我们考虑另一种情况：变量变异。我们已经讨论过（[从标识符到变量](State__Change__and_More_Equality.html#%28part._mutable-variables%29)）我们术语选择，并在Pyret中看到了它们的使用示例。特别是，其他语言会重载变异语法，正如我们所见（[将含义与表示分离](#%28part._mutation-notation%29)），在Pyret中它们保持不同：!
    变异对象的字段，而 := 变异变量。这迫使Pyret程序员面对我们在[将含义与表示分离](#%28part._mutation-notation%29)开头介绍的区别。当然，在我们的核心语言中，我们将通过使用不同的构造来避开这些语法问题，用于箱子和变量。
- en: 31.4.1The Syntax of Variable Assignment
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.4.1变量赋值的语法
- en: 'The first thing to note about variable mutation is that, although it too has
    two sub-terms like box mutation (setboxC), its syntax is fundamentally different.
    To understand why, let’s return to our Java fragment:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量变异的第一件事是，尽管它也有两个子项，就像箱子变异（setboxC）一样，但其语法基本上是不同的。要理解为什么，让我们回到我们的Java片段：
- en: '| x = 3; |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| x = 3; |'
- en: 'In this setting, we cannot write an arbitrary expression in place of x: we
    must literally write the name of the identifier itself. That is because, if it
    were an expression position, then we could evaluate it, yielding a value: for
    instance, if x were previously bound to 1, this would be tantamout to writing
    the following statement:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不能在x的位置写入任意表达式：我们必须直接写入标识符本身的名称。这是因为，如果它是一个表达式位置，那么我们可以对其进行求值，得到一个值：例如，如果x先前绑定到1，这将等同于写入以下语句：
- en: '| 1 = 3; |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 1 = 3; |'
- en: 'But this is, of course, nonsensical! We can’t assign a new value to 1, and
    indeed 1 is pretty much the definition of immutable. What we instead want is to
    find where x is in the store, and change the value held over there.Here’s another
    way to see this. Suppose, in Java, the local variable o is already bound to some
    String object:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 但这显然是荒谬的！我们不能将新值赋给1，实际上1几乎就是不可变的定义。我们真正想要的是找到x在存储中的位置，并更改那里保存的值。另一种看待这个问题的方式是，假设在Java中，局部变量o已经绑定到某个String对象上：
- en: '| o = new String("an initial string"); |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| o = new String("一个初始字符串"); |'
- en: Say the program now executes
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 假设程序现在执行
- en: '| o = new String("a new string"); |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| o = new String("一个新字符串"); |'
- en: 'Is it trying to change the content of the original string ("an initial string")?
    Certainly not: the second assignment intends to leave that original string alone;
    it only wants to change the value that o is referring to, so that subsequent references
    evaluate to this new string ("a new string") object instead.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 它是在尝试改变原始字符串的内容（"一个初始字符串"）吗？当然不是：第二个赋值意图保持原始字符串不变；它只想要改变o所引用的值，以便随后的引用计算出这个新字符串（"一个新字符串"）对象。
- en: 31.4.2Interpreting Variables
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.4.2解释变量
- en: 'We’ll start by reflecting this in our syntax:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的语法中反映这一点：
- en: '[PRE7]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Observe that we’ve jettisoned the box operations, but kept sequencing because
    it’s handy around mutation. Importantly, we’ve now added the setC case, and its
    first sub-term is not an expression but the literal name of a variable. We’ve
    also renamed idC to varC.Because we’ve gotten rid of boxes, we can also get rid
    of the special box values. When the only kind of mutation you have is variables,
    you don’t need new kinds of values.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经放弃了盒子操作，但保留了顺序执行，因为它在突变时很方便。重要的是，我们现在添加了setC情况，它的第一个子项不是表达式，而是一个变量的文字名称。我们还将idC重命名为varC。因为我们摆脱了盒子，所以也可以摆脱特殊的盒子值。当你只有一种突变类型时，你不需要新的值种类。
- en: '[PRE8]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you might imagine, to support variables we need the same store-passing style
    that we’ve seen before ([Interpreting Boxes](#%28part._store-passing-style%29)),
    and for the same reasons. What differs is in precisely how we use it. Because
    sequencing is interpreted in just the same way (observe that the verb for it does
    not depend on boxes versus variables), that leaves us just the variable mutation
    case to handle.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，要支持变量，我们需要与之前所见的相同的存储传递风格（[解释盒子](#%28part._store-passing-style%29)）以及出于同样的原因。不同的是我们如何精确地使用它。因为顺序执行的方式与之前完全相同（请注意，它的动词不取决于盒子还是变量），这样我们就只剩下变量突变的情况需要处理了。
- en: First, we might as well evaluate the value expression and obtain the updated
    store:<mut-var-interp/setC> ::=
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以评估值表达式并获得更新后的存储：<mut-var-interp/setC> ::=
- en: '|   &#124; setC(v, b) => |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; setC(v, b) => |'
- en: '|     new-val = interp(b, nv, st) |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|     new-val = interp(b, nv, st) |'
- en: '|     [<mut-var-interp/setC/core>](#%28elem._mut-var-interp%2Fset.C%2Fcore%29)
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|     [<mut-var-interp/setC/core>](#%28elem._mut-var-interp%2Fset.C%2Fcore%29)
    |'
- en: What now? Remember we just said that we don’t want to fully evaluate the variable,
    because that would just give the value it is bound to. Instead, we want to know
    which memory location it corresponds to, and update what is stored at that memory
    location; this latter part is just the same thing we did when mutating boxes:<mut-var-interp/setC/core>
    ::=
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在怎么办？记得我们刚刚说过我们不想完全评估变量，因为那只会给出它绑定的值。相反，我们想知道它对应哪个内存位置，并更新该内存位置存储的内容；后半部分与我们突变盒子时所做的事情完全相同：<mut-var-interp/setC/core>
    ::=
- en: '|   var-loc = lookup(v, nv) |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|   var-loc = lookup(v, nv) |'
- en: '|   ret(new-val.v, |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|   ret(new-val.v, |'
- en: '|     xtnd-sto(cell(var-loc, new-val.v), new-val.st)) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '|     xtnd-sto(cell(var-loc, new-val.v), new-val.st)) |'
- en: 'The very interesting new pattern we have here is this. When we added boxes,
    in the idC case ([<mut-str-interp/idC>](#%28elem._mut-str-interp%2Fid.C%29)),
    we looked up an identifier in the environment (just as above), and then immediately
    fetched the value at that location from the store; the composition yielded a value,
    just as it used to before we added stores. Now, however, we have a new pattern:
    looking up an identifier in the environment without subsequently fetching its
    value from the store, i.e., we have “half” of a variable’s evaluation. The result
    of invoking just lookup is traditionally called an l-value, for “left-hand-side
    (of an assignment) value”. This is a fancy way of saying “memory address”, and
    stands in contast to the actual values that the store yields: observe that it
    does not directly correspond to anything in the type Value.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个非常有趣的新模式。当我们添加了盒子时，在 idC 的情况下（[<mut-str-interp/idC>](#%28elem._mut-str-interp%2Fid.C%29)），我们在环境中查找标识符（就像上面一样），然后立即从存储中获取该位置处的值；组合产生了一个值，就像我们在添加存储之前一样。然而，现在，我们有一个新的模式：在环境中查找标识符，而不是随后从存储中获取它的值，即，我们只有一个变量评估的“一半”。调用
    lookup 的结果传统上称为左值，表示“赋值的左边值”。这是一种说“内存地址”的花哨方式，并且与存储产生的实际值形成对比：注意它与类型 Value 中的任何内容都没有直接对应。
- en: And we’re done! We did all the hard work when we implemented store-passing style
    (and also in that application allocated new locations for variables).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做完了！我们在实现存储传递样式时做了所有的艰苦工作（并且在那个应用程序中为变量分配新位置时也是如此）。
- en: 31.4.3Reference Parameter Passing
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.4.3 引用参数传递
- en: 'Let’s return to the parenthetical statement above: that every application allocates
    a fresh location in the store for the parameter.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上面的括号语句：每个应用程序为参数分配一个新的存储位置。
- en: Do Now!
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在做！
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Why does this matter? Consider the following Pyret program:'
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这为什么重要？考虑以下 Pyret 程序：
- en: ''
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-376
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: After this runs, what do we expect to be the value of y?
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行之后，我们期望 y 的值是多少？
- en: In the example above, y evaluates to 5, not 3. That is because the value of
    the formal parameter x is held at a different location than that of the actual
    parameter y, so the mutation affects the location of x, leaving y unscathed.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，y 的评估结果为 5，而不是 3。这是因为形式参数 x 的值保存在与实际参数 y 不同的位置，因此突变影响了 x 的位置，而 y 并未受到影响。
- en: 'Now suppose, instead, that application behaved as follows. When the actual
    parameter is a variable, and hence has a location in memory, instead of allocating
    a new location for the value, it simply passes along the existing one for the
    variable. Now the formal parameter is referring to the same store location as
    the actual: i.e., they are variable aliases. Thus any mutation on the formal will
    leak back out into the calling context; the above program would evaluate to 3
    rather than 5. These is called a call-by-reference parameter-passing strategy.Instead,
    our interpreter implements call-by-value, and this is the same strategy followed
    by languages like Java. This causes confusion because when the value is itself
    mutable, changes made to the value in the callee are observed by the caller. However,
    that is simply an artifact of mutable values, not of the calling strategy. Please
    avoid this confusion!'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设，相反地，应用程序的行为如下。当实际参数是一个变量时，因此在内存中有一个位置时，它不是为值分配一个新的位置，而是简单地传递变量的现有位置。现在形式参数引用的是与实际参数相同的存储位置：即，它们是变量别名。因此，对形式参数的任何突变都会泄漏到调用上下文中；上面的程序将评估为
    3 而不是 5。这称为引用参数传递策略。相反，我们的解释器实现了按值调用，这是像 Java 这样的语言所遵循的相同策略。这会引起混淆，因为当值本身是可变的时，调用者会观察到在被调用者中对值所做的更改。然而，这只是可变值的一个副作用，而不是调用策略的副作用。请避免这种混淆！
- en: 'For some years, this power was considered a good idea. It was useful because
    programmers could write abstractions such as swap, which swaps the value of two
    variables in the caller. However, the disadvantages greatly outweigh the advantages:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，这种方法被认为是一个好主意。这是有用的，因为程序员可以编写抽象，比如 swap，它交换调用者的两个变量的值。然而，缺点远远超过了优点：
- en: A careless programmer can alias a variable in the caller and modify it without
    realizing they have done so, and the caller may not even realize this has happened
    until some obscure condition triggers it.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个粗心的程序员可以在调用者中创建一个变量的别名并修改它，而不知道他们已经这样做了，调用者甚至可能不会意识到发生了这种情况，直到一些隐晦的条件触发它。
- en: 'Some people thought this was necessary for efficiency: they assumed the alternative
    was to copy large data structures. However, call-by-value is compatible with passing
    just the address of the data structure. You only need make a copy if (a) the data
    structure is mutable, (b) you do not want the caller to be able to mutate it,
    and (c) the language does not itself provide immutability annotations or other
    mechanisms.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人认为这是为了效率而必要的：他们认为替代方案是复制大型数据结构。然而，传值调用与仅传递数据结构的地址是兼容的。只有在（a）数据结构是可变的，（b）您不希望调用方能够对其进行变异，以及（c）语言本身没有提供不可变性注释或其他机制时，您才需要复制。
- en: 'It can force non-local and hence non-modular reasoning. For instance, suppose
    we have the procedure:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以强制进行非本地和因此非模块化的推理。例如，假设我们有以下过程：
- en: '[PRE10]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the language were to permit by-reference parameter passing, then the programmer
    cannot locally—<wbr>i.e., just from the above code—<wbr>determine what the value
    of x will be in the ellipses, because it depends on precisely who the callee (which
    is being passed in as a parameter) will be, and what it might do, which in turn
    may depend on dynamic conditions (including the phase of the moon).
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果语言允许按引用传递参数，那么程序员不能在本地—<wbr>即仅从上述代码—<wbr>确定椭圆中 x 的值，因为它取决于被调用方（作为参数传递）将是谁，以及它可能会做什么，这反过来可能取决于动态条件（包括月相）。
- en: At the very least, then, if the language is going to permit by-reference parameters,
    it should let the caller determine whether to pass the reference—<wbr>i.e., let
    the callee share the memory address of the caller’s variable—<wbr>or not. However,
    even this option is not quite as attractive as it may sound, because now the callee
    faces a symmetric problem, not knowing whether its parameters are aliased or not.
    In traditional, sequential programs this is less of a concern, but if the procedure
    is reentrant, the callee faces precisely the same predicaments.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 最起码，如果语言要允许按引用传递参数，它应该让调用方确定是否传递引用—<wbr>即让被调用方共享调用方变量的内存地址—<wbr>或不传递。然而，即使这个选项听起来并不那么吸引人，因为现在被调用方面临着对称的问题，不知道它的参数是否被别名。在传统的、顺序的程序中，这不是那么值得关注，但如果过程是可重入的，被调用方面临着完全相同的困境。
- en: At some point, therefore, we should consider whether any of this fuss is worthwhile.
    Instead, callers who want the callee to perform a mutation could simply send a
    boxed value to the callee. The box signals that the caller accepts—<wbr>indeed,
    invites—<wbr>the callee to perform a mutation, and the caller can extract the
    value when it’s done. This does obviate the ability to write a simple swapper,
    but that’s a small price to pay for genuine software engineering concerns.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该考虑是否值得进行所有这些麻烦。相反，想要被调用方执行变异的调用方只需将一个封装值发送给被调用方。这个盒子表示调用方接受—<wbr>实际上，邀请—<wbr>被调用方执行变异，调用方在完成时可以提取值。这确实取消了编写简单交换程序的能力，但这是为了真正的软件工程问题所付出的小代价。
- en: 31.5The Design of Stateful Language Operations
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31.5有状态语言操作的设计
- en: 'Though most programming languages include one or both kinds of state we have
    studied, their admission should not be regarded as a trivial or foregone matter.
    On the one hand, state brings some vital benefits:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数编程语言包括我们研究过的一种或两种状态，但它们的允许不应该被视为一个微不足道的或既定的问题。一方面，状态带来了一些重要的好处：
- en: 'State provides a form of modularity. As our very interpreter demonstrates,
    without explicit stateful operations, to achieve the same effect:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态提供了一种模块化的形式。正如我们的解释器所展示的那样，如果没有显式的状态操作，要实现相同的效果：
- en: We would need to add explicit parameters and return values that pass the equivalent
    of the store around.
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要添加明确的参数和返回值，以传递等效于存储的内容。
- en: These changes would have to be made to all procedures that may be involved in
    a communication path between producers and consumers of state.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些更改必须应用到可能涉及生产者和消费者之间通信路径的所有过程中。
- en: Thus, a different way to think of state in a programming language is that it
    is an implicit parameter already passed to and returned from all procedures, without
    imposing that burden on the programmer. This enables procedures to communicate
    “at a distance” without all the intermediaries having to be aware of the communication.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，思考编程语言中状态的另一种方式是，它是一个隐式参数，已经传递给所有过程并从中返回，而不会将这种负担加在程序员身上。这使得过程能够在“距离”上进行通信，而不需要所有中介都意识到通信。
- en: State makes it possible to construct dynamic, cyclic data structures, or at
    least to do so in a relatively straightforward manner ([Graphs](graphs.html)).
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态使得可以构建动态、循环的数据结构，或者至少以相对直接的方式进行构建（[图表](graphs.html)）。
- en: State gives procedures memory, such as new-loc above. If a procedure could not
    remember things for itself, the callers would need to perform the remembering
    on its behalf, employing the moral equivalent of (at least local) store-passing.
    This is not only unwieldy, it creates the potential for a caller to interfere
    with the memory for its own nefarious purposes (e.g., a caller might purposely
    send back an old store, thereby obtaining a reference already granted to some
    other party, through which it might launch a correctness or security attack).
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态给予过程内存，例如上面的 new-loc。如果一个过程不能为自己记忆事物，调用者将需要代表其执行记忆，采用（至少是局部的）存储传递的道德等价物。这不仅笨拙，而且会为调用者干扰其内存提供潜在可能性，以用于其自身的邪恶目的（例如，调用者可能故意发送回旧存储，从而获取已授予其他一方的引用，通过这个引用可能发起正确性或安全性攻击）。
- en: On the other hand, state imposes real costs on programmers as well as on programs
    that process programs (such as compilers). One is “aliasing”, which we discuss
    later [REF]. Another is “referential transparency”, which too I hope to return
    to [REF]. Finally, we have described above how state provides a form of modularity.
    However, this same description could be viewed as that of a back-channel of communication
    that the intermediaries did not know and could not monitor. In some (especially
    security and distributed system) settings, such back-channels can lead to collusion,
    and can hence be extremely dangerous and undesirable.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，状态对程序员和处理程序的程序（如编译器）都产生了实际成本。一个是“别名”，我们稍后会讨论[REF]。另一个是“引用透明性”，我也希望能够回到[REF]。最后，我们已经描述了状态如何提供一种模块化形式。然而，同样的描述也可以被视为中间人不知道且无法监视的后门通信。在某些（特别是安全和分布式系统）设置中，这种后门通信可能导致勾结，并因此极其危险和不可取。
- en: Because there is no optimal answer, it is probably wise to include mutation
    operators but to carefully delinate them. In Standard ML, for instance, there
    is no variable mutation, because it is considered unnecessary. Instead, the language
    has the equivalent of boxes (called refs). One can easily simulate variables using
    boxes, so no expressive power is lost, though it does create more potential for
    aliasing than variables alone would have ([REF aliasing]) if the boxes are not
    used carefully.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有最佳答案，所以可能明智的做法是包含变异运算符，但要仔细界定它们。例如，在标准 ML 中，没有变量变异，因为认为这是不必要的。相反，语言具有盒子的等效物（称为
    refs）。可以使用盒子轻松模拟变量，因此不会丢失表现力，尽管这会比仅使用变量产生更多的别名潜在问题（[REF aliasing]），如果不小心使用盒子的话。
- en: 'In return, however, developers obtain expressive types: every data structure
    is considered immutable unless it contains a ref, and the presence of a ref is
    a warning to both developers and programs (such as compilers) that the underlying
    value may keep changing.This same argument applies to Pyret, where the absence
    of a ref declaration means that a field is immutable, and the absence of a var
    declaration means an identifier is immutable, i.e., not a variable. Thus, for
    instance, suppose b is a box and v is bound to the unboxing of b. A developer
    should be aware that replacing all instances of the unboxing b with references
    to v is not safe, because the former always fetches the current value in the box
    while the latter holds the value only at the instant when v was computed, and
    may now be inconsistent. The declaration that a field is mutable provides this
    information to both the developer and to programming tools (such as compilers);
    in particular, the absence of such a declaration permits caching of values, thereby
    trading computation time for space.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发者在此过程中获得了表现力强的类型：每个数据结构都被视为不可变，除非它包含一个 ref，并且 ref 的存在是对开发者和程序（如编译器）的警告，表明底层值可能会不断变化。同样的论点适用于
    Pyret，在那里，缺少 ref 声明意味着字段是不可变的，缺少 var 声明意味着标识符是不可变的，即不是变量。因此，例如，假设 b 是一个盒子，并且 v
    绑定到 b 的解箱。开发者应意识到，将所有解箱 b 的实例替换为对 v 的引用是不安全的，因为前者总是获取盒子中的当前值，而后者仅在计算 v 时保持值，并且现在可能不一致。字段可变的声明向开发者和编程工具（如编译器）提供了这些信息；特别是，缺少这样的声明允许缓存值，从而以计算时间换取空间。
- en: 31.6Typing State
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31.6 类型化状态
- en: 'Adding stateful operations to a type-checker is easy: the only safe thing to
    do is make sure the type of the new value is exactly the same as that of the old
    one. If that is true, the behavior of the program will be indistinguishable to
    the type system before and after the mutation. That is, it is safest to follow
    invariance ([The Principle of Substitutability](types.html#%28part._type-substitutability%29)).'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 向类型检查器添加有状态操作很容易：唯一安全的做法是确保新值的类型与旧值完全相同。如果是这样，程序的行为在突变之前和之后对类型系统来说是不可区分的。也就是说，最安全的做法是遵循不变性（[替换原则](types.html#%28part._type-substitutability%29)）。
- en: 31.6.1Mutation and Polymorphism
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.6.1突变和多态性
- en: 'Later, once we encounter subtyping ([Subtyping](objects.html#%28part._subtyping%29)),
    we will find it is no longer trivial to type mutation. Already, however, mutation
    is complex in the presence of polymorphism. Let us first give polymorphic types
    to boxes, where Box is a type constructor for boxes:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，一旦我们遇到子类型（[子类型](objects.html#%28part._subtyping%29)），我们会发现在对突变进行类型化不再是微不足道的。但是，在多态性存在的情况下，突变已经很复杂了。让我们先给盒子赋予多态类型，其中Box是盒子的类型构造器：
- en: '[PRE11]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (assuming that the mutation operation, set-box, returns the box as its result).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: （假设突变操作set-box将盒子作为其结果返回）。
- en: Exercise
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the above three functions.
  id: totrans-408
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现上述三个函数。
- en: 'Now let us consider a simple example that uses these:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个使用这些方法的简单示例：
- en: '[PRE12]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initially, the type of f is Box((A -> A)) where (A -> A) represents the type
    of the polymorphic identity function. When performing inference, a copy of this
    type certainly unifies with Number -> Number, the type of lam(x): x + 5 end. Another
    copy is used at the application site; the argument type unifies with that of true,
    giving the whole expression the type Boolean. However, when the actual function
    is applied, it attempts to add true to 5, resulting in a run-time error. If the
    compiler had assumed the type-system was sound and had not compiled in checks,
    this program could even result in a segmentation fault.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '最初，f的类型是Box((A -> A))，其中(A -> A)表示多态身份函数的类型。在进行推断时，该类型的副本肯定与Number -> Number统一，这是lam(x):
    x + 5 end的类型。另一个副本用于应用位置；参数类型与true的类型统一，给整个表达式赋予Boolean类型。然而，当实际函数被应用时，它尝试将true加到5上，导致运行时错误。如果编译器假设类型系统是合理的，并且没有编译检查，这个程序甚至可能导致分段错误。'
- en: There are many ways to try to understand this problem, which is beyond the scope
    of this study. The simplest way is that polymorphism and mutation do not work
    together well. The essence of polymorphism is to imagine a quantified type is
    instantiated at each use; however, the essence of mutation is to silently transmit
    values from one part of the program to the other. Thus, the values being unified
    at two different sites are only guaranteed to be compatible with the let-bound
    identifier—<wbr>not with each other. This is normally not a problem because the
    two do not communicate directly, except where mutation is involved. Therefore,
    a simple solution in this case is to prevent polymorphic generalization for mutable
    let-bound identifiers.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以尝试理解这个问题，这超出了本研究的范围。最简单的方法是多态性和突变不太搭配。多态的本质是想象一个量化类型在每次使用时被实例化；然而，突变的本质是在程序的一部分和另一部分之间悄悄传递值。因此，在两个不同位置统一的值只保证与let-bound标识符兼容，而不是彼此兼容。这通常不是问题，因为两者不直接通信，除非涉及突变。因此，在这种情况下的一个简单解决方案是防止对可变let-bound标识符进行多态泛化。
- en: 31.6.2Typing the Initial Value
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.6.2初始值的类型化
- en: 'There is one last issue we should address where mutation is concerned: the
    typing of cycle creation, and in particular dealing with the problem of [Premature
    Evaluation](State__Change__and_More_Equality.html#%28part._premature-eval%29).
    We have discussed several approaches to handling the initial value; each of these
    has consequences for typing:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个问题与突变有关，我们应该解决：创建循环的类型化，特别是处理[过早评估](State__Change__and_More_Equality.html#%28part._premature-eval%29)的问题。我们已经讨论了处理初始值的几种方法；每种方法都会影响到类型化：
- en: Using a fixed initial value of a standard type means the value subsequently
    mutated into place may not be type-compatible, thereby failing invariance.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准类型的固定初始值意味着随后突变到位的值可能不兼容类型，从而违反不变性。
- en: Using a different initial value of the type that will eventually be put into
    the mutable has the problem that prematurely observing it is even more deadly,
    because it may not be distinguishable from the eventual value.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最终将放入可变对象的类型的不同初始值存在一个问题，即过早观察它甚至更加致命，因为它可能无法与最终值区分开来。
- en: Using a new value just for this case works provided there is one of each type.
    Otherwise, again, we violate invariance. But having one of each type is a problem
    in itself, because now the run-time system has to check for all of them.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个新值仅适用于这种情况，前提是每种类型都有一个。否则，我们再次违反了不变性。但是每种类型都有一个本身就是一个问题，因为现在运行时系统必须检查所有这些类型。
- en: Syntactically restricting recursion to functions is the safest, because the
    initial value is never seen. As a result, there is no need to provide any meaningful
    type for it.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在语法上将递归限制为函数是最安全的，因为初始值永远不会被看到。因此，不需要为其提供任何有意义的类型。
- en: In short, this is a place where we have to confront unsurmountable trade-offs.
    The first option sacrifices typability; the second option sacrifices program reliability
    (because the dummy values are of the right type, and may hence be inadvertently
    used without noticing they are wrong); the third sacrifices run-time simplicity;
    and the fourth sacrifices programmer flexibility.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是一个我们不得不面对不可逾越的权衡的地方。第一种选择牺牲了可类型化性；第二种选择牺牲了程序的可靠性（因为虚拟值是正确类型的，因此可能在不知情的情况下被无意中使用）；第三种选择牺牲了运行时的简单性；第四种选择牺牲了程序员的灵活性。
