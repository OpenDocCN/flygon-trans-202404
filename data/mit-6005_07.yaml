- en: 'Reading 7: Designing Specifications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读7：设计规范
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 免受错误困扰 | 易于理解 | 为变化做好准备 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确，未来也正确。 | 与未来的程序员清晰沟通，包括未来的你。 | 设计以适应变化而无需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: Understand underdetermined specs, and be able to identify and assess nondeterminism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解未决定规范，并能够识别和评估非确定性
- en: Understand declarative vs. operational specs, and be able to write declarative
    specs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解声明性与操作性规范，并能够编写声明性规范
- en: Understand strength of preconditions, postconditions, and specs; and be able
    to compare spec strength
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解前置条件、后置条件和规范的强度，并能够比较规范的强度
- en: Be able to write coherent, useful specifications of appropriate strength
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编写连贯、有用的适当强度的规范
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,introduction/qtzCnF3-GJw)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,introduction/qtzCnF3-GJw)'
- en: 'In this reading we’ll look at different specs for similar behaviors, and talk
    about the tradeoffs between them. We’ll look at three dimensions for comparing
    specs:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇阅读中，我们将看看类似行为的不同规范，并讨论它们之间的权衡。我们将从三个维度来比较规范：
- en: How **deterministic** it is. Does the spec define only a single possible output
    for a given input, or allow the implementor to choose from a set of legal outputs?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有多少**确定性**。规范是否仅为给定输入定义了单一可能的输出，还是允许实现者从一组合法输出中选择？
- en: How **declarative** it is. Does the spec just characterize *what* the output
    should be, or does it explicitly say *how* to compute the output?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有多么**声明性**。规范是否只是描述输出应该是什么，还是明确说明了如何计算输出？
- en: How **strong** it is. Does the spec have a small set of legal implementations,
    or a large set?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有多么**强**。规范是否有一个小的合法实现集合，还是一个大的集合？
- en: Not all specifications we might choose for a module are equally useful, and
    we’ll explore what makes some specifications better than others.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并非我们可能为一个模块选择的所有规范都同样有用，我们将探讨什么使一些规范比其他规范更好。
- en: Deterministic vs. underdetermined specs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定性与未决定性规范
- en: 'Recall the two example implementations of `find` we began with in the [previous
    reading](../06-specifications/):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在[上一篇阅读](../06-specifications/)中开始的`find`的两个示例实现：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The subscripts `[First]` and `[Last]` are not actual Java syntax. We’re using
    them here to distinguish the two implementations for the sake of discussion. In
    the actual code, both implementations should be Java methods called `find`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下标`[First]`和`[Last]`不是实际的Java语法。我们在这里使用它们是为了区分两种实现以便讨论。在实际的代码中，这两种实现都应该是名为`find`的Java方法。
- en: 'Here is one possible specification of `find`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`find`的一种可能的规范：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This specification is **deterministic**: when presented with a state satisfying
    the precondition, the outcome is completely determined. Only one return value
    and one final state is possible. There are no valid inputs for which there is
    more than one valid output.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范是**确定性的**：当提供满足前置条件的状态时，结果是完全确定的。只有一个返回值和一个最终状态是可能的。没有有效输入会导致多个有效输出。
- en: Both `find[First]` and `find[Last]` satisfy the specification, so if this is
    the specification on which the clients relied, the two implementations are equivalent
    and substitutable for one another.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`find[First]`和`find[Last]`都满足规范，因此如果这是客户所依赖的规范，那么这两个实现是等效的，并可以相互替代。'
- en: 'Here is a slightly different specification:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个略有不同的规范：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This specification is not deterministic. It doesn’t say which index is returned
    if `val` occurs more than once. It simply says that if you look up the entry at
    the index given by the returned value, you’ll find `val`. This specification allows
    multiple valid outputs for the same input.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范不是确定性的。它没有说明如果`val`出现多次则返回哪个索引。它只是说，如果你查找由返回值给出的索引的条目，你会找到`val`。这个规范允许同一输入有多个有效输出。
- en: Note that this is different from *nondeterministic* in the usual sense of that
    word. Nondeterministic code sometimes behaves one way and sometimes another, even
    if called in the same program with the same inputs. This can happen, for example,
    when the code’s behavior depends on a random number, or when it depends on the
    timing of concurrent processes. But a specification which is not deterministic
    doesn’t have to have a nondeterministic implementation. It can be satisfied by
    a fully deterministic implementation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与通常意义上的*不确定性*是不同的。不确定性代码有时表现一种方式，有时表现另一种方式，即使在同一程序中使用相同的输入调用。例如，当代码的行为依赖于随机数或依赖于并发进程的时间时，就会发生这种情况。但是，一个不确定的规范并不一定要有一个非确定性的实现。它可以由一个完全确定性的实现满足。
- en: To avoid the confusion, we’ll refer to specifications that are not deterministic
    as **underdetermined**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，我们将不确定的规范称为**未决定性**。
- en: This underdetermined `find` spec is again satisfied by both `find[First]` and
    `find[Last]`, each resolving the underdeterminedness in its own (fully deterministic)
    way. A client of `find[OneOrMore,AnyIndex]` spec can’t rely on which index will
    be returned if `val` appears more than once. The spec would be satisfied by a
    nondeterministic implementation, too — for example, one that tosses a coin to
    decide whether to start searching from the beginning or the end of the array.
    But in almost all cases we’ll encounter, underdeterminism in specifications offers
    a choice that is made by the implementor at implementation time. An underdetermined
    spec is typically implemented by a fully-deterministic implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`find`规范的**未决定性（underdetermined）**版本同样被`find[First]`和`find[Last]`所满足，每个都以自己的方式（完全确定的方式）解决了未决定性。如果`val`出现多次，那么`find[OneOrMore,AnyIndex]`规范的客户端不能依赖于返回哪个索引。该规范也可以被一个非确定性的实现所满足，例如，一个根据抛硬币来决定是从数组的开始还是末尾开始搜索的实现。但在我们遇到的几乎所有情况下，规范中的未决定性都提供了一个由实现者在实现时进行选择的选项。未决定性规范通常由完全确定性的实现来实现。
- en: reading exercises
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Distinguished
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的
- en: 'With the same two implementations from above:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与上述相同的两个实现：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Consider this spec:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个规范：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Over/under
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 过度/不足
- en: 'Previously we saw this underdetermined version of the `find` specification:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到了`find`规范的这个未决定版本：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This spec allows multiple possible return values for arrays with duplicate values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范允许对于具有重复值的数组有多个可能的返回值。
- en: For each spec below, say whether it is *less* fully-determined than `find[OneOrMore,AnyIndex]`,
    *more* fully-determined, or deterministic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的每个规范，说它是否比`find[OneOrMore,AnyIndex]`*更*未决定，*更*确定，还是确定的。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Declarative vs. operational specs
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式与操作性规范
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,declarative_vs_operational_specs/nFmrlOPBbE0)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,declarative_vs_operational_specs/nFmrlOPBbE0)'
- en: Roughly speaking, there are two kinds of specifications. *Operational* specifications
    give a series of steps that the method performs; pseudocode descriptions are operational.
    *Declarative* specifications don’t give details of intermediate steps. Instead,
    they just give properties of the final outcome, and how it’s related to the initial
    state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，有两种规范。*操作性*规范给出了方法执行的一系列步骤；伪代码描述是操作性的。*声明式*规范不提供中间步骤的细节。相反，它们只给出最终结果的属性，以及它与初始状态的关系。
- en: Almost always, declarative specifications are preferable. They’re usually shorter,
    easier to understand, and most importantly, they don’t inadvertently expose implementation
    details that a client may rely on (and then find no longer hold when the implementation
    is changed). For example, if we want to allow either implementation of `find`,
    we would *not* want to say in the spec that the method “goes down the array until
    it finds `val`,” since aside from being rather vague, this spec suggests that
    the search proceeds from lower to higher indices and that the lowest will be returned,
    which perhaps the specifier did not intend.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是，声明性规范更可取。它们通常更短，更容易理解，而且最重要的是，它们不会无意中暴露客户可能依赖的实现细节（然后发现在更改实现时不再有效）。例如，如果我们想要允许
    `find` 的任一实现，我们就不会希望在规范中说方法“沿着数组找到 `val`”，因为除了非常模糊外，这个规范暗示着搜索是从较低索引到较高索引进行的，并且会返回最低值，这也许不是规范者的意图。
- en: One reason programmers sometimes lapse into operational specifications is because
    they’re using the spec comment to explain the implementation for a maintainer.
    Don’t do that. When it’s necessary, use comments within the body of the method,
    not in the spec comment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员有时候会陷入操作规范，是因为他们在规范注释中为维护者解释实现方式。不要这样做。当有必要时，在方法体内使用注释，而不是在规范注释中。
- en: 'For a given specification, there may be many ways to express it declaratively:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的规范，可能有多种方式来声明它：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It’s up to us to choose the clearest specification for clients and maintainers
    of the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 选择对客户和代码维护者最清晰的规范是我们的责任。
- en: reading exercises
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Joint declaration
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 联合声明
- en: 'Given this specification:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个规范：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Stronger vs. weaker specs
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更强 vs. 更弱的规范
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,stronger_vs_weaker_specs/Du57bZsp3gE)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,stronger_vs_weaker_specs/Du57bZsp3gE)'
- en: Suppose you want to change a method – either how its implementation behaves,
    or the specification itself. There are already clients that depend on the method’s
    current specification. How do you compare the behaviors of two specifications
    to decide whether it’s safe to replace the old spec with the new spec?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要改变一个方法——无论是其实现的行为还是规范本身。已经有客户端依赖于方法的当前规范。如何比较两个规范的行为，以决定是否安全地用新规范替换旧规范？
- en: A specification S2 is stronger than or equal to a specification S1 if
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规范 S2 强于或等于规范 S1，那么
- en: S2’s precondition is weaker than or equal to S1’s,
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S2 的前置条件比 S1 的要弱或者相等，
- en: and
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和
- en: S2’s postcondition is stronger than or equal to S1’s, for the states that satisfy
    S1’s precondition.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于满足 S1 的前置条件的状态，S2 的后置条件比 S1 的要强或者相等。
- en: If this is the case, then an implementation that satisfies S2 can be used to
    satisfy S1 as well, and it’s safe to replace S1 with S2 in your program.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，那么一个满足 S2 的实现也可以用来满足 S1，并且可以安全地用 S2 替换 S1 在你的程序中。
- en: These two rules embody several ideas. They tell you that you can always weaken
    the precondition; placing fewer demands on a client will never upset them. And
    you can always strengthen the post-condition, which means making more promises.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条规则包含了几个观点。它们告诉你，你总是可以弱化前置条件；对客户提出较少要求永远不会让他们感到不满。而且你总是可以加强后置条件，这意味着可以做更多承诺。
- en: 'For example, this spec for `find`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，对于 `find` 的这个规范：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'can be replaced with:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被替换为：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'which has a weaker precondition. This in turn can be replaced with:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 具有更弱前置条件。这反过来又可以被替换为：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: which has a stronger postcondition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 具有更强后置条件。
- en: 'What about this specification:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个规范，有什么想法：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ll come back to `find[CanBeMissing]` in the exercises.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在练习中回到 `find[CanBeMissing]`。
- en: '## Diagramming specifications'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '## 绘制规范图表'
- en: Imagine (very abstractly) the space of all possible Java methods.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象（非常抽象地）所有可能的 Java 方法的空间。
- en: Each point in this space represents a method implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空间中的每个点代表一个方法实现。
- en: First we’ll diagram `find[First]` and `find[Last]` defined [above](#deterministic_vs_underdetermined_specs).
    Look back at the code and see that `find[First]` and `find[Last]` are *not specs*.
    They are implementations, with method bodies that implement their actual behavior.
    So we denote them as points in the space.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将绘制在[上面](#deterministic_vs_underdetermined_specs)定义的 `find[First]` 和 `find[Last]`。回顾代码，看到
    `find[First]` 和 `find[Last]` 不是规范。它们是实现，具有实现其实际行为的方法体。因此我们将它们表示为空间中的点。
- en: A specification defines a *region* in the space of all possible implementations.
    A given implementation either behaves according to the spec, satisfying the precondition-implies-postcondition
    contract (it is inside the region), or it does not (outside the region).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个规范在所有可能实现的空间中定义了一个*区域*。给定的实现要么按照规范行为，满足前置条件蕴含后置条件的契约（它在区域内），要么不满足（在区域外）。
- en: Both `find[First]` and `find[Last]` satisfy `find[OneOrMore,AnyIndex]`, so they
    are inside the region defined by that spec.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`find[First]` 和 `find[Last]` 都满足 `find[OneOrMore,AnyIndex]`，因此它们位于该规范定义的区域内。'
- en: 'We can imagine clients looking in on this space: the specification acts as
    a firewall.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象客户端在这个空间中观察：规范就像一个防火墙。
- en: Implementors have the freedom to move around inside the spec, changing their
    code without fear of upsetting a client. This is crucial in order for the implementor
    to be able to improve the performance of their algorithm, the clarity of their
    code, or to change their approach when they discover a bug, etc.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现者可以在规范内部自由移动，改变他们的代码而不必担心影响客户。这对于实现者能够改进算法性能、代码清晰度或在发现错误时改变方法等方面至关重要。
- en: Clients don’t know which implementation they will get. They must respect the
    spec, but also have the freedom to change how they’re using the implementation
    without fear that it will suddenly break.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端不知道他们将得到哪种实现。他们必须尊重规范，但也有自由更改他们使用实现的方式，而不必担心它会突然出现问题。
- en: How will similar specifications relate to one another? Suppose we start with
    specification S1 and use it to create a new specification S2.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的规范如何相互关联？假设我们从规范 S1 开始，并使用它创建一个新规范 S2。
- en: If S2 is stronger than S1, how will these specs appear in our diagram?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 S2 比 S1 更强，这些规范在我们的图表中会如何呈现？
- en: Let’s start by **strengthening the postcondition**. If S2’s postcondition is
    now stronger than S1’s postcondition, then S2 is the stronger specification.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们从**增强后置条件**开始。如果 S2 的后置条件现在比 S1 的后置条件更强，那么 S2 就是更强的规范。
- en: 'Think about what strengthening the postcondition means for implementors: it
    means they have less freedom, the requirements on their output are stronger. Perhaps
    they previously satisfied `find[OneOrMore,AnyIndex]` by returning any index `i`,
    but now the spec demands the *lowest* index `i`. So there are now implementations
    *inside* `find[OneOrMore,AnyIndex]` but *outside* `find[OneOrMore,FirstIndex]`.'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想想增强后置条件对于实现者意味着什么：这意味着他们的自由度更小，对于他们输出的要求更强。也许他们之前通过返回任何索引 `i` 来满足 `find[OneOrMore,AnyIndex]`，但现在规范要求返回*最低*索引
    `i`。因此现在有实现位于 `find[OneOrMore,AnyIndex]` 但位于 `find[OneOrMore,FirstIndex]` 之外。
- en: Could there be implementations *inside* `find[OneOrMore,FirstIndex]` but *outside*
    `find[OneOrMore,AnyIndex]`? No. All of those implementations satisfy a stronger
    postcondition than what `find[OneOrMore,AnyIndex]` demands.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否可能有实现位于 `find[OneOrMore,FirstIndex]` 内部但位于 `find[OneOrMore,AnyIndex]` 外部？不可能。所有这些实现都满足比
    `find[OneOrMore,AnyIndex]` 要求更强的后置条件。
- en: Think through what happens if we **weaken the precondition**, which will again
    make S2 a stronger specification. Implementations will have to handle new inputs
    that were previously excluded by the spec. If they behaved badly on those inputs
    before, we wouldn’t have noticed, but now their bad behavior is exposed.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想一想如果**减弱前置条件**会发生什么，这将再次使 S2 成为更强的规范。实现者将不得不处理先前由规范排除的新输入。如果它们之前在这些输入上表现不佳，我们可能没有注意到，但现在它们的不良行为暴露出来了。
- en: We see that when S2 is stronger than S1, it defines a *smaller* region in this
    diagram; a weaker specification defines a larger region.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到当 S2 比 S1 更强时，在这个图表中它定义了一个*更小*的区域；一个较弱的规范定义了一个更大的区域。
- en: In our figure, since `find[Last]` iterates from the end of the array `arr`,
    it does not satisfy `find[OneOrMore,FirstIndex]` and is outside that region.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图中，由于 `find[Last]` 从数组 `arr` 的末尾开始迭代，它不满足 `find[OneOrMore,FirstIndex]`，并且位于该区域之外。
- en: Another specification S3 that is neither stronger nor weaker than S1 might overlap
    (such that there exist implementations that satisfy only S1, only S3, and both
    S1 and S3) or might be disjoint. In both cases, S1 and S3 are incomparable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个规范S3既不比S1强也不比S1弱，可能会重叠（存在仅满足S1、仅满足S3和同时满足S1和S3的实现）或者可能是不相交的。在这两种情况下，S1和S3是不可比较的。
- en: '#### reading exercises'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 阅读练习'
- en: Bulking up(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 增加(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Strength is truth(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 力量是真实的(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Finding findExactlyOne
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找findExactlyOne
- en: 'Here are the `find` specifications again:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次是`find`的规范：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We already know that `find[OneOrMore,FirstIndex]` is stronger than `find[OneOrMore,AnyIndex]`,
    which is stronger than `find[ExactlyOne]`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道`find[OneOrMore,FirstIndex]`比`find[OneOrMore,AnyIndex]`强，后者比`find[ExactlyOne]`强。
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Finding findCanBeMissing
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找findCanBeMissing
- en: Let’s determine where `find[CanBeMissing]` is on the diagram.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确定图表上`find[CanBeMissing]`的位置。
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Found(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 找到(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Designing good specifications
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计良好的规范
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,designing_good_specifications/aQDLg2_nU9s)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,designing_good_specifications/aQDLg2_nU9s)'
- en: What makes a good method? Designing a method means primarily writing a specification.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是一个好的方法？设计一个方法主要意味着编写规范。
- en: 'About the form of the specification: it should obviously be succinct, clear,
    and well-structured, so that it’s easy to read.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于规范的形式：显然应该简洁、清晰和结构良好，以便阅读。
- en: The content of the specification, however, is harder to prescribe. There are
    no infallible rules, but there are some useful guidelines.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，规范的内容更难规定。没有绝对的规则，但有一些有用的指导原则。
- en: The specification should be coherent
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范应该是连贯的
- en: 'The spec shouldn’t have lots of different cases. Long argument lists, deeply
    nested if-statements, and boolean flags are all signs of trouble. Consider this
    specification:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 规范不应该有很多不同的情况。长参数列表、深度嵌套的if语句和布尔标志都是麻烦的迹象。考虑这个规范：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Is this a well-designed procedure? Probably not: it’s incoherent, since it
    does several things (finding in two arrays and summing the indexes) that are not
    really related. It would be better to use two separate procedures, one that finds
    the indexes, and the other that sums them.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个设计良好的过程吗？可能不是：它是不连贯的，因为它做了几件事情（在两个数组中查找并求索引的总和）这些事情并不真正相关。最好使用两个单独的过程，一个用于查找索引，另一个用于求和。
- en: 'Here’s another example, [the `countLongWords` method from *Code Review*](../04-code-review/#countLongWords):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，[来自*Code Review*的`countLongWords`方法](../04-code-review/#countLongWords)：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition to [terrible use of global variables](../04-code-review/#dont_use_global_variables)
    and [printing instead of returning](../04-code-review/#methods_should_return_results_not_print_them),
    the specification is not coherent — it does two different things, counting words
    and finding the longest word.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[糟糕使用全局变量](../04-code-review/#dont_use_global_variables)和[打印而不是返回](../04-code-review/#methods_should_return_results_not_print_them)之外，规范不连贯——它做了两件不同的事情，计算单词数和找到最长的单词。
- en: Separating those two responsibilities into two different methods will make them
    simpler (easy to understand) and more useful in other contexts (ready for change).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个责任分开成两个不同的方法将使它们更简单（易于理解）并且在其他情境中更有用（为变更做好准备）。
- en: The results of a call should be informative
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用的结果应该是有信息的
- en: 'Consider the specification of a method that puts a value in a map, where keys
    are of some type `K` and values are of some type `V`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个将值放入映射中的方法的规范，其中键是某种类型`K`，值是某种类型`V`：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the precondition does not rule out `null` values so the map can store
    `null`s. But the postcondition uses `null` as a special return value for a missing
    key. This means that if `null` is returned, you can’t tell whether the key was
    not bound previously, or whether it was in fact bound to `null`. This is not a
    very good design, because the return value is useless unless you know for sure
    that you didn’t insert `null`s.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前置条件并不排除`null`值，因此映射可以存储`null`。但后置条件将`null`用作缺失键的特殊返回值。这意味着如果返回`null`，你无法确定先前是否未绑定键，还是实际上绑定到了`null`。这不是一个很好的设计，因为返回值是无用的，除非你确定没有插入`null`。
- en: The specification should be strong enough
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范应该足够强大。
- en: Of course the spec should give clients a strong enough guarantee in the general
    case — it needs to satisfy their basic requirements. We must use extra care when
    specifying the special cases, to make sure they don’t undermine what would otherwise
    be a useful method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在一般情况下，规范应该为客户端提供足够强大的保证 - 它需要满足他们的基本要求。在指定特殊情况时，我们必须特别小心，以确保它们不会破坏否则将是一个有用方法的内容。
- en: 'For example, there’s no point throwing an exception for a bad argument but
    allowing arbitrary mutations, because a client won’t be able to determine what
    mutations have actually been made. Here’s a specification illustrating this flaw
    (and also written in an inappropriately operational style):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于一个坏参数抛出异常但允许任意变异是没有意义的，因为客户端将无法确定实际进行了哪些变异。这里有一个说明这个缺陷的规范（也以不恰当的操作风格编写）：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If a `NullPointerException` is thrown, the client is left to figure out on their
    own which elements of `list2` actually made it to `list1`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出`NullPointerException`，客户端将被迫自行确定哪些元素实际上传递到了`list1`。
- en: The specification should also be weak enough
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范也应该足够弱。
- en: 'Consider this specification for a method that opens a file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个打开文件的方法的规范：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is a bad specification. It lacks important details: is the file opened
    for reading or writing? Does it already exist or is it created? And it’s too strong,
    since there’s no way it can guarantee to open a file. The process in which it
    runs may lack permission to open a file, or there might be some problem with the
    file system beyond the control of the program. Instead, the specification should
    say something much weaker: that it attempts to open a file, and if it succeeds,
    the file has certain properties.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个糟糕的规范。它缺乏重要细节：文件是用于读取还是写入？它已经存在还是被创建？而且它太强大了，因为它无法保证打开文件。运行它的过程可能缺乏打开文件的权限，或者可能存在程序无法控制的文件系统问题。相反，规范应该说得更弱：它尝试打开一个文件，如果成功，文件具有某些属性。
- en: The specification should use *abstract types* where possible
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范应尽可能使用*抽象类型*。
- en: We saw early on in the [Java Collections section of *Basic Java*](../02-basic-java/#arraylists_and_linkedlists_creating_lists)
    that we can distinguish between more abstract notions like a `List` or `Set` and
    particular implementations like `ArrayList` or `HashSet`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们早在[Java基础部分的*基本Java*](../02-basic-java/#arraylists_and_linkedlists_creating_lists)中看到，我们可以区分更抽象的概念，如`List`或`Set`和特定实现，如`ArrayList`或`HashSet`。
- en: 'Writing our specification with *abstract types* gives more freedom to both
    the client and the implementor. In Java, this often means using an interface type,
    like `Map` or `Reader`, instead of specific implementation types like `HashMap`
    or `FileReader`. Consider this specification:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*抽象类型*编写我们的规范为客户端和实现者提供了更多自由。在Java中，这通常意味着使用接口类型，如`Map`或`Reader`，而不是具体的实现类型，如`HashMap`或`FileReader`。考虑这个规范：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This forces the client to pass in an `ArrayList`, and forces the implementor
    to return an `ArrayList`, even if there might be alternative `List` implementations
    that they would rather use. Since the behavior of the specification doesn’t depend
    on anything specific about `ArrayList`, it would be better to write this spec
    in terms of the more abstract `List`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使客户端传入`ArrayList`，并迫使实现者返回`ArrayList`，即使可能有他们更愿意使用的其他`List`实现。由于规范的行为与`ArrayList`的特定内容无关，最好以更抽象的`List`形式编写此规范。
- en: Precondition or postcondition?
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前置条件还是后置条件？
- en: Another design issue is whether to use a precondition, and if so, whether the
    method code should attempt to make sure the precondition has been met before proceeding.
    In fact, the most common use of preconditions is to demand a property precisely
    because it would be hard or expensive for the method to check it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个设计问题是是否使用先决条件，以及如果使用，则方法代码是否应该尝试确保已满足先决条件才继续进行。实际上，先决条件最常见的用法是要求一个属性，因为对于方法来说，检查它可能很难或很昂贵。
- en: As mentioned above, a non-trivial precondition inconveniences clients, because
    they have to ensure that they don’t call the method in a bad state (that violates
    the precondition); if they do, there is no predictable way to recover from the
    error. So users of methods don’t like preconditions. That’s why the Java API classes,
    for example, tend to specify (as a postcondition) that they throw unchecked exceptions
    when arguments are inappropriate. This approach makes it easier to find the bug
    or incorrect assumption in the caller code that led to passing bad arguments.
    In general, it’s better to **fail fast**, as close as possible to the site of
    the bug, rather than let bad values propagate through a program far from their
    original cause.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，非平凡的先决条件会让客户感到不便，因为他们必须确保不调用处于不良状态（违反先决条件）的方法；如果他们这样做，就没有可预测的方法来从错误中恢复。方法的用户不喜欢先决条件。这就是为什么Java
    API类，例如，倾向于指定（作为后置条件），当参数不合适时抛出未检查的异常。这种方法使得更容易找到在调用者代码中导致传递错误参数的错误或不正确假设。一般来说，更好的做法是**尽早失败**，尽可能靠近bug的地方，而不是让错误值在远离原始原因的程序中传播。
- en: 'Sometimes, it’s not feasible to check a condition without making a method unacceptably
    slow, and a precondition is often necessary in this case. If we wanted to implement
    the `find` method using binary search, we would have to require that the array
    be sorted. Forcing the method to actually *check* that the array is sorted would
    defeat the entire purpose of the binary search: to obtain a result in logarithmic
    and not linear time.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在不使方法变得不可接受地缓慢的情况下，不可避免地需要检查一个条件，而在这种情况下，先决条件是必要的。如果我们想要使用二分查找来实现`find`方法，我们将不得不要求数组已经排序。强制方法实际上*检查*数组是否已排序将完全背离二分查找的目的：以对数而不是线性时间获取结果。
- en: The decision of whether to use a precondition is an engineering judgment. The
    key factors are the cost of the check (in writing and executing code), and the
    scope of the method. If it’s only called locally in a class, the precondition
    can be discharged by carefully checking all the sites that call the method. But
    if the method is public, and used by other developers, it would be less wise to
    use a precondition. Instead, like the Java API classes, you should throw an exception.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用先决条件的决定是一种工程判断。关键因素是检查的成本（编写和执行代码）以及方法的范围。如果方法只在类中本地调用，那么先决条件可以通过仔细检查调用方法的所有地点来释放。但是，如果方法是public的，并且被其他开发人员使用，那么使用先决条件就不太明智。相反，像Java
    API类一样，你应该抛出一个异常。
- en: About access control
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于访问控制
- en: 'Read: **[Packages](http://docs.oracle.com/javase/tutorial/java/package/index.html)**
    (7 short pages) in the Java Tutorials.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读：**[包](http://docs.oracle.com/javase/tutorial/java/package/index.html)**（7页）在Java教程中。
- en: 'Read: **[Controlling Access](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)**
    (1 page) in the Java Tutorials.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读：**[控制访问](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)**（1页）在Java教程中。
- en: We have been using *public* for almost all of our methods, without really thinking
    about it. The decision to make a method public or private is actually a decision
    about the contract of the class. Public methods are freely accessible to other
    parts of the program. Making a method public advertises it as a service that your
    class is willing to provide. If you make all your methods public — including helper
    methods that are really meant only for local use within the class — then other
    parts of the program may come to depend on them, which will make it harder for
    you to change the internal implementation of the class in the future. Your code
    won’t be as **ready for change**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎所有的方法都使用*public*，而没有真正考虑过。将方法设置为public或private实际上是关于类的契约的决定。公共方法可以自由地被程序的其他部分访问。将方法设置为public就是在宣传它是你的类愿意提供的一项服务。如果你将所有的方法都设置为public，包括只是用于类内部本地使用的辅助方法，那么程序的其他部分可能会依赖于它们，这将使得将来更难以改变类的内部实现。你的代码就不会**做好变更准备**。
- en: Making internal helper methods public will also add clutter to the visible interface
    your class offers. Keeping internal things *private* makes your class’s public
    interface smaller and more coherent (meaning that it does one thing and does it
    well). Your code will be **easier to understand**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将内部辅助方法公开也会使你的类提供的可见接口变得混乱。将内部事物保持*私有*可以使你的类的公共接口更小更连贯（意味着它做一件事情并且做得很好）。你的代码将更**易于理解**。
- en: We will see even stronger reasons to use *private* in the next few classes,
    when we start to write classes with persistent internal state. Protecting this
    state will help keep the program **safe from bugs**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写具有持久内部状态的类时，在接下来的几个课程中，我们将会有更多理由使用*private*。保护这个状态将有助于使程序**免受错误**。
- en: About static vs. instance methods
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于静态 vs. 实例方法
- en: 'Read: **[the `static` keyword](http://www.codeguru.com/java/tij/tij0037.shtml#Heading79)**
    on CodeGuru.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读：**[`static` 关键字](http://www.codeguru.com/java/tij/tij0037.shtml#Heading79)**
    在 CodeGuru 上。
- en: We have also been using *static* for almost all of our methods, again without
    much discussion. Static methods are not associated with any particular instance
    of a class, while *instance* methods (declared without the `static` keyword) must
    be called on a particular object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎所有的方法都使用了*static*，同样没有太多讨论。静态方法不与类的任何特定实例相关联，而*实例*方法（声明时没有使用 `static` 关键字）必须在特定对象上调用。
- en: Specifications for instance methods are written just the same way as specifications
    for static methods, but they will often refer to properties of the instance on
    which they were called.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法的规范的编写方式与静态方法的规范完全相同，但它们通常会引用调用它们的实例的属性。
- en: 'For example, by now we’re very familiar with this specification:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，到目前为止，我们非常熟悉这个规范：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead of using an `int[]`, what if we had a class `IntArray` designed for
    storing arrays of integers? The `IntArray` class might provide an instance method
    with the specification:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个设计用于存储整数数组的类`IntArray`，而不是使用`int[]`会怎样？`IntArray` 类可能提供一个具有如下规范的实例方法：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ll have much more to say about specifications for instance methods in future
    classes!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在未来的课程中将会对实例方法的规范有更多的讨论！
- en: reading exercises
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Show me a sign(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 给我看一个标志（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: That’s an odd way of looking at it
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个奇怪的看法
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Behavioral oddities
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 行为怪异
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Consider the following test cases for `secondToLastIndexOf`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`secondToLastIndexOf`的以下测试用例：
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Odd doc
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的文档
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'A specification acts as a crucial firewall between implementor and client —
    both between people (or the same person at different times) and between code.
    [As we saw last time](../06-specifications/#summary), it makes separate development
    possible: the client is free to write code that uses a module without seeing its
    source code, and the implementor is free to write the implementation code without
    knowing how it will be used.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 规范充当实施者和客户之间的关键防火墙 - 不管是人与人之间（或同一个人在不同的时间点）还是代码之间。[就像我们上次看到的那样](../06-specifications/#summary)，它使分开开发成为可能：客户可以自由地编写使用模块的代码，而不必看到其源代码，实施者可以自由地编写实现代码，而不必知道它将如何使用。
- en: Declarative specifications are the most useful in practice. Preconditions (which
    weaken the specification) make life harder for the client, but applied judiciously
    they are a vital tool in the software designer’s repertoire, allowing the implementor
    to make necessary assumptions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，声明性规范是最有用的。前置条件（弱化规范）让客户的生活更加困难，但是如果明智地应用，它们是软件设计师工具库中的重要工具，允许实施者做出必要的假设。
- en: 'As always, our goal is to design specifications that make our software:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们的目标是设计使我们的软件：
- en: '**Safe from bugs**. Without specifications, even the tiniest change to any
    part of our program could be the tipped domino that knocks the whole thing over.
    Well-structured, coherent specifications minimize misunderstandings and maximize
    our ability to write correct code with the help of static checking, careful reasoning,
    testing, and code review.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误的影响**。没有规范，甚至我们程序的任何部分的微小变化都可能是倒下的倒下的骨牌。良好结构化、连贯的规范最小化了误解，并最大化了我们通过静态检查、仔细推理、测试和代码审查编写正确代码的能力。'
- en: '**Easy to understand**. A well-written declarative specification means the
    client doesn’t have to read or understand the code. You’ve probably never read
    the code for, say, [Python `dict.update`](https://hg.python.org/cpython/file/7ae156f07a90/Objects/dictobject.c#l1990),
    and doing so isn’t nearly as useful to the Python programmer as [reading the declarative
    spec](https://docs.python.org/3/library/stdtypes.html#dict.update).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**。一个写得很好的声明性规范意味着客户不必阅读或理解代码。你可能从来没有阅读过，比如 [Python `dict.update`](https://hg.python.org/cpython/file/7ae156f07a90/Objects/dictobject.c#l1990)
    的代码，而这样做对 Python 程序员来说并不像 [阅读声明性规范](https://docs.python.org/3/library/stdtypes.html#dict.update)
    那样有用。'
- en: '**Ready for change**. An appropriately weak specification gives freedom to
    the implementor, and an appropriately strong specification gives freedom to the
    client. We can even change the specs themselves, without having to revisit every
    place they’re used, as long as we’re only strengthening them: weakening preconditions
    and strengthening postconditions.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**愿意改变**。一个适度弱化的规范给了实施者自由，而一个适度强化的规范给了客户自由。我们甚至可以改变规范本身，而不必回顾每个使用它们的地方，只要我们只是加强它们：弱化前置条件和加强后置条件。'
