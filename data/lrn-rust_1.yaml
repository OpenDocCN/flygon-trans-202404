- en: About Me
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å…³äºæˆ‘
- en: About Me
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å…³äºæˆ‘
- en: Hi, I'm [Dumindu Madunuwan](https://lk.linkedin.com/in/dumindunuwan). I'm a
    web developer, mainly PHP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¥½ï¼Œæˆ‘æ˜¯[Dumindu Madunuwan](https://lk.linkedin.com/in/dumindunuwan)ã€‚æˆ‘æ˜¯ä¸€åç½‘é¡µå¼€å‘è€…ï¼Œä¸»è¦ä½¿ç”¨PHPã€‚
- en: Around 2007â€“2009, I chose web development because at that time I truly believed,
    web will be the next ultimate, system independent & language independent platform
    and the next generation software ecosystem will be implemented top of browsers.
    The web I expected is sort of similar to this.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§çº¦åœ¨2007å¹´è‡³2009å¹´ï¼Œæˆ‘é€‰æ‹©äº†ç½‘é¡µå¼€å‘ï¼Œå› ä¸ºé‚£æ—¶æˆ‘çœŸæ­£ç›¸ä¿¡ï¼Œç½‘ç»œå°†æˆä¸ºä¸‹ä¸€ä¸ªç»ˆæã€ç³»ç»Ÿç‹¬ç«‹å’Œè¯­è¨€ç‹¬ç«‹çš„å¹³å°ï¼Œä¸‹ä¸€ä»£è½¯ä»¶ç”Ÿæ€ç³»ç»Ÿå°†åœ¨æµè§ˆå™¨ä¹‹ä¸Šå®ç°ã€‚æˆ‘æœŸæœ›çš„ç½‘ç»œä¸æ­¤æœ‰äº›ç›¸ä¼¼ã€‚
- en: '[![The Future of The Web : Mozilla Labs Aurora Concept Browser](mozilla_labs_aurora_concept_browser.png)](http://www.youtube.com/watch?v=FZ-zvx1QCcA
    "The Future of The Web : Mozilla Labs Aurora Concept Browser")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Webçš„æœªæ¥ï¼šMozilla Labs Auroraæ¦‚å¿µæµè§ˆå™¨](mozilla_labs_aurora_concept_browser.png)](http://www.youtube.com/watch?v=FZ-zvx1QCcA
    "Webçš„æœªæ¥ï¼šMozilla Labs Auroraæ¦‚å¿µæµè§ˆå™¨")'
- en: Like some of web developers, I truly bet on HTML5 over native apps on past years.
    I learned about HTML5, CSS3, RWD, Mobile First Design, UI/UX and etc. Now a days
    we have hundreds of front-end frameworks but still web technologies can't win
    over native apps, especially on performance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: åƒä¸€äº›ç½‘é¡µå¼€å‘è€…ä¸€æ ·ï¼Œæˆ‘è¿‡å»ç¡®å®æ›´çœ‹å¥½HTML5è€Œä¸æ˜¯æœ¬æœºåº”ç”¨ç¨‹åºã€‚æˆ‘å­¦ä¹ äº†HTML5ã€CSS3ã€RWDã€Mobile First Designã€UI/UXç­‰ã€‚å¦‚ä»Šï¼Œæˆ‘ä»¬æœ‰æ•°ç™¾ä¸ªå‰ç«¯æ¡†æ¶ï¼Œä½†ä»ç„¶æ— æ³•èƒœè¿‡æœ¬æœºåº”ç”¨ç¨‹åºï¼Œå°¤å…¶æ˜¯åœ¨æ€§èƒ½æ–¹é¢ã€‚
- en: Itâ€™s true that web technologies are slowly adapting for native app development
    via asmjs, NativeScript, Electron, WebAssembly, React Native but future web application
    development will be more complex because of Emerging Connected Cars and VR Ecosystems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®å®ï¼Œç½‘ç»œæŠ€æœ¯æ­£åœ¨é€æ¸é€‚åº”é€šè¿‡asmjsã€NativeScriptã€Electronã€WebAssemblyã€React Nativeè¿›è¡Œæœ¬æœºåº”ç”¨ç¨‹åºå¼€å‘ï¼Œä½†ç”±äºæ–°å…´çš„è”ç½‘æ±½è½¦å’Œè™šæ‹Ÿç°å®ç”Ÿæ€ç³»ç»Ÿï¼Œæœªæ¥çš„ç½‘ç»œåº”ç”¨ç¨‹åºå¼€å‘å°†å˜å¾—æ›´åŠ å¤æ‚ã€‚
- en: Also in the other hand, now we have much powerful alternatives for PHP, like
    node and Go. So as a PHP developer its time to learn something new, a new language.
    I chose Rust because it's an interesting language to learn and next generation
    browser engine, [Servo](https://servo.org/) is written using Rust.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€æ–¹é¢ï¼Œç°åœ¨æˆ‘ä»¬æœ‰è®¸å¤šå¼ºå¤§çš„PHPæ›¿ä»£å“ï¼Œæ¯”å¦‚nodeå’ŒGoã€‚æ‰€ä»¥ä½œä¸ºPHPå¼€å‘è€…ï¼Œç°åœ¨æ˜¯å­¦ä¹ æ–°ä¸œè¥¿çš„æ—¶å€™ï¼Œå­¦ä¹ ä¸€é—¨æ–°çš„è¯­è¨€ã€‚æˆ‘é€‰æ‹©Rustæ˜¯å› ä¸ºå®ƒæ˜¯ä¸€é—¨æœ‰è¶£çš„å­¦ä¹ è¯­è¨€ï¼Œä¸‹ä¸€ä»£æµè§ˆå™¨å¼•æ“[Servo](https://servo.org/)æ˜¯ç”¨Rustç¼–å†™çš„ã€‚
- en: '* * *'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[![Medium](medium.png)](https://medium.com/@dumindu "Medium") [![Ycombinator](ycombinator.png)](https://news.ycombinator.com/user?id=dumindunuwan
    "Ycombinator") [![Reddit](reddit.png)](https://www.reddit.com/user/dumindunuwan/
    "Reddit") [![Github](github.png)](https://github.com/dumindu/ "Github") [![LinkedIn](linkedin.png)](https://lk.linkedin.com/in/dumindunuwan/
    "LinkedIn") [![Pinterest](pinterest.png)](https://www.pinterest.com/dumindu/ "Pinterest")
    [![Behance](behance.png)](https://www.behance.net/dumindu-madunuwan/ "Behance")'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Medium](medium.png)](https://medium.com/@dumindu "Medium") [![Ycombinator](ycombinator.png)](https://news.ycombinator.com/user?id=dumindunuwan
    "Ycombinator") [![Reddit](reddit.png)](https://www.reddit.com/user/dumindunuwan/
    "Reddit") [![Github](github.png)](https://github.com/dumindu/ "Github") [![LinkedIn](linkedin.png)](https://lk.linkedin.com/in/dumindunuwan/
    "LinkedIn") [![Pinterest](pinterest.png)](https://www.pinterest.com/dumindu/ "Pinterest")
    [![Behance](behance.png)](https://www.behance.net/dumindu-madunuwan/ "Behance")'
- en: Why Rust?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆé€‰æ‹©Rustï¼Ÿ
- en: Why Rust?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆé€‰æ‹©Rustï¼Ÿ
- en: Rust initially designed and developed by Mozilla employee Graydon Hoare as a
    personal project. Mozilla began sponsoring the project in 2009 and announced it
    in 2010\. But the first stable release, Rust 1.0 released on May 15, 2015.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rustæœ€åˆç”±Mozillaå‘˜å·¥Graydon Hoareä½œä¸ºä¸ªäººé¡¹ç›®è®¾è®¡å’Œå¼€å‘ã€‚Mozillaäº2009å¹´å¼€å§‹èµåŠ©è¯¥é¡¹ç›®ï¼Œå¹¶åœ¨2010å¹´å®£å¸ƒã€‚ä½†æ˜¯ï¼Œç¬¬ä¸€ä¸ªç¨³å®šç‰ˆæœ¬Rust
    1.0äº2015å¹´5æœˆ15æ—¥å‘å¸ƒã€‚
- en: '[![Rethinking Systems Programming](rust_control_over_safety.png)](http://thoughtram.io/rust-and-nickel/#/11)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![é‡æ–°æ€è€ƒç³»ç»Ÿç¼–ç¨‹](rust_control_over_safety.png)](http://thoughtram.io/rust-and-nickel/#/11)'
- en: The goal of Rust is to be a good language for creating highly concurrent and
    highly safe systems. Also as you can see on above diagram, Rust designed to provide
    speed and safety at the same time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Rustçš„ç›®æ ‡æ˜¯æˆä¸ºåˆ›å»ºé«˜åº¦å¹¶å‘å’Œé«˜åº¦å®‰å…¨ç³»ç»Ÿçš„è‰¯å¥½è¯­è¨€ã€‚æ­£å¦‚æ‚¨åœ¨ä¸Šå›¾ä¸­æ‰€çœ‹åˆ°çš„ï¼ŒRustæ—¨åœ¨åŒæ—¶æä¾›é€Ÿåº¦å’Œå®‰å…¨æ€§ã€‚
- en: '"Rust is a systems programming language focused on three goals: safety, speed,
    and concurrency."'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"Rustæ˜¯ä¸€ç§ä¸“æ³¨äºä¸‰ä¸ªç›®æ ‡çš„ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼šå®‰å…¨æ€§ã€é€Ÿåº¦å’Œå¹¶å‘æ€§ã€‚"'
- en: __ Rust Documentation
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: __ Rustæ–‡æ¡£
- en: Rust is very young and very modern language. It's a **compiled programming language**
    and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on its backend. Also Rust
    is a **multi-paradigm programming language**, it supports imperative procedural,
    concurrent actor, object-oriented and pure functional styles. It also supports
    generic programming and meta programming, in both static and dynamic styles.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Rust æ˜¯ä¸€ç§éå¸¸å¹´è½»å’Œç°ä»£çš„è¯­è¨€ã€‚å®ƒæ˜¯ä¸€ç§**ç¼–è¯‘å‹ç¼–ç¨‹è¯­è¨€**ï¼Œåœ¨åç«¯ä½¿ç”¨[LLVM](https://en.wikipedia.org/wiki/LLVM)ã€‚æ­¤å¤–ï¼ŒRust
    æ˜¯ä¸€ç§**å¤šèŒƒå¼ç¼–ç¨‹è¯­è¨€**ï¼Œæ”¯æŒå‘½ä»¤å¼è¿‡ç¨‹ã€å¹¶å‘actorã€é¢å‘å¯¹è±¡å’Œçº¯å‡½æ•°å¼é£æ ¼ã€‚å®ƒè¿˜æ”¯æŒé™æ€å’ŒåŠ¨æ€é£æ ¼çš„æ³›å‹ç¼–ç¨‹å’Œå…ƒç¼–ç¨‹ã€‚
- en: Its design elements came from a wide range of sources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶è®¾è®¡å…ƒç´ æ¥è‡ªå„ç§æ¥æºã€‚
- en: 'Abstract Machine Model : **C**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æŠ½è±¡æœºå™¨æ¨¡å‹ï¼š**C**
- en: 'Data types : **C, SML, OCaml, Lisp, Limbo**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°æ®ç±»å‹ï¼š**C, SML, OCaml, Lisp, Limbo**
- en: 'Optional Bindings : **Swift**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯é€‰ç»‘å®šï¼š**Swift**
- en: 'Hygienic Macros : **Scheme**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å«ç”Ÿå®ï¼š**Scheme**
- en: 'Functional Programming : **Haskell, OCaml, F#**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡½æ•°å¼ç¼–ç¨‹ï¼š**Haskell, OCaml, F#**
- en: 'Attributes : **ECMA**-335'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å±æ€§ï¼š**ECMA**-335
- en: 'Memory Model and Memory Management : **C++, ML Kit, Cyclone**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å†…å­˜æ¨¡å‹å’Œå†…å­˜ç®¡ç†ï¼š**C++, ML Kit, Cyclone**
- en: 'Type Classes : **Haskell**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç±»å‹ç±»ï¼š**Haskell**
- en: 'Crate : Assembly in the **ECMA**-335 CLI model'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç®±ï¼š**ECMA**-335 CLI æ¨¡å‹ä¸­çš„æ±‡ç¼–
- en: 'Channels and Concurrency : **Newsqueak, Alef, Limbo**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šé“å’Œå¹¶å‘æ€§ï¼š**Newsqueak, Alef, Limbo**
- en: 'Message passing and Thread failure : **Erlang**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¶ˆæ¯ä¼ é€’å’Œçº¿ç¨‹å¤±è´¥ï¼š**Erlang**
- en: and etc.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ã€‚
- en: Rust **doesn't use an automated garbage collection** system(GC) by default.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Rust **é»˜è®¤ä¸ä½¿ç”¨è‡ªåŠ¨åƒåœ¾å›æ”¶**ç³»ç»Ÿï¼ˆGCï¼‰ã€‚
- en: ğŸ” One of Rustâ€™s most unique and compelling features is [ownership](https://doc.rust-lang.org/stable/book/ownership.html),
    which uses to achieves memory safety. Rust creates memory pointers optimistically,
    checks memory pointersâ€™ limited accesses at the compiler time with the usage of
    [References and Borrowing](https://doc.rust-lang.org/stable/book/references-and-borrowing.html).
    And it does automatic compile time memory management by checking the [Lifetimes](https://doc.rust-lang.org/stable/book/lifetimes.html).
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” Rust æœ€ç‹¬ç‰¹å’Œå¼•äººæ³¨ç›®çš„ç‰¹æ€§ä¹‹ä¸€æ˜¯[æ‰€æœ‰æƒ](https://doc.rust-lang.org/stable/book/ownership.html)ï¼Œå®ƒç”¨äºå®ç°å†…å­˜å®‰å…¨ã€‚
    Rust ä¹è§‚åœ°åˆ›å»ºå†…å­˜æŒ‡é’ˆï¼Œé€šè¿‡ä½¿ç”¨[å¼•ç”¨å’Œå€Ÿç”¨](https://doc.rust-lang.org/stable/book/references-and-borrowing.html)åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å†…å­˜æŒ‡é’ˆçš„æœ‰é™è®¿é—®ã€‚å®ƒé€šè¿‡æ£€æŸ¥[Lifetimes](https://doc.rust-lang.org/stable/book/lifetimes.html)å®ç°è‡ªåŠ¨çš„ç¼–è¯‘æ—¶å†…å­˜ç®¡ç†ã€‚
- en: Rust compiler observe the code at compiler time and help to [prevent many types
    of errors](https://doc.rust-lang.org/error-index.html) that are possible to write
    in C++
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Rust ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶è§‚å¯Ÿä»£ç ï¼Œå¹¶å¸®åŠ©[é˜²æ­¢è®¸å¤šç§å¯èƒ½åœ¨ C++ ä¸­ç¼–å†™çš„é”™è¯¯](https://doc.rust-lang.org/error-index.html)ã€‚
- en: Installation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å®‰è£…
- en: Installation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å®‰è£…
- en: There are many ways to install Rust on your system. For the moment the official
    way to install Rust is using [Rustup](https://rustup.rs/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰è®¸å¤šå®‰è£… Rust çš„æ–¹æ³•ã€‚ç›®å‰å®˜æ–¹å®‰è£… Rust çš„æ–¹å¼æ˜¯ä½¿ç”¨[Rustup](https://rustup.rs/)ã€‚
- en: '[ğŸ•®](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust
    Programming Language from the official release channels, enabling you to easily
    switch between stable, beta, and nightly compilers and keep them updated. It makes
    cross-compiling simpler with binary builds of the standard library for common
    platforms.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[ğŸ•®](https://github.com/rust-lang-nursery/rustup.rs) Rustup ä»å®˜æ–¹å‘å¸ƒæ¸ é“å®‰è£… Rust ç¼–ç¨‹è¯­è¨€ï¼Œä½¿æ‚¨å¯ä»¥è½»æ¾åœ¨ç¨³å®šç‰ˆã€æµ‹è¯•ç‰ˆå’Œå¤œé—´ç‰ˆç¼–è¯‘å™¨ä¹‹é—´åˆ‡æ¢å¹¶ä¿æŒå…¶æ›´æ–°ã€‚å®ƒé€šè¿‡ä¸ºå¸¸è§å¹³å°æä¾›æ ‡å‡†åº“çš„äºŒè¿›åˆ¶æ„å»ºï¼Œç®€åŒ–äº†äº¤å‰ç¼–è¯‘ã€‚'
- en: '[ğŸ•®](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs
    `rustc`, `cargo`, `rustup` and other standard tools to Cargo''s `bin` directory.
    On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\.cargo\bin`.
    This is the same directory that `cargo install` will install Rust programs and
    Cargo plugins.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[ğŸ•®](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup å°† `rustc`ã€`cargo`ã€`rustup`
    å’Œå…¶ä»–æ ‡å‡†å·¥å…·å®‰è£…åˆ° Cargo çš„ `bin` ç›®å½•ä¸­ã€‚åœ¨ Unix ä¸Šï¼Œå®ƒä½äº `$HOME/.cargo/bin`ï¼Œåœ¨ Windows ä¸Šä½äº `%USERPROFILE%\.cargo\bin`ã€‚è¿™æ˜¯
    `cargo install` å°†å®‰è£… Rust ç¨‹åºå’Œ Cargo æ’ä»¶çš„ç›¸åŒç›®å½•ã€‚'
- en: '**ğŸ’¡** More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**ğŸ’¡** æ›´å¤šä¿¡æ¯å¯ä»¥åœ¨[Rustup é¡¹ç›®çš„ Github é¡µé¢](https://github.com/rust-lang-nursery/rustup.rs)æ‰¾åˆ°ã€‚'
- en: After installing Rust you can check the current version by typing `rustc --version`
    or`rustc -V` on your terminal to verify the success of the installation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å®‰è£… Rust åï¼Œæ‚¨å¯ä»¥åœ¨ç»ˆç«¯ä¸Šé”®å…¥ `rustc --version` æˆ– `rustc -V` æ¥æ£€æŸ¥å½“å‰ç‰ˆæœ¬ï¼Œä»¥éªŒè¯å®‰è£…æˆåŠŸã€‚
- en: Hello World
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: Hello World
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`fn` means function. main function is the beginning of every Rust program.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn` è¡¨ç¤ºå‡½æ•°ã€‚ä¸»å‡½æ•°æ˜¯æ¯ä¸ª Rust ç¨‹åºçš„èµ·ç‚¹ã€‚'
- en: '`println!` prints text to the console and its *!* indicate that itâ€™s a [macro](https://doc.rust-lang.org/book/macros.html)
    instead of a function.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!` å°†æ–‡æœ¬æ‰“å°åˆ°æ§åˆ¶å°ï¼Œå…¶ *!* è¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ª [å®](https://doc.rust-lang.org/book/macros.html)
    è€Œä¸æ˜¯å‡½æ•°ã€‚'
- en: ğŸ’¡ Rust files should have .rs file extension and if youâ€™re using more than one
    word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ’¡ Rust æ–‡ä»¶åº”è¯¥å…·æœ‰ .rs æ–‡ä»¶æ‰©å±•åï¼Œå¦‚æœæ–‡ä»¶åä½¿ç”¨äº†å¤šä¸ªå•è¯ï¼Œè¯·éµå¾ª [snake_case](https://en.wikipedia.org/wiki/Snake_case)ã€‚
- en: compiling via `rustc file.rs`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ `rustc file.rs` è¿›è¡Œç¼–è¯‘
- en: executing by `./file` on Linux and Mac or `file.exe` on Windows
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Linux å’Œ Mac ä¸Šé€šè¿‡ `./file` æ‰§è¡Œï¼Œåœ¨ Windows ä¸Šé€šè¿‡ `file.exe` æ‰§è¡Œ
- en: '* * *'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ğŸ’¯ These are the other usages of println! macro,
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¯ è¿™æ˜¯ println! å®çš„å…¶ä»–ç”¨æ³•ï¼Œ
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Cargo, Crates and Basic Project Structure
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargoã€Crates å’ŒåŸºæœ¬é¡¹ç›®ç»“æ„
- en: Cargo, Crates and Basic Project Structure
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargoã€Crates å’ŒåŸºæœ¬é¡¹ç›®ç»“æ„
- en: Cargo is Rustâ€™s build-in Package Manager. But mainly it uses for,
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo æ˜¯ Rust çš„å†…ç½®åŒ…ç®¡ç†å™¨ã€‚ä½†ä¸»è¦ç”¨äºï¼Œ
- en: 'â–¸ Create new project : `cargo new`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ åˆ›å»ºæ–°é¡¹ç›®ï¼š`cargo new`
- en: 'â–¸ Update dependencies : `cargo update`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ æ›´æ–°ä¾èµ–ï¼š`cargo update`
- en: 'â–¸ Build project : `cargo build`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ æ„å»ºé¡¹ç›®ï¼š`cargo build`
- en: 'â–¸ Build and run a project : `cargo run`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ æ„å»ºå¹¶è¿è¡Œé¡¹ç›®ï¼š`cargo run`
- en: 'â–¸ Run tests : `cargo test`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ è¿è¡Œæµ‹è¯•ï¼š`cargo test`
- en: 'â–¸ Generate documentation via rustdoc : `cargo doc`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ é€šè¿‡ rustdoc ç”Ÿæˆæ–‡æ¡£ï¼š`cargo doc`
- en: Other than that there are some cargo commands, especially for publishing crates
    directly via cargo.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº› Cargo å‘½ä»¤ï¼Œä¸“é—¨ç”¨äºé€šè¿‡ cargo ç›´æ¥å‘å¸ƒ cratesã€‚
- en: 'â–¸ `cargo login` : acquiring an API token'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ `cargo login`ï¼šè·å– API ä»¤ç‰Œ
- en: 'â–¸ `cargo package` : make the local create uploadable to crates.io'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ `cargo package`ï¼šä½¿æœ¬åœ°åˆ›å»ºå¯ä¸Šä¼ åˆ° crates.io
- en: 'â–¸ `cargo publish` : make the local create uploadable to crates.io and upload
    the crate'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ `cargo publish`ï¼šä½¿æœ¬åœ°åˆ›å»ºå¯ä¸Šä¼ åˆ° crates.io å¹¶ä¸Šä¼  crate
- en: â­ï¸ **A crate is a package. Crates can be shared via** [**Cargo**](https://crates.io/)**.**
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ **ä¸€ä¸ª crate æ˜¯ä¸€ä¸ª packageã€‚Crates å¯ä»¥é€šè¿‡** [**Cargo**](https://crates.io/) **åˆ†äº«ã€‚**
- en: '* * *'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A crate can produce an executable or a library. In other words, it can be a
    binary crate or a library crate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ª crate å¯ä»¥ç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æˆ–ä¸€ä¸ªåº“ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒå¯ä»¥æ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶ crate æˆ–ä¸€ä¸ªåº“ crateã€‚
- en: '`cargo new crate_name --bin` : produces an **executable**'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo new crate_name --bin`ï¼šç”Ÿæˆä¸€ä¸ª **å¯æ‰§è¡Œæ–‡ä»¶**'
- en: '`cargo new crate_name --lib` OR `cargo new crate_name`: produces a **library**'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo new crate_name --lib` æˆ– `cargo new crate_name`ï¼šç”Ÿæˆä¸€ä¸ª **åº“**'
- en: The first one generates,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ç§ç”Ÿæˆæ–¹å¼ä¸ºï¼Œ
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: and the second one generates,
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç§ç”Ÿæˆæ–¹å¼ä¸ºï¼Œ
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Cargo.toml**(capital c) is the configuration file which contains all of the
    metadata that Cargo needs to compile your project.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cargo.toml**ï¼ˆå¤§å†™çš„ cï¼‰æ˜¯é…ç½®æ–‡ä»¶ï¼ŒåŒ…å«äº† Cargo ç¼–è¯‘é¡¹ç›®æ‰€éœ€çš„æ‰€æœ‰å…ƒæ•°æ®ã€‚'
- en: '**src** folder is the place to store the source code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src** æ–‡ä»¶å¤¹æ˜¯å­˜å‚¨æºä»£ç çš„åœ°æ–¹ã€‚'
- en: Each crate has an implicit crate root/ entry point. **main.rs** is the crate
    root for a binary crate and **lib.rs** is the crate root for a library crate.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸ª crate éƒ½æœ‰ä¸€ä¸ªéšå¼ crate æ ¹ / å…¥å£ç‚¹ã€‚å¯¹äºäºŒè¿›åˆ¶ crateï¼Œ**main.rs** æ˜¯ crate æ ¹ï¼Œå¯¹äºåº“ crateï¼Œ**lib.rs**
    æ˜¯ crate æ ¹ã€‚
- en: ğŸ’¡ When we build a binary crate via `cargo build` or `cargo run`, the executable
    file will be stored in **target/debug/** folder. But when build it via `cargo
    build --release` for a release it will be stored in **target/release/** folder.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ’¡ å½“æˆ‘ä»¬é€šè¿‡ `cargo build` æˆ– `cargo run` æ„å»ºä¸€ä¸ªäºŒè¿›åˆ¶ crate æ—¶ï¼Œå¯æ‰§è¡Œæ–‡ä»¶å°†å­˜å‚¨åœ¨ **target/debug/**
    æ–‡ä»¶å¤¹ä¸­ã€‚ä½†å½“é€šè¿‡ `cargo build --release` æ„å»ºç”¨äºå‘å¸ƒçš„ç‰ˆæœ¬æ—¶ï¼Œå¯æ‰§è¡Œæ–‡ä»¶å°†å­˜å‚¨åœ¨ **target/release/** æ–‡ä»¶å¤¹ä¸­ã€‚
- en: '* * *'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This is how [Cargo Docs describes](http://doc.crates.io/guide.html#project-layout)
    about the recommended Project Layout,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ [Cargo Docs æè¿°](http://doc.crates.io/guide.html#project-layout) æ¨èçš„é¡¹ç›®å¸ƒå±€ï¼Œ
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: â–¸ Source code goes in the `src` directory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ æºä»£ç æ”¾åœ¨ `src` ç›®å½•ä¸­ã€‚
- en: â–¸ The default library file is `src/lib.rs`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ é»˜è®¤åº“æ–‡ä»¶ä¸º `src/lib.rs`ã€‚
- en: â–¸ The default executable file is `src/main.rs`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ é»˜è®¤å¯æ‰§è¡Œæ–‡ä»¶ä¸º `src/main.rs`ã€‚
- en: â–¸ Other executables can be placed in `src/bin/*.rs`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ å…¶ä»–å¯æ‰§è¡Œæ–‡ä»¶å¯ä»¥æ”¾åœ¨ `src/bin/*.rs` ä¸­ã€‚
- en: â–¸ Integration tests go in the `tests` directory (unit tests go in each file
    they're testing).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ é›†æˆæµ‹è¯•æ”¾åœ¨ `tests` ç›®å½•ä¸­ï¼ˆå•å…ƒæµ‹è¯•æ”¾åœ¨å®ƒä»¬æ‰€æµ‹è¯•çš„æ¯ä¸ªæ–‡ä»¶ä¸­ï¼‰ã€‚
- en: â–¸ Examples go in the `examples` directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ ç¤ºä¾‹æ”¾åœ¨ `examples` ç›®å½•ä¸­ã€‚
- en: â–¸ Benchmarks go in the `benches` directory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: â–¸ åŸºå‡†æµ‹è¯•æ”¾åœ¨ `benches` ç›®å½•ä¸­ã€‚
- en: Comments and Documenting the code
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ³¨é‡Šå’Œä»£ç æ–‡æ¡£
- en: Comments and Documenting the code
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ³¨é‡Šå’Œä»£ç æ–‡æ¡£
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nested block comments are supported.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: æ”¯æŒåµŒå¥—çš„å—æ³¨é‡Šã€‚
- en: ğŸ’¡ **Always avoid block comments, Use line comments instead.**
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ **å§‹ç»ˆé¿å…ä½¿ç”¨å—æ³¨é‡Šï¼Œæ”¹ç”¨è¡Œæ³¨é‡Šã€‚**
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Doc comments support Markdown notations. Using `cargo doc`, the HTML documentation
    can be generated from these doc comments. Letâ€™s see the difference between the
    two sets of doc comments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: æ–‡æ¡£æ³¨é‡Šæ”¯æŒ Markdown æ ‡è®°ã€‚ä½¿ç”¨ `cargo doc` å‘½ä»¤ï¼Œå¯ä»¥ä»è¿™äº›æ–‡æ¡£æ³¨é‡Šç”Ÿæˆ HTML æ–‡æ¡£ã€‚è®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸¤ç»„æ–‡æ¡£æ³¨é‡Šä¹‹é—´çš„åŒºåˆ«ã€‚
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see both use to document the same module. First comment has been
    added before the module while the second one has been added inside the module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œä¸¤è€…éƒ½ç”¨äºè®°å½•ç›¸åŒçš„æ¨¡å—ã€‚ç¬¬ä¸€ä¸ªæ³¨é‡Šå·²æ·»åŠ åˆ°æ¨¡å—ä¹‹å‰ï¼Œè€Œç¬¬äºŒä¸ªæ³¨é‡Šå·²æ·»åŠ åˆ°æ¨¡å—å†…éƒ¨ã€‚
- en: ğŸ’¡ **Only use //! to write crate and module-level documentation, nothing else.
    When using mod blocks, use /// outside of the block.**
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ **åªä½¿ç”¨//!ç¼–å†™ crate å’Œæ¨¡å—çº§æ–‡æ¡£ï¼Œä¸è¦å†™å…¶ä»–å†…å®¹ã€‚ä½¿ç”¨ mod å—æ—¶ï¼Œåœ¨å—å¤–ä½¿ç”¨///ã€‚**
- en: Also we can use **doc attributes** for documenting the code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨**æ–‡æ¡£å±æ€§**æ¥è®°å½•ä»£ç ã€‚
- en: ğŸ” An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general,
    free-form **metadatum** that is interpreted according to name, convention, and
    language and compiler version. Any item declaration may have an attribute applied
    to it.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” [å±æ€§](https://doc.rust-lang.org/reference.html#attributes)æ˜¯ä¸€ä¸ªé€šç”¨çš„ã€è‡ªç”±å½¢å¼çš„**å…ƒæ•°æ®**ï¼Œæ ¹æ®åç§°ã€çº¦å®šå’Œè¯­è¨€å’Œç¼–è¯‘å™¨ç‰ˆæœ¬è¿›è¡Œè§£é‡Šã€‚ä»»ä½•é¡¹ç›®å£°æ˜éƒ½å¯ä»¥åº”ç”¨å±æ€§ã€‚
- en: In here each comments are equivalent to relevant data attributes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„æ¯ä¸ªæ³¨é‡Šéƒ½ç­‰åŒäºç›¸å…³çš„æ•°æ®å±æ€§ã€‚
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Variable bindings , Constants & Statics
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å˜é‡ç»‘å®šï¼Œå¸¸é‡å’Œé™æ€å˜é‡
- en: Variable bindings , Constants & Statics
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å˜é‡ç»‘å®šï¼Œå¸¸é‡å’Œé™æ€å˜é‡
- en: â­ï¸ In Rust variable are **immutable by default**, so we call them **Variable
    bindings**. To make them mutable, `mut` keyword is used.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ åœ¨ Rust ä¸­ï¼Œå˜é‡é»˜è®¤æ˜¯**ä¸å¯å˜çš„**ï¼Œå› æ­¤æˆ‘ä»¬ç§°å®ƒä»¬ä¸º**å˜é‡ç»‘å®š**ã€‚è¦ä½¿å®ƒä»¬å¯å˜ï¼Œä½¿ç”¨`mut` å…³é”®å­—ã€‚
- en: â­ï¸ Rust is a **statically typed** language; It checks data type at compile time.
    But it **doesnâ€™t require you to actually type it when declare variable bindings**.
    On that case compiler checks the usage and set a better data type for it. But
    for **constants and statics you must annotate the type**. Types come after a colon(:)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ Rust æ˜¯ä¸€ç§**é™æ€ç±»å‹**è¯­è¨€ï¼›å®ƒåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥æ•°æ®ç±»å‹ã€‚ä½†æ˜¯**å£°æ˜å˜é‡ç»‘å®šæ—¶ä¸éœ€è¦å®é™…è¾“å…¥ç±»å‹**ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šæ£€æŸ¥ç”¨æ³•å¹¶ä¸ºå…¶è®¾ç½®æ›´å¥½çš„æ•°æ®ç±»å‹ã€‚ä½†æ˜¯**å¸¸é‡å’Œé™æ€å˜é‡å¿…é¡»æ³¨æ˜ç±»å‹**ã€‚ç±»å‹åœ¨å†’å·(:)ä¹‹åå£°æ˜ã€‚
- en: Variable bindings
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å˜é‡ç»‘å®š
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Constants
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¸¸é‡
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Statics
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é™æ€å˜é‡
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**let** keyword is used in binding expressions. We can bind a name to a value
    or a function. Also because of left-hand side of a let expression is a â€˜patternâ€™,
    you can bind multiple names to set of values or function values.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**let** å…³é”®å­—ç”¨äºç»‘å®šè¡¨è¾¾å¼ã€‚æˆ‘ä»¬å¯ä»¥å°†åç§°ç»‘å®šåˆ°å€¼æˆ–å‡½æ•°ã€‚æ­¤å¤–ï¼Œç”±äº let è¡¨è¾¾å¼çš„å·¦ä¾§æ˜¯ä¸€ä¸ªâ€˜æ¨¡å¼â€™ï¼Œæ‚¨å¯ä»¥å°†å¤šä¸ªåç§°ç»‘å®šåˆ°ä¸€ç»„å€¼æˆ–å‡½æ•°å€¼ã€‚'
- en: '**const** keyword is used to define constants. It lives for the entire lifetime
    of a program but have no fixed address in memory. **static** keyword is used to
    define â€˜global variableâ€™ type facility. There is only one instance for each value,
    and itâ€™s at a **fixed location in memory**.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**const** å…³é”®å­—ç”¨äºå®šä¹‰å¸¸é‡ã€‚å®ƒåœ¨æ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸå†…å­˜åœ¨ï¼Œä½†åœ¨å†…å­˜ä¸­æ²¡æœ‰å›ºå®šçš„åœ°å€ã€‚**static** å…³é”®å­—ç”¨äºå®šä¹‰â€˜å…¨å±€å˜é‡â€™ç±»å‹çš„è®¾æ–½ã€‚æ¯ä¸ªå€¼åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶ä¸”ä½äºå†…å­˜ä¸­çš„**å›ºå®šä½ç½®**ã€‚'
- en: ğŸ’¡ **Always use const**, instead of static. Itâ€™s pretty rare that you actually
    want a memory location associated with your constant, and using a const allows
    for optimizations like constant propagation not only in your crate but also in
    downstream crates.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ **å§‹ç»ˆä½¿ç”¨ const**ï¼Œè€Œä¸æ˜¯ staticã€‚ä½ å®é™…ä¸Šå¾ˆå°‘éœ€è¦å°†å†…å­˜ä½ç½®ä¸å¸¸é‡å…³è”èµ·æ¥ï¼Œä½¿ç”¨ const å…è®¸è¿›è¡Œä¼˜åŒ–ï¼Œä¾‹å¦‚å¸¸é‡ä¼ æ’­ä¸ä»…åœ¨ä½ çš„
    crate ä¸­ï¼Œåœ¨ä¸‹æ¸¸ crate ä¸­ä¹Ÿèƒ½è¿›è¡Œã€‚
- en: ğŸ’¡ Usually statics are placed at top of the code file, outside the functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ é€šå¸¸é™æ€å˜é‡æ”¾ç½®åœ¨ä»£ç æ–‡ä»¶çš„é¡¶éƒ¨ï¼Œå‡½æ•°ä¹‹å¤–ã€‚
- en: Functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‡½æ•°
- en: Functions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‡½æ•°
- en: Functions are declared with the keyword `fn`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡½æ•°ä½¿ç”¨å…³é”®å­— `fn` å£°æ˜
- en: When using **arguments**, you **must declare data types**.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä½¿ç”¨**å‚æ•°**æ—¶ï¼Œæ‚¨**å¿…é¡»å£°æ˜æ•°æ®ç±»å‹**ã€‚
- en: By default functions **return empty tuple ()**. If you want to return a value,
    **return type must be specified** after **->**
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œå‡½æ•°**è¿”å›ç©ºå…ƒç»„ ()**ã€‚å¦‚æœè¦è¿”å›ä¸€ä¸ªå€¼ï¼Œå¿…é¡»åœ¨**->**ä¹‹åæŒ‡å®š**è¿”å›ç±»å‹**ã€‚
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Primitive Data Types
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åŸå§‹æ•°æ®ç±»å‹
- en: Primitive Data Types
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åŸå§‹æ•°æ®ç±»å‹
- en: '**bool** : true or false'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bool**ï¼štrue æˆ– false'
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**char** : a single Unicode scalar value'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**char**ï¼šä¸€ä¸ªå•ä¸€çš„ Unicode æ ‡é‡å€¼'
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**i8 i16 i32 i64** : fixed size(bit) signed(+/-) integer types'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i8 i16 i32 i64**ï¼šå›ºå®šå¤§å°(bit)æœ‰ç¬¦å·(+/-)æ•´æ•°ç±»å‹'
- en: '| DATA TYPE | MIN | MAX |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| æ•°æ®ç±»å‹ | æœ€å°å€¼ | æœ€å¤§å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| i8 | -128 | 127 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| i8 | -128 | 127 |'
- en: '| i16 | -32768 | 32767 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| i16 | -32768 | 32767 |'
- en: '| i32 | -2147483648 | 2147483647 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| i32 | -2147483648 | 2147483647 |'
- en: '| i64 | -9223372036854775808 | 9223372036854775807 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| i64 | -9223372036854775808 | 9223372036854775807 |'
- en: ğŸ’¡ Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic;
    From **-2â¿â»Â¹ to 2â¿â»Â¹-1** . You can use **min_value()** and **max_value()** to
    find min and max of each integer type, ex. i8::min_value();
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ æœ€å°å€¼å’Œæœ€å¤§å€¼åŸºäº IEEE æ ‡å‡†çš„äºŒè¿›åˆ¶æµ®ç‚¹ç®—æœ¯ï¼›ä»**-2â¿â»Â¹åˆ°2â¿â»Â¹-1**ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ **min_value()** å’Œ **max_value()**
    æ¥æ‰¾åˆ°æ¯ç§æ•´æ•°ç±»å‹çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œä¾‹å¦‚ i8::min_value();
- en: '**u8 u16 u32 u64** : fixed size(bit) unsigned(+) integer types'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**u8 u16 u32 u64**ï¼šå›ºå®šå¤§å°(bit)æ— ç¬¦å·(+)æ•´æ•°ç±»å‹'
- en: '| DATA TYPE | MIN | MAX |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| æ•°æ®ç±»å‹ | æœ€å°å€¼ | æœ€å¤§å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| u8 | 0 | 255 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| u8 | 0 | 255 |'
- en: '| u16 | 0 | 65535 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| u16 | 0 | 65535 |'
- en: '| u32 | 0 | 4294967295 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| u32 | 0 | 4294967295 |'
- en: '| u64 | 0 | 18446744073709551615 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| u64 | 0 | 18446744073709551615 |'
- en: ğŸ’¡ Same as signed numbers, min and max values are based on IEEE standard for
    Binary Floating-Point Arithmetic; From **0 to 2â¿-1** . Same way you can use **min_value()**
    and **max_value()** to find min and max of each integer type, ex. u8::max_value();
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ ä¸æœ‰ç¬¦å·æ•°ä¸€æ ·ï¼Œæœ€å°å€¼å’Œæœ€å¤§å€¼åŸºäºIEEEäºŒè¿›åˆ¶æµ®ç‚¹ç®—æœ¯æ ‡å‡†ï¼›ä»**0åˆ°2â¿-1**ã€‚åŒæ ·ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨**min_value()**å’Œ**max_value()**æ¥æ‰¾åˆ°æ¯ç§æ•´æ•°ç±»å‹çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œä¾‹å¦‚u8::max_value();
- en: '**isize** : variable sized signed(+/-) integer'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isize**ï¼šå¯å˜å¤§å°çš„æœ‰ç¬¦å·ï¼ˆ+/-ï¼‰æ•´æ•°'
- en: Simply this is the data type to cover all signed integer types but memory allocates
    according to the size of a pointer. Min and max values are similar to i64 .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€å•æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§æ•°æ®ç±»å‹ï¼Œç”¨äºæ¶µç›–æ‰€æœ‰æœ‰ç¬¦å·æ•´æ•°ç±»å‹ï¼Œä½†å†…å­˜åˆ†é…æ ¹æ®æŒ‡é’ˆçš„å¤§å°ã€‚æœ€å°å’Œæœ€å¤§å€¼ç±»ä¼¼äºi64ã€‚
- en: '**usize** : variable sized unsigned(+) integer'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**usize**ï¼šå¯å˜å¤§å°çš„æ— ç¬¦å·ï¼ˆ+ï¼‰æ•´æ•°'
- en: Simply this is the data type to cover all unsigned integer types but memory
    allocates according to the size of a pointer. Min and max values are similar to
    u64.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€å•æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§æ•°æ®ç±»å‹ï¼Œç”¨äºæ¶µç›–æ‰€æœ‰æ— ç¬¦å·æ•´æ•°ç±»å‹ï¼Œä½†å†…å­˜åˆ†é…æ ¹æ®æŒ‡é’ˆçš„å¤§å°ã€‚æœ€å°å’Œæœ€å¤§å€¼ç±»ä¼¼äºu64ã€‚
- en: '**f32** : 32-bit floating point'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f32**ï¼š32ä½æµ®ç‚¹æ•°'
- en: Similar to float in other languages, **Single precision**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„æµ®ç‚¹æ•°ï¼Œ**å•ç²¾åº¦**ã€‚
- en: ğŸ’¡ Should avoid using this unless you need to reduce memory consumption badly
    or if you are doing low-level optimization, when targeted hardware not supports
    for double-precision or when single-precision is faster than double-precision
    on it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ é™¤éæ‚¨è¿«åˆ‡éœ€è¦å‡å°‘å†…å­˜æ¶ˆè€—ï¼Œæˆ–è€…æ­£åœ¨è¿›è¡Œä½çº§ä¼˜åŒ–ï¼Œå½“ç›®æ ‡ç¡¬ä»¶ä¸æ”¯æŒåŒç²¾åº¦ï¼Œæˆ–è€…å½“å•ç²¾åº¦æ¯”åŒç²¾åº¦æ›´å¿«æ—¶ï¼Œåº”é¿å…ä½¿ç”¨è¿™ç§ç±»å‹ã€‚
- en: '**f64** : 64-bit floating point'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f64**ï¼š64ä½æµ®ç‚¹æ•°'
- en: Similar to double in other languages, **Double precision**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„åŒç²¾åº¦ï¼Œ**åŒç²¾åº¦**ã€‚
- en: '**arrays** : fixed-size list of elements of same data type'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ•°ç»„**ï¼šç›¸åŒæ•°æ®ç±»å‹çš„å›ºå®šå¤§å°å…ƒç´ åˆ—è¡¨'
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: â­ï¸ Arrays are **immutable** by default and also **even with mut, its element
    count can not be changed**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ æ•°ç»„é»˜è®¤ä¸º**ä¸å¯å˜**ï¼Œå³ä½¿ä½¿ç”¨mutï¼Œå…¶å…ƒç´ æ•°é‡ä¹Ÿä¸èƒ½æ›´æ”¹ã€‚
- en: ğŸ” If you are looking for a dynamic/growable array, you can use **Vec**. Vectors
    can contain any type of elements but all elements must be in the same data type.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” å¦‚æœæ‚¨æ­£åœ¨å¯»æ‰¾ä¸€ä¸ªåŠ¨æ€/å¯å¢é•¿çš„æ•°ç»„ï¼Œå¯ä»¥ä½¿ç”¨**Vec**ã€‚å‘é‡å¯ä»¥åŒ…å«ä»»ä½•ç±»å‹çš„å…ƒï¿½ï¿½ï¿½ï¼Œä½†æ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒçš„æ•°æ®ç±»å‹ã€‚
- en: '**tuples** : fixed-size ordered list of elements of different(or same) data
    types'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å…ƒç»„**ï¼šå›ºå®šå¤§å°çš„æœ‰åºå…ƒç´ åˆ—è¡¨ï¼Œå…ƒç´ å¯ä»¥æ˜¯ä¸åŒï¼ˆæˆ–ç›¸åŒï¼‰æ•°æ®ç±»å‹'
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: â­ï¸ Tuples are also **immutable** by default and **even with mut, its element
    count can not be changed. Also if you want to change an elementâ€™s value, new value
    should have the same data type of previous value**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ å…ƒç»„é»˜è®¤ä¹Ÿæ˜¯**ä¸å¯å˜**çš„ï¼Œå³ä½¿ä½¿ç”¨mutï¼Œå…¶å…ƒç´ æ•°é‡ä¹Ÿä¸èƒ½æ›´æ”¹ã€‚æ­¤å¤–ï¼Œå¦‚æœè¦æ›´æ”¹å…ƒç´ çš„å€¼ï¼Œæ–°å€¼åº”ä¸å…ˆå‰çš„æ•°æ®ç±»å‹ç›¸åŒã€‚
- en: '**slice** : dynamically-sized reference to another data structure'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åˆ‡ç‰‡**ï¼šå¯¹å¦ä¸€ä¸ªæ•°æ®ç»“æ„çš„åŠ¨æ€å¤§å°å¼•ç”¨'
- en: Think you want to get/pass a part of an array or any other data structure. Instead
    of copy it to another array (or same data structure), Rust allows to create a
    view/reference to access only that part of data. And it can be mutable or not.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæƒ³è¦è·å–/ä¼ é€’æ•°ç»„æˆ–ä»»ä½•å…¶ä»–æ•°æ®ç»“æ„çš„ä¸€éƒ¨åˆ†ã€‚è€Œä¸æ˜¯å°†å…¶å¤åˆ¶åˆ°å¦ä¸€ä¸ªæ•°ç»„ï¼ˆæˆ–ç›¸åŒæ•°æ®ç»“æ„ï¼‰ä¸­ï¼ŒRustå…è®¸åˆ›å»ºä¸€ä¸ªè§†å›¾/å¼•ç”¨ï¼Œä»…è®¿é—®æ•°æ®çš„é‚£éƒ¨åˆ†ã€‚å®ƒå¯ä»¥æ˜¯å¯å˜çš„æˆ–ä¸å¯å˜çš„ã€‚
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**str** : unsized UTF-8 sequence of Unicode string slices'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**str**ï¼šæœªå®šå¤§å°çš„UTF-8 Unicodeå­—ç¬¦ä¸²åˆ‡ç‰‡'
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: â­ï¸ It's an **immutable/statically allocated slice** holding an **unknown sized
    sequence of UTF-8** code points stored in somewhere in memory. **&str** is used
    to borrow and assign the whole array to the given variable binding.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ è¿™æ˜¯ä¸€ä¸ª**ä¸å¯å˜/é™æ€åˆ†é…çš„åˆ‡ç‰‡**ï¼Œå…¶ä¸­å­˜å‚¨åœ¨å†…å­˜ä¸­çš„æŸä¸ªä½ç½®çš„**æœªçŸ¥å¤§å°çš„UTF-8**ä»£ç ç‚¹åºåˆ—ã€‚**&str**ç”¨äºå€Ÿç”¨å¹¶å°†æ•´ä¸ªæ•°ç»„åˆ†é…ç»™ç»™å®šçš„å˜é‡ç»‘å®šã€‚
- en: 'ğŸ” A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a
    **heap**-allocated string. This string is growable, and is also guaranteed to
    be UTF-8\. They are commonly created by converting from a string slice using the
    **to_string()** or **String::from()** methods. ex: `â€œHelloâ€.to_string();` `String::from("Hello");`'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” [å­—ç¬¦ä¸²](https://doc.rust-lang.org/std/string/struct.String.html)æ˜¯ä¸€ä¸ª**å †**åˆ†é…çš„å­—ç¬¦ä¸²ã€‚è¯¥å­—ç¬¦ä¸²æ˜¯å¯å¢é•¿çš„ï¼Œå¹¶ä¸”ä¿è¯ä¸ºUTF-8ã€‚å®ƒä»¬é€šå¸¸é€šè¿‡ä½¿ç”¨**to_string()**æˆ–**String::from()**æ–¹æ³•ä»å­—ç¬¦ä¸²åˆ‡ç‰‡è½¬æ¢è€Œæ¥ã€‚ä¾‹å¦‚ï¼š`â€œHelloâ€.to_string();`
    `String::from("Hello");`
- en: ğŸ’¡ In general, you should use **String** when you need **ownership**, and **&str**
    when you just need to **borrow a string**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå½“æ‚¨éœ€è¦**æ‰€æœ‰æƒ**æ—¶åº”ä½¿ç”¨**String**ï¼Œå½“æ‚¨åªéœ€è¦**å€Ÿç”¨å­—ç¬¦ä¸²**æ—¶åº”ä½¿ç”¨**&str**ã€‚
- en: '**functions**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å‡½æ•°**'
- en: As we discussed on functions section, b is a function pointer, to plus_one function
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨å‡½æ•°éƒ¨åˆ†è®¨è®ºçš„é‚£æ ·ï¼Œbæ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼ŒæŒ‡å‘plus_oneå‡½æ•°
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Operators
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è¿ç®—ç¬¦
- en: Operators
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è¿ç®—ç¬¦
- en: '**Arithmetic Operators** : + - * / %'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ç®—æœ¯è¿ç®—ç¬¦**ï¼š+ - * / %'
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ğŸ” Also **+** is used for **array and string concatenation**
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” è¿˜æœ‰**+**ç”¨äº**æ•°ç»„å’Œå­—ç¬¦ä¸²çš„è¿æ¥**
- en: '**Comparison Operators** : == != < > <= >='
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ¯”è¾ƒè¿ç®—ç¬¦**ï¼š== != < > <= >='
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Logical Operators** : ! && ||'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**é€»è¾‘è¿ç®—ç¬¦**ï¼š! && ||'
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ğŸ” On integer types, ! inverts the individual bits in the twoâ€™s complement representation
    of the value.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” åœ¨æ•´æ•°ç±»å‹ä¸Šï¼Œ!ä¼šåè½¬å€¼çš„äºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºä¸­çš„å„ä¸ªä½ã€‚
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Bitwise Operators** : & | ^ << >>'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ä½è¿ç®—ç¬¦**ï¼š& | ^ << >>'
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Assignment and Compound Assignment Operators**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**èµ‹å€¼å’Œå¤åˆèµ‹å€¼è¿ç®—ç¬¦**'
- en: The = operator is used to assign a name to a value or a function. Compound Assignment
    Operators are created by composing one of + - * / % & | ^ << >> operators with
    = operator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: =è¿ç®—ç¬¦ç”¨äºå°†å€¼æˆ–å‡½æ•°çš„åç§°åˆ†é…ç»™ä¸€ä¸ªåç§°ã€‚å¤åˆèµ‹å€¼è¿ç®—ç¬¦æ˜¯é€šè¿‡å°†+ - * / % & | ^ << >>è¿ç®—ç¬¦ä¹‹ä¸€ä¸=è¿ç®—ç¬¦ç»„åˆè€Œæˆçš„ã€‚
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Type Casting Operator** : as'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ç±»å‹è½¬æ¢è¿ç®—ç¬¦**ï¼šas'
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Borrowing and Dereference Operators** : & &mut *'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å€Ÿç”¨å’Œè§£å¼•ç”¨è¿ç®—ç¬¦**ï¼š& &mut *'
- en: The **& or &mut** operators are used for **borrowing** and ***** operator for
    **Dereferencing**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**&æˆ–&mut**è¿ç®—ç¬¦ç”¨äº**å€Ÿç”¨**ï¼Œ*****è¿ç®—ç¬¦ç”¨äº**è§£å¼•ç”¨**ã€‚'
- en: ğŸ” Usage of these operators is an advanced topic, for more information use [Rust
    Reference Documentation](https://doc.rust-lang.org/reference.html#unary-operator-expressions).
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” è¿™äº›è¿ç®—ç¬¦çš„ä½¿ç”¨æ˜¯ä¸€ä¸ªé«˜çº§è¯é¢˜ï¼Œæ›´å¤šä¿¡æ¯è¯·å‚è€ƒ[Rustå‚è€ƒæ–‡æ¡£](https://doc.rust-lang.org/reference.html#unary-operator-expressions)ã€‚
- en: Control Flows
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ§åˆ¶æµ
- en: Control Flows
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ§åˆ¶æµ
- en: '**if - else if - else**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if - else if - else**'
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: â­ï¸ **Return data type should be same on each block, when using this as an expression.**
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ **å½“å°†å…¶ç”¨ä½œè¡¨è¾¾å¼æ—¶ï¼Œæ¯ä¸ªå—çš„è¿”å›æ•°æ®ç±»å‹åº”è¯¥ç›¸åŒã€‚**
- en: '**match**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åŒ¹é…**'
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**while**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**while**'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**loop**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å¾ªç¯**'
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**for**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for**'
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Vectors
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‘é‡
- en: Vectors
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‘é‡
- en: If you remember, array is a fixed-size list of elements, of same data type.
    Even with mut, itâ€™s element count can not be changed. Vector is kind of a re-sizable
    array but all elements must be in the same type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨è®°å¾—ï¼Œæ•°ç»„æ˜¯ç›¸åŒæ•°æ®ç±»å‹çš„å›ºå®šå¤§å°å…ƒç´ åˆ—è¡¨ã€‚å³ä½¿ä½¿ç”¨mutï¼Œå…¶å…ƒç´ è®¡æ•°ä¹Ÿä¸èƒ½æ›´æ”¹ã€‚å‘é‡æ˜¯ä¸€ç§å¯è°ƒæ•´å¤§å°çš„æ•°ç»„ï¼Œä½†æ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒç±»å‹çš„ã€‚
- en: â­ï¸ Itâ€™s a generic type, written as Vec <t class="hljs-meta">. T can have any
    type, ex. The type of a Vec of i32s is Vec<i32 class="hljs-meta">. Also Vectors
    always allocate their data in dynamically allocated heap.</i32></t>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ è¿™æ˜¯ä¸€ä¸ªé€šç”¨ç±»å‹ï¼Œå†™ä½œVec <t class="hljs-meta">ã€‚Tå¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œä¾‹å¦‚ã€‚i32sçš„Vecçš„ç±»å‹æ˜¯Vec<i32 class="hljs-meta">ã€‚æ­¤å¤–ï¼Œå‘é‡æ€»æ˜¯åœ¨åŠ¨æ€åˆ†é…çš„å †ä¸­åˆ†é…å®ƒä»¬çš„æ•°æ®ã€‚</i32></t>
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: â­ï¸ Mainly a vector represent 3 things; a pointer to the data, No of elements
    currently have(length), capacity (Amount of space allocated for any future elements).
    If the length of a vector exceeds its capacity, its capacity will be increased
    automatically. But its elements will be reallocated(which can be slow). So always
    use Vec::with_capacity whenever itâ€™s possible.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ ä¸»è¦ä¸€ä¸ªå‘é‡ä»£è¡¨3ä¸ªä¸œè¥¿ï¼›æŒ‡å‘æ•°æ®çš„æŒ‡é’ˆï¼Œå½“å‰æ‹¥æœ‰çš„å…ƒç´ æ•°é‡ï¼ˆé•¿åº¦ï¼‰ï¼Œå®¹é‡ï¼ˆä¸ºä»»ä½•æœªæ¥å…ƒç´ åˆ†é…çš„ç©ºé—´é‡ï¼‰ã€‚å¦‚æœå‘é‡çš„é•¿åº¦è¶…è¿‡å…¶å®¹é‡ï¼Œå…¶å®¹é‡å°†è‡ªåŠ¨å¢åŠ ã€‚ä½†å…¶å…ƒç´ å°†è¢«é‡æ–°åˆ†é…ï¼ˆå¯èƒ½ä¼šå¾ˆæ…¢ï¼‰ã€‚å› æ­¤ï¼Œå°½å¯èƒ½åœ¨å¯èƒ½çš„æƒ…å†µä¸‹å§‹ç»ˆä½¿ç”¨Vec::with_capacityã€‚
- en: ğŸ” String data type is a UTF-8 encoded vector. But you can not index into a String
    because of encoding.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” å­—ç¬¦ä¸²æ•°æ®ç±»å‹æ˜¯UTF-8ç¼–ç çš„å‘é‡ã€‚ä½†ç”±äºç¼–ç çš„åŸå› ï¼Œæ‚¨æ— æ³•å¯¹å­—ç¬¦ä¸²è¿›è¡Œç´¢å¼•ã€‚
- en: Vectors can be used with iterators in three ways,
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: å‘é‡å¯ä»¥ä»¥ä¸‰ç§æ–¹å¼ä¸è¿­ä»£å™¨ä¸€èµ·ä½¿ç”¨ï¼Œ
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Structs
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“æ„ä½“
- en: Structs
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“æ„ä½“
- en: â­ï¸ Structs are used to encapsulate related properties into one unified datatype.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ ç»“æ„ä½“ç”¨äºå°†ç›¸å…³å±æ€§å°è£…æˆä¸€ä¸ªç»Ÿä¸€çš„æ•°æ®ç±»å‹ã€‚
- en: ğŸ’¡ By convention, the name of the struct starts with a capital letter and follows
    CamelCase.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ æŒ‰ç…§æƒ¯ä¾‹ï¼Œç»“æ„ä½“çš„åç§°ä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼Œå¹¶éµå¾ªé©¼å³°å‘½åæ³•ã€‚
- en: There are 3 variants of structs,
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰3ç§ç»“æ„ä½“çš„å˜ä½“ï¼Œ
- en: C-like structs
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç±»ä¼¼Cçš„ç»“æ„ä½“
- en: one or more comma separated name:value pairs
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæˆ–å¤šä¸ªé€—å·åˆ†éš”çš„åç§°:å€¼å¯¹
- en: brace-enclosed list
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¤§æ‹¬å·åŒ…å›´çš„åˆ—è¡¨
- en: similar to classes (without itâ€™s methods) in other languages like Java
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸å…¶ä»–è¯­è¨€ï¼ˆå¦‚Javaï¼‰ä¸­çš„ç±»ï¼ˆæ²¡æœ‰æ–¹æ³•ï¼‰ç±»ä¼¼
- en: because fields have names, we can access them through dot notation
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å› ä¸ºå­—æ®µæœ‰åç§°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡ï¿½ï¿½ï¿½ç¬¦å·è®¿é—®å®ƒä»¬
- en: Tuple structs
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: å…ƒç»„ç»“æ„ä½“
- en: one or more comma separated values
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæˆ–å¤šä¸ªé€—å·åˆ†éš”çš„å€¼
- en: parenthesized list like tuples
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åƒå…ƒç»„ä¸€æ ·ç”¨æ‹¬å·æ‹¬èµ·æ¥çš„åˆ—è¡¨
- en: looks like a named tuples
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: çœ‹èµ·æ¥åƒå‘½åå…ƒç»„
- en: Unit structs
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: å•å…ƒç»“æ„ä½“
- en: a struct with no members at all
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ²¡æœ‰ä»»ä½•æˆå‘˜çš„ç»“æ„ä½“
- en: it defines a new type but it resembles an empty tuple, ()
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å®ƒå®šä¹‰äº†ä¸€ä¸ªæ–°ç±»å‹ï¼Œä½†å®ƒç±»ä¼¼äºä¸€ä¸ªç©ºå…ƒç»„ï¼Œ()
- en: rarely in use, useful with generics
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¾ˆå°‘ä½¿ç”¨ï¼Œä¸æ³›å‹ä¸€èµ·å¾ˆæœ‰ç”¨
- en: â­ï¸ When regarding OOP in Rust, attributes and methods are placed separately
    on structs and traits. Structs contain only attributes, traits contain only methods.
    They are getting connected via impls
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ åœ¨Rustä¸­æ¶‰åŠé¢å‘å¯¹è±¡ç¼–ç¨‹æ—¶ï¼Œå±æ€§å’Œæ–¹æ³•åˆ†åˆ«æ”¾ç½®åœ¨ç»“æ„ä½“å’Œç‰¹å¾ä¸Šã€‚ç»“æ„ä½“ä»…åŒ…å«å±æ€§ï¼Œç‰¹å¾ä»…åŒ…å«æ–¹æ³•ã€‚å®ƒä»¬é€šè¿‡implsè¿æ¥åœ¨ä¸€èµ·
- en: 01\. C-like structs
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 01\. ç±»Cç»“æ„ä½“
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 02\. Tuple structs
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 02\. å…ƒç»„ç»“æ„ä½“
- en: â­ï¸ When a tuple struct has only one element, we called it â€˜newtypeâ€™ pattern.
    Because it helps to create a new type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ å½“å…ƒç»„ç»“æ„åªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º 'newtype' æ¨¡å¼ã€‚å› ä¸ºå®ƒæœ‰åŠ©äºåˆ›å»ºä¸€ä¸ªæ–°ç±»å‹ã€‚
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 03\. Unit structs
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 03\. å•å…ƒç»“æ„ä½“
- en: This is rarely useful on its own, but in combination with other features, it
    can become useful.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æœ¬èº«å¾ˆå°‘æœ‰ç”¨ï¼Œä½†ä¸å…¶ä»–åŠŸèƒ½ç»“åˆä½¿ç”¨æ—¶ï¼Œå®ƒå¯ä»¥å˜å¾—æœ‰ç”¨ã€‚
- en: 'ğŸ“– ex: A library may ask you to create a structure that implements a certain
    trait to handle events. If you donâ€™t have any data you need to store in the structure,
    you can create a unit-like struct.'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ“– ä¾‹å¦‚ï¼šä¸€ä¸ªåº“å¯èƒ½ä¼šè¦æ±‚æ‚¨åˆ›å»ºä¸€ä¸ªå®ç°æŸä¸ªç‰¹å®šç‰¹å¾ä»¥å¤„ç†äº‹ä»¶çš„ç»“æ„ã€‚å¦‚æœæ‚¨ä¸éœ€è¦åœ¨ç»“æ„ä¸­å­˜å‚¨ä»»ä½•æ•°æ®ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªç±»ä¼¼äºå•å…ƒçš„ç»“æ„ã€‚
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Enums
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æšä¸¾
- en: Enums
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æšä¸¾
- en: â­ï¸ An enum is a single type. It contains variants, which are possible values
    of the enum at a given time. For example,
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ æšä¸¾æ˜¯ä¸€ä¸ªå•ä¸€ç±»å‹ã€‚å®ƒåŒ…å«å˜ä½“ï¼Œè¿™äº›æ˜¯æšä¸¾åœ¨ç»™å®šæ—¶é—´çš„å¯èƒ½å€¼ã€‚ä¾‹å¦‚ï¼Œ
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'â­ï¸ Variants can be accessed through :: notation , ex. Day::Sunday'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'â­ï¸ å¯ä»¥é€šè¿‡ :: ç¬¦å·è®¿é—®å˜ä½“ï¼Œä¾‹å¦‚ Day::Sunday'
- en: â­ï¸ Each enum variant can have,
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ æ¯ä¸ªæšä¸¾å˜ä½“éƒ½å¯ä»¥æœ‰ï¼Œ
- en: no data (unit variant)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ— æ•°æ®ï¼ˆå•å…ƒå˜ä½“ï¼‰
- en: unnamed ordered data (tuple variant)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœªå‘½åçš„æœ‰åºæ•°æ®ï¼ˆå…ƒç»„å˜ä½“ï¼‰
- en: named data (struct variant)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‘½åæ•°æ®ï¼ˆstruct å˜ä½“ï¼‰
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Generics
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ³›å‹
- en: Generics
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ³›å‹
- en: ğŸ“– Sometimes, when writing a function or data type, we may want it to work for
    multiple types of arguments. In Rust, we can do this with generics.
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ“– æœ‰æ—¶ï¼Œåœ¨ç¼–å†™å‡½æ•°æˆ–æ•°æ®ç±»å‹æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›å®ƒé€‚ç”¨äºå¤šç§ç±»å‹çš„å‚æ•°ã€‚åœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ³›å‹æ¥å®ç°è¿™ä¸€ç‚¹ã€‚
- en: 'ğŸ’­ The concept is, instead of declaring a specific data type we use an uppercase
    letter(or CamelCase identifier). ex, instead x : u8 we use x : T . but we have
    to inform to the compiler that T is a generic type(can be any type) by adding
    <t class="hljs-meta">at first.</t>'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'ğŸ’­ è¿™ä¸ªæ¦‚å¿µæ˜¯ï¼Œæˆ‘ä»¬ä¸æ˜¯å£°æ˜ä¸€ä¸ªç‰¹å®šçš„æ•°æ®ç±»å‹ï¼Œè€Œæ˜¯ä½¿ç”¨ä¸€ä¸ªå¤§å†™å­—æ¯ï¼ˆæˆ– CamelCase æ ‡è¯†ç¬¦ï¼‰ã€‚ä¾‹å¦‚ï¼Œä»£æ›¿ x : u8ï¼Œæˆ‘ä»¬ä½¿ç”¨ x : Tã€‚ä½†æˆ‘ä»¬å¿…é¡»å‘ç¼–è¯‘å™¨å£°æ˜
    T æ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹ï¼ˆå¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼‰ï¼Œé€šè¿‡åœ¨æœ€å‰é¢æ·»åŠ  <t class="hljs-meta">ã€‚</t>'
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: â­ï¸ Above Option and Result types are kind of special generic types which are
    already defined in Rustâ€™s standard library.
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: â­ï¸ ä¸Šè¿° Option å’Œ Result ç±»å‹æ˜¯ Rust æ ‡å‡†åº“ä¸­å·²ç»å®šä¹‰çš„ä¸€äº›ç‰¹æ®Šæ³›å‹ç±»å‹ã€‚
- en: ''
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An optional value can have either Some value or no value/ None.
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯é€‰å€¼å¯ä»¥æ˜¯ Some å€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯æ²¡æœ‰å€¼ / Noneã€‚
- en: A result can represent either success/ Ok or failure/ Err
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»“æœå¯ä»¥è¡¨ç¤ºæˆåŠŸ / Ok æˆ–å¤±è´¥ / Err
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ğŸ“– The Option type is a way to use Rustâ€™s type system to express the possibility
    of absence. Result expresses the possibility of error.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ“– Option ç±»å‹æ˜¯ä½¿ç”¨ Rust çš„ç±»å‹ç³»ç»Ÿæ¥è¡¨è¾¾ç¼ºå¤±å¯èƒ½æ€§çš„ä¸€ç§æ–¹å¼ã€‚Result è¡¨è¾¾äº†é”™è¯¯çš„å¯èƒ½æ€§ã€‚
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ğŸ” Many useful methods have been implemented around Option and Result types.
    More information can be found on std::option::Option and std::result::Result pages
    on Rust doc.
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” åœ¨ Option å’Œ Result ç±»å‹å‘¨å›´å·²ç»å®ç°äº†è®¸å¤šæœ‰ç”¨çš„æ–¹æ³•ã€‚å…³äºå®ƒä»¬çš„æ›´å¤šä¿¡æ¯å¯ä»¥åœ¨ Rust æ–‡æ¡£ä¸­çš„ std::option::Option
    å’Œ std::result::Result é¡µé¢æ‰¾åˆ°ã€‚
- en: â­ï¸ Also more practical examples of options & results can be found on Error Handling
    section in Rust doc.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ åœ¨ Rust æ–‡æ¡£çš„é”™è¯¯å¤„ç†éƒ¨åˆ†ä¹Ÿå¯ä»¥æ‰¾åˆ°æ›´å¤šå…³äºé€‰é¡¹ï¼ˆOptionsï¼‰å’Œç»“æœï¼ˆResultsï¼‰çš„å®ç”¨ç¤ºä¾‹ã€‚
- en: Impls & Traits
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å®ç° & ç‰¹å¾
- en: Impls & Traits
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å®ç° & ç‰¹å¾
- en: ğŸ’¡ When we discussed about C-like structs, I mentioned that those are similar
    to classes in other languages like Java, but without their methods. impls are
    used to define methods for Rust structs and enums.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ å½“æˆ‘ä»¬è®¨è®ºç±»ä¼¼äº C çš„ç»“æ„ä½“æ—¶ï¼Œæˆ‘æåˆ°è¿‡å®ƒä»¬ä¸å…¶ä»–è¯­è¨€ï¼ˆå¦‚ Javaï¼‰ä¸­çš„ç±»ç›¸ä¼¼ï¼Œä½†æ²¡æœ‰å®ƒä»¬çš„æ–¹æ³•ã€‚impls ç”¨äºä¸º Rust ç»“æ„ä½“å’Œæšä¸¾å®šä¹‰æ–¹æ³•ã€‚
- en: ğŸ’¡ Traits are kind of similar to interfaces in other languages like Java. They
    are used to define the functionality a type must provide. Multiple traits can
    be implemented to a single type.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ ç‰¹å¾ä¸å…¶ä»–è¯­è¨€ï¼ˆå¦‚ Javaï¼‰ä¸­çš„æ¥å£æœ‰äº›ç›¸ä¼¼ã€‚å®ƒä»¬ç”¨äºå®šä¹‰ç±»å‹å¿…é¡»æä¾›çš„åŠŸèƒ½ã€‚ä¸€ä¸ªç±»å‹å¯ä»¥å®ç°å¤šä¸ªç‰¹å¾ã€‚
- en: â­ï¸â­ï¸â­ï¸ But traits can also include default implementations of methods. Default
    methods can be override when implementing types.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸â­ï¸â­ï¸ ä½†ç‰¹å¾ä¹Ÿå¯ä»¥åŒ…å«æ–¹æ³•çš„é»˜è®¤å®ç°ã€‚å½“å®ç°ç±»å‹æ—¶ï¼Œå¯ä»¥è¦†ç›–é»˜è®¤æ–¹æ³•ã€‚
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: â­ï¸ As you can see methods take a special first parameter, the type itself. It
    can be either self, &self, or &mut self . self if itâ€™s a value on the stack(taking
    ownership), &self if itâ€™s a reference, and &mut self if itâ€™s a mutable reference.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ æ­£å¦‚æ‚¨æ‰€è§ï¼Œæ–¹æ³•æ¥å—ä¸€ä¸ªç‰¹æ®Šçš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå³ç±»å‹æœ¬èº«ã€‚å®ƒå¯ä»¥æ˜¯ selfã€&self æˆ– &mut selfã€‚å¦‚æœå®ƒæ˜¯å †æ ˆä¸Šçš„å€¼ï¼ˆæ‹¥æœ‰æƒï¼‰ï¼Œåˆ™ä¸º
    selfï¼Œå¦‚æœå®ƒæ˜¯å¼•ç”¨ï¼Œåˆ™ä¸º &selfï¼Œå¦‚æœå®ƒæ˜¯å¯å˜å¼•ç”¨ï¼Œåˆ™ä¸º &mut selfã€‚
- en: 'â­ï¸ Some other languages support static methods. At such times, we call a function
    directly through the class without creating an object. In Rust, we call them Associated
    Functions. we use :: instead of . when calling them from struct. ex. Person::new(â€œElon
    Musk Jrâ€);'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'â­ï¸ ä¸€äº›å…¶ä»–è¯­è¨€æ”¯æŒé™æ€æ–¹æ³•ã€‚è¿™æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡ç±»è°ƒç”¨ä¸€ä¸ªå‡½æ•°è€Œä¸åˆ›å»ºå¯¹è±¡ã€‚åœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºå…³è”å‡½æ•°ã€‚å½“ä»ç»“æ„ä½“è°ƒç”¨å®ƒä»¬æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨
    :: è€Œä¸æ˜¯ .ã€‚ä¾‹å¦‚ï¼ŒPerson::newï¼ˆâ€œåŸƒéš†Â·é©¬æ–¯å…‹Â·å°â€ï¼‰;'
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: â­ï¸ Traits may inherit from other traits.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ ç‰¹å¾å¯ä»¥ç»§æ‰¿è‡ªå…¶ä»–ç‰¹å¾ã€‚
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ğŸ” While Rust favors static dispatch, it also supports dynamic dispatch through
    a mechanism called â€˜trait objects.â€™
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ” è™½ç„¶Ruståå‘äºé™æ€åˆ†æ´¾ï¼Œä½†ä¹Ÿæ”¯æŒé€šè¿‡ä¸€ç§ç§°ä¸ºâ€˜ç‰¹è´¨å¯¹è±¡â€™çš„æœºåˆ¶è¿›è¡ŒåŠ¨æ€åˆ†æ´¾ã€‚
- en: ğŸ…† Dynamic dispatch is the process of selecting which implementation of a polymorphic
    operation (method or function) to call at run time.
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ…† åŠ¨æ€åˆ†æ´¾æ˜¯åœ¨è¿è¡Œæ—¶é€‰æ‹©è¦è°ƒç”¨çš„å¤šæ€æ“ä½œï¼ˆæ–¹æ³•æˆ–å‡½æ•°ï¼‰çš„è¿‡ç¨‹ã€‚
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Ownership
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‹¥æœ‰æƒ
- en: Ownership
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‹¥æœ‰æƒ
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the above examples, we are just trying to **assign the value of â€˜aâ€™ to â€˜bâ€™**
    . Almost the same code in both code blocks, but having **two different data types**.
    And the second one gives an error. This is because of the **Ownership**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯å°è¯•**å°†â€˜aâ€™çš„å€¼èµ‹ç»™â€˜bâ€™**ã€‚ä¸¤ä¸ªä»£ç å—ä¸­çš„ä»£ç å‡ ä¹ç›¸åŒï¼Œä½†æœ‰**ä¸¤ç§ä¸åŒçš„æ•°æ®ç±»å‹**ã€‚ç¬¬äºŒä¸ªä¼šæŠ¥é”™ã€‚è¿™æ˜¯å› ä¸º**æ‰€æœ‰æƒ**ã€‚
- en: â­ï¸ Variable bindings have **ownership** of what theyâ€™re bound to. A piece of
    data can only have **one owner at a time**. When a binding goes out of scope,
    Rust will free the bound resources. This is how Rust achieves **memory safety**.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ å˜é‡ç»‘å®šæ‹¥æœ‰å®ƒä»¬æ‰€ç»‘å®šçš„**æ‰€æœ‰æƒ**ã€‚ä¸€æ®µæ•°æ®ä¸€æ¬¡åªèƒ½æœ‰**ä¸€ä¸ªæ‰€æœ‰è€…**ã€‚å½“ä¸€ä¸ªç»‘å®šè¶…å‡ºèŒƒå›´æ—¶ï¼ŒRustä¼šé‡Šæ”¾ç»‘å®šçš„èµ„æºã€‚è¿™å°±æ˜¯Rustå®ç°**å†…å­˜å®‰å…¨**çš„æ–¹å¼ã€‚
- en: '[Ownership (noun)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[æ‰€æœ‰æƒï¼ˆåè¯ï¼‰](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
- en: The act, state, or right of possessing something.
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ‹¥æœ‰æŸç‰©çš„è¡Œä¸ºã€çŠ¶æ€æˆ–æƒåˆ©ã€‚
- en: â­ï¸ **When assigning** a variable binding to another variable binding **or when
    passing it to a function**(Without referencing), if its data type is a
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ **å½“å°†**ä¸€ä¸ªå˜é‡ç»‘å®š**èµ‹ç»™å¦ä¸€ä¸ªå˜é‡ç»‘å®š**æ—¶ï¼ˆä¸å¼•ç”¨ï¼‰ï¼Œå¦‚æœå…¶æ•°æ®ç±»å‹æ˜¯ä¸€ä¸ª
- en: '**Copy Type**'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å¤åˆ¶ç±»å‹**'
- en: Bound resources are **made a copy and assign** or pass it to the function.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»‘å®šçš„èµ„æºè¢«**å¤åˆ¶å¹¶åˆ†é…**æˆ–ä¼ é€’ç»™å‡½æ•°ã€‚
- en: The ownership state of the original bindings are set to **â€œcopiedâ€ state**.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åŸå§‹ç»‘å®šçš„æ‰€æœ‰æƒçŠ¶æ€è¢«è®¾ç½®ä¸º**â€œå¤åˆ¶â€çŠ¶æ€**ã€‚
- en: '**Mostly Primitive types**'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å¤§å¤šæ•°åŸå§‹ç±»å‹**'
- en: '**Move type**'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ç§»åŠ¨ç±»å‹**'
- en: Bound resources are **moved** to the new variable binding and we **can not access
    the original variable binding** anymore.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»‘å®šçš„èµ„æºè¢«**ç§»åŠ¨**åˆ°æ–°çš„å˜é‡ç»‘å®šï¼Œæˆ‘ä»¬**æ— æ³•å†è®¿é—®åŸå§‹çš„å˜é‡ç»‘å®š**ã€‚
- en: The ownership state of the original bindings are set to **â€œmovedâ€ state**.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åŸå§‹ç»‘å®šçš„æ‰€æœ‰æƒçŠ¶æ€è¢«è®¾ç½®ä¸º**â€œç§»åŠ¨â€çŠ¶æ€**ã€‚
- en: '**Non-primitive types**'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**éåŸå§‹ç±»å‹**'
- en: ğŸ” The functionality of a type is handled by the traits which have been implemented
    to it. By default, variable bindings have â€˜move semantics.â€™ However, if a type
    implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html)
    , it has a 'copy semantics'.
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” ä¸€ä¸ªç±»å‹çš„åŠŸèƒ½ç”±å·²å®ç°çš„ç‰¹è´¨å¤„ç†ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå˜é‡ç»‘å®šå…·æœ‰â€˜ç§»åŠ¨è¯­ä¹‰â€™ã€‚ä½†æ˜¯ï¼Œå¦‚æœä¸€ä¸ªç±»å‹å®ç°äº†[**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html)ï¼Œå®ƒå…·æœ‰'å¤åˆ¶è¯­ä¹‰'ã€‚
- en: ğŸ’¡ **So in the above second example, ownership of the Vec object moves to â€œbâ€
    and â€œaâ€ doesnâ€™t have any ownership to access the resource.**
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ **æ‰€ä»¥åœ¨ä¸Šé¢çš„ç¬¬äºŒä¸ªä¾‹å­ä¸­ï¼ŒVecå¯¹è±¡çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°â€œbâ€ï¼Œâ€œaâ€æ²¡æœ‰æ‰€æœ‰æƒè®¿é—®èµ„æºã€‚**
- en: Borrowing
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å€Ÿç”¨
- en: Borrowing
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å€Ÿç”¨
- en: In real life applications, most of the times we have to pass variable bindings
    to other functions or assign them to another variable bindings. In this case we
    **referencing** the original binding; **borrow** the data of it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦å°†å˜é‡ç»‘å®šä¼ é€’ç»™å…¶ä»–å‡½æ•°æˆ–å°†å®ƒä»¬åˆ†é…ç»™å¦ä¸€ä¸ªå˜é‡ç»‘å®šã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬**å¼•ç”¨**åŸå§‹ç»‘å®šï¼›**å€Ÿç”¨**å®ƒçš„æ•°æ®ã€‚
- en: '[Borrow (verb)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[å€Ÿç”¨ï¼ˆåŠ¨è¯ï¼‰](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
- en: To receive something with the promise of returning it.
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¸¦æœ‰æ‰¿è¯ºè¿”å›çš„æ¥æ”¶ã€‚
- en: â­ï¸ There are two types of Borrowing,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ æœ‰ä¸¤ç§å€Ÿç”¨ç±»å‹ï¼Œ
- en: '**Shared Borrowing** `(&T)`'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å…±äº«å€Ÿç”¨** `(&T)`'
- en: A piece of data can be **borrowed by a single or multiple users**, but **data
    should not be altered**.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€æ®µæ•°æ®å¯ä»¥è¢«**å•ä¸ªæˆ–å¤šä¸ªç”¨æˆ·å€Ÿç”¨**ï¼Œä½†**æ•°æ®ä¸åº”è¯¥è¢«æ›´æ”¹**ã€‚
- en: '**Mutable Borrowing** `(&mut T)`'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å¯å˜å€Ÿç”¨** `(&mut T)`'
- en: A piece of data can be **borrowed and altered by a single user**, but the data
    should not be accessible for any other users at that time.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€æ®µæ•°æ®å¯ä»¥è¢«**å•ä¸ªç”¨æˆ·å€Ÿç”¨å¹¶æ›´æ”¹**ï¼Œä½†æ­¤æ—¶å…¶ä»–ç”¨æˆ·ä¸åº”è¯¥èƒ½å¤Ÿè®¿é—®è¯¥æ•°æ®ã€‚
- en: â­ï¸ And there are **very important rules** regarding borrowing,
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ è¿˜æœ‰å…³äºå€Ÿç”¨çš„**éå¸¸é‡è¦çš„è§„åˆ™**ï¼Œ
- en: One piece of data can be borrowed **either** as a shared borrow **or** as a
    mutable borrow **at a given time. But not both at the same time**.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸€æ®µæ•°æ®å¯ä»¥è¢«å€Ÿç”¨ä¸º**å…±äº«å€Ÿç”¨** **æˆ–** ä½œä¸ºå¯å˜å€Ÿç”¨ **ä¹‹ä¸€**ã€‚ä½†ä¸èƒ½åŒæ—¶å‘ç”Ÿã€‚
- en: Borrowing **applies for both copy types and move types**.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å€Ÿç”¨**é€‚ç”¨äºå¤åˆ¶ç±»å‹å’Œç§»åŠ¨ç±»å‹**ã€‚
- en: The concept of **Liveness** â†´
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**æ´»æ€§**çš„æ¦‚å¿µ â†´'
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ğŸ’¡ **Letâ€™s see how to use shared and mutable borrowings in examples.**
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ **è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•åœ¨ç¤ºä¾‹ä¸­ä½¿ç”¨å…±äº«å’Œå¯å˜å€Ÿç”¨ã€‚**
- en: Examples for Shared Borrowing
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…±äº«å€Ÿç”¨ç¤ºä¾‹
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Examples for Mutable Borrowing
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯å˜å€Ÿç”¨ç¤ºä¾‹
- en: '[PRE49]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Lifetimes
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç”Ÿå‘½å‘¨æœŸ
- en: Lifetimes
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç”Ÿå‘½å‘¨æœŸ
- en: When we are dealing with references, we have to make sure that the referencing
    data stay alive until we are stop using the references.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬å¤„ç†å¼•ç”¨æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ç¡®ä¿å¼•ç”¨çš„æ•°æ®åœ¨æˆ‘ä»¬åœæ­¢ä½¿ç”¨å¼•ç”¨ä¹‹å‰ä¿æŒå­˜æ´»ã€‚
- en: Think,
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³ä¸€æƒ³ï¼Œ
- en: We have a variable binding, â€œ**a**â€.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰ä¸€ä¸ªå˜é‡ç»‘å®šï¼Œâ€œ**a**â€ã€‚
- en: We are referencing the value of â€œaâ€, from another variable binding â€œ**x**â€.
    We have to make sure that â€œaâ€ **lives** until we stop using â€œxâ€
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ­£åœ¨å¼•ç”¨â€œaâ€çš„å€¼ï¼Œæ¥è‡ªå¦ä¸€ä¸ªå˜é‡ç»‘å®šâ€œ**x**â€ã€‚æˆ‘ä»¬å¿…é¡»ç¡®ä¿â€œaâ€åœ¨æˆ‘ä»¬åœæ­¢ä½¿ç”¨â€œxâ€ä¹‹å‰**å­˜æ´»**ã€‚
- en: ğŸ” **Memory management** is a form of resource management applied to computer
    memory. Up until the mid-1990s, the majority of programming languages used **Manual
    Memory Management** which **requires the programmer to give manual instructions**
    to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy
    invented **Garbage collection**(GC), a form of **Automatic Memory Management**(AMM).
    It determines what memory is no longer used and frees it automatically instead
    of relying on the programmer. However **Objective-C and Swift** provide similar
    functionality through **Automatic Reference Counting**(ARC).
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ” **å†…å­˜ç®¡ç†**æ˜¯åº”ç”¨äºè®¡ç®—æœºå†…å­˜çš„èµ„æºç®¡ç†å½¢å¼ã€‚ç›´åˆ°1990å¹´ä»£ä¸­æœŸï¼Œå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä½¿ç”¨**æ‰‹åŠ¨å†…å­˜ç®¡ç†**ï¼Œéœ€è¦ç¨‹åºå‘˜ç»™å‡ºæ‰‹åŠ¨æŒ‡ä»¤æ¥è¯†åˆ«å’Œé‡Šæ”¾æœªä½¿ç”¨çš„å¯¹è±¡/åƒåœ¾ã€‚çº¦1959å¹´ï¼Œçº¦ç¿°Â·éº¦å¡é”¡å‘æ˜äº†**åƒåœ¾æ”¶é›†**(GC)ï¼Œä¸€ç§**è‡ªåŠ¨å†…å­˜ç®¡ç†**(AMM)å½¢å¼ã€‚å®ƒç¡®å®šå“ªäº›å†…å­˜ä¸å†ä½¿ç”¨å¹¶è‡ªåŠ¨é‡Šæ”¾ï¼Œè€Œä¸ä¾èµ–äºç¨‹åºå‘˜ã€‚ç„¶è€Œï¼Œ**Objective-Cå’ŒSwift**é€šè¿‡**è‡ªåŠ¨å¼•ç”¨è®¡æ•°**(ARC)æä¾›ç±»ä¼¼åŠŸèƒ½ã€‚
- en: In Rust,
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Rustä¸­ï¼Œ
- en: A resource can only have **one owner** at a time. When it goes **out of the
    scope**, Rust removes it from the Memory.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªèµ„æºä¸€æ¬¡åªèƒ½æœ‰**ä¸€ä¸ªæ‰€æœ‰è€…**ã€‚å½“å®ƒè¶…å‡ºèŒƒå›´æ—¶ï¼ŒRustä¼šå°†å…¶ä»å†…å­˜ä¸­ç§»é™¤ã€‚
- en: When we want to reuse the same resource, we are **referencing** it/ **borrowing**
    its content.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬æƒ³è¦é‡å¤ä½¿ç”¨ç›¸åŒçš„èµ„æºæ—¶ï¼Œæˆ‘ä»¬æ­£åœ¨**å¼•ç”¨**å®ƒ/ **å€Ÿç”¨**å…¶å†…å®¹ã€‚
- en: When dealing with **references**, we have to specify **lifetime annotations**
    to provide instructions for the **compiler** to set **how long** those referenced
    resources **should be alive**.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¤„ç†**å¼•ç”¨**æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»æŒ‡å®š**ç”Ÿå‘½å‘¨æœŸæ³¨è§£**ï¼Œä»¥ä¾¿ä¸º**ç¼–è¯‘å™¨**æä¾›æŒ‡ç¤ºï¼Œè®¾ç½®è¿™äº›å¼•ç”¨èµ„æº**åº”è¯¥å­˜æ´»å¤šä¹…**ã€‚
- en: â­ï¸But because of lifetime annotations make **code more verbose**, in order to
    make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**
    in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: â­ï¸ä½†æ˜¯ç”±äºç”Ÿå‘½å‘¨æœŸæ³¨è§£ä½¿**ä»£ç æ›´å†—é•¿**ï¼Œä¸ºäº†ä½¿**å¸¸è§æ¨¡å¼**æ›´ç¬¦åˆäººä½“å·¥ç¨‹å­¦ï¼ŒRustå…è®¸åœ¨`fn`å®šä¹‰ä¸­**çœç•¥**ç”Ÿå‘½å‘¨æœŸã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼š**éšå¼**åˆ†é…ç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚
- en: Lifetime annotations are **checked at compile-time**. Compiler checks when a
    data is used for the first and the last times. According to that, Rust manages
    memory in **run time**. This is the major reason of having **slower compilation
    times** in Rust.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿå‘½å‘¨æœŸæ³¨è§£åœ¨**ç¼–è¯‘æ—¶æ£€æŸ¥**ã€‚ç¼–è¯‘å™¨åœ¨æ•°æ®ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡ä½¿ç”¨æ—¶è¿›è¡Œæ£€æŸ¥ã€‚æ ¹æ®è¿™ä¸€ç‚¹ï¼ŒRuståœ¨**è¿è¡Œæ—¶**ç®¡ç†å†…å­˜ã€‚è¿™æ˜¯Rustç¼–è¯‘æ—¶é—´**è¾ƒæ…¢**çš„ä¸»è¦åŸå› ã€‚
- en: Unlike C and C++, **usually** Rust doesnâ€™t explicitly drop values at all.
  id: totrans-331
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸Cå’ŒC++**ä¸åŒ**ï¼ŒRusté€šå¸¸ä¸ä¼šæ˜¾å¼ä¸¢å¼ƒå€¼ã€‚
- en: Unlike GC, Rust doesnâ€™t place deallocation calls where the data is no longer
    referenced.
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸GCä¸åŒï¼ŒRustä¸ä¼šåœ¨æ•°æ®ä¸å†è¢«å¼•ç”¨çš„åœ°æ–¹æ”¾ç½®é‡Šæ”¾è°ƒç”¨ã€‚
- en: Rust places deallocation calls where the data is about to go out of the scope
    and then enforces that no references to that resource exist after that point.
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruståœ¨æ•°æ®å³å°†è¶…å‡ºèŒƒå›´çš„åœ°æ–¹æ”¾ç½®é‡Šæ”¾è°ƒç”¨ï¼Œç„¶åå¼ºåˆ¶ç¡®ä¿åœ¨é‚£ä¸€ç‚¹ä¹‹åä¸å­˜åœ¨å¯¹è¯¥èµ„æºçš„å¼•ç”¨ã€‚
- en: ğŸ’¡ Lifetimes are denoted with an apostrophe. By convention, a lowercase letter
    is used for naming. Usually **starts with** `'a` and **follows alphabetic order**
    when we need to add **multiple lifetime** annotations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ ç”Ÿå‘½å‘¨æœŸç”¨æ’‡å·è¡¨ç¤ºã€‚æŒ‰ç…§æƒ¯ä¾‹ï¼Œå°å†™å­—æ¯ç”¨äºå‘½åã€‚é€šå¸¸ä»¥**'a**å¼€å¤´ï¼Œå¹¶åœ¨éœ€è¦æ·»åŠ **å¤šä¸ªç”Ÿå‘½å‘¨æœŸ**æ³¨è§£æ—¶æŒ‰å­—æ¯é¡ºåº**è·Ÿéš**ã€‚
- en: When using references,
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä½¿ç”¨å¼•ç”¨æ—¶ï¼Œ
- en: ğŸğŸ. On **Function Declaration**
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸğŸ. åœ¨**å‡½æ•°å£°æ˜**ä¸­
- en: 'Input and output parameters with references should attach lifetimes after `&`
    sign. ex `..(x: &''a str)` , `..(x: &''a mut str)`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'å¸¦æœ‰å¼•ç”¨çš„è¾“å…¥å’Œè¾“å‡ºå‚æ•°åº”åœ¨`&`ç¬¦å·åé™„åŠ ç”Ÿå‘½å‘¨æœŸã€‚ä¾‹å¦‚ `..(x: &''a str)`ï¼Œ`..(x: &''a mut str)`'
- en: After the function name, we should mention that the given lifetimes are generic
    types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å‡½æ•°åä¹‹åï¼Œæˆ‘ä»¬åº”è¯¥æåˆ°ç»™å®šçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ³›å‹ç±»å‹ã€‚ä¾‹å¦‚ `fn foo<'a>(..)`ï¼Œ`fn foo<'a, 'b>(..)`
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ğŸğŸ. On **Struct or Enum Declaration**
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸğŸ. åœ¨**ç»“æ„ä½“æˆ–æšä¸¾å£°æ˜**ä¸­
- en: Elements with references should attach lifetimes after `&` sign.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…·æœ‰å¼•ç”¨çš„å…ƒç´ åº”åœ¨`&`ç¬¦å·åé™„åŠ ç”Ÿå‘½å‘¨æœŸã€‚
- en: After the name of the struct or enum, we should mention that the given lifetimes
    are generic types.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ç»“æ„ä½“æˆ–æšä¸¾çš„åç§°ä¹‹åï¼Œæˆ‘ä»¬åº”è¯¥æåˆ°ç»™å®šçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ³›å‹ç±»å‹ã€‚
- en: '[PRE51]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ğŸğŸ‘. With **Impls and Traits**
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸğŸ‘. ä½¿ç”¨**Implså’ŒTraits**
- en: '[PRE52]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ğŸğŸ’. With **Generic Types**
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸğŸ’. ä½¿ç”¨**æ³›å‹ç±»å‹**
- en: '[PRE53]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Lifetime Elision
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ç”Ÿå‘½å‘¨æœŸçœç•¥
- en: As I mentioned earlier, in order to make **common patterns** more ergonomic,
    Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime
    Elision**.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä¹‹å‰æåˆ°çš„ï¼Œä¸ºäº†ä½¿**å¸¸è§æ¨¡å¼**æ›´ç¬¦åˆäººä½“å·¥ç¨‹å­¦ï¼ŒRust å…è®¸çœç•¥ç”Ÿå‘½å‘¨æœŸã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä¸º**ç”Ÿå‘½å‘¨æœŸçœç•¥**ã€‚
- en: ğŸ’¡ For the moment Rust supports Lifetime Elisions only on `fn` definitions. But
    in the future it will support for `impl` headers as well.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ ç›®å‰ Rust ä»…åœ¨`fn`å®šä¹‰ä¸­æ”¯æŒç”Ÿå‘½å‘¨æœŸçœç•¥ã€‚ä½†åœ¨æœªæ¥ï¼Œå®ƒä¹Ÿå°†æ”¯æŒ`impl`å¤´éƒ¨çš„ç”Ÿå‘½å‘¨æœŸçœç•¥ã€‚
- en: â­ï¸ lifetime annotations of `fn` definitions can be elided
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ fn å®šä¹‰çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šå¯ä»¥è¢«çœç•¥
- en: if its **parameter list** has either,
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå…¶**å‚æ•°åˆ—è¡¨**ä¸­æœ‰è¦ä¹ˆï¼Œ
- en: '**only one input parameter passes by reference**.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åªæœ‰ä¸€ä¸ªè¾“å…¥å‚æ•°é€šè¿‡å¼•ç”¨ä¼ é€’**ã€‚'
- en: a parameter with **either** `&self` **or** **&mut self** reference.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…·æœ‰**è¦ä¹ˆ** `&self` **è¦ä¹ˆ** **&mut self** å¼•ç”¨çš„å‚æ•°ã€‚
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ğŸ’¡ In the Lifetime Elision process of fn definitions,
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ğŸ’¡ åœ¨ fn å®šä¹‰çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è¿‡ç¨‹ä¸­ï¼Œ
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each parameter passes by reference is got a distinct lifetime annotation. ex.
    `..(x: &str, y: &str)` ğŸ¡’ `..<''a, ''b>(x: &''a str, y: &''b str)`'
  id: totrans-358
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'æ¯ä¸ªé€šè¿‡å¼•ç”¨ä¼ é€’çš„å‚æ•°éƒ½æœ‰ä¸€ä¸ªä¸åŒçš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚ä¾‹å¦‚ `..(x: &str, y: &str)` ğŸ¡’ `..<''a, ''b>(x: &''a
    str, y: &''b str)`'
- en: 'If the parameter list has only one parameter passes by reference, that lifetime
    is assigned to all elided lifetimes in the return values of that function. ex.
    `..(x: i32, y: &str) -> &str` ğŸ¡’ `..<''a>(x: i32, y: &''a str) -> &''a str`'
  id: totrans-359
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'å¦‚æœå‚æ•°åˆ—è¡¨åªæœ‰ä¸€ä¸ªé€šè¿‡å¼•ç”¨ä¼ é€’çš„å‚æ•°ï¼Œåˆ™è¯¥ç”Ÿå‘½å‘¨æœŸå°†åˆ†é…ç»™è¯¥å‡½æ•°è¿”å›å€¼ä¸­æ‰€æœ‰çœç•¥çš„ç”Ÿå‘½å‘¨æœŸã€‚ä¾‹å¦‚ `..(x: i32, y: &str) -> &str`
    ğŸ¡’ `..<''a>(x: i32, y: &''a str) -> &''a str`'
- en: 'Even it has multiple parameters pass by reference, if one of them has &self
    or &mut self, the lifetime of self is assigned to all elided output lifetimes.
    ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` ğŸ¡’ `impl<''a> Impl<''a>{
    fn function(&''a self, x: &''b str) -> &''a str {} }`'
  id: totrans-360
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'å³ä½¿å®ƒæœ‰å¤šä¸ªé€šè¿‡å¼•ç”¨ä¼ é€’çš„å‚æ•°ï¼Œå¦‚æœå…¶ä¸­ä¸€ä¸ªæœ‰ &self æˆ– &mut selfï¼Œself çš„ç”Ÿå‘½å‘¨æœŸå°†åˆ†é…ç»™æ‰€æœ‰çœç•¥çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸã€‚ä¾‹å¦‚ `impl
    Impl{ fn function(&self, x: &str) -> &str {} }` ğŸ¡’ `impl<''a> Impl<''a>{ fn function(&''a
    self, x: &''b str) -> &''a str {} }`'
- en: For all other cases, we have to write lifetime annotations manually.
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºæ‰€æœ‰å…¶ä»–æƒ…å†µï¼Œæˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨ç¼–å†™ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚
- en: '''static'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '''static'
- en: â­ï¸ `'static` lifetime annotation is a **reserved** lifetime annotation. These
    references are valid for the entire program. They are saved in the data segment
    of the binary and the data referred to will never go out of scope.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: â­ï¸ `'static` ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šæ˜¯ä¸€ä¸ª**ä¿ç•™**çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚è¿™äº›å¼•ç”¨åœ¨æ•´ä¸ªç¨‹åºä¸­éƒ½æœ‰æ•ˆã€‚å®ƒä»¬ä¿å­˜åœ¨äºŒè¿›åˆ¶æ–‡ä»¶çš„æ•°æ®æ®µä¸­ï¼Œæ‰€å¼•ç”¨çš„æ•°æ®æ°¸è¿œä¸ä¼šè¶…å‡ºä½œç”¨åŸŸã€‚
- en: ğŸ’¡ **Letâ€™s see how to use lifetime annotations in examples.**
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ **è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•åœ¨ç¤ºä¾‹ä¸­ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚**
- en: '[PRE55]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
