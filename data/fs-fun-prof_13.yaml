- en: The "Object-oriented programming in F#" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “F#中的面向对象编程”系列
- en: As has been stressed many times before, F# is fundamentally a functional language
    at heart, yet the OO features have been nicely integrated and do not have a "tacked-on"
    feeling. As a result, it is quite viable to use F# just as an OO language, as
    an alternative to C#, say.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前多次强调的那样，F#在本质上是一种功能性语言，但面向对象的特性已经很好地集成在其中，没有“外挂”感觉。因此，将F#仅作为面向对象语言使用，例如作为C#的替代方案，是完全可行的。
- en: In this series, we'll look at how F# supports object-oriented classes and methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们将看看F#如何支持面向对象的类和方法。
- en: '[Object-oriented programming in F#: Introduction](object-oriented-intro.html).
    .'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F#中的面向对象编程：介绍](object-oriented-intro.html)。'
- en: '[Classes](classes.html). .'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类](classes.html)。'
- en: '[Inheritance and abstract classes](inheritance.html). .'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[继承和抽象类](inheritance.html)。'
- en: '[Interfaces](interfaces.html). .'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[接口](interfaces.html)。'
- en: '[Object expressions](object-expressions.html). .'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[对象表达式](object-expressions.html)。'
- en: 'Object-oriented programming in F#: Introduction'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F#中的面向对象编程：介绍
- en: 'Object-oriented programming in F#: Introduction'
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F#中的面向对象编程：介绍
- en: In this series, we'll look at how F# supports object-oriented classes and methods.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们将看看F#如何支持面向对象的类和方法。
- en: Should you use object-oriented features at all?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否应该使用面向对象特性？
- en: As has been stressed many times before, F# is fundamentally a functional language
    at heart, yet the OO features have been nicely integrated and do not have a "tacked-on"
    feeling. As a result, it is quite viable to use F# just as an OO language, as
    an alternative to C#, say.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前多次强调的那样，F#在本质上是一种功能性语言，但面向对象的特性已经很好地集成在其中，没有“外挂”感觉。因此，将F#仅作为面向对象语言使用，例如作为C#的替代方案，是完全可行的。
- en: Whether to use the OO style or the functional style is, of course, up to you.
    Here are some arguments for and against.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是使用面向对象风格还是函数式风格，当然取决于你。以下是一些赞成和反对的观点。
- en: 'Reasons in favor of using OO features:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向对象特性的原因：
- en: If you just want to do a direct port from C# without refactoring. (For more
    on this, there is a [entire series on how to port from C# to F#](porting-from-csharp.html).)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只想直接从C#进行移植而不进行重构。（更多关于此的信息，请参阅[如何从C#移植到F#的整个系列](porting-from-csharp.html)。）
- en: If you want to use F# primarily as an OO language, as an alternative to C#.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想将F#主要用作面向对象语言，作为C#的替代方案。
- en: If you need to integrate with other .NET languages
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要与其他.NET语言集成
- en: 'Reasons against using OO features:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用面向对象特性的原因：
- en: If you are a beginner coming from an imperative language, classes can be a crutch
    that hinder your understanding of functional programming.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是一个从命令式语言转变而来的初学者，类可能会成为阻碍你理解函数式编程的绊脚石。
- en: Classes do not have the convenient "out of the box" features that the "pure"
    F# data types have, such as built-in equality and comparison, pretty printing,
    etc.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类没有“开箱即用”的便利功能，如“纯”F#数据类型具有的内置相等性和比较、漂亮的打印等功能。
- en: Classes and methods do not play well with the type inference system and higher
    order functions (see [discussion here](type-extensions.html#downsides-of-methods)),
    so using them heavily means that you are making it harder to benefit from the
    most powerful parts of F#.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和方法与类型推断系统和高阶函数不太兼容（参见[这里的讨论](type-extensions.html#downsides-of-methods)），因此大量使用它们意味着你将难以从F#最强大的部分中受益。
- en: In most cases, the best approach is a hybrid one, primarily using pure F# types
    and functions to benefit from type inference, but occasionally using interfaces
    and classes when polymorphism is needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最佳方法是混合使用，主要使用纯粹的F#类型和函数以便从类型推断中受益，但在需要多态性时偶尔使用接口和类。
- en: Understanding the object-oriented features of F#
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解F#的面向对象特性
- en: If you do decide to use the object-oriented features of F#, the following series
    of posts should cover everything you need to know to be productive with classes
    and methods in F#.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用F#的面向对象特性，接下来的一系列文章应该涵盖你在使用F#中类和方法时需要了解的一切。
- en: First up, how to create classes!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如何创建类！
- en: Classes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Classes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: This post and the next will cover the basics of creating and using classes and
    methods in F#.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章和接下来的文章将介绍在F#中创建和使用类和方法的基础知识。
- en: Defining a class
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个类
- en: Just like all other data types in F#, class definitions start with the `type`
    keyword.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就像F#中的所有其他数据类型一样，类定义以`type`关键字开头。
- en: The thing that distinguishes them from other types is that classes always have
    some parameters passed in when they are created -- the constructor -- and so there
    are *always parentheses after the class name*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的区别在于，类在创建时总是有一些参数传递进去 -- 构造函数 -- 因此类名后面*总是有括号*。
- en: Also, unlike other types, classes *must* have functions attached to them as
    members. This post will explain how you do this for classes, but for a general
    discussion of attaching functions to other types see [the post on type extensions](type-extensions.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与其他类型不同，类*必须*附加函数作为成员。本文将解释如何为类执行此操作，但对于将函数附加到其他类型的一般讨论，请参阅[类型扩展的文章](type-extensions.html)。
- en: 'So, for example, if we want to have a class called `CustomerName` that requires
    three parameters to construct it, it would be written like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果我们想要一个名为`CustomerName`的类，该类需要三个参数来构造它，它将被写成这样：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s compare this with the C# equivalent:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与 C# 等效项进行比较：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that in the F# version, the primary constructor is embedded into
    the class declaration itself --- it is not a separate method. That is, the class
    declaration has the same parameters as the constructor, and the parameters automatically
    become immutable private fields that store the original values that were passed
    in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在 F# 版本中，主要构造函数嵌入到了类声明本身中 --- 它不是一个单独的方法。也就是说，类声明具有与构造函数相同的参数，并且参数自动成为不可变的私有字段，用于存储传入的原始值。
- en: 'So in the above example, because we declared the `CustomerName` class as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上面的示例中，由于我们将`CustomerName`类声明为：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: therefore `firstName`, `middleInitial`, and `lastName` automatically became
    immutable private fields.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此`firstName`，`middleInitial`和`lastName`自动成为了不可变的私有字段。
- en: Specifying types in the constructor
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在构造函数中指定类型
- en: You might not have noticed, but the `CustomerName` class defined above does
    not constrain the parameters to be strings, unlike the C# version. In general,
    type inference from usage will probably force the values to be strings, but if
    you do need to specify the types explicitly, you can do so in the usual way with
    a colon followed by the type name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到，但上面定义的`CustomerName`类不约束参数为字符串，与 C# 版本不同。通常，从使用中推断的类型推断可能会强制值为字符串，但如果你确实需要明确指定类型，可以像往常一样使用冒号后跟类型名称。
- en: 'Here''s a version of the class with explicit types in the constructor:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有构造函数中显式类型的类的版本：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One little quirk about F# is that if you ever need to pass a tuple as a parameter
    to a constructor, you will have to annotate it explicitly, because the call to
    the constructor will look identical:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 F# 的一个小特性是，如果你需要将元组作为参数传递给构造函数，你将不得不显式地注释它，因为对构造函数的调用看起来是相同的：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Class members
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类成员
- en: The example class above has three read-only instance properties. In F#, both
    properties and methods use the `member` keyword.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例类具有三个只读实例属性。在 F# 中，属性和方法都使用`member`关键字。
- en: Also, in the example above, you see the word "`this`" in front of each member
    name. This is a "self-identifier" that can be used to refer to the current instance
    of the class. Every non-static member must have a self-identifier, even it is
    not used (as in the properties above). There is no requirement to use a particular
    word, just as long as it is consistent. You could use "this" or "self" or "me"
    or any other word that commonly indicates a self reference.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在上面的示例中，你可以看到每个成员名称前面都有一个"`this`"。这是一个"自我标识符"，用于引用类的当前实例。每个非静态成员都必须有一个自我标识符，即使它没有被使用（如上面的属性）。没有使用特定的单词的要求，只要是一致的即可。你可以使用"this"、"self"、"me"或任何其他通常表示自我引用的单词。
- en: Understanding class signatures
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解类签名
- en: 'When a class is compiled (or when you over hover the definition in the editor),
    you see the "class signature" for the class. For example, for the class definition:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当类被编译（或当你在编辑器中悬停在定义上时），你会看到类的"类签名"。例如，对于类定义：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'the corresponding signature is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的签名是：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The class signature contains the signatures for all the constructors, methods
    and properties in the class. It is worth understanding what these signatures mean,
    because, just as with functions, you can understand what the class does by looking
    at them. It is also important because you will need to write these signatures
    when creating abstract methods and interfaces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类签名包含了类中所有构造函数、方法和属性的签名。了解这些签名的含义很重要，因为就像函数一样，你可以通过它们来理解类的功能。这也很重要，因为当创建抽象方法和接口时，你需要编写这些签名。
- en: Method signatures
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法签名
- en: Method signatures such as are very similar to the [signatures for standalone
    functions](how-types-work-with-functions.html), except that the parameter names
    are part of the signature itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 `how-types-work-with-functions.html` 的独立函数的签名一样，方法签名非常相似，只是参数名称是签名本身的一部分。
- en: 'So in this case, the method signature is:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，方法签名是：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And for comparison, the corresponding signature for a standalone function would
    be:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为比较，相应的独立函数的签名是：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Constructor signatures
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数签名
- en: Constructor signatures are always called `new`, but other than that, they look
    like a method signature.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数签名总是被称为 `new`，但除此之外，它们看起来像一个方法签名。
- en: Constructor signatures always take tuple values as their only parameter. In
    this case the tuple type is `int * string`, as you would expect. The return type
    is the class itself, again as you would expect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数签名总是以元组值作为它们唯一的参数。在这种情况下，元组类型是 `int * string`，正如你所期望的那样。返回类型是类本身，同样是你所期望的。
- en: 'Again, we can compare the constructor signature with a similar standalone function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以将构造函数签名与类似的独立函数进行比较：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Property signatures
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性签名
- en: 'Finally, property signatures such as `member Two : int` are very similar to
    the signatures for standalone simple values, except that no explicit value is
    given.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，诸如 `member Two : int` 的属性签名与独立简单值的签名非常相似，只是没有给出显式的值。'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Private fields and functions using "let" bindings
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 "let" 绑定的私有字段和函数
- en: After the class declaration, you can optionally have a set of "let" bindings,
    typically used for defining private fields and functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明之后，你可以选择性地有一组“let”绑定，通常用于定义私有字段和函数。
- en: 'Here''s some sample code to demonstrate this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些演示这一点的示例代码：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the example above, there are three let bindings:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，有三个 `let` 绑定：
- en: '`privateValue` is set to the initial seed plus 1'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`privateValue` 被设置为初始种子加 1'
- en: '`mutableValue` is set to 42'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutableValue` 被设置为 42'
- en: The `privateAddToSeed` function uses the initial seed plus a parameter
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`privateAddToSeed` 函数使用了初始种子加上一个参数'
- en: Because they are let bindings, they are automatically private, so to access
    them externally, there must be a public member to act as a wrapper.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们是 `let` 绑定，所以它们自动是私有的，因此要从外部访问它们，必须有一个公共成员作为包装器。
- en: Note that the `seed` value passed into the constructor is also available as
    a private field, just like the let-bound values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意构造函数中传递的 `seed` 值也可以作为私有字段使用，就像 `let` 绑定的值一样。
- en: Mutable constructor parameters
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变的构造函数参数
- en: 'Sometimes, you want a parameter passed to the constructor to be mutable. You
    cannot specify this in the parameter itself, so the standard technique is to create
    a mutable let-bound value and assign it from the parameter, as shown below:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你希望传递给构造函数的参数是可变的。你不能在参数本身指定这一点，所以标准技术是创建一个可变的 `let` 绑定值，并从参数中赋值，如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In cases, like this, it is quite common to give the mutable value the same
    name as the parameter itself, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，给可变值赋予与参数本身相同的名称是非常常见的，像这样：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Additional constructor behavior with "do" blocks
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用“do”块的附加构造函数行为
- en: In the `CustomerName` example earlier, the constructor just allowed some values
    to be passed in but didn't do anything else. However, in some cases, you might
    need to execute some code as part of the constructor. This is done using `do`
    blocks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`CustomerName`示例中，构造函数只允许一些值被传入，但不做其他任何事情。然而，在某些情况下，你可能需要执行一些代码作为构造函数的一部分。这是使用
    `do` 块来完成的。
- en: 'Here''s an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The "do" code can also call any let-bound functions defined before it, as shown
    in this example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: “do” 代码也可以调用在它之前定义的任何 `let` 绑定的函数，就像在这个例子中所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Accessing the instance via "this" in a do block
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 do 块中通过 "this" 访问实例
- en: One of the differences between the "do" and "let" bindings is that the "do"
    bindings can access the instance while "let" bindings cannot. This is because
    "let" bindings are actually evaluated before the constructor itself (similar to
    field initializers in C#), so the instance in a sense does not exist yet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: “do”绑定和“let”绑定之间的一个区别是，“do”绑定可以访问实例，而“let”绑定则不能。这是因为“let”绑定实际上在构造函数之前就已经被评估了（类似于C#中的字段初始化器），所以在某种意义上，实例还不存在。
- en: If you need to call members of the instance from a "do" block, you need some
    way to refer to the instance itself. This is again done using a "self-identifier",
    but this time it is attached to the class declaration itself.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要从“do”块中调用实例的成员，您需要一种方法来引用实例本身。这再次是使用“self标识符”完成的，但这次它附加到类声明本身。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In general though, it is not best practice to call members from constructors
    unless you have to (e.g. calling a virtual method). Better to call private let-bound
    functions, and if necessary, have the public members call those same private functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，最好不要从构造函数中调用成员，除非必须（例如调用虚方法）。最好调用私有let-bound函数，并且如果必要，让公共成员调用同样的私有函数。
- en: Methods
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: A method definition is very like a function definition, except that it has the
    `member` keyword and the self-identifier instead of just the `let` keyword.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义非常类似于函数定义，只是它有`member`关键字和self标识符，而不只是`let`关键字。
- en: 'Here are some examples:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see that, just like normal functions, methods can have parameters, call
    other methods, and be parameterless (or to be precise, take a [unit parameter](how-types-work-with-functions.html#parameterless-functions))
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，就像普通函数一样，方法可以具有参数，调用其他方法，并且可以没有参数（或者更准确地说，带有[unit参数](how-types-work-with-functions.html#parameterless-functions)）
- en: Tuple form vs. curried form
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组形式与柯里化形式
- en: 'Unlike normal functions, methods with more than one parameter can be defined
    in two different ways:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通函数不同，具有多个参数的方法可以通过两种不同的方式进行定义：
- en: The curried form, where parameters are separated with spaces, and partial application
    is supported. (Why "curried"? See the [explanation of currying](currying.html).)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化形式，其中参数用空格分隔，并支持部分应用。（为什么称为“柯里化”？请参阅[柯里化的解释](currying.html)。）
- en: The tuple form, where all the parameters as passed in at the same time, comma-separated,
    in a single tuple.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组形式，其中所有参数同时传入，用逗号分隔，放在单个元组中。
- en: 'The curried approach is more functional, and the tuple approach is more object-oriented.
    Here is an example class with a method for each approach:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化方法更加功能性，元组方法更加面向对象。下面是一个分别采用两种方法的示例类：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So which approach should you use?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你应该使用哪种方法呢？
- en: 'The advantages of tuple form are:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 元组形式的优点是：
- en: Compatible with other .NET code
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他.NET代码兼容
- en: Supports named parameters and optional parameters
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持命名参数和可选参数
- en: Supports method overloads (multiple methods with the same name that differ only
    in their function signature)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持方法重载（具有相同名称但函数签名不同的多个方法）
- en: 'On the other hand, the disadvantages of tuple form are:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，元组形式的缺点是：
- en: Doesn't support partial application
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持部分应用
- en: Doesn't work well with higher order functions
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与高阶函数不太适用
- en: Doesn't work well with type inference
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不太适用于类型推断
- en: For a more detailed discussion on tuple form vs. curried form see the post on
    [type extensions](type-extensions.html#tuple-form).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关元组形式与柯里化形式的更详细讨论，请参阅[type extensions](type-extensions.html#tuple-form)中的文章。
- en: Let- bound functions in conjunction with class methods
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与类方法结合使用的Let-bound函数
- en: A common pattern is to create let-bound functions that do all the heavy lifting,
    and then have the public methods call these internal functions directly. This
    has the benefit that the type inference works much better with functional-style
    code than with methods.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是创建执行所有繁重工作的let-bound函数，然后让公共方法直接调用这些内部函数。这样做的好处是，与方法相比，类型推断在函数式代码中效果更好。
- en: 'Here''s an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For more details on how to do this, see [this discussion](type-extensions.html#attaching-existing-functions).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何执行此操作的更多详细信息，请参阅[此讨论](type-extensions.html#attaching-existing-functions)。
- en: Recursive methods
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归方法
- en: 'Unlike normal let-bound functions, methods that are recursive do not need the
    special `rec` keyword. Here''s the boringly familiar Fibonacci function as a method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通let-bound函数不同，递归方法不需要特殊的`rec`关键字。下面是作为方法的沉闷的熟悉的斐波那契函数：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Type annotation for methods
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法的类型注解
- en: 'As usual, the types for a method''s parameters and return value can normally
    be inferred by the compiler, but if you need to specify them, you do so in the
    same way that you would for a standard function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，方法参数和返回值的类型通常可以由编译器推断出来，但如果您需要指定它们，您可以像为标准函数指定方式一样进行指定：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Properties
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Properties can be divided into three groups:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以分为三组：
- en: Immutable properties, where there is a "get" but no "set".
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变属性，其中有一个“获取”但没有“设置”。
- en: Mutable properties, where there is a "get" and also a (possibly private) "set".
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变属性，其中有一个“获取”和一个（可能是私有的）“设置”。
- en: Write-only properties, where there is a "set" but no "get". These are so unusual
    that I won't discuss them here, but the MSDN documentation describes the syntax
    if you ever need it.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只写属性，其中有一个“设置”但没有“获取”。这些很少见，我不会在这里讨论它们，但是如果您有需要，MSDN文档描述了它们的语法。
- en: The syntax for immutable and mutable properties is slightly different.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变和可变属性的语法略有不同。
- en: For immutable properties, the syntax is simple. There is a "get" member that
    is similar to a standard "let" value binding. The expression on the right-hand
    side of the binding can be any standard expression, typically a combination of
    the constructor parameters, private let-bound fields, and private functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不可变属性，语法很简单。有一个“获取”成员，类似于标准的“let”值绑定。绑定右侧的表达式可以是任何标准表达式，通常是构造函数参数、私有let绑定字段和私有函数的组合。
- en: 'Here''s an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For mutable properties however, the syntax is more complicated. You need to
    provide two functions, one to get and one to set. This is done by using the syntax:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于可变属性，语法更加复杂。您需要提供两个函数，一个用于获取，一个用于设置。这是通过以下语法实现的：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here''s an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To make the set function private, use the keywords `private set` instead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使设置函数私有化，请改用关键字`private set`。
- en: Automatic properties
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动属性
- en: Starting in VS2012, F# supports automatic properties, which remove the requirement
    to create a separate backing store for them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从VS2012开始，F#支持自动属性，这消除了为它们创建单独的备份存储的要求。
- en: 'To create an immutable auto property, use the syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个不可变的自动属性，请使用以下语法：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To create a mutable auto property, use the syntax:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可变的自动属性，请使用以下语法：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that in this syntax there is a new keyword `val` and the self-identifier
    has gone.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个语法中有一个新关键字`val`，并且自身标识符已经消失。
- en: Complete property example
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的属性示例
- en: 'Here''s a complete example that demonstrates all the property types:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示所有属性类型的完整示例：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Properties vs. parameterless methods
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性与无参数方法
- en: At this point you might be confused by the difference between properties and
    parameterless methods. They look identical at first glance, but there is a subtle
    difference -- "parameterless" methods are not really parameterless; they always
    have a unit parameter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会对属性和无参数方法之间的区别感到困惑。乍一看，它们看起来相同，但是有一个微妙的区别--“无参数”方法实际上并不是无参数的；它们总是具有一个单位参数。
- en: 'Here''s an example of the difference in both definition and usage:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个在定义和使用上的区别的示例：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can also tell the difference by looking at the signature of the class definition
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过查看类定义的签名来区分它们
- en: 'The class definition looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类的定义如下所示：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The method has signature `MyFunc : unit -> int` and the property has signature
    `MyProp : int`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '该方法的签名为`MyFunc : unit -> int`，属性的签名为`MyProp : int`。'
- en: 'This is very similar to what the signatures would be if the function and property
    were declared standalone, outside of any class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这与如果函数和属性是独立声明的，在任何类外部的情况下，签名会非常相似：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The signatures for these would look like:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些的签名将如下所示：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: which is almost exactly the same.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎完全相同。
- en: If you are unclear on the difference and why the unit parameter is needed for
    the function, please read the [discussion of parameterless methods](how-types-work-with-functions.html#parameterless-functions).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不清楚两者之间的区别以及为什么函数需要单位参数，请阅读[无参数方法的讨论](how-types-work-with-functions.html#parameterless-functions)。
- en: Secondary constructors
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 次要构造函数
- en: In addition to the primary constructor embedded in its declaration, a class
    can have additional constructors. These are indicated by the `new` keyword and
    must call the primary constructor as their last expression.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了嵌入其声明中的主构造函数外，类还可以具有其他构造函数。这些由`new`关键字指示，并且必须将主构造函数作为它们的最后一个表达式调用。
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Static members
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员
- en: Just as in C#, classes can have static members, and this is indicated with the
    `static` keyword. The `static` modifier comes before the member keyword.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 C# 中一样，类可以具有静态成员，这是用`static`关键字表示的。`static`修饰符在成员关键字之前。
- en: Members which are static cannot have a self-identifier such as "this" because
    there is no instance for them to refer to.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员不能具有自我标识符（例如“this”），因为它们没有实例可以引用。
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Static constructors
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态构造函数
- en: There is no direct equivalent of a static constructor in F#, but you can create
    static let-bound values and static do-blocks that are executed when the class
    is first used.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中没有静态构造函数的直接等价物，但您可以创建静态 let 绑定值和静态 do 块，在类首次使用时执行。
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Accessibility of members
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员的可访问性
- en: You can control the accessibility of a member with the standard .NET keywords
    `public`, `private` and `internal`. The accessibility modifiers come after the
    `member` keyword and before the member name.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准 .NET 关键字`public`、`private`和`internal`来控制成员的可访问性。可访问性修饰符在成员关键字之后，在成员名称之前。
- en: Unlike C#, all class members are public by default, not private. This includes
    both properties and methods. However, non-members (e.g. let declarations) are
    private and cannot be made public.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 不同，所有类成员默认为公共，而不是私有。这包括属性和方法。但是，非成员（例如`let`声明）是私有的，不能被公开。
- en: 'Here''s an example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For properties, if the set and get have different accessibilities, you can tag
    each part with a separate accessibility modifier.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性，如果设置和获取具有不同的可访问性，您可以使用单独的可访问性修饰符标记每个部分。
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In practice, the "public get, private set" combination that is so common in
    C# is not generally needed in F#, because immutable properties can be defined
    more elegantly, as described earlier.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，C# 中常见的“公共获取，私有设置”组合在 F# 中通常不需要，因为可以更优雅地定义不可变属性，如前所述。
- en: 'Tip: defining classes for use by other .NET code'
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示：为其他 .NET 代码定义类
- en: If you are defining classes that need to interop with other .NET code, do not
    define them inside a module! Define them in a namespace instead, outside of any
    module.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要定义需要与其他 .NET 代码进行互操作的类，请不要将它们定义在模块内！请将它们定义在命名空间中，而不是在任何模块之外。
- en: The reason for this is that F# modules are exposed as static classes, and any
    F# classes defined inside a module are then defined as nested classes within the
    static class, which can mess up your interop. For example, some unit test runners
    don't like static classes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是，F# 模块被公开为静态类，模块内定义的任何 F# 类都被定义为静态类内的嵌套类，这可能会影响您的互操作性。例如，一些单元测试运行器不喜欢静态类。
- en: F# classes which are defined outside a module are generated as normal top-level
    .NET classes, which is probably what you want. But remember that (as discussed
    in a [previous post](organizing-functions.html)) if you don't declare a namespace
    specifically, your class will be placed in an automatically generated module,
    and will be nested without your knowledge.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块外定义的 F# 类将生成为普通的顶级 .NET 类，这可能是您想要的。但请记住（如在[先前的帖子](organizing-functions.html)中讨论的），如果您没有明确声明命名空间，您的类将被放置在自动生成的模块中，并且将在您不知情的情况下进行嵌套。
- en: 'Here''s an example of two F# classes, one defined outside a module and one
    defined inside:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个 F# 类的示例，一个在模块外定义，一个在模块内定义：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here''s how the same code might look in C#:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相同代码在 C# 中的样子：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Constructing and using a class
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造和使用类
- en: Now that we have defined the class, how do we go about using it?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了类，如何使用它呢？
- en: One way to create an instance of a class is straightfoward and just like C#
    -- use the `new` keyword and pass in the arguments to the constructor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类的一种方式是直接并且与 C# 类似 -- 使用`new`关键字并传递参数给构造函数。
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'However, in F#, the constructor is considered to be just another function,
    so you can normally eliminate the `new` and call the constructor function on its
    own, like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 F# 中，构造函数被视为另一个函数，因此通常可以消除`new`，并单独调用构造函数函数，就像这样：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the case when you are creating a class that implements `IDisposible`, you
    will get a compiler warning if you do not use `new`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实现`IDisposible`的类时，如果不使用`new`，编译器会发出警告。
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This can be a useful reminder to use the `use` keyword instead of the `let`
    keyword for disposables. See [the post on `use`](let-use-do.html#use) for more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可处置的内容，使用`use`关键字而不是`let`关键字可能是有用的。有关更多信息，请参阅[关于`use`的帖子](let-use-do.html#use)。
- en: Calling methods and properties
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用方法和属性
- en: And once you have an instance, you can "dot into" the instance and use any methods
    and properties in the standard way.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个实例，你可以"点进"该实例，并以标准方式使用任何方法和属性。
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have seen many examples of member usage in the above discussion, and there's
    not too much to say about it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的讨论中，我们已经看到了许多成员使用的示例，关于这点没有太多要说的。
- en: 'Remember that, as discussed above, tuple-style methods and curried-style methods
    can be called in distinct ways:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如上所述，元组式方法和柯里化式方法可以以不同的方式调用：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Inheritance and abstract classes
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和抽象类
- en: Inheritance and abstract classes
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和抽象类
- en: This is a follow-on from the [previous post on classes](classes.html). This
    post will focus on inheritance in F#, and how to define and use abstract classes
    and interfaces.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对[前一篇关于类的文章](classes.html)的延续。本文将重点讨论F#中的继承，以及如何定义和使用抽象类和接口。
- en: Inheritance
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'To declare that a class inherits from another class, use the syntax:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个类继承自另一个类，使用以下语法：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `inherit` keyword signals that `DerivedClass` inherits from `BaseClass`.
    In addition, some `BaseClass` constructor must be called at the same time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`inherit`关键字表示`DerivedClass`继承自`BaseClass`。此外，必须同时调用某个`BaseClass`的构造函数。'
- en: It might be useful to compare F# with C# at this point. Here is some C# code
    for a very simple pair of classes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此时比较F#和C#可能会有用。这里是一个非常简单的一对类的C#代码。
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that the inheritance declaration `class MyDerivedClass: MyBaseClass` is
    distinct from the constructor which calls `base(param1)`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，继承声明`class MyDerivedClass: MyBaseClass`与调用`base(param1)`的构造函数是不同的。'
- en: 'Now here is the F# version:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是F#版本：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Unlike C#, the inheritance part of the declaration, `inherit BaseClass(param1)`,
    contains both the class to inherit from *and* its constructor.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#不同，声明中的继承部分，`inherit BaseClass(param1)`，包含了要继承的类*和*它的构造函数。
- en: Abstract and virtual methods
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象和虚拟方法
- en: Obviously, part of the point of inheritance is to be able to have abstract methods,
    virtual methods, and so on.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，继承的一部分是能够拥有抽象方法、虚拟方法等。
- en: Defining abstract methods in the base class
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在基类中定义抽象方法
- en: In C#, an abstract method is indicated by the `abstract` keyword plus the method
    signature. In F#, it is the same concept, except that the way that function signatures
    are written in F# is quite different from C#.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，抽象方法由`abstract`关键字加上方法签名来表示。在F#中，这是相同的概念，只是F#中函数签名的书写方式与C#有很大不同。
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'So to define an abstract method, we use the signature syntax, along with the
    `abstract member` keywords:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要定义一个抽象方法，我们使用签名语法，加上`abstract member`关键字：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice that the equals sign has been replaced with a colon. This is what you
    would expect, as the equals sign is used for binding values, while the colon is
    used for type annotation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意等号已被冒号替换。这是你所期望的，因为等号用于绑定值，而冒号用于类型注解。
- en: 'Now, if you try to compile the code above, you will get an error! The compiler
    will complain that there is no implementation for the method. To fix this, you
    need to:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试编译上面的代码，你会得到一个错误！编译器会抱怨该方法没有实现。要解决这个问题，你需要：
- en: provide a default implementation of the method, or
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供方法的默认实现，或者
- en: tell the compiler that the class as whole is also abstract.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉编译器整个类也是抽象的。
- en: We'll look at both of these alternatives shortly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会看到这两种替代方案。
- en: Defining abstract properties
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义抽象属性
- en: An abstract immutable property is defined in a similar way. The signature is
    just like that of a simple value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的不可变属性的定义方式类似。签名就像简单值的签名一样。
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the abstract property is read/write, you add the get/set keywords.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抽象属性是可读/可写的，你需要添加`get/set`关键字。
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Default implementations (but no virtual methods)
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认实现（但没有虚拟方法）
- en: 'To provide a default implementation of an abstract method in the base class,
    use the `default` keyword instead of the `member` keyword:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基类中为抽象方法提供默认实现，使用`default`关键字而不是`member`关键字：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can see that the default method is defined in the usual way, except for
    the use of `default` instead of `member`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到默认方法的定义方式与通常方式相同，只是使用`default`而不是`member`。
- en: One major difference between F# and C# is that in C# you can combine the abstract
    definition and the default implementation into a single method, using the `virtual`
    keyword. In F#, you cannot. You must declare the abstract method and the default
    implementation separately. The `abstract member` has the signature, and the `default`
    has the implementation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: F# 与 C# 之间的一个主要区别是，在 C# 中，你可以使用`virtual`关键字将抽象定义和默认实现合并为一个单独的方法。在 F# 中，你不能这样做。你必须分别声明抽象方法和默认实现。`abstract
    member`有签名，`default`有实现。
- en: Abstract classes
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象类
- en: If at least one abstract method does *not* have a default implementation, then
    the entire class is abstract, and you must indicate this by annotating it with
    the `AbstractClass` attribute.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果至少有一个抽象方法*没有*默认实现，则整个类都是抽象的，并且你必须通过为其添加`AbstractClass`属性来指示这一点。
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If this is done, then the compiler will no longer complain about a missing implementation.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，那么编译器将不再抱怨缺少实现。
- en: Overriding methods in subclasses
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在子类中重写方法
- en: To override an abstract method or property in a subclass, use the `override`
    keyword instead of the `member` keyword. Other than that change, the overridden
    method is defined in the usual way.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要在子类中重写抽象方法或属性，使用`override`关键字而不是`member`关键字。除了这个变化，重写的方法是按照通常的方式定义的。
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: And to call a base method, use the `base` keyword, just as in C#.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用基方法，请使用`base`关键字，就像在 C# 中一样。
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Summary of abstract methods
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象方法摘要
- en: 'Abstract methods are basically straightforward and similar to C#. There are
    only two areas that might be tricky if you are used to C#:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法基本上很简单，与 C# 类似。如果你习惯于 C#，可能有两个地方会有些棘手：
- en: You must understand how function signatures work and what their syntax is! For
    a detailed discussion see the [post on function signatures](function-signatures.html).
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须理解函数签名如何工作以及它们的语法是什么！详细讨论请参阅[函数签名帖子](function-signatures.html)。
- en: There is no all-in-one virtual method. You must define the abstract method and
    the default implementation separately.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有全能虚方法。你必须分别定义抽象方法和默认实现。
- en: Interfaces
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are available and fully supported in F#, but there are number of
    important ways in which their usage differs from what you might be used to in
    C#.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在 F# 中是可用且完全支持的，但在使用方式上有许多重要的区别，与你在 C# 中可能习惯的方式不同。
- en: Defining interfaces
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义接口
- en: Defining an interface is similar to defining an abstract class. So similar,
    in fact, that you might easily get them confused.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 定义接口与定义抽象类类似。事实上，它们非常相似，以至于你可能很容易混淆它们。
- en: 'Here''s an interface definition:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接口定义：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And here''s the definition for the equivalent abstract base class:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是等效抽象基类的定义：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So what's the difference? As usual, all abstract members are defined by signatures
    only. The only difference seems to be the lack of the `[<AbstractClass>]` attribute.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 那么区别在哪里呢？像往常一样，所有抽象成员仅由签名定义。唯一的区别似乎是缺少`[<AbstractClass>]`属性。
- en: But in the earlier discussion on abstract methods, we stressed that the `[<AbstractClass>]`
    attribute was required; the compiler would complain that the methods have no implementation
    otherwise. So how does the interface definition get away with it?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但在之前关于抽象方法的讨论中，我们强调了需要`[<AbstractClass>]`属性；否则编译器会抱怨方法没有实现。那么接口定义如何摆脱这一点呢？
- en: 'The answer is trivial, but subtle. *The interface has no constructor*. That
    is, it does not have any parentheses after the interface name:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很琐碎，但微妙。*接口没有构造函数*。也就是说，它在接口名后没有括号：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That's it. Removing the parens will convert a class definition into an interface!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。删除括号将类定义转换为接口！
- en: Explicit and implicit interface implementations
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式和隐式接口实现
- en: When it comes time to implement an interface in a class, F# is quite different
    from C#. In C#, you can add a list of interfaces to the class definition and implement
    the interfaces implicitly.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类中实现接口时，F# 与 C# 相比有很大不同。在 C# 中，你可以将接口列表添加到类定义中，并隐式实现接口。
- en: Not so in F#. In F#, all interfaces must be *explicitly* implemented.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中并非如此。在 F# 中，所有接口必须*显式*实现。
- en: In an explicit interface implementation, the interface members can only be accessed
    through an interface instance (e.g. by casting the class to the interface type).
    The interface members are not visible as part of the class itself.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在显式接口实现中，接口成员只能通过接口实例（例如通过将类转换为接口类型）访问。接口成员不作为类本身的一部分可见。
- en: C# has support for both explicit and implicit interface implementations, but
    almost always, the implicit approach is used, and many programmers are not even
    aware of [explicit interfaces in C#](http://msdn.microsoft.com/en-us/library/ms173157.aspx).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持显式和隐式接口实现，但几乎总是使用隐式方法，并且许多程序员甚至不知道[C#中的显式接口](http://msdn.microsoft.com/en-us/library/ms173157.aspx)。
- en: Implementing interfaces in F#
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在F#中实现接口
- en: 'So, how do you implement an interface in F#? You cannot just "inherit" from
    it, as you would an abstract base class. You have to provide an explicit implementation
    for each interface member using the syntax `interface XXX with`, as shown below:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在F#中实现接口？你不能像继承抽象基类那样“继承”它。你必须为每个接口成员提供显式实现，使用语法`interface XXX with`，如下所示：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The above code shows how the class `MyAddingService` explicitly implements the
    `IAddingService` and the `IDisposable` interfaces. After the required `interface
    XXX with` section, the members are implemented in the normal way.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了类`MyAddingService`如何显式实现`IAddingService`和`IDisposable`接口。在必需的`interface
    XXX with`部分之后，成员以正常方式实现。
- en: (As an aside, note again that `MyAddingService()` has a constructor, while `IAddingService`
    does not.)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: （另外注意，`MyAddingService()`有一个构造函数，而`IAddingService`没有。）
- en: Using interfaces
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用接口
- en: 'So now let''s try to use the adding service interface:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用添加服务接口：
- en: '[PRE59]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Immediately, we run into an error. It appears that the instance does not implement
    the `Add` method at all. Of course, what this really means is that we must cast
    it to the interface first using the `:>` operator:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，我们遇到了一个错误。似乎实例根本没有实现`Add`方法。当然，这实际上意味着我们必须首先使用`：>`运算符将其转换为接口：
- en: '[PRE60]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This might seem incredibly awkward, but in practice it is not a problem as in
    most cases the casting is done implicitly for you.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来非常笨拙，但实际上并不是问题，因为在大多数情况下，转换会隐式完成。
- en: 'For example, you will typically be passing an instance to a function that specifies
    an interface parameter. In this case, the casting is done automatically:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你通常会将一个实例传递给指定接口参数的函数。在这种情况下，转换是自动完成的：
- en: '[PRE61]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And in the special case of `IDisposable`, the `use` keyword will also automatically
    cast the instance as needed:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 而在`IDisposable`的特殊情况下，`use`关键字也会根据需要自动转换实例：
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Object expressions
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象表达式
- en: Object expressions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象表达式
- en: So as we saw in the [previous post](interfaces.html), implementing interfaces
    in F# is a bit more awkward than in C#. But F# has a trick up its sleeve, called
    "object expressions".
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们在[上一篇文章](interfaces.html)中所看到的那样，在F#中实现接口比在C#中更加笨拙。但是F#有一个名为"对象表达式"的技巧。
- en: With object expressions, you can implement an interface on-the-fly, without
    having to create a class.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象表达式，你可以即时地实现一个接口，而不必创建一个类。
- en: Implementing interfaces with object expressions
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象表达式实现接口
- en: Object expressions are most commonly used to implement interfaces. To do this,
    you use the syntax `new MyInterface with ...`, and the wrap the whole thing in
    curly braces (one of the few uses for them in F#!)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对象表达式最常用于实现接口。为此，你可以使用语法`new MyInterface with ...`，并将整个内容放在花括号中（这是F#中的少数用途之一！）
- en: Here is some example code that creates a number of objects, each of which implements
    `IDisposable`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些示例代码，创建了多个对象，每个对象都实现了`IDisposable`。
- en: '[PRE63]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you execute this code, you will see the output below. You can see that `Dispose()`
    is indeed being called when the objects go out of scope.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此代码，你将看到下面的输出。你可以看到当对象超出范围时确实调用了`Dispose()`。
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We can take the same approach with the `IAddingService` and create one on the
    fly as well.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以采用与`IAddingService`相同的方法，并且也可以即时创建一个。
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Object expressions are extremely convenient, and can greatly reduce the number
    of classes you need to create if you are interacting with an interface heavy library.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对象表达式非常方便，如果你要与一个接口密集的库进行交互，可以大大减少你需要创建的类的数量。
