- en: '| [![](../Images/7f8c088dd0cbaa378937d5eea09c7de2.jpg)](/http://philip.greenspun.com/images/pcd0088/no-zoo-rhino-double-101.tcl)
    |'
  id: totrans-0
  prefs: []
  type: TYPE_TB
  zh: '| [![](../Images/7f8c088dd0cbaa378937d5eea09c7de2.jpg)](/http://philip.greenspun.com/images/pcd0088/no-zoo-rhino-double-101.tcl)
    |'
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: by [Philip Greenspun](http://philip.greenspun.com/), part of [SQL for Web Nerds](index.html)
    |
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [Philip Greenspun](http://philip.greenspun.com/) 撰写，[面向Web极客的SQL](index.html)
    的一部分 |
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: After writing a preface lampooning academic eggheads who waste a lot of ink
    placing the relational database management system (RDBMS) in the context of 50
    years of database management software, how does this book start? With a chapter
    placing the RDBMS in the context of other database management software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '在写了一个嘲讽学术脑壳浪费大量墨水将关系数据库管理系统（RDBMS）放在50年数据库管理软件的背景下的序言后，这本书是如何开始的？通过将RDBMS置于其他数据库管理软件背景下的章节来开始。 '
- en: Why? You ought to know why you're paying the huge performance, financial, and
    administration cost of an RDBMS. This chapter doesn't dwell on mainframe systems
    that people stopped using in the 1970s, but it does cover the alternative approaches
    to data management taken by Web sites that you've certainly visited and perhaps
    built.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？你应该知道为什么要支付庞大的性能、财务和管理成本来使用RDBMS。本章不讨论人们在上世纪70年代停止使用的大型机系统，但它确实涵盖了你肯定曾访问过甚至可能创建过的网站采取的数据管理的替代方法。
- en: The architect of any new information system must decide how much responsibility
    for data management the new custom software should take and how much should be
    left to packaged software and the operating system. This chapter explains what
    kind of packaged data management software is available, covering files, flat file
    database management systems, the RDBMS, object-relational database management
    systems, and object databases. This chapter also introduces the SQL language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何新信息系统的架构师必须决定新定制软件应该承担多少数据管理责任，以及多少应该留给打包软件和操作系统。本章介绍了可用的打包数据管理软件的种类，涵盖了文件、平面文件数据库管理系统、RDBMS、对象关系数据库管理系统和对象数据库。本章还介绍了SQL语言。
- en: What's wrong with a file system (and also what's right)
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统的问题（以及优点）
- en: '[![Arizona](../Images/47618fd6e9a16b03449b271513338be0.jpg)](/http://philip.greenspun.com/images/pcd4231/old-tractor-4.4.jpg)
    The file system that comes with your computer is a very primitive kind of database
    management system. Whether your computer came with the Unix file system, NTFS,
    or the Macintosh file system, the basic idea is the same. Data are kept in big
    unstructured named clumps called *files*. The great thing about the file system
    is its invisibility. You probably didn''t purchase it separately, you might not
    be aware of its existence, you won''t have to run an ad in the newspaper for a
    *file system administrator* with 5+ years of experience, and it will pretty much
    work as advertised. All you need to do with a file system is back it up to tape
    every day or two.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[![亚利桑那](../Images/47618fd6e9a16b03449b271513338be0.jpg)](/http://philip.greenspun.com/images/pcd4231/old-tractor-4.4.jpg)
    随着你的计算机附带的文件系统是一种非常原始的数据库管理系统。无论你的计算机是带有Unix文件系统、NTFS还是Macintosh文件系统，其基本思想都是相同的。数据保存在称为*文件*的大型非结构化命名块中。文件系统的伟大之处在于其隐形性。你可能没有单独购买它，可能没有意识到它的存在，你不需要在报纸上刊登一则寻找*文件系统管理员*的广告，也基本上会按照广告运作。你只需要每天或每两天将文件系统备份到磁带上。'
- en: Despite its unobtrusiveness, the file system on a Macintosh, Unix, or Windows
    machine is capable of storing any data that may be represented in digital form.
    For example, suppose that you are storing a mailing list in a file system file.
    If you accept the limitation that no e-mail address or person's name can contain
    a newline character, you can store one entry per line. Then you could decide that
    no e-mail address or name may contain a vertical bar. That lets you separate e-mail
    address and name fields with the vertical bar character.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不显眼，但Macintosh、Unix或Windows机器上的文件系统能够存储以数字形式表示的任何数据。例如，假设你将邮件列表存储在文件系统文件中。如果你接受以下限制：电子邮件地址或人名不能包含换行符，你可以每行存储一个条目。然后你可以决定电子邮件地址或名字中不能包含竖线。这样你就可以用竖线字符分隔电子邮件地址和名字字段。
- en: So far, everything is great. As long as you are careful never to try storing
    a newline or vertical bar, you can keep your data in this "flat file." Searching
    can be slow and expensive, though. What if you want to see if "philg@mit.edu"
    is on the mailing list? You computer must read through the entire file to check.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。只要你小心永远不要尝试存储换行符或竖线，你就可以将数据保存在这个“平面文件”中。不过，搜索可能会很慢，也很昂贵。如果你想知道“philg@mit.edu”是否在邮件列表中，你的计算机必须读取整个文件进行检查。
- en: 'Let''s say that you write a program to process "insert new person" requests.
    It works by appending a line to the flat file with the new information. Suppose,
    however, that several users are simultaneously using your Web site. Two of them
    ask to be added to the mailing list at exactly the same time. Depending on how
    you wrote your program, the particular kind of file system that you have, and
    luck, you could get any of the following behaviors:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你写了一个程序来处理“插入新人”请求。它的工作原理是将包含新信息的一行追加到平面文件中。然而，假设有几个用户同时使用您的网站。其中两个在完全相同的时间要求加入邮件列表。根据您编写程序的方式、您拥有的文件系统的特定类型和运气，您可能会得到以下任何一种行为：
- en: Both inserts succeed.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个插入都成功了。
- en: One of the inserts is lost.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个插入丢失。
- en: Information from the two inserts is mixed together so that both are corrupted.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自两个插入的信息被混合在一起，以至于两者都被破坏了。
- en: In the last case, the programs you've written to use the data in the flat file
    may no longer work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，您编写的用于使用平面文件中数据的程序可能不再起作用。
- en: So what? Emacs may be ancient but it is still the best text editor in the world.
    You love using it so you might as well spend your weekends and evenings manually
    fixing up your flat file databases with Emacs. Who needs concurrency control?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那又怎样？Emacs可能是古老的，但它仍然是世界上最好的文本编辑器。你喜欢使用它，所以你也可以花周末和晚上用Emacs手动修复你的平面文件数据库。谁需要并发控制？
- en: It all depends on what kind of stove you have.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都取决于你有什么样的炉子。
- en: Yes, that's right, your stove. Suppose that you buy a $268,500 condo in Harvard
    Square. You think to yourself, "Now my friends will really be impressed with me"
    and invite them over for brunch. Not because you like them, but just to make them
    envious of your large lifestyle. Imagine your horror when all they can say is
    "What's this old range doing here? Don't you have a Viking stove?" [![Old fishing
    hamlet of Helgumannen.  Faro, Gotland. Sweden](../Images/45d231d33a7008361f779b00656344db.jpg)](/http://philip.greenspun.com/images/pcd0834/helgumannen-60.tcl)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就是你的炉子。假设你在哈佛广场购买了一套价值268,500美元的公寓。你自言自语道：“现在我的朋友们肯定会对我印象深刻”，然后邀请他们来参加早午餐。不是因为你喜欢他们，而只是为了让他们对你的豪华生活感到嫉妒。想象一下，当他们唯一能说的话是“这个旧的炉子怎么回事？你难道没有维京炉吗？”时，你会有多么恐慌。[![Helgumannen的旧渔村。法罗，哥特兰岛。瑞典](../Images/45d231d33a7008361f779b00656344db.jpg)](/http://philip.greenspun.com/images/pcd0834/helgumannen-60.tcl)
- en: A *Viking stove*?!? They cost $5000\. The only way you are going to come up
    with this kind of cash is to join the growing ranks of on-line entrepreneurs.
    So you open an Internet bank. An experienced Perl script/flat-file wizard by now,
    you confidently build a system in which all the checking account balances are
    stored in one file, `checking.text`, and all the savings balances are stored in
    another file, `savings.text`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 维京炉？！？它们要花费5000美元。你能想到这种现金的唯一办法是加入日益增长的在线企业家行列。所以你开了一家互联网银行。作为一名经验丰富的Perl脚本/平面文件专家，你自信地构建了一个系统，其中所有支票账户余额都存储在一个文件`checking.text`中，而所有储蓄账户余额都存储在另一个文件`
    savings.text`中。
- en: A few days later, an unlucky combination of events occurs. Joe User is transferring
    $10,000 from his savings to his checking account. Judy User is simultaneously
    depositing $5 into her savings account. One of your Perl scripts successfully
    writes the checking account flat file with Joe's new, $10,000 higher, balance.
    It also writes the savings account file with Joe's new, $10,000 lower, savings
    balance. However, the script that is processing Judy's deposit started at about
    the same time and began with the version of the savings file that had Joe's original
    balance. It eventually finishes and writes Judy's $5 higher balance but also overwrites
    Joe's new lower balance with the old high balance. Where does that leave you?
    $10,000 poorer, cooking on an old GE range, and wishing you had Concurrency Control.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 几天后，发生了一系列不幸的事件。Joe 用户正在将 $10,000 从储蓄账户转到支票账户。Judy 用户同时向她的储蓄账户存入 $5。你的一个 Perl
    脚本成功地将支票账户的平面文件写入了 Joe 的新余额，高出 $10,000。它还将储蓄账户文件写入了 Joe 的新余额，低了 $10,000。然而，处理
    Judy 存款的脚本大约在同一时间开始，并以 Joe 原始余额的版本开始。最终完成并写入 Judy 的高 $5 余额，但也用旧的高余额覆盖了 Joe 的新低余额。这让你处于什么境地？比原来少了
    $10,000，用着旧的 GE 炉灶做饭，希望你有并发控制。
- en: After a few months of programming and reading operating systems theory books
    from the 1960s that deal with mutual exclusion, you've solved your concurrency
    problems. Congratulations. However, like any good Internet entrepreneur, you're
    running this business out of your house and you're getting a little sleepy. So
    you heat up some coffee in the microwave and simultaneously toast a bagel in the
    toaster oven. The circuit breaker trips. This is the time when you are going to
    regret having bought that set of Calphalon pots to go with your Viking stove rather
    than investing in an uninterruptible power supply for your server. You hear the
    sickening sound of disks spinning down. You scramble to get your server back up
    and don't really have time to look at the logs and notice that Joe User was back
    transferring $25,000 from savings to checking. What happened to Joe's transaction?
    [![Santa Karin. Visby, Gotland.  Sweden](../Images/718ca4c8449e1408e2e4c0efebe0d9f1.jpg)](/http://philip.greenspun.com/images/pcd1213/santa-karin-22.tcl)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月的编程和阅读上世纪60年代处理互斥的操作系统理论书籍后，你解决了并发问题。恭喜。然而，像任何优秀的互联网企业家一样，你在家里经营这家企业，感到有点困倦。于是你在微波炉里加热一些咖啡，同时在烤箱里烤一个贝果。保险丝跳闸了。这时你会后悔买了一套
    Calphalon 锅来搭配你的 Viking 炉灶，而不是为服务器投资一个不间断电源。你听到磁盘停止旋转的令人不安的声音。你急忙让服务器恢复运行，没有时间查看日志，注意到
    Joe 用户正在将 $25,000 从储蓄账户转到支票账户。Joe 的交易发生了什么？[![圣卡琳。维斯比，哥特兰岛。瑞典](../Images/718ca4c8449e1408e2e4c0efebe0d9f1.jpg)](/http://philip.greenspun.com/images/pcd1213/santa-karin-22.tcl)
- en: The good news for Joe is that your Perl script had just finished crediting his
    checking account with $25,000\. The bad news for you is that it hadn't really
    gotten started on debiting his savings account. You're so busy preparing the public
    offering for your on-line business that you fail to notice the loss. But your
    underwriters eventually do and your plans to sell the bank to the public go down
    the toilet.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Joe 的好消息是，你的 Perl 脚本刚刚完成了向他的支票账户存入 $25,000。你的坏消息是，它实际上还没有开始从他的储蓄账户扣款。你正忙着为你的在线业务准备公开发行，没有注意到这笔损失。但你的承销商最终注意到了，你计划将银行出售给公众的计划泡汤了。
- en: Where does that leave you? Cooking on an old GE range and wishing you'd left
    the implementation of transactions to professionals.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你处于什么境地？用着旧的 GE 炉灶做饭，希望你把事务的实现留给专业人士。
- en: What Do You Need for Transaction Processing?
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事务处理需要什么？
- en: 'Data processing folks like to talk about the "ACID test" when deciding whether
    or not a database management system is adequate for handling transactions. An
    adequate system has the following properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理人员喜欢在决定数据库管理系统是否足以处理事务时谈论“ACID测试”。一个足够的系统具有以下特性：
- en: Atomicity
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性
- en: Results of a transaction's execution are either all committed or all rolled
    back. All changes take effect, or none do. That means, for Joe User's money transfer,
    that both his savings and checking balances are adjusted or neither are. For a
    Web content management example, suppose that a user is editing a comment. A Web
    script tells the database to "copy the old comment value to an audit table and
    update the live table with the new text". If the hard drive fills up after the
    copy but before the update, the audit table insertion will be rolled back.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事务执行的结果要么全部提交，要么全部回滚。所有更改生效，或者都不生效。这意味着，对于Joe用户的转账，他的储蓄和支票余额都会调整，或者都不会。对于Web内容管理的例子，假设用户正在编辑评论。Web脚本告诉数据库“将旧评论值复制到审核表中，并使用新文本更新实时表”。如果硬盘在复制后但更新前已满，审核表插入将被回滚。
- en: Consistency
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性
- en: '[![Welcome to Universal City  (shopping mall built in the style of a city street;
    Los Angeles California).](../Images/4bbb5bf68881b2ac68941ea09d272017.jpg)](/http://philip.greenspun.com/images/pcd1359/universal-city-rules-42.tcl)
    The database is transformed from one valid state to another valid state. This
    defines a transaction as legal only if it obeys user-defined integrity constraints.
    Illegal transactions aren''t allowed and, if an integrity constraint can''t be
    satisfied then the transaction is rolled back. For example, suppose that you define
    a rule that postings in a discussion forum table must be tied to a valid user
    ID. Then you hire Joe Novice to write some admin pages. Joe writes a delete-user
    page that doesn''t bother to check whether or not the deletion will result in
    an orphaned discussion forum posting. The DBMS will check, though, and abort any
    transaction that would result in you having a discussion forum posting by a deleted
    user.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![环球城欢迎您（以城市街道风格建造的购物中心；加利福尼亚洛杉矶）。](../Images/4bbb5bf68881b2ac68941ea09d272017.jpg)](/http://philip.greenspun.com/images/pcd1359/universal-city-rules-42.tcl)
    数据库从一个有效状态转换为另一个有效状态。这将一个事务定义为仅在遵守用户定义的完整性约束时才合法。不允许非法事务，如果无法满足完整性约束，则事务将被回滚。例如，假设您定义了一个规则，讨论论坛表中的帖子必须与有效的用户ID相关联。然后您雇佣了Joe
    Novice来编写一些管理页面。Joe编写了一个删除用户页面，没有检查删除是否会导致孤立的讨论论坛帖子。尽管Joe没有检查，但数据库管理系统会检查，并中止任何导致您拥有被删除用户的讨论论坛帖子的事务。'
- en: Isolation
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离
- en: The results of a transaction are invisible to other transactions until the transaction
    is complete. For example, if you are running an accounting report at the same
    time that Joe is transferring money, the accounting report program will either
    see the balances before Joe transferred the money or after, but never the intermediate
    state where checking has been credited but savings not yet debited.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的结果对其他事务是不可见的，直到事务完成。例如，如果您正在运行会计报告的同时Joe正在转账，会计报告程序将在Joe转账前或后看到余额，但永远不会看到中间状态，即支票已入账但储蓄尚未借记。
- en: Durability
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性
- en: Once committed (completed), the results of a transaction are permanent and survive
    future system and media failures. If the airline reservation system computer gives
    you seat 22A and crashes a millisecond later, it won't have forgotten that you
    are sitting in 22A and also give it to someone else. Furthermore, if a programmer
    spills coffee into a disk drive, it will be possible to install a new disk and
    recover the transactions up to the coffee spill, showing that you had seat 22A.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交（完成），事务的结果是永久的，并且可以在未来的系统和媒体故障中幸存。如果航空公司预订系统的计算机给您22A座位，然后在一毫秒后崩溃，它不会忘记您坐在22A座位上并将其分配给其他人。此外，如果程序员将咖啡洒入磁盘驱动器，将可以安装新磁盘并恢复直到洒咖啡的事务，显示您坐在22A座位上。
- en: That doesn't sound too tough to implement, does it? And, after all, one of the
    most refreshing things about the Web is how it encourages people without formal
    computer science backgrounds to program. So why not build your Internet bank on
    a transaction system implemented by an English major who has just discovered Perl?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不难实现，是吗？毕竟，网络最令人耳目一新的事情之一就是它鼓励没有正式计算机科学背景的人来编程。那么，为什么不在刚刚发现Perl的英语专业人员实现的事务系统上构建您的互联网银行呢？
- en: Because you still need indexing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您仍然需要索引。
- en: Finding Your Data (and Fast)
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找您的数据（并且快速）
- en: '[![Stockholm airport, hopskotch](../Images/aca465f7a22442d7e4c1ed53193e38de.jpg)](/http://philip.greenspun.com/images/pcd0510/stockholm-airport-hopskotch-102.tcl)
    One facet of a database management system is processing inserts, updates, and
    deletes. This all has to do with putting information into the database. Sometimes
    it is also nice, though, to be able to get data out. And with popular sites getting
    100 hits per second, it pays to be conscious of speed.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![斯德哥尔摩机场，跳房子](../Images/aca465f7a22442d7e4c1ed53193e38de.jpg)](/http://philip.greenspun.com/images/pcd0510/stockholm-airport-hopskotch-102.tcl)
    数据库管理系统的一个方面是处理插入、更新和删除。这都涉及将信息放入数据库中。有时候，能够获取数据也是很好的。而且随着流行网站每秒获得 100 次点击，要注意速度是很值得的。'
- en: Flat files work okay if they are very small. A Perl script can read the whole
    file into memory in a split second and then look through it to pull out the information
    requested. But suppose that your on-line bank grows to have 250,000 accounts.
    A user types his account number into a Web page and asks for his most recent deposits.
    You've got a chronological financial transactions file with 25 million entries.
    Crunch, crunch, crunch. Your server laboriously works through all 25 million to
    find the ones with an account number that matches the user's. While it is crunching,
    25 other users come to the Web site and ask for the same information about their
    accounts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 平面文件在非常小的情况下运行良好。一个 Perl 脚本可以在一瞬间将整个文件读入内存，然后查找其中请求的信息。但是假设你的在线银行发展到有 250,000
    个账户。用户在网页上输入他的账号，要求查看最近的存款。你有一个包含 2500 万条记录的时间顺序财务交易文件。咔咔咔。你的服务器费力地查找所有 2500 万条记录，找到与用户账号匹配的记录。在它忙碌的时候，另外
    25 个用户来到网站，要求查看他们账户的相同信息。
- en: 'You have two choices: (1) buy a 64-processor Sun E10000 server with 64 GB of
    RAM, or (2) build an index file. If you build an index file that maps account
    numbers to sequential transaction numbers, your server won''t have to search all
    25 million records anymore. However, you have to modify all of your programs that
    insert, update, or delete from the database to also keep the index current.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个选择：（1）购买一台具有 64 个处理器和 64 GB RAM 的 Sun E10000 服务器，或者（2）构建一个索引文件。如果你构建一个将账号映射到顺序交易号的索引文件，你的服务器就不再需要搜索所有
    2500 万条记录。然而，你必须修改所有插入、更新或删除数据库的程序，以保持索引的实时性。
- en: This works great until two years later when a brand new MBA arrives from Harvard.
    She asks your English major cum Perl hacker for "a report of all customers who
    have more than $5,000 in checking or live in Oklahoma and have withdrawn more
    than $100 from savings in the last 17 days." It turns out that you didn't anticipate
    this query so your indexing scheme doesn't speed things up. Your server has to
    grind through all the data over and over again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切运行得很顺利，直到两年后，一位来自哈佛的全新 MBA 毕业生到来。她向你的英语专业兼 Perl 黑客要求“列出所有在支票账户中有超过 $5,000
    或居住在俄克拉荷马州并在过去 17 天中从储蓄账户中提取超过 $100 的客户的报告。”结果发现你没有预料到这个查询，所以你的索引方案无法加快速度。你的服务器不得不一遍又一遍地处理所有数据。
- en: Enter the Relational Database
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进入关系数据库
- en: 'You are building a cutting-edge Web service. You need the latest and greatest
    in computer technology. That''s why you use, uh, Unix. Yeah. Anyway, even if your
    operating system was developed in 1969, you definitely can''t live without the
    most modern database management system available. Maybe this guy E.F. Codd can
    help:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在构建一项尖端的网络服务。你需要最新和最先进的计算机技术。这就是为什么你使用，呃，Unix。是的。无论如何，即使你的操作系统是在 1969 年开发的，你绝对不能没有最现代的数据库管理系统。也许这个叫
    E.F. Codd 的家伙可以帮忙：
- en: '"Future users of large data banks must be protected from having to know how
    the data is organized in the machine (the internal representation). ... Activities
    of users at terminals and most application programs should remain unaffected when
    the internal representation of data is changed and even when some aspects of the
    external representation are changed. Changes in data representation will often
    be needed as a result of changes in query, update, and report traffic and natural
    growth in the types of stored information.'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"未来大型数据库的用户必须免于必须了解数据在机器中是如何组织的（内部表示）。...终端用户和大多数应用程序的活动在数据的内部表示发生变化时应保持不受影响，甚至在外部表示的某些方面发生变化时也应如此。随着查询、更新和报告流量的变化以及存储信息类型的自然增长，数据表示的变化通常是必要的。'
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"Existing noninferential, formatted data systems provide users with tree-structured
    files or slightly more general network models of the data. In Section 1, inadequacies
    of these models are discussed. A model based on *n*-ary relations, a normal form
    for data base relations, and the concept of a universal data sublanguage are introduced.
    In Section 2, certain operations on relations (other than logical inference) are
    discussed and applied to the problems of redundancy and consistency in the user''s
    model."'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"现有的非推理格式化数据系统为用户提供了树形文件或略微更一般的数据网络模型。在第1节中，讨论了这些模型的不足之处。引入了基于*n*元关系的模型，数据库关系的范式以及通用数据子语言的概念。在第2节中，讨论了关系上的某些操作（除了逻辑推理）并应用于用户模型中冗余和一致性的问题。"'
- en: Sounds pretty spiffy, doesn't it? Just like what you need. That's the abstract
    to "A Relational Model of Data for Large Shared Data Banks", a paper Codd wrote
    while working at IBM's San Jose research lab. It was published in the *Communications
    of the ACM* in June, 1970.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来相当不错，对吧？就像你需要的一样。这是科德在IBM圣何塞研究实验室工作时撰写的论文《大型共享数据库的关系模型》，发表于1970年6月的*ACM通讯*中的摘要。
- en: '[![Volvo.  Visby, Gotland, near Fiskarporten.](../Images/77d6b0b907fe6615aefea2599d77657b.jpg)](/http://philip.greenspun.com/images/pcd1143/visby-volvo-64.tcl)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![沃尔沃。Visby，Gotland，靠近Fiskarporten。](../Images/77d6b0b907fe6615aefea2599d77657b.jpg)](/http://philip.greenspun.com/images/pcd1143/visby-volvo-64.tcl)'
- en: Yes, that's right, 1970\. What you need to do is move your Web site into the
    '70s with one of these newfangled relational database management systems (RDBMS).
    Actually, as Codd notes in his paper, most of the problems we've encountered so
    far in this chapter were solved in the 1960s by off-the-shelf mainframe software
    sold by IBM and the "seven dwarves" (as IBM's competitors were known). By the
    early 1960s, businesses had gotten tired of losing important transactions and
    manually uncorrupting databases. They began to think that their applications programmers
    shouldn't be implementing transactions and indexing on an ad hoc basis for each
    new project. Companies began to buy database management software from computer
    vendors like IBM. These products worked fairly well but resulted in brittle data
    models. If you got your data representation correct the first time and your business
    needs never changed then a 1967-style hierarchical database was great. Unfortunately,
    if you put a system in place and subsequently needed new indices or a new data
    format then you might have to rewrite all of your application programs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，没错，1970年。你需要做的是将你的网站带入70年代，使用这些新潮的关系数据库管理系统（RDBMS）。实际上，正如科德在他的论文中所指出的，我们在本章中遇到的大部分问题在20世纪60年代就已经被IBM和"七个小矮人"（IBM的竞争对手所称）出售的现成大型机软件解决了。到了20世纪60年代早期，企业已经厌倦了丢失重要交易和手动修复数据库的情况。他们开始认为他们的应用程序员不应该为每个新项目按照特定情况实现事务和索引。公司开始从IBM等计算机供应商那里购买数据库管理软件。这些产品运行得相当不错，但导致了脆弱的数据模型。如果你第一次就正确地获取了数据表示并且你的业务需求从未改变，那么1967年风格的分层数据库就很好。不幸的是，如果你实施了一个系统，随后需要新的索引或新的数据格式，那么你可能需要重写所有的应用程序。
- en: From an application programmer's point of view, the biggest innovation in the
    relational database is that one uses a *declarative* query language, SQL (an acronym
    for Structured Query Language and pronounced "ess-cue-el" or "sequel"). Most computer
    languages are *procedural*. The programmer tells the computer what to do, step
    by step, specifying a procedure. In SQL, the programmer says "I want data that
    meet the following criteria" and the RDBMS query planner figures out how to get
    it. There are two advantages to using a declarative language. The first is that
    the queries no longer depend on the data representation. The RDBMS is free to
    store data however it wants. The second is increased software reliability. It
    is much harder to have "a little bug" in an SQL query than in a procedural program.
    Generally it either describes the data that you want and works all the time or
    it completely fails in an obvious way.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序员的角度来看，关系数据库中最大的创新是使用*声明性*查询语言SQL（结构化查询语言的缩写，发音为"ess-cue-el"或"sequel"）。大多数计算机语言都是*过程式*的。程序员逐步告诉计算机要做什么，指定一个过程。在SQL中，程序员说"我想要符合以下条件的数据"，而关系数据库管理系统的查询规划器会找出如何获取这些数据。使用声明性语言有两个优点。第一个是查询不再依赖于数据表示。关系数据库管理系统可以自由地存储数据。第二个是增加软件的可靠性。在SQL查询中很难出现"一个小错误"，而在过程式程序中很容易。通常它要么描述你想要的数据并且始终有效，要么以明显的方式完全失败。
- en: Another benefit of declarative languages is that less sophisticated users are
    able to write useful programs. For example, many computing tasks that required
    professional programmers in the 1960s can be accomplished by non-technical people
    with spreadsheets. In a spreadsheet, you don't tell the computer how to work out
    the numbers or in what sequence. You just *declare* "This cell will be 1.5 times
    the value of that other cell over there."
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性语言的另一个好处是，不太精通的用户也能编写有用的程序。例如，许多在20世纪60年代需要专业程序员的计算任务，现在可以由非技术人员通过电子表格完成。在电子表格中，你不需要告诉计算机如何计算数字或以什么顺序进行。你只需*声明*“这个单元格将是那边那个单元格值的1.5倍”。
- en: RDBMSes can run very very slowly. Depending on whether you are selling or buying
    computers, this may upset or delight you. Suppose that the system takes 30 seconds
    to return the data you asked for in your query. Does that mean you have a lot
    of data? That you need to add some indices? That the RDBMS query planner made
    some bad choices and needs some hints? Who knows? The RDBMS is an enormously complicated
    program that you didn't write and for which you don't have the source code. Each
    vendor has tracing and debugging tools that purport to help you, but the process
    is not simple. Good luck figuring out a different SQL incantation that will return
    the same set of data in less time. If you can't, call 1-800-USESUNX and ask them
    to send you a 16-processor Sun Enterprise 10000 with 32 GB of RAM.. Alternatively,
    you can keep running the non-relational software you used in the 1960s, which
    is what the airlines do for their reservations systems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS 可以运行非常慢。根据你是在卖还是在买计算机，这可能会让你感到不安或高兴。假设系统需要30秒才能返回你查询的数据。这意味着你有很多数据吗？你需要添加一些索引吗？RDBMS
    查询规划器做出了一些错误选择，需要一些提示吗？谁知道呢？RDBMS 是一个你没有编写过且没有源代码的极其复杂的程序。每个供应商都有追踪和调试工具声称可以帮助你，但这个过程并不简单。祝你好运，试着找出一个不同的
    SQL 咒语，可以在更短的时间内返回相同的数据集。如果你做不到，打电话给 1-800-USESUNX，让他们给你寄送一台带有32 GB RAM 的 16 处理器
    Sun Enterprise 10000。或者，你可以继续运行你在20世纪60年代使用的非关系软件，这就是航空公司为他们的预订系统所做的。
- en: How Does This RDBMS Thing Work?
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这个 RDBMS 东西是如何工作的？
- en: '[![Botaniska Tradgarden.  Visby, Gotland.](../Images/4b309c677177ed9ab31a673bee6638eb.jpg)](/http://philip.greenspun.com/images/pcd1143/visby-flowers-82.tcl)
    Database researchers love to talk about relational algebra, n-tuples, normal form,
    and natural composition, while throwing around mathematical symbols. This patina
    of mathematical obscurity tends to distract your attention from their bad suits
    and boring personalities, but is of no value if you just want to use a relational
    database management system.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![植物园。维斯比，哥特兰岛。](../Images/4b309c677177ed9ab31a673bee6638eb.jpg)](/http://philip.greenspun.com/images/pcd1143/visby-flowers-82.tcl)
    数据库研究人员喜欢谈论关系代数，n-元组，正规形式和自然组合，同时使用数学符号。这种数学上的模糊光环往往会让你的注意力从他们糟糕的西装和无聊的个性中分散开来，但如果你只想使用关系数据库管理系统，这是没有价值的。'
- en: 'In fact, this is all you need to know to be a Caveman Database Programmer:
    A relational database is a big spreadsheet that several people can update simultaneously.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是你成为穴居人数据库程序员所需要知道的全部：关系数据库是一个大的电子表格，几个人可以同时更新。
- en: 'Each *table* in the database is one spreadsheet. You tell the RDBMS how many
    columns each row has. For example, in our mailing list database, the table has
    two columns: `name` and `email`. Each entry in the database consists of one row
    in this table. An RDBMS is more restrictive than a spreadsheet in that all the
    data in one column must be of the same type, e.g., integer, decimal, character
    string, or date. Another difference between a spreadsheet and an RDBMS is that
    the rows in an RDBMS are not ordered. You can have a column named `row_number`
    and ask the RDBMS to return the rows ordered according to the data in this column,
    but the row numbering is not implicit as it would be with Visicalc or its derivatives
    such as Lotus 1-2-3 and Excel. If you do define a `row_number` column or some
    other unique identifier for rows in a table, it becomes possible for a row in
    another table to refer to that row by including the value of the unique ID.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的每个*表*都是一个电子表格。您告诉 RDBMS 每行有多少列。例如，在我们的邮件列表数据库中，表有两列：`name`和`email`。数据库中的每个条目都由此表中的一行组成。RDBMS
    比电子表格更受限制，因为一列中的所有数据必须是相同类型的，例如，整数、小数、字符串或日期。电子表格和 RDBMS 之间的另一个区别是，RDBMS 中的行不是有序的。您可以有一个名为`row_number`的列，并要求
    RDBMS 根据该列中的数据返回已排序的行，但是行编号不是像 Visicalc 或其衍生产品 Lotus 1-2-3 和 Excel 中那样隐式的。如果您定义了一个`row_number`列或某个其他表中行的唯一标识符，那么另一个表中的行可以通过包含唯一
    ID 的值来引用该行。
- en: 'Here''s what some SQL looks like for the mailing list application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是邮件列表应用程序的一些 SQL 代码示例：
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The table will be called `mailing_list` and will have two columns, both variable
    length character strings. We've added a couple of integrity constraints on the
    `email` column. The `not null` will prevent any program from inserting a row where
    `name` is specified but `email` is not. After all, the whole point of the system
    is to send people e-mail so there isn't much value in having a name with no e-mail
    address. The `primary key` tells the database that this column's value can be
    used to uniquely identify a row. That means the system will reject an attempt
    to insert a row with the same e-mail address as an existing row. This sounds like
    a nice feature, but it can have some unexpected performance implications. For
    example, every time anyone tries to insert a row into this table, the RDBMS will
    have to look at all the other rows in the table to make sure that there isn't
    already one with the same e-mail address. For a really huge table, that could
    take minutes, but if you had also asked the RDBMS to create an index for `mailing_list`
    on `email` then the check becomes almost instantaneous. However, the integrity
    constraint still slows you down because every update to the `mailing_list` table
    will also require an update to the index and therefore you'll be doing twice as
    many writes to the hard disk.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表将被称为`mailing_list`，并将具有两列，都是可变长度的字符串。我们在`email`列上添加了一些完整性约束。`not null`将阻止任何程序插入其中`name`已指定但`email`未指定的行。毕竟，系统的整个目的是发送电子邮件给人们，所以拥有没有电子邮件地址的姓名没有太多价值。`primary
    key`告诉数据库该列的值可以用于唯一标识一行。这意味着系统将拒绝尝试插入具有与现有行相同电子邮件地址的行的尝试。这听起来像是一个很好的功能，但它可能会产生一些意想不到的性能影响。例如，每当有人尝试向该表中插入一行时，RDBMS都必须查看表中的所有其他行，以确保没有已经存在具有相同电子邮件地址的行。对于一个非常庞大的表来说，这可能需要几分钟，但如果您还要求RDBMS在`email`上为`mailing_list`创建一个索引，那么检查几乎会立即完成。但是，完整性约束仍然会减慢您的速度，因为对`mailing_list`表的每次更新也将需要更新索引，因此您将对硬盘进行两倍的写入。
- en: That is the joy and the agony of SQL. Inserting two innocuous looking words
    can cost you a factor of 1000 in performance. Then inserting a sentence (to create
    the index) can bring you back so that it is only a factor of two or three. (Note
    that many RDBMS implementations, including Oracle, automatically define an index
    on a column that is constrained to be unique.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 SQL 的乐趣和痛苦。插入两个看似无害的单词可能会使性能降低 1000 倍。然后插入一句话（创建索引）可能会让你回到只有两到三倍的程度。（请注意，包括
    Oracle 在内的许多 RDBMS 实现会自动在受约束的列上定义索引。）
- en: 'Anyway, now that we''ve executed the Data Definition Language "create table"
    statement, we can move on to *Data Manipulation Language*: an INSERT.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，现在我们已经执行了数据定义语言的"create table"语句，我们可以继续进行数据操纵语言：INSERT。
- en: '[PRE1]'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we specify into which columns we are inserting. That way, if someone
    comes along later and does
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们指定了要插入哪些列。这样，如果以后有人来了
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '(the Oracle syntax for adding a column), our INSERT will still work. Note also
    that the string quoting character in SQL is a single quote. Hey, it was the ''70s.
    If you visit the newsgroup `comp.databases` right now, I''ll bet that you can
    find someone asking "How do I insert a string containing a single quote into an
    RDBMS?" Here''s one harvested from AltaVista:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: （添加列的 Oracle 语法），我们的插入仍然有效。还要注意，在 SQL 中，字符串引用字符是单引号。嘿，那是70年代。如果你现在访问新闻组`comp.databases`，我敢打赌你会找到有人在问"如何在关系数据库管理系统中插入包含单引号的字符串？"这是从
    AltaVista 收集的一个例子：
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ll take Pete Nelson''s advice and double the single quote in "O''Grady":'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采纳皮特·尼尔森的建议，并将"O'Grady"中的单引号加倍：
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Having created a table and inserted some data, at last we are ready to experience
    the awesome power of the SQL SELECT. Want your data back?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个表并插入了一些数据后，我们终于准备好体验 SQL SELECT 的强大威力了。想要你的数据回来吗？
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you typed this query into a standard shell-style RDBMS client program, for
    example Oracle''s SQL*PLUS, you''d get ... a horrible mess. That''s because you
    told Oracle that the columns could be as wide as 100 characters (`varchar(100)`).
    Very seldom will you need to store e-mail addresses or names that are anywhere
    near as long as 100 characters. However, the solution to the "ugly report" problem
    is not to cut down on the maximum allowed length in the database. You don''t want
    your system failing for people who happen to have exceptionally long names or
    e-mail addresses. The solution is either to use a more sophisticated tool for
    querying your database or to give SQL*Plus some hints for preparing a report:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个查询输入到标准的 shell 风格的关系数据库管理系统客户端程序中，例如 Oracle 的 SQL*PLUS，你会得到... 一团糟。这是因为你告诉
    Oracle 列的宽度可以达到 100 个字符（`varchar(100)`）。很少会有需要存储长达 100 个字符的电子邮件地址或姓名。然而，解决"丑陋报告"问题的方法不是减少数据库中允许的最大长度。你不希望系统因为某些人的名字或电子邮件地址特别长而失败。解决方案要么是使用更复杂的工具来查询数据库，要么是为
    SQL*Plus 提供一些准备报告的提示：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that there are no values in the `phone_number` column because we haven't
    set any. As soon as we do start to add phone numbers, we realize that our data
    model was inadequate. This is the Internet and Joe Typical User will have his
    pants hanging around his knees under the weight of a cell phone, beeper, and other
    personal communication accessories. One phone number column is clearly inadequate
    and even `work_phone` and `home_phone` columns won't accommodate the wealth of
    information users might want to give us. The clean database-y way to do this is
    to remove our `phone_number` column from the `mailing_list` table and define a
    helper table just for the phone numbers. Removing or renaming a column turns out
    to be impossible in Oracle 8 (see the "Data Modeling" chapter for some ALTER TABLE
    commands that become possible starting with Oracle 8i), so we
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`phone_number`列中没有任何值，因为我们还没有设置任何值。一旦我们开始添加电话号码，我们意识到我们的数据模型是不够的。这是互联网，典型用户乔会因为手机、寻呼机和其他个人通讯配件的重量而让裤子垂到膝盖。一个电话号码列显然是不够的，即使`work_phone`和`home_phone`列也无法容纳用户可能想要提供给我们的丰富信息。处理这个问题的干净数据库方式是从`mailing_list`表中移除我们的`phone_number`列，并为电话号码定义一个辅助表。在
    Oracle 8 中，删除或重命名列是不可能的（请参阅"数据建模"章节，了解一些从 Oracle 8i 开始变得可能的 ALTER TABLE 命令），所以我们
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that in this table the email column is *not* a primary key. That''s because
    we want to allow multiple rows with the same e-mail address. If you are hanging
    around with a database nerd friend, you can say that there is a *relationship*
    between the rows in the `phone_numbers` table and the `mailing_list` table. In
    fact, you can say that it is a *many-to-one relation* because many rows in the
    `phone_numbers` table may correspond to only one row in the `mailing_list` table.
    If you spend enough time thinking about and talking about your database in these
    terms, two things will happen:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个表中，电子邮件列*不是*主键。这是因为我们希望允许具有相同电子邮件地址的多行。如果你和一个数据库迷友一起，你可以说`phone_numbers`表中的行与`mailing_list`表中的行之间存在*关系*。实际上，你可以说这是*多对一关系*，因为`phone_numbers`表中的许多行可能对应`mailing_list`表中的一行。如果你花足够的时间思考和讨论你的数据库，两件事会发生：
- en: You'll get an A in an RDBMS course at any state university.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在任何州立大学的关系数据库管理系统课程中获得A。
- en: You'll pick up readers of Psychology Today who think you are sensitive and caring
    because you are always talking about relationships. [see "Using the Internet to
    Pick up Babes and/or Hunks" at [http://philip.greenspun.com/wtr/getting-dates.html](http://philip.greenspun.com/wtr/getting-dates.html)
    before following any of my dating advice]
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会吸引《今日心理学》的读者，因为你总是谈论关系，他们会认为你很敏感、关心。[在查看任何约会建议之前，请参阅[http://philip.greenspun.com/wtr/getting-dates.html](http://philip.greenspun.com/wtr/getting-dates.html)中的"使用互联网约会"文章]
- en: Another item worth noting about our two-table data model is that we do not store
    the user's name in the `phone_numbers` table. That would be redundant with the
    `mailing_list` table and potentially self-redundant as well, if, for example,
    "robert.loser@fastbuck.com" says he is "Robert Loser" when he types in his work
    phone and then "Rob Loser" when he puts in his beeper number, and "Bob Lsr" when
    he puts in his cell phone number while typing on his laptop's cramped keyboard.
    A database nerd would say that that this data model is consequently in "Third
    Normal Form". Everything in each row in each table depends only on the primary
    key and nothing is dependent on only part of the key. The primary key for the
    `phone_numbers` table is the combination of `email` and `number_type`. If you
    had the user's name in this table, it would depend only on the email portion of
    the key.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的两表数据模型还值得注意的一点是，我们不在`phone_numbers`表中存储用户的姓名。这将与`mailing_list`表中的内容重复，并且在某种程度上也是自相矛盾的，比如，"robert.loser@fastbuck.com"在输入工作电话时称自己为"Robert
    Loser"，然后在输入寻呼机号码时称自己为"Rob Loser"，最后在用笔记本电脑狭窄的键盘上输入手机号码时称自己为"Bob Lsr"。一个数据库迷会说，这个数据模型因此处于"第三范式"。每个表中每行的一切都仅依赖于主键，没有任何内容仅依赖于主键的一部分。`phone_numbers`表的主键是`email`和`number_type`的组合。如果在这个表中有用户的姓名，它将仅依赖于主键的电子邮件部分。
- en: 'Anyway, enough database nerdism. Let''s populate the `phone_numbers` table:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，数据库方面的废话就到此为止。让我们填充`phone_numbers`表：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Ooops! When we dropped the `mailing_list` table, we lost all the rows. The
    `phone_numbers` table has a referential integrity constraint ("references mailing_list")
    to make sure that we don''t record e-mail addresses for people whose names we
    don''t know. We have to first insert the two users into `mailing_list`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！当我们删除`mailing_list`表时，所有行都丢失了。`phone_numbers`表有一个参照完整性约束（"references mailing_list"），以确保我们不为我们不知道姓名的人记录电子邮件��址。我们必须首先将这两个用户插入`mailing_list`：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the last four INSERTs use an evil SQL shortcut and don't specify the
    columns into which we are inserting data. The system defaults to using all the
    columns in the order that they were defined. Except for prototyping and playing
    around, we don't recommend ever using this shortcut.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后四个INSERT使用了一个邪恶的SQL快捷方式，并没有指定要插入数据的列。系统默认使用按定义顺序的所有列。除了用于原型设计和玩耍，我们不建议使用这种快捷方式。
- en: The first three INSERTs work fine, but what about the last one, where Mr. O'Grady
    misspelled "beeper"?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个INSERT正常工作，但最后一个怎么办，O'Grady先生拼错了"beeper"？
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We asked Oracle at table definition time to `check (number_type in ('work','home','cell','beeper'))`
    and it did. The database cannot be left in an inconsistent state.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在表定义时要求Oracle`check (number_type in ('work','home','cell','beeper'))`，它也做到了。数据库不能处于不一致的状态。
- en: Let's say we want all of our data out. Email, full name, phone numbers. The
    most obvious query to try is a *join*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要所有的数据。电子邮件、全名、电话号码。最明显的查询尝试是*连接*。
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Yow! What happened? There are only two rows in the `mailing_list` table and
    three in the `phone_numbers` table. Yet here we have six rows back. This is how
    joins work. They give you the *Cartesian product* of the two tables. Each row
    of one table is paired with all the rows of the other table in turn. So if you
    join an N-row table with an M-row table, you get back a result with N*M rows.
    In real databases, N and M can be up in the millions so it is worth being a little
    more specific as to which rows you want:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！发生了什么？`mailing_list`表中只有两行，`phone_numbers`表中有三行。但这里我们却得到了六行。这就是连接的工作原理。它们给出了两个表的*笛卡尔积*。一个表的每一行依次与另一个表的所有行配对。因此，如果将一个N行表与一个M行表连接，将得到一个包含N*M行的结果。在真实的数据库中，N和M可能达到百万级，因此最好更具体地指定你想要哪些行：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Probably more like what you had in mind. Refining your SQL statements in this
    manner can sometimes be more exciting. For example, let's say that you want to
    get rid of Philip Greenspun's phone numbers but aren't sure of the exact syntax.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更接近您心目中的样子。通过这种方式完善您的SQL语句有时可能更加令人兴奋。例如，假设您想摆脱菲利普·格林斯潘的电话号码，但不确定确切的语法。
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Oops. Yes, this does actually delete *all* the rows in the table. You probably
    wish you'd typed
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕。是的，这实际上删除了表中的*所有*行。您可能希望您输入的是
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: but it is too late now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在为时已晚。
- en: 'There is one more fundamental SQL statement to learn. Suppose that Philip moves
    to Hollywood to realize his long-standing dream of becoming a major motion picture
    producer. Clearly a change of name is in order, though he''d be reluctant to give
    up the e-mail address he''s had since 1976\. Here''s the SQL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个更基本的SQL语句需要学习。假设菲利普搬到好莱坞实现他长久以来成为一名重要电影制片人的梦想。显然，需要更改姓名，尽管他不愿放弃自1976年以来一直拥有的电子邮件地址。以下是SQL语句：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As with DELETE, don't play around with UPDATE statements unless you have a WHERE
    clause at the end.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与DELETE一样，不要在UPDATE语句中玩弄，除非在最后有一个WHERE子句。
- en: Brave New World
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇敢的新世界
- en: 'The original mid-1970s RDBMS let companies store the following kinds of data:
    numbers, dates, and character strings. After more than twenty years of innovation,
    you can today run out to the store and spend $300,000 on an "enterprise-class"
    RDBMS that will let you store the following kinds of data: numbers, dates, and
    character strings.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的70年代中期关系数据库管理系统让公司存储以下类型的数据：数字、日期和字符串。经过二十多年的创新，今天您可以跑到商店花费30万美元购买一个“企业级”关系数据库管理系统，可以让您存储以下类型的数据：数字、日期和字符串。
- en: With an *object-relational* database, you get to define your own data types.
    For example, you could define a data type called `url`...
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*对象关系*数据库，您可以定义自己的数据类型。例如，您可以定义一个名为`url`的数据类型...
- en: '[http://www.postgresql.org](http://www.postgresql.org ).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.postgresql.org](http://www.postgresql.org)。'
- en: Braver New World
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更勇敢的新世界
- en: '[![Millesgarden. Stockholm, Sweden](../Images/1f8a14059faf718621693b452c0860dc.jpg)](/http://philip.greenspun.com/images/pcd0836/millesgarden-37.tcl)
    If you really want to be on the cutting edge, you can use a bona fide object database,
    like Object Design''s ObjectStore (acquired by Progress Software). These persistently
    store the sorts of object and pointer structures that you create in a Smalltalk,
    Common Lisp, C++, or Java program. Chasing pointers and certain kinds of transactions
    can be 10 to 100 times faster than in a relational database. If you believed everything
    in the object database vendors'' literature, then you''d be surprised that Larry
    Ellison still has $100 bills to fling to peasants as he roars past in his Acura
    NSX. The relational database management system should have been crushed long ago
    under the weight of this superior technology, introduced with tremendous hype
    in the mid-1980s.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Millesgarden. Stockholm, Sweden](../Images/1f8a14059faf718621693b452c0860dc.jpg)](/http://philip.greenspun.com/images/pcd0836/millesgarden-37.tcl)
    如果您真的想走在前沿，您可以使用一个真正的对象数据库，比如Object Design的ObjectStore（被Progress Software收购）。这些数据库持久地存储您在Smalltalk、Common
    Lisp、C++或Java程序中创建的对象和指针结构。追踪指针和某些类型的事务可能比关系数据库快10到100倍。如果您相信对象数据库供应商的宣传资料中的一切，那么您会惊讶于拉里·埃里森仍然有100美元的钞票可以向过路人扔，当他驾驶他的Acura
    NSX飞驰而过时。关系数据库管理系统应该在80年代中期以巨大的宣传声势引入这种优越技术后早就被击垮了。'
- en: After 10 years, the market for object database management systems is about $100
    million a year, perhaps 1 percent the size of the relational database market.
    Why the fizzle? Object databases bring back some of the bad features of 1960s
    pre-relational database management systems. The programmer has to know a lot about
    the details of data storage. If you know the identities of the objects you're
    interested in, then the query is fast and simple. But it turns out that most database
    users don't care about object *identities*; they care about object *attributes*.
    Relational databases tend to be faster and better at coughing up aggregations
    based on attributes. The critical difference between RDBMS and ODBMS is the extent
    to which the programmer is constrained in interacting with the data. With an RDBMS
    the application program--written in a procedural language such as C, COBOL, Fortran,
    Perl, or Tcl--can have all kinds of catastrophic bugs. However, these bugs generally
    won't affect the information in the database because all communication with the
    RDBMS is constrained through SQL statements. With an ODBMS, the application program
    is directly writing slots in objects stored in the database. A bug in the application
    program may translate directly into corruption of the database, one of an organization's
    most valuable assets.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 十年后，对象数据库管理系统市场每年约为1亿美元，可能是关系数据库市场规模的1%。为什么会失败？对象数据库带回了1960年代关系数据库管理系统之前的一些不好的特征。程序员必须了解数据存储的许多细节。如果你知道你感兴趣的对象的身份，那么查询就会快速简单。但事实证明，大多数数据库用户并不关心对象的*身份*；他们关心对象的*属性*。关系数据库在根据属性提供聚合方面往往更快更好。关系数据库管理系统（RDBMS）和对象数据库管理系统（ODBMS）之间的关键区别在于程序员与数据交互的程度。在RDBMS中，应用程序——用诸如C、COBOL、Fortran、Perl或Tcl等过程语言编写——可能存在各种灾难性错误。然而，这些错误通常不会影响数据库中的信息，因为所有与RDBMS的通信都通过SQL语句限制。在ODBMS中，应用程序直接编写存储在数据库中的对象中的插槽。应用程序中的错误可能直接导致数据库损坏，这是组织中最有价值的资产之一。
- en: More
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多
- en: '"A Relational Model of Data for Large Shared Data Banks", E.F. Codd''s paper
    in the June 1970 *Communications of the ACM* is reprinted in [Readings in Database
    Systems](http://www.amazon.com/exec/obidos/ASIN/1558605231/pgreenspun-20) (Stonebraker
    and Hellerstein 1998; Morgan Kaufmann). You might be wondering why, in 1999, eight
    years after the world''s physicists gave us the Web, I didn''t hyperlink you over
    to Codd''s paper at www.acm.org. However, the organization is so passionately
    dedicated to demonstrating simultaneously the greed and incompetence of academic
    computer scientists worldwide that they charge money to electronically distribute
    material that they didn''t pay for themselves.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “大型共享数据库的关系模型”，E.F. Codd在1970年6月的*ACM通讯*中的论文被重新印刷在[数据库系统读物](http://www.amazon.com/exec/obidos/ASIN/1558605231/pgreenspun-20)中（Stonebraker和Hellerstein
    1998；Morgan Kaufmann）。也许你会想知道为什么在1999年，世界物理学家给了我们互联网八年后，我没有将你链接到Codd在www.acm.org上的论文。然而，该组织如此热衷于同时展示全球学术计算机科学家的贪婪和无能，以至于他们要收费才能电子分发他们自己没有支付的材料。
- en: For some interesting history about the first relational database implementation,
    visit [http://www.mcjones.org/System_R/](http://www.mcjones.org/System_R/)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关第一个关系数据库实现的有趣历史，请访问[http://www.mcjones.org/System_R/](http://www.mcjones.org/System_R/)
- en: For a look under the hoods of a variety of database management systems, get
    [Readings in Database Systems](http://www.amazon.com/exec/obidos/ASIN/1558605231/pgreenspun-20)
    (above)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解各种数据库管理系统的内部工作原理，请获取[数据库系统读物](http://www.amazon.com/exec/obidos/ASIN/1558605231/pgreenspun-20)（上述链接）。
- en: Reference
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考
- en: If you want to sit down and drive Oracle, you'll find [SQL*Plus User's Guide
    and Reference](http://www.oradoc.com/keyword/sqlplus) useful.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要操作Oracle，你会发现[SQL*Plus用户指南和参考](http://www.oradoc.com/keyword/sqlplus)很有用。
- en: If you're hungry for detail, you can get God's honest truth (well, Larry Ellison's
    honest truth anyway, which is pretty much the same thing in the corporate IT world)
    from [Oracle8 Server Concepts](http://www.oradoc.com/keyword/concepts).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你渴望细节，你可以从[Oracle8 Server Concepts](http://www.oradoc.com/keyword/concepts)中获得上帝的真实话（好吧，至少是拉里·埃里森在企业IT世界中的真实话，这在公司IT世界中几乎是一回事）。
- en: 'Next: [data modeling](data-modeling.html)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步：[数据建模](data-modeling.html)
- en: '* * *'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[philg@mit.edu](http://philip.greenspun.com/)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[philg@mit.edu](http://philip.greenspun.com/)'
- en: Reader's Comments
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读者评论
- en: Actually, the ACM do make [A Relational Model of Data for Large Shared Data
    Banks](http://www.acm.org/classics/nov95/toc.html) freely available, but that's
    the exception rather than the rule.
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，ACM 确实免费提供 [大型共享数据库的数据关系模型](http://www.acm.org/classics/nov95/toc.html)，但这只是个例外，而不是规则。
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Tom L](/shared/community-member?user_id=255362), November 26, 2003
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [汤姆·L](/shared/community-member?user_id=255362)，2003年11月26日
- en: I'm using MySQL, and I wanted to comment on a snag I ran into while I was following
    the tutorial in this page. Maybe other newbies can benefit from this.
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我正在使用 MySQL，并且我想评论一下我在遵循本页面教程时遇到的问题。也许其他新手可以从中受益。
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As far as I can tell:'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 据我所知：
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a) MySQL supports different "storage engines" for tables. This is presumably
    a good thing. However, not all engines support referencial constraints.
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a) MySQL 支持不同的“存储引擎”来存储表。这可能是一件好事。但是，并非所有引擎都支持引用约束。
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b) For a MySQL table to support a "references" constraint, it must be of type
    InnoDB. In my installation (on SuSE Linux, right out of a standard RPM binary
    package), this is *not* the default. So you have to either change the server configuration
    to make this the default, or specify "ENGINE = InnoDB" after the closing parenthesis
    in the table definition.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b) 要支持“引用”约束的 MySQL 表必须是 InnoDB 类型。在我的安装中（在 SuSE Linux 上，直接从标准 RPM 二进制包安装），这
    *不是* 默认设置。因此，您必须要么更改服务器配置使其成为默认设置，要么在表定义的右括号后指定“ENGINE = InnoDB”。
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c) Even for InnoDB, the syntax described by Phil above does not work, though
    it is not rejected, merely ignored. According to the manual, this is effectively
    just a comment to the developer that this column is supposed to reference another
    column, even if the constraint is not enforced by mysql.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c) 即使对于 InnoDB，菲尔上面描述的语法也不起作用，尽管它不被拒绝，只是被忽略。根据手册，这实际上只是对开发人员的注释，指出该列应该引用另一列，即使
    mysql 不强制执行约束。
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'd) So, the only way to make this kind of constraint work is to: 1\. make the
    table InnoDB and 2\. use the "FOREIGN KEY (email) REFERENCES mailing_list(email)"
    format as a separate entry inside the table definition.'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d) 因此，使此类约束生效的唯一方法是：1\. 将表设置为 InnoDB 并且 2\. 使用“FOREIGN KEY (email) REFERENCES
    mailing_list(email)”格式作为表定义中的单独条目。
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[MySQL won''t even give a warning! Not even a reminder that such reference
    clauses are merely "comments". It will just happily ignore them and allow any
    old value in that row. Ugh.]'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[MySQL 甚至不会发出警告！甚至不会提醒这些引用子句只是“注释”。它只会欣然接受它们并允许该行中的任何旧值。噫。]'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Antonio Ramirez](/shared/community-member?user_id=280434), March 19, 2007
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [安东尼奥·拉米雷斯](/shared/community-member?user_id=280434)，2007年3月19日
- en: Another addendum for MySQL is that "The CHECK clause is parsed but ignored by
    all storage engines" (http://dev.mysql.com/doc/refman/5.1/en/create-table.html).
    The CHECK can be accomplished, however, with an appropriate TRIGGER.
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个关于 MySQL 的补充是，“CHECK 子句被所有存储引擎解析但被忽略” (http://dev.mysql.com/doc/refman/5.1/en/create-table.html)。然而，可以通过适当的触发器实现
    CHECK。
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Eddie Marks](/shared/community-member?user_id=327715), June 22, 2010
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [埃迪·马克斯](/shared/community-member?user_id=327715)，2010年6月22日
- en: I'd avoid MySQL when learning about RDBMSes - it's philosophically a bit different,
    as evidenced by the silent errors and nondefault status of InnoDB. I use PostGres
    instead - it's free, and the command line tools are excellent. It's straightforward
    to configure and install, and has mature support pretty much anywhere you care
    to use it.
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在学习关系型数据库时我会避开 MySQL - 它在哲学上有点不同，这一点可以从其静默错误和 InnoDB 的非默认状态中看出。我改用 PostGres
    - 它是免费的，命令行工具非常出色。配置和安装都很简单，并且在您想使用的任何地方都有成熟的支持。
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [chris cooney](/shared/community-member?user_id=330155), September 2, 2010
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [克里斯·库尼](/shared/community-member?user_id=330155)，2010年9月2日
- en: The default storage engine can be changed in the MySQL config file, which on
    Linux (e.g. RHEL, CentOS, Debian, SLES, etc.) is stored at **/etc/my.cnf**
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认存储引擎可以在 MySQL 配置文件中更改，在 Linux 上（例如 RHEL、CentOS、Debian、SLES 等），配置文件存储在 **/etc/my.cnf**
    中
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Within that file there SHOULD be a section labeled [mysqld]. Add the following
    line immediately below that label so that the result is as follows:'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在该文件中应该有一个标记为 [mysqld] 的部分。在该标签的下面立即添加以下行，以便结果如下：
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| `[mysqld]` |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `[mysqld]` |'
- en: '| `default-storage-engine = myisam` |'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `default-storage-engine = myisam` |'
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You will then need to restart the mysqld process. There are different ways
    to accomplish this task depending upon your version of Linux. One way is as follow:'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后，您需要重新启动 mysqld 进程。根据您的 Linux 版本，有多种方法可以完成此任务。一种方式如下：
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| `/etc/init.d/mysql stop` |'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `/etc/init.d/mysql stop` |'
- en: '| `/etc/init.d/mysql start` |'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `/etc/init.d/mysql start` |'
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enjoy!
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 祝您愉快！
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Cai Black](/shared/community-member?user_id=339295), June 9, 2011
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [蔡布莱克](/shared/community-member?user_id=339295)，2011年6月9日
- en: '[Add a comment](/comments/add?page_id=3455)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[添加评论](/comments/add?page_id=3455)'
