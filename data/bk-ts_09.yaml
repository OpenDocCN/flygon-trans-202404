- en: 'Chapter 9: Classes in Depth'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：深入类
- en: Classes In Depth
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解类
- en: 'This chapter covers TypeScript classes in more depth, including:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更深入地介绍了 TypeScript 类，包括：
- en: More on public and private methods and properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于公共和私有方法和属性的内容
- en: Accessors (Getters and Setters)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存取器（Getters 和 Setters）
- en: Using interfaces to simplify constructors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口简化构造函数
- en: 'Inheritance: Build a hierarchy of classes'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承：构建类的层次结构
- en: 'Hiding Information: protecting your class data and methods from the outside
    world'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏信息：保护类数据和方法免受外部世界的影响
- en: 'Working with interfaces: Hide your implementation and enable greater levels
    of abstraction'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口：隐藏你的实现并启用更高级别的抽象
- en: 'Abstract classes: Define templates with minimum standards of functionality'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类：定义具有最低功能标准的模板
- en: As you'll see, TypeScript supports classes in mach the same way as C#, Java
    and other class oriented languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，TypeScript 支持类的方式与 C#、Java 和其他面向类的语言基本相同。
- en: Public, Private and Generated JavaScript
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公开、私有和生成的 JavaScript
- en: 'The bus example from the previous chapter shows both public and private class
    members (`SayRoute` and `myRouteNumber` respectively). You can declare both methods
    and properties as public or private. Here''s a slightly more complex example showing
    a private method and public property:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章的公交车示例显示了公共和私有类成员（分别为 `SayRoute` 和 `myRouteNumber`）。你可以将方法和属性声明为公共或私有。下面是一个稍微复杂一点的示例，显示了一个私有方法和一个公共属性：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code defines a new public property, `SeatingCapacity`. Since it's public,
    client functions may both read (get) it and write (set) it. Client functions may
    not invoke the private method, `calculateRunCost`. However, the constructor is
    allowed to invoke calculateRunCost since they both belong to the same object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个新的公共属性，`SeatingCapacity`。由于它是公共的，客户端函数既可以读取（获取）它，也可以写入（设置）它。客户端函数可能不会调用私有方法
    `calculateRunCost`。但是构造函数允许调用 calculateRunCost，因为它们都属于同一个对象。
- en: Transpiled Objects and Implications Thereof
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译后的对象及其影响
- en: It's important to remember that TypeScript eventually compiles down to JavaScript.
    Let's correct the TypeScript syntax error and show the resulting JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住 TypeScript 最终会被编译成 JavaScript。让我们纠正 TypeScript 的语法错误并展示生成的 JavaScript。
- en: 'TypeScript Bus Object:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript Bus 对象：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Transpiled JavaScript Bus Object:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的 JavaScript Bus 对象：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, TypeScript creates an Immediately Invoked Function Expression
    (IIFE) called Bus3 with the following characteristics:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，TypeScript 创建了一个立即调用的函数表达式（IIFE），名为 Bus3，具有以下特征：
- en: Comments from TypeScript source emitted into transpiled JavaScript
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 TypeScript 源代码发射到编译后的 JavaScript 的注释
- en: A function named "Bus3". This maps to the TypeScript constructor.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名为 "Bus3" 的函数。这对应于 TypeScript 构造函数。
- en: Two prototype methods, "SayRoute" and "calculateRunCost".
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个原型方法，"SayRoute" 和 "calculateRunCost"。
- en: In addition, it also shows that TypeScript can't always enforce privacy the
    same way that C# and Java can. At the end of the day, you're working with JavaScript
    and you do anything that JavaScript lets you do. This means access object properties
    using bracket notation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还表明 TypeScript 无法总是像 C# 和 Java 那样强制执行隐私。归根结底，你是在处理 JavaScript，你可以做 JavaScript
    允许你做的任何事情。这意味着使用方括号表示法访问对象属性。
- en: Accessors (Getters and Setters)
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存取器（Getters 和 Setters）
- en: 'TypeScript provides syntax to create Accessors, often called "getters" and
    "setters". These are functions that look and feel a lot like properties but are,
    in fact, functions. Client code uses them just like it uses any other property,
    Here''s a very simple example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 提供了创建存取器的语法，通常称为 "getters" 和 "setters"。这些是看起来感觉很像属性但实际上是函数。客户端代码使用它们就像使用任何其他属性一样，下面是一个非常简单的例子：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Bus4` class defines a private property, `_mySeatingCapacity`. It defines
    a corresponding getter and setter, `SeatingCapacity`. Client code then interacts
    with SeatingCapacity as if it were a public property by setting the value to 80
    and then reading the value when logging it out to the console.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bus4` 类定义了一个私有属性 `_mySeatingCapacity`。它定义了一个对应的 getter 和 setter，`SeatingCapacity`。客户端代码然后通过将值设置为
    80，然后在将其记录到控制台时读取值，与公共属性交互。'
- en: 'TypeScript compiles getters and setters down to plain JavaScript "Object.DefineProperty"
    calls:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将 getters 和 setters 编译成了普通的 JavaScript 的 "Object.DefineProperty"
    调用：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If all you want to do is wrap a public getter and setter around a private property,
    it's hardly worth the trouble^([1](#fn_1)) - and indeed can be misleading. Here's
    a more comprehensive example showing how a getter can perform a more meaningful
    calculation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想在私有属性周围包装一个公共getter和setter，那么这几乎不值得麻烦^([1](#fn_1)) - 实际上可能会误导。这里有一个更全面的示例，展示了getter如何执行更有意义的计算。
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This examples shows a getter, `CostPerRider`. When client code refers to the
    CostPerRider, it calculates a value at run-time by taking into account distance,
    cost per mile and total riders. It then returns that value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了一个getter，`CostPerRider`。当客户端代码引用CostPerRider时，它通过考虑距离、每英里成本和总乘客数在运行时计算一个值，然后返回该值。
- en: '* * *'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '*A Note Regarding Accessors and Performance*Be wary of long-running accessors.
    Some frameworks, such as Angular 1.x, use two-way binding to keep the UI in sync
    with the back end data. If you bind a field in your Angular template to a long-running
    accessor, your users won''t be wishing you a happy birthday.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于访问器和性能的说明*要谨慎使用长时间运行的访问器。一些框架，比如Angular 1.x，使用双向绑定来保持UI与后端数据同步。如果您在Angular模板中将一个字段绑定到一个长时间运行的访问器，您的用户将不会祝您生日快乐。'
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Use Interfaces to Define Constructor Arguments
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用接口定义构造函数参数
- en: 'In the previous example, the Bus5 object''s constructor takes four numeric
    arguments as input:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，Bus5对象的构造函数以四个数字参数作为输入：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's difficult to know what those arguments mean. Sure, intellisense helps a
    lot, but you need to hover your mouse over the code to get that context.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很难知道这些参数的含义。当然，智能感知会帮助很多，但您需要将鼠标悬停在代码上才能获得上下文。
- en: 'We could have create an empty constructor and gone with public accessors or
    properties instead. In this case, we''d end up with code like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以创建一个空构造函数，然后使用公共访问器或属性。在这种情况下，我们最终会得��这样的代码：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are at least two problems with this approach:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法至少存在两个问题：
- en: It requires public properties. This means that they can be changed after they've
    been initialized and that can lead to pernicious side effects.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要公共属性。这意味着它们在初始化后可以被更改，这可能导致有害的副作用。
- en: If you add a new public property, IDEs can't easily tell you everywhere you
    need to change the code to initialize it.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果添加一个新的公共属性，IDE无法轻松告诉您需要在哪里更改代码以初始化它。
- en: 'Consider the second point. Let''s say you have a non-trivial Bus management
    solution and you''re instantiating Bus objects in multiple modules in the solution.
    One day, you realize you need to model a new property, `StandardRouteTime` to
    record how long a particular bus route should take from start to finish. It''s
    easy to update the class definition and and likewise easy enough to update any
    given bit of code that creates a new instance of the bus object. However, it can
    be hard to find every place that you need to change. Interfaces help solve this,
    as shown in the following bit of code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第二点。假设您有一个非平凡的Bus管理解决方案，并且在解决方案中的多个模块中实例化Bus对象。有一天，您意识到需要建模一个新属性，`StandardRouteTime`来记录特定公交路线从起点到终点应该花费多长时间。更新类定义很容易，同样很容易更新任何创建新公交对象实例的代码。但是，找到需要更改的每个地方可能很困难。接口有助于解决这个问题，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code is better for at least three important reasons:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码至少有三个重要原因更好：
- en: Clarity
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清晰度
- en: Long-term maintenance
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 长期维护
- en: Better information hiding
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更好的信息隐藏
- en: Clarity
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清晰度
- en: 'The code defines an interface, `Bus6Args`. The class constructor then takes
    an argument of type Bus6Args. This allows us to write a line of code like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个接口，`Bus6Args`。然后类构造函数接受一个类型为Bus6Args的参数。这使我们可以编写这样一行代码：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a lot easier to understand than:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以下内容更容易理解：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It's immediately obvious what each of these four parameters do.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个参数的作用立即显而易见。
- en: Long-term Maintenance
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长期维护
- en: 'Recall the scenario from above - complex Bus management system with many modules,
    thousands or more lines of code and many, many times when the code instantiates
    a new Bus6 object. To model a new property, follow these simple steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上面的场景 - 复杂的Bus管理系统，有许多模块，成千上万行代码，以及许多次代码实例化新的Bus6对象。要建模一个新属性，请按照以下简单步骤进行：
- en: Update the class definition to include the new property
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新类定义以包含新属性
- en: Update the constructor and class business logic to make use of the property
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新构造函数和类业务逻辑以使用该属性
- en: Compile all the code.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译所有代码。
- en: The first time you do this, the TypeScript compiler will report an error everywhere
    you've instantiated a new Bus object since all of your constructor arguments will
    be missing the new property. This gives you a comprehensive checklist of every
    place you need to account for this new property^([2](#fn_2)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次这样做时，TypeScript 编译器会在您实例化新的 Bus 对象的每个地方报告错误，因为所有构造函数参数都将缺少新属性。这为您提供了一个全面的检查列表，列出了您需要考虑这个新属性的每个地方^([2](#fn_2))。
- en: Classes and Interfaces
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和接口
- en: Many common software design patterns find their best implementation rooted in
    interfaces. In object oriented languages like TypeScript, C# and Java, developers
    use interfaces to abstract implementation details and to create generic functionality
    that works against a collection of seemingly disparate classes instead of individual
    named classes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的软件设计模式在接口中找到了它们最佳的实现。在像 TypeScript、C＃ 和 Java 这样的面向对象语言中，开发人员使用接口来抽象实现细节，并创建通用功能，该功能针对一系列看似不同的类而不是单个命名类。
- en: Classes, Interfaces and Data
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类、接口和数据
- en: So far, we've used interfaces to define the "shape" of data. We can also use
    interfaces to define the shape - the required properties - of a class. Let's step
    away from Buses for the moment and think instead about a product recommendation
    engine. Imagine that you have a database of clothing products such as pants, shirts,
    jackets, shoes, sneakers, etc. You've created a nice search screen that allows
    users to state a preferred color and price range. You want to iterate over all
    of your products and show anything that meets the user's preferences.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用接口来定义数据的“形状”。我们也可以使用接口来定义类的形状 - 所需的属性。暂时抛开公交车，想象一下产品推荐引擎。假设您有一个包含裤子、衬衫、夹克、鞋子、运动鞋等服装产品的数据库。您已经创建了一个很好的搜索屏幕，允许用户指定首选颜色和价格范围。您想要遍历所有产品，并显示满足用户偏好的任何产品。
- en: 'We can easily model these products as classes and if we''re careful about it,
    we can make sure that each class includes a `color` and `price` property. This
    would then allow us to iterate over a collection of these objects and recommend
    them based on the user''s preferences. Taking this approach, we might come up
    with a models like these:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将这些产品建模为类，如果我们小心对待，我们可以确保每个类都包含`color`和`price`属性。这样一来，我们就可以遍历这些对象的集合，并根据用户的偏好推荐它们。采用这种方法，我们可能会得到这样的模型：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each of the three classes has `color` and `price` and this lets us write some
    comparison logic:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类中的每个都有`color`和`price`，这使我们能够编写一些比较逻辑：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code, we build up a random array of products. The code doesn't show
    it, but you can easily pretend that each object is initialized with appropriate
    data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们建立了一个随机产品数组。代码没有显示，但你可以轻松假设每个对象都初始化了适当的数据。
- en: The code defines a function, `Recommend` and that function iterates (via `reduce`)
    over the collection of products, extracting those that match the user's criteria.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码定义了一个函数，`Recommend`，该函数通过`reduce`迭代（通过）产品集合，提取符合用户标准的产品。
- en: 'This works well enough, but it''s really pretty awful overall. There''s an
    `any` array. It''s referencing object properties via bracket notation. If we accidentally
    put a colorless product in the allProducts array, such as bottled water, the code
    throws a runtime error or returns an undefined value. Even if we add a new product,
    such as a scarf, we need to be very careful that we follow the expected naming
    convention. This, for instance, will cause a runtime error:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做已经足够好了，但整体来说真的相当糟糕。有一个`any`数组。它通过括号表示法引用对象属性。如果我们在`allProducts`数组中意外地放入了一个没有颜色的产品，比如瓶装水，代码会抛出运行时错误或返回一个未定义的值。即使我们添加一个新产品，比如围巾，我们也需要非常小心地遵循预期的命名约定。例如，这会导致运行时错误：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It would fail because color is capitalized in the Scarf object but the `Recommend`
    function expects lower case names.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它会失败，因为围巾对象中的颜色是大写的，但`Recommend`函数期望小写名称。
- en: 'We can avoid all this trouble by using interfaces to define required properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用接口来定义所需的属性来避免所有这些麻烦：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So far, this looks a lot like the interfaces discussed earlier in the book.
    However, we can also apply interfaces to classes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这看起来很像本书中前面讨论的接口。然而，我们也可以将接口应用于类：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `implements` keyword tells TypeScript that `Scarf` objects always minimally
    define `color` and `price` properties. They can define more properties and as
    you can see, they do. However, they must at least define those two.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`implements`关键字告诉TypeScript，`Scarf`对象始终至少定义了`color`和`price`属性。它们可以定义更多属性，正如你所看到的，它们确实这样做了。然而，它们至少必须定义这两个属性。'
- en: 'We can make other "Recommendable" objects and by doing this, we can now enjoy
    some intellisense support. Consider this refactored code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建其他“可推荐”对象，通过这样做，我们现在可以享受一些智能感知支持。考虑这个重构后的代码：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code has many advantages over the earlier, non-interface style approach:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比之前的非接口风格方法有很多优势：
- en: '`allRecommendableProducts` contains a collection of objects (`IRecommendable[]`)
    each of which is guaranteed to hold a `price` and `color` property.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allRecommendableProducts`包含一个对象集合（`IRecommendable[]`），每个对象都保证有一个`price`和`color`属性。'
- en: If we try to add another object, such as `ProductDisplay` to that collection,
    the IDE will warn us that it does not meet the interface requirements of the collection's
    objects. This means that our code can safely assume the object properties are
    present.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们尝试添加另一个对象，比如`ProductDisplay`到该集合中，IDE会警告我们它不符合集合对象的接口要求。这意味着我们的代码可以安全地假定对象属性是存在的。
- en: We can reference the color and price properties using dot notation inside the
    reduce function. In fact, the IDE even gives helpful intellisense hints.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在reduce函数内部使用点符号表示颜色和价格属性。事实上，IDE甚至会给出有用的智能感知提示。
- en: 'Here''s a video showing the whole thing:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个展示整个过程的视频：
- en: '[https://www.youtube.com/embed/97u6yaGJ1T4](https://www.youtube.com/embed/97u6yaGJ1T4)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/embed/97u6yaGJ1T4](https://www.youtube.com/embed/97u6yaGJ1T4)'
- en: '(If you can''t see the video, [try clicking here](https://youtu.be/97u6yaGJ1T4)
    or type this URL into your web browser: [https://youtu.be/97u6yaGJ1T4](https://youtu.be/97u6yaGJ1T4).)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (如果您无法查看视频，请[尝试点击这里](https://youtu.be/97u6yaGJ1T4)或将此网址输入到您的网络浏览器中：[https://youtu.be/97u6yaGJ1T4](https://youtu.be/97u6yaGJ1T4)。)
- en: Classes, Interfaces and Methods
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类、接口和方法
- en: In addition to defining data requirements, you can define required methods.
    Let's explore this in the context of a data export. You've modeled a collection
    of products as objects and you want to allow an end user to export those products
    out to an Excel spreadsheet. Excel works great with comma separated lists, so
    if your objects can create a comma-separated version of themselves, then it's
    a piece of cake to export that out and let Excel do its magic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义数据要求，您还可以定义必需的方法。让我们在数据导出的背景下探讨这一点。您已经将一组产品建模为对象，并希望允许最终用户将这些产品导出到Excel电子表格中。Excel非常适合与逗号分隔列表一起使用，因此如果您的对象可以创建一个逗号分隔的版本，那么将其导出并让Excel发挥其魔力就是小菜一碟。
- en: This wouldn't be very hard to do in a generic way using plain JavaScript, so
    let's complicate matters a little bit by introducing a bit of security. Some objects
    contain sensitive information, such as `cost` and you want to restrict access
    to that property based on the user's role (e.g. "operator", "supervisor", "administrator").
    Lastly, we're not only worried about the `cost` property. Some products, but not
    all, are subject to inventory control measures. In these cases, rather than providing
    the product's actual inventory-on-hand, we need to show a message, "contact sales."
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯JavaScript中以通用方式实现这一点并不难，所以让我们稍微复杂化一下，引入一点安全性。一些对象包含敏感信息，比如`cost`，您希望根据用户的角色（例如“操作员”，“主管”，“管理员”）限制对该属性的访问。最后，我们不仅担心`cost`属性。一些产品，但不是全部，受到库存控制措施的约束。在这些情况下，我们不需要提供产品的实际库存量，而是需要显示一条消息，“联系销售”。
- en: We *could* write a big messy CSV generator that generically iterates over object
    properties and then litter it with a bunch of if/then/else statements. Let's instead
    delegate the field level logic to the product objects themselves.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*编写一个大而混乱的CSV生成器，通用地迭代对象属性，然后用一堆if/then/else语句来填充它。相反，让我们将字段级逻辑委托给产品对象本身。
- en: 'Here''s a moderately complex example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个相对复杂的例子：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One of the first things you''ll notice is that the code defines two interfaces:
    `StandardProduct` and `SecuredFieldsItem`. Then, both classes (Fidget and HotItem)
    implement both interfaces:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到的第一件事是，代码定义了两个接口：`StandardProduct`和`SecuredFieldsItem`。然后，两个类（Fidget和HotItem）都实现了这两个接口：
- en: '`class Fidget implements StandardProduct, SecuredFieldsItem`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Fidget implements StandardProduct, SecuredFieldsItem`'
- en: Classes can implement more than one interface. All you do is define your interfaces
    as usual and then `implement` each one, separating multiple interfaces with a
    comma.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以实现多个接口。你所要做的就是像往常一样定义你的接口，然后用逗号分隔每个接口，`implement`每个接口。
- en: 'Look at the `SecuredFieldItem` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`SecuredFieldItem`类：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Classes that implement the `SecuredFieldsItem` interface must implement a method,
    `GetAllowedFieldNames`. That method must take a string input parameter and it
    must return an array of strings. In a more realistic scenario, you would probably
    pass in some kind of object representing the user as a whole, including his/her
    roles. This example uses hard coded strings to simplify things.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`SecuredFieldsItem`接口的类必须实现一个方法，`GetAllowedFieldNames`。该方法必须接受一个字符串输入参数，并且必须返回一个字符串数组。在一个更现实的场景中，你可能会传递一些表示用户作为一个整体的对象，包括他/她的角色。这个例子使用硬编码的字符串来简化事情。
- en: As you can see, GetAllowedFieldsNames has its own independent implementation
    in each class. Fidget is only concerned about users whose role is "Price Admin".
    HotItem products perform an additional check for users with the "Inventory Admin"
    role.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，GetAllowedFieldsNames在每个类中都有独立的实现。Fidget只关心角色是“价格管理员”的用户。HotItem产品对具有“库存管理员”角色的用户执行额外的检查。
- en: '`getGeneratedCsv` invokes GetAllowedFieldNames on each product. Note the function
    signature:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGeneratedCsv`在每个产品上调用GetAllowedFieldNames。注意函数签名：'
- en: '`function getGeneratedCsv(forProducts: SecuredFieldsItem[], forRoleLabel: string)`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`function getGeneratedCsv(forProducts: SecuredFieldsItem[], forRoleLabel: string)`'
- en: It can iterate over disparate products with significantly different properties
    because they each implement the SecuredFieldsItem interface. Therefore, they will
    always have the GetAllowedFieldNames method to invoke.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以遍历具有完全不同属性的不同产品，因为它们都实现了SecuredFieldsItem接口。因此，它们将始终有GetAllowedFieldNames方法可供调用。
- en: Finally, the helper function `getFormattedCsvRow` generates a properly formatted
    row of comma separated data based on the current item and the allowed fields.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，辅助函数`getFormattedCsvRow`基于当前项目和允许的字段生成适当格式的逗号分隔数据行。
- en: Inheritance
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Like Java and C#, TypeScript supports hierarchical class structures. This allows
    you to incrementally build complex classes by starting with a minimal "base" class
    and then extending it to a new class. This new extended class is said to *inherit*
    the functionality of its base class. "Extend" means to add new class members (properties
    and/or methods).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java和C#一样，TypeScript支持分层类结构。这允许您通过从最小的“基础”类开始然后将其扩展到新类来逐步构建复杂的类。这个新扩展的类被称为*继承*其基类的功能。
    “扩展”意味着添加新的类成员（属性和/或方法）。
- en: Let's demonstrate inheritance by means of US residency models. In this case,
    "resident" means a person living permanently or temporarily in the US.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过美国居留模型来演示继承。在这种情况下，“居民”意味着永久或临时居住在美国的人。
- en: All residents have a name. They have a name irrespective of their residency
    type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有居民都有一个姓名。他们的姓名与他们的居留类型无关。
- en: 'A temporary resident is a resident with two additional properties: A country
    of origin and the date that they need to exit the country (i.e. when their visa
    expires).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 临时居民是具有两个附加属性的居民：出生国家和他们需要离开国家的日期（即他们的签证到期日期）。
- en: A US citizen, like a temporary resident is just a resident with some additional
    properties - the name of the city in which they were born.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 美国公民和临时居民都是一种具有一些额外属性的居民 - 他们出生的城市的名称。
- en: 'Based on this, we can infer a class hierarchy as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们可以推断出类层次结构如下：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Temporary Resident US Citizen
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 临时居民 美国公民
- en: 'Let''s show some code. Here''s a `Resident`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示一些代码。这是一个`Resident`：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This simplistic class defines a single private property, `_name`. It can only
    be set when it''s first created:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的类定义了一个单一的私有属性，`_name`。只有在它首次创建时才能设置：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It has one accessor (a getter) to retrieve the resident''s name:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个访问器（getter）用于检索居民的姓名：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s the model for a temporary resident:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个临时居民的模型：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This model introduces new syntax, the `extends` keyword:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型引入了新的语法，即`extends`关键字：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This means that `TemporaryResident` shares the same members as `Resident`. In
    this case, it's both the `_name` property, as well as the Resident's constructor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`TemporaryResident`共享与`Resident`相同的成员。在这种情况下，它是`_name`属性以及Resident的构造函数。
- en: 'Any class that extends another must always invoke the extended class'' constructor
    via a call to `super`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 任何扩展其他类的类都必须始终通过调用`super`来调用扩展类的构造函数：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, it doesn't need to have the same signature as the extended class.
    `TemporaryResident` takes three parameters. It passes one of those, `name`, to
    its extended class' constructor via the `super(name)` call.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它不需要与扩展类具有相同的签名。`TemporaryResident`接受三个参数。它通过`super(name)`调用将其中一个参数`name`传递给其扩展类的构造函数。
- en: 'Lets round out the example with one more model, a U.S. Citizen:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过另一个模型来完善示例，即美国公民：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just like a `TemporaryResident`, the `USCitizen` class shares the same class
    members as `Resident`. It uses the `extend` keyword to define its parent class.
    `USCitizen`''s constructor invokes its parent class'' constructor, passing in
    the name: `super(birthCity)`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`TemporaryResident`一样，`USCitizen`类共享与`Resident`相同的类成员。它使用`extend`关键字来定义其父类。`USCitizen`的构造函数调用其父类的构造函数，传递名字：`super(birthCity)`。
- en: 'Here''s a full featured video that demonstrates this in great detail:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个功能齐全的视频，详细演示了这一点：
- en: '[https://www.youtube.com/embed/-P1uYVlYEc4](https://www.youtube.com/embed/-P1uYVlYEc4)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/embed/-P1uYVlYEc4](https://www.youtube.com/embed/-P1uYVlYEc4)'
- en: 'If you can''t see the video, [try clicking this link](https://youtu.be/-P1uYVlYEc4)
    or type this URL into your web browser: [https://youtu.be/-P1uYVlYEc4](https://youtu.be/-P1uYVlYEc4)).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到视频，[请尝试点击此链接](https://youtu.be/-P1uYVlYEc4)或将此URL键入您的网络浏览器中：[https://youtu.be/-P1uYVlYEc4](https://youtu.be/-P1uYVlYEc4))。
- en: Hiding and Exposing Class Members
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏和暴露类成员
- en: 'We''ve already see how the `public` keyword and `private` keyword protect or
    grant access to your class members, both properties and methods. Inheritance adds
    a small bit of complexity and enables you to control access to class members via
    public/private as well as a new data control keyword, `protected`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`public`关键字和`private`关键字如何保护或授予对类成员的访问权限，包括属性和方法。继承增加了一点复杂性，并且使您能够通过public/private以及一个新的数据控制关键字`protected`来控制对类成员的访问：
- en: '`public` members may always be accessed up and down the hierarchy and from
    outside the client (i.e. client code).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` 成员始终可以在层次结构中上下访问，并且可以从客户端（即客户端代码）外部访问。'
- en: '`private` members may only be access from within the class itself. This means
    that extended classes may not access their parents'' private members.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private` 成员只能从类本身访问。这意味着扩展类不能访问其父类的私有成员。'
- en: TypeScript provides a new keyword, `protected`. Protected members act like both
    public and private members. They are private to any external client code. They
    are public from their point of definition and all extended sub-classes.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript提供了一个新关键字，`protected`。受保护的成员既像公有成员又像私有成员。它们对任何外部客户端代码都是私有的。从其定义点和所有扩展的子类来看，它们是公共的。
- en: 'This bit of code should help clarify matters:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段应有助于澄清问题：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code sample shows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例显示：
- en: A class, `BaseClass`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类，`BaseClass`。
- en: 'BaseClass defines three members: `_myPrivateProperty`, `_myProtectedProperty`
    and `MyPublicProperty`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BaseClass定义了三个成员：`_myPrivateProperty`、`_myProtectedProperty`和`MyPublicProperty`。
- en: It defines another class, `ExtendedBaseClass`. This extends BaseClass.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了另一个类，`ExtendedBaseClass`。这扩展了BaseClass。
- en: ExtendedBaseClass is allowed to access _myProtectedProperty and MyPublicProperty.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ExtendedBaseClass允许访问_myProtectedProperty和MyPublicProperty。
- en: ExtendedBaseClass *may not* access _myPrivateProperty.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ExtendedBaseClass *可能不* 访问_myPrivateProperty。
- en: Some client code defines a new const variable, `myExtendedBaseClass`. It holds
    a reference to an instance of ExtendedBaseClass.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些客户端代码定义了一个新的const变量，`myExtendedBaseClass`。它保存对ExtendedBaseClass实例的引用。
- en: The client code is able to access the instance's `MyPublicProperty` but is prevented
    from accessing either the private or the protected properties.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端代码能够访问实例的`MyPublicProperty`，但无法访问私有或受保护的属性。
- en: Abstract Classes
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'Abstract classes round out TypeScript''s support for hierarchies of this nature.
    An abstract class looks and feels like a standard class with a key exception:
    abstract classes may never be instantiated. If JavaScript is your first and primary
    programming language, this may seem strange. However, abstract classes, along
    with interfaces, enable developers to express many common software design patterns
    naturally and gracefully. Let''s consider an example.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类完善了TypeScript对这种类型层次结构的支持。抽象类看起来和感觉像标准类，但有一个关键的例外：抽象类永远不能被实例化。如果JavaScript是您的第一种和主要的编程语言，这可能看起来很奇怪。然而，抽象类以及接口使开发人员能够自然而优雅地表达许多常见的软件设计模式。让我们考虑一个例子。
- en: 'Imagine that you are a writing a game. Players place different types of military
    bases (e.g. "Army", "Navy") on a two dimensional map. Bases share some common
    features, like "name" but diverge from each other in important details. Army bases
    consist of soldiers while navy bases consist of ships. Lastly, at run-time, players
    can "activate" a base. This triggers the base to do something meaningful in the
    game. Here''s a naive way to model it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在编写一个游戏。玩家在二维地图上放置不同类型的军事基地（例如“陆军”，“海军”）。基地共享一些共同特征，比如“名称”，但在重要细节上有所不同。陆军基地由士兵组成，而海军基地由船只组成。最后，在运行时，玩家可以“激活”一个基地。这会触发基地在游戏中执行有意义的操作。以下是一种简单的建模方式：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By now, this is pretty straight-forward. A `NaiveBase` class holds a private
    property, `_myName` and provides an get accessor to retrieve the value. Two other
    classes extend it and add their own properties: `NaiveArmyBase` and `NaiveNavyBase`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是相当简单明了的。一个`NaiveBase`类持有一个私有属性`_myName`，并提供一个获取器来检索值。另外两个类扩展它并添加自己的属性：`NaiveArmyBase`和`NaiveNavyBase`。
- en: Both the army an navy base classes implement the `Activatable` interface, albeit
    in this example, each class' `ActiveSelf()` method simply throws an exception.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 陆军和海军基地类都实现了`Activatable`接口，尽管在这个例子中，每个类的`ActiveSelf()`方法只是简单地抛出异常。
- en: 'There is a problem with this modelling approach: there''s no such thing as
    plain vanilla NaiveBase. Players never create vanilla bases, they always create
    a specific kind of base. However, there''s nothing stopping the code from doing
    that.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种建模方法存在一个问题：没有纯粹的香草NaiveBase。玩家永远不会创建普通的基地，他们总是创建特定类型的基地。然而，代码没有阻止这样做。
- en: There's another problem here as well. This approach forces us to implement the
    `Activatable` interface on every class. We could implement it on the base class,
    but that just compounds the first problem - now we've implemented an interface
    on a class we should never instantiate.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一个问题。这种方法迫使我们在每个类上实现`Activatable`接口。我们可以在基类上实现它，但这只会加剧第一个问题 - 现在我们在一个不应该实例化的类上实现了一个接口。
- en: 'Abstract classes solve this problem for us. Here''s the code re-written using
    an abstract class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类为我们解决了这个问题。以下是使用抽象类重新编写的代码：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This example introduces the `abstract` keyword. We now have an abstract class,
    `Base`. This abstract class implements the `Activatable` interface. In doing so,
    you can see another characteristic of TypeScript''s abstract functionality: you
    may mark classes and *class members* as abstract. (In fact, you must mark the
    class abstract if it contains any abstract members). The Activatable interface
    requires a method, `ActiveSelf`. However, this method only makes sense for "real"
    bases - army and navy bases. Hence, we mark the ActivateSelf method itself as
    abstract:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子介绍了`abstract`关键字。我们现在有一个抽象类`Base`。这个抽象类实现了`Activatable`接口。通过这样做，你可以看到TypeScript抽象功能的另一个特点：你可以将类和*类成员*标记为抽象。（事实上，如果包含任何抽象成员，必须将类标记为抽象）。`Activatable`接口需要一个`ActiveSelf`方法。然而，这个方法只对“真实”的基地
    - 陆军和海军基地有意义。因此，我们��`ActivateSelf`方法本身标记为抽象：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This abstract ActivateSelf method meets the requirements of the Activatable
    interface. This is perfect since a vanilla "base" can''t meaningfully activate
    itself - only army and navy bases can do that. At the same time, it forces subclasses
    to implement the method. This is good for two reasons:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象的`ActivateSelf`方法满足了`Activatable`接口的要求。这很完美，因为一个普通的“基地”不能有意义地激活自己 - 只有陆军和海军基地才能这样做。同时，它强制子类实现这个方法。这有两个好处：
- en: You can't forget to do it since the IDE and compiler won't let you.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不能忘记做这件事，因为IDE和编译器不会让你这样做。
- en: Since the subclasses implement the interface, we can write code that leverages
    their type as `Activatable` where and when we need to.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于子类实现了接口，我们可以编写代码，在需要的时候将它们的类型作为`Activatable`来利用。
- en: 'The abstract Base class shows another feature: Abstract classes can define
    non-abstract class members. Since every base has a name, regardless of base type,
    it makes sense to define a concrete `_myName` property and associated getter.
    Sub-classes inherit these concrete class members (properties and methods) just
    like they do with concrete classes.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类展示了另一个特性：抽象类可以定义非抽象类成员。由于每个基类都有一个名称，无论基类类型如何，定义一个具体的`_myName`属性和相关的getter是有意义的。子类继承这些具体类成员（属性和方法）就像它们继承具体类一样。
- en: The army and navy bases extend the abstract class just as if it were a concrete
    class using the same `extends` keyword.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 陆军和海军基地扩展了抽象类，就像它是一个具体类一样，使用相同的`extends`关键字。
- en: 'Wrapping up the example, you can see that newing up army and navy bases works
    the same way as it does in the naive example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 包装示例，你会发现新建的陆军和海军基地的工作方式与简单示例中的工作方式相同：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since both types of bases implement Activatable, you can do this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两种类型的基类都实现了 Activatable，你可以这样做：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s put it all together in a video:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在视频中把所有内容放在一起：
- en: '[https://www.youtube.com/embed/ska4WEeG3pM](https://www.youtube.com/embed/ska4WEeG3pM)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/embed/ska4WEeG3pM](https://www.youtube.com/embed/ska4WEeG3pM)'
- en: '(If you can''t view that video, [try clicking tis link](https://youtu.be/ska4WEeG3pM)
    or typing this url into your web browser: [https://youtu.be/ska4WEeG3pM](https://youtu.be/ska4WEeG3pM).)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: (如果你无法观看该视频，[尝试点击此链接](https://youtu.be/ska4WEeG3pM)或将此网址输入到你的网络浏览器中：[https://youtu.be/ska4WEeG3pM](https://youtu.be/ska4WEeG3pM).)
- en: Further Reading
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'I wrote a blog post that combines unions, Rest parameters and interfaces (wrapped
    inside class) that implements a general purpose logger function: [https://blog.hellojs.org/simple-javascript-logger-in-typescript-demonstrating-interfaces-union-types-and-rest-parameters-6efc5aee2c97](https://blog.hellojs.org/simple-javascript-logger-in-typescript-demonstrating-interfaces-union-types-and-rest-parameters-6efc5aee2c97)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我写了一篇博文，结合了联合、剩余参数和接口（封装在类中），实现了一个通用的记录器函数：[https://blog.hellojs.org/simple-javascript-logger-in-typescript-demonstrating-interfaces-union-types-and-rest-parameters-6efc5aee2c97](https://blog.hellojs.org/simple-javascript-logger-in-typescript-demonstrating-interfaces-union-types-and-rest-parameters-6efc5aee2c97)
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The previous chapter gave you a sip and this chapter turned on the fire hose.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章让你了解了一点，而这一章则打开了消防龙头。
- en: Use interfaces to define both the shape of data and the shape of classes. In
    this case, "shape" means required class members (both methods and properties).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口来定义数据的形状和类的形状。在这种情况下，“形状”意味着必需的类成员（方法和属性）。
- en: Classes *implement* interfaces. Classes may implement multiple interfaces.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类*实现*接口。类可以实现多个接口。
- en: TypeScript allows you to create hierarchies. A class can *extend* another class
    and it, in turn, may be extended. A given class can only extend one other class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许你创建层次结构。一个类可以*扩展*另一个类，而且它本身也可以被扩展。给定的类只能扩展另一个类。
- en: A special kind of class, the *Abstract Class*, can never be instantiated but
    otherwise looks and feel the same as non-abstract classes. Abstract classes can
    (and often do) implement interfaces and they can even define concrete members
    (properties and methods).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型的类，*抽象类*，永远不能被实例化，但在其他方面看起来和非抽象类一样。抽象类可以（并且经常会）实现接口，它们甚至可以定义具体成员（属性和方法）。
- en: We're nearly done with classes. The next chapter provides te final word on classes,
    as well as introducing the final bit of typing TypeScript offers - Generics.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经快要结束了类的学习。下一章将提供类的最终解释，以及引入 TypeScript 提供的最终的类型 - 泛型。
- en: '* * *'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹. Get accessors are well-used when you want to make a property available to
    client code but you don't want to let that client code edit the value. In this
    case, you'd define a private variable paired with its own Get accessor but no
    Set accessor. Don't create a private variable and then pair it with a public getter
    *and* setter. In that case, you may as well just keep it public. [↩](#reffn_1
    "Jump back to footnote [1] in the text.")
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹. 当你想要将属性提供给客户端代码但不想让该客户端代码编辑值时，Getter 访问器就很有用。在这种情况下，你会定义一个私有变量以及它自己的 Getter
    访问器，但没有 Setter 访问器。不要创建一个私有变量，然后将其与公共 Getter *和* Setter 配对。在这种情况下，你可以直接将其保持为公共的。[↩](#reffn_1
    "跳转回文中的脚注 [1]")
- en: ². Since you're still reading at this point, it's probably safe to say that
    you're satisfied that TypeScript is pretty useful. If you're still on the fence,
    consider how you'd address this same issue with plain JavaScript. If you needed
    to make a change of this nature, it would be much more difficult to achieve given
    that you can't get the same kind of great tooling support. You can't force a syntax
    error the same way. You have to rely on global search and/or find/replace. Not
    very fun. [↩](#reffn_2 "Jump back to footnote [2] in the text.")
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ². 既然你仍然在这个地方阅读，可以安全地说你对 TypeScript 非常有用。如果你仍然犹豫不决，考虑一下你将如何用纯 JavaScript 解决这个问题。如果你需要做这样的变化，要实现这样的效果就会更加困难，因为你无法得到同样优秀的工具支持。你无法强制出现语法错误。你必须依赖全局搜索和/或查找/替换。不是很有趣。[↩](#reffn_2
    "跳转回文中的脚注 [2]")
