- en: Chapter 5\. Control Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。控制操作
- en: This chapter introduces the syntactic forms and procedures that serve as control
    structures for Scheme programs, The first section covers the most basic control
    structure, procedure application, and the remaining sections cover sequencing,
    conditional evaluation, recursion, mapping, continuations, delayed evaluation,
    multiple values, and evaluation of programs constructed at run time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了作为 Scheme 程序控制结构的语法形式和过程，第一节涵盖了最基本的控制结构，即过程应用，其余部分涵盖了顺序执行、条件评估、递归、映射、延迟评估、多值和在运行时构建的程序的评估。
- en: Section 5.1\. Procedure Application
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5.1节。过程应用
- en: '**syntax**: `(*expr[0]* *expr[1]* ...)`'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `(*expr[0]* *expr[1]* ...)`'
- en: '**returns:** values of applying the value of `*expr[0]*` to the values of `*expr[1]* ...`'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 将`*expr[0]*`的值应用于`*expr[1]* ...`的值'
- en: Procedure application is the most basic Scheme control structure. Any structured
    form without a syntax keyword in the first position is a procedure application.
    The expressions `*expr[0]*` and `*expr[1]* ...` are evaluated; each should evaluate
    to a single value. After each of these expressions has been evaluated, the value
    of `*expr[0]*` is applied to the values of `*expr[1]* ...`. If `*expr[0]*` does
    not evaluate to a procedure, or if the procedure does not accept the number of
    arguments provided, an exception with condition type `&assertion` is raised.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 过程应用是最基本的 Scheme 控制结构。在第一个位置没有语法关键字的结构化形式是一个过程应用。表达式`*expr[0]*`和`*expr[1]* ...`被评估；每个应该评估为单个值。在每个表达式被评估之后，`*expr[0]*`的值被应用于`*expr[1]* ...`的值。如果`*expr[0]*`不评估为过程，或者过程不接受提供的参数数量，那么将引发一个带有条件类型`&assertion`的异常。
- en: 'The order in which the procedure and argument expressions are evaluated is
    unspecified. It may be left to right, right to left, or any other order. The evaluation
    is guaranteed to be sequential, however: whatever order is chosen, each expression
    is fully evaluated before evaluation of the next is started.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 过程和参数表达式的评估顺序是未指定的。可能是从左到右，从右到左，或者任何其他顺序。然而，评估是有保证的：无论选择了哪种顺序，每个表达式在下一个表达式的评估开始之前都会被完全评估。
- en: '`(+ 3 4) ![<graphic>](ch2_0.gif) 7'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ 3 4) ![<graphic>](ch2_0.gif) 7'
- en: ((if (odd? 3) + -) 6 2) ![<graphic>](ch2_0.gif) 8
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ((if (odd? 3) + -) 6 2) ![<graphic>](ch2_0.gif) 8
- en: ((lambda (x) x) 5) ![<graphic>](ch2_0.gif) 5
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (x) x) 5) ![<graphic>](ch2_0.gif) 5
- en: (let ([f (lambda (x) (+ x x))])
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda (x) (+ x x))])
- en: (f 8)) ![<graphic>](ch2_0.gif) 16`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: (f 8)) ![<graphic>](ch2_0.gif) 16`
- en: '**procedure**: `(apply *procedure* *obj* ... *list*)`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(apply *procedure* *obj* ... *list*)`'
- en: '**returns:** the values of applying `*procedure*` to `*obj* ...` and the elements
    of `*list*`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 将`*procedure*`应用于`*obj* ...`和`*list*`的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`, `(rnrs)`'
- en: '`apply` invokes `*procedure*`, passing the first `*obj*` as the first argument,
    the second `*obj*` as the second argument, and so on for each object in `*obj* ...`,
    and passing the elements of `*list*` in order as the remaining arguments. Thus,
    `*procedure*` is called with as many arguments as there are `*objs*` plus elements
    of `*list*`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`调用`*procedure*`，将第一个`*obj*`作为第一个参数传递，第二个`*obj*`作为第二个参数传递，依此类推，对于`*obj* ...`中的每个对象，将`*list*`中的元素按顺序作为剩余参数传递。因此，`*procedure*`被调用的参数数量等于`*objs*`的数量加上`*list*`的元素数量。'
- en: '`apply` is useful when some or all of the arguments to be passed to a procedure
    are in a list, since it frees the programmer from explicitly destructuring the
    list.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当要传递给过程的一些或所有参数在列表中时，`apply`是有用的，因为它使程序员免于显式地解构列表。
- en: '`(apply + ''(4 5)) ![<graphic>](ch2_0.gif) 9'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (apply + '(4 5)) ![<graphic>](ch2_0.gif) 9
- en: (apply min '(6 8 3 2 5)) ![<graphic>](ch2_0.gif) 2
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: (apply min '(6 8 3 2 5)) ![<graphic>](ch2_0.gif) 2
- en: (apply min  5 1 3 '(6 8 3 2 5)) ![<graphic>](ch2_0.gif) 1
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: (apply min  5 1 3 '(6 8 3 2 5)) ![<graphic>](ch2_0.gif) 1
- en: (apply vector 'a 'b '(c d e)) ![<graphic>](ch2_0.gif) #(a b c d e)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: (apply vector 'a 'b '(c d e)) ![<graphic>](ch2_0.gif) #(a b c d e)
- en: (define first
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: (define first
- en: (lambda (ls)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (apply (lambda (x . y) x) ls)))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (apply (lambda (x . y) x) ls)))
- en: (define rest
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: (define rest
- en: (lambda (ls)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (apply (lambda (x . y) y) ls)))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: (apply (lambda (x . y) y) ls)))
- en: (first '(a b c d)) ![<graphic>](ch2_0.gif) a
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: (first '(a b c d)) ![<graphic>](ch2_0.gif) a
- en: (rest '(a b c d)) ![<graphic>](ch2_0.gif) (b c d)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (rest '(a b c d)) ![<graphic>](ch2_0.gif) (b c d)
- en: (apply append
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: (apply append
- en: '''(1 2 3)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 2 3)'
- en: '''((a b) (c d e) (f))) ![<graphic>](ch2_0.gif) (1 2 3 a b c d e f)`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '''((a b) (c d e) (f))) ![<graphic>](ch2_0.gif) (1 2 3 a b c d e f)`'
- en: Section 5.2\. Sequencing
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5.2节。顺序执行
- en: '**syntax**: `(begin *expr[1]* *expr[2]* ...)`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `(begin *expr[1]* *expr[2]* ...)`'
- en: '**returns:** the values of the last subexpression'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 最后一个子表达式的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: The expressions `*expr[1]* *expr[2]* ...` are evaluated in sequence from left
    to right. `begin` is used to sequence assignments, input/output, or other operations
    that cause side effects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `*expr[1]* *expr[2]* ...` 从左到右顺序执行。`begin` 用于顺序执行赋值、输入/输出或其他会引起副作用的操作。
- en: '`(define x 3)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define x 3)'
- en: (begin
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (set! x (+ x 1))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: (set! x (+ x 1))
- en: (+ x x)) ![<graphic>](ch2_0.gif) 8`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x x)) ![<graphic>](ch2_0.gif) 8`
- en: A `begin` form may contain zero or more definitions in place of the expressions
    `*expr[1]* *expr[2]* ...`, in which case it is considered to be a definition and
    may appear only where definitions are valid.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin` 表单可以包含零个或多个定义，代替表达式 `*expr[1]* *expr[2]* ...`，在这种情况下，它被视为定义，并且只能出现在定义有效的地方。'
- en: '`(let ()'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ()'
- en: (begin (define x 3) (define y 4))
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: (begin (define x 3) (define y 4))
- en: (+ x y)) ![<graphic>](ch2_0.gif) 7`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (+ x y)) ![<graphic>](ch2_0.gif) 7`
- en: This form of `begin` is primarily used by syntactic extensions that must expand
    into multiple definitions. (See page [101](binding.html#multi-define-syntax).)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的 `begin` 主要用于必须扩展为多个定义的语法扩展中。（参见第 [101](binding.html#multi-define-syntax)
    页。）
- en: The bodies of many syntactic forms, including `lambda`, `case-lambda`, `let`,
    `let*`, `letrec`, and `letrec*`, as well as the result clauses of `cond`, `case`,
    and `do`, are treated as if they were inside an implicit `begin`; i.e., the expressions
    making up the body or result clause are executed in sequence, with the values
    of the last expression being returned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语法形式的主体，包括 `lambda`、`case-lambda`、`let`、`let*`、`letrec` 和 `letrec*`，以及 `cond`、`case`
    和 `do` 的结果子句，被视为在隐式 `begin` 内部；即，构成主体或结果子句的表达式按顺序执行，最后一个表达式的值被返回。
- en: '`(define swap-pair!'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define swap-pair!'
- en: (lambda (x)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (let ([temp (car x)])
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([temp (car x)])
- en: (set-car! x (cdr x))
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! x (cdr x))
- en: (set-cdr! x temp)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! x temp)
- en: x)))
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: x)))
- en: (swap-pair! (cons 'a 'b)) ![<graphic>](ch2_0.gif) (b . a)`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: (swap-pair! (cons 'a 'b)) ![<graphic>](ch2_0.gif) (b . a)`
- en: Section 5.3\. Conditionals
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5.3节 条件语句
- en: '**syntax**: `(if *test* *consequent* *alternative*)`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(if *test* *consequent* *alternative*)`'
- en: '**syntax**: `(if *test* *consequent*)`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(if *test* *consequent*)`'
- en: '**returns:** the values of `*consequent*` or `*alternative*` depending on the
    value of `*test*`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 根据 `*test*` 的值返回 `*consequent*` 或 `*alternative*` 的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: The `*test*`, `*consequent*`, and `*alternative*` subforms must be expressions.
    If `*test*` evaluates to a true value (anything other than `#f`), `consequent`
    is evaluated and its values are returned. Otherwise, `alternative` is evaluated
    and its values are returned. With the second, "one-armed," form, which has no
    `*alternative*`, the result is unspecified if `*test*` evaluates to false.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`*test*`、`*consequent*` 和 `*alternative*` 子表达式必须是表达式。如果 `*test*` 评估为真值（除了 `#f`
    之外的任何值），则评估 `consequent` 并返回其值。否则，评估 `alternative` 并返回其值。对于第二种“单臂”形式，没有 `*alternative*`，如果
    `*test*` 评估为假，则结果是未指定的。'
- en: '`(let ([ls ''(a b c)])'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([ls ''(a b c)])'
- en: (if (null? ls)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cdr ls))) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr ls))) ![<graphic>](ch2_0.gif) (b c)
- en: (let ([ls '()])
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls '()])
- en: (if (null? ls)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cdr ls))) ![<graphic>](ch2_0.gif) ()
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr ls))) ![<graphic>](ch2_0.gif) ()
- en: (let ([abs
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([abs
- en: (lambda (x)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (if (< x 0)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< x 0)
- en: (- 0 x)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (- 0 x)
- en: x))])
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: x))])
- en: (abs -4)) ![<graphic>](ch2_0.gif) 4
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (abs -4)) ![<graphic>](ch2_0.gif) 4
- en: (let ([x -4])
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x -4])
- en: (if (< x 0)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< x 0)
- en: (list 'minus (- 0 x))
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: (list 'minus (- 0 x))
- en: (list 'plus 4))) ![<graphic>](ch2_0.gif) (minus 4)`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (list 'plus 4))) ![<graphic>](ch2_0.gif) (minus 4)`
- en: '**procedure**: `(not *obj*)`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(not *obj*)`'
- en: '**returns:** `#t` if `*obj*` is false, `#f` otherwise'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果 `*obj*` 为假，则返回 `#t`，否则返回 `#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`not` is equivalent to `(lambda (x) (if x #f #t))`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 等同于 `(lambda (x) (if x #f #t))`。'
- en: '`(not #f) ![<graphic>](ch2_0.gif) #t'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`(not #f) ![<graphic>](ch2_0.gif) #t'
- en: (not #t) ![<graphic>](ch2_0.gif) #f
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (not #t) ![<graphic>](ch2_0.gif) #f
- en: (not '()) ![<graphic>](ch2_0.gif) #f
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: (not '()) ![<graphic>](ch2_0.gif) #f
- en: (not (< 4 5)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (not (< 4 5)) ![<graphic>](ch2_0.gif) #f`
- en: '**syntax**: `(and *expr* ...)`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(and *expr* ...)`'
- en: '**returns:** see below'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If no subexpressions are present, the `and` form evaluates to `#t`. Otherwise,
    `and` evaluates each subexpression in sequence from left to right until only one
    subexpression remains or a subexpression returns `#f`. If one subexpression remains,
    it is evaluated and its values are returned. If a subexpression returns `#f`,
    `and` returns `#f` without evaluating the remaining subexpressions. A syntax definition
    of `and` appears on page [62](further.html#defn:and).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有子表达式，则 `and` 形式评估为 `#t`。否则，`and` 从左到右按顺序评估每个子表达式，直到只剩下一个子表达式或一个子表达式返回 `#f`。如果只剩下一个子表达式，则对其进行评估并返回其值。如果一个子表达式返回
    `#f`，则 `and` 返回 `#f` 而不评估剩余的子表达式。`and` 的语法定义见第 [62](further.html#defn:and) 页。
- en: '`(let ([x 3])'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 3])'
- en: (and (> x 2) (< x 4))) ![<graphic>](ch2_0.gif) #t
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (和 (> x 2) (< x 4))) ![<graphic>](ch2_0.gif) #t
- en: (let ([x 5])
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 5])
- en: (and (> x 2) (< x 4))) ![<graphic>](ch2_0.gif) #f
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: (和 (> x 2) (< x 4))) ![<graphic>](ch2_0.gif) #f
- en: (and #f '(a b) '(c d)) ![<graphic>](ch2_0.gif) #f
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: (和 #f '(a b) '(c d)) ![<graphic>](ch2_0.gif) #f
- en: (and '(a b) '(c d) '(e f)) ![<graphic>](ch2_0.gif) (e f)`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: (和 '(a b) '(c d) '(e f)) ![<graphic>](ch2_0.gif) (e f)`
- en: '**syntax**: `(or *expr* ...)`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(or *expr* ...)`'
- en: '**returns:** see below'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`，`(rnrs)`'
- en: If no subexpressions are present, the `or` form evaluates to `#f`. Otherwise,
    `or` evaluates each subexpression in sequence from left to right until only one
    subexpression remains or a subexpression returns a value other than `#f`. If one
    subexpression remains, it is evaluated and its values are returned. If a subexpression
    returns a value other than `#f`, `or` returns that value without evaluating the
    remaining subexpressions. A syntax definition of `or` appears on page [63](further.html#defn:or).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有子表达式，则 `or` 形式评估为 `#f`。否则，`or` 从左到右按顺序评估每个子表达式，直到只剩下一个子表达式或一个子表达式返回一个不是
    `#f` 的值。如果只剩下一个子表达式，则对其进行评估并返回其值。如果一个子表达式返回一个不是 `#f` 的值，则 `or` 返回该值而不评估剩余的子表达式。`or`
    的语法定义见第 [63](further.html#defn:or) 页。
- en: '`(let ([x 3])'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 3])'
- en: (or (< x 2) (> x 4))) ![<graphic>](ch2_0.gif) #f
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (或者 (< x 2) (> x 4))) ![<graphic>](ch2_0.gif) #f
- en: (let ([x 5])
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 5])
- en: (or (< x 2) (> x 4))) ![<graphic>](ch2_0.gif) #t
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (或者 (< x 2) (> x 4))) ![<graphic>](ch2_0.gif) #t
- en: (or #f '(a b) '(c d)) ![<graphic>](ch2_0.gif) (a b)`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: (或者 #f '(a b) '(c d)) ![<graphic>](ch2_0.gif) (a b)`
- en: '**syntax**: `(cond *clause[1]* *clause[2]* ...)`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(cond *clause[1]* *clause[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`，`(rnrs)`'
- en: Each `*clause*` but the last must take one of the forms below.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `*clause*` 除了最后一个必须采用以下形式之一。
- en: '`(*test*)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*test*)'
- en: (*test* *expr[1]* *expr[2]* ...)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (*test* *expr[1]* *expr[2]* ...)
- en: (*test* => *expr*)`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (*test* => *expr*)`
- en: The last clause may be in any of the above forms, or it may be an "`else` clause"
    of the form
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个子句可以采用上述任何形式之一，或者可以是形式为 "`else` 子句" 的形式
- en: '`(else *expr[1]* *expr[2]* ...)`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`(else *expr[1]* *expr[2]* ...)`'
- en: Each `*test*` is evaluated in order until one evaluates to a true value or until
    all of the tests have been evaluated. If the first clause whose `*test*` evaluates
    to a true value is in the first form given above, the value of `*test*` is returned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `*test*` 按顺序评估，直到有一个评估为真值或者所有测试都已经评估。如果第一个子句的 `*test*` 评估为真值，则返回 `*test*`
    的值。
- en: If the first clause whose `*test*` evaluates to a true value is in the second
    form given above, the expressions `*expr[1]* *expr[2]*...` are evaluated in sequence
    and the values of the last expression are returned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个子句的 `*test*` 评估为真值，则给定上述第二种形式，将按顺序评估表达式 `*expr[1]* *expr[2]*...`，并返回最后一个表达式的值。
- en: If the first clause whose `*test*` evaluates to a true value is in the third
    form given above, the expression `*expr*` is evaluated. The value should be a
    procedure of one argument, which is applied to the value of `*test*`. The values
    of this application are returned.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个子句的 `*test*` 评估为真值，则给定上述第三种形式，将评估表达式 `*expr*`。该值应为一个接受一个参数的过程，该参数应用于 `*test*`
    的值。此应用的值将被返回。
- en: If none of the tests evaluates to a true value and an `else` clause is present,
    the expressions `*expr[1]* *expr[2]* ...` of the `else` clause are evaluated in
    sequence and the values of the last expression are returned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有测试评估为真值且存在 `else` 子句，则按顺序评估 `else` 子句的表达式 `*expr[1]* *expr[2]* ...`，并返回最后一个表达式的值。
- en: If none of the tests evaluates to a true value and no `else` clause is present,
    the value or values are unspecified.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有测试评估为真值且没有 `else` 子句，则值或值未指定。
- en: See page [305](syntax.html#defn:cond) for a syntax definition of `cond`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `cond` 的语法定义，请参见第 [305](syntax.html#defn:cond) 页。
- en: '`(let ([x 0])'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 0])'
- en: (cond
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(< x 0) (list ''minus (abs x))]'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[(< x 0) (列表 ''minus (绝对值 x))]'
- en: '[(> x 0) (list ''plus x)]'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[(> x 0) (列表 ''plus x)]'
- en: '[else (list ''zero x)])) ![<graphic>](ch2_0.gif) (zero 0)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (列表 ''zero x)])) ![<graphic>](ch2_0.gif) (零 0)'
- en: (define select
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 select
- en: (lambda (x)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (cond
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(not (symbol? x))]'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[(不是 (符号？ x))]'
- en: '[(assq x ''((a . 1) (b . 2) (c . 3))) => cdr]'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[(assq x ''((a . 1) (b . 2) (c . 3))) => cdr]'
- en: '[else 0])))'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[else 0])))'
- en: (select 3) ![<graphic>](ch2_0.gif) #t
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: (选择 3) ![<graphic>](ch2_0.gif) #t
- en: (select 'b) ![<graphic>](ch2_0.gif) 2
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (选择 'b) ![<graphic>](ch2_0.gif) 2
- en: (select 'e) ![<graphic>](ch2_0.gif) 0`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (选择 'e) ![<graphic>](ch2_0.gif) 0`
- en: '**syntax**: `else`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`else`'
- en: '**syntax**: `=>`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`=>`'
- en: '**libraries:** `(rnrs base)`, `(rnrs exceptions)`, `(rnrs)`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs base)`，`(rnrs exceptions)`，`(rnrs)`'
- en: These identifiers are auxiliary keywords for `cond`. Both also serve as auxiliary
    keywords for `guard`, and `else` also serves as an auxiliary keyword for `case`.
    It is a syntax violation to reference these identifiers except in contexts where
    they are recognized as auxiliary keywords.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标识符是`cond`的辅助关键字。它们也作为`guard`和`case`的辅助关键字。在除了它们被识别为辅助关键字的上下文之外引用这些标识符是语法违例。
- en: '**syntax**: `(when *test-expr* *expr[1]* *expr[2]* ...)`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(when *test-expr* *expr[1]* *expr[2]* ...)`'
- en: '**syntax**: `(unless *test-expr* *expr[1]* *expr[2]* ...)`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(unless *test-expr* *expr[1]* *expr[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**见下文'
- en: '**libraries:** `(rnrs control)`, `(rnrs)`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs control)`，`(rnrs)`'
- en: For `when`, if `*test-expr*` evaluates to a true value, the expressions `*expr[1]* *expr[2]* ...`
    are evaluated in sequence, and the values of the last expression are returned.
    If `*test-expr*` evaluates to false, none of the other expressions are evaluated,
    and the value or values of `when` are unspecified.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`when`，如果`*test-expr*`评估为真值，则按顺序评估表达式`*expr[1]* *expr[2]* ...`，并返回最后一个表达式的值。如果`*test-expr*`评估为假，则不评估其他表达式，并且`when`的值或值是未指定的。
- en: For `unless`, if `*test-expr*` evaluates to false, the expressions `*expr[1]* *expr[2]* ...`
    are evaluated in sequence, and the values of the last expression are returned.
    If `*test-expr*` evaluates to a true value, none of the other expressions are
    evaluated, and the value or values of `unless` are unspecified.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`unless`，如果`*test-expr*`评估为假，则按顺序评估表达式`*expr[1]* *expr[2]* ...`，并返回最后一个表达式的值。如果`*test-expr*`评估为真值，则不评估其他表达式，并且`unless`的值或值是未指定的。
- en: A `when` or `unless` expression is usually clearer than the corresponding "one-armed"
    `if` expression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`或`unless`表达式通常比相应的"单臂" `if`表达式更清晰。'
- en: '`(let ([x -4] [sign ''plus])'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`(让 ([x -4] [sign ''plus])'
- en: (when (< x 0)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: (当 (< x 0)
- en: (set! x (- 0 x))
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: (设定！ x (- 0 x))
- en: (set! sign 'minus))
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: (设定！ sign 'minus))
- en: (list sign x)) ![<graphic>](ch2_0.gif) (minus 4)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: (列表 符号 x)) ![<graphic>](ch2_0.gif) (减 4)
- en: (define check-pair
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 check-pair
- en: (lambda (x)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (unless (pair? x)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (unless (pair? x)
- en: (syntax-violation 'check-pair "invalid argument" x))
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (语法违例 'check-pair "无效的参数" x))
- en: x))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: x))
- en: (check-pair '(a b c)) ![<graphic>](ch2_0.gif) (a b c)`
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (check-pair '(a b c)) ![<graphic>](ch2_0.gif) (a b c)`
- en: '`when` may be defined as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`可以定义如下：'
- en: '`(define-syntax when'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax when'
- en: (syntax-rules ()
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (语法规则 ()
- en: '[(_ e0 e1 e2 ...)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e0 e1 e2 ...)'
- en: (if e0 (begin e1 e2 ...))]))`
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 e0 (开始 e1 e2 ...))]))`
- en: '`unless` may be defined as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless`可以定义如下：'
- en: '`(define-syntax unless'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax unless'
- en: (syntax-rules ()
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (语法规则 ()
- en: '[(_ e0 e1 e2 ...)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e0 e1 e2 ...)'
- en: (if (not e0) (begin e1 e2 ...))]))`
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (不是 e0) (开始 e1 e2 ...))]))`
- en: 'or in terms of `when` as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 或者用`when`表示如下：
- en: '`(define-syntax unless'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax unless'
- en: (syntax-rules ()
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (语法规则 ()
- en: '[(_ e0 e1 e2 ...)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e0 e1 e2 ...)'
- en: (when (not e0) e1 e2 ...)]))`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (当 (不是 e0) e1 e2 ...)]))`
- en: '**syntax**: `(case *expr[0]* *clause[1]* *clause[2]* ...)`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(case *expr[0]* *clause[1]* *clause[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs base)`，`(rnrs)`'
- en: Each clause but the last must take the form
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子句除了最后一个必须采用以下形式
- en: '`((*key* ...) *expr[1]* *expr[2]* ...)`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`((*key* ...) *expr[1]* *expr[2]* ...)`'
- en: where each `*key*` is a datum distinct from the other keys. The last clause
    may be in the above form or it may be an `else` clause of the form
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`*key*`都是与其他键不同的数据。最后一个子句可以是上述形式，也可以是一个`else`子句的形式
- en: '`(else *expr[1]* *expr[2]* ...)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`(else *expr[1]* *expr[2]* ...)`'
- en: '`*expr[0]*` is evaluated and the result is compared (using `eqv?`) against
    the keys of each clause in order. If a clause containing a matching key is found,
    the expressions `*expr[1]* *expr[2]* ...` are evaluated in sequence and the values
    of the last expression are returned.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`*expr[0]*`被评估，并且结果（使用`eqv?`）与每个子句的键按顺序进行比较。如果找到包含匹配键的子句，则按顺序评估表达式`*expr[1]* *expr[2]* ...`，并返回最后一个表达式的值。'
- en: If none of the clauses contains a matching key and an `else` clause is present,
    the expressions `*expr[1]* *expr[2]* ...` of the `else` clause are evaluated in
    sequence and the values of the last expression are returned.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一个子句包含匹配的键，且存在一个 `else` 子句，则按顺序评估 `else` 子句的表达式 `*expr[1]* *expr[2]* ...`，并返回最后一个表达式的值。
- en: If none of the clauses contains a matching key and no `else` clause is present,
    the value or values are unspecified.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一个子句包含匹配的键，且没有 `else` 子句存在，则值或值是未指定的。
- en: See page [306](syntax.html#defn:case) for a syntax definition of `case`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见第 [306](syntax.html#defn:case) 页，了解 `case` 的语法定义。
- en: '`(let ([x 4] [y 5])'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 4] [y 5])'
- en: (case (+ x y)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (case (+ x y)
- en: '[(1 3 5 7 9) ''odd]'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[(1 3 5 7 9) ''odd]'
- en: '[(0 2 4 6 8) ''even]'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[(0 2 4 6 8) ''even]'
- en: '[else ''out-of-range])) ![<graphic>](ch2_0.gif) odd`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[else ''out-of-range])) ![<graphic>](ch2_0.gif) odd`'
- en: Section 5.4\. Recursion and Iteration
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5.4 节。递归和迭代
- en: '**syntax**: `(let *name* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(let *name* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: '**returns:** values of the final body expression'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 最终体表达式的值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: This form of `let`, called `*named*` `let`, is a general-purpose iteration and
    recursion construct. It is similar to the more common form of `let` (see Section [4.4](binding.html#g92))
    in the binding of the variables `*var* ...` to the values of `*expr* ...` within
    the body `*body[1]* *body[2]* ...`, which is processed and evaluated like a `lambda`
    body. In addition, the variable `*name*` is bound within the body to a procedure
    that may be called to recur or iterate; the arguments to the procedure become
    the new values of the variables `*var* ...`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的 `let`，称为*命名* `let`，是一个通用的迭代和递归构造。它类似于更常见的 `let` 形式（参见第 [4.4](binding.html#g92)
    节），在其中将变量 `*var* ...` 绑定到 `*expr* ...` 的值，这些值在体 `*body[1]* *body[2]* ...` 中被处理和评估，就像一个
    `lambda` 体一样。此外，变量 `*name*` 在体内绑定到一个可以用于递归或迭代的过程，该过程的参数成为变量 `*var* ...` 的新值。
- en: A named `let` expression of the form
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个形式为 `let` 的命名表达式
- en: '`(let *name* ((*var* *expr*) ...)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let *name* ((*var*��*expr*) ...)'
- en: '*body[1]* *body[2]* ...)`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*body[1]* *body[2]* ...)`'
- en: can be rewritten with `letrec` as follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用 `letrec` 重写如下。
- en: '`((letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`((letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
- en: '*name*)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*name*)'
- en: '*expr* ...)`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*expr* ...)`'
- en: A syntax definition of `let` that implements this transformation and handles
    unnamed `let` as well can be found on page [312](syntax.html#defn:let).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在第 [312](syntax.html#defn:let) 页找到实现此转换并处理未命名 `let` 的 `let` 的语法定义。
- en: The procedure `divisors` defined below uses named `let` to compute the nontrivial
    divisors of a nonnegative integer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面定义的 `divisors` 过程使用命名 `let` 来计算非负整数的非平凡除数。
- en: '`(define divisors'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define divisors'
- en: (lambda (n)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (let f ([i 2])
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([i 2])
- en: (cond
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(>= i n) ''()]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[(>= i n) ''()]'
- en: '[(integer? (/ n i)) (cons i (f (+ i 1)))]'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[(integer? (/ n i)) (cons i (f (+ i 1)))]'
- en: '[else (f (+ i 1))]))))'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (f (+ i 1))]))))'
- en: (divisors 5) ![<graphic>](ch2_0.gif) ()
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: (divisors 5) ![<graphic>](ch2_0.gif) ()
- en: (divisors 32) ![<graphic>](ch2_0.gif) (2 4 8 16)`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: (divisors 32) ![<graphic>](ch2_0.gif) (2 4 8 16)`
- en: The version above is non-tail-recursive when a divisor is found and tail-recursive
    when a divisor is not found. The version below is fully tail-recursive. It builds
    up the list in reverse order, but this is easy to remedy, if desired, by reversing
    the list on exit.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的版本在找到除数时是非尾递归的，在找不到除数时是尾递归的。下面的版本是完全尾递归的。它以相反的顺序构建列表，但如果需要，可以在退出时轻松纠正这一点，通过反转列表。
- en: '`(define divisors'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define divisors'
- en: (lambda (n)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (let f ([i 2] [ls '()])
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([i 2] [ls '()])
- en: (cond
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(>= i n) ls]'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[(>= i n) ls]'
- en: '[(integer? (/ n i)) (f (+ i 1) (cons i ls))]'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[(integer? (/ n i)) (f (+ i 1) (cons i ls))]'
- en: '[else (f (+ i 1) ls)]))))`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (f (+ i 1) ls)]))))`'
- en: '**syntax**: `(do ((*var* *init* *update*) ...) (*test* *result* ...) *expr* ...)`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(do ((*var* *init* *update*) ...) (*test* *result* ...) *expr* ...)`'
- en: '**returns:** the values of the last `*result*` expression'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 最后一个 `*result*` 表达式的值'
- en: '**libraries:** `(rnrs control)`, `(rnrs)`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs control)`, `(rnrs)`'
- en: '`do` allows a common restricted form of iteration to be expressed succinctly.
    The variables `*var* ...` are bound initially to the values of `*init* ...` and
    are rebound on each subsequent iteration to the values of `*update* ...`. The
    expressions `*test*`, `*update* ...`, `*expr* ...`, and `*result* ...` are all
    within the scope of the bindings established for `*var* ...`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` 允许以简洁的方式表达常见的受限迭代形式。变量 `*var* ...` 最初绑定到 `*init* ...` 的值，并在每次迭代中重新绑定到
    `*update* ...` 的值。表达式 `*test*`、`*update* ...`、`*expr* ...` 和 `*result* ...` 都在为
    `*var* ...` 建立的绑定范围内。'
- en: On each step, the test expression `*test*` is evaluated. If the value of `*test*`
    is true, iteration ceases, the expressions `*result* ...` are evaluated in sequence,
    and the values of the last expression are returned. If no result expressions are
    present, the value or values of the `do` expression are unspecified.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，测试表达式 `*test*` 被评估。如果 `*test*` 的值为真，则迭代停止，表达式 `*result* ...` 按顺序被评估，并返回最后一个表达式的值。如果没有结果表达式，则
    `do` 表达式的值是未指定的。
- en: If the value of `*test*` is false, the expressions `*expr* ...` are evaluated
    in sequence, the expressions `*update* ...` are evaluated, new bindings for `*var* ...`
    to the values of `*update* ...` are created, and iteration continues.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*test*` 的值为假，则表达式 `*expr* ...` 按顺序被评估，表达式 `*update* ...` 被评估，为 `*var* ...`
    创建到 `*update* ...` 值的新绑定，并继续迭代。
- en: The expressions `*expr* ...` are evaluated only for effect and are often omitted
    entirely. Any `*update*` expression may be omitted, in which case the effect is
    the same as if the `*update*` were simply the corresponding `*var*`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `*expr* ...` 仅用于效果评估，通常完全省略。任何 `*update*` 表达式都可以省略，此时效果与 `*update*` 简单地是相应的
    `*var*` 一样。
- en: Although looping constructs in most languages require that the loop iterands
    be updated via assignment, `do` requires the loop iterands `*var* ...` to be updated
    via rebinding. In fact, no side effects are involved in the evaluation of a `do`
    expression unless they are performed explicitly by its subexpressions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数语言中的循环结构要求通过赋值来更新循环迭代器，`do` 要求通过重新绑定来更新循环迭代器 `*var* ...`。实际上，在 `do` 表达式的评估中不涉及任何副作用，除非它们由其子表达式显式执行。
- en: See page [313](syntax.html#defn:do) for a syntax definition of `do`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 查看页面 [313](syntax.html#defn:do) 以获取 `do` 的语法定义。
- en: The definitions of `factorial` and `fibonacci` below are straightforward translations
    of the tail-recursive named-`let` versions given in Section [3.2](further.html#g55).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `factorial` 和 `fibonacci` 的定义是第 [3.2](further.html#g55) 节中给出的尾递归具名 `let`
    版本的直接翻译。
- en: '`(define factorial'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define factorial'
- en: (lambda (n)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (do ([i n (- i 1)] [a 1 (* a i)])
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i n (- i 1)] [a 1 (* a i)])
- en: ((zero? i) a))))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ((zero? i) a))))
- en: (factorial 10) ![<graphic>](ch2_0.gif) 3628800
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: (factorial 10) ![<graphic>](ch2_0.gif) 3628800
- en: (define fibonacci
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: (define fibonacci
- en: (lambda (n)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (= n 0)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0)
- en: '0'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (do ([i n (- i 1)] [a1 1 (+ a1 a2)] [a2 0 a1])
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i n (- i 1)] [a1 1 (+ a1 a2)] [a2 0 a1])
- en: ((= i 1) a1)))))
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ((= i 1) a1)))))
- en: (fibonacci 6) ![<graphic>](ch2_0.gif) 8`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 6) ![<graphic>](ch2_0.gif) 8`
- en: The definition of `divisors` below is similar to the tail-recursive definition
    of `divisors` given with the description of named `let` above.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `divisors` 的定义类似于上面给出的具名 `let` 的尾递归定义 `divisors` 的描述。
- en: '`(define divisors'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define divisors'
- en: (lambda (n)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (do ([i 2 (+ i 1)]
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i 2 (+ i 1)]
- en: '[ls ''()'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[ls ''()'
- en: (if (integer? (/ n i))
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (integer? (/ n i))
- en: (cons i ls)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (cons i ls)
- en: ls)])
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ls)])
- en: ((>= i n) ls))))`
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ((>= i n) ls))))`
- en: The definition of `scale-vector!` below, which scales each element of a vector
    *v* by a constant *k*, demonstrates a nonempty `do` body.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `scale-vector!` 的定义，它通过一个常数 *k* 缩放向量 *v* 的每个元素，演示了一个非空的 `do` 体。
- en: '`(define scale-vector!'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define scale-vector!'
- en: (lambda (v k)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (v k)
- en: (let ([n (vector-length v)])
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([n (vector-length v)])
- en: (do ([i 0 (+ i 1)])
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i 0 (+ i 1)])
- en: ((= i n))
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ((= i n))
- en: (vector-set! v i (* (vector-ref v i) k))))))
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-set! v i (* (vector-ref v i) k))))))
- en: (define vec (vector 1 2 3 4 5))
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: (define vec (vector 1 2 3 4 5))
- en: (scale-vector! vec 2)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: (scale-vector! vec 2)
- en: vec ![<graphic>](ch2_0.gif) #(2 4 6 8 10)`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: vec ![<graphic>](ch2_0.gif) #(2 4 6 8 10)`
- en: Section 5.5\. Mapping and Folding
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5.5 节。映射和折叠
- en: When a program must recur or iterate over the elements of a list, a mapping
    or folding operator is often more convenient. These operators abstract away from
    null checks and explicit recursion by applying a procedure to the elements of
    the list one by one. A few mapping operators are also available for vectors and
    strings.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序必须对列表进行递归或迭代时，映射或折叠运算符通常更方便。这些运算符通过逐个应用过程到列表的元素来抽象出空检查和显式递归。一些映射运算符也适用于向量和字符串。
- en: '**procedure**: `(map *procedure* *list[1]* *list[2]* ...)`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(map *procedure* *list[1]* *list[2]* ...)`'
- en: '**returns:** list of results'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 结果列表'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`map` applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    and returns a list of the resulting values. The lists `*list[1]* *list[2]* ...`
    must be of the same length. `*procedure*` should accept as many arguments as there
    are lists, should return a single value, and should not mutate the `*list*` arguments.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 将 `*procedure*` 应用于列表 `*list[1]* *list[2]* ...` 中对应的元素，并返回结果值的列表。列表 `*list[1]* *list[2]* ...`
    必须具有相同长度。`*procedure*` 应接受与列表数量相同的参数，应返回单个值，并且不应改变 `*list*` 参数。'
- en: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)'
- en: (map (lambda (x y) (* x y))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (map (lambda (x y) (* x y))
- en: '''(1 2 3 4)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 2 3 4)'
- en: '''(8 7 6 5)) ![<graphic>](ch2_0.gif) (8 14 18 20)`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '''(8 7 6 5)) ![<graphic>](ch2_0.gif) (8 14 18 20)`'
- en: While the order in which the applications themselves occur is not specified,
    the order of the values in the output list is the same as that of the corresponding
    values in the input lists.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用本身的顺序没有指定，但输出列表中值的顺序与输入列表中相应值的顺序相同。
- en: '`map` might be defined as follows.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 可能定义如下。'
- en: '`(define map'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 map'
- en: (lambda (f ls . more)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f ls . more)
- en: (if (null? more)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? more)
- en: (let map1 ([ls ls])
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: (let map1 ([ls ls])
- en: (if (null? ls)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons (f (car ls))
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (f (car ls))
- en: (map1 (cdr ls)))))
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: (map1 (cdr ls)))))
- en: (let map-more ([ls ls] [more more])
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: (let map-more ([ls ls] [more more])
- en: (if (null? ls)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: (cons
- en: (apply f (car ls) (map car more))
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: (apply f (car ls) (map car more))
- en: (map-more (cdr ls) (map cdr more))))))))`
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: (map-more (cdr ls) (map cdr more))))))))`
- en: No error checking is done by this version of `map`; `f` is assumed to be a procedure
    and the other arguments are assumed to be proper lists of the same length. An
    interesting feature of this definition is that `map` uses itself to pull out the
    cars and cdrs of the list of input lists; this works because of the special treatment
    of the single-list case.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `map` 没有进行错误检查；假定 `f` 是一个过程，其他参数假定为相同长度的适当列表。这个定义的一个有趣特点是，`map` 使用自身来提取输入列表的
    car 和 cdr；这是因为对于单列表情况的特殊处理。
- en: '**procedure**: `(for-each *procedure* *list[1]* *list[2]* ...)`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(for-each *procedure* *list[1]* *list[2]* ...)`'
- en: '**returns:** unspecified'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 未指定'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`for-each` is similar to `map` except that `for-each` does not create and return
    a list of the resulting values, and `for-each` guarantees to perform the applications
    in sequence over the elements from left to right. `*procedure*` should accept
    as many arguments as there are lists and should not mutate the `*list*` arguments.
    `for-each` may be defined without error checks as follows.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-each` 类似于 `map`，但 `for-each` 不会创建并返回结果值的列表，并且 `for-each` 保���按顺序从左到右对元素执行应用。`*procedure*`
    应接受与列表数量相同的参数，并且不应改变 `*list*` 参数。`for-each` 可以如下定义而无需错误检查。'
- en: '`(define for-each'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 for-each'
- en: (lambda (f ls . more)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f ls . more)
- en: (do ([ls ls (cdr ls)] [more more (map cdr more)])
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([ls ls (cdr ls)] [more more (map cdr more)])
- en: ((null? ls))
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ((null? ls))
- en: (apply f (car ls) (map car more)))))
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: (apply f (car ls) (map car more)))))
- en: (let ([same-count 0])
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([same-count 0])
- en: (for-each
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: (for-each
- en: (lambda (x y)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (when (= x y)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: (when (= x y)
- en: (set! same-count (+ same-count 1))))
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: (set! same-count (+ same-count 1))))
- en: '''(1 2 3 4 5 6)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 2 3 4 5 6)'
- en: '''(2 3 3 4 7 6))'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '''(2 3 3 4 7 6))'
- en: same-count) ![<graphic>](ch2_0.gif) 3`
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: same-count) ![<graphic>](ch2_0.gif) 3`
- en: '**procedure**: `(exists *procedure* *list[1]* *list[2]* ...)`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(存在 *procedure* *list[1]* *list[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 见下文'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs lists)`, `(rnrs)`'
- en: The lists `*list[1]* *list[2]* ...` must be of the same length. `*procedure*`
    should accept as many arguments as there are lists and should not mutate the `*list*`
    arguments. If the lists are empty, `exists` returns `#f`. Otherwise, `exists`
    applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    in sequence until either the lists each have only one element or `*procedure*`
    returns a true value `*t*`. In the former case, `exists` tail-calls `*procedure*`,
    applying it to the remaining element of each list. In the latter case, `exists`
    returns `*t*`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 `*list[1]* *list[2]* ...` 必须具有相同长度。`*procedure*` 应接受与列表数量相同的参数，并且不应改变 `*list*`
    参数。如果列表为空，则 `exists` 返回 `#f`。否则，`exists` 依次对列表 `*list[1]* *list[2]* ...` 中对应的元素应用
    `*procedure*`，直到每个列表仅剩一个元素或 `*procedure*` 返回真值 `*t*`。在前一种情况下，`exists` 尾调用 `*procedure*`，将其应用于每个列表的剩余元素。在后一种情况下，`exists`
    返回 `*t*`。
- en: '`(exists symbol? ''(1.0 #\a "hi" ''())) ![<graphic>](ch2_0.gif) #f'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`(存在 symbol? ''(1.0 #\a "hi" ''())) ![<graphic>](ch2_0.gif) #f'
- en: (exists member
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: (存在 member
- en: '''(a b c)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '''(a b c)'
- en: '''((c b) (b a) (a c))) ![<graphic>](ch2_0.gif) (b a)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '''((c b) (b a) (a c))) ![<graphic>](ch2_0.gif) (b a)'
- en: (exists (lambda (x y z) (= (+ x y) z))
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: (exists (lambda (x y z) (= (+ x y) z))
- en: '''(1 2 3 4)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 2 3 4)'
- en: '''(1.2 2.3 3.4 4.5)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1.2 2.3 3.4 4.5)'
- en: '''(2.3 4.4 6.4 8.6)) ![<graphic>](ch2_0.gif) #t`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '''(2.3 4.4 6.4 8.6)) ![<graphic>](ch2_0.gif) #t`'
- en: '`exists` may be defined (somewhat inefficiently and without error checks) as
    follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists`可以定义为（有些低效且没有错误检查）如下：'
- en: '`(define exists'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define exists'
- en: (lambda (f ls . more)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f ls . more)
- en: (and (not (null? ls))
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (null? ls))
- en: (let exists ([x (car ls)] [ls (cdr ls)] [more more])
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: (let exists ([x (car ls)] [ls (cdr ls)] [more more])
- en: (if (null? ls)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: (apply f x (map car more))
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: (apply f x (map car more))
- en: (or (apply f x (map car more))
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: (or (apply f x (map car more))
- en: (exists (car ls) (cdr ls) (map cdr more))))))))`
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: (exists (car ls) (cdr ls) (map cdr more))))))))`
- en: '**procedure**: `(for-all *procedure* *list[1]* *list[2]* ...)`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`(for-all *procedure* *list[1]* *list[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**见下文'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs lists)`，`(rnrs)`'
- en: The lists `*list[1]* *list[2]* ...` must be of the same length. `*procedure*`
    should accept as many arguments as there are lists and should not mutate the `*list*`
    arguments. If the lists are empty, `for-all` returns `#t`. Otherwise, `for-all`
    applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    in sequence until either the lists each have only one element left or `*procedure*`
    returns `#f`. In the former case, `for-all` tail-calls `*procedure*`, applying
    it to the remaining element of each list. In the latter case, `for-all` returns
    `#f`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`*list[1]* *list[2]* ...`必须具有相同的长度。`*procedure*`应接受与列表数量相同的参数，并且不应该改变`*list*`参数。如果列表为空，则`for-all`返回`#t`。否则，`for-all`将`*procedure*`应用于列表`*list[1]* *list[2]* ...`中对应的元素，直到每个列表仅剩下一个元素或`*procedure*`返回`#f`为止。在前一种情况下，`for-all`尾调用`*procedure*`，将其应用于每个列表的剩余元素。在后一种情况下，`for-all`返回`#f`。
- en: '`(for-all symbol? ''(a b c d)) ![<graphic>](ch2_0.gif) #t'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`(for-all symbol? ''(a b c d)) ![<graphic>](ch2_0.gif) #t'
- en: (for-all =
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: (for-all =
- en: '''(1 2 3 4)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 2 3 4)'
- en: '''(1.0 2.0 3.0 4.0)) ![<graphic>](ch2_0.gif) #t'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1.0 2.0 3.0 4.0)) ![<graphic>](ch2_0.gif) #t'
- en: (for-all (lambda (x y z) (= (+ x y) z))
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: (for-all (lambda (x y z) (= (+ x y) z))
- en: '''(1 2 3 4)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 2 3 4)'
- en: '''(1.2 2.3 3.4 4.5)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1.2 2.3 3.4 4.5)'
- en: '''(2.2 4.3 6.5 8.5)) ![<graphic>](ch2_0.gif) #f`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '''(2.2 4.3 6.5 8.5)) ![<graphic>](ch2_0.gif) #f`'
- en: '`for-all` may be defined (somewhat inefficiently and without error checks)
    as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-all`可以定义为（有些低效且没有错误检查）如下：'
- en: '`(define for-all'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define for-all'
- en: (lambda (f ls . more)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f ls . more)
- en: (or (null? ls)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: (or (null? ls)
- en: (let for-all ([x (car ls)] [ls (cdr ls)] [more more])
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: (let for-all ([x (car ls)] [ls (cdr ls)] [more more])
- en: (if (null? ls)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: (apply f x (map car more))
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: (apply f x (map car more))
- en: (and (apply f x (map car more))
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: (and (apply f x (map car more))
- en: (for-all (car ls) (cdr ls) (map cdr more))))))))`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: (for-all (car ls) (cdr ls) (map cdr more))))))))`
- en: '**procedure**: `(fold-left *procedure* *obj* *list[1]* *list[2]* ...)`'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`(fold-left *procedure* *obj* *list[1]* *list[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**见下文'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs lists)`，`(rnrs)`'
- en: The `*list*` arguments should all have the same length. `*procedure*` should
    accept one more argument than the number of `*list*` arguments and return a single
    value. It should not mutate the `*list*` arguments.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`*list*`参数应具有相同的长度。`*procedure*`应接受比`*list*`参数数量多一个的参数，并返回单个值。它不应该改变`*list*`参数。
- en: '`fold-left` returns `*obj*` if the `*list*` arguments are empty. If they are
    not empty, `fold-left` applies `*procedure*` to `*obj*` and the cars of `*list[1]* *list[2]* ...`,
    then recurs with the value returned by `*procedure*` in place of `*obj*` and the
    cdr of each `*list*` in place of the `*list*`.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold-left`如果`*list*`参数为空，则返回`*obj*`。如果它们不为��，则`fold-left`将`*procedure*`应用于`*obj*`和`*list[1]* *list[2]* ...`的car，然后用`*procedure*`返回的值替换`*obj*`，用每个`*list*`的cdr替换`*list*`进行递归。'
- en: '`(fold-left cons ''() ''(1 2 3 4)) ![<graphic>](ch2_0.gif) ((((() . 1) . 2) . 3) . 4)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`(fold-left cons ''() ''(1 2 3 4)) ![<graphic>](ch2_0.gif) ((((() . 1) . 2) . 3) . 4)'
- en: (fold-left
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: (fold-left
- en: (lambda (a x) (+ a (* x x)))
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (a x) (+ a (* x x)))
- en: 0 '(1 2 3 4 5)) ![<graphic>](ch2_0.gif) 55
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 0 '(1 2 3 4 5)) ![<graphic>](ch2_0.gif) 55
- en: (fold-left
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: (fold-left
- en: (lambda (a . args) (append args a))
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (a . args) (append args a))
- en: '''(question)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '''(question)'
- en: '''(that not to)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '''(that not to)'
- en: '''(is to be)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '''(is to be)'
- en: '''(the be: or)) ![<graphic>](ch2_0.gif) (to be or not to be: that is the question)`'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '''(the be: or)) ![<graphic>](ch2_0.gif) (to be or not to be: that is the question)`'
- en: '**procedure**: `(fold-right *procedure* *obj* *list[1]* *list[2]* ...)`'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`(fold-right *procedure* *obj* *list[1]* *list[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**见下文'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs lists)`，`(rnrs)`'
- en: The `*list*` arguments should all have the same length. `*procedure*` should
    accept one more argument than the number of `*list*` arguments and return a single
    value. It should not mutate the `*list*` arguments.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `*list*` 参数的长度应相同。 `*procedure*` 应接受比 `*list*` 参数数量多一个参数，并返回单个值。 它不应更改 `*list*`
    参数。
- en: '`fold-right` returns `*obj*` if the `*list*` arguments are empty. If they are
    not empty, `fold-right` recurs with the cdr of each `*list*` replacing the `*list*`,
    then applies `*procedure*` to the cars of `*list[1]* *list[2]* ...` and the result
    returned by the recursion.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold-right` 如果 `*list*` 参数为空，则返回 `*obj*`。 如果它们不为空，则 `fold-right` 递归地用每个 `*list*`
    的 cdr 替换 `*list*`���然后将 `*procedure*` 应用于 `*list[1]* *list[2]* ...` 的 car 和递归返回的结果。'
- en: '`(fold-right cons ''() ''(1 2 3 4)) ![<graphic>](ch2_0.gif) (1 2 3 4)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`(fold-right cons ''() ''(1 2 3 4)) ![<graphic>](ch2_0.gif) (1 2 3 4)'
- en: (fold-right
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: (fold-right
- en: (lambda (x a) (+ a (* x x)))
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x a) (+ a (* x x)))
- en: 0 '(1 2 3 4 5)) ![<graphic>](ch2_0.gif) 55
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 0 '(1 2 3 4 5)) ![<graphic>](ch2_0.gif) 55
- en: (fold-right
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: (fold-right
- en: (lambda (x y a) (cons* x y a))   ![<graphic>](ch2_0.gif) (parting is such sweet sorrow
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y a) (cons* x y a))   ![<graphic>](ch2_0.gif) 分别是如此甜蜜的离别
- en: '''((with apologies))              ![](ch3_ghostRightarrow.gif)  gotta go see ya tomorrow'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '''((with apologies))              ![](ch3_ghostRightarrow.gif)  明天见'
- en: '''(parting such sorrow go ya)     ![](ch3_ghostRightarrow.gif)  (with apologies))'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '''(parting such sorrow go ya)     ![](ch3_ghostRightarrow.gif)  (with apologies))'
- en: '''(is sweet gotta see tomorrow))`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '''(is sweet gotta see tomorrow))`'
- en: '**procedure**: `(vector-map *procedure* *vector[1]* *vector[1]* ...)`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(vector-map *procedure* *vector[1]* *vector[1]* ...)`'
- en: '**returns:** vector of results'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 结果的向量'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`vector-map` applies `*procedure*` to corresponding elements of `*vector[1]* *vector[2]* ...`
    and returns a vector of the resulting values. The vectors `*vector[1]* *vector[2]* ...`
    must be of the same length, and `*procedure*` should accept as many arguments
    as there are vectors and return a single value.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector-map` 将 `*procedure*` 应用于 `*vector[1]* *vector[2]* ...` 的对应元素，并返回一个包含结果值的向量。
    向量 `*vector[1]* *vector[2]* ...` 必须具有相同的长度，而 `*procedure*` 应接受与向量数量相同的参数，并返回单个值。'
- en: '`(vector-map abs ''#(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) #(1 2 3 4 5 6)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`(vector-map abs ''#(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) #(1 2 3 4 5 6)'
- en: (vector-map (lambda (x y) (* x y))
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-map (lambda (x y) (* x y))
- en: '''#(1 2 3 4)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '''#(1 2 3 4)'
- en: '''#(8 7 6 5)) ![<graphic>](ch2_0.gif) #(8 14 18 20)`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '''#(8 7 6 5)) ![<graphic>](ch2_0.gif) #(8 14 18 20)`'
- en: While the order in which the applications themselves occur is not specified,
    the order of the values in the output vector is the same as that of the corresponding
    values in the input vectors.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用本身的顺序未指定，但输出向量中的值的顺序与输入向量中相应值的顺序相同。
- en: '**procedure**: `(vector-for-each *procedure* *vector[1]* *vector[2]* ...)`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(vector-for-each *procedure* *vector[1]* *vector[2]* ...)`'
- en: '**returns:** unspecified'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 未指定'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`vector-for-each` is similar to `vector-map` except that `vector-for-each`
    does not create and return a vector of the resulting values, and `vector-for-each`
    guarantees to perform the applications in sequence over the elements from left
    to right.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector-for-each` 类似于 `vector-map`，但 `vector-for-each` 不会创建并返回包含结果值的向量，并且 `vector-for-each`
    保证按顺序从左到右对元素执行应用。'
- en: '`(let ([same-count 0])'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([same-count 0])'
- en: (vector-for-each
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-for-each
- en: (lambda (x y)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (when (= x y)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: (当 (= x y)
- en: (set! same-count (+ same-count 1))))
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (set! same-count (+ same-count 1))))
- en: '''#(1 2 3 4 5 6)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '''#(1 2 3 4 5 6)'
- en: '''#(2 3 3 4 7 6))'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '''#(2 3 3 4 7 6))'
- en: same-count) ![<graphic>](ch2_0.gif) 3`
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: same-count) ![<graphic>](ch2_0.gif) 3`
- en: '**procedure**: `(string-for-each *procedure* *string[1]* *string[2]* ...)`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(string-for-each *procedure* *string[1]* *string[2]* ...)`'
- en: '**returns:** unspecified'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 未指定'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`string-for-each` is similar to `for-each` and `vector-for-each` except that
    the inputs are strings rather than lists or vectors.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`string-for-each` 类似于 `for-each` 和 `vector-for-each`，但输入是字符串而不是列表或向量。'
- en: '`(let ([ls ''()])'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([ls ''()])'
- en: (string-for-each
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: (string-for-each
- en: (lambda r (set! ls (cons r ls)))
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda r (set! ls (cons r ls)))
- en: '"abcd"'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '"abcd"'
- en: '"===="'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '"===="'
- en: '"1234")'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '"1234")'
- en: (map list->string (reverse ls))) ![<graphic>](ch2_0.gif) ("a=1" "b=2" "c=3" "d=4")`
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: (map list->string (reverse ls))) ![<graphic>](ch2_0.gif) ("a=1" "b=2" "c=3" "d=4")`
- en: Section 5.6\. Continuations
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5.6节。 续延
- en: Continuations in Scheme are procedures that represent the remainder of a computation
    from a given point in the computation. They may be obtained with `call-with-current-continuation`,
    which can be abbreviated to `call/cc`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme中的续延是代表计算中给定点后续部分的过程。可以使用`call-with-current-continuation`获得续延，可以缩写为`call/cc`。
- en: '**procedure**: `(call/cc *procedure*)`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(call/cc *procedure*)`'
- en: '**procedure**: `(call-with-current-continuation *procedure*)`'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(call-with-current-continuation *procedure*)`'
- en: '**returns:** see below'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 请参见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: These procedures are the same. The shorter name is often used for the obvious
    reason that it requires fewer keystrokes to type.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程是相同的。通常使用较短的名称是因为它需要更少的按键次数来输入。
- en: '`call/cc` obtains its continuation and passes it to `*procedure*`, which should
    accept one argument. The continuation itself is represented by a procedure. Each
    time this procedure is applied to zero or more values, it returns the values to
    the continuation of the `call/cc` application. That is, when the continuation
    procedure is called, it returns its arguments as the values of the application
    of `call/cc`.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`call/cc`获取其续延并将其传递给`*procedure*`，后者应接受一个参数。续延本身由一个过程表示。每次将此过程应用于零个或多个值时，它将这些值返回给`call/cc`应用的续延。也就是说，当调用续延过程时，它将其参数作为`call/cc`应用的值返回。'
- en: If `*procedure*` returns normally when passed the continuation procedure, the
    values returned by `call/cc` are the values returned by `*procedure*`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*procedure*`在传递续延过程时正常返回，则`call/cc`返回的值是`*procedure*`返回的值。
- en: Continuations allow the implementation of nonlocal exits, backtracking [[14](bibliography.html#g232),[29](bibliography.html#g247)],
    coroutines [[16](bibliography.html#g234)], and multitasking [[10](bibliography.html#g228),[32](bibliography.html#g250)].
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 续延允许实现非局部退出、回溯 [[14](bibliography.html#g232),[29](bibliography.html#g247)]、协程 [[16](bibliography.html#g234)]和多任务 [[10](bibliography.html#g228),[32](bibliography.html#g250)]。
- en: The example below illustrates the use of a continuation to perform a nonlocal
    exit from a loop.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了使用续延从循环中进行非局部退出的用法。
- en: '`(define member'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define member'
- en: (lambda (x ls)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x ls)
- en: (call/cc
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (break)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (break)
- en: (do ([ls ls (cdr ls)])
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([ls ls (cdr ls)])
- en: ((null? ls) #f)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ((null? ls) #f)
- en: (when (equal? x (car ls))
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: (when (equal? x (car ls))
- en: (break ls)))))))
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: (break ls)))))))
- en: (member 'd '(a b c)) ![<graphic>](ch2_0.gif) #f
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: (member 'd '(a b c)) ![<graphic>](ch2_0.gif) #f
- en: (member 'b '(a b c)) ![<graphic>](ch2_0.gif) (b c)`
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: (member 'b '(a b c)) ![<graphic>](ch2_0.gif) (b c)`
- en: Additional examples are given in Sections [3.3](further.html#g63) and [12.11](examples.html#g208).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [3.3](further.html#g63) 和 [12.11](examples.html#g208) 节中提供了其他示例。
- en: The current continuation is typically represented internally as a stack of procedure
    activation records, and obtaining the continuation involves encapsulating the
    stack within a procedural object. Since an encapsulated stack has indefinite extent,
    some mechanism must be used to preserve the stack contents indefinitely. This
    can be done with surprising ease and efficiency and with no impact on programs
    that do not use continuations [[17](bibliography.html#g235)].
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当前续延通常在内部表示为一堆过程激活记录的堆栈，并且获取续延涉及将堆栈封装在过程对象中。由于封装的堆栈具有无限范围，必须使用某种机制无限期地保留堆栈内容。这可以以惊人的轻松和效率完成，并且不会对不使用续延的程序产生影响 [[17](bibliography.html#g235)]。
- en: '**procedure**: `(dynamic-wind *in* *body* *out*)`'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(dynamic-wind *in* *body* *out*)`'
- en: '**returns:** values resulting from the application of `*body*`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** values resulting from the application of `*body*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`dynamic-wind` offers "protection" from continuation invocation. It is useful
    for performing tasks that must be performed whenever control enters or leaves
    `*body*`, either normally or by continuation application.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic-wind`提供了对续延调用的“保护”。它用于执行必须在控制进入或离开`*body*`时执行的任务，无论是正常执行还是通过续延应用。'
- en: The three arguments `*in*`, `*body*`, and `*out*` must be procedures and should
    accept zero arguments, i.e., they should be `*thunks*`. Before applying `*body*`,
    and each time `*body*` is entered subsequently by the application of a continuation
    created within `*body*`, the `*in*` thunk is applied. Upon normal exit from `*body*`
    and each time `*body*` is exited by the application of a continuation created
    outside `*body*`, the `*out*` thunk is applied.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 三个参数`*in*`、`*body*`和`*out*`必须是过程，并且应该接受零个参数，即它们应该是`*thunks*`。在应用`*body*`之前，以及每次通过在`*body*`内创建的continuation应用`*body*`时，都会应用`*in*`
    thunk。在从`*body*`正常退出以及每次通过在`*body*`外创建的continuation退出`*body*`时，都会应用`*out*` thunk。
- en: Thus, it is guaranteed that `*in*` is invoked at least once. In addition, if
    `*body*` ever returns, `*out*` is invoked at least once.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以保证至少调用一次`*in*`。此外，如果`*body*`返回，至少会调用一次`*out*`。
- en: The following example demonstrates the use of `dynamic-wind` to be sure that
    an input port is closed after processing, regardless of whether the processing
    completes normally.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用`dynamic-wind`确保在处理后关闭输入端口，无论处理是否正常完成。
- en: '`(let ([p (open-input-file "input-file")])'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([p (open-input-file "input-file")])'
- en: (dynamic-wind
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: (dynamic-wind
- en: (lambda () #f)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () #f)
- en: (lambda () (process p))
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (process p))
- en: (lambda () (close-port p))))`
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (close-port p))))
- en: Common Lisp provides a similar facility (`unwind-protect`) for protection from
    nonlocal exits. This is often sufficient. `unwind-protect` provides only the equivalent
    to `*out*`, however, since Common Lisp does not support fully general continuations.
    Here is how `unwind-protect` might be specified with `dynamic-wind`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp提供了类似的机制（`unwind-protect`）来保护非局部退出。这通常足够了。然而，`unwind-protect`只提供了等价于`*out*`的功能，因为Common
    Lisp不支持完全通用的continuations。以下是如何使用`dynamic-wind`指定`unwind-protect`的方式。
- en: '`(define-syntax unwind-protect'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax unwind-protect'
- en: (syntax-rules ()
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ body cleanup ...)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ body cleanup ...)'
- en: (dynamic-wind
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: (dynamic-wind
- en: (lambda () #f)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () #f)
- en: (lambda () body)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () body)
- en: (lambda () cleanup ...))]))
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () cleanup ...))]))
- en: ((call/cc
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ((call/cc
- en: (let ([x 'a])
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 'a])
- en: (lambda (k)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (unwind-protect
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: (unwind-protect
- en: (k (lambda () x))
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: (k (lambda () x))
- en: (set! x 'b)))))) ![<graphic>](ch2_0.gif) b`
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: (set! x 'b)))))) ![<graphic>](ch2_0.gif) b`
- en: Some Scheme implementations support a controlled form of assignment known as
    *fluid binding*, in which a variable takes on a temporary value during a given
    computation and reverts to the old value after the computation has completed.
    The syntactic form `fluid-let` defined below in terms of `dynamic-wind` permits
    the fluid binding of a single variable `x` to the value of an expression `e` within
    a the body `b1 b2 ...`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Scheme实现支持一种受控的赋值形式，称为*fluid binding*，其中一个变量在给定计算期间采用临时值，并在计算完成后恢复到旧值。以下所定义的语法形式`fluid-let`使用`dynamic-wind`允许将单个变量`x`的fluid
    binding到表达式`e`的值在`b1 b2 ...`体内。
- en: '`(define-syntax fluid-let'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax fluid-let'
- en: (syntax-rules ()
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ ((x e)) b1 b2 ...)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ((x e)) b1 b2 ...)'
- en: (let ([y e])
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([y e])
- en: (let ([swap (lambda () (let ([t x]) (set! x y) (set! y t)))])
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([swap (lambda () (let ([t x]) (set! x y) (set! y t)))])
- en: (dynamic-wind swap (lambda () b1 b2 ...) swap)))]))`
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: (dynamic-wind swap (lambda () b1 b2 ...) swap)))]))`
- en: Implementations that support `fluid-let` typically extend it to allow an indefinite
    number of `(x e)` pairs, as with `let`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 支持`fluid-let`的实现通常会扩展它，允许无限数量的`(x e)`对，就像`let`一样。
- en: If no continuations are invoked within the body of a `fluid-let`, the behavior
    is the same as if the variable were simply assigned the new value on entry and
    assigned the old value on return.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`fluid-let`的主体中没有调用continuations，那么行为就像变量在进入时简单地被赋予新值，返回时被赋予旧值一样。
- en: '`(let ([x 3])'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 3])'
- en: (+ (fluid-let ([x 5])
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (fluid-let ([x 5])
- en: x)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: x)
- en: x)) ![<graphic>](ch2_0.gif) 8`
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: x)) ![<graphic>](ch2_0.gif) 8`
- en: A fluid-bound variable also reverts to the old value if a continuation created
    outside of the `fluid-let` is invoked.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`fluid-let`之外创建的continuation被调用，fluid-bound变量也会恢复到旧值。
- en: '`(let ([x ''a])'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x ''a])'
- en: (let ([f (lambda () x)])
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda () x)])
- en: (cons (call/cc
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (call/cc
- en: (lambda (k)
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (fluid-let ([x 'b])
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: (fluid-let ([x 'b])
- en: (k (f)))))
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: (k (f)))))
- en: (f)))) ![<graphic>](ch2_0.gif) (b . a)`
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: (f)))) ![<graphic>](ch2_0.gif) (b . a)`
- en: If control has left a `fluid-let` body, either normally or by the invocation
    of a continuation, and control reenters the body by the invocation of a continuation,
    the temporary value of the fluid-bound variable is reinstated. Furthermore, any
    changes to the temporary value are maintained and reflected upon reentry.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制已经离开了`fluid-let`的主体，无论是正常离开还是通过调用continuation，如果控制通过调用continuation重新进入主体，fluid-bound变量的临时值将被恢复。此外，对临时值的任何更改都将得到维护和在重新进入时反映出来。
- en: '`(define reenter #f)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define reenter #f)'
- en: (define x 0)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: (define x 0)
- en: (fluid-let ([x 1])
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: (fluid-let ([x 1])
- en: (call/cc (lambda (k) (set! reenter k)))
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc (lambda (k) (set! reenter k)))
- en: (set! x (+ x 1))
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: (set! x (+ x 1))
- en: x) ![<graphic>](ch2_0.gif) 2
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: x) ![<graphic>](ch2_0.gif) 2
- en: x ![<graphic>](ch2_0.gif) 0
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: x ![<graphic>](ch2_0.gif) 0
- en: (reenter '*) ![<graphic>](ch2_0.gif) 3
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: (reenter '*) ![<graphic>](ch2_0.gif) 3
- en: (reenter '*) ![<graphic>](ch2_0.gif) 4
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: (reenter '*) ![<graphic>](ch2_0.gif) 4
- en: x ![<graphic>](ch2_0.gif) 0`
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: x ![<graphic>](ch2_0.gif) 0`
- en: A library showing how `dynamic-wind` might be implemented were it not already
    built in is given below. In addition to defining `dynamic-wind`, the code defines
    a version of `call/cc` that does its part to support `dynamic-wind`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了`dynamic-wind`如果不是内建的情况下可能如何实现的库。除了定义`dynamic-wind`之外，代码还定义了一个版本的`call/cc`，该版本对支持`dynamic-wind`做出了贡献。
- en: '`(library (dynamic-wind)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (dynamic-wind)'
- en: (export dynamic-wind call/cc
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: (export dynamic-wind call/cc
- en: (rename (call/cc call-with-current-continuation)))
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: (rename (call/cc call-with-current-continuation)))
- en: (import (rename (except (rnrs) dynamic-wind) (call/cc rnrs:call/cc)))
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: (import (rename (except (rnrs) dynamic-wind) (call/cc rnrs:call/cc)))
- en: (define winders '())
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: (define winders '())
- en: (define common-tail
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: (define common-tail
- en: (lambda (x y)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (let ([lx (length x)] [ly (length y)])
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([lx (length x)] [ly (length y)])
- en: (do ([x (if (> lx ly) (list-tail x (- lx ly)) x) (cdr x)]
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([x (if (> lx ly) (list-tail x (- lx ly)) x) (cdr x)]
- en: '[y (if (> ly lx) (list-tail y (- ly lx)) y) (cdr y)])'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[y (if (> ly lx) (list-tail y (- ly lx)) y) (cdr y)])'
- en: ((eq? x y) x)))))
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: ((eq? x y) x)))))
- en: (define do-wind
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: (define do-wind
- en: (lambda (new)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new)
- en: (let ([tail (common-tail new winders)])
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([tail (common-tail new winders)])
- en: (let f ([ls winders])
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([ls winders])
- en: (if (not (eq? ls tail))
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: (if (not (eq? ls tail))
- en: (begin
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (set! winders (cdr ls))
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: (set! winders (cdr ls))
- en: ((cdar ls))
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ((cdar ls))
- en: (f (cdr ls)))))
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: (f (cdr ls)))))
- en: (let f ([ls new])
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([ls new])
- en: (if (not (eq? ls tail))
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: (if (not (eq? ls tail))
- en: (begin
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (f (cdr ls))
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: (f (cdr ls))
- en: ((caar ls))
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: ((caar ls))
- en: (set! winders ls)))))))`
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: (set! winders ls)))))))`
- en: '`  (define call/cc'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (define call/cc'
- en: (lambda (f)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f)
- en: (rnrs:call/cc
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs:call/cc
- en: (lambda (k)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (f (let ([save winders])
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: (f (let ([save winders])
- en: (lambda (x)
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (unless (eq? save winders) (do-wind save))
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: (unless (eq? save winders) (do-wind save))
- en: (k x))))))))
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: (k x))))))))
- en: (define dynamic-wind
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: (define dynamic-wind
- en: (lambda (in body out)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (in body out)
- en: (in)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: (in)
- en: (set! winders (cons (cons in out) winders))
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: (set! winders (cons (cons in out) winders))
- en: (let-values ([ans* (body)])
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: (let-values ([ans* (body)])
- en: (set! winders (cdr winders))
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: (set! winders (cdr winders))
- en: (out)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: (out)
- en: (apply values ans*)))))`
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: (apply values ans*)))))`
- en: Together, `dynamic-wind` and `call/cc` manage a list of *winders*. A winder
    is a pair of *in* and *out* thunks established by a call to `dynamic-wind`. Whenever
    `dynamic-wind` is invoked, the *in* thunk is invoked, a new winder containing
    the *in* and *out* thunks is placed on the winders list, the *body* thunk is invoked,
    the winder is removed from the winders list, and the *out* thunk is invoked. This
    ordering ensures that the winder is on the winders list only when control has
    passed through *in* and not yet entered *out*. Whenever a continuation is obtained,
    the winders list is saved, and whenever the continuation is invoked, the saved
    winders list is reinstated. During reinstatement, the *out* thunk of each winder
    on the current winders list that is not also on the saved winders list is invoked,
    followed by the *in* thunk of each winder on the saved winders list that is not
    also on the current winders list. The winders list is updated incrementally, again
    to ensure that a winder is on the current winders list only if control has passed
    through its *in* thunk and not entered its *out* thunk.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic-wind`和`call/cc`共同管理着一个*winders*列表。winder是通过调用`dynamic-wind`建立的一个包含*in*和*out*
    thunk的对。每当调用`dynamic-wind`时，将调用*in* thunk，一个新的winder（包含*in*和*out* thunk）将被放置在winder列表上，将调用*body*
    thunk，然后将winder从winder列表中移除，并调用*out* thunk。这种顺序确保了winder只有在通过*in*传递控制而尚未进入*out*时才存在于winder列表中。每当获得一个continuation时，winders列表将被保存，每当调用continuation时，保存的winders列表将被恢复。在恢复期间，当前winders列表上的每个winder的*out*
    thunk将被调用，而不在当前winders列表上但在保存的winders列表上的每个winder的*in* thunk将被调用。winders列表会进行增量更新，以确保只有当控制通过其*in*
    thunk并且尚未进入其*out* thunk时，winder才存在于当前winders列表中。'
- en: The test `(not (eq? save winders))` performed in `call/cc` is not strictly necessary
    but makes invoking a continuation less costly whenever the saved winders list
    is the same as the current winders list.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `call/cc` 中执行的测试 `(not (eq? save winders))` 不是严格必要的，但在保存的 winders 列表与当前 winders
    列表相同时，使调用 continuation 更少成本。
- en: Section 5.7\. Delayed Evaluation
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5.7 节。延迟评估
- en: The syntactic form `delay` and the procedure `force` may be used in combination
    to implement *lazy evaluation*. An expression subject to lazy evaluation is not
    evaluated until its value is required and, once evaluated, is never reevaluated.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 语法形式 `delay` 和过程 `force` 可以结合使用以实现*惰性评估*。受惰性评估影响的表达式直到需要其值时才被评估，并且一旦评估，就不会重新评估。
- en: '**syntax**: `(delay *expr*)`'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(delay *expr*)`'
- en: '**returns:** a promise'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个 promise'
- en: '**procedure**: `(force *promise*)`'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(force *promise*)`'
- en: '**returns:** result of forcing `*promise*`'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 强制 `*promise*` 的结果'
- en: '**libraries:** `(rnrs r5rs)`'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs r5rs)`'
- en: The first time a promise created by `delay` is *forced* (with `force`), it evaluates
    `*expr*`, "remembering" the resulting value. Thereafter, each time the promise
    is forced, it returns the remembered value instead of reevaluating `*expr*`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `delay` 创建的 promise 第一次被 *强制*（使用 `force`）时，它评估 `*expr*`，"记住"结果值。此后，每次强制 promise
    时，它返回记住的值，而不是重新评估 `*expr*`。
- en: '`delay` and `force` are typically used only in the absence of side effects,
    e.g., assignments, so that the order of evaluation is unimportant.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay` 和 `force` 通常仅在没有副作用的情况下使用，例如赋值，以便评估顺序不重要。'
- en: The benefit of using `delay` and `force` is that some amount of computation
    might be avoided altogether if it is delayed until absolutely required. Delayed
    evaluation may be used to construct conceptually infinite lists, or *streams*.
    The example below shows how a stream abstraction may be built with `delay` and
    `force`. A stream is a promise that, when forced, returns a pair whose cdr is
    a stream.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `delay` 和 `force` 的好处在于，如果延迟到绝对需要时，可以完全避免一些计算。延迟评估可用于构建概念上无限的列表，或*流*。下面的示例显示了如何使用
    `delay` 和 `force` 构建流抽象。流是一个 promise，当强制时返回一个 cdr 是流的对。
- en: '`(define stream-car'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 stream-car'
- en: (lambda (s)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s)
- en: (car (force s))))
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: (car (force s))))
- en: (define stream-cdr
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 stream-cdr
- en: (lambda (s)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s)
- en: (cdr (force s))))
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr (force s))))
- en: (define counters
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 counters
- en: (let next ([n 1])
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: (让 next ([n 1])
- en: (delay (cons n (next (+ n 1))))))
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: (delay (cons n (next (+ n 1))))))
- en: (stream-car counters) ![<graphic>](ch2_0.gif) 1
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: (stream-car counters) ![<graphic>](ch2_0.gif) 1
- en: (stream-car (stream-cdr counters)) ![<graphic>](ch2_0.gif) 2
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: (stream-car (stream-cdr counters)) ![<graphic>](ch2_0.gif) 2
- en: (define stream-add
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 stream-add
- en: (lambda (s1 s2)
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s1 s2)
- en: (delay (cons
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: (延迟 (cons
- en: (+ (stream-car s1) (stream-car s2))
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (stream-car s1) (stream-car s2))
- en: (stream-add (stream-cdr s1) (stream-cdr s2))))))
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: (stream-add (stream-cdr s1) (stream-cdr s2))))))
- en: (define even-counters
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 even-counters
- en: (stream-add counters counters))
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: (stream-add counters counters))
- en: (stream-car even-counters) ![<graphic>](ch2_0.gif) 2
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: (stream-car even-counters) ![<graphic>](ch2_0.gif) 2
- en: (stream-car (stream-cdr even-counters)) ![<graphic>](ch2_0.gif) 4`
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: (stream-car (stream-cdr even-counters)) ![<graphic>](ch2_0.gif) 4`
- en: '`delay` may be defined by'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay` 可以定义为'
- en: '`(define-syntax delay'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义语法 delay'
- en: (syntax-rules ()
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ expr) (make-promise (lambda () expr))]))`'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ expr) (make-promise (lambda () expr))]))`'
- en: where `make-promise` might be defined as follows.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `make-promise` 可能定义如下。
- en: '`(define make-promise'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 make-promise'
- en: (lambda (p)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p)
- en: (let ([val #f] [set? #f])
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([val #f] [set? #f])
- en: (lambda ()
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (unless set?
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 set?
- en: (let ([x (p)])
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([x (p)])
- en: (unless set?
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 set?
- en: (set! val x)
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: (set! val x)
- en: (set! set? #t))))
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: (set! set? #t))))
- en: val))))`
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: val))))`
- en: With this definition of `delay`, `force` simply invokes the promise to force
    evaluation or to retrieve the saved value.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种 `delay` 的定义，`force` 简单地调用 promise 来强制评估或检索保存的值。
- en: '`(define force'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 force'
- en: (lambda (promise)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (promise)
- en: (promise)))`
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: (promise)))`
- en: The second test of the variable `set?` in `make-promise` is necessary in the
    event that, as a result of applying `*p*`, the promise is recursively forced.
    Since a promise must always return the same value, the result of the first application
    of `*p*` to complete is returned.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-promise` 中对变量 `set?` 的第二次测试是必要的，以防由于应用 `*p*` 的结果而递归强制 promise。由于 promise
    必须始终返回相同的值，因此返回完成第一次应用 `*p*` 的结果。'
- en: Whether `delay` and `force` handle multiple return values is unspecified; the
    implementation given above does not, but the following version does, with the
    help of `call-with-values` and `apply`.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay` 和 `force` 是否处理多个返回值是未指定的；上面给出的实现不处理，但以下版本使用 `call-with-values` 和 `apply`
    来处理。'
- en: '`(define make-promise'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 make-promise'
- en: (lambda (p)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p)
- en: (let ([vals #f] [set? #f])
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([vals #f] [set? #f])
- en: (lambda ()
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (unless set?
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 set?
- en: (call-with-values p
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values p
- en: (lambda x
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda x
- en: (unless set?
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 set?
- en: (set! vals x)
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: (set! vals x)
- en: (set! set? #t)))))
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: (set! set? #t)))))
- en: (apply values vals)))))
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: (apply values vals)))))
- en: (define p (delay (values 1 2 3)))
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 p (delay (values 1 2 3)))
- en: (force p) ![<graphic>](ch2_0.gif) 1
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: (force p) ![<graphic>](ch2_0.gif) 1
- en: '![](ch3_ghostRightarrow.gif) 2'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) 2'
- en: '![](ch3_ghostRightarrow.gif) 3'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) 3'
- en: (call-with-values (lambda () (force p)) +) ![<graphic>](ch2_0.gif) 6`
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values (lambda () (force p)) +) ![<graphic>](ch2_0.gif) 6`
- en: Neither implementation is quite right, since `force` must raise an exception
    with condition type `&assertion` if its argument is not a promise. Since distinguishing
    procedures created by `make-promise` from other procedures is impossible, `force`
    cannot do so reliably. The following reimplementation of `make-promise` and `force`
    represents promises as records of the type `promise` to allow `force` to make
    the required check.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现都不太正确，因为如果`force`的参数不是一个promise，它必须引发一个条件类型为`&assertion`的异常。由于无法区分由`make-promise`创建的过程和其他过程，`force`无法可靠地执行此操作。下面对`make-promise`和`force`的重新实现将promise表示为类型为`promise`的记录，以允许`force`进行所需的检查。
- en: '`(define-record-type promise'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type promise'
- en: (fields (immutable p) (mutable vals) (mutable set?))
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: (字段 (不可变 p) (可变 vals) (可变 set?))
- en: (protocol (lambda (new) (lambda (p) (new p #f #f)))))
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: (协议 (lambda (new) (lambda (p) (new p #f #f)))))
- en: (define force
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 force
- en: (lambda (promise)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (promise)
- en: (unless (promise? promise)
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 (promise? promise)
- en: (assertion-violation 'promise "invalid argument" promise))
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: (assertion-violation 'promise "invalid argument" promise))
- en: (unless (promise-set? promise)
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 (promise-set? promise)
- en: (call-with-values (promise-p promise)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values (promise-p promise)
- en: (lambda x
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda x
- en: (unless (promise-set? promise)
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 (promise-set? promise)
- en: (promise-vals-set! promise x)
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: (promise-vals-set! promise x)
- en: (promise-set?-set! promise #t)))))
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: (promise-set?-set! promise #t)))))
- en: (apply values (promise-vals promise))))`
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: (apply values (promise-vals promise))))`
- en: Section 5.8\. Multiple Values
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5.8节。多值
- en: 'While all Scheme primitives and most user-defined procedures return exactly
    one value, some programming problems are best solved by returning zero values,
    more than one value, or even a variable number of values. For example, a procedure
    that partitions a list of values into two sublists needs to return two values.
    While it is possible for the producer of multiple values to package them into
    a data structure and for the consumer to extract them, it is often cleaner to
    use the built-in multiple-values interface. This interface consists of two procedures:
    `values` and `call-with-values`. The former produces multiple values and the latter
    links procedures that produce multiple-value values with procedures that consume
    them.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有Scheme原语和大多数用户定义的过程都返回一个值，但某些编程问题最好通过返回零个值、多个值甚至可变数量的值来解决。例如，将值列表分成两个子���表的过程需要返回两个值。虽然生产多个值的程序员可以将它们打包成数据结构，消费者可以提取它们，但通常更干净的方法是使用内置的多值接口。该接口由两个过程组成：`values`和`call-with-values`。前者产生多个值，后者将产生多值的过程与消费它们的过程链接起来。
- en: '**procedure**: `(values *obj* ...)`'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(values *obj* ...)`'
- en: '**returns:** `*obj* ...`'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** `*obj* ...`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: The procedure `values` accepts any number of arguments and simply passes (returns)
    the arguments to its continuation.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`values`接受任意数量的参数，并简单地将这些参数传递（返回）给其续体。
- en: '`(values) ![<graphic>](ch2_0.gif)'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`(values) ![<graphic>](ch2_0.gif)'
- en: (values 1) ![<graphic>](ch2_0.gif) 1
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: (values 1) ![<graphic>](ch2_0.gif) 1
- en: (values 1 2 3) ![<graphic>](ch2_0.gif) 1
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: (values 1 2 3) ![<graphic>](ch2_0.gif) 1
- en: '![](ch3_ghostRightarrow.gif) 2'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) 2'
- en: '![](ch3_ghostRightarrow.gif) 3'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) 3'
- en: (define head&tail
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 head&tail
- en: (lambda (ls)
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (values (car ls) (cdr ls))))
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: (values (car ls) (cdr ls))))
- en: (head&tail '(a b c)) ![<graphic>](ch2_0.gif) a
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: (head&tail '(a b c)) ![<graphic>](ch2_0.gif) a
- en: '![](ch3_ghostRightarrow.gif) (b c)`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) (b c)`'
- en: '**procedure**: `(call-with-values *producer* *consumer*)`'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(call-with-values *producer* *consumer*)`'
- en: '**returns:** see below'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 请参见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`*producer*` and `*consumer*` must be procedures. `call-with-values` applies
    `*consumer*` to the values returned by invoking `*producer*` without arguments.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`*producer*`和`*consumer*`必须是过程。`call-with-values`将`*consumer*`应用于调用`*producer*`而不带参数返回的值。'
- en: '`(call-with-values'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-values'
- en: (lambda () (values 'bond 'james))
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (values 'bond 'james))
- en: (lambda (x y) (cons y x))) ![<graphic>](ch2_0.gif) (james . bond)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y) (cons y x))) ![<graphic>](ch2_0.gif) (james . bond)
- en: (call-with-values values list) ![<graphic>](ch2_0.gif) '()`
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values values list) ![<graphic>](ch2_0.gif) '()`
- en: In the second example, `values` itself serves as the producer. It receives no
    arguments and thus returns no values. `list` is thus applied to no arguments and
    so returns the empty list.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，`values`本身充当生产者。它不接收任何参数，因此不返回任何值。因此，`list`被应用于没有参数，因此返回空列表。
- en: The procedure `dxdy` defined below computes the change in `*x*` and `*y*` coordinates
    for a pair of points whose coordinates are represented by `(*x* . *y*)` pairs.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 下面定义的`dxdy`过程计算由`(*x* . *y*)`对表示的一对点的坐标的`*x*`和`*y*`坐标的变化。
- en: '`(define dxdy'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define dxdy'
- en: (lambda (p1 p2)
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p1 p2)
- en: (values (- (car p2) (car p1))
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: (values (- (car p2) (car p1))
- en: (- (cdr p2) (cdr p1)))))
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: (- (cdr p2) (cdr p1)))))
- en: (dxdy '(0 . 0) '(0 . 5)) ![<graphic>](ch2_0.gif) 0
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: (dxdy '(0 . 0) '(0 . 5)) ![<graphic>](ch2_0.gif) 0
- en: '![](ch3_ghostRightarrow.gif) 5`'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) 5`'
- en: '`dxdy` can be used to compute the length and slope of a segment represented
    by two endpoints.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`dxdy`可以用于计算由两个端点表示的线段的长度和斜率。'
- en: '`(define segment-length'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define segment-length'
- en: (lambda (p1 p2)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p1 p2)
- en: (call-with-values
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values
- en: (lambda () (dxdy p1 p2))
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (dxdy p1 p2))
- en: (lambda (dx dy) (sqrt (+ (* dx dx) (* dy dy)))))))
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (dx dy) (sqrt (+ (* dx dx) (* dy dy)))))))
- en: (define segment-slope
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: (define segment-slope
- en: (lambda (p1 p2)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p1 p2)
- en: (call-with-values
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values
- en: (lambda () (dxdy p1 p2))
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (dxdy p1 p2))
- en: (lambda (dx dy) (/ dy dx)))))
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (dx dy) (/ dy dx)))))
- en: (segment-length '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 5
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: (segment-length '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 5
- en: (segment-slope '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 4/3`
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: (segment-slope '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 4/3`
- en: We can of course combine these to form one procedure that returns two values.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将这些组合成一个返回两个值的过程。
- en: '`(define describe-segment'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define describe-segment'
- en: (lambda (p1 p2)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p1 p2)
- en: (call-with-values
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values
- en: (lambda () (dxdy p1 p2))
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (dxdy p1 p2))
- en: (lambda (dx dy)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (dx dy)
- en: (values
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: (values
- en: (sqrt (+ (* dx dx) (* dy dy)))
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: (sqrt (+ (* dx dx) (* dy dy)))
- en: (/ dy dx))))))
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: (/ dy dx))))))
- en: (describe-segment '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 5
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: (describe-segment '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 5
- en: '![<graphic>](ch2_0.gif) 4/3`'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '![<graphic>](ch2_0.gif) 4/3`'
- en: The example below employs multiple values to divide a list nondestructively
    into two sublists of alternating elements.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例使用多个值将列表非破坏性地分成两个交替元素的子列表。
- en: '`(define split'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define split'
- en: (lambda (ls)
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (if (or (null? ls) (null? (cdr ls)))
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: (if (or (null? ls) (null? (cdr ls)))
- en: (values ls '())
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: (values ls '())
- en: (call-with-values
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values
- en: (lambda () (split (cddr ls)))
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (split (cddr ls)))
- en: (lambda (odds evens)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (odds evens)
- en: (values (cons (car ls) odds)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: (values (cons (car ls) odds)
- en: (cons (cadr ls) evens)))))))
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (cadr ls) evens)))))))
- en: (split '(a b c d e f)) ![<graphic>](ch2_0.gif) (a c e)
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: (split '(a b c d e f)) ![<graphic>](ch2_0.gif) (a c e)
- en: '![](ch3_ghostRightarrow.gif) (b d f)`'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) (b d f)`'
- en: 'At each level of recursion, the procedure `split` returns two values: a list
    of the odd-numbered elements from the argument list and a list of the even-numbered
    elements.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归的每个级别，`split`过程返回两个值：参数列表中奇数元素的列表和偶数元素的列表。
- en: 'The continuation of a call to `values` need not be one established by a call
    to `call-with-values`, nor must only `values` be used to return to a continuation
    established by `call-with-values`. In particular, `(values *e*)` and `*e*` are
    equivalent expressions. For example:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 对`values`的调用的继续不一定是由对`call-with-values`的调用建立的，也不一定只有`values`用于返回到由`call-with-values`建立的继续。特别地，`(values *e*)`和`*e*`是等价的表达式。例如：
- en: '`(+ (values 2) 4) ![<graphic>](ch2_0.gif) 6'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ (values 2) 4) ![<graphic>](ch2_0.gif) 6'
- en: (if (values #t) 1 2) ![<graphic>](ch2_0.gif) 1
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: (if (values #t) 1 2) ![<graphic>](ch2_0.gif) 1
- en: (call-with-values
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-values
- en: (lambda () 4)
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () 4)
- en: (lambda (x) x)) ![<graphic>](ch2_0.gif) 4`
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) x)) ![<graphic>](ch2_0.gif) 4`
- en: Similarly, `values` may be used to pass any number of values to a continuation
    that ignores the values, as in the following.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`values`可以用于将任意数量的值传递给忽略这些值的继续，如下所示。
- en: '`(begin (values 1 2 3) 4) ![<graphic>](ch2_0.gif) 4`'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`(begin (values 1 2 3) 4) ![<graphic>](ch2_0.gif) 4`'
- en: Because a continuation may accept zero or more than one value, continuations
    obtained via `call/cc` may accept zero or more than one argument.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 因为继续可能接受零个或多个值，通过`call/cc`获得的继续可能接受零个或多个参数。
- en: '`(call-with-values'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-values'
- en: (lambda ()
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (call/cc (lambda (k) (k 2 3))))
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc (lambda (k) (k 2 3))))
- en: (lambda (x y) (list x y))) ![<graphic>](ch2_0.gif) (2 3)`
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y) (list x y))) ![<graphic>](ch2_0.gif) (2 3)`
- en: The behavior is unspecified when a continuation expecting exactly one value
    receives zero values or more than one value. For example, the behavior of each
    of the following expressions is unspecified. Some implementations raise an exception,
    while others silently suppress additional values or supply defaults for missing
    values.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个期望正好一个值的延续接收到零个值或多个值时，行为是未指定的。例如，以下每个表达式的行为都是未指定的。一些实现会引发异常，而其他实现会在沉默中抑制额外的值或为丢失的值提供默认值。
- en: '`(if (values 1 2) ''x ''y)'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '`(if (values 1 2) ''x ''y)`'
- en: (+ (values) 5)`
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ (values) 5)`'
- en: Programs that wish to force extra values to be ignored in particular contexts
    can do so easily by calling `call-with-values` explicitly. A syntactic form, which
    we might call `first`, can be defined to abstract the discarding of more than
    one value when only one is desired.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在特定上下文中强制忽略额外值的程序可以通过显式调用`call-with-values`轻松实现。可以定义一个称为`first`的语法形式来抽象出当只需要一个值时丢弃多个值。
- en: '`(define-syntax first'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax first`'
- en: (syntax-rules ()
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`(syntax-rules ()`'
- en: '[(_ expr)'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(_ expr)`'
- en: (call-with-values
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-values`'
- en: (lambda () expr)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda () expr)`'
- en: (lambda (x . y) x))]))
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (x . y) x))]))`'
- en: (if (first (values #t #f)) 'a 'b) ![<graphic>](ch2_0.gif) a`
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '`(if (first (values #t #f)) ''a ''b) ![<graphic>](ch2_0.gif) a`'
- en: Since implementations are required to raise an exception with condition type
    `&assertion` if a procedure does not accept the number of arguments passed to
    it, each of the following raises an exception.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实现必须在过程不接受传递给它的参数数量时引发带有条件类型`&assertion`的异常，因此以下每个都会引发异常。
- en: '`(call-with-values'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-values`'
- en: (lambda () (values 2 3 4))
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda () (values 2 3 4))`'
- en: (lambda (x y) x))
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (x y) x))`'
- en: (call-with-values
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-values`'
- en: (lambda () (call/cc (lambda (k) (k 0))))
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda () (call/cc (lambda (k) (k 0))))`'
- en: (lambda (x y) x))`
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (x y) x))`'
- en: Since `*producer*` is most often a `lambda` expression, it is often convenient
    to use a syntactic extension that suppresses the lambda expression in the interest
    of readability.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`*producer*`通常是一个`lambda`表达式，因此通常可以使用语法扩展来抑制lambda表达式以提高可读性。
- en: '`(define-syntax with-values'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax with-values`'
- en: (syntax-rules ()
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '`(syntax-rules ()`'
- en: '[(_ expr consumer)'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(_ expr consumer)`'
- en: (call-with-values (lambda () expr) consumer)]))
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-values (lambda () expr) consumer)]))`'
- en: (with-values (values 1 2) list) ![<graphic>](ch2_0.gif) (1 2)
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '`(with-values (values 1 2) list) ![<graphic>](ch2_0.gif) (1 2)`'
- en: (with-values (split '(1 2 3 4))
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`(with-values (split ''(1 2 3 4))'
- en: (lambda (odds evens)
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (odds evens)`'
- en: evens)) ![<graphic>](ch2_0.gif) (2 4)`
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '`evens)) ![<graphic>](ch2_0.gif) (2 4)`'
- en: If the `*consumer*` is also a `lambda` expression, the multiple-value variants
    of `let` and `let*` described in Section [4.5](binding.html#g93) are usually even
    more convenient.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*consumer*`也是一个`lambda`表达式，那么第 [4.5](binding.html#g93) 节描述的`let`和`let*`的多值变体通常更加方便。
- en: '`(let-values ([(odds evens) (split ''(1 2 3 4))])'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let-values ([(odds evens) (split ''(1 2 3 4))])`'
- en: evens) ![<graphic>](ch2_0.gif) (2 4)
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`evens) ![<graphic>](ch2_0.gif) (2 4)`'
- en: (let-values ([ls (values 'a 'b 'c)])
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let-values ([ls (values ''a ''b ''c)])`'
- en: ls) ![<graphic>](ch2_0.gif) (a b c)`
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls) ![<graphic>](ch2_0.gif) (a b c)`'
- en: 'Many standard syntactic forms and procedures pass along multiple values. Most
    of these are "automatic," in the sense that nothing special must be done by the
    implementation to make this happen. The usual expansion of `let` into a direct
    `lambda` call automatically propagates multiple values produced by the body of
    the `let`. Other operators must be coded specially to pass along multiple values.
    The `call-with-port` procedure (page [7.6](io.html#g127)), for example, calls
    its procedure argument, then closes the port argument before returning the procedure''s
    values, so it must save the values temporarily. This is easily accomplished via
    `let-values`, `apply`, and `values`:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准的语法形式和过程传递多个值。其中大多数是“自动”的，意味着实现不需要特别处理就可以使这种情况发生。`let`的通常展开成直接的`lambda`调用会自动传播`let`体产生的多个值。其他运算符必须特别编码以传递多个值。例如，`call-with-port`过程（第 [7.6](io.html#g127) 页）调用其过程参数，然后在返回过程的值之前关闭端口参数，因此它必须临时保存值。这可以通过`let-values`、`apply`和`values`轻松实现：
- en: '`(define call-with-port'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define call-with-port`'
- en: (lambda (port proc)
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (port proc)`'
- en: (let-values ([val* (proc port)])
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let-values ([val* (proc port)])`'
- en: (close-port port)
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '`(close-port port)`'
- en: (apply values val*))))`
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`(apply values val*))))`'
- en: 'If this seems like too much overhead when a single value is returned, the code
    can use `call-with-values` and `case-lambda` to handle the single-value case more
    efficiently:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当返回单个值时看起来太过头疼，代码可以使用`call-with-values`和`case-lambda`来更有效地处理单值情况：
- en: '`(define call-with-port'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define call-with-port`'
- en: (lambda (port proc)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (port proc)`'
- en: (call-with-values (lambda () (proc port))
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-values (lambda () (proc port))`'
- en: (case-lambda
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: (case-lambda
- en: '[(val) (close-port port) val]'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '[(val) (close-port port) val]'
- en: '[val* (close-port port) (apply values val*)]))))`'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '[val* (close-port port) (apply values val*)]))))`'
- en: The definitions of `values` and `call-with-values` (and concomitant redefinition
    of `call/cc`) in the library below demonstrate that the multiple-return-values
    interface could be implemented in Scheme if it were not already built in. No error
    checking can be done, however, for the case in which more than one value is returned
    to a single-value context, such as the test part of an `if` expression.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 下面库中 `values` 和 `call-with-values` 的定义（以及与之相关的 `call/cc` 的重新定义）演示了如果不是已经内置的，多返回值接口可以在
    Scheme 中实现。然而，不能对将多个值返回给单值上下文（例如 `if` 表达式的测试部分）进行任何错误检查。
- en: '`(library (mrvs)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (mrvs)'
- en: (export call-with-values values call/cc
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: (export call-with-values values call/cc
- en: (rename (call/cc call-with-current-continuation)))
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: (rename (call/cc call-with-current-continuation)))
- en: (import
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: (import
- en: (rename
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: (rename
- en: (except (rnrs) values call-with-values)
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: (except (rnrs) values call-with-values)
- en: (call/cc rnrs:call/cc)))
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc rnrs:call/cc)))
- en: (define magic (cons 'multiple 'values))
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: (define magic (cons 'multiple 'values))
- en: (define magic?
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: (define magic?
- en: (lambda (x)
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (and (pair? x) (eq? (car x) magic))))`
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: (and (pair? x) (eq? (car x) magic))))`
- en: '`  (define call/cc'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (define call/cc'
- en: (lambda (p)
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p)
- en: (rnrs:call/cc
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs:call/cc
- en: (lambda (k)
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (p (lambda args
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: (p (lambda args
- en: (k (apply values args))))))))
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: (k (apply values args))))))))
- en: (define values
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: (define values
- en: (lambda args
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda args
- en: (if (and (not (null? args)) (null? (cdr args)))
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: (if (and (not (null? args)) (null? (cdr args)))
- en: (car args)
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: (car args)
- en: (cons magic args))))
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: (cons magic args))))
- en: (define call-with-values
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: (define call-with-values
- en: (lambda (producer consumer)
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (producer consumer)
- en: (let ([x (producer)])
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (producer)])
- en: (if (magic? x)
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: (if (magic? x)
- en: (apply consumer (cdr x))
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: (apply consumer (cdr x))
- en: (consumer x))))))`
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: (consumer x))))))`
- en: Multiple values can be implemented more efficiently [[2](bibliography.html#g220)],
    but this code serves to illustrate the meanings of the operators and may be used
    to provide multiple values in older, nonstandard implementations that do not support
    them.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更有效地实现多值 [[2](bibliography.html#g220)]，但此代码用于说明操作符的含义，并且可以用于在不支持它们的旧的、非标准实现中提供多个值。
- en: Section 5.9\. Eval
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5.9\. 评估
- en: Scheme's `eval` procedure allows programmers to write programs that construct
    and evaluate other programs. This ability to do run-time *meta programming* should
    not be overused but is handy when needed.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme 的 `eval` 过程允许程序员编写构造和评估其他程序的程序。这种运行时*元编程*的能力不应该被滥用，但在需要时非常方便。
- en: '**procedure**: `(eval *obj* *environment*)`'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(eval *obj* *environment*)`'
- en: '**returns:** values of the Scheme expression represented by `*obj*` in `*environment*`'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** `*obj*` 在 `*environment*` 中表示的 Scheme 表达式的值'
- en: '**libraries:** `(rnrs eval)`'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs eval)`'
- en: If `*obj*` does not represent a syntactically valid expression, `eval` raises
    an exception with condition type `&syntax`. The environments returned by `environment`,
    `scheme-report-environment`, and `null-environment` are immutable. Thus, `eval`
    also raises an exception with condition type `&syntax` if an assignment to any
    of the variables in the environment appears within the expression.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*obj*` 不表示语法上有效的表达式，则 `eval` 引发带有条件类型 `&syntax` 的异常。由 `environment`、`scheme-report-environment`
    和 `null-environment` 返回的环境是不可变的。因此，如果表达式中出现对环境中的任何变量的赋值，则 `eval` 还将引发带有条件类型 `&syntax`
    的异常。
- en: '`(define cons ''not-cons)'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define cons ''not-cons)'
- en: (eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) ![<graphic>](ch2_0.gif) (3 . 4)
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: (eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) ![<graphic>](ch2_0.gif) (3 . 4)
- en: (define lambda 'not-lambda)
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: (define lambda 'not-lambda)
- en: (eval '(lambda (x) x) (environment '(rnrs))) ![<graphic>](ch2_0.gif) #<procedure>
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: (eval '(lambda (x) x) (environment '(rnrs))) ![<graphic>](ch2_0.gif) #<procedure>
- en: (eval '(cons 3 4) (environment)) ![<graphic>](ch2_0.gif) *exception*`
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: (eval '(cons 3 4) (environment)) ![<graphic>](ch2_0.gif) *exception*`
- en: '**procedure**: `(environment *import-spec* ...)`'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(environment *import-spec* ...)`'
- en: '**returns:** an environment'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个环境'
- en: '**libraries:** `(rnrs eval)`'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs eval)`'
- en: '`environment` returns an environment formed from the combined bindings of the
    given import specifiers. Each `*import-spec*` must be an s-expression representing
    a valid import specifier (see Chapter [10](libraries.html#g142)).'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '`environment` 返回一个由给定导入说明符的组合绑定形成的环境。每个 `*import-spec*` 必须是一个表示有效导入说明符的 S 表达式（参见第 [10](libraries.html#g142) 章）。'
- en: '`(define env (environment ''(rnrs) ''(prefix (rnrs lists) $)))'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define env (environment ''(rnrs) ''(prefix (rnrs lists) $)))'
- en: (eval '($cons* 3 4 (* 5 8)) env) ![<graphic>](ch2_0.gif) (3 4 . 40)`
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: (eval '($cons* 3 4 (* 5 8)) env) ![<graphic>](ch2_0.gif) (3 4 . 40)`
- en: '**procedure**: `(null-environment *version*)`'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(null-environment *version*)`'
- en: '**procedure**: `(scheme-report-environment *version*)`'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(scheme-report-environment *version*)`'
- en: '**returns:** an R5RS compatibility environment'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个 R5RS 兼容环境'
- en: '**libraries:** `(rnrs r5rs)`'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs r5rs)`'
- en: '`*version*` must be the exact integer `5`.'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`*version*` 必须是精确的整数 `5`。'
- en: '`null-environment` returns an environment containing bindings for the keywords
    whose meanings are defined by the Revised⁵ Report on Scheme, along with bindings
    for the auxiliary keywords `else`, `=>`, `...`, and `_`.'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '`null-environment` 返回一个包含由 Scheme 修订⁵报告定义含义的关键字绑定的环境，以及辅助关键字 `else`、`=>`、`...`
    和 `_` 的绑定。'
- en: '`scheme-report-environment` returns an environment containing the same keyword
    bindings as the environment returned by `null-environment` along with bindings
    for the variables whose meanings are defined by the Revised⁵ Report on Scheme,
    except those not defined by the Revised⁶ Report: `load`, `interaction-environment`,
    `transcript-on`, `transcript-off`, and `char-ready?`.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '`scheme-report-environment` 返回一个包含与由 `null-environment` 返回的环境相同的关键字绑定的环境，以及由
    Scheme 修订⁵报告定义含义的变量的绑定，除了修订⁶报告未定义的变量：`load`、`interaction-environment`、`transcript-on`、`transcript-off`
    和 `char-ready?`。'
- en: The bindings for each of the identifiers in the environments returned by these
    procedures are those of the corresponding Revised⁶ Report library, so this does
    not provide full backward compatibility, even if the excepted identifier bindings
    are not used.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程返回的环境中每个标识符的绑定都是对应的修订⁶报告库的绑定，因此即使未使用预期的标识符绑定，也不会提供完全的向后兼容性。
- en: '* * *'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it>
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: R. Kent Dybvig / <it>《Scheme 编程语言，第四版》</it>
- en: Copyright © 2009 [The MIT Press](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984).
    Electronically reproduced by permission.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 © 2009 [麻省理工学院出版社](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984)。经许可电子重印。
- en: Illustrations © 2009 [Jean-Pierre Hébert](http://hebert.kitp.ucsb.edu/)
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 插图 © 2009 [Jean-Pierre Hébert](http://hebert.kitp.ucsb.edu/)
- en: ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
- en: '[to order this book](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984)
    / [about this book](canned/about.html)'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '[购买此书](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984)
    / [关于此书](canned/about.html)'
- en: '[http://www.scheme.com](http://www.scheme.com/)'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.scheme.com](http://www.scheme.com/)'
