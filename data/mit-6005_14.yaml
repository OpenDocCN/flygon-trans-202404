- en: 'Reading 14: Recursion'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 14：递归
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 免受错误影响 | 易于理解 | 准备好改变 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天和未来未知时期的正确性。 | 与未来的程序员清晰沟通，包括未来的你。 | 设计以适应更改而不需要重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: 'After today’s class, you should:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的课结束后，你应该：
- en: be able to decompose a recursive problem into recursive steps and base cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将递归问题分解为递归步骤和基本情况
- en: know when and how to use helper methods in recursion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道何时以及如何在递归中使用辅助方法
- en: understand the advantages and disadvantages of recursion vs. iteration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解递归与迭代的优缺点
- en: Recursion
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: In today’s class, we’re going to talk about how to implement a method, once
    you already have a specification. We’ll focus on one particular technique, *recursion*.
    Recursion is not appropriate for every problem, but it’s an important tool in
    your software development toolbox, and one that many people scratch their heads
    over. We want you to be comfortable and competent with recursion, because you
    will encounter it over and over. (That’s a joke, but it’s also true.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的课上，我们将讨论如何在已有规范的情况下实现方法。我们将重点放在一种特定的技术上，即*递归*。递归并不适用于每个问题，但它是你软件开发工具箱中的重要工具，很多人会对此感到困惑。我们希望你对递归感到舒适并且能够胜任，因为你将会反复遇到它。（这是个笑话，但也是真的。）
- en: Since you’ve taken 6.01, recursion is not completely new to you, and you have
    seen and written recursive functions like factorial and fibonacci before. Today’s
    class will delve more deeply into recursion than you may have gone before. Comfort
    with recursive implementations will be necessary for upcoming classes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经学过6.01，递归对你来说并不完全陌生，你之前已经见过并编写过递归函数，比如阶乘和斐波那契数列。今天的课程将比你之前接触的递归更深入地探讨。对递归实现的熟悉将是接下来课程的必要条件。
- en: A recursive function is defined in terms of *base cases* and *recursive steps*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数是根据*基本情况*和*递归步骤*定义的。
- en: In a base case, we compute the result immediately given the inputs to the function
    call.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基本情况下，我们立即计算给定函数调用的结果。
- en: In a recursive step, we compute the result with the help of one or more *recursive
    calls* to this same function, but with the inputs somehow reduced in size or complexity,
    closer to a base case.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在递归步骤中，我们通过一次或多次对这个相同函数的*递归调用*来计算结果，但输入的大小或复杂性会减小，接近基本情况。
- en: 'Consider writing a function to compute factorial. We can define factorial in
    two different ways:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑编写一个计算阶乘的函数。我们可以用两种不同的方式定义阶乘：
- en: '| Product | Recurrence relation |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 乘积 | 递推关系 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ![](../Images/2e97a3ae0804063338d29a036f5f195e.jpg)  (where the empty product
    equals'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '| ![](../Images/2e97a3ae0804063338d29a036f5f195e.jpg)  (其中空积等于'
- en: multiplicative identity *1*) | ![](../Images/fe973412b7b35a397b0fc00c31f4f314.jpg)
    |
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法恒等式 *1*) | ![](../Images/fe973412b7b35a397b0fc00c31f4f314.jpg) |
- en: 'which leads to two different implementations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致两种不同的实现：
- en: '| Iterative | Recursive |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | 递归 |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In the recursive implementation on the right, the base case is *n = 0*, where
    we compute and return the result immediately: *0!* is defined to be *1*. The recursive
    step is *n > 0*, where we compute the result with the help of a recursive call
    to obtain *(n-1)!*, then complete the computation by multiplying by *n*.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的递归实现中，基本情况是 *n = 0*，其中我们立即计算并返回结果：*0!* 被定义为 *1*。递归步骤是 *n > 0*，其中我们通过递归调用来获得
    *(n-1)!* 的结果，然后通过乘以 *n* 完成计算。
- en: To visualize the execution of a recursive function, it is helpful to diagram
    the *call stack* of currently-executing functions as the computation proceeds.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化递归函数的执行，将当前执行函数的 *调用堆栈* 作为计算进行时的图表是有帮助的。
- en: 'Let’s run the recursive implementation of `factorial` in a main method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个主方法中运行 `factorial` 的递归实现：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At each step, with time moving left to right:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，时间从左到右移动：
- en: '| starts in `main` | calls `factorial(3)` | calls `factorial(2)` | calls `factorial(1)`
    | calls `factorial(0)` | returns to `factorial(1)` | returns to `factorial(2)`
    | returns to `factorial(3)` | returns to `main` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 在 `main` 中开始 | 调用 `factorial(3)` | 调用 `factorial(2)` | 调用 `factorial(1)`
    | 调用 `factorial(0)` | 返回到 `factorial(1)` | 返回到 `factorial(2)` | 返回到 `factorial(3)`
    | 返回到 `main` |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| main | factorialn = 3  mainx | factorialn = 2  factorialn = 3'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '| main | factorialn = 3  mainx | factorialn = 2  factorialn = 3'
- en: mainx | factorialn = 1  factorialn = 2
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: mainx | factorialn = 1  factorialn = 2
- en: factorialn = 3
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: factorialn = 3
- en: mainx | factorialn = 0 returns 1factorialn = 1
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: mainx | factorialn = 0 返回 1factorialn = 1
- en: factorialn = 2
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: factorialn = 2
- en: factorialn = 3
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: factorialn = 3
- en: mainx | factorialn = 1 returns 1factorialn = 2
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: mainx | factorialn = 1 返回 1factorialn = 2
- en: factorialn = 3
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: factorialn = 3
- en: mainx | factorialn = 2 returns 2factorialn = 3
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: mainx | factorialn = 2 返回 2factorialn = 3
- en: mainx | factorialn = 3 returns 6mainx | mainx = 6 |
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: mainx | factorialn = 3 返回 6mainx | mainx = 6 |
- en: In the diagram, we can see how the stack grows as `main` calls `factorial` and
    `factorial` then calls *itself*, until `factorial(0)` does not make a recursive
    call. Then the call stack unwinds, each call to `factorial` returning its answer
    to the caller, until `factorial(3)` returns to `main`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中，我们可以看到堆栈如何增长，当`main`调用`factorial`，`factorial`然后调用*自身*，直到`factorial(0)`不再进行递归调用。然后调用堆栈展开，每次调用`factorial`将其答案返回给调用者，直到`factorial(3)`返回给`main`。
- en: Here’s an [**interactive visualization of `factorial`**](http://www.pythontutor.com/visualize.html#code=public+class+Factorial+%7B%0A++++public+static+void+main(String%5B%5D+args)+%7B%0A++++++++long+x+%3D+factorial(3)%3B%0A++++%7D%0A++++public+static+long+factorial(int+n)+%7B%0A++++++++if+(n+%3D%3D+0)+%7B%0A++++++++++++return+1%3B%0A++++++++%7D+else+%7B%0A++++++++++++return+n+*+factorial(n-1)%3B%0A++++++++%7D%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=0).
    You can step through the computation to see the recursion in action. New stack
    frames grow down instead of up in this visualization.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个[**交互式可视化的`factorial`**](http://www.pythontutor.com/visualize.html#code=public+class+Factorial+%7B%0A++++public+static+void+main(String%5B%5D+args)+%7B%0A++++++++long+x+%3D+factorial(3)%3B%0A++++%7D%0A++++public+static+long+factorial(int+n)+%7B%0A++++++++if+(n+%3D%3D+0)+%7B%0A++++++++++++return+1%3B%0A++++++++%7D+else+%7B%0A++++++++++++return+n+*+factorial(n-1)%3B%0A++++++++%7D%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=0)。你可以逐步执行计算，观察递归的过程。在这个可视化中，新的堆栈帧向下增长而不是向上增长。
- en: 'You’ve probably seen factorial before, because it’s a common example for recursive
    functions. Another common example is the Fibonacci series:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以前见过阶乘，因为它是递归函数的常见示例。另一个常见示例是斐波那契数列：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Fibonacci is interesting because it has multiple base cases: n=0 and n=1\.
    You can look at an [**interactive visualization of Fibonacci**](http://www.pythontutor.com/visualize.html#code=public+class+Fibonacci+%7B%0A++++public+static+void+main(String%5B%5D+args)+%7B%0A++++++++int+x+%3D+fibonacci(3)%3B%0A++++%7D%0A++++public+static+int+fibonacci(int+n)+%7B%0A++++++++if+(n+%3D%3D+0+%7C%7C+n+%3D%3D+1)+%7B%0A++++++++++++return+1%3B%0A++++++++%7D+else+%7B%0A++++++++++++return+fibonacci(n-1)+%2B+fibonacci(n-2)%3B%0A++++++++%7D%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=0).
    Notice that where factorial’s stack steadily grows to a maximum depth and then
    shrinks back to the answer, Fibonacci’s stack grows and shrinks repeatedly over
    the course of the computation.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契很有趣，因为它有多个基本情况：n=0和n=1。你可以看看一个[**交互式斐波那契可视化**](http://www.pythontutor.com/visualize.html#code=public+class+Fibonacci+%7B%0A++++public+static+void+main(String%5B%5D+args)+%7B%0A++++++++int+x+%3D+fibonacci(3)%3B%0A++++%7D%0A++++public+static+int+fibonacci(int+n)+%7B%0A++++++++if+(n+%3D%3D+0+%7C%7C+n+%3D%3D+1)+%7B%0A++++++++++++return+1%3B%0A++++++++%7D+else+%7B%0A++++++++++++return+fibonacci(n-1)+%2B+fibonacci(n-2)%3B%0A++++++++%7D%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=0)。注意，阶乘的堆栈逐渐增长到最大深度，然后缩小到答案，而斐波那契的堆栈在计算过程中重复增长和缩小。
- en: reading exercises
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Recursive factorial
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 递归阶乘
- en: Consider this recursive implementation of the factorial function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个递归实现的阶乘函数。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For `factorial(3)`, how many times will the base case `return 1` be executed?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`factorial(3)`，基本情况`return 1`将执行多少次？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Recursive Fibonacci
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 递归斐波那契
- en: Consider this recursive implementation of the Fibonacci sequence.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个递归实现的斐波那契序列。
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For `fibonacci(3)`, how many times will the base case `return 1` be executed?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`fibonacci(3)`，基本情况`return 1`将执行多少次？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Choosing the Right Decomposition for a Problem
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的问题分解方式
- en: Finding the right way to decompose a problem, such as a method implementation,
    is important. Good decompositions are simple, short, easy to understand, safe
    from bugs, and ready for change.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 找到正确的方法来分解问题，例如方法的实现，是很重要的。良好的分解方法简单、简短、易于理解、安全免受错误影响，并且可以轻松应对变化。
- en: 'Recursion is an elegant and simple decomposition for some problems. Suppose
    we want to implement this specification:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 递归对于某些问题来说是一种优雅而简单的分解方法。假设我们想要实现这个规范：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For example, `subsequences("abc")` might return `"abc,ab,bc,ac,a,b,c,"`. Note
    the trailing comma preceding the empty subsequence, which is also a valid subsequence.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`subsequences("abc")`可能返回`"abc,ab,bc,ac,a,b,c,"`。注意空子序列之前的尾随逗号，这也是一个有效的子序列。
- en: This problem lends itself to an elegant recursive decomposition. Take the first
    letter of the word. We can form one set of subsequences that *include* that letter,
    and another set of subsequences that exclude that letter, and those two sets completely
    cover the set of possible subsequences.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题很适合进行优雅的递归分解。取词的第一个字母。我们可以形成一个包含该字母的子序列集合，以及一个不包含该字母的子序列集合，这两个集合完全覆盖了可能的子序列集合。
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: reading exercises
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: subsequences("c")(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: subsequences("c")(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: subsequences("gc")(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: subsequences("gc")(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Structure of Recursive Implementations
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归实现的结构
- en: 'A recursive implementation always has two parts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 递归实现总是有两个部分：
- en: '**base case**, which is the simplest, smallest instance of the problem, that
    can’t be decomposed any further. Base cases often correspond to emptiness – the
    empty string, the empty list, the empty set, the empty tree, zero, etc.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本情形**，即问题的最简单、最小的实例，不能进一步分解。基本情形通常对应于空集 – 空字符串、空列表、空集合、空树、零等。'
- en: '**recursive step**, which **decomposes** a larger instance of the problem into
    one or more simpler or smaller instances that can be solved by recursive calls,
    and then **recombines** the results of those subproblems to produce the solution
    to the original problem.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归步骤**，它将问题的较大实例分解为一个或多个更简单或较小的实例，可以通过递归调用解决，然后将这些子问题的结果重新组合以产生原始问题的解决方案。'
- en: It’s important for the recursive step to transform the problem instance into
    something smaller, otherwise the recursion may never end. If every recursive step
    shrinks the problem, and the base case lies at the bottom, then the recursion
    is guaranteed to be finite.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 递归步骤将问题实例转换为更小的东西非常重要，否则递归可能永远不会结束。如果每个递归步骤都将问题缩小，并且基本情形位于底部，则递归保证是有限的。
- en: A recursive implementation may have more than one base case, or more than one
    recursive step. For example, the Fibonacci function has two base cases, n=0 and
    n=1.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 递归实现可能有多个基本情形，或多个递归步骤。例如，斐波那契函数有两个基本情形，n=0 和 n=1。
- en: reading exercises
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Recursive structure
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 递归结构
- en: Recursive methods have a base case and a recursive step. What other concepts
    from computer science also have (the equivalent of) a base case and a recursive
    step?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 递归方法有一个基本情形和一个递归步骤。计算机科学中还有哪些概念具有（等价的）基本情形和递归步骤？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Helper Methods
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助方法
- en: The recursive implementation we just saw for `subsequences()` is one possible
    recursive decomposition of the problem. We took a solution to a subproblem – the
    subsequences of the remainder of the string after removing the first character
    – and used it to construct solutions to the original problem, by taking each subsequence
    and adding the first character or omitting it. This is in a sense a *direct* recursive
    implementation, where we are using the existing specification of the recursive
    method to solve the subproblems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的`subsequences()`的递归实现是问题的一种可能的递归分解。我们拿到了一个子问题的解决方案 – 去掉第一个字符后字符串的子序列
    – 并用它来构造原始问题的解决方案，方法是取每个子序列并添加第一个字符或省略它。从某种意义上说，这是一种*直接*的递归实现，我们在其中使用现有的递归方法规范来解决子问题。
- en: In some cases, it’s useful to require a stronger (or different) specification
    for the recursive steps, to make the recursive decomposition simpler or more elegant.
    In this case, what if we built up a partial subsequence using the initial letters
    of the word, and used the recursive calls to *complete* that partial subsequence
    using the remaining letters of the word? For example, suppose the original word
    is “orange”. We’ll both select “o” to be in the partial subsequence, and recursively
    extend it with all subsequences of “range”; and we’ll skip “o”, use “” as the
    partial subsequence, and again recursively extend it with all subsequences of
    “range”.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，要求递归步骤的规范更强（或不同），以使递归分解更简单或更优雅。在这种情况下，如果我们用单词的初始字母构建部分子序列，然后使用递归调用*完成*该部分子序列的剩余字母会怎么样？例如，假设原始单词是“orange”。我们将选择“o”作为部分子序列，并用“range”的所有子序列递归扩展它；我们将跳过“o”，将“”作为部分子序列，并再次用“range”的所有子序列递归扩展它。
- en: 'Using this approach, our code now looks much simpler:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们的代码现在看起来简单得多：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `subsequencesAfter` method is called a **helper method**. It satisfies
    a different spec from the original `subsequences`, because it has a new parameter
    `partialSubsequence`. This parameter fills a similar role that a local variable
    would in an iterative implementation. It holds temporary state during the evolution
    of the computation. The recursive calls steadily extend this partial subsequence,
    selecting or ignoring each letter in the word, until finally reaching the end
    of the word (the base case), at which point the partial subsequence is returned
    as the only result. Then the recursion backtracks and fills in other possible
    subsequences.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`subsequencesAfter`方法被称为**辅助方法**。它满足与原始的`subsequences`不同的规范，因为它有一个新的参数`partialSubsequence`。这个参数填充了在迭代实现中本地变量的类似角色。它在计算演变过程中保持临时状态。递归调用逐步扩展这个部分子序列，选择或忽略单词中的每个字母，直到最终达到单词的末尾（基本情况），此时部分子序列作为唯一的结果返回。然后递归回溯并填充其他可能的子序列。
- en: 'To finish the implementation, we need to implement the original `subsequences`
    spec, which gets the ball rolling by calling the helper method with an initial
    value for the partial subsequence parameter:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成实现，我们需要实现原始的`subsequences`规范，通过用一个部分子序列参数的初始值调用辅助方法来启动该过程：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Don’t expose the helper method to your clients.** Your decision to decompose
    the recursion this way instead of another way is entirely implementation-specific.
    In particular, if you discover that you need temporary variables like `partialSubsequence`
    in your recursion, don’t change the original spec of your method, and don’t force
    your clients to correctly initialize those parameters. That exposes your implementation
    to the client and reduces your ability to change it in the future. Use a private
    helper function for the recursion, and have your public method call it with the
    correct initializations, as shown above.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要向客户暴露辅助方法。** 你选择这种递归分解方式而不是其他方式完全是特定于实现的。特别是，如果你发现在递归中需要像`partialSubsequence`这样的临时变量，不要更改方法的原始规范，并且不要强迫客户正确初始化这些参数。这会向客户暴露你的实现，并降低你将来更改它的能力。对于递归，使用一个私有的辅助函数，并让你的公共方法以正确的初始化调用它，如上所示。'
- en: reading exercises
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Unhelpful 1
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 无用 1
- en: 'Louis Reasoner doesn’t want to use a helper method, so he tries to implement
    `subsequences()` by storing `partialSubsequence` as a static variable instead
    of a parameter. Here is his implementation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·理性人不想使用辅助方法，因此他尝试通过将`partialSubsequence`存储为静态变量而不是参数来实现`subsequences()`。这是他的实现：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Suppose we call `subsequencesLouis("c")` followed by `subsequencesLouis("a")`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们调用`subsequencesLouis("c")`，然后是`subsequencesLouis("a")`。
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Unhelpful 2
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无用 2
- en: 'Louis fixes that problem by making partialSubsequence public:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯通过将partialSubsequence公开来解决了这个问题：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Alyssa P. Hacker throws up her hands when she sees what Louis did. Which of
    these statements are true about his code?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当Alyssa P. Hacker看到路易斯做的事情时，她举起了手。关于他的代码，以下哪些陈述是正确的？
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Unhelpful 3
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无用 3
- en: 'Louis gives in to Alyssa’s strenuous arguments, hides his static variable again,
    and takes care of initializing it properly before starting the recursion:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Louis屈服于Alyssa的激烈争论，再次隐藏他的静态变量，并在开始递归之前正确初始化它：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unfortunately a static variable is simply a bad idea in recursion. Louis’s
    solution is still broken. To illustrate, let’s trace through the call `subsequences("xy")`.
    You can step through an [**interactive visualization of this version**](http://www.pythontutor.com/java.html#code=public+class+Subsequences+%7B%0A++++%0A++++public+static+String+subsequences%28String+word%29+%7B%0A++++++++partialSubsequence+%3D+%22%22%3B%0A++++++++return+subsequencesLouis%28word%29%3B%0A++++%7D%0A++++%0A++++private+static+String+partialSubsequence+%3D+%22%22%3B%0A++++%0A++++public+static+String+subsequencesLouis%28String+word%29+%7B%0A++++++++if+%28word.isEmpty%28%29%29+%7B%0A++++++++++++//+base+case%0A++++++++++++return+partialSubsequence%3B%0A++++++++%7D+else+%7B%0A++++++++++++//+recursive+step%0A++++++++++++String+withoutFirstLetter+%3D+subsequencesLouis%28word.substring%281%29%29%3B%0A++++++++++++partialSubsequence+%2B%3D+word.charAt%280%29%3B%0A++++++++++++String+withFirstLetter+%3D+subsequencesLouis%28word.substring%281%29%29%3B%0A++++++++++++return+withoutFirstLetter+%2B+%22,%22+%2B+withFirstLetter%3B%0A++++++++%7D%0A++++%7D%0A++++%0A++++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++++String+result+%3D+subsequences%28%22xy%22%29%3B%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=4)
    to see what happens. It will produce these recursive calls to `subsequencesLouis()`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在递归中使用静态变量是一个坏主意。Louis的解决方案仍然存在问题。为了说明问题，让我们跟踪调用`subsequences("xy")`。您可以通过[**此版本的交互式可视化**](http://www.pythontutor.com/java.html#code=public+class+Subsequences+%7B%0A++++%0A++++public+static+String+subsequences%28String+word%29+%7B%0A++++++++partialSubsequence+%3D+%22%22%3B%0A++++++++return+subsequencesLouis%28word%29%3B%0A++++%7D%0A++++%0A++++private+static+String+partialSubsequence+%3D+%22%22%3B%0A++++%0A++++public+static+String+subsequencesLouis%28String+word%29+%7B%0A++++++++if+%28word.isEmpty%28%29%29+%7B%0A++++++++++++//+base+case%0A++++++++++++return+partialSubsequence%3B%0A++++++++%7D+else+%7B%0A++++++++++++//+recursive+step%0A++++++++++++String+withoutFirstLetter+%3D+subsequencesLouis%28word.substring%281%29%29%3B%0A++++++++++++partialSubsequence+%2B%3D+word.charAt%280%29%3B%0A++++++++++++String+withFirstLetter+%3D+subsequencesLouis%28word.substring%281%29%29%3B%0A++++++++++++return+withoutFirstLetter+%2B+%22,%22+%2B+withFirstLetter%3B%0A++++++++%7D%0A++++%7D%0A++++%0A++++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++++String+result+%3D+subsequences%28%22xy%22%29%3B%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=4)来查看发生了什么。它将产生这些对`subsequencesLouis()`的递归调用：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When each of these calls **starts**, what is the value of the static variable
    partialSubsequence?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些调用**开始**时，静态变量partialSubsequence的值是多少？
- en: '`subsequencesLouis("xy")`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subsequencesLouis("xy")`'
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>空字符串</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(缺失答案)
- en: '`subsequencesLouis("y")`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subsequencesLouis("y")`'
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>空字符串</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(缺失答案)
- en: '`subsequencesLouis("")`'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subsequencesLouis("")`'
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>空字符串</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(缺失答案)
- en: '`subsequencesLouis("")`'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subsequencesLouis("")`'
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>空字符串</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(缺失答案)
- en: '`subsequencesLouis("y")`'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subsequencesLouis("y")`'
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>空字符串</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(缺失答案)
- en: '`subsequencesLouis("")`'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subsequencesLouis("")`'
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>空字符串</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(缺失答案)
- en: '`subsequencesLouis("")`'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subsequencesLouis("")`'
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>xyy</option>,<option>yx</option>,<option>yxy</option></select>(missing
    answer)
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>空字符串</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>xyy</option>,<option>yx</option>,<option>yxy</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Choosing the Right Recursive Subproblem
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的递归子问题
- en: 'Let’s look at another example. Suppose we want to convert an integer to a string
    representation with a given base, following this spec:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。假设我们想要将整数转换为给定基数的字符串表示，遵循这个规范：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For example, `stringValue(16, 10)` should return `"16"`, and `stringValue(16,
    2)` should return `"10000"`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`stringValue(16, 10)` 应该返回 `"16"`，而 `stringValue(16, 2)` 应该返回 `"10000"`。
- en: 'Let’s develop a recursive implementation of this method. One recursive step
    here is straightforward: we can handle negative integers simply by recursively
    calling for the representation of the corresponding positive integer:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发这种方法的递归实现。这里一个递归步骤很简单：我们可以通过简单地递归调用相应正整数的表示来处理负整数：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This shows that the recursive subproblem can be smaller or simpler in more subtle
    ways than just the value of a numeric parameter or the size of a string or list
    parameter. We have still effectively reduced the problem by reducing it to positive
    integers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明递归子问题可以通过比数值参数的值或字符串或列表参数的大小更微妙的方式变得更小或更简单。我们仍然通过将问题简化为正整数有效地减小了问题。
- en: 'The next question is, given that we have a positive n, say n=829 in base 10,
    how should we decompose it into a recursive subproblem? Thinking about the number
    as we would write it down on paper, we could either start with 8 (the leftmost
    or highest-order digit), or 9 (the rightmost, lower-order digit). Starting at
    the left end seems natural, because that’s the direction we write, but it’s harder
    in this case, because we would need to first find the number of digits in the
    number to figure out how to extract the leftmost digit. Instead, a better way
    to decompose n is to take its remainder modulo base (which gives the *rightmost*
    digit) and also divide by base (which gives the subproblem, the remaining higher-order
    digits):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是，假设我们有一个正整数 n，比如 n=829，以十进制表示，我们应该如何将其分解为一个递归子问题？考虑到我们将数字写在纸上的方式，我们可以从
    8 开始（最左边或最高位数），或者从 9 开始（最右边，较低位数）。从左边开始似乎很自然，因为这是我们写的方向，但在这种情况下会更困难，因为我们需要首先找出数字中的位数，以确定如何提取最左边的数字。相反，将
    n 分解的更好方法是取余数模基数（给出*最右边*的数字）并且除以基数（给出子问题，剩余的更高位数）：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Think about several ways to break down the problem, and try to write the
    recursive steps.** You want to find the one that produces the simplest, most natural
    recursive step.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑几种分解问题的方式，并尝试编写递归步骤。** 你希望找到产生最简单、最自然的递归步骤。'
- en: It remains to figure out what the base case is, and include an if statement
    that distinguishes the base case from this recursive step.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要弄清楚基本情况是什么，并包含一个 if 语句，用于区分基本情况和这个递归步骤。
- en: reading exercises
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Implementing stringValue
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 stringValue
- en: 'Here is the recursive implementation of `stringValue()` with the recursive
    steps brought together but with the base case still missing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `stringValue()` 的递归实现，递归步骤已汇集在一起，但基本情况仍然缺失：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Which of the following can be substituted for the `BASE CONDITION` and `BASE
    CASE` to make the code correct?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个可以替换 `BASE CONDITION` 和 `BASE CASE` 以使代码正确？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Calling stringValue
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 stringValue
- en: Assuming the code is completed with one of the base cases identified in the
    previous problem, what does `stringValue(170, 16)` do?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设代码已经完成，并且在前一个问题中已确定了一个基本情况，那么 `stringValue(170, 16)` 做什么？
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Recursive Problems vs. Recursive Data
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归问题 vs. 递归数据
- en: The examples we’ve seen so far have been cases where the problem structure lends
    itself naturally to a recursive definition. Factorial is easy to define in terms
    of smaller subproblems. Having a *recursive problem* like this is one cue that
    you should pull a recursive solution out of your toolbox.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们见过的例子都是问题结构自然地支持递归定义的情况。阶乘很容易根据更小的子问题来定义。像这样有一个*递归问题*是你应该从你的工具箱中拿出递归解决方案的一个提示。
- en: 'Another cue is when the data you are operating on is inherently recursive in
    structure. We’ll see many examples of recursive data a few classes from now, but
    for now let’s look at the recursive data found in every laptop computer: its filesystem.
    A filesystem consists of named *files*. Some files are *folders*, which can contain
    other files. So a filesystem is recursive: folders contain other folders which
    contain other folders, until finally at the bottom of the recursion are plain
    (non-folder) files.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提示是当你操作的数据在结构上本质上是递归的时候。在几节课后我们会看到许多递归数据的例子，但现在让我们看一看每台笔记本电脑中都有的递归数据：它的文件系统。文件系统由命名的*文件*组成。一些文件是*文件夹*，它们可以包含其他文件。因此文件系统是递归的：文件夹包含其他文件夹，这些文件夹又包含其他文件夹，直到递归的最底层是普通（非文件夹）文件。
- en: The Java library represents the file system using [`java.io.File`](http://docs.oracle.com/javase/8/docs/api/index.html?java/io/File.html).
    This is a recursive data type, in the sense that `f.getParentFile()` returns the
    parent folder of a file `f`, which is a `File` object as well, and `f.listFiles()`
    returns the files contained by `f`, which is an array of other `File` objects.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Java 库使用 [`java.io.File`](http://docs.oracle.com/javase/8/docs/api/index.html?java/io/File.html)
    表示文件系统。这是一个递归数据类型，因为 `f.getParentFile()` 返回文件 `f` 的父文件夹，它也是一个 `File` 对象，`f.listFiles()`
    返回 `f` 包含的文件，这是其他 `File` 对象的数组。
- en: 'For recursive data, it’s natural to write recursive implementations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递归数据，写递归实现是很自然的：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Recent versions of Java have added a new API, [`java.nio.Files`](http://docs.oracle.com/javase/8/docs/api/index.html?java/nio/file/Files.html)
    and [`java.nio.Path`](http://docs.oracle.com/javase/8/docs/api/index.html?java/nio/file/Path.html),
    which offer a cleaner separation between the filesystem and the pathnames used
    to name files in it. But the data structure is still fundamentally recursive.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的最新版本增加了一个新的 API，[`java.nio.Files`](http://docs.oracle.com/javase/8/docs/api/index.html?java/nio/file/Files.html)
    和 [`java.nio.Path`](http://docs.oracle.com/javase/8/docs/api/index.html?java/nio/file/Path.html)，提供了文件系统和用于命名其中文件的路径之间的更清晰的分离。但数据结构仍然基本上是递归的。
- en: Reentrant Code
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重入代码
- en: Recursion – a method calling itself – is a special case of a general phenomenon
    in programming called **reentrancy**. Reentrant code can be safely re-entered,
    meaning that it can be called again *even while a call to it is underway.* Reentrant
    code keeps its state entirely in parameters and local variables, and doesn’t use
    static variables or global variables, and doesn’t share aliases to mutable objects
    with other parts of the program, or other calls to itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 递归——一个方法调用自身——是编程中一个称为**重入性**的一般现象的特殊情况。可重入代码可以安全地重新进入，这意味着它可以在调用正在进行时再次被调用。可重入代码完全通过参数和局部变量保持其状态，并且不使用静态变量或全局变量，并且不与程序的其他部分或其他对自身的调用共享可变对象的别名。
- en: Direct recursion is one way that reentrancy can happen. We’ve seen many examples
    of that during this reading. The `factorial()` method is designed so that `factorial(n-1)`
    can be called even though `factorial(n)` hasn’t yet finished working.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 直接递归是重入性发生的一种方式。在本文中我们已经看到了许多这样的例子。`factorial()` 方法被设计成 `factorial(n-1)` 可以被调用，即使
    `factorial(n)` 还没有完成工作。
- en: Mutual recursion between two or more functions is another way this can happen
    – A calls B, which calls A again. Direct mutual recursion is virtually always
    intentional and designed by the programmer. But unexpected mutual recursion can
    lead to bugs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或多个函数之间的相互递归是另一种可能发生的情况——A 调用 B，B 再次调用 A。直接的相互递归几乎总是有意的，并由程序员设计。但意外的相互递归可能导致错误。
- en: When we talk about concurrency later in the course, reentrancy will come up
    again, since in a concurrent program, a method may be called at the same time
    by different parts of the program that are running concurrently.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在课程的后面讨论并发时，重入性会再次出现，因为在并发程序中，一个方法可能同时被程序的不同部分调用。
- en: It’s good to design your code to be reentrant as much as possible. Reentrant
    code is safer from bugs and can be used in more situations, like concurrency,
    callbacks, or mutual recursion.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能设计您的代码为可重入是很好的。可重入代码免于错误，并且可以在更多情况下使用，如并发、回调或相互递归。
- en: When to Use Recursion Rather Than Iteration
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用递归而不是迭代。
- en: 'We’ve seen two common reasons for using recursion:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到使用递归的两个常见原因：
- en: The problem is naturally recursive (e.g. Fibonacci)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题自然是递归的（例如 Fibonacci）。
- en: The data is naturally recursive (e.g. filesystem)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据自然是递归的（例如文件系统）。
- en: Another reason to use recursion is to take more advantage of immutability. In
    an ideal recursive implementation, all variables are final, all data is immutable,
    and the recursive methods are all pure functions in the sense that they do not
    mutate anything. The behavior of a method can be understood simply as a relationship
    between its parameters and its return value, with no side effects on any other
    part of the program. This kind of paradigm is called *functional programming*,
    and it is far easier to reason about than *imperative programming* with loops
    and variables.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归的另一个原因是更多地利用不可变性。在理想的递归实现中，所有变量都是最终的，所有数据都是不可变的，并且递归方法都是纯函数，意味着它们不会改变任何东西。方法的行为可以简单地理解为其参数与其返回值之间的关系，不会对程序的任何其他部分产生副作用。这种范式称为*函数式编程*，比使用循环和变量的*命令式编程*要容易得多。
- en: In iterative implementations, by contrast, you inevitably have non-final variables
    or mutable objects that are modified during the course of the iteration. Reasoning
    about the program then requires thinking about snapshots of the program state
    at various points in time, rather than thinking about pure input/output behavior.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代实现中，相反地，您不可避免地会有在迭代过程中修改的非最终变量或可变对象。因此，对程序的推理需要考虑在不同时间点的程序状态的快照，而不是考虑纯输入/输出行为。
- en: One downside of recursion is that it may take more space than an iterative solution.
    Building up a stack of recursive calls consumes memory temporarily, and the stack
    is limited in size, which may become a limit on the size of the problem that your
    recursive implementation can solve.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的一个缺点是它可能比迭代解决方案占用更多空间。建立递归调用堆栈的堆栈会暂时消耗内存，并且堆栈大小是有限的，这可能成为您的递归实现能够解决的问题大小的限制。
- en: Common Mistakes in Recursive Implementations
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归实现中的常见错误。
- en: 'Here are two common ways that a recursive implementation can go wrong:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是递归实现可能出错的两种常见方式： '
- en: The base case is missing entirely, or the problem needs more than one base case
    but not all the base cases are covered.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况完全缺失，或者问题需要多个基本情况，但并非所有基本情况都被覆盖。
- en: The recursive step doesn’t reduce to a smaller subproblem, so the recursion
    doesn’t converge.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归步骤不会缩减为更小的子问题，因此递归不会收敛。
- en: Look for these when you’re debugging.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进行调试时，请查找这些问题。
- en: On the bright side, what would be an infinite loop in an iterative implementation
    usually becomes a `StackOverflowError` in a recursive implementation. A buggy
    recursive program fails faster.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从好的一面来看，迭代实现中会成为无限循环的东西通常会在递归实现中成为`StackOverflowError`。有错误的递归程序失败得更快。
- en: reading exercises
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习。
- en: subsequences("123456")
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`subsequences("123456")`。'
- en: 'Recall the implementation of `subsequences()` from the start of this reading:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下从本阅读开始的`subsequences()`的实现：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For `subsequences("123456")`, how deep does its recursive call stack get? How
    many recursive calls to `subsequences()` can be active at the same time?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`subsequences("123456")`，其递归调用堆栈有多深？同时可以有多少个递归调用`subsequences()`处于活动状态？
- en: (missing answer)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）
- en: (missing explanation)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We saw these ideas:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了这些概念：
- en: recursive problems and recursive data
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归问题和递归数据。
- en: comparing alternative decompositions of a recursive problem
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较递归问题的替代分解。
- en: using helper methods to strengthen a recursive step
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用辅助方法来加强递归步骤。
- en: recursion vs. iteration
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归与迭代
- en: 'The topics of today’s reading connect to our three key properties of good software
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 今天阅读的主题与我们关于良好软件的三个关键属性连接如下：
- en: '**Safe from bugs.** Recursive code is simpler and often uses immutable variables
    and immutable objects.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免于错误**。递归代码更简单，通常使用不可变变量和不可变对象。'
- en: '**Easy to understand.** Recursive implementations for naturally recursive problems
    and recursive data are often shorter and easier to understand than iterative solutions.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解。** 对于自然递归问题和递归数据，递归实现通常比迭代解决方案更短、更易于理解。'
- en: '**Ready for change.** Recursive code is also naturally reentrant, which makes
    it safer from bugs and ready to use in more situations.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备好变革。** 递归代码也自然是可重入的，这使得它更安全免受错误影响，并且可以在更多情况下使用。'
