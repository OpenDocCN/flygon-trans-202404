- en: Module 0x4 | Web Kung Fu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块 0x4 | Web Kung Fu
- en: Chapter 0x4 | Web Kung Fu
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 0x4 章 | Web Kung Fu
- en: Send Get request
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送 Get 请求
- en: Using Net::HTTP
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Net::HTTP
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Simple Shortened URL extractor
  id: totrans-5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单的缩短 URL 提取器
- en: '**urlextractor.rb**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**urlextractor.rb**'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run it
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ok, what if I gave you this shortened url(`http://short-url.link/f2a`)? try
    the above script and tell me what's going-on
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果我给你这个缩短的 URL（`http://short-url.link/f2a`）呢？尝试上面的脚本并告诉我发生了什么
- en: Using Open-uri
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Open-uri
- en: Here another way to do the same thing
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一种做同样事情的方法
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Send HTTP Post request with custom headers
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送带有自定义标头的 HTTP Post 请求
- en: Here the post body from a file
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从文件中获取的 post body
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: More control on Post variables
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 Post 变量有更多控制
- en: Let's to take the following form as a simple post form to mimic in our script
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下表单作为一个简单的 post 表单在我们的脚本中模拟
- en: '| ![PostForm](webfu__post_form1.png) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| ![PostForm](webfu__post_form1.png) |'
- en: '| --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Figure 1.** Simple Post form |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **图1.** 简单的 Post 表单 |'
- en: 'Post form code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Post 表单代码：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to send a Post request as the form figure 1 would do with control on
    each value and variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要发送一个 Post 请求，就像表单图1中的控制每个值和变量一样。
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can use `body` method instead of `set_form_data` to avoid auto-encoding
    for any reason
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`body`方法代替`set_form_data`以避免自动编码的任何原因
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dealing with Cookies
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 Cookies
- en: Some times you need to deal with some actions after authentication. Ideally,
    it's all about cookies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要在认证后处理一些操作。理想情况下，这都与 cookies 有关。
- en: 'Notes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: To Read cookies you need to get **set-cookie** from **response**
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要读取 cookies，你需要从**响应**中获取**set-cookie**
- en: To Set cookies you need to set **Cookie** to **request**
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置 cookies，你需要将**Cookie**设置到**请求**中
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: HTTP authentication (Basic, Digest, NTLM)
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 认证（基本、摘要、NTLM）
- en: Basic authentication
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本认证
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Digest authentication
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要认证
- en: Install net-http-digest_auth gem
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 net-http-digest_auth gem
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here is an [example](https://gist.github.com/KINGSABRI/a1df06eb48cbc52660577df6c7947ed5)
    to build it without external gem
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个[示例](https://gist.github.com/KINGSABRI/a1df06eb48cbc52660577df6c7947ed5)来构建它而不使用外部
    gem
- en: NTLM authentication
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NTLM 认证
- en: Install ntlm gem
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 ntlm gem
- en: '[PRE12]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note: ntlm gem works with http, imap, smtp protocols. [Read more](https://github.com/macks/ruby-ntlm).'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：ntlm gem 适用于 http、imap、smtp 协议。[阅读更多](https://github.com/macks/ruby-ntlm)。
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: CGI
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CGI
- en: Get info - from XSS/HTMLi exploitation
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取信息 - 来自 XSS/HTMLi 攻击
- en: When you exploit XSS or HTML injection you may need to receive the grepped data
    from exploited user to your external server. Here a simple example of CGI script
    take sent get request from fake login from that asks users to enter log-in with
    username and password then will store the data to `hacked_login.txt` text file
    and fix its permissions to assure that nobody can access that file from public.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你利用 XSS 或 HTML 注入时，可能需要从被攻击用户那里接收到 grepped 数据传输到你的外部服务器。这里有一个简单的 CGI 脚本示例，接收从伪登录发送的
    get 请求，要求用户输入用户名和密码，然后将数据存储到`hacked_login.txt`文本文件中，并修复其权限以确保没有人可以从公共访问该文件。
- en: Add the following to `/etc/apache2/sites-enabled/[SITE]` then restart the service
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`/etc/apache2/sites-enabled/[SITE]`，然后重新启动服务
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, put the script in /var/www/[CGI FOLDER]. You can use it now.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将脚本放在`/var/www/[CGI FOLDER]`中。现在你可以使用它了。
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Web Shell^([1](#fn_1)) - command execution via GET
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web Shell^([1](#fn_1)) - 通过 GET 执行命令
- en: if you have a server that supports ruby CGI, you can use the following as backdoor
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个支持 Ruby CGI 的服务器，你可以使用以下内容作为后门
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now you can simply use a web browser, Netcat or WebShellConsole^([1](#fn_1))
    to execute your commands. ex. **Browser**
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以简单地使用 web 浏览器、Netcat 或 WebShellConsole^([1](#fn_1))来执行你的命令。例如**浏览器**
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Netcat**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**Netcat**'
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**WebShellConsole**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebShellConsole**'
- en: run wsc
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 wsc
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Add Shell URL
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 Shell URL
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now prompt your commands
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在提示你的命令
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Mechanize
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mechanize
- en: Since we're talking about dealing with web in ruby, we can't forget **Mechanize**
    gem, the most known library for dealing wit web.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在谈论在 Ruby 中处理 web，我们不能忘记**Mechanize** gem，这是最知名的用于处理 web 的库。
- en: '**The Official description says**, the Mechanize library is used for automating
    interaction with websites. Mechanize automatically stores and sends cookies, follows
    redirects, and can follow links and submit forms. Form fields can be populated
    and submitted. Mechanize also keeps track of the sites that you have visited as
    a history.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**官方描述说**，Mechanize 库用于自动化与网站的交互。Mechanize 自动存储和发送 cookies，跟随重定向，并可以跟随链接和提交表单。表单字段可以填充并提交。Mechanize
    还会跟踪你访问过的站点作为历史记录。'
- en: More about Mechanize gem
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Mechanize gem
- en: '[Getting Started With Mechanize](http://docs.seattlerb.org/mechanize/GUIDE_rdoc.html)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[开始使用 Mechanize](http://docs.seattlerb.org/mechanize/GUIDE_rdoc.html)'
- en: '[Mechanize examples](http://docs.seattlerb.org/mechanize/EXAMPLES_rdoc.html)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Mechanize 示例](http://docs.seattlerb.org/mechanize/EXAMPLES_rdoc.html)'
- en: '[RailsCasts | Mechanize tutorial](http://railscasts.com/episodes/191-mechanize)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RailsCasts | Mechanize 教程](http://railscasts.com/episodes/191-mechanize)'
- en: Since you know the hard way, you'll find Mechanize as simple as mouse clicks!
    give it a try!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道了艰难的方式，你会发现 Mechanize 就像鼠标点击一样简单！试试吧！
- en: HTTP.rb
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP.rb
- en: HTTP (The Gem! a.k.a. http.rb) is an easy-to-use client library for making requests
    from Ruby. It uses a simple method chaining system for building requests, similar
    to Python's Requests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP（The Gem！即 http.rb）是一个用于从 Ruby 发出请求的易于使用的客户端库。它使用了一种简单的方法链接系统来构建请求，类似于 Python
    的 Requests。
- en: Under the hood, http.rb uses http_parser.rb, a fast HTTP parsing native extension
    based on the Node.js parser and a Java port thereof. This library isn't just yet
    another wrapper around Net::HTTP. It implements the HTTP protocol natively and
    outsources the parsing to native extensions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，http.rb 使用 http_parser.rb，这是一个基于 Node.js 解析器和其 Java 版本的快速 HTTP 解析本地扩展。这个库不仅仅是另一个围绕
    Net::HTTP 的包装器。它本地实现了 HTTP 协议并将解析外包给本地扩展。
- en: More about http.rb gem
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 http.rb gem 的更多信息
- en: '[The Official repository](https://github.com/httprb/http)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[官方仓库](https://github.com/httprb/http)'
- en: '[The official wiki](https://github.com/httprb/http/wiki)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[官方 wiki](https://github.com/httprb/http/wiki)'
- en: '* * *'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹. [WebShellConsole](https://github.com/KINGSABRI/WebShellConsole) is simple
    interactive console, interacts with simple web shells using HTTP GET rather than
    using browser. wsc will work with any shell use GET method. It takes care of all
    URL encoding too. [↩](#reffn_1 "Jump back to footnote [1] in the text.")
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹. [WebShellConsole](https://github.com/KINGSABRI/WebShellConsole) 是一个简单的交互式控制台，使用
    HTTP GET 与简单的 Web shell 进行交互，而不是使用浏览器。wsc 将使用任何使用 GET 方法的 shell。它还负责所有 URL 编码。[↩](#reffn_1
    "跳回到文本中的脚注 [1]")
- en: '[CGI Examples](http://www.java2s.com/Code/Ruby/CGI/CatalogCGI.htm)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CGI 示例](http://www.java2s.com/Code/Ruby/CGI/CatalogCGI.htm)'
- en: SQL Injection Scanner
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 注入扫描器
- en: SQL Injection Scanner
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 注入扫描器
- en: Basic SQLi script as command line browser
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的 SQLi 脚本作为命令行浏览器
- en: The is a very basic script take your given payload and send it to the vulnerable
    parameter and returns the response back to you. I'll use ([http://testphp.vulnweb.com/](http://testphp.vulnweb.com/))
    as it's legal to test.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的脚本，获取你提供的负载并将其发送到易受攻击的参数，然后将响应返回给你。我将使用([http://testphp.vulnweb.com/](http://testphp.vulnweb.com/))，因为它是合法的测试。
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I've commented the line `puts response.body.gsub(/<.*?>/, '').strip` and added
    a custom regular expression to fix our target outputs.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我已经注释掉了 `puts response.body.gsub(/<.*?>/, '').strip` 这一行，并添加了一个自定义的正则表达式来修复我们的目标输出。
- en: Let's to test it in action
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下它的功能
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here a very basic and simple SQL-injection solid scanner, develop it as far
    as you can!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本和简单的 SQL 注入实体扫描器，尽可能地完善它！
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Try it on this URL ([http://testasp.vulnweb.com/showforum.asp?id=0](http://testasp.vulnweb.com/showforum.asp?id=0))
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 URL 上尝试一下 ([http://testasp.vulnweb.com/showforum.asp?id=0](http://testasp.vulnweb.com/showforum.asp?id=0))
- en: Results
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Boolean-bases SQLi Exploit Script
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于布尔值的 SQLi Exploit 脚本
- en: Here is a Boolean-based SQLi exploit for [sqli-labs](https://github.com/Audi-1/sqli-labs)
    vulnerable application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对 [sqli-labs](https://github.com/Audi-1/sqli-labs) 可能存在漏洞的应用程序的基于布尔值的 SQLi
    攻击。
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Time-bases SQLi Exploit Script
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于时间的 SQLi Exploit 脚本
- en: A Time-based SQLi exploit for [sqli-labs](https://github.com/Audi-1/sqli-labs)
    vulnerable application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个针对 [sqli-labs](https://github.com/Audi-1/sqli-labs) 可能存在漏洞的应用程序的基于时间的 SQLi
    攻击。
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Databases
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: Databases
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: Dealing with database is a required knowledge in web testing and here we will
    go though most known databases and how to deal with it in ruby.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据库是 Web 测试中必需的知识，在这里我们将介绍最常见的数据库以及如何在 Ruby 中处理它。
- en: SQLite
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite
- en: Install sqlite3 gem
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 sqlite3 gem
- en: '[PRE28]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You've have to have sqlite3 development libraries installed on your system
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你必须在系统上安装 sqlite3 开发库
- en: '[PRE29]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Basic operations
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本操作
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Active Record
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Active Record
- en: Install ActiveRecord gem
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 ActiveRecord gem
- en: '[PRE31]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: MySQL database
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL 数据库
- en: Install MySQL adapter gem
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 MySQL 适配器 gem
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Login to mysql console and create database *rubyfu_db* and table *attackers*
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到 mysql 控制台并创建数据库 *rubyfu_db* 和表 *attackers*
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The outputs look like following
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let's to connect to *rubyfu_db* database
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接到 *rubyfu_db* 数据库
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using the ActiveRecord library, available as the activerecord gem.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ActiveRecord 库，可作为 activerecord gem 使用。
- en: Using the ActiveRecord adapter namely *mysql*
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ActiveRecord 适配器，即 *mysql*
- en: Establishing a connection to the database *rubyfu_db*
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立到数据库 *rubyfu_db* 的连接
- en: Creating a class called *Attackers* following the conventions mentioned above
    (attacker)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 *Attackers* 的类，遵循上述约定（attacker）
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You will observe that ActiveRecord examines the database tables themselves
    to find out which columns are available. This is how we were able to use accessor
    methods for participant.name without explicitly defining them: we defined them
    in the database, and ActiveRecord picked them up.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到ActiveRecord会检查数据库表本身，以查找可用的列。这就是我们能够使用participant.name的访问器方法而无需显式定义它们的原因：我们在数据库中定义了它们，ActiveRecord就会识别它们。
- en: You can find the item
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到该项
- en: by id
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按id
- en: '[PRE37]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: by name
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按名称
- en: '[PRE38]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Result
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE39]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: or you can work it as object
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以将其作为对象处理
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you want to delete an item from the database, you can use the destroy (Deletes
    the record in the database) method of ActiveRecord::Base:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从数据库中删除一个项目，可以使用ActiveRecord::Base的destroy（删除数据库中的记录）方法：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So to write a complete script,
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要编写一个完整��脚本，
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Oracle database
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle数据库
- en: Prerequisites
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'in order to make [ruby-oci8](http://www.rubydoc.info/gems/ruby-oci8/file/docs/install-full-client.md)
    -which is the main dependency for oracle driver- works you''ve to do some extra
    steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使[ruby-oci8](http://www.rubydoc.info/gems/ruby-oci8/file/docs/install-full-client.md)
    -这是Oracle驱动程序的主要依赖项-正常工作，您需要执行一些额外的步骤：
- en: Download links for [Linux](http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html)
    | [Windows](http://www.oracle.com/technetwork/topics/winsoft-085727.html) | [Mac](http://www.oracle.com/technetwork/topics/intel-macsoft-096467.html)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Linux](http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html)
    | [Windows](http://www.oracle.com/technetwork/topics/winsoft-085727.html) | [Mac](http://www.oracle.com/technetwork/topics/intel-macsoft-096467.html)的下载链接'
- en: instantclient-basic-[OS].[Arch]-[VERSION].zip
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: instantclient-basic-[OS].[Arch]-[VERSION].zip
- en: instantclient-sqlplus-[OS].[Arch]-[VERSION].zip
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: instantclient-sqlplus-[OS].[Arch]-[VERSION].zip
- en: instantclient-sdk-[OS].[Arch]-[VERSION].zip
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: instantclient-sdk-[OS].[Arch]-[VERSION].zip
- en: Unzip downloaded files
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压下载的文件
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Create system directories as root / sudo
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以root / sudo身份创建系统目录
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The file structure should be
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构应该是
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Move files
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动文件
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Setup environment
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'Append oracle environment variables in to `~/.bashrc` Then add the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将Oracle环境变量追加到`~/.bashrc`中，然后添加以下内容：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then run:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Install Oracle adapter gem
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Oracle适配器gem
- en: '[PRE49]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now let's to connect
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: MSSQL database
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MSSQL数据库
- en: Install MSSQL adapter gem
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装MSSQL适配器gem
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '* * *'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Extending Burp Suite
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Burp Suite
- en: Extending Burp Suite
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Burp Suite
- en: Setting up the Ruby environment for Burp Extensions
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Burp扩展设置Ruby环境
- en: Download a stable version of JRuby from [JRuby Downloads](http://jruby.org/download)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[JRuby Downloads](http://jruby.org/download)下载一个稳定版本的JRuby
- en: Select the jar for Linux (JRuby x.x.x Complete .jar) or Executable for Windows.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Linux（JRuby x.x.x Complete .jar）的jar包或Windows的可执行文件。
- en: Import the environment from **Burp Suite** >> **Extender** >> **Options** >>
    **Ruby Environment**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Burp Suite** >> **Extender** >> **Options** >> **Ruby Environment**导入环境。
- en: '![](webfu__burp_setenv1.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](webfu__burp_setenv1.png)'
- en: Import the Burp Suite Extender Core API `IBurpExtender`
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Burp Suite Extender核心API `IBurpExtender`
- en: '**alert.rb**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**alert.rb**'
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Load the plugin alert.rb
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 加载插件alert.rb
- en: '![](webfu__burp-ext1.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](webfu__burp-ext1.png)'
- en: Check Alerts tab
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 检查警报选项卡
- en: '![](webfu__burp-ext2.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](webfu__burp-ext2.png)'
- en: Burp Suite Extension in Ruby template initiative
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ruby模板倡议中的Burp Suite扩展
- en: As Rubyfu project keeps groing, we've decided to develope our vesion of make
    a solid place for Ruby in the information security community. We've deceided to
    build a repository that makes building a Burp Suite extension in Ruby is very
    easy and understandable. [**Repository link**](https://github.com/KINGSABRI/BurpSuite_Extension_Ruby_Template)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Rubyfu项目的不断发展，我们决定开发我们自己的版本，为Ruby在信息安全社区中建立一个坚实的地位。我们决定建立一个仓库，使得用Ruby构建Burp
    Suite扩展变得非常简单和易懂。[**仓库链接**](https://github.com/KINGSABRI/BurpSuite_Extension_Ruby_Template)
- en: Buby
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buby
- en: Buby is a mashup of JRuby with the popular commercial web security testing tool
    Burp Suite from PortSwigger. Burp is driven from and tied to JRuby with a Java
    extension using the BurpExtender API. This extension aims to add Ruby scriptability
    to Burp Suite with an interface comparable to the Burp's pure Java extension interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Buby是JRuby与流行的商业网络安全测试工具Burp Suite的混合。Burp是通过使用BurpExtender API的Java扩展从JRuby派生并与之绑定的。该扩展旨在向Burp
    Suite添加Ruby脚本功能，其接口可与Burp的纯Java扩展接口相媲美。
- en: '**Resources**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源**'
- en: Burp Suite Extender API Documentations [ [link](https://portswigger.net/burp/extender/api/)
    ]
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Burp Suite Extender API文档 [ [链接](https://portswigger.net/burp/extender/api/)
    ]
- en: Step by step Ruby-based Burp Extension for JSON Encryption/Decryption [ [Part
    1](https://www.trustwave.com/Resources/SpiderLabs-Blog/JSON-Crypto-Helper-a-Ruby-based-Burp-Extension-for-JSON-Encryption/Decryption---Part-I/)
    | [Part 2](http://blog.spiderlabs.com/2015/01/json-crypto-helper-a-ruby-based-burp-extension-for-json-encryptiondecryption-part-ii.html)
    ]
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步指导使用 Ruby 编写的 Burp 扩展，用于 JSON 加密/解密 [ [Part 1](https://www.trustwave.com/Resources/SpiderLabs-Blog/JSON-Crypto-Helper-a-Ruby-based-Burp-Extension-for-JSON-Encryption/Decryption---Part-I/)
    | [Part 2](http://blog.spiderlabs.com/2015/01/json-crypto-helper-a-ruby-based-burp-extension-for-json-encryptiondecryption-part-ii.html)
    ]
- en: Buby [ [website](http://human.versus.computer/buby/) | [rdoc](http://human.versus.computer/buby/rdoc/index.html)
    ]
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buby [ [website](http://human.versus.computer/buby/) | [rdoc](http://human.versus.computer/buby/rdoc/index.html)
    ]
- en: Extensions written in Ruby [ [WhatThWAF](https://github.com/null--/what-the-waf)
    ]
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 Ruby 编写的扩展 [ [WhatThWAF](https://github.com/null--/what-the-waf) ]
- en: Burp suite Scripting with Buby [ [Link](http://www.gotohack.org/2011/05/cktricky-appsec-buby-script-basics-part.html)
    ]
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Buby 编写的 Burp suite 脚本 [ [Link](http://www.gotohack.org/2011/05/cktricky-appsec-buby-script-basics-part.html)
    ]
- en: Browser Manipulation
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器操作
- en: Browser Manipulation
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器操作
- en: As a hacker, sometimes you need to automate your client side tests (ex. XSS)
    and reduce the false positives that happen specially in XSS tests. The traditional
    automation depends on finding the sent payload been received in the response,
    but it doesn't mean the vulnerability get really exploited so you have to do it
    manually again and again.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为黑客，有时您需要自动化客户端测试（例如 XSS）并减少特别是在 XSS 测试中发生的误报。传统的自动化依赖于在响应中找到发送的有效负载，但这并不意味着漏洞真正被利用了，因此您必须一遍又一遍地手动执行。
- en: Here we'll learn how to make ruby controls our browser in order to **emulate**
    the same attacks from browser and get the real results.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将学习如何让 Ruby 控制我们的浏览器，以**模拟**浏览器中的相同攻击并获得真实结果。
- en: The most known APIs for this task are ***Selenium*** and ***Watir*** which support
    most know web browsers currently exist.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这项任务最常用的 API 是 ***Selenium*** 和 ***Watir***，它们支持目前已知的大多数网络浏览器。
- en: Selenium Webdriver
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium Webdriver
- en: '[**Selenium**](https://github.com/seleniumhq/selenium) is an umbrella project
    encapsulating a variety of tools and libraries enabling web browser automation.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Selenium**](https://github.com/seleniumhq/selenium) 是一个总项目，封装了各种工具和库，实现了
    Web 浏览器自动化。'
- en: install selenium gem
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 selenium gem
- en: '[PRE53]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: GET Request
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GET 请求
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the actual keys to send depend on your OS, for example, Mac uses `COMMAND
    + t`, instead of `CONTROL + t`.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，发送的实际键取决于您的操作系统，例如，Mac 使用`COMMAND + t`，而不是`CONTROL + t`。
- en: POST Request
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST 请求
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let's test the page against XSS vulnerability. First I'll list what kind of
    action we need from browser
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试页面是否存在 XSS 漏洞。首先，我将列出我们需要浏览器执行的操作。
- en: Open a browser window (Firefox)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个浏览器窗口（Firefox）
- en: Navigate to a URL (altoromutual.com)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到一个 URL（altoromutual.com）
- en: Perform some operations (Send an XSS payload)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一些操作（发送 XSS 负载）
- en: Check if the payload is working(Popping-up) or it's a false positive
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查有效负载是否起作用（弹出）或者是误报
- en: Print the succeed payloads on terminal
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上打印成功的有效负载
- en: '**selenium-xss.rb**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**selenium-xss.rb**'
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Result
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Watir Webdriver
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Watir Webdriver
- en: '[**Watir**](http://watirwebdriver.com/) is abbreviation for (Web Application
    Testing in Ruby). I believe that Watir is more elegant than Selenium but I like
    to know many ways to do the same thing, just in case.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Watir**](http://watirwebdriver.com/) 是 (Web Application Testing in Ruby)
    的缩写。我认为 Watir 比 Selenium 更优雅，但我喜欢知道完成同样任务的多种方式，以防万一。'
- en: install watir gem
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 watir gem
- en: '[PRE58]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: GET Request
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GET 请求
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Sometime you''ll need to send XSS GET request from URL like `http://app/search?q=<script>alert</script>`.
    You''ll face a known error `Selenium::WebDriver::Error::UnhandledAlertError: Unexpected
    modal dialog` if the alert box popped up but it you do refresh page for the sent
    payload it''ll work so the fix for this issue is the following.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '有时，您需要从 URL 发送 XSS GET 请求，例如`http://app/search?q=<script>alert</script>`。如果弹出了警报框，您将面临已知错误`Selenium::WebDriver::Error::UnhandledAlertError:
    Unexpected modal dialog`，但如果刷新页面以发送有效负载，它将起作用，因此解决此问题的方法如下。'
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: POST Request
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST 请求
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since Waiter is integrated with Selenium, you can use both to achieve one goal
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Waiter 与 Selenium 集成，您可以同时使用两者来实现一个目标
- en: For Some reason in some log-in cases, you may need to add a delay time between
    entering username and password then submit.
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于某些情况下的某些登录情况，您可能需要在输入用户名和密码后添加延迟时间，然后再提交。
- en: Selenium, Watir Arbitrary POST request
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium、Watir 任意 POST 请求
- en: Here another scenario I've faced, I was against POST request without submit
    button, in another word, the test was against intercepted request generated from
    jQuery function, in my case was a drop menu. So The work round wad quite simple,
    Just create an HTML file contains POST form with the original parameters plus
    a **Submit button**(***just like creating CSRF exploit from a POST form***) then
    call that html file to the browser and deal with it as normal form. Let's to see
    an example here.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我遇到的另一个场景是，我反对没有提交按钮的 POST 请求，换句话说，测试是针对从 jQuery 函数生成的拦截请求，我的情况是一个下拉菜单。因此，解决方法非常简单，只需创建一个包含原始参数加上**提交按钮**（***就像从
    POST 表单创建 CSRF 利用一样***) 的 HTML 文件，然后将该 html 文件调用到浏览器中，并像处理正常表单一样处理它。让我们看一个例子。
- en: '**POST request**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**POST 请求**'
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**example.html**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**example.html**'
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**exploit.rb**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**exploit.rb**'
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Dealing with tabs
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理标签页
- en: One of scenarios I've faced is to exploit XSS a user profile fields and check
    the result in another page which present the public user's profile. Instead of
    revisiting the URLs again and again I open new tab and refresh the public user's
    profile page then return back to send the exploit and so on.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的一个场景是利用 XSS 用户配置字段，并在另一页中检查结果，该页面显示公共用户的配置文件。我不断地重新访问 URL，而是打开新标签页并刷新公共用户的配置文件页面，然后返回发送利用，依此类推。
- en: '**xss_tab.rb**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**xss_tab.rb**'
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '* * *'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Selenium official documentations](http://docs.seleniumhq.org/docs/)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Selenium 官方文档](http://docs.seleniumhq.org/docs/)'
- en: '[Selenium Cheat Sheet](https://gist.github.com/kenrett/7553278)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Selenium Cheat Sheet](https://gist.github.com/kenrett/7553278)'
- en: '[Selenium webdriver vs Watir-webdriver in Ruby](http://watirmelon.com/2011/05/05/selenium-webdriver-vs-watir-webdriver-in-ruby/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Selenium webdriver 与 Ruby 中的 Watir-webdriver](http://watirmelon.com/2011/05/05/selenium-webdriver-vs-watir-webdriver-in-ruby/)'
- en: '[Writing automate test scripts in Ruby](https://www.browserstack.com/automate/ruby)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 Ruby 中编写自动化测试脚本](https://www.browserstack.com/automate/ruby)'
- en: '[Selenium WebDriver and Ruby](https://swdandruby.wordpress.com/)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Selenium WebDriver 和 Ruby](https://swdandruby.wordpress.com/)'
- en: '[The Selenium Guidebook - Commercial](https://seleniumguidebook.com/)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Selenium 指南 - 商业版](https://seleniumguidebook.com/)'
- en: '[Watir WebDriver](http://watirwebdriver.com/)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Watir WebDriver](http://watirwebdriver.com/)'
- en: '[Watir Cheat Sheet](https://github.com/watir/watir/wiki/Cheat-Sheet)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Watir Cheat Sheet](https://github.com/watir/watir/wiki/Cheat-Sheet)'
- en: Web Services and APIs
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 服务和 API
- en: Web Services and APIs
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 服务和 API
- en: Web Services and APIs are getting popular and used in many known websites we
    use in daily basis. For that matter, I'd like to put some general definitions
    that may make it clear to deal with
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Web Services 和 API 在我们日常使用的许多知名网站中变得越来越受欢迎和使用。为此，我想提供一些通用的定义，可能会使处理变得清晰。
- en: Technical Definitions
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术定义
- en: API
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API
- en: An application programming interface (API) is a set of routines, data structures,
    object classes and/or protocols provided by libraries and/or operating system
    services in order to support the building of applications.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）是由库和/或操作系统服务提供的一组例程、数据结构、对象类和/或协议，以支持应用程序的构建。
- en: Web Service
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web 服务
- en: A Web service (also Web Service) is defined by the W3C as "a software system
    designed to support interoperable machine-to-machine interaction over a network"
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务（也称为 Web 服务）由 W3C 定义为“设计用于支持网络上的可互操作的机器对机器交互的软件系统”。
- en: Difference Between API and Web Service
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 和 Web 服务之间的区别
- en: All Web services are APIs but all APIs are not Web services.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 Web 服务都是 API，但并非所有 API 都是 Web 服务。
- en: Web services might not perform all the operations that an API would perform.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web 服务可能无法执行 API 执行的所有操作。
- en: 'A Web service uses only three styles of use: SOAP, REST and XML-RPC for communication
    whereas API may use any style for communication.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web 服务仅使用三种使用方式：SOAP、REST 和 XML-RPC 进行通信，而 API 可以使用任何样式进行通信。
- en: A Web service always needs a network for its operation whereas an API doesn't
    need a network for its operation.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web 服务始终需要网络进行操作，而 API 不需要网络进行操作。
- en: An API facilitates interfacing directly with an application whereas a Web service
    interacts with two machines over a network.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 有助于直接与应用程序进行接口，而 Web 服务通过网络与两台机器进行交互。
- en: Web service is like advanced URLs and API is Programmed Interface.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web 服务就像高级的 URL，而 API 是编程接口。
- en: API contains classes and Interfaces just like a program.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 包含类和接口，就像一个程序一样。
- en: A web service is a form of API (Application Programming Interface).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web 服务是 API（应用程序编程接口）的一种形式。
- en: An API is used by a computer programmer to establish a link between software
    applications. This interface can take several forms, a web service is just one
    of these.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API被计算机程序员用来建立软件应用程序之间的链接。这种接口可以采用多种形式，Web服务只是其中之一。
- en: There are several types of web service. SOAP (Simple Object Access Protocol)
    is one of the most common. The API takes the form of a service description (WSDL)
    which is used to automatically generate the program code which makes the connection.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种类型的Web服务。SOAP（简单对象访问协议）是最常见的之一。API采用服务描述（WSDL）的形式，用于自动生成建立连接的程序代码。
- en: '* * *'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Difference Between API And Web Service](http://microsoft-techies.blogspot.com/2014/03/difference-between-api-and-web-service.html)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[API和Web服务之间的区别](http://microsoft-techies.blogspot.com/2014/03/difference-between-api-and-web-service.html)'
- en: '[Application programming interface](https://en.wikipedia.org/wiki/Application_programming_interface)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[应用程序编程接口](https://en.wikipedia.org/wiki/Application_programming_interface)'
- en: '[Web service](https://en.wikipedia.org/wiki/Web_service)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Web服务](https://en.wikipedia.org/wiki/Web_service)'
- en: Interacting with Web Services
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Web服务交互
- en: Interacting with Web Services
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Web服务交互
- en: SOAP - WSDL
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SOAP - WSDL
- en: Generally speaking, dealing with SOAP means dealing with XML messages and a
    WSDL file (also XML) that describes how to use a given SOAP API. Ruby has really
    elegant way to do so and let's to get our hand dirty with an exploit
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，处理SOAP意味着处理XML消息和描述如何使用给定SOAP API的WSDL文件（也是XML）。Ruby有一种非常优雅的方式来做到这一点，让我们用一个漏洞来动手实践一下
- en: Install wasabi, sabvon & httpclient gems
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装wasabi、sabvon和httpclient宝石
- en: '[PRE66]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Enumeration
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 枚举
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Results
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE68]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Interaction
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 互动
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Results
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE70]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Hacking via SOAP vulnerabilities
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过SOAP漏洞进行黑客攻击
- en: This is a working exploit for Vtiger CRM SOAP from auth-bypass to shell upload
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对Vtiger CRM SOAP的工作利用，从绕过认证到上传shell
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: More about [Savon](http://savonrb.com/)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于[Savon](http://savonrb.com/)的内容
- en: '* * *'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Interacting with APIs
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与API交互
- en: Interacting with APIs
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与API交互
- en: APIs have a variety of structures to interact with their peers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: API有各种结构与其同行进行交互。
- en: '**StackExchange API**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**StackExchange API**'
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**IPify API**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPify API**'
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: WordPress API
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress API
- en: WordPress API
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress API
- en: Ruby has a [standard library](http://ruby-doc.org/stdlib-2.2.3/libdoc/xmlrpc/rdoc/XMLRPC/Client.html)
    called `xmlrpc` which takes care of all xmlrpc stuff, you can even create an XML-RPC
    server using it. Let's to get some real word example
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby有一个名为`xmlrpc`的[标准库](http://ruby-doc.org/stdlib-2.2.3/libdoc/xmlrpc/rdoc/XMLRPC/Client.html)，它负责处理所有xmlrpc的事情，甚至可以使用它创建一个XML-RPC服务器。让我们来看一个真实的例子
- en: Looking for really known application that support XML-RPC then of course WordPress
    was the first attendee.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找真正知名支持XML-RPC的应用程序，当然WordPress是第一个参与者。
- en: So what do we want to do?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们想要做什么呢？
- en: Say hello to WordPress
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与WordPress打个招呼
- en: List all available methods
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有可用方法
- en: List all available users
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有可用用户
- en: List all available post
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有可用帖子
- en: Create a new post!
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新帖子！
- en: Retrieve our created post
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索我们创建的帖子
- en: List all comments on our created post
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出我们创建的帖子上的所有评论
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Results
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE75]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: and here is the new post ![](webfu__xmlrpc1.png)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的帖子！![](webfu__xmlrpc1.png)
- en: 'Source: [HOW TO PROGRAMATICALLY CONTROL WORDPRESS WITH RUBY USING XML-RPC](http://notes.jerzygangi.com/how-to-programatically-control-wordpress-with-ruby-using-xml-rpc/)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[如何使用Ruby通过XML-RPC编程控制WordPress](http://notes.jerzygangi.com/how-to-programatically-control-wordpress-with-ruby-using-xml-rpc/)
- en: More about [WordPress XML-RPC](http://notes.jerzygangi.com/how-to-programatically-control-wordpress-with-ruby-using-xml-rpc/)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于[WordPress XML-RPC](http://notes.jerzygangi.com/how-to-programatically-control-wordpress-with-ruby-using-xml-rpc/)的内容
- en: '* * *'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Twitter API
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter API
- en: Twitter API
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter API
- en: Dealing with Twitter's API is really useful for information gathering, taxonomy
    and social engineering. However, you have to have some keys and tokens in-order
    to interact with Twitter's APIs. To do so, please refer to the official [Twitter
    development page](https://dev.twitter.com/oauth/overview).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Twitter的API对于信息收集、分类和社会工程非常有用。然而，您必须拥有一些密钥和令牌才能与Twitter的API进行交互。要做到这一点，请参考官方的[Twitter开发页面](https://dev.twitter.com/oauth/overview)。
- en: Install Twitter API gem
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Twitter API宝石
- en: '[PRE76]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Basic Usage
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本用法
- en: '**rubyfu-tweet.rb**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**rubyfu-tweet.rb**'
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](webfu__twitterAPI1.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](webfu__twitterAPI1.png)'
- en: '**Your turn**, tweet to @Rubyfu using above example. Tweet your code and output
    to **@Rubyfu**.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**，使用上面的例子向@Rubyfu发推文。将您的代码和输出推文给**@Rubyfu**。'
- en: Building Stolen Credentials notification bot
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建被盗凭证通知机器人
- en: We're exploiting an XSS/HTML injection vulnerability and tricking users to enter
    there Username and Password. The idea is, We'll make a [CGI script](http://rubyfu.net/content/module_0x4__web_kung_fu/index.html#cgi)
    that takes that stolen credentials then tweet these credentials to us as notification
    or log system
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在利用 XSS/HTML 注入漏洞，并诱使用户输入他们的用户名和密码。想法是，我们将制作一个[CGI 脚本](http://rubyfu.net/content/module_0x4__web_kung_fu/index.html#cgi)，获取被盗的凭据，然后将这些凭据作为通知或日志系统推文给我们
- en: '[PRE78]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Telegram API
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Telegram API
- en: Telegram API
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Telegram API
- en: As we know that Telegram is a messaging app identifies users by their mobile
    number. Fortunately, Telegram has its own API -*Ruby has a wrapper gem for* [*Telegram's
    Bot API*](https://core.telegram.org/bots/api) called [*telegram-bot-ruby*](https://github.com/atipugin/telegram-bot-ruby)
    - which allows you to Integrate with other services, create custom tools, build
    single- and multiplayer games, build social services, do virtually anything else;
    Do you smell anything evil here?
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 Telegram 是一款通过用户的手机号识别用户的消息应用。幸运的是，Telegram 有自己的 API -*Ruby 有一个包装 gem 用于*
    [*Telegram 的 Bot API*](https://core.telegram.org/bots/api) 叫做 [*telegram-bot-ruby*](https://github.com/atipugin/telegram-bot-ruby)
    - 允许你与其他服务集成，创建自定义工具，构建单人和多人游戏，构建社交服务，几乎可以做任何事情；你闻到了一些邪恶的味道吗？
- en: Install telegram-bot gem
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 telegram-bot gem
- en: '[PRE79]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Basic usage
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本用法
- en: As many APIs, you have to get a [token](https://core.telegram.org/bots#botfather)
    to deal with your bot. Here a basic usage
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多 API 一样，你必须获取一个[token](https://core.telegram.org/bots#botfather)来处理你的机器人。这里是一个基本用法
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Once your run it, go to your telegram and find the bot and start chat with `/start`,
    try to send `/rubyfu`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，打开你的 Telegram 并找到机器人，开始聊天输入 `/start`，尝试发送 `/rubyfu`。
- en: '![](rubyfubot.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](rubyfubot.png)'
- en: Inline bots
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联机器人
- en: If you got that evil smile from above example, you may thinking about interacting
    with your bots [inline](https://core.telegram.org/bots/inline) to call/@mention
    your bots and request more action from the bot(s).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从上面的例子中得到了那种邪恶的微笑，你可能会考虑与你的机器人[内联](https://core.telegram.org/bots/inline)互动，调用/@提及你的机器人，并要求机器人执行更多操作。
- en: '[PRE81]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '**Resources**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源**'
- en: A good topic about Quickly Create a Telegram Bot in Ruby can be found [here](http://www.sitepoint.com/quickly-create-a-telegram-bot-in-ruby/).
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关在 Ruby 中快速创建 Telegram 机器人的好主题可以在[这里](http://www.sitepoint.com/quickly-create-a-telegram-bot-in-ruby/)找到。
- en: There are more usage and documentation for the [gem](https://github.com/atipugin/telegram-bot-ruby)
    and the [API](https://core.telegram.org/bots), and you can show us your evil code,
    and you can pull it in Rubyfu!
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关[gem](https://github.com/atipugin/telegram-bot-ruby)和[API](https://core.telegram.org/bots)的更多用法和文档，你可以展示你的邪恶代码，也可以在
    Rubyfu 中拉取它！
- en: '[Bot Revolution. Know your API or die hard.](http://web.neurotiko.com/bots/2015/08/03/bots-know-your-api/)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[机器人革命。了解你的 API 或死得很惨。](http://web.neurotiko.com/bots/2015/08/03/bots-know-your-api/)'
- en: Ruby 2 JavaScript
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 2 JavaScript
- en: Ruby 2 JavaScript
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 2 JavaScript
- en: CoffeeScript
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CoffeeScript
- en: '[CoffeeScript](http://coffeescript.org) is a programming language that transcompiles
    to JavaScript. It adds syntactic sugar inspired by Ruby, Python and Haskell in
    an effort to enhance JavaScript''s brevity and readability.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[CoffeeScript](http://coffeescript.org) 是一种编程语言，可以转译为 JavaScript。它添加了受 Ruby、Python
    和 Haskell 启发的语法糖，旨在增强 JavaScript 的简洁性和可读性。'
- en: Quick CoffeeScript Review
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速 CoffeeScript 回顾
- en: Here a quick how to if CoffeeScript in general
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于如何使用 CoffeeScript 的快速指南
- en: Install CoffeScript lib
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 CoffeScript lib
- en: '[PRE82]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: For live conversion
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于实时转换
- en: '[PRE83]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Ruby CoffeScript gem
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ruby CoffeScript gem
- en: '**Ruby** CoffeeScript gem is a bridge to the official CoffeeScript compiler.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ruby** CoffeeScript gem 是官方 CoffeeScript 编译器的桥梁。'
- en: Install CoffeeScript gem
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 CoffeeScript gem
- en: '[PRE84]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Convert CoffeeScript file to JavaScript
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 CoffeeScript 文件转换为 JavaScript
- en: '[PRE85]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Run it
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它
- en: '[PRE86]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Opal
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Opal
- en: Opal is a Ruby to JavaScript source-to-source compiler. It also has an implementation
    of the Ruby corelib.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Opal 是一个将 Ruby 编译为 JavaScript 的源到源编译器。它还有一个 Ruby 核心库的实现。
- en: Install Opal gem
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Opal gem
- en: '[PRE87]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '* * *'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Web Server and Proxy
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 服务器和代理
- en: Ruby as Web Server and Proxy
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 作为 Web 服务器和代理
- en: Web Server
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 服务器
- en: You can run Ruby as web server for any folder/file on any unused port
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何未使用的端口上为任何文件夹/文件运行 Ruby 作为 Web 服务器
- en: '[PRE88]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: or
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE89]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**HTTPS server**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTPS 服务器**'
- en: '[PRE90]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Advanced HTTP Server**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级 HTTP 服务器**'
- en: During working on [CVE-2016-4971(Wget)](https://github.com/KINGSABRI/CVE-in-Ruby/tree/master/CVE-2016-4971)
    exploit, more advanced & custom behavior needed. Here is a web server with a fake
    login form that saves the collected credentials to a text file. This comes in
    handy when you don't need to make customizations on apache config or you don't
    have enough privileges to do so. It require no knowledge for web frameworks like
    Rails or Senatra.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 [CVE-2016-4971(Wget)](https://github.com/KINGSABRI/CVE-in-Ruby/tree/master/CVE-2016-4971)
    漏洞利用时，需要更高级和自定义的行为。这里有一个带有虚假登录表单的 Web 服务器，它会将收集到的凭据保存到一个文本文件中。当您不需要对 apache 配置进行自定义或者您没有足够的权限这样做时，这将非常方便。它不需要了解像
    Rails 或 Senatra 这样的 Web 框架。
- en: '[PRE91]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Run it
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它
- en: '[PRE92]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You'll find credentials have been saved in 'credentials.txt'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现凭据已保存在 'credentials.txt' 中
- en: '**References**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考资料**'
- en: '[http://ruby-doc.org/stdlib-2.0.0/libdoc/webrick/rdoc/WEBrick.html](http://ruby-doc.org/stdlib-2.0.0/libdoc/webrick/rdoc/WEBrick.html)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://ruby-doc.org/stdlib-2.0.0/libdoc/webrick/rdoc/WEBrick.html](http://ruby-doc.org/stdlib-2.0.0/libdoc/webrick/rdoc/WEBrick.html)'
- en: '[https://www.igvita.com/2007/02/13/building-dynamic-webrick-servers-in-ruby/](https://www.igvita.com/2007/02/13/building-dynamic-webrick-servers-in-ruby/)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.igvita.com/2007/02/13/building-dynamic-webrick-servers-in-ruby/](https://www.igvita.com/2007/02/13/building-dynamic-webrick-servers-in-ruby/)'
- en: '[https://rubyit.wordpress.com/2011/07/25/basic-rest-server-with-webrick/](https://rubyit.wordpress.com/2011/07/25/basic-rest-server-with-webrick/)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://rubyit.wordpress.com/2011/07/25/basic-rest-server-with-webrick/](https://rubyit.wordpress.com/2011/07/25/basic-rest-server-with-webrick/)'
- en: '[https://gist.github.com/Integralist/2862917](https://gist.github.com/Integralist/2862917)'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/Integralist/2862917](https://gist.github.com/Integralist/2862917)'
- en: Web Proxy
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 代理
- en: Transparent Web Proxy
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明的 Web 代理
- en: '[PRE93]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Transparent Web Proxy with Authentication
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带身份验证的透明 Web 代理
- en: Well, it was great to know that building a proxy server is that easy. Now we
    need to Force authentication to connect to the proxy server
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，知道构建代理服务器是如此简单真是太棒了。现在我们需要强制进行身份验证以连接到代理服务器
- en: 'To enable authentication for requests in WEBrick you will need a user database
    and an authenticator. To start, here''s a htpasswd database for use with a DigestAuth
    authenticator:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 WEBrick 中为请求启用身份验证，您将需要一个用户数据库和一个验证器。首先，这里是一个用于 DigestAuth 验证器的 htpasswd
    数据库：
- en: The `:Realm` is used to provide different access to different groups across
    several resources on a server. Typically you'll need only one realm for a server.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`:Realm` 用于为服务器上的多个资源提供不同组的不同访问权限。通常，您只需要为服务器设置一个域。'
- en: '[PRE94]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If you do it right, you'll get an authentication pop-up in your browser just
    like below.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您操作正确，您将在浏览器中看到一个身份验证弹出窗口，就像下面这样。
- en: '![](webfu__proxy2.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](webfu__proxy2.png)'
