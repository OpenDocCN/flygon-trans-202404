- en: Virtual Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: Lecture Notes for CS 140
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: CS 140课程讲义
- en: Spring 2014
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年春季
- en: John Ousterhout
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰·奥斯特豪特
- en: 'Readings for this topic from *Operating Systems: Principles and Practice*:
    Chapter 8.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本主题的阅读材料来自*操作系统：原理与实践*：第8章。
- en: How can one memory be shared among several concurrent processes?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使一个内存被多个并发进程共享？
- en: 'Single-tasking (no sharing):'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单任务（无共享）：
- en: Highest memory holds OS.
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高内存保存操作系统。
- en: Process is allocated memory starting at 0, up to the OS area.
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程从0开始分配内存，直到操作系统区域。
- en: 'Examples: early batch monitors where only one job ran at a time. It could corrupt
    the OS, which would be rebooted by an operator. Some early personal computers
    were similar.'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：早期批处理监视器只能一次运行一个作业。它可能会破坏操作系统，操作员会重新启动操作系统。一些早期个人计算机类似。
- en: 'Goals for sharing memory:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存的目标：
- en: 'Multitasking: allow multiple processes to be memory-resident at once.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多任务：允许多个进程同时驻留在内存中。
- en: 'Transparency: no process should need to be aware of the fact that memory is
    shared. Each must run regardless of the number and/or locations of processes.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明性：没有进程应该意识到内存是共享的事实。每个进程必须运行，无论进程的数量和/或位置如何。
- en: 'Isolation: processes mustn''t be able to corrupt each other.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离：进程不能相互破坏。
- en: Efficiency (both of CPU and memory) shouldn't be degraded badly by sharing.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率（CPU和内存）不应该因共享而严重降低。
- en: 'Load-time relocation:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载时重定位：
- en: Highest memory holds OS.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高内存保存操作系统。
- en: First process loaded at 0; others fill empty spaces.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个进程加载在0处；其他进程填充空白空间。
- en: 'When a process is loaded, relocate it so that it can run in its allocated memory
    area, similar to linking:'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当加载一个进程时，重新定位它，使其能够在其分配的内存区域中运行，类似于链接：
- en: Linker outputs relocation records in executable files
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接器在可执行文件中输出重定位记录
- en: 'Similar to information in object files: indicates which locations contain memory
    addresses'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于目标文件中的信息：指示哪些位置包含内存地址
- en: OS modifies addresses when it loads process (add base address)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统在加载进程时会修改地址（添加基地址）
- en: What are the problems with this approach?
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法存在哪些问题？
- en: Dynamic Memory Relocation
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内存重定位
- en: Instead of relocating a program statically when it is loaded, add hardware (*memory
    management unit*) that changes addresses dynamically *during every memory reference*.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加载程序时静态重定位程序时，添加硬件（*内存管理单元*）在每次内存引用时��态更改地址。
- en: Each address generated by a process (called a *virtual address*) is translated
    in hardware to a *physical* address. This happens during every memory reference.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程生成的地址（称为*虚拟地址*）在硬件中被转换为*物理*地址。这在每次内存引用时发生。
- en: 'Results in two views of memory, called *address spaces*:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致内存的两种视图，称为*地址空间*：
- en: Virtual address space is what the program sees
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟地址空间是程序看到的内容
- en: Physical address space is the actual allocation of memory
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理地址空间是内存的实际分配
- en: Base and Bound Relocation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基址和绑定重定位
- en: 'Two hardware registers:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个硬件寄存器：
- en: 'Base: physical address corresponding to virtual address 0.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基址：对应于虚拟地址0的物理地址。
- en: 'Bound: highest allowable virtual address.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定：最高允许的虚拟地址。
- en: On each memory reference, virtual address is compared to the bound register,
    then added to the base register to produce a physical address. A bound violation
    results in a trap to the operating system.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次内存引用时，虚拟地址与绑定寄存器进行比较，然后加上基址寄存器以生成物理地址。绑定违规会导致操作系统陷入陷阱。
- en: Each process appears to have a completely private memory whose size is determined
    by the bound register.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程似乎有一个完全私有的内存，其大小由绑定寄存器确定。
- en: Processes are isolated from each other and OS.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程彼此之间和操作系统之间隔离。
- en: No address relocation is necessary when a process is loaded.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载进程时不需要进行地址重定位。
- en: Each process has its own base and bound values, which are saved in the process
    control block.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程都有自己的基址和绑定值，这些值保存在进程控制块中。
- en: OS runs with relocation turned off, so it can access all of memory (a bit in
    the processor status word controls relocation).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统在关闭重定位的情况下运行，因此可以访问所有内存（处理器状态字中的一个位控制重定位）。
- en: Must prevent users from turning off relocation or modifying the base and bound
    registers (another bit in PSW for user/kernel mode).
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须防止用户关闭重定位或修改基址和绑定寄存器（PSW中的另一个位用于用户/内核模式）。
- en: 'Problem: how does OS regain control once it has given it up?'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题：操作系统一旦放弃控制权，如何重新获得控制权？
- en: 'Base & bound is cheap (only 2 hardware registers) and fast: the add and compare
    can be done in parallel.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基址和绑定是便宜的（只有2个硬件寄存器）和快速的：加法和比较可以并行进行。
- en: What's wrong with base and bound relocation?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基址和绑定重定位有什么问题？
- en: Multiple segments
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个段
- en: Each process is split among several variable-size areas of memory, called segments.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程分布在几个可变大小的内存区域中，称为段。
- en: E.g. one segment for code, one segment for heap, one segment for stack.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一个段用于代码，一个段用于堆，一个段用于栈。
- en: '*Segment table* holds the bases and bounds for all the segments of a process,
    plus protection bit for each segment: read-write versus read-only.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*段表*保存进程的所有段的基址和限制，以及每个段的保护位：读写对比只读。'
- en: Memory mapping procedure consists of table lookup + add + compare.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存映射过程包括表查找+添加+比较。
- en: 'Each memory reference must indicate a *segment number* and *offset*:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个内存引用必须指示一个*段号*和*偏移量*：
- en: Top bits of address select segment, low bits the offset.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址的高位选择段，低位选择偏移量。
- en: 'Example: PDP-10 with high and low segments selected by high-order address bit.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：PDP-10使用高阶地址位选择高段和低段。
- en: Or, segment can be selected implicitly by the instruction (e.g. code vs. data,
    stack vs. data, or 8086 prefixes).
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，段可以由指令隐式选择（例如代码与数据，堆栈与数据，或8086前缀）。
- en: 'Advantage of segmentation: flexibility'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分段的优点：灵活性
- en: 'Manage each segment separately:'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别管理每个段：
- en: Grow and shrink independently
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以独立地增长和缩小
- en: Swap to disk
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换到磁盘
- en: Can share segments between processes (e.g., shared code).
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在进程之间共享段（例如，共享代码）。
- en: Can move segments to compact memory and eliminate fragmentation.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将段移动到紧凑的存储器并消除碎片。
- en: What's wrong with segmentation?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分段存在哪些问题？
- en: Paging
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页
- en: Divide virtual and physical memory into fixed-sized chunks called *pages*. The
    most common size is 4 Kbytes.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将虚拟内存和物理内存划分为称为*页面*的固定大小块。最常见的大小是4 K字节。
- en: For each process, a *page table* defines the base address of each of that process'
    pages along with read-only and "present" bits.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个进程，*页表*定义了该进程每个页面的基址，以及只读和“存在”位。
- en: Page table stored in contiguous memory (with base register in hardware).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页表存储在连续的内存中（硬件中的基址寄存器）。
- en: 'Translation process: page number always comes directly from the address. Since
    page size is a power of two, no comparison or addition is necessary. Just do table
    lookup and bit substitution.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译过程：页面号始终直接来自地址。由于页面大小是2的幂，不需要比较或添加。只需进行表查找和位替换。
- en: 'Easy to allocate: keep a free list of available pages and grab the first one.
    Easy to swap since everything is the same size, which is usually the same size
    as disk blocks.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于分配：保持一个可用页面的空闲列表并获取第一个。易于交换，因为一切都是相同大小，通常与磁盘块大小相同。
- en: 'Problem: for modern machines, page tables can be very large:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题：对于现代计算机，页表可能非常庞大：
- en: 'Consider x86-64 addressing architecture: 64-bit addresses, 4096-byte pages.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑x86-64寻址架构：64位地址，4096字节页面。
- en: Ideally, each page table should fit in a page.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，每个页表应该适合一页。
- en: Most processes are small, so most page table entries are unused.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数进程很小，因此大多数页表条目未使用。
- en: Even large processes use their address space sparsely (e.g., code at the bottom,
    stack at the top)
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是大型进程也会稀疏地使用它们的地址空间（例如，代码在底部，堆栈在顶部）
- en: 'Solution: multi-level page tables. Intel x86-64 addressing architecture:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案：多级页表。Intel x86-64寻址架构：
- en: 64-bit virtual addresses, but only the lower 48 bits are actually used.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位虚拟地址，但实际上只使用了低48位。
- en: '4 Kbyte pages: low-order 12 bits of virtual address hold off set within page.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 K字节页面：虚拟地址的低12位保存页面内的偏移量。
- en: 4 levels of page table, each indexed with 9 bits of virtual address.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4级页表，每个索引使用9位虚拟地址。
- en: Each page table fits in one page (page table entries are 8 bytes).
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个页表适合一个页面（页表条目为8字节）。
- en: Can omit empty page tables.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以省略空页表。
- en: 'Next problem: page tables are too large to load into fast memory in the relocation
    unit.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个问题：页表太大，无法加载到重定位单元中的快速存储器中。
- en: Page tables kept in main memory
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页表保留在主存储器中
- en: Relocation unit holds base address for top-level page table
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定位单元保存顶级页表的基址
- en: With x86-64 architecture, must make 4 memory references to translate a virtual
    address!
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用x86-64架构，必须进行4次内存引用才能翻译虚拟地址！
- en: Translation Lookaside Buffers (TLBs)
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译后备缓冲区（TLB）
- en: 'Solution to page translation overhead: create a small hardware cache of recent
    translations.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决页面翻译开销的方案：创建一个最近翻译的小型硬件高速缓存。
- en: Each cache entry stores the page number portion of a virtual address (36 bits
    for x86-64) and the corresponding physical page number (40 bits for x86-64).
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个缓存条目存储虚拟地址的页号部分（对于x86-64为36位）和相应的物理页号（对于x86-64为40位）。
- en: 'Typical TLB sizes: 64-2048 entries.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型TLB大小：64-2048条目。
- en: On each memory reference, compare the page number from the virtual address with
    the virtual page numbers in every TLB entry (in parallel).
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次内存引用时，将虚拟地址中的页面号与每个TLB条目中的虚拟页号进行比较（并行进行）。
- en: If there is a match, use the corresponding physical page number.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有匹配的话，使用相应的物理页码。
- en: If no match, perform the full address translation and save the information in
    the TLB (replace one of the existing entries).
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有匹配，则执行完整的地址转换，并将信息保存在TLB中（替换现有条目中的一个）。
- en: TLB "hit rates" typically 95% or more.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLB的“命中率”通常为95%或更高。
- en: 'TLB complications:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLB的复杂性：
- en: When context switching, must invalidate all of the entries in the TLB (mappings
    will be different for the next process). Chip hardware does this automatically
    when the page table base register is changed.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上下文切换时，必须使TLB中的所有条目无效（映射将对下一个进程不同）。当页表基址寄存器被更改时，芯片硬件会自动执行此操作。
- en: If virtual memory mappings change for the current process (e.g. page moved),
    must invalidate some TLB entries. Special hardware instruction for this.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前进程的虚拟内存映射发生变化（例如，页面移动），必须使一些TLB条目无效。为此有特殊的硬件指令。
- en: Miscellaneous Topics
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项主题
- en: How does the operating system get information from user memory? E.g. I/O buffers,
    parameter blocks. Note that the user passes the OS a *virtual address*.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统如何从用户内存中获取信息？例如I/O缓冲区、参数块。请注意，用户向操作系统传递的是*虚拟地址*。
- en: In some systems the OS just runs unmapped.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些系统中，操作系统只是无映射地运行。
- en: In this case it reads page the tables and translates user addresses in software.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，它会读取页面表，并在软件中转换用户地址。
- en: Addresses that are contiguous in the virtual address space may not be contiguous
    physically. Thus I/O operations may have to be split up into multiple blocks.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟地址空间中连续的地址在物理上可能不是连续的。因此，I/O操作可能需要被拆分为多个块。
- en: Most newer systems include kernel and user memory in same virtual address space
    (but kernel memory not accessible in user mode). This makes life easier for the
    kernel, although it doesn't solve the I/O problem.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数较新的系统将内核和用户内存包含在同一虚拟地址空间中（但内核内存在用户模式下不可访问）。这让内核的生活变得更加容易，尽管它并没有解决I/O问题。
- en: 'Another issue with paging: *internal fragmentation*.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页的另一个问题是：*内部碎片*。
- en: Can't allocate partial pages, so for small chunks of information only part of
    the page will be used
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法分配部分页面，因此对于小块信息，只有页面的一部分会被使用。
- en: 'Result: wasted space at the ends of some pages'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果：一些页面两端会有浪费的空间。
- en: 'Not much of a problem in today''s systems:'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在今天的系统中并不是一个大问题：
- en: The objects (such as code or stack) tend to be much larger than a page.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象（如代码或堆栈）往往比页面大得多。
- en: Percentage wasted space from fragmentation is small.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于碎片化造成的浪费空间百分比很小。
- en: What happens if page sizes grow?
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果页面大小增长会发生什么？
