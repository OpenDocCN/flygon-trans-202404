- en: Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Good Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好测试
- en: The testing pyramid and different levels of tests are discussed in "Agree the
    language you use for tests".
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔和不同级别的测试在“约定您用于测试的语言”中进行了讨论。
- en: As discussed in that section it is important to maintain a layered strategy
    with many fast running unit tests and smaller numbers of integration and system
    tests. The precise proportions that work best will vary from project to project
    but the pyramid formation will hold.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在该部分中讨论的，保持分层策略非常重要，其中有许多快速运行的单元测试和少量的集成和系统测试。最适合的比例会因项目而异，但金字塔形状将保持不变。
- en: Although it is important to write tests at all these levels this section mainly
    concerns itself with unit tests as these are the ones we write most of and run
    most frequently.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在所有这些级别编写测试都很重要，但本节主要关注单元测试，因为这些是我们编写最多且运行最频繁的测试。
- en: Write Specifications Not Tests
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写规范而不是测试
- en: Write Specifications Not Tests
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写规范而不是测试
- en: Before you sit down to write a test it's important to understand *why* you are
    doing it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写测试之前，了解*为什么*这样做很重要。
- en: What is it that you want to achieve?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要实现什么？
- en: There is an unfortunate tendency for developers to look at tests as a thing
    you have to do because it's "best practice". Some extra work to be performed after
    the real work is done. A chore.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，开发人员倾向于将测试视为必须执行的事情，因为这是“最佳实践”。在真正的工作完成后要执行的一些额外工作。一种苦差事。
- en: The reason for writing them has become lost.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编写它们的原因已经迷失。
- en: Why Write Tests?
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么要写测试？
- en: The reason to write tests is to make our lives easier.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 写测试的原因是为了让我们的生活更轻松。
- en: If we are not writing tests that do this we should stop writing them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不编写这样做的测试，我们应该停止编写它们。
- en: 'A good test should do all of the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试应该完成以下所有内容：
- en: Enable refactoring by preventing regression when the implementation changes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在实现更改时防止回归来促进重构
- en: Catch bugs during initial coding
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始编码期间捕获错误
- en: Document how the code behaves
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录代码的行为方式
- en: Inform the design of the code
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为代码设计提供信息
- en: When tests are viewed as a chore to be completed after the code is written only
    this first point is considered.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试被视为在编写代码之后完成的一项任务时，只考虑到了这一点。
- en: Often it is not achieved.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 往往不会实现。
- en: 'Tests written with this mindset can have a negative value:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种心态编写的测试可能具有负面价值：
- en: Instead of enabling refactoring they can increase its cost.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是在促进重构，而是可能增加其成本。
- en: Instead of documenting what the code does, the tests are harder to understand
    than the code itself.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是在记录代码的功能，而是比代码本身更难理解。
- en: Instead of aiding development they increase the work that must be done
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是帮助开发，而是增加了必须完成的工作量
- en: This first problem causes the most pain.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个问题引起了最多的痛苦。
- en: If you have a test that is tied to the code's implementation, to change the
    way the code is implemented you have to spend effort changing the test.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个与代码实现相关联的测试，要更改代码的实现方式，您必须花费精力更改测试。
- en: If the test must change whenever the implementation changes then we cannot trust
    that the test will stop regression. How do we know we did not introduce a bug
    into the test when we changed it?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试必须在实现更改时更改，那么我们就无法相信测试会阻止回归。我们如何知道我们在更改测试时没有引入错误呢？
- en: Executable Specifications
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可执行的规范
- en: So how do we make sure we do not write negative value tests? How do we make
    sure we write tests that provide the benefits in our list?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何确保不编写负值测试？如何确保我们编写的测试能提供列表中的好处？
- en: The first thing to do is let go of the idea that we are testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要做的第一件事是放弃我们正在进行测试的想法。
- en: We are not testing, we're *specifying*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在测试，我们是在*规定*。
- en: To test something you only need to verify that it "does what it does". To specify
    you need to describe the important things that it must do in a way that can be
    clearly understood.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试某样东西，您只需要验证它“做了什么”。要规定，您需要以清晰易懂的方式描述它必须做的重要事情。
- en: A good specification describes *only* the important things.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的规范只描述*重要的*事情。
- en: It describes what something *must* do without making assumptions about how it
    will do it. It allows for multiple implementations. If a specification is tied
    to one implementation then it is *over-specified* and will have to change when
    the implementation does.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它描述了某物*必须*做什么，而不做出关于它将如何做的假设。它允许多种实现。如果规范与一种实现绑定，那么它就是*过度规范化*的，当实现更改时，它将不得不改变。
- en: So this is what we must aim for - an executable specification of our code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们必须追求的目标 - 我们代码的可执行规范。
- en: Unfortunately it is very hard to do.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是这很难做到。
- en: Specification First
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先有规范
- en: One simple technique that can help is to write the specification before the
    code. i.e. TDD.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的技巧可以帮助我们的是在编写代码之前编写规范。即 TDD。
- en: A rigorous TDD cycle proceeds in very small steps.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的TDD循环以非常小的步骤进行。
- en: First write a test and run it to ensure that it fails.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编写一个测试并运行它以确保它失败。
- en: Next write just enough code to make that test pass (and no more).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来只编写足够的代码使该测试通过（不多不少）。
- en: Take a moment to see if there is a sensible refactoring that would improve the
    code, then write the next test and continue the cycle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微停顿一下，看看是否有一个合理的重构可以改进代码，然后编写下一个测试并继续循环。
- en: 'This has several advantages:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个优点：
- en: It guarantees that all the code *can* be tested
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保证所有的代码*可以*被测试
- en: As there is no implementation when the test is written it is harder to write
    a test that is tied to one
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编写测试时没有实现时，更难编写与之相关的测试。
- en: It guarantees that all behavior is covered by tests
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保证所有的行为都被测试覆盖
- en: It discourages writing superfluous code
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它阻止编写多余的代码
- en: 'There are two important aspects to TDD:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TDD有两个重要方面：
- en: Writing the specification first
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先编写规范
- en: Moving in very small steps
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采取非常小的步骤
- en: Both of these practices are a good idea individually, even if they are not combined.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些做法各自单独都是一个好主意，即使它们没有结合在一起。
- en: If we wrote our specification first, but moved in larger steps (possibly because
    we believed we knew what our implementation should look like) we would realize
    our first advantage - a guarantee that the code we wrote could be tested.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们先编写规范，但采取较大的步骤（可能是因为我们相信我们知道我们的实现应该是什么样的），我们将意识到我们的第一个优势 - 保证我们编写的代码可以测试。
- en: What do we mean by this?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？
- en: If code is not written with testing in mind then it can be difficult to write
    a test for it that fits our definition of a *unit* test.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码没有考虑测试，那么很难为其编写符合我们对*单元*测试定义的测试。
- en: 'We can make our code more likely to be testable by following simple rules such
    as:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过遵循简单的规则使我们的代码更容易测试，例如：
- en: Always inject dependencies
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终注入依赖项
- en: Avoid global state (singletons, static variables, ThreadLocals, registries etc)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免全局状态（单例，静态变量，ThreadLocals，注册表等）
- en: But even if we follow these rules we can still find that it is difficult to
    test our code if we have not designed for it. Writing our specification first
    requires our design to consider testing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使我们遵循这些规则，如果我们没有为此进行设计，我们仍然可能发现很难测试我们的代码。首先编写我们的规范需要我们的设计考虑测试。
- en: Although we ensured our code was testable, because we moved in large steps with
    an implementation in mind we might not achieve the other benefits.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们确保了我们的代码是可测试的，但由于我们采取了带有实现的大步骤，我们可能无法获得其他好处。
- en: If we were to write our code without first writing a test we might discover
    we were finished that our code was difficult to test. The process of writing that
    code would however have been easier if we had applied the second technique - moving
    in small steps.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在没有先编写测试的情况下编写代码，我们可能会发现我们已经完成了，但我们的代码很难测试。然而，如果我们采用了第二种技术 - 采取小步骤，编写该代码的过程将更加容易。
- en: If we wrote only a small amount of code before executing it and observing the
    result of each small code change, we would probably spend less time debugging,
    be less likely to write code we did not need and move faster over all.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在执行之前只编写了少量代码，并观察每个小的代码更改的结果，我们可能会花费更少的时间进行调试，更不太可能编写我们不需要的代码，并且总体上更快。
- en: TDD has many advantages but it is not magic.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: TDD有很多优点，但它并不是魔法。
- en: Even if it is applied rigorously it is entirely possible to write terrible code
    and specifications. TDD doesn't mean you can stop thinking.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使严格应用，也完全有可能编写糟糕的代码和规范。TDD并不意味着你可以停止思考。
- en: Despite this, if you have a good understanding of the technologies and domain
    in which you are working, TDD is usually the best approach if you wish to optimize
    for quality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果您对正在工作的技术和领域有很好的理解，如果您希望优化质量，TDD通常是最好的方法。
- en: If you do not understand your domain or technology well you may find writing
    a specification first hard.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不太了解您的领域或技术，您可能会发现先编写规范很难。
- en: The classic solution to this problem is to first gain understanding by producing
    a throw away spike.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的经典解决方案是首先通过制作一个临时的试验来获得理解。
- en: Spikes
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尖峰
- en: A spike is just some quick and dirty code to explore how you might tackle the
    problem. At the end of the spike you will know if that approach works well or
    if it is worth looking for alternative approaches.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个"尖峰"只是一些快速而粗糙的代码，用来探索你可能如何解决问题。在尖峰结束时，你会知道这种方法是否有效，或者是否值得寻找其他方法。
- en: By producing a spike, you gain more understanding of both the domain and the
    technology you are working with. Even if the conclusion at the end of the spike
    is that it was a poor approach, the spike was still useful as it increased your
    understanding.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过制作一个尖峰，你会更多地了解你正在处理的领域和技术。即使尖峰结束时的结论是这是一个糟糕的方法，尖峰仍然是有用的，因为它增加了你的理解。
- en: Once you have learned what you can from the spike, it should be thrown away
    and the final code test driven using the knowledge you have gained.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从尖峰中学到了东西，就应该将其丢弃，并使用你所获得的知识进行最终的代码测试驱动。
- en: Spike and Stabilize
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尖峰和稳定
- en: Traditionally, spikes are thrown away as they are inherently of low quality.
    Discarding the spike is done to optimize code quality at the expense of a (probably)
    slower delivery.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，尖峰会被丢弃，因为它们本质上质量低下。丢弃尖峰是为了优化代码质量，以换取（可能）更慢的交付速度。
- en: Sometimes this is not the trade-off you want.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这并不是你想要的权衡。
- en: An alternative is to try to stabilize the spike so that it is fit for use. If
    you do this, you will usually end up with something of lower quality than if you
    had started again.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是尝试稳定尖峰，使其适用。如果你这样做，通常会得到比重新开始时质量较低的东西。
- en: You will also end up spending more effort on this piece of code over the lifetime
    of the project than if you had thrown the spike away.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会在项目的整个生命周期中花费更多的精力在这段代码上，而不是如果你将尖峰丢弃的话。
- en: What you gain for this loss in quality and increase in effort is a faster *first*
    delivery. Sometimes this is a trade-off worth making, sometimes it is not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你为了这种质量损失和努力增加所获得的是更快的*首次*交付。有时这是值得做出的权衡，有时则不是。
- en: Think Units Not Methods
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑单位而不是方法
- en: Think Units, Not Methods
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑单位，而不是方法
- en: Each behavior that a unit test describes should normally relate to the overall
    *unit* rather than the responsibilities of an individual method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试描述的每个行为通常应与整个*单位*相关，而不是个别方法的责任。
- en: What is a Unit?
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是一个单位？
- en: To think in terms of units we have to first answer the difficult question of
    what a *unit* actually is.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以单位为单位思考，我们首先必须回答一个困难的问题，那就是*单位*到底是什么。
- en: Testing in terms of methods is effectively the same as saying that a *unit*
    is a method. It is easy to show why this does not always work.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以方法为单位进行测试实际上等同于说一个*单位*就是一个方法。很容易说明为什么这并不总是有效。
- en: 'If we were to try and write a unit test for the `push` method of `java.util.Stack`
    we might end up with something like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图为`java.util.Stack`的`push`方法编写一个单元测试，我们可能会得到类似以下的内容：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now lets test the `pop` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试`pop`方法：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Oh. That looks familiar.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 哦。那看起来很熟悉。
- en: The problem we are hitting is that we have defined too small a *unit*. We are
    trying to describe the behavior of something that is only useful when it collaborates
    with other *units* of the same size.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的问题是我们定义了一个太小的*单位*。我们试图描述的是只有在与同样大小的其他*单位*合作时才有用的东西的行为。
- en: 'If we start thinking of `java.util.Stack` as our *unit* then tests become much
    easier to write:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们开始将`java.util.Stack`视为我们的*单位*，那么测试变得更容易编写：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have written a test that, instead of trying to describe what a method does,
    describes the behavior of the class as a whole.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个测试，描述的不是一个方法做什么，而是描述整个类的行为。
- en: The idea that our job is to test methods is common with developers that are
    new to unit testing, and is unfortunately re-enforced by some IDEs and tools that
    provide templates to generate tests for each method of a class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 认为我们的工作是测试方法是新手单元测试开发人员常见的想法，而且不幸的是，一些提供模板为类的每个方法生成测试的IDE和工具进一步强化了这种想法。
- en: As we have seen, for `Stack` it makes far more sense to consider the behavior
    of the class of a whole.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，对于`Stack`来说，考虑整个类的行为更有意义。
- en: Are Classes Units?
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类是单位吗？
- en: It often does make sense to treat a class as a *unit* so this is a good default
    definition, but it isn't always the right granularity.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将一个类视为一个*单位*是有道理的，所以这是一个很好的默认定义，但并不总是正确的粒度。
- en: If we were to try to test the `java.util.Collections` class we would find that
    it is perfectly reasonable to treat the `sort`, `reverse` , `singleton`, etc.
    methods as separate *units*. Each one represents a self contained logical behavior.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图测试`java.util.Collections`类，我们会发现将`sort`、`reverse`、`singleton`等方法视为单独的*单元*是完全合理的。每个方法代表了一个独立的逻辑行为。
- en: So sometimes *units* are as small as methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时*单元*的大小就像方法一样小。
- en: Sometimes they are also larger than a single class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时它们也比一个单一类更大。
- en: If we were to inherit the code below without any tests what tests might we write
    for it?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继承了下面的代码而没有任何测试，我们可能会为它编写哪些测试呢？
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We might write tests for the Addition and Subtraction classes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会为Addition和Subtraction类编写测试：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And for the `ThingaMeBob` class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于`ThingaMeBob`类：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At some point we would hopefully question why this code is so over-engineered
    and consider refactoring to something simpler like.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到了某个时候，我们希望质疑为什么这段代码如此过度设计，并考虑重构成更简单的形式。
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What happens to our tests?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试会发生什么变化？
- en: Which ones were most valuable?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些是最有价值的呢？
- en: The answer of course is that the test which exercised all three classes through
    the public interface of `ThingaMeBob` proved the most useful. We did not have
    to change it at all. When it ran green we knew our refactoring was successful
    and everything still works.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最有用的测试是通过`ThingaMeBob`的公共接口执行所有三个类的测试。我们根本不需要更改它。当它运行正常时，我们就知道我们的重构是成功的，一切仍然正常运行。
- en: We deleted the ones for `Addition` and `Subtraction`. The smaller units we created
    were just implementation detail.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了`Addition`和`Subtraction`的测试。我们创建的更小单元只是实现细节。
- en: Lets re-wind and imagine things happened differently.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回溯一下，想象事情发生了不同的情况。
- en: What if we were asked to test drive the desired behavior from scratch? What
    would we write?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们被要求从头开始测试所需的行为，我们会写什么呢？
- en: We would most likely write something that looked like our 2nd simpler version
    of `ThingaMeBob` and a test that looked something like `ThingAMeBobTest`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很可能会编写类似于我们的第二个更简单版本的`ThingaMeBob`和类似于`ThingAMeBobTest`的测试。
- en: If we were then asked to add support for another 10 operations, we might leave
    our design fundamentally the same.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们被要求添加对其他10个操作的支持，我们可能会保持设计基本相同。
- en: What if a new requirement came for the behavior in `ThingAMeBob` to be more
    dynamic, with different operations being enabled and disabled at runtime?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ThingAMeBob`的行为需要更加动态，比如在运行时启用和禁用不同的操作，该怎么办呢？
- en: It would then make sense to refactor to something like our earlier more complex
    version.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么将重构为类似于我们之前更复杂版本的东西就会有意义。
- en: What should we do with the tests?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何处理这些测试？
- en: We would already have tests written in terms of `ThingaMeBob` that describe
    all supported behaviors. Should we also fully describe `Addition`, `Subtraction`
    and the other 10 operations with tests as we extract them into classes?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了以`ThingaMeBob`为基础的测试，描述了所有支持的行为。在将它们提取为类时，我们是否也应该完整描述`Addition`、`Subtraction`和其他10个操作的测试呢？
- en: There is no right answer here, but I hope it is clear that the most useful *unit*
    that we have identified is `ThingaMeBob`. The smaller *units* are part of just
    one implementation of the functionality we require.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有正确答案，但我希望很明显我们已经确定的最有用的*单元*是`ThingaMeBob`。这些较小的*单元*只是我们需要的功能的一个实现的一部分。
- en: If we choose to write tests for each extracted class those tests would have
    some value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择为每个提取出的类编写测试，这些测试将具有一定的价值。
- en: The test written in terms of `ThingaMeBob` would do a poor job of describing
    what each of the small extracted units does. If a test was failing it wouldn't
    be instantly obvious which class the bug was in. If we had to change one of the
    extracted classes it wouldn't be instantly obvious which test to run.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以`ThingaMeBob`为基础编写的测试会很差地描述每个小提取单元的作用。如果一个测试失败了，不会立即明确出错的类。如果我们必须更改一个提取出来的类，不会立即明确要运行哪个测试。
- en: So there is definitely value in writing tests for each of the extracted classes.
    At the same time, if we were not to do so, that would also be a reasonable decision
    and it would reduce the cost of the refactoring.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为每个提取出的类编写测试确实有价值。同时，如果我们不这样做，那也是一个合理的决定，它会减少重构的成本。
- en: The `ThingaMeBob` tests will be fast and repeatable and allow us to work easily
    with the code. If we could only have tests at one level, the level we would choose
    is `ThingaMeBob`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThingaMeBob`测试将是快速和可重复的，并且允许我们轻松地处理代码。如果我们只能在一个级别上进行测试，我们将选择`ThingaMeBob`级别。'
- en: So, as a starting point, assume that a *unit* will be a class, but recognize
    that this is not a hard rule.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为起点，假设一个*单元*将是一个类，但要认识到这并不是一个硬性规则。
- en: A *unit* is really a "single self contained logical concern" - it may make sense
    to have several classes collaborate in order to capture that concern - as long
    as that collaboration provides a single well defined entry point.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元*实际上是一个“单一自包含的逻辑关注点” - 可能有几个类合作以捕获该关注点 - 只要该协作提供了一个单一定义明确的入口点。'
- en: Making units too small may be a form of over-specifying.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使单元太小可能是一种过度规范化的形式。
- en: Making units too large may result in tests that are difficult to understand
    and expensive to maintain.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使单元太大可能导致难以理解和维护成本高昂的测试。
- en: As a rule of thumb, if you might reasonably have made one or more classes inner
    classes of a different class, perhaps they should be treated as a single unit.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果您可能合理地将一个或多个类作为不同类的内部类，那么它们可能应该被视为一个单一单元。
- en: Name Tests With A Specification Style
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用规范风格命名测试用例
- en: Name Test Cases With a Specification Style
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用规范风格命名测试用例
- en: Use the name of each test case to describe one (and **only** one) behavior of
    the unit under test. The name should be a proposition - i.e. a statement that
    could be true or false.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个测试案例的名称来描述单元测试中的一个（并且**只有一个**）行为。名称应该是一个命题 - 即一个可以是真或假的陈述。
- en: The method name should start with *should*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称应该以*应该*开头。
- en: This is superfluous once you get good at writing test names, but in a mixed
    team it is useful as it encourages thinking about the test in the right way.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您擅长编写测试名称，这就不再重要了，但是在混合团队中，这是有用的，因为它鼓励以正确的方式思考测试。
- en: The rest of the name should describe a behavior and, optionally, a scenario
    (identified by the word When).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分的名称应描述一种行为，可选地，还有一个情景（由单词When标识）。
- en: 'For example, we might start to describe `java.util.Stack` with:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会开始描述`java.util.Stack`：
- en: '`shouldBeEmptyWhenCreated`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建时应该为空`'
- en: '`shouldReturnMostRecentlyAddedItemsFirst`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`应该返回最近添加的项首先`'
- en: '`shouldThrowAnErrorWhenItemsRemovedFromEmptyStack`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`从空栈中移除项时应该抛出错误`'
- en: 'Contrast this with common naming patterns found in some code bases:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些代码库中发现的常见命名模式相对比：
- en: '`emptyStack`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空栈`'
- en: '`testEmptyStack`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试空栈`'
- en: '`testPush`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试推送`'
- en: These names alone tell us nothing about how a `Stack` should behave.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称本身并没有告诉我们关于`Stack`应该如何行为的任何信息。
- en: If we omit *should* we can create more concise names
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略*应该*，我们可以创建更简洁的名称
- en: '`isEmptyWhenCreated`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建时为空`'
- en: '`returnsItemsInOrderTheyAreAdded`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`以添加顺序返回项`'
- en: '`throwsAnErrorWhenItemsRemovedFromEmptyStack`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`从空栈中移除项时抛出错误`'
- en: Although more verbose the formulaic *should* form has an advantage - it provides
    a clear pattern to follow.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然更冗长的公式化*应该*形式具有优势 - 它提供了一个清晰的遵循模式。
- en: If a developer knows that a test name must start with *should* (often because
    they have seen this pattern within existing tests) it is hard for them to revert
    to a different style and write a test that is not a proposition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发人员知道测试名称必须以*应该*开头（通常是因为他们在现有测试中看到了这种模式），那么很难让他们返回到不同的风格并编写一个不是命题的测试。
- en: The verbosity of *should* pays for itself by forcing developers to think about
    tests in the right fashion.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*应该*的冗长通过强迫开发人员以正确的方式思考测试而得到回报。'
- en: Kevlin Henney compares *shoulds* to training wheels on a bike - a device to
    help while we are learning.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Kevlin Henney将*应该*比作自行车上的训练轮 - 一个在学习时帮助的设备。
- en: So when should we take the training wheels off?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们什么时候应该摘掉训练轮呢？
- en: This depends on the makeup of the team and how often the team changes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于团队的构成以及团队的变动频率。
- en: If the majority of people who are likely to work on the codebase over its lifetime
    are accustomed to writing tests in this style then the added verbosity is not
    worth it. If a sufficiently large proportion are not then it is probably best
    for the team to stick with the convention.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能在其生命周期内大多数可能参与代码库工作的人习惯于以这种风格编写测试，则增加的冗长不值得。如果有足够大比例的人不这样做，则最好让团队坚持惯例。
- en: Use the Example Style When Specification Style Does Not Work
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当规范风格不起作用时，请使用示例风格
- en: 'Occasionally, it is not possible to follow the specification naming style because
    the descriptions become too long and unwieldy. If it feels like your method names
    are becoming overly long ask yourself two questions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，不可能遵循规范命名风格，因为描述变得太长和难以控制。如果您觉得您的方法名称变得过长，请问自己两个问题：
- en: Am I really testing only one thing?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我真的只测试了一件事吗？
- en: Is my unit doing too much?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我的单元是否做得太多了？
- en: If you're confident the answer is "no" to both then switch to a different style
    - example style.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对两个问题的答案都很有信心是"否"，那么切换到另一种风格 - 示例风格。
- en: 'In example style the name describes only the "When" part. It does not describe
    the expected behavior, e.g.:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例风格中，名称仅描述了"When"部分。它不描述预期行为，例如：
- en: '`emptyStack`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptyStack`'
- en: '`oneItemAdded`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oneItemAdded`'
- en: '`removalFromEmptyStack`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removalFromEmptyStack`'
- en: To understand tests named with the example style, you must read the code within
    the tests. For this reason, this specification style should be preferred when
    possible.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解以示例风格命名的测试，您必须阅读测试中的代码。因此，应尽可能使用此规范样式。
- en: Avoid Method Names in Test Descriptions Where Possible
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在可能的情况下，尽量避免在测试描述中包含方法名称
- en: Where possible, avoid including method names in test names.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，避免在测试名称中包含方法名称。
- en: On a practical level this avoids the extra overhead of updating test names if
    method names are ever refactored.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际层面上，这避免了如果方法名称曾经重构过而需要更新测试名称的额外开销。
- en: More subtly, including names can make you think in the wrong fashion - verifying
    method implementation rather than specifying unit behavior.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 更微妙的是，包含名称可能会让您以错误的方式思考 - 验证方法实现而不是指定单元行为。
- en: This is not a hard rule - sometimes it will be difficult or impossible to describe
    a meaningful behavior without referring to the unit's interface.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个硬性规则 - 有时很难或不可能描述有意义的行为而不涉及单元的接口。
- en: The domain language may also overlap with the method names, so you may find
    yourself using the same **words** as are also used as a method name.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 领域语言可能与方法名称重叠，因此您可能会发现自己使用与方法名称相同的**单词**。
- en: Pick Examples Carefully
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仔细选择示例
- en: Pick Examples Carefully
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细选择示例
- en: Traditional testing is performed with examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 传统测试是通过示例进行的。
- en: The overall behavior of the component or unit is explained by supplying a series
    of example input and output values, or example interactions with other components.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一系列示例输入和输出值或与其他组件的示例交互来解释组件或单元的整体行为。
- en: Our goal is to use examples to
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使用示例来
- en: Communicate the general expected behavior
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传达一般预期行为
- en: Communicate the behavior at any edge cases
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传达任何边缘情况下的行为
- en: Gain confidence that our code is correct and remains correct when we change
    it
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们的代码在更改时仍然正确并保持正确
- en: So how should we pick these examples?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该如何选择这些示例呢？
- en: One approach is to look at the possible inputs to the component under test.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是查看要测试组件的可能输入。
- en: We could fully specify our code if we provided the expected output for each
    possible input. Usually, this is not practical because the possible range of inputs
    is far too large. Instead, we can look for categories of values within the possible
    range of inputs (e.g *valid* and *invalid*) and pick an example from each one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为每个可能的输入提供预期输出，我们可以完全指定我们的代码。通常，这是不切实际的，因为可能的输入范围太大。相反，我们可以查找可能输入范围内的值类别（例如*有效*和*无效*）并从中选择一个示例。
- en: However, the best approach is usually not to think in terms of possible inputs
    and examples, but to instead think first of the behaviors we would like our code
    to exhibit.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好的方法通常不是考虑可能的输入和示例，而是首先考虑我们希望我们的代码表现出的行为。
- en: Once we have identified the behavior we can then pick examples that demonstrate
    it. The actual values used are often unimportant - "Make tests easy to understand"
    discusses some techniques to make unimportant values less prominent in tests and
    highlight the important ones.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了行为，我们就可以选择演示它的示例。通常使用的实际值并不重要 - "使测试易于理解"讨论了一些技巧，使不重要的值在测试中不那么突出，并突出重要的值。
- en: Property-based testing takes this a stage further.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试将这一步骤推进了一步。
- en: Properties are identified that must hold true for all inputs or for a subset
    of possible inputs that meet certain criteria. The tests do not contain any example
    values - just a description of how they must be constrained. The examples used
    to check the properties are generated randomly and only ever seen if the check
    fails.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 确定必须对所有输入或满足特定条件的可能输入的子集成立的属性。测试不包含任何示例值 - 只包含它们必须受到约束的描述。用于检查属性的示例是随机生成的，只有在检查失败时才会看到。
- en: 'There are some compelling advantages to property based testing:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试有一些引人注目的优点：
- en: The tests describe what is important about the input values. In example testing
    this must be inferred by the reader
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试描述了输入值的重要性。在示例测试中，这必须由读者推断。
- en: The tests will automatically find edge cases and bad assumptions made by the
    programmer
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试将自动发现程序员所做的边界情况和错误假设
- en: There is currently little experience with property-based testing in the Java
    community, so questions remain on how best to use it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Java社区中对基于属性的测试的经验很少，因此如何最好地使用它仍然存在疑问。
- en: One obvious issue is that it introduces randomness, although most frameworks
    provide some mechanism to control it and repeat test runs.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的问题是它引入了随机性，尽管大多数框架提供了一些机制来控制它和重复测试运行。
- en: Follow the Zero, One and Many Rule
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循零、一和多的规则
- en: If your components deals with numbers or collections of things, make sure you
    use sufficient examples to describe its behavior.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组件涉及数字或事物的集合，请确保你使用足够的示例来描述它的行为。
- en: A good rule thumb is that test cases covering 0 (or empty), 1 and "many" are
    likely to be necessary. There will also be important edge cases, e.g. algorithmic
    code dealing with integers might need to consider `Integer.MAX` and `Integer.MIN`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是，覆盖0（或空）、1和“多”可能是必要的。还将存在一些重要的边缘情况，例如，处理整数的算法代码可能需要考虑`Integer.MAX`和`Integer.MIN`。
- en: The zero, one many rule defines the minimum number of cases you can hope to
    consider. To properly describe your code's behavior will likely require many more.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 零、一、多规则定义了你可以希望考虑的最小数量的情况。要正确描述代码的行为，可能需要更多的情况。
- en: When test driving, it is usually easiest to start with the *zero* test case.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试驱动时，通常最容易从*零*测试案例开始。
- en: Test One Thing at a Time
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次只测试一件事
- en: Each test case should specify one thing and one thing only.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试案例应该只指定一件事情。
- en: Multiple assertions within a test may be an indicator that the test is testing
    more than one thing. Multiple assertions should be treated with suspicion, but
    are not necessarily a problem e.g.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个测试中有多个断言可能表明该测试正在测试多个事情。多个断言应该被视为可疑，但不一定是一个问题，例如
- en: '[PRE7]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This test tests only one concern, but uses multiple asserts to do so.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试只测试一个关注点，但使用多个断言来做到这一点。
- en: Test Each Thing Only Once
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只测试每个东西一次
- en: Once you've tested a concern, don't let it leak into other tests - if you do
    then those tests are no longer testing only one thing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你测试了一个关注点，就不要让它泄漏到其他测试中 - 如果你这样做了，那么这些测试就不再只测试一件事情了。
- en: This is a particularly easy mistake to make with interaction-based testing.
    If it is vitally important that the method `anImportantSideEffect` is called,
    it is easy to find yourself verifying that method in each test case.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特别容易犯的错误，特别是在基于交互的测试中。如果方法`anImportantSideEffect`的调用非常重要，那么很容易发现自己在每个测试案例中都验证该方法。
- en: If the contract ever changes so that this side effect is not longer important,
    all tests will need to be updated.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果合同发生变化，以至于这个副作用不再重要，那么所有的测试都需要更新。
- en: This concern should instead by covered by a single test case `shouldPerformImportantSideEffect`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题应该由一个单独的测试案例`shouldPerformImportantSideEffect`来解决。
- en: Although we shouldn't let a property leak into test cases where it does not
    belong this does not necessarily mean that it will be confined to a single test
    case. It may take several examples to fully demonstrate a property.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不应该让属性泄漏到它不属于的测试案例中，但这并不一定意味着它将被限制在单个测试案例中。可能需要多个示例来充分证明一个属性。
- en: Make Tests Easy To Understand
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使测试易于理解
- en: Make Tests Easy to Understand
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使测试易于理解
- en: One of our goals when writing a test is to document what the code under tests
    does.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 写测试的一个目标是记录受测试代码的影响。
- en: We achieve this in part by choosing clear specification style names for each
    test case, but we must also ensure that the code implementing each test case is
    easy to understand.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们部分地通过为每个测试案例选择清晰的规范风格名称来实现这一点，但我们还必须确保实现每个测试案例的代码易于理解。
- en: Some techniques that help achieve this are discussed below.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下面讨论了一些有助于实现这一目标的技术。
- en: Make Test Structure Clear
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明确测试结构
- en: 'A test can be viewed as having three parts:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试可以看作有三个部分：
- en: Given - create the values and objects required for the test
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定 - 创建测试所需的值和对象
- en: When - executes the code under test
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 - 执行被测试的代码
- en: Then - verifies the output/behavior is as expected
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 - 验证输出/行为是否符合预期
- en: These stages are also sometimes called *arrange*, *act* and *assert* by people
    particularly attached to the letter 'a'.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这些阶段也被一些特别喜欢字母'a'的人称为*arrange*、*act*和*assert*。
- en: Although it is important that these three stages are visible, trying to rigorously
    separate them or label them with comments adds noise to a test.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这三个阶段的可见性很重要，但试图严格分开它们或用注释标记它们会给测试添加噪音。
- en: '**Bad**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕**'
- en: '[PRE8]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Better**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好**'
- en: '[PRE9]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Follow Standard TEA Naming Convention for Test Variables
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循标准的TEA测试变量命名约定
- en: Establishing simple conventions can make some very basic things about a test
    clear to a reader.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 建立简单的约定可以让测试的一些非常基本的内容清晰地呈现给读者。
- en: If the unit you are testing is a class make this clear by always naming it `testee`
    within a test.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在测试的单元是一个类，请通过在测试中始终将其命名为`testee`来明确表示。
- en: If you need to store an expected value in a variable, call it `expected` (but
    don't store it in a variable just for the sake of it).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将预期值存储在一个变量中，请将其命名为`expected`（但不要仅仅为了这个目的而将其存储在一个变量中）。
- en: If you need to store a result that you will compare against an expected value
    in variable, name it `actual` (but don't store it in a variable just for the sake
    of it).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要存储一个结果，以便与预期值进行比较，将其命名为`actual`（但不要仅仅为了这个目的而将其存储在一个变量中）。
- en: If you have stubbed a participant consider naming it `stubbedFoo`, if it is
    acting as a mock name it `mockedFoo`. This rule is less hard than the others -
    decide on a case by case basis whether you think it makes your test more or less
    readable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经存根了一个参与者，请考虑将其命名为`stubbedFoo`，如果它充当模拟，请将其命名为`mockedFoo`。这个规则不像其他规则那么严格
    - 根据具体情况决定它是否使你的测试更易读。
- en: Highlight What is Important, Hide What is Not
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强调重要的内容，隐藏不重要的内容
- en: It should be possible to read each test case at a glance - so make things clear
    by highlighting what is important for that test case and hiding what is not.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 应该能够一目了然地阅读每个测试用例 - 因此通过突出显示对该测试用例重要的内容并隐藏不重要的内容来使事情清晰。
- en: If an aspect of the input is important to the test case, highlight it by setting
    it **explicitly** in the test case - don't rely on that value being set in a generic
    setup method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的某个方面对测试用例很重要，请通过在测试用例中**明确**设置它来突出显示它 - 不要依赖于在通用设置方法中设置该值。
- en: Even if the same value is set by default, it is better to re-supply it in the
    test so it is clearly visible.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 即使相同的值已经默认设置，最好还是在测试中重新提供它，以便清晰可见。
- en: If a particular value is not important, indicate this to the reader by using
    well-known neutral values such as `"foo"` for strings, or use clear names such
    as `someInt` or `anInt` for variables and methods that supply values.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个特定的值不重要，请通过使用众所周知的中性值（如字符串的`"foo"`）或使用清晰的名称（如`someInt`或`anInt`）来向读者指示这一点，这很重要。
- en: Supplying values via a method call makes them less visible.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过方法调用提供值会使它们变得不那么显眼。
- en: What is important in the test below?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试中重要的是什么？
- en: '**Bad**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕**'
- en: '[PRE10]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How about this version?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本怎么样？
- en: '**Better**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好**'
- en: '[PRE11]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While we need additional context to understand why `3` is an invalid value,
    it should be clear that the first two parameters to the `process` method are not
    important to the behavior we are specifying.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们需要额外的上下文来理解为什么`3`是一个无效值，但应清楚地表明`process`方法的前两个参数对我们正在指定的行为并不重要。
- en: Why is it important that the testee below returns the enum `CONTINUE`?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么下面的`testee`返回枚举`CONTINUE`很重要？
- en: '**Bad**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕**'
- en: '[PRE12]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we look through the rest of the class we might find:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们浏览类的其余部分，我们可能会发现：
- en: '[PRE13]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Other tests might not need to care about what the default state is, but this
    test does so we should write:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其他测试可能不需要关心默认状态是什么，但这个测试需要，所以我们应该写：
- en: '**Better**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好**'
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we start to deal with more complex domain objects, it becomes harder to separate
    the important values from the ones that are required to construct valid objects
    but not of particular interest to our test. Fortunately, we can use the builder
    pattern to ease the pain, reduce duplication, and keep the tests readable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始处理更复杂的领域对象，将重要的值与构造有效对象所需但对我们的测试不是特别重要的值分开变得更加困难。幸运的是，我们可以使用构建器模式来减轻痛苦，减少重复，并保持测试的可读性。
- en: Name Values Meaningfully
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有意义地命名值
- en: 'If a value has an important meaning, make that meaning clear e.g.:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个值具有重要含义，请明确其含义，例如：
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'instead of:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE16]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Write DAMP Test Code
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写DAMP测试代码
- en: As we have seen, in order to highlight that a value is important to a test,
    we need to keep it within the test method that uses it. This may introduce duplication
    which we might not accept in normal code - but test code is a little different.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在突出显示一个值对于测试很重要的情况下，我们需要将其保留在使用它的测试方法中。这可能会引入重复，这在正常代码中我们可能不会接受，但测试代码有点不同。
- en: Copy and paste coding is bad in tests as well as production code - the more
    code there is, the harder it is to read and a change to a concern will result
    in shotgun surgery if it has been duplicated throughout the tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 复制粘贴编码在测试中和生产代码中都不好——代码越多，阅读起来就越困难，如果已经在整个测试中重复了，对一个问题的更改将导致霰弹手术。
- en: Repetition should therefore generally be avoided in test code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码中因此应该尽量避免重复。
- en: Test code **is** different from production code however.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，测试代码与生产代码是不同的。
- en: Test code must tell more of a story - highlighting what is important and hiding
    what is not. Test code should not be as DRY ( **D**on't **R**epeat **Y**ourself
    ) as production code. It should be DAMP ( contain **D**escriptive **A**nd **M**eaningful
    **P**hrases ).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码必须讲述更多的故事——突出重要的内容，隐藏不重要的内容。测试代码不应该像生产代码一样DRY（**D**on't **R**epeat **Y**ourself），它应该是DAMP（包含**D**escriptive
    **A**nd **M**eaningful **P**hrases）。
- en: If refactoring a small amount of code out of a test method into a shared method
    hides what is happening, accept the duplication and leave it in place. If it does
    not affect readability then refactor mercilessly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将少量代码从测试方法中重构为共享方法会隐藏正在发生的事情，请接受重复，并将其保留在原位。如果不影响可读性，那么无情地进行重构。
- en: Choose the Right Assertion Method
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的断言方法
- en: When a test fails, a good assertion tells you what is wrong.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，一个好的断言会告诉你哪里出了问题。
- en: Although JUnit allows you to supply an assertion message this adds noise to
    the test. Like comments, these messages should be saved for those occasions when
    you cannot communicate using code alone.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JUnit允许您提供断言消息，但这会为测试添加噪音。像注释一样，这些消息应该保留在那些仅凭代码无法沟通的情况下。
- en: Bad
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不好的
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Good
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 好的
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The built in assertions are fairly limited. Alternative assertion libraries
    such as AssertJ provide richer functionality and result in more readable code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的断言功能相当有限。像AssertJ这样的替代断言库提供了更丰富的功能，并且导致了更可读的代码。
- en: Understand How To Use Mocks And Stubs
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解如何使用模拟对象和存根
- en: Understand How to Use Mocks and Stubs
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解如何使用模拟对象和存根
- en: There are two sorts of code and they require two different sorts of test.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的代码，它们需要两种不同类型的测试。
- en: '**Worker code** does stuff. We can test worker code with **state based testing**
    - i.e. asserting that expected values are returned from methods, or objects are
    left in expected states.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作代码**完成工作。我们可以使用**基于状态的测试**来测试工作代码——即断言预期的值是否从方法返回，或者对象是否处于预期状态。'
- en: State based testing is easily recognized as it will use assert statements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 基于状态的测试很容易识别，因为它会使用断言语句。
- en: '**Manager code** does stuff by co-coordinating others.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理器代码**通过协调其他人来完成工作。'
- en: Manager code is harder to test than worker code because we need to make a choice
    - do we try to infer its behavior from its outputs using state based testing,
    or do we use **interaction based testing**?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器代码比工作代码更难测试，因为我们需要做出选择——我们是尝试从其输出中推断其行为，使用基于状态的测试，还是使用**基于交互的测试**？
- en: In interaction based testing, we check that objects talk to each other in the
    expected fashion. To do this we need to somehow eavesdrop on the conversation.
    This is achieved by using objects that impersonate real ones.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于交互的测试中，我们检查对象是否以预期的方式交谈。为了做到这一点，我们需要以某种方式窃听对话。这通过使用模拟真实对象的对象来实现。
- en: Usually these are created using a mocking framework.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这些是使用模拟框架创建的。
- en: Mocking Frameworks
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟框架
- en: Although it is common to refer to all objects created by a mocking framework
    as mocks this is inaccurate.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常将模拟框架创建的所有对象称为模拟对象，但这是不准确的。
- en: A more correct generic term for these objects is *test double*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象的更正确的通用术语是*测试替身*。
- en: 'These can be subdivided based on how they behave:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以根据它们的行为方式进行细分：
- en: Dummy object - needs to be present to satisfy a type signature but is never
    actually used
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哑对象——需要存在以满足类型签名，但实际上从未被使用
- en: Stub - must be present and may supply *indirect inputs*
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存根——必须存在并可能提供*间接输入*
- en: Mock - verifies that expected interactions take place
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象 - 验证期望的交互是否发生
- en: Fake - like a real thing but less heavy - e.g an in memory database
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪造对象 - 像真实对象一样但更轻量化 - 例如内存数据库
- en: Spy - object that records its interactions with others
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间谍对象 - 记录其与其他对象的交互的对象
- en: Of these only stubs, mocks and spies might be created by a mocking framework.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 其中只有存根对象、模拟对象和间谍对象可能由模拟框架创建。
- en: We will talk about spies in a moment, but most test doubles can be conceptually
    viewed as being either a stub or a mock.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论间谍对象，但大多数测试替身都可以在概念上被视为存根对象或模拟对象。
- en: The important difference between them is that a mock has an expectation that
    will cause a test to fail if it is not met. i.e. if an expected method is not
    called on a mock the test will fail.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的重要区别在于，模拟对象有一个期望，如果没有满足就会导致测试失败。即，如果在模拟对象上没有调用预期的方法，测试将失败。
- en: A stub does not care if it is called or not - its role is simply to supply values.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 存根对象不关心自己是否被调用 - 其作用仅仅是提供值。
- en: Traditional Mocks present a code readability dilemma. They define an expected
    outcome (a *then*), but are also part of the fixture required for the test to
    execute (a *given*).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的模拟对象提出了一个代码可读性的困境。它们定义了一个预期的结果（*then*），但同时也是测试执行所需的固定部分（*given*）。
- en: 'For example with JMock we would write:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 JMock 我们会这样写：
- en: '[PRE19]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Spies solve this problem neatly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍对象巧妙地解决了这个问题。
- en: Spies
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 间谍对象
- en: Spies record their interactions with other objects.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍对象记录与其他对象的交互。
- en: In practice this means that Spies act as stubs by default, but as mocks when
    we want them to.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着 Spy 默认情况下充当存根对象，但是当我们希望它们充当模拟对象时，它们会作为模拟对象。
- en: The given/when/then flow becomes easy and natural to maintain.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: given/when/then 的流程变得容易和自然地维护。
- en: 'For example, using Mockito:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 Mockito：
- en: '[PRE20]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For this reason we recommend using a spy framework.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议使用间谍对象框架。
- en: When spies act as mocks that must also supply indirect inputs, it is best to
    make them as forgiving as possible when supplying values but as specific as possible
    when verifying.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当间谍对象充当模拟对象并且必须提供间接输入时，最好在提供值时尽可能宽容，在验证时尽可能具体。
- en: What does this mean?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么呢？
- en: 'Lets imagine that, for some reason, the subscribers in our example had to return
    a positive integer in order for the code to execute without error. Perhaps there
    is some sort of assert statement in the code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设，由于某种原因，在我们的示例中，订阅者必须返回一个正整数才能使代码无错误地执行。也许代码中有某种断言语句：
- en: '[PRE21]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We could ensure our test passed as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保我们的测试通过如下所示：
- en: '[PRE22]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will not discuss the Mockito API in any detail here, but this line:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细讨论 Mockito API，但是这一行代码：
- en: '[PRE23]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ensures that when the `receive` method is called on the spy with a string that
    equals the `message` variable, it will return `1`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 确保当在间谍对象上调用 `receive` 方法时，传入的字符串与 `message` 变量相等时，它将返回 `1`。
- en: If this line was not present the spy would do what Mockito does by default,
    which is to return `0`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在这行代码，间谍对象将按照 Mockito 默认的方式执行，即返回 `0`。
- en: What would our test do if, due to a bug, `receive` was called with a different
    string?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于错误，`receive` 被调用时传入了不同的字符串，我们的测试会怎么样呢？
- en: 'The answer is that, instead of failing due to the verification:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，与其由于验证而失败：
- en: '[PRE24]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It would throw an error before it reached this point because the assertion in
    our production code would trigger.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在达到此点之前，它将抛出一个错误，因为我们生产代码中的断言将触发。
- en: We were too specific.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过于具体了。
- en: If we instead setup our spy as follows
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的间谍对象设置如下
- en: '[PRE25]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The test would fail cleanly.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将会干净地失败。
- en: This pattern of being lenient when supplying values, but specific when verifying
    also tends to result in tests that are less brittle when things change.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供值时宽容，但在验证时具体的这种模式也倾向于导致测试在事物变化时更不脆弱。
- en: Stubs in State-Based Tests
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于状态的测试中的存根对象
- en: By definition, state-based testing will never include mocks (in the strict sense
    of the word), but they may use stubs to supply indirect values.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，基于状态的测试永远不会包括模拟对象（严格意义上的），但是它们可能使用存根对象来提供间接值。
- en: It can be tempting to also use a mocking framework to stub values instead of
    using their constructors and modifier methods. For complex objects using stubs
    can appear easier than constructing real ones.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用模拟框架来存根值而不是使用它们的构造函数和修改器方法会很诱人。对于复杂对象，使用存根对象可能比构造真实对象更容易。
- en: Don't do this.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做。
- en: Mocking frameworks should be used only to isolate our tests from objects with
    behavior. If you have values that are difficult to construct consider the test
    data builder pattern instead
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟框架只应用于将我们的测试与具有行为的对象隔离开来。如果您有难以构建的值，请考虑使用测试数据生成器模式。
- en: Choosing Between State and Interaction Testing
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在状态和交互测试之间进行选择
- en: Sometimes there is no choice about which to use. For example, it is not possible
    to meaningfully specify how a cache should behave from its inputs and outputs
    alone. Other times we must weigh the pros and cons.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们没有选择。例如，仅通过输入和输出就无法有意义地指定缓存应如何行为。其他时候我们必须权衡利弊。
- en: A state-based test for manager code is likely to be less easy to read and understand
    as it must rely on the behaviors of the objects the SUT interacts with. The test
    will also be coupled to these behaviors and will require changes if those behaviors
    change - you have effectively increased the size of the "unit" you are testing
    as discussed in "Think units not methods".
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理器代码的基于状态的测试可能不太容易阅读和理解，因为它必须依赖于SUT与之交互的对象的行为。测试还将与这些行为耦合，并且如果这些行为发生变化，则需要更改
    - 实际上，您已经增加了您正在测试的“单元”的大小，如“思考单元而不是方法”中所讨论的那样。
- en: Interaction-based testing requires us to peek beyond the unit's external interface
    and into its implementation. This carries the risk that we might over-specify
    and create an implementation-specific test.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 基于交互的测试要求我们窥视单位的外部接口之外，并深入其实现。这带来的风险是我们可能会过度规定并创建一个特定于实现的测试。
- en: On balance, it is preferable to lean towards state based testing and where possible
    enable it in the design of your code. There will, however, be many situations
    in which you will decide that interaction based testing is preferable.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，倾向于基于状态的测试并在可能的情况下在代码设计中启用它是可取的。然而，有许多情况下您会决定交互式测试更可取。
- en: Understand Your Options For Code Reuse
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解代码重用的选项
- en: Understand Your Options for Code Reuse
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解代码重用的选项
- en: Reusing code is a good thing.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 重用代码是件好事。
- en: When people start programming in an OO language for the first time they tend
    to over-use inheritance for this purpose before discovering that composition is
    generally a better idea.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们第一次开始使用面向对象的编程语言时，他们往往会过度使用继承来达到这个目的，直到发现组合通常是一个更好的主意为止。
- en: Unfortunately, it is not easy to use composition to reuse code in JUnit tests
    and this can lead you to write difficult-to-maintain test class hierarchies.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在JUnit测试中使用组合重用代码并不容易，这可能会导致编写难以维护的测试类层次结构。
- en: A small amount of duplication may be preferable to introducing a class hierarchy
    when other options do not exist, but some types of test can be reused without
    inheritance.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 少量重复可能比在没有其他选择时引入类层次结构更可取，但某些类型的测试可以在没有继承的情况下重用。
- en: Assertions
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: Code related to assertions is straightforward to reuse outside of class hierarchies.
    This can be done trivially, by creating classes containing static assert methods
    that can be statically imported (as the built in JUnit assertions now are), or
    more elegantly by creating custom matchers for hamcrest or AssertJ.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 与断言相关的代码在类层次结构之外重用是很简单的。这可以通过创建包含静态断言方法的类来轻松实现（就像现在内置的JUnit断言一样），或者更优雅地通过为hamcrest或AssertJ创建自定义匹配器来实现。
- en: Object Creation
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象创建
- en: For small, simple objects, the mother pattern can be used, but this can quickly
    become a maintenance issue if the objects become more complex over time.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小而简单的对象，可以使用mother模式，但如果对象随着时间变得更复杂，这可能很快成为一个维护问题。
- en: A better pattern is the Builder pattern, this can have the added advantage of
    allowing tests to clearly highlight important and unimportant input.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的模式是建造者模式，这样可以额外提供优势，使测试能够清晰地突出重要和不重要的输入。
- en: Repeated Behaviors
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复行为
- en: If you are using JUnit then repeated section of code within a test can be packaged
    and re-used as [custom rules](https://github.com/junit-team/junit/wiki/Rules).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用JUnit，那么测试中重复的代码段可以被打包并重复使用为[自定义规则](https://github.com/junit-team/junit/wiki/Rules)。
- en: Write Repeatable Tests
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可重复的测试
- en: Write Repeatable Unit Tests
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可重复的单元测试
- en: Unit tests must be repeatable and deterministic - it must be possible to run
    them thousands of times in any order and get the same result. This means that
    they must have no dependency on any external factor.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试必须是可重复和确定性的 - 必须能够以任何顺序运行数千次并得到相同的结果。这意味着它们不能依赖于任何外部因素。
- en: 'In practice this means unit tests must not:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着单元测试不能：
- en: Read or write from databases
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中读取或写入
- en: Perform network IO
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行网络IO
- en: Write to disk
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入磁盘
- en: Modify static state
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改静态状态
- en: If your test does any of these things then it is not a **unit** test. This is
    not to say that your test is not valuable.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的测试执行了这些操作之一，那么它就不是一个**单元**测试。这并不是说您的测试没有价值。
- en: Only Unit Test Code It Makes Sense To Unit Test
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只有对单元测试代码进行单元测试才有意义
- en: Only Unit Test Code That It Makes Sense to Unit Test
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只有对单元测试代码进行单元测试才有意义
- en: 'In most cases, there is little value in unit testing:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，对单元测试的价值不大：
- en: Auto generated code
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成的代码
- en: Logging
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Code whose **sole** concern is integration with another system
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一**关注的代码是与另一个系统集成。'
- en: The canonical example of code with a pure integration concern is a DAO.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 具有纯集成关注的典型示例是DAO。
- en: If a compatible in-memory fake database is available then it can be meaningfully
    unit tested against that. If no fake is available, there is no value in writing
    tests that mock out the JDBC driver - the first level of testing should instead
    be integration testing against a real database.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个兼容的内存中的虚拟数据库可用，那么可以对其进行有意义的单元测试。如果没有虚拟数据库可用，则没有编写模拟JDBC驱动器的测试的价值-第一级测试应该是与真实数据库进行集成测试。
- en: There is also little value in **explicitly** specifying the behavior of very
    simple boiler plate code such as get/set methods. The expected behavior is clear
    without the presence of a test and their actual behavior ought to be verified
    by other tests that use the code while testing more complex logic. If code coverage
    indicates that these methods have not been executed by other tests perhaps you
    can delete them?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常简单的样板代码（如get/set方法）明确指定行为也没有太大价值。在没有测试的情况下，预期的行为是清晰的，而其实际行为应该由使用代码的其他测试验证，同时测试更复杂的逻辑。如果代码覆盖率表明这些方法尚未被其他测试执行，也许您可以删除它们？
- en: Code that is not unit tested should always be integration tested.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 没有进行单元测试的代码应始终进行集成测试。
- en: Testing FAQS
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试常见问题解答
- en: Testing FAQ
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试常见问题解答
- en: How Do I Test a Private Method?
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何测试一个私有方法？
- en: You don't test methods (private or public), you test the behavior of a unit
    as a whole.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您不测试方法（私有或公共），您测试单元作为整体的行为。
- en: If you cannot exercise the logic of a private method via the public interface,
    is that logic actually required? If it is required, and is sufficiently complex
    that it is causing you testing pain, then perhaps you should extract that concern
    into a separate unit that can be tested in isolation and injected in via the constructor?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法通过公共接口执行私有方法的逻辑，则该逻辑是否真的需要？如果它是必需的，并且足够复杂，以至于它给您带来测试上的困扰，那么也许您应该将该关注点提取到一个单独的单元中，该单元可以被隔离测试并通过构造函数注入？
- en: How Do I Test a Void Method?
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何测试一个空方法？
- en: You don't test methods (void or not), you test the behavior of a unit as a whole.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您不测试方法（void或不是），您测试单元作为整体的行为。
- en: If the method is void, it must be performing some sort of side effect that can
    be checked by either state testing or interaction testing.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法是void，则必须执行某种可以通过状态测试或交互测试进行检查的副作用。
- en: 'For example, if you are trying to ''test the add method'' of collection class,
    you should probably instead be writing tests like:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您正在尝试“测试集合类的添加方法”，那么您应该考虑编写类似的测试：
- en: '[PRE26]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How do I Test Code That Reasons About the Current Date/Time?
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何测试涉及当前日期/时间的代码？
- en: A bad solution is to use a static method (such as joda time's `setCurrentMillisFixed`)
    to set the current date.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态方法（例如joda时间的`setCurrentMillisFixed`）设置当前日期是一个不好的解决方案。
- en: A good solution is to inject a strategy for retrieving the date/time into your
    class as a dependency.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的解决方案是将检索日期/时间的策略作为依赖项注入到您的类中。
- en: Java 8 provides the `java.time.Clock` class which can be used for this purpose.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8提供了`java.time.Clock`类，可用于此目的。
- en: The static factory method `fixed` will create an instance that represents a
    constant time. Other methods provide implementations suitable for production use.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂方法`fixed`将创建一个代表常量时间的实例。其他方法提供了适合生产使用的实现。
- en: Java 7 does not provide an out of the box class for this purpose so you will
    need to roll your own.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7没有提供用于此目的的开箱即用类，因此您需要自己编写。
- en: Do I Need to Implement a Teardown Method for my Test?
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我的测试需要实现一个拆卸方法吗？
- en: This used to be a requirement for all JUnit 3 tests. If you didn't nullify all
    members of a test class in a teardown your test suite began to eat memory as it
    grew.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这曾经是所有JUnit 3测试的要求。如果您在拆卸中未将测试类的所有成员置空，则您的测试套件将在增长时开始占用内存。
- en: This is not a requirement for vanilla JUnit 4 tests, but it is possible that
    you may need to do so if you are using a custom runner.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于普通的JUnit 4测试不是必需的，但如果您使用自定义运行器，则可能需要这样做。
- en: What's the Difference Between Errors and Failures?
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误和失败之间有什么区别？
- en: You should try to design your tests to produce **failures** when the code is
    logically wrong. Your tests should only produce errors when something unexpected
    has happened.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码在逻辑上错误时，您应该尝试设计您的测试以产生**失败**。只有在发生意外情况时，您的测试才应该产生错误。
- en: How Should I Test for Expected Exceptions?
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我应该如何测试预期的异常？
- en: It depends.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于。
- en: 'The built in:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 内置：
- en: '[PRE27]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Is concise and suffices for simple scenarios, but has a gotcha. If the test
    method exercises more than one method of the testee, the expectation applies to
    the whole test method rather than the specific interaction with the testee that
    is expected to throw it.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的场景来说，这是简洁且足够的，但有一个陷阱。如果测试方法调用了测试对象的多个方法，期望将适用于整个测试方法，而不是期望与测试对象的特定交互。
- en: If data held within the exception is important, it is also not possible to assert
    on it with this method.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常中保存的数据很重要，使用这种方法也无法对其进行断言。
- en: 'The traditional solution is to use a try catch block:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的解决方案是使用try catch块：
- en: '[PRE28]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is easy to follow, but a little verbose. It is also easy to forget to include
    the call to `fail()` if you are not test driving your code.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易理解，但有点冗长。如果您不是测试驱动您的代码，很容易忘记包含对`fail()`的调用。
- en: 'JUnit now provides an alternate solution in the form of the ''ExpectedException''
    method rule. This allows for more fine grained exception checking:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit现在提供了一种替代解决方案，即“ExpectedException”方法规则。这允许进行更精细的异常检查：
- en: '[PRE29]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is more concise, but breaks the usual given/when/then flow of a test by
    moving the then part to the start of the method.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加简洁，但打破了测试的通常给定/当/然后流程，将然后部分移到方法的开头。
- en: For Java 8 AssertJ provides some custom assertions that can be used without
    breaking this flow.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java 8，AssertJ提供了一些自定义断言，可以在不中断此流程的情况下使用。
- en: '[PRE30]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Although it maintains the flow, the lambda in which the testee is called looks
    a little ugly.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它保持了流程，但测试对象被调用的lambda看起来有点丑陋。
- en: When it can be used we recommend sticking with the concise `expected =` format.
    For more complex situations it is largely a matter of taste.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当可以使用时，我们建议坚持简洁的`expected =`格式。对于更复杂的情况，这在很大程度上是一种品味问题。
- en: How Do I Test an Abstract Class?
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我如何测试抽象类？
- en: An abstract class is just a dependency that some other code will use - a dependency
    that you have made harder than usual to isolate due to your choice to make it
    an abstract class.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类只是其他代码将使用的一个依赖项 - 由于您选择将其设置为抽象类，使得它比通常更难隔离。
- en: So first off, would your design look better if the functionality was being re-used
    by composition rather than inheritance?
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果功能通过组合而不是继承被重用，您的设计会更好吗？
- en: 'Assuming that you can''t improve your design by getting rid of the abstract
    class you can either:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您不能通过摆脱抽象类来改进设计，您可以选择：
- en: Treat it as an implementation detail and check that each of its clients behaves
    as expected.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其视为实现细节，并检查其每个客户端的行为是否符合预期。
- en: Test it in isolation by creating an anonymous concrete class
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建一个匿名具体类来隔离地测试它
- en: The first approach will result in tests that are less tied to the implementation,
    but there will be repetition between the tests for each subclass.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法将导致与实现不太相关的测试，但在每个子类的测试之间会有重复。
- en: The second approach will avoid repetition but is tied to the implementation
    and is likely to be brittle.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法将避免重复，但与实现绑定，可能会很脆弱。
- en: How Do I test Hashcode and Equals?
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我如何测试Hashcode和Equals？
- en: Testing hashcode and equals can be fiddly and time consuming, which raises questions
    about whether it is time well spent given that the code is likely to have been
    auto-generated.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 测试哈希码和等式可能会很棘手和耗时，这引发了一个问题，即考虑到代码可能已经是自动生成的，这是否值得花费时间。
- en: 'Equals verifier project provides a good (partial) solution:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Equals验证器项目提供了一个很好的（部分）解决方案：
- en: '[http://www.jqno.nl/equalsverifier/](http://www.jqno.nl/equalsverifier/)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.jqno.nl/equalsverifier/](http://www.jqno.nl/equalsverifier/)'
- en: 'It checks that a class fulfills the hashcode-equals contract with a single
    line test that is trivial to write:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过一行测试检查一个类是否满足哈希码-等式合同，这是很容易编写的：
- en: '[PRE31]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It does, however, do a very thorough job of checking the contract - including
    how it interacts with inheritance. It is non-trivial to make a non-final class
    conform to the contract.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它确实非常彻底地检查了合同 - 包括它与继承的交互方式。让一个非final类符合合同是非平凡的。
- en: Although equals verifier does a good job of checking the hashcode equals contract,
    it has no knowledge of how you expect the methods to actually behave. If you wish
    equality to (for example) be defined by a single ID field only, you must write
    additional tests that verify this behavior.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管equals verifier在检查哈希码相等合同方面做得很好，但它不知道你希望方法实际上如何行为。如果你希望相等性（例如）仅由单个ID字段定义，你必须编写额外的测试来验证这种行为。
- en: 'For the common scenario of a class that should be considered equal based on
    all of its fields the behavior may be checked in a single test:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个类在所有字段都应被视为相等的常见情况，可以在单个测试中检查其行为：
- en: '[PRE32]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This may become the default behavior in a future version of EqualsVerifier,
    but must be specifically specified in 1.7.5
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会成为EqualsVerifier未来版本的默认行为，但必须在1.7.5中明确指定。
