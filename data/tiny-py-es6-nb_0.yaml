- en: Tiny Python 2.7 Notebook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tiny Python 2.7 笔记
- en: 'From: [mattharrison/Tiny-Python-2.7-Notebook](https://github.com/mattharrison/Tiny-Python-2.7-Notebook)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 来自：[mattharrison/Tiny-Python-2.7-Notebook](https://github.com/mattharrison/Tiny-Python-2.7-Notebook)
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This is not so much an instructional manual, but rather notes, tables, and examples
    for Python syntax. It was created by the author as an additional resource during
    training, meant to be distributed as a physical notebook. Participants (who favor
    the physical characteristics of dead tree material) could add their own notes,
    thoughts, and have a valuable reference of curated examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本教程手册，而是 Python 语法的笔记、表格和示例。它是作者在培训期间创建的额外资源，旨在作为一本实体笔记本进行分发。参与者（偏爱纸质书籍特性的人）可以添加自己的笔记、思考，并获得一本有价值的精选示例参考资料。
- en: Running Python
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Python
- en: Installation
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: 'To check if Python is installed, run the following from a terminal:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Python 是否已安装，请从终端运行以下命令：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Otherwise, install Python from the website [[1]](#id2).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，请从网站安装 Python [[1]](#id2)。
- en: '| [[1]](#id1) | [http://python.org](http://python.org) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [[1]](#id1) | [http://python.org](http://python.org) |'
- en: Invoking Python
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用 Python
- en: 'The Python executable will behave differently depending on the command line
    options you give it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可执行文件的行为会根据你给出的命令行选项而有所不同：
- en: 'Start the Python REPL:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 Python REPL：
- en: '[PRE1]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Execute the `file.py` file:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `file.py` 文件：
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the `file.py` file, and drop into REPL with namespace of `file.py`:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `file.py` 文件，并进入 `file.py` 的 REPL 命名空间：
- en: '[PRE3]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Execute the `json/tool.py` module:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `json/tool.py` 模块：
- en: '[PRE4]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute `"print 'hi'"`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `"print 'hi'"`
- en: '[PRE5]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: REPL
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REPL
- en: Use the `help` function to read the documentation for a module/class/function.
    As a standalone invocation, you enter the help system and can explore various
    topics.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `help` 函数阅读模块/类/函数的文档。作为独立的调用，你将进入帮助系统，并可以探索各种主题。
- en: Use the `dir` function to list contents of the namespace, or attributes of an
    object if you pass one in
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dir` 函数列出命名空间的内容，或者如果传入了对象，则列出对象的属性
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The majority of code in this book is written as if it where executed in a REPL.
    If you are typing it in, ignore the primary and secondary prompts (`>>>` and `...`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大部分代码都是以在 REPL 中执行的方式编写的。如果你正在输入它，请忽略主要和次要提示符（`>>>` 和 `...`）。
- en: The Zen of Python
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 之禅
- en: 'Run the following in an interpreter to get an easter egg that describes some
    of the ethos behind Python. This is also codified in PEP 20:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释器中运行以下内容，你将得到一个彩蛋，描述了 Python 背后的一些精神。这也被编码到了 PEP 20 中：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These might just seem like silly one liners, but there is a lot of wisdom packed
    in here. It is good for Python programmers to review these every once in a while
    and see if these hold true for their code. (Or to justify their code reviews)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能只是看起来像是愚蠢的一行代码，但其中包含了很多智慧。Python 程序员偶尔回顾一下这些内容，并看看这些内容是否适用于他们的代码是很好的。（或者用来证明他们的代码审查）
- en: Built-in Types
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置类型
- en: Variables
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'Python variables are like cattle tags, they point to objects (which can be
    classes, instances, modules, or functions), but variables are not the objects.
    You can reuse variable names for different object types (though you probably shouldn''t):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python 变量就像牛标签一样，它们指向对象（可以是类、实例、模块或函数），但变量本身不是对象。你可以为不同类型的对象重复使用变量名（尽管你可能不应该这样做）：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `#` character denotes the start of a comment. There are no multi-line comments,
    though most editors with Python support can comment out a region.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` 字符表示注释的开始。虽然没有多行注释，但大多数带有 Python 支持的编辑器都可以注释掉一个区域。'
- en: '[![../Images/rebind2.png](../Images/rebind2.png)](../Images/rebind2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/rebind2.png](../Images/rebind2.png)](../Images/rebind2.png)'
- en: Illustration of reusing the same variable
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重用相同变量的示例
- en: Numbers
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字
- en: 'Python includes three types of numeric literals: *integers*, *floats*, and
    *complex numbers*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包括三种类型的数字字面量：*整数*、*浮点数* 和 *复数*。
- en: Number types
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数字类型
- en: '| Type | Example |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 示例 |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Integer | `14` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | `14` |'
- en: '| Integer (Hex) | `0xe` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 整数（十六进制） | `0xe` |'
- en: '| Integer (Octal) | `0o16` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 整数（八进制） | `0o16` |'
- en: '| Integer (Binary) | `0b1110` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 整数（二进制） | `0b1110` |'
- en: '| Float | `14.0` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | `14.0` |'
- en: '| Float | `1.4e1` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | `1.4e1` |'
- en: '| Complex | `14+0j` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 复数 | `14+0j` |'
- en: There are many built-in functions for manipulating numbers ie. `abs`, `min`,
    `max`, `ceil`. Also see the `math` and `random` modules in the standard library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于操作数字的内置函数，如 `abs`、`min`、`max`、`ceil`。还可以查看标准库中的 `math` 和 `random` 模块。
- en: Number magic methods
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数字魔术方法
- en: '| Operation | Provided By | Result |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 提供者 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `abs(num)` | `__abs__` | Absolute value of `num` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `abs(num)` | `__abs__` | `num` 的绝对值 |'
- en: '| `num + num2` | `__add__` | Addition |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `num + num2` | `__add__` | 加法 |'
- en: '| `bool(num)` | `__bool__` | Boolean coercion |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `bool(num)` | `__bool__` | 布尔强制转换 |'
- en: '| `num / num2` | `__div__` | Division |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `num / num2` | `__div__` | 除法 |'
- en: '| `num == num2` | `__eq__` | Equality |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `num == num2` | `__eq__` | 相等性 |'
- en: '| `float(num)` | `__float__` | Float coercion |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `float(num)` | `__float__` | 浮点数强制转换 |'
- en: '| `num // num2` | `__floordiv__` | Integer division |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `num // num2` | `__floordiv__` | 整数除法 |'
- en: '| `num >= num2` | `__ge__` | Greater or equal |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `num >= num2` | `__ge__` | 大于或等于 |'
- en: '| `num > num2` | `__gt__` | Greater than |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `num > num2` | `__gt__` | 大于 |'
- en: '| `int(num)` | `__int__` | Integer coercion |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `int(num)` | `__int__` | 整数强制转换 |'
- en: '| `long(num)` | `__long__` | Long coercion |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `long(num)` | `__long__` | 长整数强制转换 |'
- en: '| `num <= num2` | `__le__` | Less or equal |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `num <= num2` | `__le__` | 小于或等于 |'
- en: '| `num < num2` | `__lt__` | Less than |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `num < num2` | `__lt__` | 小于 |'
- en: '| `num % num2` | `__mod__` | Modulus |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `num % num2` | `__mod__` | 取模 |'
- en: '| `num * num2` | `__mul__` | Multiplication |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `num * num2` | `__mul__` | 乘法 |'
- en: '| `num != num2` | `__ne__` | Not equal |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `num != num2` | `__ne__` | 不相等 |'
- en: '| `-num` | `__neg__` | Negative |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `-num` | `__neg__` | 负数 |'
- en: '| `+num` | `__pos__` | Positive |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `+num` | `__pos__` | 正数 |'
- en: '| `num ** num2` | `__pow__` | Power |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `num ** num2` | `__pow__` | 幂运算 |'
- en: '| `round(num)` | `__round__` | Round |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `round(num)` | `__round__` | 四舍五入 |'
- en: '| `num.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `num.__sizeof__()` | `__sizeof__` | 内部表示的字节数 |'
- en: '| `str(num)` | `__str__` | String coercion |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `str(num)` | `__str__` | 字符串强制转换 |'
- en: '| `num - num2` | `__sub__` | Subtraction |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `num - num2` | `__sub__` | 减法 |'
- en: '| `math.trunc(num)` | `__trunc__` | Truncation |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `math.trunc(num)` | `__trunc__` | 截断 |'
- en: Integer specific methods and operations
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 整数特定方法和操作
- en: '| Operation | Provided By | Result |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `num & num2` | `__and__` | Bitwise and |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `num & num2` | `__and__` | 按位与 |'
- en: '| `math.ceil(num)` | `__ceil__` | Ceiling |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `math.ceil(num)` | `__ceil__` | 上取整 |'
- en: '| `math.floor(num)` | `__floor__` | Floor |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `math.floor(num)` | `__floor__` | 下取整 |'
- en: '| `hex(num)` | `__hex__` | Hex conversion |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `hex(num)` | `__hex__` | 十六进制转换 |'
- en: '| `~num` | `__invert__` | Bitwise inverse |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `~num` | `__invert__` | 按位取反 |'
- en: '| `num << num2` | `__lshift__` | Left shift |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `num << num2` | `__lshift__` | 左移 |'
- en: '| `num &#124; num2` | `__or__` | Bitwise or |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `num &#124; num2` | `__or__` | 按位或 |'
- en: '| `num >> num2` | `__rshift__` | Right shift |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `num >> num2` | `__rshift__` | 右移 |'
- en: '| `num ^ num2` | `__xor__` | Bitwise xor |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `num ^ num2` | `__xor__` | 按位异或 |'
- en: '| `num.bit_length()` | `bit_length` | Number of bits necessary |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `num.bit_length()` | `bit_length` | 所需位数 |'
- en: Float specific methods and operations
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数特定方法和操作
- en: '| Operation | Result |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `f.as_integer_ratio()` | Returns num, denom tuple |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `f.as_integer_ratio()` | 返回 num, denom 元组 |'
- en: '| `f.is_integer()` | Boolean if whole number |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `f.is_integer()` | 是否为整数 |'
- en: Strings
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Python 2 strings hold byte strings. To create Unicode strings, you need to
    use a Unicode literal. Python has a few ways to represent strings:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2 字符串保存字节字符串。要创建 Unicode 字符串，需要使用 Unicode 文本。Python 有几种表示字符串的方式：
- en: String types
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串类型
- en: '| Type | Example |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 示例 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| String | `"hello\tthere"` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `"hello\tthere"` |'
- en: '| String | `''hello''` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `''hello''` |'
- en: '| String | `''''''He said, "hello"''''''` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `''''''He said, "hello"''''''` |'
- en: '| Unicode String | `u''Hello again''` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| Unicode 字符串 | `u''Hello again''` |'
- en: '| Raw string | `r''hello\tthere''` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 原始字符串 | `r''hello\tthere''` |'
- en: Escape Characters (Unicode escapes must be in a Unicode literal)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 转义字符（Unicode 转义必须在 Unicode 文本中）
- en: '| Escape Sequence | Output |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 输出 |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\` newline | Ignore trailing newline in triple quoted string |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `\` 换行 | 忽略三引号字符串中的结尾换行符 |'
- en: '| `\\` | Backslash |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 |'
- en: '| `\''` | Single quote |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | 单引号 |'
- en: '| `\"` | Double quote |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 |'
- en: '| `\a` | ASCII Bell |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `\a` | ASCII 响铃 |'
- en: '| `\b` | ASCII Backspace |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | ASCII 退格 |'
- en: '| `\n` | Newline |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行 |'
- en: '| `\r` | ASCII carriage return |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | ASCII 回车 |'
- en: '| `\t` | Tab |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |'
- en: '| `\u12af` | Unicode 16 bit |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `\u12af` | Unicode 16 位 |'
- en: '| `\U12af89bc` | Unicode 32 bit |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `\U12af89bc` | Unicode 32 位 |'
- en: '| `\N{BLACK STAR}` | Unicode name |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `\N{BLACK STAR}` | Unicode 名称 |'
- en: '| `\o84` | Octal character |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `\o84` | 八进制字符 |'
- en: '| `\xFF` | Hex character |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `\xFF` | 十六进制字符 |'
- en: String operations
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作
- en: '| Operation | Provided By | Result |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `s + s2` | `__add__` | String concatenation |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `s + s2` | `__add__` | 字符串连接 |'
- en: '| `"foo" in s` | `__contains__` | Membership |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `"foo" in s` | `__contains__` | 成员关系 |'
- en: '| `s == s2` | `__eq__` | Equality |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `s == s2` | `__eq__` | 相等性 |'
- en: '| `s >= s2` | `__ge__` | Greater or equal |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `s >= s2` | `__ge__` | 大于或等于 |'
- en: '| `s[0]` | `__getitem__` | Index operation |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `s[0]` | `__getitem__` | 索引操作 |'
- en: '| `s > s2` | `__gt__` | Greater |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `s > s2` | `__gt__` | 大于 |'
- en: '| `s <= s2` | `__le__` | Less than or equal |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `s <= s2` | `__le__` | 小于或等于 |'
- en: '| `len(s)` | `__len__` | Length |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `len(s)` | `__len__` | 长度 |'
- en: '| `s < s2` | `__lt__` | Less than |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `s < s2` | `__lt__` | 小于 |'
- en: '| `s % (1, ''foo'')` | `__mod__` | Formatting |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `s % (1, ''foo'')` | `__mod__` | 格式化 |'
- en: '| `s * 3` | `__mul__` | Repetition |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `s * 3` | `__mul__` | 重复 |'
- en: '| `s != s2` | `__ne__` | Not equal |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `s != s2` | `__ne__` | 不等于 |'
- en: '| `repr(s)` | `__repr__` | Programmer friendly string |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `repr(s)` | `__repr__` | 程序员友好字符串 |'
- en: '| `s.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `s.__sizeof__()` | `__sizeof__` | 内部表示的字节 |'
- en: '| `str(s)` | `__str__` | User friendly string |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `str(s)` | `__str__` | 用户友好字符串 |'
- en: String methods
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串方法
- en: '| Operation | Result |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `s.capitalize()` | Capitalizes a string |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `s.capitalize()` | 字符串首字母大写 |'
- en: '| `s.center(w, [char])` | Center a string in `w` spaces with `char` (default
    `" "`) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `s.center(w, [char])` | 在`w`个空格中居中字符串，使用`char`（默认为`" "） |'
- en: '| `s.count(sub, [start, [end]])` | Count `sub` in `s` between start and end
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(sub, [start, [end]])` | 计算`sub`在`start`和`end`之间的`s`中出现次数 |'
- en: '| `s.decode(encoding, errors= ''strict'')` | Encode a (byte) string into a
    Unicode string |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `s.decode(encoding, errors= ''strict'')` | 将（字节）字符串解码为Unicode字符串 |'
- en: '| `s.encode(encoding, errors= ''strict'')` | Encode a (Unicode) string into
    a byte string |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `s.encode(encoding, errors= ''strict'')` | 将（Unicode）字符串编码为字节字符串 |'
- en: '| `s.endswith(sub)` | Check for a suffix |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `s.endswith(sub)` | 检查是否有后缀 |'
- en: '| `s.expandtabs( tabsize=8)` | Replaces tabs with spaces |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `s.expandtabs( tabsize=8)` | 用空格替换制表符 |'
- en: '| `s.find(sub, [start, [end]])` | Find substring or return `-1` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `s.find(sub, [start, [end]])` | 查找子字符串或返回`-1` |'
- en: '| `s.format(*args, **kw)` | Format string |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `s.format(*args, **kw)` | 格式化字符串 |'
- en: '| `s.index(sub, [start, [end]])` | Find substring or raise `ValueError` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `s.index(sub, [start, [end]])` | 查找子字符串或引发`ValueError` |'
- en: '| `s.isalnum()` | Boolean if alphanumeric |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `s.isalnum()` | 是否为字母数字 |'
- en: '| `s.isalpha()` | Boolean if alphabetic |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `s.isalpha()` | 是否为字母 |'
- en: '| `s.isdecimal()` | Boolean if decimal |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdecimal()` | 是否为十进制数 |'
- en: '| `s.isdigit()` | Boolean if digit |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdigit()` | 是否为数字 |'
- en: '| `s.isidentifier()` | Boolean if valid identifier |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `s.isidentifier()` | 是否为有效标识符 |'
- en: '| `s.islower()` | Boolean if lowercase |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `s.islower()` | 是否为小写 |'
- en: '| `s.isspace()` | Boolean if whitespace |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `s.isspace()` | 是否为空格 |'
- en: '| `s.istitle()` | Boolean if titlecased |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `s.istitle()` | 是否为标题化 |'
- en: '| `s.isupper()` | Boolean if uppercased |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `s.isupper()` | 是否为大写 |'
- en: '| `s.join(iterable)` | Return a string inserted between sequence |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `s.join(iterable)` | 返回插入在序列之间的字符串 |'
- en: '| `s.ljust(w, [char])` | Left justify in w spaces with `char` (default `''
    ''`) |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `s.ljust(w, [char])` | 在`w`个空格中左对齐，使用`char`（默认为`'' ''`） |'
- en: '| `s.lower()` | Lowercase |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `s.lower()` | 小写 |'
- en: '| `s.lstrip([chars])` | Left strip `chars` (default spacing). |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `s.lstrip([chars])` | 左侧去除`chars`（默认为空格） |'
- en: '| `s.partition(sub)` | Split string at first occurrence of substring, return
    `(before, sub, after)` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `s.partition(sub)` | 在第一次出现子字符串处拆分字符串，返回`(before, sub, after)` |'
- en: '| `s.replace(old, new, [count])` | Replace substring with new string |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `s.replace(old, new, [count])` | 用新字符串替换子字符串 |'
- en: '| `s.rfind(sub, [start, [end]])` | Find rightmost substring or return `-1`
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `s.rfind(sub, [start, [end]])` | 查找最右侧子字符串或返回`-1` |'
- en: '| `s.rindex(sub, [start, [end]])` | Find rightmost substring or raise `ValueError`
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `s.rindex(sub, [start, [end]])` | 查找最右侧子字符串或引发`ValueError` |'
- en: '| `s.rjust(w, [char)` | Right justify in w spaces with char (default `" "`)
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `s.rjust(w, [char)` | 在`w`个空格中右对齐，使用`char`（默认为`" "） |'
- en: '| `s.rpartition(sub)` | Rightmost partition |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `s.rpartition(sub)` | 最右侧分区 |'
- en: '| `s.rsplit([sep, [maxsplit=-1])` | Rightmost split by sep (defaults to whitespace)
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `s.rsplit([sep, [maxsplit=-1])` | 由分隔符右侧拆分（默认为空格） |'
- en: '| `s.rstrip([chars])` | Right strip |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `s.rstrip([chars])` | 右侧去除 |'
- en: '| `s.split([sep, [maxsplit=-1]])` | Split a string into sequence around substring
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `s.split([sep, [maxsplit=-1]])` | 将字符串分割成围绕子字符串的序列 |'
- en: '| `s.splitlines( keepends=False)` | Break string at line boundaries |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `s.splitlines( keepends=False)` | 在行边界处断开字符串 |'
- en: '| `s.startswith( prefix, [start, [end]])` | Check for prefix |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `s.startswith( prefix, [start, [end]])` | 检查是否有前缀 |'
- en: '| `s.strip([chars])` | Remove leading and trailing whitespace (default) or
    `chars` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `s.strip([chars])` | 移除前导和尾随空格（默认）或`chars` |'
- en: '| `s.swapcase()` | Swap casing of string |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `s.swapcase()` | 交换字符串大小写 |'
- en: '| `s.title()` | Titlecase string |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `s.title()` | 标题化字符串 |'
- en: '| `s.translate(table)` | Use a translation table to replace strings |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `s.translate(table)` | 使用翻译表替换字符串 |'
- en: '| `s.upper()` | Uppercase |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `s.upper()` | 大写 |'
- en: '| `s.zfill(width)` | Left fill with `0` so string fills `width` (no truncation)
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `s.zfill(width)` | 左侧填充`0`，使字符串填充到`width`（不截断） |'
- en: Lists
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'Lists are ordered mutable sequences:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序的可变序列：
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `in` operator is useful for checking membership on sequences:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`操作符对于在序列上检查成员资格很有用：'
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we need the index number during iteration, the `enumerate` function gives
    us a tuple of index, item pairs:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在迭代过程中获取索引号，`enumerate`函数会给我们一个索引、项对的元组：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can do index operations on most sequences:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数序列还支持索引操作：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also do *slicing* operations on most sequences:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数序列也支持*切片*操作：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: List Operations
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表操作
- en: '| Operation | Provided By | Result |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `l + l2` | `__add__` | List concatenation (see `.extend`) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `l + l2` | `__add__` | 列表连接（参见`.extend`） |'
- en: '| `"name" in l` | `__contains__` | Membership |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `"name" in l` | `__contains__` | 成员关系 |'
- en: '| `del l[idx]` | `__del__` | Remove item at index `idx` (see `.pop`) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `del l[idx]` | `__del__` | 删除索引`idx`处的项目（参见`.pop`） |'
- en: '| `l == l2` | `__eq__` | Equality |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `l == l2` | `__eq__` | 相等性 |'
- en: '| `"{}".format(l)` | `__format__` | String format of list |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `"{}".format(l)` | `__format__` | 列表的字符串格式 |'
- en: '| `l >= l2` | `__ge__` | Greater or equal. Compares items in lists from left
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `l >= l2` | `__ge__` | 大于或等于。从左边比较列表中的项目 |'
- en: '| `l[idx]` | `__getitem__` | Index operation |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `l[idx]` | `__getitem__` | 索引操作 |'
- en: '| `l > l2` | `__gt__` | Greater. Compares items in lists from left |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `l > l2` | `__gt__` | 大于。从左边比较列表中的项目 |'
- en: '| No hash | `__hash__` | Set to `None` to ensure you can''t insert in dictionary
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 无哈希 | `__hash__` | 设为`None`以确保无法在字典中插入 |'
- en: '| `l += l2` | `__iadd__` | Augmented (mutates `l`) concatenation |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `l += l2` | `__iadd__` | 增量（修改`l`）连接 |'
- en: '| `l *= 3` | `__imul__` | Augmented (mutates `l`) repetition |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `l *= 3` | `__imul__` | 增量（修改`l`）重复 |'
- en: '| `for thing in l:` | `__iter__` | Iteration |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `for thing in l:` | `__iter__` | 迭代 |'
- en: '| `l <= l2` | `__le__` | Less than or equal. Compares items in lists from left
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `l <= l2` | `__le__` | 小于或等于。从左边比较列表中的项目 |'
- en: '| `len(l)` | `__len__` | Length |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `len(l)` | `__len__` | 长度 |'
- en: '| `l < l2` | `__lt__` | Less than. Compares items in lists from left |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `l < l2` | `__lt__` | 小于。从左边比较列表中的项目 |'
- en: '| `l * 2` | `__mul__` | Repetition |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `l * 2` | `__mul__` | 重复 |'
- en: '| `l != l2` | `__ne__` | Not equal |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `l != l2` | `__ne__` | 不等于 |'
- en: '| `repr(l)` | `__repr__` | Programmer friendly string |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `repr(l)` | `__repr__` | 程序员友好的字符串 |'
- en: '| `reversed(l)` | `__reversed__` | Reverse |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `reversed(l)` | `__reversed__` | 反转 |'
- en: '| `foo * l` | `__rmul__` | Called if `foo` doesn''t implement `__mul__` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `foo * l` | `__rmul__` | 如果`foo`没有实现`__mul__`则调用 |'
- en: '| `l[idx] = ''bar''` | `__setitem__` | Index operation to set value |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `l[idx] = ''bar''` | `__setitem__` | 索引操作以设置值 |'
- en: '| `l.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `l.__sizeof__()` | `__sizeof__` | 内部表示的字节数 |'
- en: '| `str(l)` | `__str__` | User friendly string |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `str(l)` | `__str__` | 用户友好的字符串 |'
- en: List Methods
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表方法
- en: '| Operation | Result |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `l.append(item)` | Append `item` to end |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `l.append(item)` | 在末尾追加`item` |'
- en: '| `l.clear()` | Empty list (mutates `l`) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `l.clear()` | 空列表（修改`l`） |'
- en: '| `l.copy()` | Shallow copy |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `l.copy()` | 浅拷贝 |'
- en: '| `l.count(thing)` | Number of occurrences of `thing` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `l.count(thing)` | `thing`出现的次数 |'
- en: '| `l.extend(l2)` | List concatenation (mutates `l`) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `l.extend(l2)` | 列表连接（修改`l`） |'
- en: '| `l.index(thing)` | Index of `thing` else `ValueError` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `l.index(thing)` | `thing`的索引，否则`ValueError` |'
- en: '| `l.insert(idx, bar)` | Insert `bar` at index `idx` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `l.insert(idx, bar)` | 在索引`idx`处插入`bar` |'
- en: '| `l.pop([idx])` | Remove last item or item at `idx` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `l.pop([idx])` | 删除最后一项或索引`idx`处的项 |'
- en: '| `l.remove(bar)` | Remove first instance of `bar` else `ValueError` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `l.remove(bar)` | 删除首次出现的`bar`，否则`ValueError` |'
- en: '| `l.reverse()` | Reverse (mutates `l`) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `l.reverse()` | 反转（修改`l`） |'
- en: '| `l.sort([key=], reverse=False)` | In-place sort, by optional `key` function
    (mutates `l`) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `l.sort([key=], reverse=False)` | 就地排序，可选的`key`函数（修改`l`） |'
- en: Dictionaries
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionaries are mutable mappings of keys to values. Keys must be hashable,
    but values can be any object:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是可变的键值映射。键必须是可散列的，但值可以是任何对象：
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Magic Dictionary Methods
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术字典方法
- en: '| Operation | Provided By | Result |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `key in d` | `__contains__` | Membership |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `key in d` | `__contains__` | 成员关系 |'
- en: '| `del d[key]` | `__delitem__` | Delete key |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `del d[key]` | `__delitem__` | 删除键 |'
- en: '| `d == d2` | `__eq__` | Equality. Dicts are equal or not equal |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `d == d2` | `__eq__` | 相等性。字典相等或不相等 |'
- en: '| `"{}".format(d)` | `__format__` | String format of dict |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `"{}".format(d)` | `__format__` | 字典的字符串格式 |'
- en: '| `d[key]` | `__getitem__` | Get value for `key` (see `.get`) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `d[key]` | `__getitem__` | 获取`key`的值（参见`.get`） |'
- en: '| `for key in d:` | `__iter__` | Iteration over keys |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `for key in d:` | `__iter__` | 遍历键 |'
- en: '| `len(d)` | `__len__` | Length |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `len(d)` | `__len__` | 长度 |'
- en: '| `d != d2` | `__ne__` | Not equal |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `d != d2` | `__ne__` | 不等于 |'
- en: '| `repr(d)` | `__repr__` | Programmer friendly string |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `repr(d)` | `__repr__` | 程序员友好的字符串 |'
- en: '| `d[key] = value` | `__setitem__` | Set `value` for `key` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `d[key] = value` | `__setitem__` | 为`key`设置`value` |'
- en: '| `d.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `d.__sizeof__()` | `__sizeof__` | 内部表示的字节 |'
- en: Dictionary Methods
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 字典方法
- en: '| Operation | Result |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `d.clear()` | Remove all items (mutates `d`) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `d.clear()` | 删除所有项目（改变`d`） |'
- en: '| `d.copy()` | Shallow copy |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `d.copy()` | 浅复制 |'
- en: '| `d.fromkeys(iter, value=None)` | Create dict from iterable with values set
    to value |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `d.fromkeys(iter, value=None)` | 从可迭代对象创建字典，并将值设置为指定值 |'
- en: '| `d.get(key, [default])` | Get value for `key` or return default (`None`)
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `d.get(key, [default])` | 获取`key`的值或返回默认值（`None`�� |'
- en: '| `d.items()` | List of (key, value) pairs |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `d.items()` | 键值对列表 |'
- en: '| `d.keys()` | List of keys |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `d.keys()` | 键列表 |'
- en: '| `d.pop(key, [default])` | Return value for key or default (`KeyError` if
    not set) |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `d.pop(key, [default])` | 返回键的值或默认值（如果未设置则为`KeyError`） |'
- en: '| `d.popitem()` | Return arbitrary (key, value) tuple. `KeyError` if empty
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `d.popitem()` | 返回任意（键，值）元组。如果为空则为`KeyError` |'
- en: '| `d.setdefault(k, [default])` | Does `d.get(k, default)`. If `k` missing,
    sets to default |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `d.setdefault(k, [default])` | 执行`d.get(k, default)`。如果缺少`k`，则设置为默认值 |'
- en: '| `d.values()` | List of values |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `d.values()` | 值列表 |'
- en: Tuples
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are immutable sequences. Typically they are used to store *record* type
    data:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是不可变序列。通常用于存储*记录*类型数据：
- en: '[PRE14]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that parentheses aren''t usually required:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通常不需要括号：
- en: '[PRE15]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Named tuples can be used in place of normal tuples and allow context (or names)
    to be added to positional members. The syntax for creating them is a little different
    because we are dynamically creating a class first (hence the capitalized variable):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组可用于替代普通元组，并允许向位置成员添加上下文（或名称）。创建它们的语法有点不同，因为我们首先动态创建一个类（因此变量大写）：
- en: '[PRE16]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can access members by position or name (name allows us to be more explicit):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过位置或名称访问成员（名称使我们更加明确）：
- en: '[PRE17]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tuple Methods
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 元组方法
- en: '| Operation | Provided | Result |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 由此提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `t + t2` | `__add__` | Tuple concatenation |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `t + t2` | `__add__` | 元组连接 |'
- en: '| `"name" in t` | `__contains__` | Membership |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `"name" in t` | `__contains__` | 成员资格 |'
- en: '| `t == t2` | `__eq__` | Equality |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `t == t2` | `__eq__` | 相等 |'
- en: '| `"{}".format(t)` | `__format__` | String format of tuple |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `"{}".format(t)` | `__format__` | 元组的字符串格式 |'
- en: '| `t >= t2` | `__ge__` | Greater or equal. Compares items in tuple from left
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `t >= t2` | `__ge__` | 大于或等于。从左边比较元组中的项目 |'
- en: '| `t[idx]` | `__getitem__` | Index operation |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `t[idx]` | `__getitem__` | 索引操作 |'
- en: '| `t > t2` | `__gt__` | Greater. Compares items in tuple from left |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `t > t2` | `__gt__` | 大于。从左边比较元组中的项目 |'
- en: '| `hash(t)` | `__hash__` | For set/dict insertion |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `hash(t)` | `__hash__` | 用于集合/字典插入 |'
- en: '| `for thing in t:` | `__iter__` | Iteration |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `for thing in t:` | `__iter__` | 迭代 |'
- en: '| `t <= t2` | `__le__` | Less than or equal. Compares items in tuple from left
    |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `t <= t2` | `__le__` | 小于或等于。从左边比较元组中的项目 |'
- en: '| `len(t)` | `__len__` | Length |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `len(t)` | `__len__` | 长度 |'
- en: '| `t < t2` | `__lt__` | Less than. Compares items in tuple from left |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `t < t2` | `__lt__` | 小于。从左边比较元组中的项目 |'
- en: '| `t * 2` | `__mul__` | Repetition |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `t * 2` | `__mul__` | 重复 |'
- en: '| `t != t2` | `__ne__` | Not equal |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `t != t2` | `__ne__` | 不相等 |'
- en: '| `repr(t)` | `__repr__` | Programmer friendly string |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `repr(t)` | `__repr__` | 程序员友好的字符串 |'
- en: '| `foo * t` | `__rmul__` | Called if `foo` doesn''t implement `__mul__` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `foo * t` | `__rmul__` | 如果`foo`没有实现`__mul__`则调用 |'
- en: '| `t.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `t.__sizeof__()` | `__sizeof__` | 内部表示的字节 |'
- en: '| `str(t)` | `__str__` | User friendly string |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `str(t)` | `__str__` | 用户友好的字符串 |'
- en: Tuple Methods
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 元组方法
- en: '| Operation | Result |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `t.count(item)` | Count of item |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `t.count(item)` | 项目的计数 |'
- en: '| `t.index(thing)` | Index of `thing` else `ValueError` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `t.index(thing)` | `thing`的索引，否则`ValueError` |'
- en: Sets
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set is a mutable unordered collection that cannot contain duplicates. Sets
    are used to remove duplicates and test for membership:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一种可变的无序集合，不能包含重复项。集合用于去除重复项和测试成员资格：
- en: '[PRE18]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Sets are useful because they provide *set operations*, such as union (`|`),
    intersection (`&`), difference (`-`), and xor (`^`):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 集合非常有用，因为它们提供*集合操作*，如并集（`|`）、交集（`&`）、差集（`-`）和异或（`^`）：
- en: '[PRE19]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is no literal syntax for an empty set. You need to use:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 空集合没有文字语法。您需要使用：
- en: '[PRE20]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Set Methods
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 集合方法
- en: '| Operation/Method | Provided By | Result |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 操作/方法 | 由此提供 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `s & s2` | `__and__` | Set intersection (see `.intersection`) |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `s & s2` | `__and__` | 集合交集（参见 `.intersection`） |'
- en: '| `"name" in s` | `__contains__` | Membership |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `"name" in s` | `__contains__` | 成员关系 |'
- en: '| `s == s2` | `__eq__` | Equality. Sets are equal or not equal |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `s == s2` | `__eq__` | 相等性。集合是否相等或不相等 |'
- en: '| `"{}".format(s)` | `__format__` | String format of set |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `"{}".format(s)` | `__format__` | 集合的字符串格式 |'
- en: '| `s >= s2` | `__ge__` | `s` in `s2` (see `.issuperset`) |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `s >= s2` | `__ge__` | `s` 包含于 `s2` 中（参见 `.issuperset`） |'
- en: '| `s > s2` | `__gt__` | Greater. Always `False`` |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `s > s2` | `__gt__` | 大于。始终为 `False` |'
- en: '| No hash | `__hash__` | Set to `None` to ensure you can''t insert in dictionary
    |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 没有哈希 | `__hash__` | 设置为 `None` 以确保不能将其插入字典 |'
- en: '| `s &= s2` | `__iand__` | Augmented (mutates `s`) intersection (see `.intersection_udpate`)
    |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `s &= s2` | `__iand__` | 增强（修改`s`）交集（参见 `.intersection_udpate`） |'
- en: '| `s &#124;= s2` | `__ior__` | Augmented (mutates `s`) union (see `.update`)
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `s &#124;= s2` | `__ior__` | 增强（修改`s`）联合（参见 `.update`） |'
- en: '| `s -= s2` | `__isub__` | Augmented (mutates `s`) difference (see `.difference_update`)
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `s -= s2` | `__isub__` | 增强（修改`s`）差集（参见 `.difference_update`） |'
- en: '| `for thing in s:` | `__iter__` | Iteration |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `for thing in s:` | `__iter__` | 迭代 |'
- en: '| `s ^= s2` | `__ixor__` | Augmented (mutates `s`) xor (see `.symmetric_difference_update`)
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `s ^= s2` | `__ixor__` | 增强（修改`s`）异或（参见 `.symmetric_difference_update`） |'
- en: '| `s <= s2` | `__le__` | `s2` in `s` (see `.issubset`) |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `s <= s2` | `__le__` | `s2` 包含于 `s` 中（参见 `.issubset`） |'
- en: '| `len(s)` | `__len__` | Length |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `len(s)` | `__len__` | 长度 |'
- en: '| `s < s2` | `__lt__` | Less than. Always `False` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `s < s2` | `__lt__` | 小于。始终为 `False` |'
- en: '| `s != s2` | `__ne__` | Not equal |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `s != s2` | `__ne__` | 不相等 |'
- en: '| `s &#124; s2` | `__or__` | Set union (see `.union`) |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `s &#124; s2` | `__or__` | 集合并集（参见 `.union`） |'
- en: '| `foo & s` | `__rand__` | Called if `foo` doesn''t implement `__and__` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `foo & s` | `__rand__` | 如果 `foo` 没有实现 `__and__` 则调用 |'
- en: '| `repr(s)` | `__repr__` | Programmer friendly string |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `repr(s)` | `__repr__` | 程序员友好的字符串 |'
- en: '| `foo &#124; s` | `__ror__` | Called if `foo` doesn''t implement `__or__`
    |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `foo &#124; s` | `__ror__` | 如果 `foo` 没有实现 `__or__` 则调用 |'
- en: '| `foo - s` | `__rsub__` | Called if `foo` doesn''t implement `__sub__` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `foo - s` | `__rsub__` | 如果 `foo` 没有实现 `__sub__` 则调用 |'
- en: '| `foo ^ s` | `__rxor__` | Called if `foo` doesn''t implement `__xor__` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `foo ^ s` | `__rxor__` | 如果 `foo` 没有实现 `__xor__` 则调用 |'
- en: '| `s.__sizeof__()` | `__sizeof__` | Bytes for internal representation |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `s.__sizeof__()` | `__sizeof__` | 内部表示的字节 |'
- en: '| `str(s)` | `__str__` | User friendly string |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `str(s)` | `__str__` | 用户友好的字符串 |'
- en: '| `s - s2` | `__sub__` | Set difference (see `.difference`) |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `s - s2` | `__sub__` | 集合差集（参见 `.difference`） |'
- en: '| `s ^ s2` | `__xor__` | Set xor (see `.symmetric_difference`) |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `s ^ s2` | `__xor__` | 集合异或（参见 `.symmetric_difference`） |'
- en: Set Methods
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 集合方法
- en: '| Operation/Method | Result |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 操作/方法 | 结果 |'
- en: '| --- | --- |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `s.add(item)` | Add `item` to `s` (mutates `s`) |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `s.add(item)` | 将 `item` 添加到 `s` 中（修改`s`） |'
- en: '| `s.clear()` | Remove elements from `s` (mutates `s`) |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `s.clear()` | 从`s`中移除元素（修改`s`） |'
- en: '| `s.copy()` | Shallow copy |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `s.copy()` | 浅拷贝 |'
- en: '| `s.difference(s2)` | Return set with elements from `s` and not `s2` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `s.difference(s2)` | 返回集合中存在于`s`而不在`s2`中的元素的集合 |'
- en: '| `s.difference_update(s2)` | Remove `s2` items from `s` (mutates `s`) |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `s.difference_update(s2)` | 从`s`中移除`s2`的项目（修改`s`） |'
- en: '| `s.discard(item)` | Remove `item` from s (mutates `s`). No error on missing
    `item` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `s.discard(item)` | 从`s`中移除 `item`（修改`s`）。不会在找不到 `item` 时引发错误 |'
- en: '| `s.intersection(s2)` | Return set with elements from both sets |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `s.intersection(s2)` | 返回两个集合中都存在的元素的集合 |'
- en: '| `s.intersection_update(s2)` | Update `s` with members of `s2` (mutates `s`)
    |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `s.intersection_update(s2)` | 使用`s2`的成员更新`s`（修改`s`） |'
- en: '| `s.isdisjoint(s2)` | `True` is there is no intersection |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdisjoint(s2)` | 如果没有交集则为 `True` |'
- en: '| `s.issubset(s2)` | All elements of `s` in `s2` |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `s.issubset(s2)` | `s` 中的所有元素都在 `s2` 中 |'
- en: '| `s.issuperset(s2)` | All elements of `s2` in `s2` |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `s.issuperset(s2)` | `s2` 中的所有元素都在 `s` 中 |'
- en: '| `s.pop()` | Remove arbitrary item from s (mutates `s`). `KeyError` on missing
    `item` |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop()` | 从`s`中移除任意项（修改`s`）。找不到 `item` 时引发 `KeyError` |'
- en: '| `s.remove(item)` | Remove `item` from s (mutates `s`). `KeyError` on missing
    `item` |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(item)` | 从`s`中移除 `item`（修改`s`）。找不到 `item` 时引发 `KeyError` |'
- en: '| `s.symmetric_difference(s2)` | Return set with elements only in one of the
    sets |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `s.symmetric_difference(s2)` | 返回仅存在于其中一个集合中的元素的集合 |'
- en: '| `s.symmetric_difference_update(s2)` | Update `s` with elements only in one
    of the sets (mutates `s`) |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `s.symmetric_difference_update(s2)` | 使用仅存在于其中一个集合中的元素更新`s`（修改`s`） |'
- en: '| `s.union(s2)` | Return all elements of both sets |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `s.union(s2)` | 返回两个集合的所有元素 |'
- en: '| `s.update(s2)` | Update `s` with all elements of both sets (mutates `s`)
    |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `s.update(s2)` | 使用两个集合的所有元素更新`s`（修改`s`） |'
- en: Built in Functions
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置函数
- en: 'In the default namespace you have access to various callables:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认命名空间中，您可以访问各种可调用对象：
- en: Built in callables
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 内置可调用对象
- en: '| Operation | Result |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abs(x)` | Absolute value protocol (call `x.__abs__()`) |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `abs(x)` | 绝对值协议（调用`x.__abs__()`） |'
- en: '| `all(seq)` | Boolean check if all items in `seq` are truthy |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `all(seq)` | 布尔检查`seq`中所有项目是否为真值 |'
- en: '| `any(seq)` | Boolean check if at least one item in `seq` is truthy |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `any(seq)` | 布尔检查`seq`中是否至少有一个项目为真值 |'
- en: '| `apply(callable, [args, [kwargs])` | Call `callable(*args, **kwargs)` |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `apply(callable, [args, [kwargs])` | 调用`callable(*args, **kwargs)` |'
- en: '| `bin(i)` | String containing binary version of number (`int(bin(i), 2)` to
    reverse) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `bin(i)` | 包含数字的二进制版本的字符串（`int(bin(i), 2)`可逆） |'
- en: '| `bool(x)` | Boolean protocol (call `x.__nonzero__()` then `x.__len__()`)
    |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `bool(x)` | 布尔协议（调用`x.__nonzero__()`然后`x.__len__()`） |'
- en: '| `buffer(obj, [offset, [size])` | Create buffer object from `obj` |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `buffer(obj, [offset, [size])` | 从`obj`创建缓冲区对象 |'
- en: '| `bytearray(x)` | Create a mutable bytearray from iterable of ints, text string,
    bytes, an integer, or pass nothing for an empty bytearray |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `bytearray(x)` | 从整数可迭代对象、文本字符串、字节、整数创建可变字节数组，或者不传任何内容以创建空字节数组 |'
- en: '| `bytes(x)` | Create an immutable bytes from iterable of ints, text string,
    bytes, an integer, or pass nothing for an empty bytes |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `bytes(x)` | 从整数可迭代对象、文本字符串、字节、整数创建不可变字节，或者不传任何内容以创建空字节 |'
- en: '| `callable(x)` | Boolean check if you can do `x()` (ie `x.__call__` exists)
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `callable(x)` | 检查是否可以执行`x()`（即`x.__call__`存在） |'
- en: '| `chr(i)` | Convert integer codepoint to Unicode string (`ord(chr(i))` to
    reverse) |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `chr(i)` | 将整数码点转换为Unicode字符串（`ord(chr(i))`可逆） |'
- en: '| `@classmethod` | Use to decorate a method so you can invoke it on the class
    |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `@classmethod` | 用于装饰方法，以便可以在类上调用它 |'
- en: '| `cmp(a, b)` | -1, 0, or 1 if `a` <, == or > `b` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `cmp(a, b)` | 如果`a` <、= 或 > `b`，则返回-1、0或1 |'
- en: '| `coerce(num1, num2)` | Coerce nums to common type |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `coerce(num1, num2)` | 将数字强制转换为公共类型 |'
- en: '| `compile(source, fname, mode)` | Compile `source` to code (`fname` used for
    error, `mode` is `exec`: module, `single`: statement, `eval`: expression). Can
    run `eval(code)` on expression, `exec(code)` on statement |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `compile(source, fname, mode)` | 将`source`编译为代码（`fname`用于错误，`mode`为`exec`：模块，`single`：语句，`eval`：表达式）。可以在表达式上运行`eval(code)`，在语句上运行`exec(code)`
    |'
- en: '| `complex(i, y)` | Create complex number |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `complex(i, y)` | 创建复数 |'
- en: '| `copyright` | Python copyright string |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `copyright` | Python版权字符串 |'
- en: '| `credits` | Python credits string |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `credits` | Python鸣谢字符串 |'
- en: '| `delattr(obj, attr)` | Remove attribute from `obj` (`del obj.attr`) |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `delattr(obj, attr)` | 从`obj`中删除属性（`del obj.attr`） |'
- en: '| `dict([x])` | Create a dictionary from a mapping, iterable of k,v tuples,
    named parameters, or pass nothing for an empty dictionary |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `dict([x])` | 从映射、k、v元组的可迭代对象、命名参数创建字典，或者不传任何内容以创建空字典 |'
- en: '| `dir([obj])` | List attributes of `obj`, or names in current namespace if
    no `obj` provided |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `dir([obj])` | 列出`obj`的属性，如果没��提供`obj`，则列出当前命名空间中的名称 |'
- en: '| `divmod(num, denom)` | Return tuple pair of `num//denom` and `num%denom`
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `divmod(num, denom)` | 返回`num//denom`和`num%denom`的元组对 |'
- en: '| `enumerate(seq, [start])` | Return iterator of index, item tuple pairs. Index
    begins at `start` or `0` (default) |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `enumerate(seq, [start])` | 返回索引、项目元组对的迭代器。索引从`start`或`0`（默认）开始 |'
- en: '| `eval(source, globals=None, locals=None)` | Run `source` (expression string
    or result of `compile`) with globals and locals |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `eval(source, globals=None, locals=None)` | 使用全局变量和局部变量运行`source`（表达式字符串或`compile`的结果）
    |'
- en: '| `execfile(filename, globals=None, locals=None)` | Run code in `filename`
    with globals and locals |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `execfile(filename, globals=None, locals=None)` | 使用全局变量和局部变量在`filename`中运行代码
    |'
- en: '| `exit(code)` | Exit Python interpreter and return code |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `exit(code)` | 退出Python解释器并返回代码 |'
- en: '| `file(name, [mode, [buffering]])` | Open a file with mode |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `file(name, [mode, [buffering]])` | 以指定模式打开文件 |'
- en: '| `filter([function], seq)` | Return iterator of items where `function(item)`
    is truthy (or `item` is truthy if `function` is missing) |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `filter([function], seq)` | 返回满足`function(item)`为真值的项目的迭代器（如果缺少`function`，则`item`为真值）
    |'
- en: '| `float(x)` | Convert string or number to float (call `x.__float__()`) |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `float(x)` | 将字符串或数字转换为浮点数（调用`x.__float__()`） |'
- en: '| `format(obj, fmt)` | Format protocol (call `obj.__format__(fmt)`) |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `format(obj, fmt)` | 格式化协议（调用`obj.__format__(fmt)`） |'
- en: '| `frozenset([seq])` | Create `frozenset` from `seq` (empty if missing) |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `frozenset([seq])` | 从`seq`创建`frozenset`（如果缺少则为空） |'
- en: '| `getattr(obj, attr)` | Get attribute from `obj` (`obj.attr`) |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `getattr(obj, attr)` | 从`obj`获取属性（`obj.attr`） |'
- en: '| `globals()` | Return *mutable* dictionary with current global variables |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `globals()` | 返回当前全局变量的*可变*字典 |'
- en: '| `hasattr(obj, attr)` | Check if attribute on `obj` (`obj.attr` doesn''t throw
    `AttributeError`) |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `hasattr(obj, attr)` | 检查`obj`上的属性是否存在（`obj.attr`不会引发`AttributeError`） |'
- en: '| `hash(x)` | Hash value protocol for object (call `x.__hash__()`) |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `hash(x)` | 对象的哈希值协议（调用`x.__hash__()`） |'
- en: '| `help([x])` | Start interactive help (if no `x`), or print documentation
    for `x` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `help([x])` | 启动交互式帮助（如果没有`x`），或打印`x`的文档 |'
- en: '| `hex(i)` | String containing hexadecimal version of number (`int(hex(i),
    16)` to reverse) |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `hex(i)` | 包含数字的十六进制版本的字符串（`int(hex(i), 16)`可逆转） |'
- en: '| `id(x)` | Identity of `x` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `id(x)` | `x`的标识 |'
- en: '| `input([prompt])` | Read string from standard input |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `input([prompt])` | 从标准输入读取字符串 |'
- en: '| `int(x, [base=10])` | Create integer from number or string |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `int(x, [base=10])` | 从数字或字符串创建整数 |'
- en: '| `intern(s)` | Intern a string in global table |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `intern(s)` | 在全局表中国际化字符串 |'
- en: '| `isinstance(obj, class_or_tuple)` | Boolean check if `obj` is an instance
    or subclass of `class_or_tuple` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `isinstance(obj, class_or_tuple)` | 检查`obj`是否是`class_or_tuple`的实例或子类的布尔值
    |'
- en: '| `issubclass(cls, class_or_tuple)` | Boolean check if `cls` is the class or
    derived from `class_or_tuple` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `issubclass(cls, class_or_tuple)` | 检查`cls`是否是类或派生自`class_or_tuple`的布尔值 |'
- en: '| `iter(seq)` | Iteration protocol (call `seq.__iter__()`) |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `iter(seq)` | 迭代协议（调用`seq.__iter__()`） |'
- en: '| `len(seq)` | Number of items in sequence |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `len(seq)` | 序列中的项目数 |'
- en: '| `license()` | Display Python licenses |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `license()` | 显示Python许可证 |'
- en: '| `list([seq])` | Convert `seq` to list (empty if missing) |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `list([seq])` | 将`seq`转换为列表（如果缺失则为空） |'
- en: '| `locals()` | Return dictionary of local attributes (unlike `globals`, not
    guaranteed to update namespace when mutated) |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `locals()` | 返回本地属性的字典（不像`globals`，在变异时不保证更新命名空间） |'
- en: '| `long(num)` | Coerce `num` to a long |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `long(num)` | 将`num`强制转换为长整型 |'
- en: '| `map(function, *seqs)` | Call `function(item)` for item in `seqs` (if single
    sequence) or `function(seqs[0][0], seqs[1][0]...)` |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `map(function, *seqs)` | 对`seqs`中的项目调用`function(item)`（如果是单个序列）或`function(seqs[0][0],
    seqs[1][0]...)` |'
- en: '| `max(seq, *, [default], [key])` | Return maximum value from `seq`. `default`
    (value if empty `seq`) and `key` (function to determine magnitude) are keyword
    parameters. |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `max(seq, *, [default], [key])` | 从`seq`中返回最大值。`default`（如果`seq`为空时的值）和`key`（确定大小的函数）是关键字参数。
    |'
- en: '| `memoryview(obj)` | Create `memoryview` from `obj` |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `memoryview(obj)` | 从`obj`创建`memoryview` |'
- en: '| `min(seq, *, [default], [key])` | Return minimum value from `seq`. `default`
    (value if empty `seq`) and `key` (function to determine magnitude) are keyword
    parameters. |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `min(seq, *, [default], [key])` | 从`seq`中返回最小值。`default`（如果`seq`为空时的值）和`key`（确定大小的函数）是关键字参数。
    |'
- en: '| `next(iter, [default])` | Get next item from iteration protocol (call `iter.next()`),
    if `default` provide return instead of raising `StopIteration` |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `next(iter, [default])` | 从迭代协议中获取下一个项目（调用`iter.next()`），如果提供`default`，则返回而不是引发`StopIteration`
    |'
- en: '| `object` | Root base type |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `object` | 根基类型 |'
- en: '| `oct(i)` | String containing octal version of number (`int(oct(i), 8)` to
    reverse) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `oct(i)` | 包含数字的八进制版本的字符串（`int(oct(i), 8)`可逆转） |'
- en: '| `open(filename, [mode], [buffereing])` | Open a file |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `open(filename, [mode], [buffereing])` | 打开文件 |'
- en: '| `ord(s)` | Convert Unicode string to integer codepoint (`chr(ord(s))` to
    reverse) |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `ord(s)` | 将Unicode字符串转换为整数码点（`chr(ord(s))`可逆转） |'
- en: '| `pow(num, exp, [z])` | Power protocol (call `num.__pow__(exp, z)`) (`num
    ** exp` or `num ** exp % z`) |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `pow(num, exp, [z])` | 幂协议（调用`num.__pow__(exp, z)`）（`num ** exp`或`num **
    exp % z`） |'
- en: '| `print val, [val2 ...][,]` | Print values to stdout. Print protocol (call
    `val.__str__()`) |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `print val, [val2 ...][,]` | 将值打印到标准输出。打印协议（调用`val.__str__()`） |'
- en: '| `@property` | Decorator to turn a method into an attribute |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `@property` | 将方法转换为属性的装饰器 |'
- en: '| `quit()` | Quit interpreter |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `quit()` | 退出解释器 |'
- en: '| `range([start], stop, [step])` | Return list from `start` (default `0`) to
    `stop - 1`, by `step` increments (default `1`) |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `range([start], stop, [step])` | 返回从`start`（默认为`0`）到`stop - 1`的列表，步长为`step`（默认为`1`）
    |'
- en: '| `raw_input([prompt])` | Read input from user |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `raw_input([prompt])` | 从用户读取输入 |'
- en: '| `reduce(f, seq, [initial])` | Perform reduction by calling `f` on initial
    pair from `seq`, then result with next value. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `reduce(f, seq, [initial])` | 通过在`seq`的初始对上调用`f`来执行减少，然后结果与下一个值一起。 |'
- en: '| `reload(module)` | Reload module (doesn''t swap out existing instances of
    classes from module) |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `reload(module)` | 重新加载模块（不会替换模块中现有类的实例） |'
- en: '| `repr(x)` | Representation protocol (call `x.__repr__()`) |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `repr(x)` | 表示协议（调用`x.__repr__()`） |'
- en: '| `reversed(seq)` | Reverse iterator |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `reversed(seq)` | 反向迭代器 |'
- en: '| `round(num, [ndigits=0])` | Round to `ndigits` protocol (call `num.__round__()`)
    |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `round(num, [ndigits=0])` | 四舍五入到`ndigits`协议（调用`num.__round__()`） |'
- en: '| `set([seq])` | Create `set` from `seq` (empty if missing) |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `set([seq])` | 从`seq`创建`set`（如果缺失则为空） |'
- en: '| `setattr(obj, attr, val)` | Set attribute on `obj` (`obj.attr = val`) |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `setattr(obj, attr, val)` | 在`obj`上设置属性（`obj.attr = val`） |'
- en: '| `slice([start], stop, [step])` | Create `slice` object |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `slice([start], stop, [step])` | 创建`slice`对象 |'
- en: '| `sorted(seq, * [key=None], [reverse=False])` | Sorted list in ascending order
    (use `key` function to customize sort property) |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `sorted(seq, * [key=None], [reverse=False])` | 按升序排列的列表（使用`key`函数自定义排序属性）
    |'
- en: '| `@staticmethod` | Use to decorate a method so you can invoke it on the class
    or instance |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `@staticmethod` | 用于装饰一个方法，以便您可以在类或实例上调用它 |'
- en: '| `str(obj)` | Create string (call `obj.__str__()`) |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `str(obj)` | 创建字符串（调用`obj.__str__()`） |'
- en: '| `str(bytes, [encoding], [errors])` | Create string from bytes (`errors` defaults
    to `strict`) |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `str(bytes, [encoding], [errors])` | 从字节创建字符串（`errors`默认为`strict`） |'
- en: '| `sum(seq, [start=0])` | Sum values from `seq` (use `start` as initial value)
    |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `sum(seq, [start=0])` | 对`seq`中的值求和（使用`start`作为初始值） |'
- en: '| `super(type, [obj])` | Get access to superclass |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `super(type, [obj])` | 获取超类访问权限 |'
- en: '| `tuple([seq])` | Convert `seq` to tuple (empty if missing) |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `tuple([seq])` | 将`seq`转换为元组（如果缺失则为空） |'
- en: '| `type(name, bases, dict)` | Create a new type of `name`, with base classes
    `bases`, and attributes `dict` |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `type(name, bases, dict)` | 创建一个新的`name`类型，具有基类`bases`和属性`dict` |'
- en: '| `type(obj)` | Return type of `obj` |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `type(obj)` | 返回`obj`的类型 |'
- en: '| `unichr(num)` | Return Unicode string from integer `num` |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `unichr(num)` | 从整数`num`返回Unicode字符串 |'
- en: '| `unicode(s)` | Coerce `s` to a Unicode string |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `unicode(s)` | 强制将`s`转换为Unicode字符串 |'
- en: '| `xrange([start], stop, [step])` | Return range object that iterates from
    `start` (default `0`) to `stop - 1`, by `step` increments (default `1`) |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `xrange([start], stop, [step])` | 返回从`start`（默认为`0`）到`stop-1`，以`step`增量（默认为`1`）迭代的范围对象
    |'
- en: '| `zip(seq1, [seq2, ...])` | Return list of tuples of `(seq1[0], seq2[0])`,
    `(seq1[1], seq2[1])`, ... until shortest sequence |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `zip(seq1, [seq2, ...])` | 返回元组列表`(seq1[0], seq2[0])`，`(seq1[1], seq2[1])`，...直到最短序列为止
    |'
- en: Unicode
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode
- en: 'Python 2 represents strings byte sequences. To create a literal Unicode string
    with Unicode characters, we need to put a `u` in front of the string. We can *encode*
    Unicode strings to a series of bytes such as UTF-8\. If we have a normal string
    (bytes), we can *decode* them to a Unicode string:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2表示字符串字节序列。要创建一个带有Unicode字符的文字Unicode字符串，我们需要在字符串前面加上`u`。我们可以*编码*Unicode字符串为一系列字节，比如UTF-8。如果我们有一个普通字符串（字节），我们可以*解码*它们为Unicode字符串：
- en: '[PRE21]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we call `print` we will see the user friendly representation (calling `__str__`
    rather than `__repr__`):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`print`，我们将看到用户友好的表示（调用`__str__`而不是`__repr__`）：
- en: '[PRE22]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you have the Unicode glyph, you can use that directly. Alternatively, you
    can enter a code point using `\u` followed by the 16-bit hex value xxxx. For larger
    code points, use `\U` followed by xxxxxxxx. If you have the Unicode name (obtained
    by consulting tables at unicode.org), you can use the `\N` syntax. The following
    are equivalent:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有Unicode字形，可以直接使用。或者，您可以使用`\u`后跟16位十六进制值xxxx输入代码点。对于更大的代码点，请使用`\U`后跟xxxxxxxx。如果您有Unicode名称（通过���unicode.org上查看表格获得），您可以使用`\N`语法。以下是等效的：
- en: '[PRE23]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![../Images/uniencode2.png](../Images/uniencode2.png)](../Images/uniencode2.png)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/uniencode2.png](../Images/uniencode2.png)](../Images/uniencode2.png)'
- en: Image illustrating *encoding* a Unicode string to a byte representation. In
    this case, we convert to UTF-8\. There are other byte encodings for this string.
    If we have a UTF-8 byte string, we can *decode* it into a Unicode string. Note
    that we should be explicit about the decoding as there are potentially other encodings
    that we could decode to that might give use erroneous data, or *mojibake*.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 描述*编码*Unicode字符串为字节表示的图像。在这种情况下，我们转换为UTF-8。对于这个字符串，还有其他字节编码。如果我们有一个UTF-8字节字符串，我们可以*解码*它为Unicode字符串。请注意，我们应该明确解码，因为可能有其他编码可以解码为可能给我们错误数据或*乱码*的Unicode字符串。
- en: String Formatting
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: Most modern Python code uses the `.format` method (PEP 3101) to create strings
    from other parts. The format method uses `{}` as a placeholder.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代Python代码使用`.format`方法（PEP 3101）从其他部分创建字符串。格式方法使用`{}`作为占位符。
- en: 'Inside of the placeholder we can provide different specifiers:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在占位符内，我们可以提供不同的说明符：
- en: '`{0}` - reference first positional argument'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{0}` - 参考第一个位置参数'
- en: '`{}` - reference implicit positional argument'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}` - 参考隐式位置参数'
- en: '`{result}` - reference keyword argument'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{result}` - 参考关键字参数'
- en: '`{bike.tire}` - reference attribute of argument'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{bike.tire}` - 参考参数的属性'
- en: '`{names[0]}` - reference first element of argument'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{names[0]}` - 参考参数的第一个元素'
- en: '[PRE24]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'or:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE25]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Conversion Flags
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换标志
- en: You can provide a *conversion flag* inside the placeholder.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在占位符内提供*转换标志*。
- en: '`!s` - Call `str()` on argument'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!s` - 对参数调用`str()`'
- en: '`!r` - Call `repr()` on argument'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!r` - 对参数调用`repr()`'
- en: '[PRE26]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Format Specification
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式规范
- en: 'You can provide a format specification following a colon. The grammar for format
    specification is as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在冒号后提供格式规范。格式规范的语法如下：
- en: '[PRE27]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following table lists the field meanings:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表列出了字段含义：
- en: '| Field | Meaning |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| Field | Meaning |'
- en: '| --- | --- |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| fill | Fills in space with `align` |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| fill | 使用`align`填充空格 |'
- en: '| align | `<`-left align, `>`-right align, `^`-center align, `=`-put padding
    after sign |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| align | `<`-左对齐，`>`-右对齐，`^`-居中对齐，`=`-在符号后放置填充 |'
- en: '| sign | `+`-for all number, `-`-only negative, *space*-leading space for positive,
    sign on negative |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| sign | `+`-对所有数字，`-`-仅对负数，*空格*-正数前导空格，负数符号 |'
- en: '| # | Prefix integers. `Ob`-binary, `0o`-octal, `0x`-hex |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| # | 前缀整数。`Ob`-二进制，`0o`-八进制，`0x`-十六进制 |'
- en: '| 0 | Enable zero padding |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 启用零填充 |'
- en: '| width | Minimum field width |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| width | 最小字段宽度 |'
- en: '| grouping_option | `,`-Use comma for thousands separator, `_`-Use underscore
    for thousands separator |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| grouping_option | `,`-使用逗号作为千位分隔符，`_`-使用下划线作为千位分隔符 |'
- en: '| .precision | Digits after period (floats). Max string length (non-numerics)
    |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| .precision | 小数点后的数字（浮点数）。最大字符串长度（非数字） |'
- en: '| type | `s`-string format (default) see Integer and Float charts |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| type | `s`-字符串格式（默认）参见整数和浮点图表 |'
- en: The tables below lists the various options we have for formatting integer and
    floating point numbers.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了我们用于格式化整数和浮点数的各种选项。
- en: '| Integer Types | Meaning |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| 整数类型 | 含义 |'
- en: '| --- | --- |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `b` | binary |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 二进制 |'
- en: '| `c` | character - convert to Unicode character |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 字符 - 转换为Unicode字符 |'
- en: '| `d` | decimal (default) |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 十进制（默认） |'
- en: '| `n` | decimal with locale specific separators |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 具有区域设置特定分隔符的十进制 |'
- en: '| `o` | octal |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `o` | 八进制 |'
- en: '| `x` | hex (lower-case) |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 十六进制（小写） |'
- en: '| `X` | hex (upper-case) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 十六进制（大写） |'
- en: '| Float Types | Meaning |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| 浮点类型 | 含义 |'
- en: '| --- | --- |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `e`/`E` | Exponent. Lower/upper-case e |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `e`/`E` | 指数。小写/大写e |'
- en: '| `f` | Fixed point |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 固定点 |'
- en: '| `g`/`G` | General. Fixed with exponent for large, and small numbers (`g`
    default) |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `g`/`G` | 通用。对于大和小数字的固定指数（`g`默认） |'
- en: '| `n` | `g` with locale specific separators |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 具有区域设置特定分隔符的`g` |'
- en: '| `%` | Percentage (multiplies by 100) |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 百分比（乘以100） |'
- en: Some `format` Examples
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些`format`示例
- en: 'Here are a few examples of using `.format`. Let’s format a string in the center
    of 12 characters surrounded by `*`. `*` is the *fill* character, `^` is the *align*
    field, and `12` is the *width* field:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用`.format`的示例。让我们将一个字符串格式化在`*`包围的12个字符中心。`*`是*填充*字符，`^`是*对齐*字段，`12`是*宽度*字段：
- en: '[PRE28]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we format a percentage using a width of 10, one decimal place and the
    sign before the width padding. `=` is the *align* field, `10.1` are the *width*
    and *precision* fields, and `%` is the *float type*, which converts the number
    to a percentage:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用宽度为10，一位小数点和符号在宽度填充之前的百分比格式化。`=`是*对齐*字段，`10.1`是*宽度*和*精度*字段，`%`是*浮点类型*，将数字转换为百分比：
- en: '[PRE29]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Below is a binary and a hex conversion. The *integer type* field is set to
    `b` and `x` respectively:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是二进制和十六进制转换。*整数类型*字段分别设置为`b`和`x`：
- en: '[PRE30]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Files
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件
- en: 'The `open` function will take a file path and mode as input and return a file
    handle. There are various modes to open a file, depending on the content and your
    needs. If you open the file in binary mode, you will get bytes out. In text mode
    you will get strings back:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`函数将接受文件路径和模式作为输入，并返回文件句柄。根据内容和需求，有各种模式可以打开文件。如果以二进制模式打开文件，将得到字节。在文本模式下，将得到字符串：'
- en: '| Mode | Meaning |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| Mode | 含义 |'
- en: '| --- | --- |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `''r''` | Read text file (default) |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| `''r''` | 读取文本文件（默认） |'
- en: '| `''rU''` | Read text file. Treat `\r`, `\n`, `\r\n` as `\n`. |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| `''rU''` | 读取文本文件。将`\r`，`\n`，`\r\n`视为`\n`。 |'
- en: '| `''w''` | Write text file (truncates if exists) |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| `''w''` | 写入文本文件（如果存在则截断） |'
- en: '| `''a''` | Append to text file (write to end) |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| `''a''` | 追加到文本文件（写入末尾） |'
- en: '| `''rb''` | Read binary file |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| `''rb''` | 读取二进制文件 |'
- en: '| `''wb''` | Write binary (truncate) |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| `''wb''` | 写入二进制文件（截断） |'
- en: '| `''w+b''` | Open binary file for reading and writing |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| `''w+b''` | 以读写方式打开二进制文件 |'
- en: '| `''ab''` | Append to binary file (write to end) |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| `''ab''` | 追加到二进制文件（写入末尾） |'
- en: Writing Files
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入文件
- en: We use a context manager with a file to ensure that the file is closed when
    the context block exits.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用文件的上下文管理器来确保在上下文块退出时关闭文件。
- en: '[PRE31]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Reading Files
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'With an opened text file, you can iterate over the lines. This saves memory
    as the lines are read in as needed:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文本文件后，您可以迭代处理行。这样可以节省内存，因为需要时才读取行：
- en: '[PRE32]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: File Methods/Attributes
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 文件方法/属性
- en: '| Operation | Result |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `f.__iter__()` | Support iteration |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `f.__iter__()` | 支持迭代 |'
- en: '| `f.__repr__()` | Implementation for `repr(f)` |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `f.__repr__()` | `repr(f)` 的实现 |'
- en: '| `f.close()` | Close file |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `f.close()` | 关闭文件 |'
- en: '| `f.closed` | Is closed |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `f.closed` | 是否已关闭 |'
- en: '| `f.encoding` | The encoding of the file |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `f.encoding` | 文件的编码 |'
- en: '| `f.errors` | Error mode of encoding (`''strict''` default) |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `f.errors` | 编码的错误模式（默认为`''strict''`） |'
- en: '| `f.fileno()` | Return file descriptor |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `f.fileno()` | 返回文件描述符 |'
- en: '| `f.flush()` | Write file buffer |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `f.flush()` | 写入文件缓冲区 |'
- en: '| `f.isatty()` | Is interactive file |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| `f.isatty()` | 是否为交互式文件 |'
- en: '| `f.mode` | Mode of file |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| `f.mode` | 文件模式 |'
- en: '| `f.name` | Name of file |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| `f.name` | 文件名 |'
- en: '| `f.newlines` | End of line characters encountered (tuple or string) |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| `f.newlines` | 遇到的行结束字符（元组或字符串） |'
- en: '| `f.next()` | Return next item of iteration (line in text) |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| `f.next()` | 返回迭代的下一个项（文本中的行） |'
- en: '| `f.softspace` | Flag if space needs to be printed |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| `f.softspace` | 是否需要打印空格的标志 |'
- en: '| `f.read( size=-1)` | Read `size` characters (`-1` is whole file) |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| `f.read( size=-1)` | 读取 `size` 个字符（`-1` 为整个文件） |'
- en: '| `f.readinto()` | Mystery method |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| `f.readinto()` | 神秘的方法 |'
- en: '| `f.readline( size=-1)` | Read `size` characters from line (`-1` is whole
    line) |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `f.readline( size=-1)` | 从行中读取 `size` 个字符（`-1` 为整行） |'
- en: '| `f.readlines( hint=-1)` | Read bytes less than `hint` characters of lines
    from file (`-1` is all file) |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| `f.readlines( hint=-1)` | 从文件中读取少于 `hint` 个字符的行（`-1` 为整个文件） |'
- en: '| `f.seek(cookie, whence=0)` | Change stream location to `cookie` bytes (may
    be negative) offset from `whence` (`0` - start, `1` - current position, `2` -
    end). |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `f.seek(cookie, whence=0)` | 将流位置更改为距离 `whence`（`0` - 起始，`1` - 当前位置，`2` -
    结尾）的 `cookie` 字节（可以为负数）偏移。 |'
- en: '| `f.tell()` | Current stream location |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| `f.tell()` | 当前流位��� |'
- en: '| `f.truncate( pos=None)` | Truncate file to `pos` bytes |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `f.truncate( pos=None)` | 截断文件至 `pos` 字节 |'
- en: '| `f.write(text)` | Write `text` to file |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `f.write(text)` | 将 `text` 写入文件 |'
- en: '| `f.writelines( lines)` | Write `lines` to file (provide newlines if you want
    them) |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `f.writelines( lines)` | 将 `lines` 写入文件（如果需要换行，请提供） |'
- en: Functions
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Defining functions
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'Functions may take input, do some processing, and may return output. You may
    provide a docstring directly following the name and parameters of the function:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能接受输入，进行一些处理，并可能返回输出。你可以在函数名和参数后直接提供文档字符串：
- en: '[PRE33]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We use whitespace to specify a block in Python. We typically indent following
    a colon. PEP 8 recommends using 4 spaces.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Python 中使用空格来指定一个块。通常在冒号后缩进。PEP 8 建议使用 4 个空格。
- en: 'We can create anonymous functions using the `lambda` statement. Because this
    only allows expressions, it is somewhat crippled in functionality:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `lambda` 语句创建匿名函数。因为这只允许表达式，所以在功能上有些受限：
- en: '[PRE34]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Functions can have *default* arguments. Be careful with mutable types here,
    as the default is bound to the function when the function is created, not when
    it is called:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有*默认*参数。在这里要小心可变类型，因为默认值在函数创建时绑定，而不是在调用时：
- en: '[PRE35]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Functions can support variable positional arguments:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以支持可变位置参数：
- en: '[PRE36]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Functions can support variable keyword arguments:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以支持可变关键字参数：
- en: '[PRE37]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Calling Functions
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'You can also use `*` and `**` to *unpack* sequence and dictionary arguments:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `*` 和 `**` 来 *解包* 序列和字典参数：
- en: '[PRE38]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following two examples are the equivalent:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例是等价的：
- en: '[PRE39]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following two examples are the equivalent:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例是等价的：
- en: '[PRE40]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can also combine `*` and `**` on invocation:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在调用时结合 `*` 和 `**`：
- en: '[PRE41]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Getting Help
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取帮助
- en: 'You can get help on a function that has a docstring by using `help`:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `help` 来获取有文档字符串的函数的帮助：
- en: '[PRE42]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Classes
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'Python supports object oriented programming but doesn''t require you to create
    classes. You can use the built-in data structures to great effect. Here''s a class
    for a simple bike. The class attribute, `num_passengers`, is shared for all instances
    of `Bike`. The instance attributes, `size` and `ratio`, are unique to each instance:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持面向对象编程，但不要求你创建类。你可以有效地使用内置数据结构。这里是一个简单自行车的类。类属性 `num_passengers` 是所有
    `Bike` 实例共享的。实例属性 `size` 和 `ratio` 对每个实例都是唯一的：
- en: '[PRE43]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can call the constructor (`__init__`), by invoking the class name. Note
    that `self` is the instance, but Python passes that around for us automatically:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用构造函数（`__init__`）来调用类名。请注意，`self` 是实例，但 Python 会自动为我们传递它：
- en: '[PRE44]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can access both class attributes or instance attributes on the instance:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在实例上访问类属性或实例属性：
- en: '[PRE45]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If an attribute is not found on the instance, Python will then look for it on
    the class, it will look through the parent classes to continue to try and find
    it. If the lookup is unsuccessful, an `AttributeError` is raised.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在实例上找不到属性，Python将在类上查找，它将继续查找父类以尝试找到它。如果查找不成功，将引发`AttributeError`。
- en: Subclasses
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类
- en: 'To subclass a class, simply place the parent class name in parentheses following
    the class name in the declaration. We can call the `super` function to gain access
    to parent methods:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个类的子类，只需在声明中的类名后面的括号中放置父类名。我们可以调用`super`函数来访问父类方法：
- en: '[PRE46]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the above example, we used a `\` to indicate that the line continued on the
    following line. This is usually required unless there is an implicit line continuation
    with an opening brace that hasn't been closed (`(`, `[`, or `{`).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用`\`来表示该行在下一行继续。除非有一个未关闭的隐式行继续与未关闭的开放括号(`(`, `[`, 或 `{`)，否则通常需要这样做。
- en: Note
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `super` function will not work with old-style classes. Make sure your base
    classes inherit from `object` in Python 2.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`函数在旧式类中不起作用。确保你的基类在Python 2中继承自`object`。'
- en: 'The instance of the subclass can call methods that are defined on its class
    or the parent class:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 子类的实例可以调用在其类或父类上定义的方法：
- en: '[PRE47]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Class Methods and Static Methods
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法和静态方法
- en: 'The `classmethod` decorator is used to create methods that you can invoke directly
    on the class. This allows us to create alternate constructors. Note that the implicit
    first argument is the class, commonly named `cls` (as `class` is a keyword and
    will error out):'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`classmethod`装饰器用于创建可以直接在类上调用的方法。这允许我们创建替代构造函数。请注意，隐式的第一个参数是类，通常命名为`cls`（因为`class`是一个关键字，会报错）：'
- en: '[PRE48]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the above example, we had an implicit line continuation without a backslash,
    because there was a `(` on the line.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们有一个隐式的行继续，没有反斜杠，因为该行有一个`(`。
- en: 'The `staticmethod` decorator lets you attach functions to a class. (I don''t
    like them, just use a function). Note that they don''t get an implicit first argument.
    It can be called on the instance or the class:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`staticmethod`装饰器允许你将函数附加到一个类上。（我不喜欢它们，只需使用一个函数）。请注意，它们不会得到一个隐式的第一个参数。它可以在实例或类上调用：'
- en: '[PRE49]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Properties
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'If you want to have actions occur under the covers on attribute access, you
    can use properties to do that:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在属性访问时在内部执行操作，可以使用属性来实现：
- en: '[PRE50]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Rather than calling the `.name()` method, we access the attribute:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是调用`.name()`方法，我们访问属性：
- en: '[PRE51]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Looping
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'You can loop over objects in a sequence:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以循环遍历序列中的对象：
- en: '[PRE52]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `break` statement will pop you out of a loop:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句将使你跳出循环：'
- en: '[PRE53]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `continue` statement skips over the body of the loop and *continues* at
    the next item of iteration:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句跳过循环体，*继续*下一个迭代项：'
- en: '[PRE54]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can use the `else` statement to indicate that every item was looped over,
    and a `break` was never encountered:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`else`语句表示每个项都被遍历，并且没有遇到`break`：
- en: '[PRE55]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Don''t loop over index values (`range(len(names))`). Use `enumerate`:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 不要遍历索引值(`range(len(names))`)。使用`enumerate`：
- en: '[PRE56]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`while` Loops'
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: 'You can use `while` loops to create loops as well. If it is an infinite loop,
    you can break out of it:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`while`循环来创建循环。如果是无限循环，你可以跳出它：
- en: '[PRE57]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Iteration Protocol
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代协议
- en: 'To make an iterator implement `__iter__` and `next`:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器实现`__iter__`和`next`：
- en: '[PRE58]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use the iterator in a loop:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中使用迭代器：
- en: '[PRE59]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Unrolling the protocol:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 展开协议：
- en: '[PRE60]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Conditionals
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Python has an `if` statement with zero or more `elif` statements, and an optional
    `else` statement at the end. In Python, the word `elif` is Dutch for *else if*:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个带有零个或多个`elif`语句的`if`语句，并在最后有一个可选的`else`语句。在Python中，`elif`一词是荷兰语，意为*else
    if*：
- en: '[PRE61]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Python supports the following tests: `>`, `>=`, `<`, `<=`, `==`, and `!=`.
    For boolean operators use `and`, `or`, and `not` (`&`, `|`, and `^` are the bitwise
    operators).'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持以下测试：`>`, `>=`, `<`, `<=`, `==`, 和 `!=`。对于布尔运算符使用`and`，`or`，和`not`（`&`，`|`，和`^`是位运算符）。
- en: 'Note that Python also supports *range comparisons*:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python也支持*范围比较*：
- en: '[PRE62]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Python does not have a switch statement, often dictionaries are used to support
    a similar construct:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有switch语句，通常使用字典来支持类似的结构：
- en: '[PRE63]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Truthiness
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真值性
- en: You can define the `__nonzero__` method to teach your classes how to act in
    a boolean context. If that doesn't exists, Python will use `__len__`, and finally
    default to `True`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义`__nonzero__`方法来教导您的类在布尔上下文中如何行事。如果不存在，Python将使用`__len__`，最后默认为`True`。
- en: 'The following table lists *truthy* and *falsey* values:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表列出了*真值*和*假值*：
- en: '| Truthy | Falsey |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| 真值 | 假值 |'
- en: '| --- | --- |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `True` | `False` |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| `True` | `False` |'
- en: '| Most objects | `None` |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| 大多数对象 | `None` |'
- en: '| `1` | `0` |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` |'
- en: '| `3.2` | `0.0` |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| `3.2` | `0.0` |'
- en: '| `[1, 2]` | `[]` (empty list) |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| `[1, 2]` | `[]`（空列表） |'
- en: '| `{''a'': 1, ''b'': 2}` | `{}` (empty dict) |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| `{''a'': 1, ''b'': 2}` | `{}`（空字典） |'
- en: '| `''string''` | `""` (empty string) |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| `''string''` | `""`（空字符串） |'
- en: '| `''False''` |   |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| `''False''` |   |'
- en: '| `''0''` |   |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| `''0''` |   |'
- en: Short Circuiting
  id: totrans-654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短路
- en: 'The `and` statement will short circuit if it evaluates to false:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`and`语句评估为假，它将会短路：
- en: '[PRE64]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Likewise, the `or` statement will short circuit when something evaluates to
    true:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当某个条件为真时，`or`语句将会短路：
- en: '[PRE65]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Ternary Operator
  id: totrans-659
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'Python has its own ternary operator, called a *conditional expression* (see
    PEP 308). These are handy as they can be used in comprehension constructs and
    `lambda` functions:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: Python有自己的三元运算符，称为*条件表达式*（参见PEP 308）。这些很方便，因为它们可以用于理解构造和`lambda`函数中：
- en: '[PRE66]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note that this has similar behavior to an `if` statement, but it is an expression,
    and not a statement. Python distinguishes these two. An easy way to determine
    between the two, is to remember that an expression follows a `return` statement.
    Anything you can `return` is an expression.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与`if`语句具有类似的行为，但它是一个表达式，而不是语句。Python区分这两者。区分两者的一个简单方法是记住表达式跟随`return`语句。你可以`return`的任何东西都是表达式。
- en: Exceptions
  id: totrans-663
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'Python can catch one or more exceptions (PEP 3110). You can provide a chain
    of different exceptions to catch if you want to react differently. A few hints:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以捕获一个或多个异常（PEP 3110）。如果您想要有不同的反应，可以提供一系列不同的异常来捕获。一些建议：
- en: Try to keep the block of the `try` statement down to the code that throws exceptions
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量将`try`语句块保持在引发异常的代码范围内
- en: Be specific about the exceptions that you catch
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于您捕获的异常要具体明确
- en: If you want to inspect the exception, use `as` to create a variable to point
    to it
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要检查异常，请使用`as`创建一个指向它的变量
- en: If you use a bare `raise` inside of an `except` block, Python's traceback will
    point back to the location of the original exception, rather than where it is
    raised from.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`except`块中使用裸`raise`，Python的回溯将指向原始异常的位置，而不是引发异常的位置。
- en: '[PRE67]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Raising Exceptions
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引发异常
- en: 'You can raise an exception using the `raise` statement:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`raise`语句引发异常：
- en: '[PRE68]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Decorators
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'A decorator (PEP 318) allows us to insert logic before and after a function
    is called. You can define a decorator with a function that takes a function as
    input and returns a function as output. Here is the identity decorator:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器（PEP 318）允许我们在调用函数之前和之后插入逻辑。您可以使用一个接受函数作为输入并返回函数作为输出的函数来定义装饰器。这是身份装饰器：
- en: '[PRE69]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can decorate a function with it like this:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样装饰一个函数：
- en: '[PRE70]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A more useful decorator can inject logic before and after calling the original
    function. To do this we create a function inside of the function and return that.
    Below, we use print functions to illustrate before/after behavior, otherwise this
    is very similar to identity decorator:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有用的装饰器可以在调用原始函数之前和之后注入逻辑。为此，我们在函数内部创建一个函数并返回它。下面，我们使用打印函数来说明调用前/后的行为，否则这与身份装饰器非常相似：
- en: '[PRE71]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'There is a special syntax for applying the decorator. We put `@` before the
    decorator name and place that on a line directly above the function we wish to
    decorate. Using the `@verbose` line before a function declaration is syntactic
    sugar for re-assigning the variable pointing to the function to the result of
    calling the decorator with the function passed into it:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的语法用于应用装饰器。我们在装饰器名称前面放置`@`，并将其放在直接在要装饰的函数上面的一行上。在函数声明之前使用`@verbose`行是对将指向该函数的变量重新赋值的语法糖，以调用装饰器并将函数传递给它的结果：
- en: '[PRE72]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This could also be written as, `sub = verbose(sub)`. Note that our decorated
    function will still call our original function, but add in some `print` statements:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成`sub = verbose(sub)`。请注意，我们的装饰函数仍将调用我们的原始函数，但会添加一些`print`语句：
- en: '[PRE73]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Parameterized Decorators
  id: totrans-684
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化装饰器
- en: 'Because we can use closures to create functions, we can use closures to create
    decorators as well. This is very similar to our decorator above, but now we make
    a function that will return a decorator. Based on the inputs to that function,
    we can control (or parameterize) the behavior of the decorator:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们可以使用闭包来创建函数，我们也可以使用闭包来创建装饰器。这与我们上面的装饰器非常相似，但现在我们制作一个将返回装饰器的函数。根据该函数的输入，我们可以控制（或参数化）装饰器的行为：
- en: '[PRE74]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'When you decorate with parameterized decorators, the decoration looks differently,
    because we need to invoke the function to create a decorator:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用带参数的装饰器装饰时，装饰看起来不同，因为我们需要调用函数来创建装饰器：
- en: '[PRE75]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Class Decorators and Metaclasses
  id: totrans-689
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类装饰器和类元类
- en: Python allows you to dynamically create and modify classes. Class decorators
    and metaclasses are two ways to do this.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你动态创建和修改类。类装饰器和类元类是实现这一点的两种方式。
- en: Class Decorators
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类装饰器
- en: You can decorate a class definition with a *class decorator* (PEP 3129). It
    is a function that takes a class as input and returns a class.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用*类装饰器*（PEP 3129）装饰一个类定义。它是一个以类为输入并返回一个类的函数。
- en: '[PRE76]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Creating Classes with `type`
  id: totrans-694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`type`创建类
- en: You can use `type` to determine the type of an object, but you can also provide
    the name, parents, and attributes map, and it will return a class.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`type`来确定对象的类型，但也可以提供名称、父类和属性映射，它将返回一个类。
- en: '[PRE77]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Metaclasses with Functions
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数与函数元类
- en: In the class definition you can specify a metaclass (PEP 3115), which can be
    a function or a class. Here is an example of a function that can alter the class.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，你可以指定一个元类（PEP 3115），它可以是一个函数或一个类。这是一个可以改变类的函数的例子。
- en: '[PRE78]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Metaclasses with Classes
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类与类元类
- en: You can define a class decorator and use either `__new__` or `__init__`. Typically
    most use `__new__` as it can alter attributes like `__slots__`
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个类装饰器，并使用`__new__`或`__init__`。通常大多数人使用`__new__`，因为它可以改变像`__slots__`这样的属性
- en: '[PRE79]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Generators
  id: totrans-703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: 'Generators (PEP 255) are functions that suspend their state as you iterate
    over the results of them. Each `yield` statement returns the next item of iteration
    and then *freezes* the state of the function. When iteration is resumed, the function
    continues from the point it was frozen. Note, that the result of calling the function
    is a generator:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器（PEP 255）是在你迭代它们的结果时暂停其状态的函数。每个`yield`语句返回迭代的下一个项，然后*冻结*函数的状态。当恢复迭代时，函数从被冻结的点继续。请注意，调用函数的结果是一个生成器：
- en: '[PRE80]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can simulate iteration by using the iteration protocol:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用迭代协议来模拟迭代：
- en: '[PRE81]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Comprehensions
  id: totrans-708
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推导式
- en: 'Comprehension constructs allow us to combine the functional ideas behind map
    and filter into an easy to read, single line of code. When you see code that is
    aggregating into a list (or dict, set, or generator), you can replace it with
    a list comprehension (or dict, set comprehension, or generator expression). Here
    is an example of the code smell:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 理解构造允许我们将map和filter背后的功能思想结合到易于阅读的单行代码中。当你看到代码在列表（或字典、集合或生成器）中聚合时，可以用列表推导式（或字典、集合推导式或生成器表达式）替换它。这是一个代码异味的例子：
- en: '[PRE82]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This can be specified with a list comprehension (PEP 202):'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用列表推导式（PEP 202）来指定：
- en: '[PRE83]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To construct a list comprehension:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 构造列表推导式：
- en: 'Assign the result (`result`) to brackets. The brackets signal to the reader
    of the code that a list will be returned:'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果(`result`)赋给括号。括号向代码读者表明将返回一个列表：
- en: '[PRE84]'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Place the *for* loop construct inside the brackets. No colons are necessary:'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*for*循环结构放在括号内。不需要冒号：
- en: '[PRE85]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Insert any operations that filter the accumulation after the for loop:'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在for循环后插入任何过滤累积的操作：
- en: '[PRE86]'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Insert the accumulated object (`num*num`) at the front directly following the
    left bracket. Insert parentheses around the object if it is a tuple:'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在左括号后面插入累积对象(`num*num`)。如果是元组，则在对象周围插入括号：
- en: '[PRE87]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Set Comprehensions
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'If you replace the `[` with `{`, you will get a set comprehension (PEP 274)
    instead of a list comprehension:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用`{`替换`[`，你将得到一个集合推导式（PEP 274），而不是一个列表推导式：
- en: '[PRE88]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Dict Comprehensions
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典推导式
- en: 'If you replace the `[` with `{`, and separate the key and value with a colon,
    you will get a dictionary comprehension (PEP 274):'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用`{`替换`[`，并用冒号分隔键和值，你将得到一个字典推导式（PEP 274）：
- en: '[PRE89]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Generator Expressions
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: 'If you replace the `[` with `(`, you will get a generator instead of a list.
    This is called a *generator expression* (PEP 289):'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`[`替换为`(`，你将得到一个生成器而不是列表。这被称为*生成器表达式*（PEP 289）：
- en: '[PRE90]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Context Managers
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: If you find code where you need to make sure something happens before *AND*
    after a block, a context manager (PEP 343) is a convenient way to enforce that.
    Another code smell that indicates you could be using a context manager is a `try`/`finally`
    block.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现代码需要在一个块之前和之后确保某些事情发生，上下文管理器（PEP 343）是强制执行的便利方式。另一个表明你可能正在使用上下文管理器的代码异味是`try`/`finally`块。
- en: Context managers can be created with functions or classes.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器可以通过函数或类创建。
- en: 'If we were writing a Python module to write TeX, we might do something like
    this to ensure that the environments are closed properly:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写一个用于编写TeX的Python模块，我们可能会这样做以确保环境被正确关闭：
- en: '[PRE91]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This code can use a context manager to be a little cleaner.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以使用上下文管理器来变得更加清晰。
- en: Function Based Context Managers
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于函数的上下文管理器
- en: 'To create a context manager with a function, decorate with `contextlib.contextmanager`,
    and yield where you want to bookend:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用函数创建上下文管理器，用`contextlib.contextmanager`装饰，并在想要包围的地方`yield`：
- en: '[PRE92]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Our code looks better now, and there will always be a closing tag:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码看起来更好了，而且总会有一个闭合标签：
- en: '[PRE93]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Class Based Context Managers
  id: totrans-742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于类的上下文管理器
- en: 'To create a class based context manager, implement the `__enter__` and `__exit__`
    methods:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建基于类的上下文管理器，实现`__enter__`和`__exit__`方法：
- en: '[PRE94]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The code looks the same as using the function based context manager:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来与使用基于函数的上下文管理器相同：
- en: '[PRE95]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Context objects
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文对象
- en: 'Some context managers create objects that we can use while inside of the context.
    The `open` context manager returns a file object:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 一些上下文管理器创建我们可以在上下文中使用的对象。`open`上下文管理器返回一个文件对象：
- en: '[PRE96]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: To create an object in a function based context manager, simply `yield` the
    object. In a class based context manager, return the object in the `__enter__`
    method.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于类的上下文管理器中创建一个对象，只需`yield`该对象。在`__enter__`方法中返回对象。
- en: Scripts, Packages, and Modules
  id: totrans-751
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ���本、包和模块
- en: Scripts
  id: totrans-752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本
- en: 'A script is a Python file that you invoke `python` on. Typically there is a
    line near the bottom that looks like this:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 一个脚本是一个你在上面调用`python`的Python文件。通常在底部附近有一行看起来像这样的代码：
- en: '[PRE97]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This test allows you to change the code path when you execute the code versus
    when you import the code. The `__name__` attribute of a module is set to `'__main__'`
    when you execute that module. Otherwise, if you import the module, it will be
    the name of the module (without `.py`).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试允许你在执行代码和导入代码时改变代码路径。当你执行该模块时，模块的`__name__`属性被设置为`'__main__'`。否则，如果你导入模块，它将是模块的名称（不带`.py`）。
- en: Modules
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: Modules are files that end in `.py`. According to PEP 8, we lowercase the module
    name and don't put underscores between the words in them. Any module found in
    the `PYTHONPATH` environment variable or the `sys.path` list, can be imported.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是以`.py`结尾的文件。根据PEP 8，我们将模块名小写，并且不在它们之间加下划线。任何在`PYTHONPATH`环境变量或`sys.path`列表中找到的模块都可以被导入。
- en: Packages
  id: totrans-758
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包
- en: 'A directory that has a file named `__init__.py` in it is a *package*. A package
    can have modules in it as well as sub packages. The package should be found in
    `PYTHONPATH` or `sys.path` to be imported. An example might look like this:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含名为`__init__.py`的文件的目录是一个*包*。一个包可以包含模块以及子包。要导入包，包应该在`PYTHONPATH`或`sys.path`中找到。一个例子可能是这样的：
- en: '[PRE98]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `__init__.py` module can be empty or can import code from other modules
    in the package to remove nesting in import statements.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`模块可以是空的，也可以从包中的其他模块导入代码，以消除导入语句中的嵌套。'
- en: Importing
  id: totrans-762
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入
- en: 'You can import a package or a module:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以导入一个包或一个模块：
- en: '[PRE99]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Assume there is a `fib` function in `module1`. You have access to everything
    in the namespace of the module you imported. To use this function you will need
    to use the fully qualified name, `packagename.module1.fib`:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在`module1`中有一个`fib`函数。你可以访问你导入的模块的命名空间中的所有内容。要使用这个函数，你需要使用完全限定的名称，`packagename.module1.fib`：
- en: '[PRE100]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If you only want to import the `fib` function, use the `from` variant:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想导入`fib`函数，使用`from`变体：
- en: '[PRE101]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You can also rename imports using `as`:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`as`来重命名导入：
- en: '[PRE102]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Environments
  id: totrans-771
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境
- en: 'Python 2 does not include the ability to create *virtual environments* out
    of the box. To install the `virtualenv` module for creating a sandbox for your
    project, run (you might need to run with `sudo`):'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2不包含开箱即用的创建*虚拟环境*的功能。要安装用于为项目创建沙盒的`virtualenv`模块，请运行以下命令（可能需要使用`sudo`运行）：
- en: '[PRE103]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To create an environment on Unix and Windows systems, run:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix和Windows系统上创建环境，请运行：
- en: '[PRE104]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To enter or *activate* the environment on Unix, run:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入或*激活*Unix环境，请运行：
- en: '[PRE105]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'On Windows, run:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上运行：
- en: '[PRE106]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Your prompt should have the name of the active virtual environment in parentheses.
    To *deactivate* an environment on both platforms, just run the following:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 你的提示符应该在括号中显示活动虚拟环境的名称。要在两个平台上*停用*环境，只需运行以下命令：
- en: '[PRE107]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Installing Packages
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装软件包
- en: 'You should now have a `pip` executable, that will install a package from PyPI
    [[2]](#id4) into your virtual environment:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个`pip`可执行文件，它将从PyPI [[2]](#id4)安装一个软件包到你的虚拟环境中：
- en: '[PRE108]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '| [[2]](#id3) | [https://pypi.python.org/pypi](https://pypi.python.org/pypi)
    |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '| [[2]](#id3) | [https://pypi.python.org/pypi](https://pypi.python.org/pypi)
    |'
- en: 'To uninstall a package run:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载软件包，请运行：
- en: '[PRE109]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: If you are having issues installing a package, you might want to look into alternative
    Python distributions such as Anaconda [[3]](#id6) that have prepackaged many harder
    to install packages.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装软件包时遇到问题，您可能需要考虑使用其他Python发行版，如Anaconda [[3]](#id6)，其中预先打包了许多难以安装的软件包。
- en: '| [[3]](#id5) | [https://docs.continuum.io/anaconda/](https://docs.continuum.io/anaconda/)
    |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
  zh: '| [[3]](#id5) | [https://docs.continuum.io/anaconda/](https://docs.continuum.io/anaconda/)
    |'
