- en: クラス
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: クラス
- en: 原文：[https://jsprimer.net/basic/class/](https://jsprimer.net/basic/class/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://jsprimer.net/basic/class/](https://jsprimer.net/basic/class/)
- en: 「クラス」と一言にいってもさまざまであるため、ここでは**構造**、**動作**、**状態**を定義できるものを指すことにします。 また、この章では概念を示す場合は**クラス**と呼び、クラスに関する構文（記述するコード）のことを`class`構文と呼びます。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 「クラス」と一言にいってもさまざまであるため、こ��では**構造**、**動作**、**状態**を定義できるものを指すことにします。 また、この章では概念を示す場合は**クラス**と呼び、クラスに関する構文（記述するコード）のことを`class`構文と呼びます。
- en: '**クラス**とは**動作**や**状態**を定義した**構造**です。 クラスからはインスタンスと呼ばれるオブジェクトを作成でき、インスタンスはクラスに定義した**動作**を継承し、**状態**は動作によって変化します。
    とても抽象的なことに思えますが、これは今までオブジェクトや関数を使って表現してきたものです。 JavaScriptではES2015より前までは`class`構文はなく、関数を使ってクラスのようなものを表現して扱っていました。'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**クラス**とは**動作**や**状態**を定義した**構造**です。 クラスからはインスタンスと呼ばれるオブジェクトを作成でき、インスタンスはクラスに定義した**動作**を継承し、**状態**は動作によって変化します。
    とても抽象的なことに思えますが、これは今までオブジェクトや関数を使って表現してきたものです。 JavaScriptではES2015より前までは`class`構文はなく、関数を使ってクラスのようなものを表現して扱っていました。'
- en: ES2015でクラスを表現するための`class`構文が導入されましたが、この`class`構文で定義したクラスは関数オブジェクトの一種です。 `class`構文ではプロトタイプベースの継承の仕組みを使って関数でクラスを表現しています。
    そのため、`class`構文はクラスを作るための関数定義や継承をパターン化した書き方と言えます。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015でクラスを表現するための`class`構文が導入されましたが、この`class`構文で定義したクラスは関数オブジェクトの一種です。 `class`構文ではプロトタイプベースの継承の仕組みを使って関数でクラスを表現しています。
    そのため、`class`構文はクラスを作るための関数定義や継承をパターン化した書き方と言えます。
- en: また、関数の定義方法として関数宣言文と関数式があるように、クラスにもクラス宣言文とクラス式があります。 このように関数とクラスは似ている部分が多いです。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: また、関数の定義方法として関数宣言文と関数式があるように、クラスにもクラス宣言文とクラス式があります。 このように関数とクラスは似ている部分が多いです。
- en: この章では、`class`構文でのクラスの定義や継承、クラスの性質について学んでいきます。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: この章では、`class`構文でのクラスの定義や継承、クラスの性質について学んでいきます。
- en: '[](#class-declaration)*クラスの定義*'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#class-declaration)*クラスの定義*'
- en: '*クラスを定義するには`class`構文を使います。 クラスの定義方法にはクラス宣言文とクラス式があります。'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスを定義するには`class`構文を使います。 クラスの定義方法にはクラス宣言文とクラス式があります。'
- en: まずは、クラス宣言文によるクラスの定義方法を見ていきます。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: まずは、クラス宣言文によるクラスの定義方法を見ていきます。
- en: クラス宣言文では`class`キーワードを使い、`class クラス名{ }`のようにクラスの**構造**を定義できます。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: クラス宣言文では`class`キーワードを使い、`class クラス名{ }`のようにクラスの**構造**を定義できます。
- en: クラスは必ずコンストラクタを持ち、`constructor`という名前のメソッドとして定義します。 コンストラクタとは、そのクラスからインスタンスを作成する際にインスタンスに関する**状態**の初期化を行うメソッドです。
    `constructor`メソッドに定義した処理は、クラスをインスタンス化したときに自動的に呼び出されます。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: クラスは必ずコンストラクタを持ち、`constructor`という名前のメソッドとして定義します。 コンストラクタとは、そのクラスからインスタンスを作成する際にインスタンスに関する**状態**の初期化を行うメソッドです。
    `constructor`メソッドに定義した処理は、クラスをインスタンス化したときに自動的に呼び出されます。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: もうひとつの定義方法であるクラス式は、クラスを値として定義する方法です。 クラス式ではクラス名を省略できます。これは関数式における無名関数と同じです。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: もうひとつの定義方法であるクラス式は、クラスを値として定義する方法です。 クラス式ではクラス名を省略できます。これは関数式における無名関数と同じです。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: コンストラクタ関数内で、何も処理がない場合はコンストラクタの記述を省略できます。 省略した場合でも自動的に空のコンストラクタが定義されるため、クラスにはコンストラクタが必ず存在します。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: コンストラクタ関数内で、何も処理がない場合はコンストラクタの記述を省略できます。 省略した場合でも自動的に空のコンストラクタが定義されるため、クラスにはコンストラクタが必ず存在します。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[](#class-instance)*クラスのインスタンス化*'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#class-instance)*クラスのインスタンス化*'
- en: '*クラスは`new`演算子でインスタンスであるオブジェクトを作成できます。 `class`構文で定義したクラスからインスタンスを作成することを**インスタンス化**と呼びます。
    あるインスタンスが指定したクラスから作成されたものかを判定するには`instanceof`演算子が利用できます。'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスは`new`演算子でインスタンスであるオブジェクトを作成できます。 `class`構文で定義したクラスからインスタンスを作成することを**インスタンス化**と呼びます。
    あるインスタンスが指定したクラスから作成されたものかを判定するには`instanceof`演算子が利用できます。'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: このままでは何も処理がない空のクラスなので、値を持ったクラスを定義してみましょう。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: このままでは何も処理がない空のクラスなので、値を持ったクラスを定義してみましょう。
- en: クラスではインスタンスの初期化処理をコンストラクタ関数で行います。 コンストラクタ関数は`new`演算子でインスタンス化する際に自動的に呼び出されます。
    コンストラクタ関数内での`this`はこれから新しく作るインスタンスオブジェクトとなります。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: クラスではインスタンスの初期化処理をコンストラクタ関数で行います。 コンストラクタ関数は`new`演算子でインスタンス化する際に自動的に呼び出されます。
    コンストラクタ関数内での`this`はこれから新しく作るインスタンスオブジェクトとなります。
- en: 次のコードでは、`x`座標と`y`座標の値を持つ`Point`というクラスを定義しています。 コンストラクタ関数（`constructor`）の中でインスタンスオブジェクト（`this`）の`x`と`y`プロパティに値を代入して初期化しています。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`x`座標と`y`座標の値を持つ`Point`というクラスを定義しています。 コンストラクタ関数（`constructor`）の中でインスタンスオブジェクト（`this`）の`x`と`y`プロパティに値を代入して初期化しています。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: この`Point`クラスのインスタンスを作成するには`new`演算子を使います。 `new`演算子には関数呼び出しと同じように引数を渡すことができます。
    `new`演算子の引数はクラスの`constructor`メソッド（コンストラクタ関数）の仮引数に渡されます。 そして、コンストラクタの中ではインスタンスオブジェクト（`this`）の初期化処理を行います。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: この`Point`クラスのインスタンスを作成するには`new`演算子を使います。 `new`演算子には関数呼び出しと同じように引数を渡すことができます。
    `new`演算子の引数はクラスの`constructor`メソッド（コンストラクタ関数）の仮引数に渡されます。 そして、コンストラクタの中ではインスタンスオブジェクト（`this`）の初期化処理を行います。
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: このようにクラスからインスタンスを作成するには必ず`new`演算子を使います。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: このようにクラスからインスタンスを作成するには必ず`new`演算子を使います。
- en: 一方、クラスは通常の関数として呼ぶことができません。 これは、クラスのコンストラクタはインスタンス（`this`）を初期化する場所であり、通常の関数とは役割が異なるためです。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一方、クラスは通常の関数として呼ぶことができません。 これは、クラスのコンストラクタはインスタンス（`this`）を初期化する場所であり、通常の関数とは役割が異なるためです。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: また、コンストラクタ関数は`return`文で任意のオブジェクトを返すことが可能ですが、行うべきではありません。 なぜなら、クラスを`new`演算子で呼び出し、その評価結果はクラスのインスタンスを期待するのが一般的であるためです。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: また、コンストラクタ関数は`return`文で任意のオブジェクトを返すことが可能ですが、行うべきではありません。 なぜなら、クラスを`new`演算子で呼び出し、その評価結果はクラスのインスタンスを期待するのが一般的であるためです。
- en: 次のコードのようにコンストラクタで返した値が`new`演算子で呼び出した際の返り値となります。 このような書き方は混乱を生むため避けるべきです。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードのようにコンストラクタで返した値が`new`演算子で呼び出した際の返り値となります。 このような書き方は混乱を生むため避けるべきです。
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[](#class-name-start-upper-case)*[Note] クラス名は大文字ではじめる*'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#class-name-start-upper-case)*[Note] クラス名は大文字ではじめる*'
- en: '*JavaScriptでは慣習としてクラス名には大文字ではじまる名前をつけます。 これは、変数名にキャメルケースを使う慣習があるのと同じで、名前自体に特別なルールがあるわけではありません。
    クラス名を大文字にしておき、そのインスタンスは小文字で開始すれば名前が被らないという合理的な理由で好まれています。'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScriptでは慣習としてクラス名には大文字ではじまる名前をつけます。 これは、変数名にキャメルケースを使う慣習があるのと同じで、名前自体に特別なルールがあるわけではありません。
    クラス名を大文字にしておき、そのインスタンスは小文字で開始すれば名前が被らないという合理的な理由で好まれています。'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[](#class-vs-function)*[コラム] `class`構文と関数でのクラスの違い*'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#class-vs-function)*[コラム] `class`構文と関数でのクラスの違い*'
- en: '*ES2015より前はこれらのクラスを`class`構文ではなく、関数で表現していました。 その表現方法は人によってさまざまで、これも`class`構文という統一した記法が導入された理由の1つです。'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*ES2015より前はこれらのクラスを`class`構文ではなく、関数で表現していました。 その表現方法は人によってさまざまで、これも`class`構文という統一した記法が導入された理由の1つです。'
- en: 次のコードは、関数でクラスを実装した1つの例です。 この関数でのクラス表現は、継承の仕組みなどは省かれていますが、`class`構文とよく似ています。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードは、関数でクラスを実装した1つの例です。 この関数でのクラス表現は、継承の仕組みなどは省かれていますが、`class`構文とよく似ています。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 大きな違いとして、`class`構文で定義したクラスは関数として呼び出すことができません。 クラスは`new`演算子でインスタンス化して使うものなので、これはクラスの誤用を防ぐ仕様です。
    一方、関数でのクラス表現はただの関数なので、当然関数として呼び出せます。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大きな違いとして、`class`構文で定義したクラスは関数として呼び出すことができません。 クラスは`new`演算子でインスタンス化して使うものなので、これはクラスの誤用を防ぐ仕様です。
    一方、関数でのクラス表現はただの関数なので、当然関数として呼び出せます。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: このように、関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。 このような問題を避けるためにもクラスは`class`構文を使って実装します。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: このように、関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。 このような問題を避けるためにもクラスは`class`構文を使って実装します。
- en: '[](#class-prototype-method-definition)*クラスのプロトタイプメソッドの定義*'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#class-prototype-method-definition)*クラスのプロトタイプメソッドの定義*'
- en: '*クラスの**動作**はメソッドによって定義できます。 `constructor`メソッドは初期化時に呼ばれる特殊なメソッドですが、`class`構文ではクラスに対して自由にメソッドを定義できます。
    このクラスに定義したメソッドは作成したインスタンスが持つ動作となります。'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスの**動作**はメソッドによって定義できます。 `constructor`メソッドは初期化時に呼ばれる特殊なメソッドですが、`class`構文ではクラスに対して自由にメソッドを定義できます。
    このクラスに定義したメソッドは作成したインスタンスが持つ動作となります。'
- en: 次のように`class`構文ではクラスに対してメソッドを定義できます。 メソッドの中からクラスのインスタンスを参照するには、`constructor`メソッドと同じく`this`を使います。
    このクラスのメソッドにおける`this`は「[関数とthis](../function-this/)」の章で学んだメソッドと同じくベースオブジェクトを参照します。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 次のように`class`構文ではクラスに対してメソッドを定義できます。 メソッドの中からクラスのインスタンスを参照するには、`constructor`メソッドと同じく`this`を使います。
    このクラスのメソッドにおける`this`は「[関数とthis](../function-this/)」の章で学んだメソッドと同じくベースオブジェクトを参照します。
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'クラスのプロトタイプメソッド定義では、オブジェクトにおけるメソッドとは異なり`key : value`のように`:`区切りでメソッドを定義できないことに注意してください。
    つまり、次のような書き方は構文エラー（`SyntaxError`）となります。'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 'クラスのプロトタイプメソッド定義では、オブジェクトにおけるメソッドとは異なり`key : value`のように`:`区切りでメソッドを定義できないことに注意してください。
    つまり、次のような書き方は構文エラー（`SyntaxError`）となります。'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: このメソッド定義の構文でクラスに対して定義したメソッドは、クラスの各インスタンスから**共有されるメソッド**となります。 このインスタンス間で共有されるメソッドのことを**プロトタイプメソッド**と呼びます。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: このメソッド定義の構文でクラスに対して定義したメソッドは、クラスの各インスタンスから**共有されるメソッド**となります。 このインスタンス間で共有されるメソッドのことを**プロトタイプメソッド**と呼びます。
- en: 次のコードでは、`Counter`クラスに`increment`メソッドを定義しています。 このときの`Counter`クラスのインスタンスは、それぞれ別々の状態（`count`プロパティ）を持ちます。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`Counter`クラスに`increment`メソッドを定義しています。 このときの`Counter`クラスのインスタンスは、それぞれ別々の状態（`count`プロパティ）を持ちます。
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: このときの`increment`メソッドはプロトタイプメソッドとして定義されています。 プロトタイプメソッドは各インスタンス間(`counterA`と`counterB`)で共有されます。
    そのため、次のように各インスタンスの`increment`メソッドの参照先は同じとなっていることがわかります。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: このときの`increment`メソッドはプロトタイプメソッドとして定義されています。 プロトタイプメソッドは各インスタンス間(`counterA`と`counterB`)で共有されます。
    そのため、次のように各インスタンスの`increment`メソッドの参照先は同じとなっていることがわかります。
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: プロトタイプメソッドがなぜインスタンス間で共有されているのかは、クラスの継承の仕組みと密接に関係しています。 プロトタイプメソッドの仕組みについては後ほど解説します。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: プロトタイプメソッドがなぜインスタンス間で共有されているのかは、クラスの継承の仕組みと密接に関係しています。 プロトタイプメソッドの仕組みについては後ほど解説します。
- en: ここでは、次のような構文でクラスにメソッドを定義すると、各インスタンスで共有されるプロトタイプメソッドとして定義されるということが理解できていれば問題ありません。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ここでは、次のような構文でクラスにメソッドを定義すると、各インスタンスで共有されるプロトタイプメソッドとして定義されるということが理解できていれば問題ありません。
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[](#class-accessor-property)*クラスのアクセッサプロパティの定義*'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#class-accessor-property)*クラスのアクセッサプロパティの定義*'
- en: '*クラスに対してメソッドを定義できますが、メソッドは`インスタンス名.メソッド名()`のように呼び出す必要があります。 クラスでは、プロパティの参照（getter）、プロパティへの代入（setter）時に呼び出される特殊なメソッドを定義できます。
    このメソッドはプロパティのように振る舞うため**アクセッサプロパティ**と呼ばれます。'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスに対してメソッドを定義できますが、メソッドは`インスタンス名.メソッド名()`のように呼び出す必要があります。 クラスでは、プロパティの参照（getter）、プロパティへの代入（setter）時に呼び出される特��なメソッドを定義できます。
    このメソッドはプロパティのように振る舞うため**アクセッサプロパティ**と呼ばれます。'
- en: 次のコードでは、プロパティの参照（getter）、プロパティへの代入（setter）に対するアクセッサプロパティを定義しています。 アクセッサプロパティはメソッド名（プロパティ名）の前に`get`または`set`をつけるだけです。
    getter（`get`）には仮引数はありませんが、必ず値を返す必要があります。 setter（`set`）の仮引数にはプロパティへ代入する値が入りますが、値を返す必要はありません。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、プロパティの参照（getter）、プロパティへの代入（setter）に対するアクセッサプロパティを定義しています。 アクセッサプロパティはメソッド名（プロパティ名）の前に`get`または`set`をつけるだけです。
    getter（`get`）には仮引数はありませんが、必ず値を返す必要があります。 setter（`set`）の仮引数にはプロパティへ代入する値が入りますが、値を返す必要はありません。
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 次のコードでは、`NumberWrapper`クラスの`value`プロパティをアクセッサプロパティとして定義しています。 `value`プロパティへアクセスした際にそれぞれ定義したgetterとsetterが呼ばれているのがわかります。
    このアクセッサプロパティで実際に読み書きされているのは、`NumberWrapper`インスタンスの`_value`プロパティとなります。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`NumberWrapper`クラスの`value`プロパティをアクセッサプロパティとして定義しています。 `value`プロパティへアクセスした際にそれぞれ定義したgetterとsetterが呼ばれているのがわかります。
    このアクセッサプロパティで実際に読み書きされているのは、`NumberWrapper`インスタンスの`_value`プロパティとなります。
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[](#underbar-private-property)*[コラム] `_`（アンダーバー）から始まるプロパティ名*'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#underbar-private-property)*[コラム] `_`（アンダーバー）から始まるプロパティ名*'
- en: '*NumberWrapperの`value`のアクセッサプロパティで実際に読み書きしているのは、`_value`プロパティです。 このように、外から直接読み書きしてほしくないプロパティを`_`（アンダーバー）から始まる名前にするのはただの習慣であるため、構文としての意味はありません。'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*NumberWrapperの`value`のアクセッサプロパティで実際に読み書きしているのは、`_value`プロパティです。 このように、外から直接読み書きしてほしくないプロパティを`_`（アンダーバー）から始まる名前にするのはただの習慣であるため、構文としての意味はありません。'
- en: ECMAScript 2022から、外から直接読み書きしてほしくないプライベートなプロパティを定義するPrivateクラスフィールド構文が追加されました。
    Privateクラスフィールド構文では`#`（ハッシュ）記号をプロパティ名の前につけます。 そのため、外から直接読み書きしてほしくないプロパティを`_`からはじめるという慣習は、Privateクラスフィールド構文の利用が進むにつれて使われなくなっていくと考えています。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2022から、外から直接読み書きしてほしくないプライベートなプロパティを定義するPrivateクラスフィールド構文が追加されました。
    Privateクラスフィールド構文では`#`（ハッシュ）記号をプロパティ名の前につけます。 そのため、外から直接読み書きしてほしくないプロパティを`_`からはじめるという慣習は、Privateクラスフィールド構文の利用が進むにつれて使われなくなっていくと考えています。
- en: Privateクラスフィールド構文については、この後に解説します。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Privateクラスフィールド構文については、この後に解説します。
- en: '[](#array-like-length)*`Array.prototype.length`をアクセッサプロパティで再現する*'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#array-like-length)*`Array.prototype.length`をアクセッサプロパティで再現する*'
- en: '*getterやsetterを利用しないと実現が難しいものとして、`Array.prototype.length`プロパティがあります。 Arrayの`length`プロパティへ値を代入すると、そのインデックス以降の要素は自動的に削除される仕様になっています。'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*getterやsetterを利用しないと実現が難しいものとして、`Array.prototype.length`プロパティがあります。 Arrayの`length`プロパティへ値を代入すると、そのインデックス以降の要素は自動的に削除される仕様になっています。'
- en: 次のコードでは、配列の要素数（`length`プロパティ）を小さくすると配列の要素が削除されています。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、配列の要素数（`length`プロパティ）を小さくすると配列の要素が削除されています。
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: この`length`プロパティの挙動を再現する`ArrayLike`クラスを実装してみます。 Arrayの`length`プロパティは、`length`プロパティへ値を代入した際に次のようなことを行っています。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: この`length`プロパティの挙動を再現する`ArrayLike`クラスを実装してみます。 Arrayの`length`プロパティは、`length`プロパティへ値を代入した際に次のようなことを行っています。
- en: 現在要素数より小さな**要素数**が指定された場合、その**要素数**を変更し、配列の末尾の要素を削除する
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 現在要素数より小さな**要素数**が指定された場合、その**要素数**を変更し、配列の末尾の要素を削除する
- en: 現在要素数より大きな**要素数**が指定された場合、その**要素数**だけを変更し、配列の実際の要素はそのままにする
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 現在要素数より大きな**要素数**が指定された場合、その**要素数**だけを変更し、配列の実際の要素はそのままにする
- en: ArrayLikeの`length`プロパティのsetterで要素の追加や削除を実装することで、配列のような`length`プロパティを実装できます。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayLikeの`length`プロパティのsetterで要素の追加や削除を実装することで、配列のような`length`プロパティを実装できます。
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: このようにアクセッサプロパティでは、プロパティのようでありながら実際にアクセスした際には他のプロパティと連動する動作を実現できます。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: このようにアクセッサプロパティでは、プロパティのようでありながら実際にアクセスした際には他のプロパティと連動する動作を実現できます。
- en: '[](#public-class-fields)*[ES2022] Publicクラスフィールド*'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#public-class-fields)*[ES2022] Publicクラスフィールド*'
- en: '*クラスでは、`constructor`メソッドの中でクラスの状態であるインスタンスのプロパティを初期化することを紹介しました。 先ほども紹介した`Counter`クラスでは、`constructor`メソッドの中で`count`プロパティの初期値を`0`として定義しています。'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスでは、`constructor`メソッドの中でクラスの状態であるインスタンスのプロパティを初期化することを紹介しました。 先ほども紹介した`Counter`クラスでは、`constructor`メソッドの中で`count`プロパティの初期値を`0`として定義しています。'
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: この`Counter`では`new`演算子で何も引数を渡すことなく初期化するため、`constructor`メソッドには仮引数を定義していません。 このような場合でも、`constructor`メソッドを書かないとプロパティの初期化ができないためわずらわしいという問題がありました。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: この`Counter`では`new`演算子で何も引数を渡すことなく初期化するため、`constructor`メソッドには仮引数を定義していません。 このような場合でも、`constructor`メソッドを書かないとプロパティの初期化ができないためわずらわしいという問題がありました。
- en: ES2022で、クラスのインスタンスが持つプロパティの初期化をわかりやすく宣言的にする構文として、**クラスフィールド**構文が追加されました。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ES2022で，クラスのインスタンスが持つプロパティの初期化をわかりやすく宣言的にする構文として，**クラスフィールド**構文が追加されました。
- en: クラスフィールドは、クラスのインスタンスが持つプロパティを定義する次のような構文です。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: クラスフィールドは，クラスのインスタンスが持つプロパティを定義する次のような構文です。
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: クラスフィールドを使って先ほどの`Counter`クラスを書き直してみると次のようになります。 `count`プロパティをクラスフィールドとして定義して、その初期値は`0`としています。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: クラスフィールドを使って先ほどの`Counter`クラスを書き直してみると次のようになります。 `count`プロパティをクラスフィールドとして定義して，その初期値は`0`としています。
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: クラスフィールドで定義するのは、クラスのインスタンスが持つプロパティです。 そのため、`constructor`メソッドの中で`this.count =
    0`のように定義した場合と結果的にはほとんど同じ意味となります。 クラスフィールドで定義したプロパティは、クラス内から他のプロパティと同じように`this.プロパティ名`で参照できます。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: クラスフィールドで定義するのは，クラスのインスタンスが持つプロパティです。 そのため，`constructor`メソッドの中で`this.count =
    0`のように定義した場合と結果的にはほとんど同じ意味となります。 クラスフィールドで定義したプロパティは，クラス内から他のプロパティと同じように`this.プロパティ名`で参照できます。
- en: クラスフィールドは`constructor`メソッドでの初期化と併用が可能です。 次のコードでは、クラスフィールドと`constructor`メソッドでそれぞれインスタンスのプロパティを定義しています。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: クラスフィールドは`constructor`メソッドでの初期化と併用が可能です。 次のコードでは，クラスフィールドと`constructor`メソッドでそれぞれインスタンスのプロパティを定義しています。
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: また、クラスフィールドでの初期化処理が行われ、そのあと`constructor`でのプロパティの定義という処理順となります。 そのため、同じプロパティ名への定義がある場合は、`constructor`メソッド内での定義でプロパティは上書きされます。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: また，クラスフィールドでの初期化処理が行われ，そのあと`constructor`でのプロパティの定義という処理順となります。 そのため，同じプロパティ名への定義がある場合は，`constructor`メソッド内での定義でプロパティは上書きされます。
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: この`publicField`プロパティのように、クラスの外からアクセスできるプロパティを定義するクラスフィールドを**Publicクラスフィールド**と呼びます。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: この`publicField`プロパティのように，クラスの外からアクセスできるプロパティを定義するクラスフィールドを**Publicクラスフィールド**と呼びます。
- en: '[](#declare-class-fields)*クラスフィールドを使ってプロパティの存在を宣言する*'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#declare-class-fields)*クラスフィールドを使ってプロパティの存在を宣言する*'
- en: '*クラスフィールドでは、プロパティの初期値は省略可能となっています。 そのため、次のように初期値を省略したPublicクラスフィールドも定義できます。'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスフィ��ルドでは，プロパティの初期値は省略可能となっています。 そのため，次のように初期値を省略したPublicクラスフィールドも定義できます。'
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: このときの`myProperty`は`undefined`で初期化されます。 この初期値を省略したクラスフィールドの定義は、クラスのインスタンスが持つプロパティを明示するために利用できます。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: このときの`myProperty`は`undefined`で初期化されます。 この初期値を省略したクラスフィールドの定義は，クラスのインスタンスが持つプロパティを明示するために利用できます。
- en: 次の`Loader`クラスは、`load`メソッドを呼び出すまでは、`loadedContent`プロパティの値は`undefined`です。 クラスフィールドを使えば、`Loader`クラスのインスタンスは、`loadedContent`というプロパティを持っていることを宣言的に表現できます。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 次の`Loader`クラスは，`load`メソッドを呼び出すまでは，`loadedContent`プロパティの値は`undefined`です。 クラスフィールドを使えば，`Loader`クラスのインスタンスは，`loadedContent`というプロパティを持っていることを宣言的に表現できます。
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: JavaScriptでは、オブジェクトのプロパティは初期化時に存在していなくても、後から代入すれば作成できてしまいます。 そのため、次のように`Loader`クラスを実装しても意味は同じです。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScriptでは，オブジェクトのプロパティは初期化時に存在していなくても，後から代入すれば作成できてしまいます。 そのため，次のように`Loader`クラスを実装しても意味は同じです。
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: しかし、このように実装してしまうと`Loader`クラスを利用する側は、`loadedContent`プロパティの存在を`load`メソッドの中まで読まないとわからないという問題があります。
    これに対して、クラスフィールドを使って「`Loader`クラスは`loadedContent`というプロパティを持っている」ということを宣言的に表現できます。
    宣言的にプロパティを定義することで、エディターでのコード補完が可能になったり、コードを読む人に優しいというメリットがあります。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: しかし，このように実装してしまうと`Loader`クラスを利用する側は，`loadedContent`プロパティの存在を`load`メソッドの中まで読まないとわからないという問題があります。
    これに対して，クラスフィールドを使って「`Loader`クラスは`loadedContent`というプロパティを持っている」ということを宣言的に表現できます。
    宣言的にプロパティを定義することで，エディターでのコード補完が可能になったり，コードを読む人に優しいというメリットがあります。
- en: '[](#this-in-class-fields)*クラスフィールドでの`this`はクラスのインスタンスを示す*'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#this-in-class-fields)*クラスフィールドでの`this`はクラスのインスタンスを示す*'
- en: '*クラスフィールドの初期値には任意の式が書け、`this`も利用できます。 クラスフィールドでの`this`は、そのクラスのインスタンスを参照します。'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスフィールドの初期値には任意の式が書け，`this`も利用できます。 クラスフィールドでの`this`は，そのクラスのインスタンスを参照します。'
- en: 次のコードでは、`up`フィールドの初期値に`increment`メソッドを指定しています。 JavaScriptでは関数も値として扱えるため、`up`メソッドを呼び出すと`increment`メソッドが呼び出されます。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは，`up`フィールドの初期値に`increment`メソッドを指定しています。 JavaScriptでは関数も値として扱えるため，`up`メソッドを呼び出すと`increment`メソッドが呼び出されます。
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: クラスフィールドでの`this`は、Arrow Functionと組み合わせると強力です。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: クラスフィールドでの`this`は，Arrow Functionと組み合わせると強力です。
- en: 次のコードでは、`up`メソッドをArrow Functionとして定義し、関数内では`this.increment`メソッドを呼び出しています。 Arrow
    Functionで定義した関数における`this`は、どのような呼び出し方をしても変化しません（「[Arrow Functionでコールバック関数を扱う](../function-this/#arrow-function-callback)」を参照）。
    そのため、`up`メソッドはどのような呼び方をした場合でも`this`がクラスのインスタンスとなるため、確実に`increment`メソッドを呼び出せます。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは，`up`メソッドをArrow Functionとして定義し，関数内では`this.increment`メソッドを呼び出しています。 Arrow
    Functionで定義した関数における`this`は，どのような呼び出し方をしても変化しません（「[Arrow Functionでコールバック関数を扱う](../function-this/#arrow-function-callback)」を参照）。
    そのため，`up`メソッドはどのような呼び方をした場合でも`this`がクラスのインスタンスとなるため，確実に`increment`メソッドを呼び出せます。
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[](#difference-between-class-fields-and-instance-property)*[コラム] クラスフィールドとインスタンスのプロパティの違い*'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#difference-between-class-fields-and-instance-property)*[コラム] クラスフィールドとインスタンスのプロパティの違い*'
- en: '*クラスフィールドで定義したプロパティやメソッドは、クラスのインスタンスにプロパティとして定義されます。 そのため、クラスフィールドは、`constructor`の中で`this`に対してプロパティを追加するのと意味的にはほぼ同じで、見た目がわかりやすくなった構文と捉えることができます。'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスフィールドで定義したプロパティやメソッドは，クラスのインスタンスにプロパティとして定義されます。 そのため，クラスフィールドは，`constructor`の中で`this`に対してプロパティを追加するのと意味的にはほぼ同じで，見た目がわかりやすくな���た構文と捉えることができます。'
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: しかし、厳密にはこのふたつのプロパティ定義には異なる点はあります。 次のように、クラスフィールドと`constructor`の中で`this`に追加するプロパティ名に対するsetterを定義してみるとこの違いがわかります。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: しかし，厳密にはこのふたつのプロパティ定義には異なる点はあります。 次のように，クラスフィールドと`constructor`の中で`this`に追加するプロパティ名に対するsetterを定義してみるとこの違いがわかります。
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: クラスフィールド名に対するsetterは呼び出されないのに対して、`this.property`への代入に対するsetterは呼び出されています。 これは、クラスフィールドは`=`を使った代入で定義されるのではなく、[Object.defineProperty](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)メソッドを使ってプロパティが定義されるという違いがあります。
    `Object.defineProperty`を使ったプロパティの定義では、setterは無視してプロパティが定義されます。 setterは`=`での代入に反応します。そのため、`constructor`の中での`this.property`への代入に対してはsetterが呼び出されます。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: クラスフィールド名に対するsetterは呼び出されないのに対して，`this.property`への代入に対するsetterは呼び出されています。 これは，クラスフィールドは`=`を使った代入で定義されるのではなく，[Object.defineProperty](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)メソッドを使ってプロパティが定義されるという違いがあります。
    `Object.defineProperty`を使ったプロパティの定義では，setterは無視してプロパティが定義されます。 setterは`=`での代入に反応します。そのため，`constructor`の中での`this.property`への代入に対してはsetterが呼び出されます。
- en: 同じプロパティの定義であっても、プロパティの定義の仕組みが微妙に異なる点から、このような挙動の違いが存在しています。 しかし、この違いを意識するようなコードを書くことは避けたほうが安全です。
    実際に見た目からこの違いを意識するのは難しく、それを意識させるようなコードは複雑性が高いためです。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同じプロパティの定義であっても，プロパティの定義の仕組みが微妙に異なる点から，このような挙動の違いが存在しています。 しかし，この違いを意識するようなコードを書くことは避けたほうが安全です。
    実際に見た目からこの違いを意識するのは難しく，それを意識させるようなコードは複雑性が高いためです。
- en: '[](#private-class-fields)*[ES2022] Privateクラスフィールド*'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#private-class-fields)*[ES2022] Privateクラスフィールド*'
- en: '*クラスフィールド構文で次のように書くと、定義したプロパティはクラスをインスタンス化した後に外からも参照できます。 そのため、Publicクラスフィールドと呼ばれます。'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスフィールド構文で次のように書くと、定義したプロパティはクラスをインスタンス化した後に外からも参照できます。 そのため、Publicクラスフィールドと呼ばれます。'
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 一方で外からアクセスされたくないインスタンスのプロパティも存在します。 そのようなプライベートなプロパティを定義する構文もES2022で追加されています。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一方で外からアクセスされたくないインスタンスのプロパティも存在します。 そのようなプライベートなプロパティを定義する構文もES2022で追加されています。
- en: Privateクラスフィールドは、次のように`#`をフィールド名の前につけたクラスフィールドを定義します。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Privateクラスフィールドは、次のように`#`をフィールド名の前につけたクラスフィールドを定義します。
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 定義したPrivateクラスフィールドは、`this.#フィールド名`で参照できます。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定義したPrivateクラスフィールドは、`this.#フィールド名`で参照できます。
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: もう少し具体的なPrivateクラスフィールドの使い方を見ていきます。 アクセッサプロパティの例でも登場した`NumberWrapper`をPrivateクラスフィールドを使って書き直してみます。
    元々の`NumberWrapper`クラスでは、`_value`プロパティに実際の値を読み書きしていました。 この場合、`_value`プロパティは、外からもアクセスできてしまうため、定義したgetterとsetterが無視できてしまいます。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: もう少し具体的なPrivateクラスフィールドの使い方を見ていきます。 アクセッサプロパティの例でも登場した`NumberWrapper`をPrivateクラスフィールドを使って書き直してみます。
    元々の`NumberWrapper`クラスでは、`_value`プロパティに実際の値を読み書きしていました。 この場合、`_value`プロパティは、外からもアクセスできてしまうため、定義したgetterとsetterが無視できてしまいます。
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Privateクラスフィールドでは、外からアクセスされたくないプロパティを`#`をつけてクラスフィールドとして定義します。 次のコードでは、`#value`はプライベートプロパティとなっているため、構文エラーが発生し外からアクセスできなくなることが確認できます。
    Privateクラスフィールドを使うことで、クラスを利用する際はgetterとsetterを経由しないと`#value`を参照できなくなりました。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Privateクラスフィールドでは、外からアクセスされたくないプロパティを`#`をつけてクラスフィールドとして定義します。 次のコードでは、`#value`はプライベートプロパティとなっているため、構文エラーが発生し外からアクセスできなくなることが確認できます。
    Privateクラスフィールドを使うことで、クラスを利用する際はgetterとsetterを経由しないと`#value`を参照できなくなりました。
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Privateクラスフィールドを使うことで、クラスの外からアクセスさせたくないプロパティを宣言できます。 これは、実装したクラスの意図しない使われ方を防いだり、クラスの外からプロパティの状態を直接書き換えるといった行為を防げます。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Privateクラスフィールドを使うことで、クラスの外からアクセスさせたくないプロパティを宣言できます。 これは、実装したクラスの意図しない使われ方を防いだり、クラスの外からプロパティの状態を直接書き換えるといった行為を防げます。
- en: また、Privateクラスフィールドでは、途中から値が入る場合でもフィールドの宣言が必須となっています。 次のコードでは、`#loadedContent`に実際に値が入るのは`load`メソッドが呼び出されたときです。
    Publicクラスフィールドではフィールドの定義は省略可能でしたが、Privateクラスフィールドでは`#loadedContent`フィールドの定義が必須となっています。
    言い換えると、Privateクラスフィールドでは、クラスを定義した段階でクラスに存在するすべてのPrivateクラスフィールドを明示する必要があります。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: また、Privateクラスフィールドでは、途中から値が入る場合でもフィールドの宣言が必須となっています。 次のコードでは、`#loadedContent`に実際に値が入るのは`load`メソッドが呼び出されたときです。
    Publicクラスフィールドではフィールドの定義は省略可能でしたが、Privateクラスフィールドでは`#loadedContent`フィールドの定義が必須となっています。
    言い換えると、Privateクラスフィールドでは、クラスを定義した段階でクラスに存在するすべてのPrivateクラスフィールドを明示する必要があります。
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[](#static-method)*静的メソッド*'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#static-method)*静的メソッド*'
- en: '*インスタンスメソッドは、クラスをインスタンス化して利用します。 一方、クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*インスタンスメソッドは、クラスをインスタンス化して利用します。 一方、クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。'
- en: 静的メソッドの定義方法はメソッド名の前に、`static`をつけるだけです。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 静的メソッドの定義方法はメソッド名の前に、`static`をつけるだけです。
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 次のコードでは、配列をラップする`ArrayWrapper`というクラスを定義しています。 `ArrayWrapper`はコンストラクタの引数として配列を受け取って初期化しています。
    このクラスに配列ではなく要素そのものを引数に受け取ってインスタンス化できる`ArrayWrapper.of`という静的メソッドを定義します。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、配列をラップする`ArrayWrapper`というクラスを定義しています。 `ArrayWrapper`はコンストラクタの引数として配列を受け取って初期化しています。
    このクラスに配列ではなく要素そのものを引数に受け取ってインスタンス化できる`ArrayWrapper.of`という静的メソッドを定義します。
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: クラスの静的メソッドにおける`this`は、そのクラス自身を参照します。 そのため、先ほどのコードは`new ArrayWrapper`の代わりに`new
    this`と書くこともできます。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: クラスの静的メソッドにおける`this`は、そのクラス自身を参照します。 そのため、先ほどのコードは`new ArrayWrapper`の代わりに`new
    this`と書くこともできます。
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: このように静的メソッドでの`this`はクラス自身を参照するため、クラスのインスタンスは参照できません。 そのため静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: このように静的メソッドでの`this`はクラス自身を参照するため、クラスのインスタンスは参照できません。 そのため静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。
- en: '[](#static-class-fields)*[ES2022] 静的クラスフィールド*'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#static-class-fields)*[ES2022] 静的クラスフィールド*'
- en: '*ES2022で追加されたクラスフィールドでは、インスタンスではなくクラス自体に定義する静的クラスフィールドも利用できます。'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*ES2022で追加されたクラスフィールドでは、インスタンスではなくクラス自体に定義する静的クラスフィールドも利用できます。'
- en: 静的クラスフィールドは、フィールドの前に`static`をつけるだけです。 静的クラスフィールドで定義したプロパティは、クラス自体のプロパティとして定義されます。
    次のコードでは、Public静的クラスフィールドを使って`Colors`クラス自体にプロパティを定義しています。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 静的クラスフィールドは、フィールドの前に`static`をつけるだけです。 静的クラスフィールドで定義したプロパティは、クラス自体のプロパティとして定義されます。
    次のコードでは、Public静的クラスフィールドを使って`Colors`クラス自体にプロパティを定義しています。
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: また、Privateクラスフィールドも静的に利用できます。 Private静的クラスフィールドは、クラス自体にプロパティを定義したいが、そのプロパティを外から参照されたくない場合に利用します。
    Private静的クラスフィールドはフィールドの前に、`static`をつけるだけです。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: また、Privateクラスフィールドも静的に利用できます。 Private静的クラスフィールドは、クラス自体にプロパティを定義したいが、そのプロパティを外から参照されたくない場合に利用します。
    Private静的クラスフィールドはフィールドの前に、`static`をつけるだけです。
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[](#two-instance-method-definition)*プロトタイプに定義したメソッドとインスタンスに定義したメソッドの違い*'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#two-instance-method-definition)*プロトタ��プに定義したメソッドとインスタンスに定義したメソッドの違い*'
- en: '*ここまでで、プロトタイプメソッドの定義とクラスフィールドを使ったインスタンスに対するメソッドの定義の2種類を見てきました。 プロトタイプメソッドの定義方法は、メソッドをプロトタイプオブジェクトという特殊なオブジェクトに定義します。
    一方で、クラスフィールドで定義したメソッドは、クラスのインスタンスに対してメソッドを定義します。'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*ここまでで、プロトタイプメソッドの定義とクラスフィールドを使ったインスタンスに対するメソッドの定義の2種類を見てきました。 プロトタイプメソッドの定義方法は、メソッドをプロトタイプオブジェクトという特殊なオブジェクトに定義します。
    一方で、クラスフィールドで定義したメソッドは、クラスのインスタンスに対してメソッドを定義します。'
- en: どちらのメソッド定義方法でも、`new`演算子でインスタンス化したオブジェクトからメソッドを呼び出すことができる点は同じです。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: どちらのメソッド定義方法でも、`new`演算子でインスタンス化したオブジェクトからメソッドを呼び出すことができる点は同じです。
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: しかしこの2つのメソッドの定義方法は、メソッドの定義先となるオブジェクトが異なります。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: しかしこの2つのメソッドの定義方法は、メソッドの定義先となるオブジェクトが異なります。
- en: まず、この2種類のメソッドがそれぞれ別の場所へと定義されていることを見ていきます。 次のコードでは、`ConflictClass`クラスに`method`という同じ名前のメソッドをプロトタイプメソッドとインスタンスに対してそれぞれ定義しています。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: まず、この2種類のメソッドがそれぞれ別の場所へと定義されていることを見ていきます。 次のコードでは、`ConflictClass`クラスに`method`という同じ名前のメソッドをプロトタイプメソッドとインスタンスに対してそれぞれ定義しています。
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 結論から述べると、この場合はインスタンスオブジェクトに定義した`method`が呼び出されます。 このとき、インスタンスの`method`プロパティを`delete`演算子で削除すると、今度はプロトタイプメソッドの`method`が呼び出されます。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 結論から述べると、この場合はインスタンスオブジェクトに定義した`method`が呼び出されます。 このとき、インスタンスの`method`プロパティを`delete`演算子で削除すると、今度はプロトタイプメソッドの`method`が呼び出されます。
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: この実行結果から次のことがわかります。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: この実行結果から次のことがわかります。
- en: プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている
- en: インスタンスオブジェクトのメソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: インスタンスオブジェクトの��ソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている
- en: どちらも注意深く意識しないと気づきにくいですが、この挙動はJavaScriptの重要な仕組みであるため理解することは重要です。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: どちらも注意深く意識しないと気づきにくいですが、この挙動はJavaScriptの重要な仕組みであるため理解することは重要です。
- en: この挙動は**プロトタイプオブジェクト**と呼ばれる特殊なオブジェクトと**プロトタイプチェーン**と呼ばれる仕組みで成り立っています。 どちらも**プロトタイプ**とついていることからわかるように、2つで1組のような仕組みです。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: この挙動は**プロトタイプオブジェクト**と呼ばれる特殊なオブジェクトと**プロトタイプチェーン**と呼ばれる仕組みで成り立っています。 どちらも**プロトタイプ**とついていることからわかるように、2つで1組のような仕組みです。
- en: 次のセクションでは、**プロトタイプオブジェクト**と**プロトタイプチェーン**とはどのような仕組みなのかを見ていきます。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 次のセクションでは、**プロトタイプオブジェクト**と**プロトタイプチェーン**とはどのような仕組みなのかを見ていきます。
- en: '[](#prototype)*プロトタイプオブジェクト*'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#prototype)*プロトタイプオブジェクト*'
- en: '***プロトタイプメソッド**と**インスタンスオブジェクトのメソッド**を同時に定義しても、互いのメソッドは上書きされるわけでありません。 なぜなら、プロトタイプメソッドは**プロトタイプオブジェクト**へ、インスタンスオブジェクトのメソッドは**インスタンスオブジェクト**へそれぞれ定義されるためです。'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '***プロトタイプメソッド**と**インスタンスオブジェクトのメソッド**を同時に定義しても、互いのメソッドは上書きされるわけでありません。 なぜなら、プロトタイプメソッドは**プロトタイプオブジェクト**へ、インスタンスオブジェクトのメソッドは**インスタンスオブジェクト**へそれぞれ定義されるためです。'
- en: プロトタイプオブジェクトについては「[プロトタイプオブジェクト](../prototype-object/)」の章で簡単に紹介していましたが、改めて解説していきます。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: プロトタイプオブジェクトについては「[プロトタイプオブジェクト](../prototype-object/)」の章で簡単に紹介していましたが、改めて解説していきます。
- en: '**プロトタイプオブジェクト**とは、JavaScriptの関数オブジェクトの`prototype`プロパティに自動的に作成される特殊なオブジェクトです。
    クラスも一種の関数オブジェクトであるため、自動的に`prototype`プロパティにプロトタイプオブジェクトが作成されています。'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**プロトタイプオブジェクト**とは、JavaScriptの関数オブジェクトの`prototype`プロパティに自動的に作成される特殊なオブジェクトです。
    クラスも一種の関数オブジェクトであるため、自動的に`prototype`プロパティにプロトタイプオブジェクトが作成されています。'
- en: 次のコードでは、関数やクラス自身の`prototype`プロパティに、プロトタイプオブジェクトが自動的に作成されていることがわかります。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、関数やクラス自身の`prototype`プロパティに、プロトタイプオブジェクトが自動的に作成されていることがわかります。
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`class`構文のメソッド定義は、このプロトタイプオブジェクトのプロパティとして定義されます。'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`構文のメソッド定義は、このプロトタイプオブジェクトのプロパティとして定義されます。'
- en: 次のコードでは、クラスのメソッドがプロトタイプオブジェクトに定義されていることを確認できます。 また、クラスには`constructor`メソッド（コンストラクタ）が必ず定義されます。
    この`constructor`メソッドもプロトタイプオブジェクトに定義されており、この`constructor`プロパティはクラス自身を参照します。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、クラスのメソッドがプロトタイプオブジェクトに定義されていることを確認できます。 また、クラスには`constructor`メソッド（コンストラクタ）が必ず定義されます。
    この`constructor`メソッドもプロトタイプオブジェクトに定義されており、この`constructor`プロパティはクラス自身を参照します。
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: このように、プロトタイプメソッドはプロトタイプオブジェクトに定義され、インスタンスオブジェクトのメソッドとは異なるオブジェクトに定義されています。そのため、それぞれの方法でメソッドを定義しても、上書きされることはありません。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: このように、プロトタイプメソッドはプロトタイプオブジェクトに定義され、インスタンスオブジェクトのメソッドとは異なるオブジェクトに定義されています。そのため、それぞれの方法でメソッドを定義しても、上書きされることはありません。
- en: '[](#prototype-chain)*プロトタイプチェーン*'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#prototype-chain)*プロトタイプチェーン*'
- en: '*`class`構文で定義したプロトタイプメソッドはプロトタイプオブジェクトに定義されます。 しかし、インスタンス（オブジェクト）にはメソッドが定義されていないのに、インスタンスからクラスのプロトタイプメソッドを呼び出せます。'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*`class`構文で定義したプロトタイプメソッドはプロトタイプオブジェクトに定義されます。 しかし、インスタンス（オブジェクト）にはメソッドが定義されていないのに、インスタンスからクラスのプロトタイプメソッドを呼び出せます。'
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: インスタンスからプロトタイプメソッドを呼び出せるのは**プロトタイプチェーン**と呼ばれる仕組みによるものです。 プロトタイプチェーンは2つの処理から成り立ちます。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: インスタンスからプロトタイプメソッドを呼び出せるのは**プロトタイプチェーン**と呼ばれる仕組みによるものです。 プロトタイプチェーンは2つの処理から成り立ちます。
- en: インスタンス作成時に、インスタンスの`[[Prototype]]`内部プロパティへプロトタイプオブジェクトの参照を保存する処理
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: インスタンス作成時に、インスタンスの`[[Prototype]]`内部プロパティへプロトタイプオブジェクトの参照を保存する処理
- en: インスタンスからプロパティ（またはメソッド）を参照するときに、`[[Prototype]]`内部プロパティまで探索する処理
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: インスタンスからプロパティ（またはメソッド）を参照するときに、`[[Prototype]]`内部プロパティまで探索する処理
- en: '[](#write-prototype-chain)*インスタンス作成とプロトタイプチェーン*'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#write-prototype-chain)*インスタンス作成とプロトタイプチェーン*'
- en: '*クラスから`new`演算子によってインスタンスを作成する際に、インスタンスにはクラスのプロトタイプオブジェクトへの参照が保存されます。 このとき、インスタンスからクラスのプロトタイプオブジェクトへの参照は、インスタンスオブジェクトの`[[Prototype]]`という内部プロパティに保存されます。'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*クラスから`new`演算子によってインスタンスを作成する際に、インスタンスにはクラスのプロトタイプオブジェクトへの参照が保存されます。 こ���とき、インスタンスからクラスのプロトタイプオブジェクトへの参照は、インスタンスオブジェクトの`[[Prototype]]`という内部プロパティに保存されます。'
- en: '`[[Prototype]]`内部プロパティはECMAScriptの仕様で定められた内部的な表現であるため、通常のプロパティのようにはアクセスできません。
    ここでは説明のために、`[[プロパティ名]]`という書式でECMAScriptの仕様上に存在する内部プロパティを表現しています。'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[Prototype]]`内部プロパティはECMAScriptの仕様で定められた内部的な表現であるため、通常のプロパティのようにはアクセスできません。
    ここでは説明のために、`[[プロパティ名]]`という書式でECMAScriptの仕様上に存在する内部プロパティを表現しています。'
- en: '`[[Prototype]]`内部プロパティへプロパティのようにはアクセスできませんが、`Object.getPrototypeOf`メソッドで`[[Prototype]]`内部プロパティを参照できます。'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[Prototype]]`内部プロパティへプロパティのようにはアクセスできませんが、`Object.getPrototypeOf`メソッドで`[[Prototype]]`内部プロパティを参照できます。'
- en: 次のコードでは、`instance`オブジェクトの`[[Prototype]]`内部プロパティを取得しています。 その取得した結果がクラスのプロトタイプオブジェクトを参照していることを確認できます。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`instance`オブジェクトの`[[Prototype]]`内部プロパティを取得しています。 その取得した結果がクラスのプロトタイプオブジェクトを参照していることを確認できます。
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ここで重要なのは、インスタンスはどのクラスから作られたかやそのクラスのプロトタイプオブジェクトを知っているということです。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ここで重要なのは、インスタンスはどのクラスから作られたかやそのクラスのプロトタイプオブジェクトを知っているということです。
- en: '[](#inner-property)*[Note] `[[Prototype]]`内部プロパティを読み書きする*'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[](#inner-property)*[Note] `[[Prototype]]`内部プロパティを読み書きする*'
- en: '*`Object.getPrototypeOf(オブジェクト)`で`オブジェクト`の`[[Prototype]]`を読み取ることができます。 一方、`Object.setPrototypeOf(オブジェクト,
    プロトタイプオブジェクト)`で`オブジェクト`の`[[Prototype]]`に`プロトタイプオブジェクト`を設定できます。 また、`[[Prototype]]`内部プロパティを通常のプロパティのように扱える`__proto__`という特殊なアクセッサプロパティが存在します。'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*`Object.getPrototypeOf(オブジェクト)`で`オブジェクト`の`[[Prototype]]`を読み取ることができます。 一方、`Object.setPrototypeOf(オブジェクト,
    プロトタイプオブジェクト)`で`オブジェクト`の`[[Prototype]]`に`プロトタイプオブジェクト`を設定できます。 また、`[[Prototype]]`内部プロパティを通常のプロパティのように扱え���`__proto__`という特殊なアクセッサプロパティが存在します。'
- en: しかし、これらの`[[Prototype]]`内部プロパティを直接読み書きすることは通常の用途では行いません。 また、既存のビルトインオブジェクトの動作なども変更できるため、不用意に扱うべきではないでしょう。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: しかし、これらの`[[Prototype]]`内部プロパティを直接読み書きすることは通常の用途では行いません。 また、既存のビルトインオブジェクトの動作なども変更できるため、不用意に扱うべきではないでしょう。
- en: '[](#read-prototype-chain)*プロパティの参照とプロトタイプチェーン*'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#read-prototype-chain)*プロパティの参照とプロトタイプチェーン*'
- en: '*プロトタイプオブジェクトのプロパティがどのようにインスタンスから参照されるかを見ていきます。'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*プロトタイプオブジェクトのプロパティがどのようにインスタンスから参照されるかを見ていきます。'
- en: オブジェクトのプロパティを参照するときに、オブジェクト自身がプロパティを持っていない場合でも、そこで探索が終わるわけではありません。 オブジェクトの`[[Prototype]]`内部プロパティ（仕様上の内部的なプロパティ）の参照先であるプロトタイプオブジェクトに対しても探索を続けます。
    これは、スコープに指定した識別子の変数がなかった場合に外側のスコープへと探索するスコープチェーンと良く似た仕組みです。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: オブジェクトのプロパティを参照するときに、オブジェクト自身がプロパティを持っていない場合でも、そこで探索が終わるわけではありません。 オブジェクトの`[[Prototype]]`内部プロパティ（仕様上の内部的なプロパティ）の参照先であるプロトタイプオブジェクトに対しても探索を続けます。
    これは、スコープに指定した識別子の変数がなかった場合に外側のスコープへと探索するスコープチェーンと良く似た仕組みです。
- en: つまり、オブジェクトがプロパティを探索するときは次のような順番で、それぞれのオブジェクトを調べます。 すべてのオブジェクトにおいて見つからなかった場合の結果は`undefined`を返します。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: つまり、オブジェクトがプロパティを探索するときは次のような順番で、それぞれのオブジェクトを調べます。 すべてのオブジェクトにおいて見つからなかった場合の結果は`undefined`を返します。
- en: '`instance`オブジェクト自身'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance`オブジェクト自身'
- en: '`instance`オブジェクトの`[[Prototype]]`の参照先（プロトタイプオブジェクト）'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance`オブジェクトの`[[Prototype]]`の参照先（プロトタイプオブジェクト）'
- en: どこにもなかった場合は`undefined`
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: どこにもなかった場合は`undefined`
- en: 次のコードでは、インスタンスオブジェクト自身は`method`プロパティを持っていません。 そのため、実際に参照しているのはクラスのプロトタイプオブジェクトの`method`プロパティです。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、インスタンスオブジェクト自身は`method`プロパティを持っていません。 そのため、実際に参照しているのはクラスのプロトタイプオブジェクトの`method`プロパティです。
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: このように、インスタンスオブジェクトに`method`が定義されていなくても、クラスのプロトタイプオブジェクトの`method`を呼び出すことができます。
    このプロパティを参照する際に、オブジェクト自身から`[[Prototype]]`内部プロパティへと順番に探す仕組みのことを**プロトタイプチェーン**と呼びます。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: このように、インスタンスオブジェクトに`method`が定義されていなくても、クラスのプロトタイプオブジェクトの`method`を呼び出すことができます。
    このプロパティを参照する際に、オブジェクト自身から`[[Prototype]]`内部プロパティへと順番に探す仕組みのことを**プロトタイプチェーン**と呼びます。
- en: プロトタイプチェーンの仕組みを疑似的なコードとして表現すると次のような動きをしています。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: プロトタイプチェーンの仕組みを疑似的なコードとして表現すると次のような動きをしています。
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: プロトタイプチェーンの仕組みによって、プロトタイプオブジェクトに定義したプロトタイプメソッドをインスタンスから呼び出せます。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过原型链机制，我们可以从原型对象中定义的原型方法中调用实例。
- en: 普段は、プロトタイプオブジェクトやプロトタイプチェーンといった仕組みを意識する必要はありません。 `class`構文はこのようなプロトタイプを意識せずにクラスを利用できるように導入された構文です。
    しかし、プロトタイプベースである言語のJavaScriptではクラスをこのようなプロトタイプを使って表現していることは知っておくとよいでしょう。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 普通情况下，无需关注原型对象或原型链等机制。 `class`语法是为了让我们在不关注这些原型的情况下使用类而引入的语法。 但是，在基于原型的JavaScript中，了解类是如何通过原型来表示是有好处的。
- en: '[](#extends)*継承*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#extends)*继承*'
- en: '*`extends`キーワードを使うことで既存のクラスを継承できます。 継承とは、クラスの**構造**や**機能**を引き継いだ新しいクラスを定義することです。'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过使用`extends`关键字，您可以继承现有的类。 继承是指定义一个新类，该类继承了父类的**结构**和**功能**。'
- en: '[](#class-extends)*継承したクラスの定義*'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#class-extends)*继承的类定义*'
- en: '*`extends`キーワードを使って既存のクラスを継承した新しいクラスを定義してみます。 `class`構文の右辺に`extends`キーワードで継承元となる**親クラス**（基底クラス）を指定することで、
    親クラスを継承した**子クラス**（派生クラス）を定義できます。'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过使用`extends`关键字来定义继承自父类（基类）的**子类**（派生类）。 通过在`class`语法的右侧使用`extends`关键字指定要继承的**父类**（基类），可以定义继承自父类的**子类**（派生类）。'
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 次のコードでは、`Parent`クラスを継承した`Child`クラスを定義しています。 子クラスである`Child`クラスのインスタンス化は通常のクラスと同じく`new`演算子を使って行います。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们定义了继承自`Parent`类的`Child`类。 实例化子类`Child`类与普通类一样使用`new`运算符。
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[](#class-super)*`super`*'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#class-super)*`super`*'
- en: '*`extends`を使って定義した子クラスから親クラスを参照するには`super`というキーワードを利用します。 もっともシンプルな`super`を使う例としてコンストラクタの処理を見ていきます。'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*要从使用`extends`定义的子类引用父类，需要使用名为`super`的关键字。 我们将看到使用最简单的`super`的示例，以查看构造函数的处理。 '
- en: '`class`構文でも紹介しましたが、クラスは必ず`constructor`メソッド（コンストラクタ）を持ちます。 これは、継承した子クラスでも同じです。'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`class`语法中介绍的那样，类必须具有`constructor`方法（构造函数）。 这也适用于继承的子类。
- en: 次のコードでは、`Parent`クラスを継承した`Child`クラスのコンストラクタで、`super()`を呼び出しています。 `super()`は子クラスから親クラスの`constructor`メソッドを呼び出します。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，在`Child`类的构造函数中，我们调用了`super()`。 `super()`会调用父类的`constructor`方法。
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`class`構文でのクラス定義では、`constructor`メソッド（コンストラクタ）で何も処理しない場合は省略できることを紹介しました。 これは、継承した子クラスでも同じです。'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`class`语法中，如果`constructor`方法（构造函数）不执行任何操作，则可以省略它。 这也适用于继承的子类。
- en: 次のコードの`Child`クラスのコンストラクタでは、何も処理を行っていません。 そのため、`Child`クラスの`constructor`メソッドの定義を省略できます。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`Child`类的构造函数没有执行任何操作。 因此，可以省略`Child`类的`constructor`方法的定义。
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: このように子クラスで`constructor`を省略した場合は次のように書いた場合と同じ意味になります。 `constructor`メソッドの引数をすべて受け取り、そのまま`super`へ引数の順番を維持して渡します。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在子类中省略了`constructor`，则与下面的代码相同。 接收`constructor`方法的所有参数，并将它们按顺序传递给`super`。
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[](#constructor-order)*コンストラクタの処理順は親クラスから子クラスへ*'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#constructor-order)*构造函数的处理顺序是从父类到子类*'
- en: '*コンストラクタの処理順は、親クラスから子クラスへと順番が決まっています。'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*构造函数的处理顺序是从父类到子类。'
- en: '`class`構文では必ず親クラスのコンストラクタ処理（`super()`の呼び出し）を先に行い、その次に子クラスのコンストラクタ処理を行います。 子クラスのコンストラクタでは、`this`を触る前に`super()`で親クラスのコンストラクタ処理を呼び出さないと`ReferenceError`となるためです。'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`class`语法中，必须首先执行父类的构造函数处理（调用`super()`），然后执行子类的构造函数处理。 在子类的构造函数中，在引用`this`之前必须先调用`super()`以调用父类的构造函数处理，否则会导致`ReferenceError`。
- en: 次のコードでは、`Parent`と`Child`でそれぞれインスタンス（`this`）の`name`プロパティに値を書き込んでいます。 子クラスでは先に`super()`を呼び出してからでないと`this`を参照できません。
    そのため、コンストラクタの処理順は`Parent`から`Child`という順番に限定されます。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们分别在`Parent`和`Child`中写入了实例（`this`）的`name`属性。 在子类中，必须先调用`super()`，然后才能引用`this`。
    因此，构造函数的处理顺序被限制为从`Parent`到`Child`。
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[](#class-fields-inheritance)*クラスフィールドの継承*'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#class-fields-inheritance)*类字段继承*'
- en: '*Publicクラスフィールドもコンストラクタの処理順と同じく親クラスのフィールドが初期化された後に子クラスのフィールドが初期化されます。 Publicクラスフィールドは、インスタンスオブジェクトに対してプロパティを定義する構文でした。
    そのため、親クラスで定義されていたフィールドも、実際にインスタンス化したオブジェクトのプロパティとして定義されます。'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*Public类字段与构造函数的处理顺序相同，即在初始化父类字段之后初始化子类字段。 Public类字段是一种定义实例对象属性的语法。 因此，父类中定义的字段也会被定义为实际实例化的对象的属性。'
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 同じ名前のフィールドが定義されている場合は、子クラスのフィールド定義で上書きされます。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在相同名称的字段，则将在子类的字段定义中进行覆盖。
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Publicクラスフィールドは、このように親クラスで定義したフィールドも子クラスに定義されます。 一方で、Privateクラスフィールドは、このように親クラスで定義したフィールドは子クラスに定義されません。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Public类字段会将父类中定义的字段也定义在子类中。 另一方面，Private类字段不会将父类中定义的字段定义在子类中。
- en: 次のコードでは、親クラスで定義したPrivateクラスフィールドを子クラスから参照しようとしています。 しかし、`#parentField`は参照できずに構文エラーとなることがわかります。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们试图从子类中引用在父类中定义的Private类字段。 但是，我们发现`#parentField`无法被引用，导致语法错误。
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: これは、PrivateクラスフィールドのPrivateとは各クラスごとのPrivateを守る目的であるためです。 継承したクラスからPrivateクラスフィールドが利用できてしまうと、Privateな情報が子クラスに漏れてしまうためです。
    JavaScriptでは、クラスの外に公開したくないが、子クラスからは利用できるようにしたいというような中間の制限を持ったプロパティを定義する構文はありません。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Private类字段的Private旨在保护每个类的Private，因此从继承的类中可以使用Private类字段，这会导致Private信息泄漏给子类。
    在JavaScript中，没有一种语���可以定义既不想公开给类外部又想让子类使用的中间限制属性。
- en: このように子クラスも含むクラスの外からアクセスを厳密に拒否するPrivateをhard privateと呼びます。 JavaScriptでのPrivateクラスフィールドはhard
    privateとなっています。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，严格拒绝从子类外部访问的Private称为hard private。 JavaScript中的Private类字段被视为hard private。
- en: 一方で、子クラスからのアクセスは許可したり、クラス外からのアクセスが可能となるような特例を持つようなPrivateをsoft privateと呼びます。
    JavaScriptでのsoft privateは、WeakMapやWeakSetを使ってユーザー自身で実装する必要があります（「[Map/Set](../map-and-set/)」の章を参照）。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，允许子类访问或允许类外部访问的Private称为soft private。 在JavaScript中，soft private需要用户自己使用WeakMap或WeakSet来实现（请参考“[Map/Set](../map-and-set/)”章节）。
- en: '[](#prototype-inheritance)*プロトタイプ継承*'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#prototype-inheritance)*原型继承*'
- en: '*次のコードでは`extends`キーワードを使って`Parent`クラスを継承した`Child`クラスを定義しています。 `Parent`クラスでは`method`を定義しているため、これを継承している`Child`クラスのインスタンスからも呼び出せます。'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*在下面的代码中，我们使用`extends`关键字定义了继承自`Parent`类的`Child`类。 由于`Parent`类定义了`method`，因此可以从继承该方法的`Child`类的实例中调用。'
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: このように、子クラスのインスタンスから親クラスのプロトタイプメソッドもプロトタイプチェーンの仕組みによって呼び出せます。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，通过原型链机制，子类的实例也可以调用父类的原型方法。
- en: '`extends`によって継承した場合、子クラスのプロトタイプオブジェクトの`[[Prototype]]`内部プロパティには親クラスのプロトタイプオブジェクトが設定されます。
    このコードでは、`Child.prototype`オブジェクトの`[[Prototype]]`内部プロパティには`Parent.prototype`が設定されます。'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`extends`继承时，子类的原型对象的`[[Prototype]]`内部属性将设置为父类的原型对象。 在此代码中，`Child.prototype`对象的`[[Prototype]]`内部属性将设置为`Parent.prototype`。
- en: これにより、プロパティを参照する場合には次のような順番でオブジェクトを探索しています。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当引用属性时，会按照以下顺序搜索对象。
- en: '`instance`オブジェクト自身'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance`对象本身'
- en: '`Child.prototype`（`instance`オブジェクトの`[[Prototype]]`の参照先）'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Child.prototype`（指向`instance`对象的`[[Prototype]]`）'
- en: '`Parent.prototype`（`Child.prototype`オブジェクトの`[[Prototype]]`の参照先）'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parent.prototype`（指向`Child.prototype`对象的`[[Prototype]]`）'
- en: このプロトタイプチェーンの仕組みにより、`method`プロパティは`Parent.prototype`オブジェクトに定義されたものを参照します。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种原型链的机制，`method`属性引用了在`Parent.prototype`对象中定义的方法。
- en: このようにJavaScriptでは`class`構文と`extends`キーワードを使うことでクラスの**機能**を継承できます。 `class`構文ではプロトタイプオブジェクトを参照する仕組みによって継承が行われています。
    そのため、この継承の仕組みを**プロトタイプ継承**と呼びます。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过JavaScript的`class`语法和`extends`关键字，可以继承类的**功能**。`class`语法通过引用原型对象来实现继承。因此，这种继承机制被称为**原型继承**。
- en: '[](#static-inheritance)*静的メソッドの継承*'
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#static-inheritance)*静态方法的继承*'
- en: '*インスタンスとクラスのプロトタイプオブジェクトとの間にはプロトタイプチェーンがあります。 クラス自身（クラスのコンストラクタ）も親クラス自身（親クラスのコンストラクタ）との間にプロトタイプチェーンがあります。'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实例与类的原型对象之间存在原型链。类本身（类的构造函数）也与其父类本身（父类的构造函数）之间存在原型链。'
- en: 簡単に言えば、静的メソッドも継承されるということです。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，静态方法也会被继承。
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`extends`によって継承した場合、子クラスのコンストラクタの`[[Prototype]]`内部プロパティには親クラスのコンストラクタが設定されます。
    このコードでは、`Child`コンストラクタの`[[Prototype]]`内部プロパティに`Parent`コンストラクタが設定されます。'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`extends`进行继承时，子类构造函数的`[[Prototype]]`内部属性会被设置为父类构造函数。在这段代码中，`Child`构造函数的`[[Prototype]]`内部属性会被设置为`Parent`构造函数。
- en: つまり、先ほどのコードでは`Child.hello`プロパティを参照した場合には、次のような順番でオブジェクトを探索しています。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在先前的代码中，如果引用了`Child.hello`属性，将按照以下顺序搜索对象。
- en: '`Child`コンストラクタ'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Child`构造函数'
- en: '`Parent`コンストラクタ（`Child`コンストラクタの`[[Prototype]]`の参照先）'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parent`构造函数（指向`Child`构造函数的`[[Prototype]]`）'
- en: クラスのコンストラクタ同士にもプロトタイプチェーンの仕組みがあるため、子クラスは親クラスの静的メソッドを呼び出せます。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类的构造函数之间也存在原型链的机制，子类可以调用父类的静态方法。
- en: '[](#super-property)*`super`プロパティ*'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#super-property)*`super`属性*'
- en: '*子クラスから親クラスのコンストラクタ処理を呼び出すには`super()`を使います。 同じように、子クラスのプロトタイプメソッドからは、`super.プロパティ名`で親クラスのプロトタイプメソッドを参照できます。'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*子类调用父类构造函数的处理需要使用`super()`。同样地，从子类的原型方法中，可以通过`super.属性名`来引用父类的原型方法。'
- en: 次のコードでは、`Child.prototype.method`の中で`super.method()`と書くことで`Parent.prototype.method`を呼び出しています。
    このように、子クラスから継承元の親クラスのプロトタイプメソッドは`super.プロパティ名`で参照できます。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，通过在`Child.prototype.method`中编写`super.method()`，调用了`Parent.prototype.method`。因此，可以通过子类引用父类的原型方法。
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: プロトタイプチェーンでは、インスタンスからクラス、さらに親のクラスと継承関係をさかのぼるようにメソッドを探索すると紹介しました。 このコードでは`Child.prototype.method`が定義されているため、`child.method`は`Child.prototype.method`を呼び出します。
    そして`Child.prototype.method`は`super.method`を呼び出しているため、`Parent.prototype.method`が呼び出されます。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了原型链的概念，该链从实例到类，然后到父类，以搜索方法。在这段代码中，由于`Child.prototype.method`被定义，因此`child.method`将调用`Child.prototype.method`。然后，由于`Child.prototype.method`调用了`super.method`，因此将调用`Parent.prototype.method`。
- en: クラスの静的メソッド同士も同じように`super.method()`と書くことで呼び出せます。 次のコードでは、`Parent`を継承した`Child`から親クラスの静的メソッドを呼び出しています。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类的静态方法之间也可以通过`super.method()`来调用。在下面的代码中，从继承了`Parent`的`Child`中调用了父类的静态方法。
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[](#instanceof)*継承の判定*'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#instanceof)*继承的判定*'
- en: '*あるクラスが指定したクラスをプロトタイプ継承しているかは`instanceof`演算子を使って判定できます。'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过使用`instanceof`运算符，可以确定一个类是否继承了指定的类。'
- en: 次のコードでは、`Child`のインスタンスは`Child`クラスと`Parent`クラスを継承したオブジェクトであることを確認しています。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码确认了`Child`的实例是一个继承了`Child`类和`Parent`类的对象。
- en: '[PRE65]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: より具体的な継承の使い方については「[ユースケース:Todoアプリ](../../use-case/todoapp/)」の章で見ていきます。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体的继承用法将在"使用案例:Todo应用"章节中介绍。
- en: '[](#extends-built-in)*ビルトインオブジェクトの継承*'
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#extends-built-in)*内置对象的继承*'
- en: '*ここまで自身が定義したクラスを継承してきましたが、ビルトインオブジェクトのコンストラクタも継承できます。 ビルトインオブジェクトには`Array`、`String`、`Object`、`Number`、`Error`、`Date`などのコンストラクタがあります。
    `class`構文ではこれらのビルトインオブジェクトを継承できます。'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们已经学习了如何继承自己定义的类，但是内置对象的构造函数也可以继承。内置对象包括`Array`、`String`、`Object`、`Number`、`Error`、`Date`等。这些内置对象的构造函数可以通过`class`语法进行继承。'
- en: 次のコードでは、ビルトインオブジェクトである`Array`を継承して独自のメソッドを加えた`MyArray`クラスを定義しています。 継承した`MyArray`は`Array`の性質であるメソッドや状態管理についての仕組みを継承しています。
    継承した性質に加えて、MyArrayクラスへ`first`や`last`といったアクセッサプロパティを追加しています。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码定义了一个继承自内置对象`Array`并添加了自定义方法的`MyArray`类。继承的`MyArray`类继承了`Array`的方法和状态管理机制。除了继承的性质外，MyArray类还添加了`first`和`last`等访问器属性。
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`Array`を継承した`MyArray`は、`Array`が元々持つ`length`プロパティや`Array.from`メソッドなどを継承しているので利用できます。'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自`Array`的`MyArray`可以使用`Array`原先具有的`length`属性和`Array.from`方法等。
- en: '[](#conclusion)*まとめ*'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#conclusion)*总结*'
- en: '*この章ではクラスについて学びました。'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们学习了有关类的内容。'
- en: JavaScriptのクラスはプロトタイプベース
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的类是基于原型的
- en: クラスは`class`構文で定義できる
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以使用`class`语法来定义
- en: クラスで定義したメソッドはプロトタイプオブジェクトとプロトタイプチェーンの仕組みで呼び出せる
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中定义的方法可以通过原型对象和原型链的机制来调用
- en: クラスのインスタンスに対するプロパティの定義にはクラスフィールドが利用できる
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类实例的属性定义可以使用类字段
- en: クラスの外からアクセスさせたくないプロパティの定義にはPrivateクラスフィールドを使う
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用私有类字段可以定义不希望从外部访问的属性
- en: アクセッサプロパティはgetterとsetterのメソッドを定義することでプロパティのように振る舞う
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义getter和setter方法，访问器属性可以像属性一样使用
- en: クラスは`extends`で継承できる
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以通过`extends`来进行继承
- en: クラスのプロトタイプメソッドと静的メソッドはどちらも継承される********************************
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的原型方法和静态方法都会被继承********************************
