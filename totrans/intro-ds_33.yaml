- en: '[Map](data_mining_map.htm) > [Data Science](data_mining.htm) > [Predicting
    the Future](predicting_the_future.htm) > [Modeling](modeling.htm) > Association
    Rules'
  prefs: []
  type: TYPE_NORMAL
- en: Association Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Association Rules find all sets of items (itemsets) that have ***support***
    greater than the minimum support and then using the large itemsets to generate
    the desired rules that have ***confidence*** greater than the minimum confidence.
    The ***lift*** of a rule is the ratio of the observed support to that expected
    if X and Y were independent.  A typical and widely used example of association
    rules application is market basket analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9861a401eed980384ef1f218bc6cc949.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Example*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/46a3fc59aa432f565d0b5998796c3706.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**AIS Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: Candidate itemsets are generated and counted on-the-fly as the database is scanned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each transaction, it is determined which of the large itemsets of the previous
    pass are contained in this transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New candidate itemsets are generated by extending these large itemsets with
    other items in this transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/a524031f14aae201ba4376dfbc6a97ba.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The disadvantage of the AIS algorithm is that it results in unnecessarily generating
    and counting too many candidate itemsets that turn out to be small.  **SETM Algorithm**
  prefs: []
  type: TYPE_NORMAL
- en: Candidate itemsets are generated on-the-fly as the database is scanned, but
    counted at the end of the pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New candidate itemsets are generated the same way as in AIS algorithm, but the
    TID of the generating transaction is saved with the candidate itemset in a sequential
    structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the pass, the support count of candidate itemsets is determined
    by aggregating this sequential structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/1d1be3f448119e5141798cac58d540a2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The SETM algorithm has the same disadvantage of the AIS algorithm. Another disadvantage
    is that for each candidate itemset, there are as many entries as its support value.  **Apriori
    Algorithm**
  prefs: []
  type: TYPE_NORMAL
- en: Candidate itemsets are generated using only the large itemsets of the previous
    pass without considering the transactions in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The large itemset of the previous pass is joined with itself to generate all
    itemsets whose size is higher by 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each generated itemset that has a subset which is not large is deleted. The
    remaining itemsets are the candidate ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/2f7c7985ab36cc0f3ef8a97e9086813a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Apriori algorithm takes advantage of the fact that any subset of a frequent
    itemset is also a frequent itemset. The algorithm can therefore, reduce the number
    of candidates being considered by only exploring the itemsets whose support count
    is greater than the minimum support count. All infrequent itemsets can be pruned
    if it has an infrequent subset. **AprioriTid Algorithm**
  prefs: []
  type: TYPE_NORMAL
- en: The database is not used at all for counting the support of candidate itemsets
    after the first pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The candidate itemsets are generated the same way as in Apriori algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another set C� is generated of which each member has the TID of each transaction
    and the large itemsets present in this transaction. This set is used to count
    the support of each candidate itemset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/43df0675557ee0e01c79c35b304fb7aa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The advantage is that the number of entries in C� may be smaller than the number
    of transactions in the database, especially in the later passes. **AprioriHybrid
    Algorithm** Apriori does better than AprioriTid in the earlier passes. However,
    AprioriTid does better than Apriori in the later passes. Hence, a hybrid algorithm
    can be designed that uses Apriori in the initial passes and switches to AprioriTid
    when it expects that the set C� will fit in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '| [Exercise](association_rules_exercise.htm) | [![](../Images/a890baab528b0ca069f7f2599c0c5e39.jpg)](datasets/Arules.txt)
    |  |'
  prefs: []
  type: TYPE_TB
