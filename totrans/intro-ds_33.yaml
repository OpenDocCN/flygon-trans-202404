- en: '[Map](data_mining_map.htm) > [Data Science](data_mining.htm) > [Predicting
    the Future](predicting_the_future.htm) > [Modeling](modeling.htm) > Association
    Rules'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[地图](data_mining_map.htm) > [数据科学](data_mining.htm) > [预测未来](predicting_the_future.htm)
    > [建模](modeling.htm) > 关联规则'
- en: Association Rules
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联规则
- en: Association Rules find all sets of items (itemsets) that have ***support***
    greater than the minimum support and then using the large itemsets to generate
    the desired rules that have ***confidence*** greater than the minimum confidence.
    The ***lift*** of a rule is the ratio of the observed support to that expected
    if X and Y were independent.  A typical and widely used example of association
    rules application is market basket analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则查找所有具有大于最小支持的***支持***的项目集，并使用大项集生成具有大于最小置信度的所需规则。规则的***提升度***是观察到的支持与如果X和Y独立预期的支持之比。
    关联规则应用的典型和广泛使用的示例是市场篮子分析。
- en: '![](../Images/9861a401eed980384ef1f218bc6cc949.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9861a401eed980384ef1f218bc6cc949.jpg)'
- en: '*Example*:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*例子*：'
- en: '![](../Images/46a3fc59aa432f565d0b5998796c3706.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/46a3fc59aa432f565d0b5998796c3706.jpg)'
- en: '**AIS Algorithm**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**AIS算法**'
- en: Candidate itemsets are generated and counted on-the-fly as the database is scanned.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 候选项集在扫描数据库时即时生成和计数。
- en: For each transaction, it is determined which of the large itemsets of the previous
    pass are contained in this transaction.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个事务，确定前一次传递的大项集中包含在该事务中的哪些。
- en: New candidate itemsets are generated by extending these large itemsets with
    other items in this transaction.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将这些大项集与此事务中的其他项扩展，生成新的候选项集。
- en: '![](../Images/a524031f14aae201ba4376dfbc6a97ba.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a524031f14aae201ba4376dfbc6a97ba.jpg)'
- en: The disadvantage of the AIS algorithm is that it results in unnecessarily generating
    and counting too many candidate itemsets that turn out to be small.  **SETM Algorithm**
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: AIS算法的缺点是导致不必要地生成和计数太多的候选项集，结果是小的。 **SETM算法**
- en: Candidate itemsets are generated on-the-fly as the database is scanned, but
    counted at the end of the pass.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 候选项集在扫描数据库时即时生成，但在通过结束时计数。
- en: New candidate itemsets are generated the same way as in AIS algorithm, but the
    TID of the generating transaction is saved with the candidate itemset in a sequential
    structure.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的候选项集的生成方式与AIS算法相同，但是生成事务的TID与候选项集一起保存在顺序结构中。
- en: At the end of the pass, the support count of candidate itemsets is determined
    by aggregating this sequential structure.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过结束时，通过聚合此序列结构来确定候选项集的支持计数。
- en: '![](../Images/1d1be3f448119e5141798cac58d540a2.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1d1be3f448119e5141798cac58d540a2.jpg)'
- en: The SETM algorithm has the same disadvantage of the AIS algorithm. Another disadvantage
    is that for each candidate itemset, there are as many entries as its support value.  **Apriori
    Algorithm**
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SETM算法具有与AIS算法相同的缺点。 另一个缺点是对于每个候选项集，其条目数与其支持值一样多。 **Apriori算法**
- en: Candidate itemsets are generated using only the large itemsets of the previous
    pass without considering the transactions in the database.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用前一次传递的大项集生成候选项集，而不考虑数据库中的事务。
- en: The large itemset of the previous pass is joined with itself to generate all
    itemsets whose size is higher by 1.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一次传递的大项集与自身连接以生成所有大小增加1的项集。
- en: Each generated itemset that has a subset which is not large is deleted. The
    remaining itemsets are the candidate ones.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除具有不是大的子集的生成的项集。 剩下的项集是候选项。
- en: '![](../Images/2f7c7985ab36cc0f3ef8a97e9086813a.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2f7c7985ab36cc0f3ef8a97e9086813a.jpg)'
- en: The Apriori algorithm takes advantage of the fact that any subset of a frequent
    itemset is also a frequent itemset. The algorithm can therefore, reduce the number
    of candidates being considered by only exploring the itemsets whose support count
    is greater than the minimum support count. All infrequent itemsets can be pruned
    if it has an infrequent subset. **AprioriTid Algorithm**
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori算法利用了频繁项集的任何子集也是频繁项集的事实。 因此，该算法可以通过仅探索支持计数大于最小支持计数的项集来减少考虑的候选数目。 如果有一个不频繁的子集，则可以修剪所有不频繁的项集。
    **AprioriTid算法**
- en: The database is not used at all for counting the support of candidate itemsets
    after the first pass.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库在第一遍之后不再用于计算候选项集的支持。
- en: The candidate itemsets are generated the same way as in Apriori algorithm.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 候选项集的生成方式与Apriori算法相同。
- en: Another set C� is generated of which each member has the TID of each transaction
    and the large itemsets present in this transaction. This set is used to count
    the support of each candidate itemset.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外生成一个集合C�，其中每个成员都有每个事务的TID以及该事务中存在的大项集。这个集合用于计算每个候选项集的支持度。
- en: '![](../Images/43df0675557ee0e01c79c35b304fb7aa.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/43df0675557ee0e01c79c35b304fb7aa.jpg)'
- en: The advantage is that the number of entries in C� may be smaller than the number
    of transactions in the database, especially in the later passes. **AprioriHybrid
    Algorithm** Apriori does better than AprioriTid in the earlier passes. However,
    AprioriTid does better than Apriori in the later passes. Hence, a hybrid algorithm
    can be designed that uses Apriori in the initial passes and switches to AprioriTid
    when it expects that the set C� will fit in memory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是C�中的条目数可能小于数据库中的事务数，特别是在后续传递中。 **AprioriHybrid Algorithm** 在较早的传递中，Apriori比AprioriTid做得更好。然而，在后续传递中，AprioriTid比Apriori做得更好。因此，可以设计一个混合算法，该算法在初始传递中使用Apriori，并在预计C�集合将适合内存时切换到AprioriTid。
- en: '| [Exercise](association_rules_exercise.htm) | [![](../Images/a890baab528b0ca069f7f2599c0c5e39.jpg)](datasets/Arules.txt)
    |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| [练习](association_rules_exercise.htm) | [![](../Images/a890baab528b0ca069f7f2599c0c5e39.jpg)](datasets/Arules.txt)
    |  |'
