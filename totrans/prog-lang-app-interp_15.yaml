- en: '15Checking Program Invariants Statically: Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15Checking Program Invariants Statically: Types'
- en: '|     [15.1 Types as Static Disciplines](#(part._.Types_as_.Static_.Disciplines))
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [15.1 Types as Static Disciplines](#(part._.Types_as_.Static_.Disciplines))
    |'
- en: '|     [15.2 A Classical View of Types](#(part._.A_.Classical_.View_of_.Types))
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [15.2 A Classical View of Types](#(part._.A_.Classical_.View_of_.Types))
    |'
- en: '|       [15.2.1 A Simple Type Checker](#(part._.A_.Simple_.Type_.Checker))
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.1 A Simple Type Checker](#(part._.A_.Simple_.Type_.Checker))
    |'
- en: '|       [15.2.2 Type-Checking Conditionals](#(part._.Type-.Checking_.Conditionals))
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.2 Type-Checking Conditionals](#(part._.Type-.Checking_.Conditionals))
    |'
- en: '|       [15.2.3 Recursion in Code](#(part._.Recursion_in_.Code)) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.3 Recursion in Code](#(part._.Recursion_in_.Code)) |'
- en: '|         [15.2.3.1 A First Attempt at Typing Recursion](#(part._.A_.First_.Attempt_at_.Typing_.Recursion))
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.3.1 A First Attempt at Typing Recursion](#(part._.A_.First_.Attempt_at_.Typing_.Recursion))
    |'
- en: '|         [15.2.3.2 Program Termination](#(part._.Program_.Termination)) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.3.2 Program Termination](#(part._.Program_.Termination)) |'
- en: '|         [15.2.3.3 Typing Recursion](#(part._.Typing_.Recursion)) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.3.3 Typing Recursion](#(part._.Typing_.Recursion)) |'
- en: '|       [15.2.4 Recursion in Data](#(part._.Recursion_in_.Data)) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.4 Recursion in Data](#(part._.Recursion_in_.Data)) |'
- en: '|         [15.2.4.1 Recursive Datatype Definitions](#(part._.Recursive_.Datatype_.Definitions))
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.4.1 Recursive Datatype Definitions](#(part._.Recursive_.Datatype_.Definitions))
    |'
- en: '|         [15.2.4.2 Introduced Types](#(part._.Introduced_.Types)) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.4.2 Introduced Types](#(part._.Introduced_.Types)) |'
- en: '|         [15.2.4.3 Pattern-Matching and Desugaring](#(part._.Pattern-.Matching_and_.Desugaring))
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.4.3 Pattern-Matching and Desugaring](#(part._.Pattern-.Matching_and_.Desugaring))
    |'
- en: '|       [15.2.5 Types, Time, and Space](#(part._.Types__.Time__and_.Space))
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.5 Types, Time, and Space](#(part._.Types__.Time__and_.Space))
    |'
- en: '|       [15.2.6 Types and Mutation](#(part._.Types_and_.Mutation)) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.6 Types and Mutation](#(part._.Types_and_.Mutation)) |'
- en: '|       [15.2.7 The Central Theorem: Type Soundness](#(part._.The_.Central_.Theorem__.Type_.Soundness))
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.7 The Central Theorem: Type Soundness](#(part._.The_.Central_.Theorem__.Type_.Soundness))
    |'
- en: '|     [15.3 Extensions to the Core](#(part._.Extensions_to_the_.Core)) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|     [15.3 Extensions to the Core](#(part._.Extensions_to_the_.Core)) |'
- en: '|       [15.3.1 Explicit Parametric Polymorphism](#(part._.Explicit_.Parametric_.Polymorphism))
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|       [15.3.1 Explicit Parametric Polymorphism](#(part._.Explicit_.Parametric_.Polymorphism))
    |'
- en: '|         [15.3.1.1 Parameterized Types](#(part._.Parameterized_.Types)) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.1.1 Parameterized Types](#(part._.Parameterized_.Types)) |'
- en: '|         [15.3.1.2 Making Parameters Explicit](#(part._.Making_.Parameters_.Explicit))
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.1.2 Making Parameters Explicit](#(part._.Making_.Parameters_.Explicit))
    |'
- en: '|         [15.3.1.3 Rank-1 Polymorphism](#(part._.Rank-1_.Polymorphism)) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.1.3 Rank-1 Polymorphism](#(part._.Rank-1_.Polymorphism)) |'
- en: '|         [15.3.1.4 Interpreting Rank-1 Polymorphism as Desugaring](#(part._.Interpreting_.Rank-1_.Polymorphism_as_.Desugaring))
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.1.4 Interpreting Rank-1 Polymorphism as Desugaring](#(part._.Interpreting_.Rank-1_.Polymorphism_as_.Desugaring))
    |'
- en: '|         [15.3.1.5 Alternate Implementations](#(part._.Alternate_.Implementations))
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.1.5 Alternate Implementations](#(part._.Alternate_.Implementations))
    |'
- en: '|         [15.3.1.6 Relational Parametricity](#(part._.Relational_.Parametricity))
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.1.6 Relational Parametricity](#(part._.Relational_.Parametricity))
    |'
- en: '|       [15.3.2 Type Inference](#(part._.Type_.Inference)) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|       [15.3.2 Type Inference](#(part._.Type_.Inference)) |'
- en: '|         [15.3.2.1 Constraint Generation](#(part._.Constraint_.Generation))
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.2.1 Constraint Generation](#(part._.Constraint_.Generation))
    |'
- en: '|         [15.3.2.2 Constraint Solving Using Unification](#(part._.Constraint_.Solving_.Using_.Unification))
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.2.2 Constraint Solving Using Unification](#(part._.Constraint_.Solving_.Using_.Unification))
    |'
- en: '|         [15.3.2.3 Let-Polymorphism](#(part._.Let-.Polymorphism)) |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.2.3 Let-Polymorphism](#(part._.Let-.Polymorphism)) |'
- en: '|       [15.3.3 Union Types](#(part._.Union_.Types)) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|       [15.3.3 Union Types](#(part._.Union_.Types)) |'
- en: '|         [15.3.3.1 Structures as Types](#(part._.Structures_as_.Types)) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.3.1 Structures as Types](#(part._.Structures_as_.Types)) |'
- en: '|         [15.3.3.2 Untagged Unions](#(part._.Untagged_.Unions)) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.3.2 Untagged Unions](#(part._.Untagged_.Unions)) |'
- en: '|         [15.3.3.3 Discriminating Untagged Unions](#(part._.Discriminating_.Untagged_.Unions))
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.3.3 Discriminating Untagged Unions](#(part._.Discriminating_.Untagged_.Unions))
    |'
- en: '|         [15.3.3.4 Retrofitting Types](#(part._.Retrofitting_.Types)) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.3.4 Retrofitting Types](#(part._.Retrofitting_.Types)) |'
- en: '|         [15.3.3.5 Design Choices](#(part._.Design_.Choices)) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.3.5 Design Choices](#(part._.Design_.Choices)) |'
- en: '|       [15.3.4 Nominal Versus Structural Systems](#(part._.Nominal_.Versus_.Structural_.Systems))
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|       [15.3.4 Nominal Versus Structural Systems](#(part._.Nominal_.Versus_.Structural_.Systems))
    |'
- en: '|       [15.3.5 Intersection Types](#(part._.Intersection_.Types)) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|       [15.3.5 Intersection Types](#(part._.Intersection_.Types)) |'
- en: '|       [15.3.6 Recursive Types](#(part._.Recursive_.Types)) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|       [15.3.6 Recursive Types](#(part._.Recursive_.Types)) |'
- en: '|       [15.3.7 Subtyping](#(part._.Subtyping)) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|       [15.3.7 子类型化](#(part._.子类型化)) |'
- en: '|         [15.3.7.1 Unions](#(part._.Unions)) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.7.1 联合](#(part._.联合)) |'
- en: '|         [15.3.7.2 Intersections](#(part._.Intersections)) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.7.2 交集](#(part._.交集)) |'
- en: '|         [15.3.7.3 Functions](#(part._.Functions)) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.7.3 函数](#(part._.函数)) |'
- en: '|         [15.3.7.4 Implementing Subtyping](#(part._.Implementing_.Subtyping))
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|         [15.3.7.4 实现子类型化](#(part._.实现_.子类型化)) |'
- en: '|       [15.3.8 Object Types](#(part._.Object_.Types)) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|       [15.3.8 对象类型](#(part._.对象类型)) |'
- en: 'As programs grow larger or more subtle, developers need tools to help them
    describe and validate statements about program invariants. Invariants, as the
    name suggests, are statements about program elements that are expected to always
    hold of those elements. For example, when we write x : number in our typed language,
    we mean that x will always hold a number, and that all parts of the program that
    depend on x can rely on this statement being enforced. As we will see, types are
    just one point in a spectrum of invariants we might wish to state, and static
    type checking—<wbr>itself a diverse family of techniques—<wbr>is also a point
    in a spectrum of methods we can use to enforce the invariants.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '随着程序变得越来越大或更加微妙，开发人员需要工具来帮助他们描述和验证关于程序不变量的陈述。不变量，顾名思义，是关于预期始终保持的程序元素的陈述。例如，当我们在我们的类型语言中编写
    x : number 时，我们的意思是 x 将始终持有一个数字，并且程序中依赖于 x 的所有部分都可以依赖于此语句的执行。正如我们将看到的，类型只是我们可能希望陈述的不变量的一个点，而静态类型检查——本身是一组多样的技术——也是我们可以用来强制执行不变量的方法的一个点。'
- en: 15.1Types as Static Disciplines
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1类型作为静态学科
- en: 'In this chapter, we will focus especially on static type checking: that is,
    checking (declared) types before the program even executes. We have already experienced
    a form of this in our programs by virtue of using a typed programming language.
    We will explore some of the design space of types and their trade-offs. Finally,
    though static typing is an especially powerful and important form of invariant
    enforcement, we will also examine some other techniques that we have available.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将特别关注静态类型检查：即，在程序执行之前检查（声明的）类型。通过使用有类型的编程语言，我们已经体验过这种形式的某种程度。我们将探索一些类型及其权衡的设计空间。最后，尽管静态类型是一种特别强大和重要的不变量强制形式，但我们还将研究一些其他可用的技术。
- en: 'Consider this program in our typed language:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下我们的类型语言中的这个程序：
- en: '| (define (f [n : number]) : number |'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (f [n : number]) : number |'
- en: '|   (+ n 3)) |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (+ n 3)) |'
- en: '|   |'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (f "x") |'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (f "x") |'
- en: 'We get a static type error before the program begins execution. The same program
    (without the type annotations) in ordinary Racket fails only at runtime:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序开始执行之前就获得了静态类型错误。同样的程序（没有类型注释）在普通的 Racket 中仅在运行时失败：
- en: '| (define (f n) |'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (f n) |'
- en: '|   (+ n 3)) |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (+ n 3)) |'
- en: '|   |'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (f "x") |'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (f "x") |'
- en: Exercise
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: How would you test the assertions that one fails before the program executes
    while the other fails during execution?
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如何测试这样的断言：一个在程序执行前失败，而另一个在执行期间失败？
- en: 'Now consider the following Racket program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下 Racket 程序：
- en: '| (define f n |'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define f n |'
- en: '|   (+ n 3)) |'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (+ n 3)) |'
- en: 'This too fails before program execution begins, with a parse error. Though
    we think of parsing as being somehow distinct from type-checking—<wbr>usually
    because the type-checker assumes it has a parsed program to begin with—<wbr>it
    can be useful to think of parsing as being simply the very simplest kind of type-checking:
    determining (typically) whether the program obeys a context-free syntax. Type-checking
    then asks whether it obeys a context-sensitive (or richer) syntax. In short, type-checking
    is a generalization of parsing, in that both are concerned with syntactic methods
    for enforcing disciplines on programs.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这也在程序执行开始前失败，因为存在解析错误。尽管我们认为解析与类型检查在某种程度上是不同的——通常是因为类型检查器假定它有一个已解析的程序来开始——但将解析视为简单的类型检查的最简单形式可能是有用的：通常确定程序是否遵循上下文无关语法。然后，类型检查询问它是否遵循上下文相关（或更丰富的）语法。简而言之，类型检查是对解析的一种泛化，因为两者都涉及对程序强制执行规则的语法方法。
- en: 15.2A Classical View of Types
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2A 类型的经典观点
- en: We will begin by introducing a traditional core language of types. Later, we
    will explore both extensions [REF] and variations [REF].
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍传统类型的核心语言。稍后，我们将探索扩展[参考]和变体[参考]。
- en: 15.2.1A Simple Type Checker
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.1A 简单类型检查器
- en: 'Before we can define a type checker, we have to fix two things: the syntax
    of our typed core language and, hand-in-hand with that, the syntax of types themselves.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以定义类型检查器之前，我们必须解决两件事：我们类型化核心语言的语法以及与此同时，类型本身的语法。
- en: To begin with, we’ll return to our language with functions-as-values [REF] but
    before we added mutation and other complications (some of which we’ll return to
    later). To this language we have to add type annotations. Conventionally, we don’t
    impose type annotations on constants or on primitive operations such as addition;
    instead, we impose them on the boundaries of functions or methods. Over the course
    of this study we will explore why this is a good locus for annotations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回到我们的语言，其中函数作为值[REF]，但在添加变异和其他复杂性之前（其中一些我们稍后会回到）。对于这种语言，我们必须添加类型注释。通常，我们不会对常量或加法等原始操作强加类型注释；相反，我们将它们强加在函数或方法的边界上。在这项研究过程中，我们将探讨为什么这是一个很好的注释位置。
- en: 'Given this decision, our typed core language becomes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这个决定，我们的类型化核心语言变为：
- en: '| (define-type TyExprC |'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type TyExprC |'
- en: '|   [numC (n : number)] |'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numC (n : number)] |'
- en: '|   [idC (s : symbol)] |'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [idC (s : symbol)] |'
- en: '|   [appC (fun : TyExprC) (arg : TyExprC)] |'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [appC (fun : TyExprC) (arg : TyExprC)] |'
- en: '|   [plusC (l : TyExprC) (r : TyExprC)] |'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [plusC (l : TyExprC) (r : TyExprC)] |'
- en: '|   [multC (l : TyExprC) (r : TyExprC)] |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [multC (l : TyExprC) (r : TyExprC)] |'
- en: '|   [lamC (arg : symbol) (argT : Type) (retT : Type) (body : TyExprC)]) |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [lamC (arg : symbol) (argT : Type) (retT : Type) (body : TyExprC)]) |'
- en: 'That is, every procedure is annotated with the type of argument it expects
    and type of argument it purports to produce.Now we have to decide on a language
    of types. To do so, we follow the tradition that the types abstract over the set
    of values. In our language, we have two kinds of values:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个过程都带有它期望的参数类型和它声称要产生的参数类型的注释。现在我们必须决定一种类型的语言。为此，我们遵循类型抽象化值集合的传统。在我们的语言中，我们有两种值：
- en: '| (define-type Value |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Value |'
- en: '|   [numV (n : number)] |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numV (n : number)] |'
- en: '|   [closV (arg : symbol) (body : TyExprC) (env : Env)]) |'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [closV (arg : symbol) (body : TyExprC) (env : Env)]) |'
- en: 'It follows that we should have two kinds of types: one for numbers and the
    other for functions.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，我们应该有两种类型：一种用于数字，另一种用于函数。
- en: 'Even numeric types may not be straightforward: What information does a number
    type need to record? In most languages, there are actually many numeric types,
    and indeed there may not even be a single one that represents “numbers”. However,
    we have ignored these gradations between numbers [REF], so it’s sufficient for
    us to have just one. Having decided that, do we record additional information
    about which number? We could in principle, but we would soon run into decidability
    problems.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数字类型也可能不是直截了当的：数字类型需要记录什么信息？在大多数语言中，实际上有许多数字类型，事实上甚至可能没有一个代表“数字”的类型。然而，我们忽略了这些数字之间的渐变[REF]，所以对我们来说只有一个就足够了。决定了这一点后，我们是否记录有关哪个数字的其他信息？原则上我们可以，但很快就会遇到可决定性问题。
- en: 'As for functions, we have more information: the type of expected argument,
    and the type of claimed result. We might as well record this information we have
    been given until and unless it has proven to not be useful. Combining these, we
    obtain the following abstract language of types:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '至于函数，我们有更多信息：期望参数的类型和声称结果的类型。我们可能会记录这些信息，直到它被证明是没有用的。结合这些，我们得到以下抽象类型语言： '
- en: '| (define-type Type |'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Type |'
- en: '|   [numT] |'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numT] |'
- en: '|   [funT (arg : Type) (ret : Type)]) |'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [funT (arg : Type) (ret : Type)]) |'
- en: 'Now that we’ve fixed both the term and type structure of the language, let’s
    make sure we agree on what constitute type errors in our language (and, by fiat,
    everything not a type error must pass the type checker). There are three obvious
    forms of type errors:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经固定了语言的术语和类型结构，让我们确保我们对于在我们的语言中构成类型错误的事物达成一致（并且，通过法令，一切不是类型错误的事物必须通过类型检查器）。有三种明显的类型错误形式：
- en: One or both arguments of + is not a number, i.e., is not a numT.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: + 的一个或两个参数不是数字，即不是 numT。
- en: One or both arguments of * is not a number.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '* 的一个或两个参数不是数字。'
- en: The expression in the function position of an application is not a function,
    i.e., is not a funT.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中函数位置的表达式不是函数，即不是 funT。
- en: Do Now!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做！
- en: Any more?
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有吗？
- en: 'We’re actually missing one:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们还缺少一个：
- en: The expression in the function position of an application is a function but
    the type of the actual argument does not match the type of the formal argument
    expected by the function.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用的函数位置的表达式是一个函数，但实际参数的类型与函数预期的形式参数的类型不匹配。
- en: It seems clear all other programs in our language ought to type-check.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很明显，我们语言中的所有其他程序都应该经过类型检查。
- en: A natural starting signature for the type-checker would be that it is a procedure
    that consumes an expression and returns a boolean value indicating whether or
    not the expression type-checked. Because we know expressions contain identifiers,
    it soon becomes clear that we will want a type environment, which maps names to
    types, analogous to the value environment we have seen so far.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器的一个自然起始签名将是一个过程，它消耗一个表达式并返回一个布尔值，指示表达式是否通过了类型检查。因为我们知道表达式包含标识符，很快就会清楚我们需要一个类型环境，它将名称映射到类型，类似于我们到目前为止所见到的值环境。
- en: Exercise
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Define the types and functions associated with type environments.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义与类型环境相关联的类型和函数。
- en: 'Thus, we might begin our program as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能会将我们的程序开始如下：
- en: '[<tc-take-1>](#(elem._(chunk._~3ctc-take-1~3e~3a1))) ::='
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-take-1>](#(elem._(chunk._~3ctc-take-1~3e~3a1))) ::='
- en: '| (define (tc [expr : TyExprC] [tenv : TyEnv]) : boolean |'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (tc [expr : TyExprC] [tenv : TyEnv]) : boolean |'
- en: '|   (type-case TyExprC expr |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case TyExprC expr |'
- en: '|     [<tc-take-1-numC-case>](#(elem._(chunk._~3ctc-take-1-num.C-case~3e~3a1)))
    |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-take-1-numC-case>](#(elem._(chunk._~3ctc-take-1-num.C-case~3e~3a1)))
    |'
- en: '|     [<tc-take-1-idC-case>](#(elem._(chunk._~3ctc-take-1-id.C-case~3e~3a1)))
    |'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-take-1-idC-case>](#(elem._(chunk._~3ctc-take-1-id.C-case~3e~3a1)))
    |'
- en: '|     [<tc-take-1-appC-case>](#(elem._(chunk._~3ctc-take-1-app.C-case~3e~3a1)))))
    |'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-take-1-appC-case>](#(elem._(chunk._~3ctc-take-1-app.C-case~3e~3a1)))))
    |'
- en: As the abbreviated set of cases above suggests, this approach will not work
    out. We’ll soon see why.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上面简化的案例集所示，这种方法将行不通。我们很快就会看到原因。
- en: 'Let’s begin with the easy case: numbers. Does a number type-check? Well, on
    its own, of course it does; it may be that the surrounding context is not expecting
    a number, but that error would be signaled elsewhere. Thus:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的情况开始：数字。数字类型是否经过检查？当然，在其自身上，它当然是的；周围的上下文可能不期望一个数字，但这个错误将在其他地方被发出。因此：
- en: '[<tc-take-1-numC-case>](#(elem._(chunk._~3ctc-take-1-num.C-case~3e~3a1))) ::='
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-take-1-numC-case>](#(elem._(chunk._~3ctc-take-1-num.C-case~3e~3a1))) ::='
- en: '[numC (n) true]'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[numC (n) true]'
- en: Now let’s handle identifiers. Is an identifier well-typed? Again, on its own
    it would appear to be, provided it is actually a bound identifier; it may not
    be what the context desires, but hopefully that too would be handled elsewhere.
    Thus we might write
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们处理标识符。标识符是否是良好类型的？同样，就其本身而言，它似乎是的，前提是它实际上是一个绑定的标识符；它可能不是上下文所期望的，但希望这也将在其他地方处理。因此，我们可以写成
- en: '[<tc-take-1-idC-case>](#(elem._(chunk._~3ctc-take-1-id.C-case~3e~3a1))) ::='
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-take-1-idC-case>](#(elem._(chunk._~3ctc-take-1-id.C-case~3e~3a1))) ::='
- en: '| [idC (n) (if (lookup n tenv) |'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [idC (n) (if (lookup n tenv) |'
- en: '|              true |'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              true |'
- en: '|              (error ''tc "not a bound identifier"))] |'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (error ''tc "not a bound identifier"))] |'
- en: 'This should make you a little uncomfortable: lookup already signals an error
    if an identifier isn’t bound, so there’s no need to repeat it (indeed, we will
    never get to this error invocation). But let’s push on.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让你有点不舒服：如果标识符没有绑定，查找已经发出错误信号，因此没有必要重复它（事实上，我们永远不会到达这个错误调用）。但让我们继续下去。
- en: Now we tackle applications. We should type-check both the function part, to
    make sure it’s a function, then ensure that the actual argument’s type is consistent
    with what the function declares to be the type of its formal argument. For instance,
    the function could be a number and the application could itself be a function,
    or vice versa, and in either case we want to prevent such mis-applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理应用。我们应该对函数部分进行类型检查，以确保它是一个函数，然后确保实际参数的类型与函数声明的形式参数的类型一致。例如，函数可以是一个数字，应用本身可以是一个函数，反之亦然，在任何一种情况下，我们都希望阻止这种错误的应用。
- en: How does the code look?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来怎么样？
- en: '[<tc-take-1-appC-case>](#(elem._(chunk._~3ctc-take-1-app.C-case~3e~3a1))) ::='
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-take-1-appC-case>](#(elem._(chunk._~3ctc-take-1-app.C-case~3e~3a1))) ::='
- en: '| [appC (f a) (let ([ft (tc f tenv)]) |'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [appC (f a) (let ([ft (tc f tenv)]) |'
- en: '|               ...)] |'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               ...)] |'
- en: 'The recursive call to tc can only tell us whether the function expression type-checks
    or not. If it does, how do we know what type it has? If we have an immediate function,
    we could reach into its syntax and pull out the argument (and return) types. But
    if we have a complex expression, we need some procedure that will calculate the
    resulting type of that expression. Of course, such a procedure could only provide
    a type if the expression is well-typed; otherwise it would not be able to provide
    a coherent answer. In other words, our type “calculator” has type “checking” as
    a special case! We should therefore strengthen the inductive invariant on tc:
    that it not only tells us whether an expression is typed but also what its type
    is. Indeed, by giving any type at all it confirms that the expression types, and
    otherwise it signals an error.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对 tc 的递归调用只能告诉我们函数表达式是否经过类型检查。如果是，我们怎么知道它有什么类型？如果我们有一个立即函数，我们可以进入其语法并提取参数（和返回）类型。但是，如果我们有一个复杂的表达式，我们需要一些过程来计算该表达式的结果类型。当然，只有表达式被正确类型化时，这样的过程才能提供类型；否则它将无法提供一个连贯的答案。换句话说，我们的类型“计算器”将类型“检查”作为一个特殊情况！因此，我们应该加强对
    tc 的归纳不变量：它不仅告诉我们一个表达式是否被类型化，还告诉我们它的类型是什么。确实，通过给出任何类型，它都确认了表达式的类型，否则它会发出错误信号。
- en: Let’s now define this richer notion of a type “checker”.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个更丰富的类型“检查器”。
- en: '[<tc>](#(elem._(chunk._~3ctc~3e~3a1))) ::='
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc>](#(elem._(chunk._~3ctc~3e~3a1))) ::= '
- en: '| (define (tc [expr : TyExprC] [tenv : TyEnv]) : Type |'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (tc [expr : TyExprC] [tenv : TyEnv]) : Type |'
- en: '|   (type-case TyExprC expr |'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case TyExprC expr |'
- en: '|     [<tc-numC-case>](#(elem._(chunk._~3ctc-num.C-case~3e~3a1))) |'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-numC-case>](#(elem._(chunk._~3ctc-num.C-case~3e~3a1))) |'
- en: '|     [<tc-idC-case>](#(elem._(chunk._~3ctc-id.C-case~3e~3a1))) |'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-idC-case>](#(elem._(chunk._~3ctc-id.C-case~3e~3a1))) |'
- en: '|     [<tc-plusC-case>](#(elem._(chunk._~3ctc-plus.C-case~3e~3a1))) |'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-plusC-case>](#(elem._(chunk._~3ctc-plus.C-case~3e~3a1))) |'
- en: '|     [<tc-multC-case>](#(elem._(chunk._~3ctc-mult.C-case~3e~3a1))) |'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-multC-case>](#(elem._(chunk._~3ctc-mult.C-case~3e~3a1))) |'
- en: '|     [<tc-appC-case>](#(elem._(chunk._~3ctc-app.C-case~3e~3a1))) |'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-appC-case>](#(elem._(chunk._~3ctc-app.C-case~3e~3a1))) |'
- en: '|     [<tc-lamC-case>](#(elem._(chunk._~3ctc-lam.C-case~3e~3a1))))) |'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<tc-lamC-case>](#(elem._(chunk._~3ctc-lam.C-case~3e~3a1))))) |'
- en: 'Now let’s fill in the pieces. Numbers are easy: they have the numeric type.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们填入这些部分。数字很容易：它们具有数字类型。
- en: '[<tc-numC-case>](#(elem._(chunk._~3ctc-num.C-case~3e~3a1))) ::='
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-numC-case>](#(elem._(chunk._~3ctc-num.C-case~3e~3a1))) ::= '
- en: '[numC (n) (numT)]'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[numC (n) (numT)]'
- en: Similarly, identifiers have whatever type the environment says they do (and
    if they aren’t bound, this signals an error).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，标识符具有环境中规定的任何类型（如果它们没有绑定，则会发出错误信号）。
- en: '[<tc-idC-case>](#(elem._(chunk._~3ctc-id.C-case~3e~3a1))) ::='
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-idC-case>](#(elem._(chunk._~3ctc-id.C-case~3e~3a1))) ::= '
- en: '[idC (n) (lookup n tenv)]'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[idC (n) (lookup n tenv)]'
- en: 'Observe, so far, the similarity to and difference from interpreting: in the
    identifier case we did essentially the same thing (except we returned a type rather
    than an actual value), whereas in the numeric case we returned the abstract “number”
    rather than indicate which specific number it was.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到，到目前为止，与解释相似之处及不同之处：在标识符案例中，我们基本上做了相同的事情（除了我们返回了一个类型而不是一个实际值），而在数字案例中，我们返回了抽象的“数字”，而不是指示它是哪个特定的数字。
- en: Let’s now examine addition. We must make sure both sub-expressions have numeric
    type; only if they do will the overall expression evaluate to a number itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看加法。我们必须确保两个子表达式都具有数值类型；只有这样，整体表达式才会评估为一个数字本身。
- en: '[<tc-plusC-case>](#(elem._(chunk._~3ctc-plus.C-case~3e~3a1))) ::='
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-plusC-case>](#(elem._(chunk._~3ctc-plus.C-case~3e~3a1))) ::= '
- en: '| [plusC (l r) (let ([lt (tc l tenv)] |'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [plusC (l r) (let ([lt (tc l tenv)] |'
- en: '|                    [rt (tc r tenv)]) |'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    [rt (tc r tenv)]) |'
- en: '|                (if (and (equal? lt (numT)) |'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (if (and (equal? lt (numT)) |'
- en: '|                         (equal? rt (numT))) |'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (equal? rt (numT))) |'
- en: '|                    (numT) |'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (numT) |'
- en: '|                    (error ''tc "+ not both numbers")))] |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (error ''tc "+ not both numbers")))] |'
- en: 'We’ve usually glossed over multiplication after considering addition, but now
    it will be instructive to handle it explicitly:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在考虑加法后会忽略乘法，但现在明确处理它将是有益的：
- en: '[<tc-multC-case>](#(elem._(chunk._~3ctc-mult.C-case~3e~3a1))) ::='
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-multC-case>](#(elem._(chunk._~3ctc-mult.C-case~3e~3a1))) ::= '
- en: '| [multC (l r) (let ([lt (tc l tenv)] |'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [multC (l r) (let ([lt (tc l tenv)] |'
- en: '|                    [rt (tc r tenv)]) |'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    [rt (tc r tenv)]) |'
- en: '|                (if (and (equal? lt (numT)) |'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (if (and (equal? lt (numT)) |'
- en: '|                         (equal? rt (numT))) |'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (equal? rt (numT))) |'
- en: '|                    (numT) |'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (numT) |'
- en: '|                    (error ''tc "* not both numbers")))] |'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (error ''tc "* 不是两个数字")))] |'
- en: Do Now!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始！
- en: Did you see what’s different?
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你看到了什么不同之处吗？
- en: 'That’s right: practically nothing! (The multC instead of plusC in the type-case,
    and the slightly different error message, notwithstanding.) That’s because, from
    the perspective of type-checking (in this type language), there is no difference
    between addition and multiplication, or indeed between any two functions that
    consume two numbers and return one.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 没错：实际上几乎没有什么区别！（类型案例中的multC而不是plusC，以及稍微不同的错误消息除外。）这是因为，从类型检查的角度来看（在此类型语言中），加法和乘法之间没有区别，实际上也没有区别两个消耗两个数字并返回一个数字的任何两个函数之间。
- en: 'Observe another difference between interpreting and type-checking. Both care
    that the arguments be numbers. The interpreter then returns a precise sum or product,
    but the type-checker is indifferent to the differences between them: therefore
    the expression that computes what it returns ((numT)) is a constant, and the same
    constant in both cases.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 再观察一下解释和类型检查之间的另一个区别。两者都要求参数为数字。然后解释器返回一个精确的和或积，但类型检查器对它们之间的差异漠不关心：因此，计算返回值的表达式((numT))是一个常量，在两种情况下都是相同的常量。
- en: 'Finally, the two hard cases: application and funcions. We’ve already discussed
    what application must do: compute the value of the function and argument expressions;
    ensure the function expression has function type; and check that the argument
    expression is of compatible type. If all this holds up, then the type of the overall
    application is whatever type the function body would return (because the value
    that eventually returns at run-time is the result of evaluating the function’s
    body).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两个困难的情况：应用和函数。我们已经讨论了应用必须做什么：计算函数和参数表达式的值；确保函数表达式具有函数类型；检查参数表达式的类型是否兼容。如果所有这些都成立，那么整个应用的类型就是函数体将返回的任何类型（因为最终在运行时返回的值是评估函数体的结果）。
- en: '[<tc-appC-case>](#(elem._(chunk._~3ctc-app.C-case~3e~3a1))) ::='
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-appC-case>](#(elem._(chunk._~3ctc-app.C-case~3e~3a1))) ::='
- en: '| [appC (f a) (let ([ft (tc f tenv)] |'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [appC (f a) (let ([ft (tc f tenv)] |'
- en: '|                   [at (tc a tenv)]) |'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   [at (tc a tenv)]) |'
- en: '|               (cond |'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (cond |'
- en: '|                 [(not (funT? ft)) |'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [(not (funT? ft)) |'
- en: '|                  (error ''tc "not a function")] |'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (error ''tc "不是一个函数")] |'
- en: '|                 [(not (equal? (funT-arg ft) at)) |'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [(not (equal? (funT-arg ft) at)) |'
- en: '|                  (error ''tc "app arg mismatch")] |'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (error ''tc "应用参数不匹配")] |'
- en: '|                 [else (funT-ret ft)]))] |'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [else (funT-ret ft)]))] |'
- en: That leaves function definitions. The function has a formal parameter, which
    is presumably used in the body; unless this is bound in the environment, the body
    most probably will not type-check properly. Thus we have to extend the type environment
    with the formal name bound to its type, and in that extended environment type-check
    the body. Whatever value this computes must be the same as the declared type of
    the body. If that is so, then the function itself has a function type from the
    type of the argument to the type of the body.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了函数定义。该函数有一个形式参数，据推测在函数体中使用；除非此参数在环境中绑定，否则函数体很可能无法正确进行类型检查。因此，我们必须使用形式名称扩展类型环境，该名称绑定到其类型，并在该扩展环境中对函数体进行类型检查。无论此计算得到的值是什么，都必须与函数体的声明类型相同。如果是这样，那么函数本身就具有从参数类型到函数体类型的函数类型。
- en: Exercise
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Why do I say “most probably” above?
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么我在上面说“很可能”？
- en: '[<tc-lamC-case>](#(elem._(chunk._~3ctc-lam.C-case~3e~3a1))) ::='
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-lamC-case>](#(elem._(chunk._~3ctc-lam.C-case~3e~3a1))) ::='
- en: '| [lamC (a argT retT b) |'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [lamC (a argT retT b) |'
- en: '|       (if (equal? (tc b (extend-ty-env (bind a argT) tenv)) retT) |'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (if (equal? (tc b (extend-ty-env (bind a argT) tenv)) retT) |'
- en: '|           (funT argT retT) |'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (funT argT retT) |'
- en: '|           (error ''tc "lam type mismatch"))] |'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (error ''tc "lam类型不匹配"))] |'
- en: Observe another curious difference between the interpreter and type-checker.
    In the interpreter, application was responsible for evaluating the argument expression,
    extending the environment, and evaluating the body. Here, the application case
    does check the argument expression, but leaves the environment alone, and simply
    returns the type of the body without traversing it. Instead, the body is actually
    traversed by the checker when checking a function definition, so this is the point
    at which the environment actually extends.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意解释器和类型检查器之间的另一个奇怪差异。在解释器中，应用负责评估参数表达式、扩展环境和评估主体。在这里，应用案例确实检查了参数表达式，但是保持环境不变，只是简单地返回主体的类型而不对其进行遍历。相反，当检查函数定义时，实际上是检查器遍历主体的时候，因此这是环境实际扩展的时候。
- en: 15.2.2Type-Checking Conditionals
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.2 类型检查条件
- en: Suppose we extend the above language with conditionals. Even the humble if introduces
    several design decisions. We’ll discuss two here, and return to one of them later
    [REF].
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们用条件扩展了上述语言。即使是谦虚的 if 也会引入几个设计决策。我们将在这里讨论其中两个，并且稍后回到其中一个 [REF]。
- en: What should be the type of the test expression? In some languages it must evaluate
    to a boolean value, in which case we have to enrich the type language to include
    booleans (which would probably be a good idea anyway). In other languages it can
    be any value, and some values are considered “truthy” while others “falsy”.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试表达式的类型应该是什么？在一些语言中，它必须求值为布尔值，这种情况下我们必须丰富类型语言以包括布尔值（这可能是个好主意）。在其他语言中，它可以是任何值，并且一些值被认为是“真值”，而另一些被认为是“假值”。
- en: What should be the relationship between the then- and else-branches? In some
    languages they must be of the same type, so that there is a single, unambiguous
    type for the overall expression (which is that one type). In other languages the
    two branches can have distinct types, which greatly changes the design of the
    type-language and -checker, but also of the nature of the programming language
    itself.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: then- 和 else- 分支之间应该是什么关系？在一些语言中，它们必须具有相同的类型，以便整个表达式有一个单一、明确的类型（即那个类型）。在其他语言中，这两个分支可以有不同的类型，这极大地改变了类型语言和类型检查器的设计，也改变了编程语言本身的性质。
- en: Exercise
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Add booleans to the type language. What does this entail at a minimum, and what
    else might be expected in a typical language?
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将布尔值添加到类型语言中。这至少需要什么，并且在典型语言中可能还期望有什么？
- en: Exercise
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Add a type rule for conditionals, where the test expression is expected to evaluate
    to a boolean and both then- and else-branches must have the same type, which is
    the type of the overall expression.
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为条件添加一个类型规则，其中测试表达式预计将求值为布尔值，并且 then- 和 else- 分支必须具有相同的类型，即整个表达式的类型。
- en: 15.2.3Recursion in Code
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3 代码中的递归
- en: Now that we’ve obtained a basic programming language, let’s add recursion to
    it. We saw earlier [REF] that this could be done easily through desugaring. It’ll
    prove to be a more complex story here.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了一个基本的编程语言，让我们为其添加递归。我们先前看到 [REF]，这可以通过展开轻松完成。但在这里将会是一个更复杂的情况。
- en: 15.2.3.1A First Attempt at Typing Recursion
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3.1 尝试类型递归的第一个尝试
- en: Let’s now try to express a simple recursive function. The simplest is, of course,
    one that loops forever. Can we write an infinite loop with just functions? We
    already could simply with this program—<wbr>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试表达一个简单的递归函数。最简单的当然是一个永远循环的函数。我们能用函数写一个无限循环吗？我们已经可以通过这个程序简单地完成了—<wbr>
- en: '| ((lambda (x) (x x)) |'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((lambda (x) (x x)) |'
- en: '|  (lambda (x) (x x))) |'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (lambda (x) (x x))) |'
- en: —<wbr>which we know we can represent in our language with functions as values.Exercise
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: —<wbr>我们知道我们可以用函数作为值在我们的语言中表示。练习
- en: Why does this construct an infinite loop? What subtle dependency is it making
    about the nature of function calls?
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这为什么构成了一个无限循环？它对函数调用的本质做了什么微妙的依赖？
- en: Now that we have a typed language, and one that forces us to annotate all functions,
    let’s annotate it. For simplicity, from now on we’ll assume we’re writing programs
    in a typed surface syntax, and that desugaring takes care of constructing core
    language terms.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个有类型的语言，并且一个强制我们对所有函数进行注释的语言，让我们对其进行注释。为简单起见，从现在开始，我们假设我们在一个有类型的表面语法中编写程序，并且展开操作负责构造核心语言术语。
- en: Observe, first, that we have two identical terms being applied to each other.
    Historically, the overall term is called Ω (capital omega in Greek) and each of
    the identical sub-terms is called ω (lower-case omega in Greek). It is not a given
    that identical terms must have precisely the same type, because it depends on
    what invariants we want to assert of the context of use. In this case, however,
    observe that x binds to ω, so the second ω goes into both the first and second
    positions. As a result, typing one effectively types both.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意，我们有两个相同的术语被应用于彼此。从历史上看，整个术语被称为Ω（希腊大写的 omega），每个相同的子术语被称为ω（希腊小写的 omega）。相同的术语必须具有完全相同的类型并不是必然的，因为它取决于我们想要在使用环境中断言的不变量是什么。然而，在这种情况下，请注意x绑定到ω，因此第二个ω进入第一和第二个位置。因此，输入一个有效地相当于同时输入两个。
- en: Therefore, let’s try to type ω; let’s call this type γ. It’s clearly a function
    type, and the function takes one argument, so it must be of the form φ -> ψ. Now
    what is that argument? It’s ω itself. That is, the type of the value going into
    φ is itself γ. Thus, the type of ω is γ, which is φ -> ψ, which expands into (φ
    -> ψ) -> ψ, which further expands to ((φ -> ψ) -> ψ) -> ψ, and so on. In other
    words, this type cannot be written as any finite string!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试为ω编写类型；我们将这个类型称为γ。这显然是一个函数类型，并且这个函数接受一个参数，所以它必须是形式为φ -> ψ的。现在这个参数是什么？它是ω本身。也就是说，进入φ的值的类型本身就是γ。因此，ω的类型是γ，它是φ
    -> ψ，它展开为 (φ -> ψ) -> ψ，进一步展开为 ((φ -> ψ) -> ψ) -> ψ，以此类推。换句话说，这个类型无法被写成任何有限字符串！
- en: Do Now!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: Did you notice the subtle but important leap we just made?
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你注意到我们刚刚做了微妙但重要的飞跃了吗？
- en: 15.2.3.2Program Termination
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3.2 程序终止
- en: 'We observed that the obvious typing of Ω, which entails typing γ, seems to
    run into serious problems. From that, however, we jumped to the conclusion that
    this type cannot be written as any finite string, for which we’ve given only an
    intuition, not a proof. In fact, something even stranger is true: in the type
    system we’ve defined so far, we cannot type Ω at all!'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到Ω的明显类型化似乎会遇到严重问题。然而，从那里，我们跳到了这种类型无法被写成任何有限字符串的结论，对此我们只是给出了直觉，而不是证明。事实上，更奇怪的是：在我们迄今为止定义的类型系统中，我们根本无法为Ω类型化！
- en: 'This is a strong statement, but we can actually say something much stronger.
    The typed language we have so far has a property called strong normalization:
    every expression that has a type will terminate computation after a finite number
    of steps. In other words, this special (and peculiar) infinite loop program isn’t
    the only one we can’t type; we can’t type any infinite loop (or even potential
    infinite loop). A rough intuition that might help is that any type—<wbr>which
    must be a finite string—<wbr>can have only a finite number of ->’s in it, and
    each application discharges one, so we can perform only a finite number of applications.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强有力的陈述，但实际上我们可以说得更加强烈。到目前为止，我们所拥有的带类型的语言具有一个称为强归约的属性：每个具有类型的表达式在有限步骤后将终止计算。换句话说，这个特殊（而古怪）的无限循环程序并不是我们无法类型化的唯一程序；我们无法类型化任何无限循环（甚至是潜在的无限循环）。一个可能有所帮助的粗略直觉是，任何类型——必须是一个有限的字符串——只能有有限数量的
    ->，每次应用都会释放一个，所以我们只能执行有限数量的应用。
- en: If our language permitted only straight-line programs, this would be unsurprising.
    However, we have conditionals and even functions being passed around as values,
    and with those we can encode any datatype we want. Yet, we still get this guarantee!
    That makes this a somewhat astonishing result.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的语言只允许直线程序，那么这并不奇怪。然而，我们有条件语句，甚至可以将函数作为值传递，而且我们可以用它们来编码任何我们想要的数据类型。然而，我们仍然得到了这个保证！这使得这个结果有点令人惊讶。
- en: Exercise
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Try to encode lists using functions in the untyped and then in the typed language.
    What do you see? And what does that tell you about the impact of this type system
    on the encoding?
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试使用未类型化的函数和已类型化的语言来编码列表。你看到了什么？这对编码的影响告诉了你什么？
- en: This result also says something deeper. It shows that, contrary to what you
    may believe—<wbr>that a type system only prevents a few buggy programs from running—<wbr>a
    type system can change the semantics of a language. Whereas previously we could
    write an infinite loop in just one to two lines, now we cannot write one at all.
    It also shows that the type system can establish invariants not just about a particular
    program, but about the language itself. If we want to absolutely ensure that a
    program will terminate, we simply need to write it in this language and pass the
    type checker, and the guarantee is ours!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果还说明了更深层次的东西。它表明，与您可能相信的相反——<wbr>即类型系统只能防止一些有bug的程序运行——<wbr>类型系统可以改变语言的语义。以前我们可以用一两行写一个无限循环，现在我们根本不能写了。它还表明，类型系统不仅可以建立关于特定程序的不变量，还可以建立关于语言本身的不变量。如果我们想绝对确保一个程序会终止，我们只需要用这种语言编写它并通过类型检查器，保证就是我们的！
- en: 'What possible use is a language in which all programs terminate? For general-purpose
    programming, none, of course. But in many specialized domains, it’s a tremendously
    useful guarantee to have. For instance, suppose you are implementing a complex
    scheduling algorithm; you would like to know that your scheduler is guaranteed
    to terminate so that the tasks being scheduled will actually run. There are many
    other domains, too, where we would benefit from such a guarantee: a packet-filter
    in a router; a real-time event processor; a device initializer; a configuration
    file; the callbacks in single-threaded JavaScript; and even a compiler or linker.
    In each case, we have an almost unstated expectation that these programs will
    always terminate. And now we have a language that can offer this guarantee—<wbr>something
    it is impossible to test for, no less!These are not hypothetical examples. In
    the Standard ML language, the language for linking modules uses essentially this
    typed language for writing module linking specifications. This means developers
    can write quite sophisticated abstractions—<wbr>they have functions-as-values,
    after all!—<wbr>while still being guaranteed that linking will always terminate,
    producing a program.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个所有程序都会终止的语言有什么可能的用处呢？对于通用编程来说，当然没有。但在许多专业领域中，拥有这样的保证是非常有用的。例如，假设您正在实现一个复杂的调度算法；您希望知道您的调度程序有保证地终止，以便正在调度的任务实际上能运行。还有许多其他领域，我们也会从这样的保证中受益：路由器中的包过滤器；实时事件处理器；设备初始化程序；配置文件；单线程JavaScript中的回调函数；甚至编译器或链接器。在每种情况下，我们几乎都有这样一个默默的期望，即这些程序总是会终止。现在我们有一种语言可以提供这样的保证——<wbr>这是不可能测试的东西，更何况！这些不是假设性的例子。在标准ML语言中，用于链接模块的语言基本上使用了这种带类型的语言来编写模块链接规范。这意味着开发人员可以编写相当复杂的抽象——<wbr>毕竟他们有函数作为值！——<wbr>同时仍然保证链接总是会终止，生成一个程序。
- en: 15.2.3.3Typing Recursion
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3.3递归的类型
- en: What this says is, whereas before we were able to handle rec entirely through
    desugaring, now we must make it an explicit part of the typed language. For simplicity,
    we will consider a special case of rec—<wbr>which nevertheless covers the common
    uses—<wbr>whereby the recursive identifier is bound to a function. Thus, in the
    surface syntax, one might write
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，尽管以前我们能够完全通过解糖化来处理rec，但现在我们必须将其作为类型语言的一个显式部分。为了简单起见，我们将考虑rec的一个特殊情况——<wbr>尽管这涵盖了常见的用法——<wbr>其中递归标识符绑定到一个函数。因此，在表面语法中，一个人可能会写
- en: '| (rec (Σ num (n num) |'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (rec (Σ num (n num) |'
- en: '|         (if0 n |'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (if0 n |'
- en: '|              0 |'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              0 |'
- en: '|              (n + (Σ (n + -1))))) |'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (n + (Σ (n + -1))))) |'
- en: '|   (Σ 10)) |'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (Σ 10)) |'
- en: for a summation function, where Σ is the name of the function, n its argument,
    and num the type consumed by and returned from the function. The expression (Σ
    10) represents the use of this function to sum the number from 10 until 0.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 用于求和函数，其中Σ是函数的名称，n是其参数，num是函数消耗和返回的类型。表达式(Σ 10)表示使用该函数从10加到0的数字。
- en: How do we type such an expression? Clearly, we must have n bound in the body
    of the function as we type it (but not of course, in the use of the function);
    this much we know from typing functions. But what about Σ? Obviously it must be
    bound in the type environment when checking the use ((Σ 10)), and its type must
    be num -> num. But it must also be bound, to the same type, when checking the
    body of the function. (Observe, too, that the type returned by the body must match
    its declared return type.)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为这样的表达式编写类型？显然，我们必须在函数的主体中绑定n，当我们为其编写类型时（但当然，不在函数的使用中）；这一点我们从编写函数中知道。但Σ呢？显然，在检查使用时（（Σ
    10）），它必须在类型环境中绑定，并且其类型必须是num -> num。但在检查函数主体时，它也必须绑定到相同的类型。（还要注意，主体返回的类型必须与其声明的返回类型匹配。）
- en: Now we can see how to break the shackles of the finiteness of the type. It is
    certainly true that we can write only a finite number of ->’s in types in the
    program source. However, this rule for typing recursion duplicates the -> in the
    body that refers to itself, thereby ensuring that there is an inexhaustible supply
    of applications. It’s our infinite quiver of arrows.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到如何打破类型的有限性的枷锁。当然，我们在程序源代码中只能写入有限数量的->。然而，这种递归类型的规则会在引用自身的主体中复制->，从而确保有不尽的应用。这是我们无限的箭头图。
- en: 'The code to implement this rule would be as follows. Assuming f is bound to
    the function’s name, aT is the function’s argument type and rT is its return type,
    b is the function’s body, and u is the function’s use:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此规则的代码如下。假设f绑定到函数的名称，aT是函数的参数类型，rT是其返回类型，b是函数的主体，u是函数的用途：
- en: '[<tc-lamC-case>](#(elem._(chunk._~3ctc-lam.C-case~3e~3a1))) ::='
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[<tc-lamC-case>](#(elem._(chunk._~3ctc-lam.C-case~3e~3a1))) ::='
- en: '| [recC (f a aT rT b u) |'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [recC (f a aT rT b u) |'
- en: '|       (let ([extended-env |'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (让 ([扩展环境 |'
- en: '|              (extend-ty-env (bind f (funT aT rT)) tenv)]) |'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (扩展类型环境 (绑定 f (funT aT rT)) tenv)]) |'
- en: '|         (cond |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (条件 |'
- en: '|           [(not (equal? rT (tc b |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           [(not (equal? rT (tc b |'
- en: '|                                (extend-ty-env |'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                (扩展类型环境 |'
- en: '|                                 (bind a aT) |'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                 (绑定 a aT) |'
- en: '|                                 extended-env)))) |'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                 扩展环境)))) |'
- en: '|            (error ''tc "body return type not correct")] |'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (错误 ''tc "主体返回类型不正确")] |'
- en: '|           [else (tc u extended-env)]))] |'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           [else (tc u 扩展环境)]))] |'
- en: 15.2.4Recursion in Data
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.4数据中的递归
- en: We have seen how to type recursive programs, but this doesn’t yet enable us
    to create recursive data. We already have one kind of recursive datum—<wbr>the
    function type—<wbr>but this is built-in. We haven’t yet seen how developers can
    create their own recursive datatypes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何为递归程序编写类型，但这还不足以使我们能够创建递归数据。我们已经有一种递归数据—<wbr>函数类型—<wbr>但这是内置的。我们还没有看到开发人员如何可以创建自己的递归数据类型。
- en: 15.2.4.1Recursive Datatype Definitions
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.4.1递归数据类型定义
- en: 'When we speak of allowing programmers to create recursive data, we are actually
    talking about three different facilities at once:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当���们说允许程序员创建递归数据时，实际上我们在谈论三种不同的功能：
- en: Creating a new type.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新类型。
- en: Letting instances of the new type have one or more fields.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让新类型的实例具有一个或多个字段。
- en: Letting some of these fields refer to instances of the same type.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让一些这些字段引用相同类型的实例。
- en: 'In fact, once we allow the third, we must allow one more:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一旦我们允许第三个，我们必须再允许一个：
- en: Allowing non-recursive base-cases for the type.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许类型具有非递归基本情况。
- en: This confluence of design criteria leads to what is commonly called an algebraic
    datatype, such as the types supported by our typed language. For instance, consider
    the following definition of a binary tree of numbers:Later [REF], we will discuss
    how types can be parameterized.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计标准的融合导致了通常称为代数数据类型的东西，例如我们的类型化语言支持的类型。例如，考虑以下对数字的二叉树的定义：稍后[REF]，我们将讨论类型如何可以被参数化。
- en: '| (define-type BTnum |'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义类型 BTnum |'
- en: '|   [BTmt] |'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [BTmt] |'
- en: '|   [BTnd (n : number) (l : BTnum) (r : BTnum)]) |'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [BTnd (n : number) (l : BTnum) (r : BTnum)]) |'
- en: Observe that without a name for the new datatype, BTnum, we would not have been
    able to refer back ot it in BTnd. Similarly, without the ability to have more
    than one kind of BTnum, we would not have been able to define BTmt, and thus wouldn’t
    have been able to terminate the recursion. Finally, of course, we need multiple
    fields (as in BTnd) to construct useful and interesting data. In other words,
    all three mechanisms are packaged together because they are most useful in conjunction.
    (However, some langauges do permit the definition of stand-alone structures. We
    will return to the impact of this design decision on the type system later [REF].)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，如果没有新数据类型 BTnum 的名称，我们将无法在 BTnd 中引用它。同样，如果没有能力有多种类型的 BTnum，我们将无法定义 BTmt，因此也无法终止递归。最后，当然，我们需要多个字段（如
    BTnd 中所示）来构造有用且有趣的数据。换句话说，这三种机制一起打包，因为它们在结合使用时最有用。 （然而，一些语言确实允许定义独立的结构。我们稍后会回到这个设计决策对类型系统的影响
    [REF]。）
- en: This concludes our initial presentation of recursive types, but it has a fatal
    problem. We have not actually explained where this new type, BTnum, comes from.
    That is because we have had to pretend it is baked into our type-checker. However,
    it is simply impractical to keep changing our type-checker for each new recursive
    type definition—<wbr>it would be like modifying our interpreter each time the
    program contains a recursive function! Instead, we need to find a way to make
    such definitions intrinsic to the type language. We will return to this problem
    later [REF].
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对递归类型的初始介绍，但它存在一个致命问题。我们实际上并没有解释新类型 BTnum 是从哪里来的。这是因为我们不得不假装它是内置在我们的类型检查器中的。然而，每次定义一个新的递归类型时都改变我们的类型检查器是不现实的——这就像每次程序包含递归函数时都修改我们的解释器一样！相反，我们需要找到一种使这样的定义固有于类型语言的方法。我们稍后会回到这个问题
    [REF]。
- en: 'This style of data definition is sometimes also known as a sum of products.
    “Product” refers to the way fields combine in one variant: for instance, the legal
    values of a BTnd are the cross-product of legal values in each of the fields,
    supplied to the BTnd constructor. The “sum” is the aggregate of all these variants:
    any given BTnum value is just one of these. (Think of “product” as being “and”,
    and “sum” as being “or”.)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据定义风格有时也称为总和乘积。 “乘积” 指的是一种变体中字段组合的方式：例如，BTnd 的合法值是供应给 BTnd 构造器的每个字段中的合法值的交叉乘积。
    “总和” 是所有这些变体的总和：任何给定的 BTnum 值只是其中的一个。 （将 “乘积” 视为 “和”，将 “总和” 视为 “或”）。
- en: 15.2.4.2Introduced Types
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.4.2 引入的类型
- en: 'Now, what impact does a datatype definition have? First, it introduces a new
    type; then it uses this to define several constructors, predicates, and selectors.
    For instance, in the above example, it first introduces BTnum, then uses it to
    ascribe the following types:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数据类型定义有什么影响呢？首先，它引入了一个新类型；然后，它使用这个类型来定义几个构造器、谓词和选择器。例如，在上面的例子中，它首先引入 BTnum，然后用它来描述以下类型：
- en: '| BTmt : -> BTnum |'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTmt : -> BTnum |'
- en: '| BTnd : number * BTnum * BTnum -> BTnum |'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTnd : number * BTnum * BTnum -> BTnum |'
- en: '| BTmt? : BTnum -> boolean |'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTmt? : BTnum -> boolean |'
- en: '| BTnd? : BTnum -> boolean |'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTnd? : BTnum -> boolean |'
- en: '| BTnd-n : BTnum -> number |'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTnd-n : BTnum -> number |'
- en: '| BTnd-l : BTnum -> BTnum |'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTnd-l : BTnum -> BTnum |'
- en: '| BTnd-r : BTnum -> BTnum |'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTnd-r : BTnum -> BTnum |'
- en: 'Observe a few salient facts:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到一些显著的事实：
- en: Both the constructors create instances of BTnum, not something more refined.
    We will discuss this design tradeoff later [REF].
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个构造器创建的是 BTnum 的实例，而不是更精细的东西。我们稍后会讨论这个设计上的权衡 [REF]。
- en: Both predicates consume values of type BTnum, not “any”. This is because the
    type system can already tell us what type a value is. Thus, we only need to distinguish
    between the variants of that one type.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个谓词消耗的是 BTnum 类型的值，而不是“任何”类型的值。这是因为类型系统已经可以告诉我们一个值是什么类型。因此，我们只需要区分该类型的各个变体。
- en: The selectors really only work on instances of the relevant variant—<wbr>e.g.,
    BTnd-n can work only on instances of BTnd, not on instances of BTmt—<wbr>but we
    don’t have a way to express this in the static type system for lack of a suitable
    static type. Thus, applying these can only result in a dynamic error, not a static
    one caught by the type system.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器实际上只能在相关变体的实例上工作——例如，BTnd-n 只能在 BTnd 的实例上工作，而不能在 BTmt 的实例上工作——但我们没有办法在静态类型系统中表达这一点，因为缺乏合适的静态类型。因此，应用这些选择器只会导致动态错误，而不是类型系统捕获的静态错误。
- en: There is more to say about recursive types, which we will return to shortly
    [REF].
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关于递归类型还有更多要说的，我们马上会回来 [REF]。
- en: 15.2.4.3Pattern-Matching and Desugaring
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.4.3 模式匹配和语法糖
- en: Once we observe that these are the types, the only thing left is to provide
    an account of pattern-matching. For instance, we can write the expression
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们观察到这些是类型，唯一剩下的就是提供模式匹配的说明。例如，我们可以编写表达式
- en: '| (type-case BTnum t |'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (type-case BTnum t |'
- en: '|   [BTmt () e1] |'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [BTmt () e1] |'
- en: '|   [BTnd (nv lt rt) e2]) |'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [BTnd (nv lt rt) e2]) |'
- en: 'We have already seen [REF] that this can be written in terms of the functions
    defined above. We can simulate the binding done by this pattern-matcher using
    let:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到[REF]，这可以根据上面定义的函数来编写。我们可以使用 let 模拟此模式匹配器所做的绑定：
- en: '| (cond |'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (cond |'
- en: '|   [(BTmt? t) e1] |'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [(BTmt? t) e1] |'
- en: '|   [(BTnd? t) (let ([nv (BTnd-n t)] |'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [(BTnd? t) (let ([nv (BTnd-n t)] |'
- en: '|                    [lt (BTnd-l t)] |'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    [lt (BTnd-l t)] |'
- en: '|                    [rt (BTnd-r t)]) |'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    [rt (BTnd-r t)]) |'
- en: '|                e2)]) |'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                e2)]) |'
- en: In short, this can be done by a macro, so pattern-matching does not need to
    be in the core language and can instead be delegated to desugaring. This, in turn,
    means that one language can have many different pattern-matching mechanisms.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这可以通过宏来实现，因此模式匹配不需要在核心语言中，而可以委托给解糖。这反过来意味着一种语言可以有许多不同的模式匹配机制。
- en: Except, that’s not quite true. Somehow, the macro that generates the code above
    in terms of cond needs to know that the three positional selectors for a BTnd
    are BTnd-n, BTnd-l, and BTnd-r, respectively. This information is explicit in
    the type definition but only implicitly present in the use of the pattern-matcher
    (that, indeed, being the point). Thus, somehow this information must be communicated
    from definition to use. Thus the macro expander needs something akin to the type
    environment to accomplish its task.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这并不完全正确。一些生成上述代码的宏需要知道 BTnd 的三个位置选择器分别是 BTnd-n、BTnd-l 和 BTnd-r。这些信息在类型定义中是显式的，但在模式匹配器的使用中只是隐含的（这确实是重点）。因此，这些信息必须以某种方式从定义传达到使用。因此，宏展开器需要类似于类型环境的东西来完成其任务。
- en: Observe, furthermore, that expressions such as e1 and e2 cannot be type-checked—<wbr>indeed,
    cannot even be reliable identified as expressions—<wbr>until macro expansion expands
    the use of type-case. Thus, expansion depends on the type environment, while type-checking
    depends on the result of expansion. In other words, the two are symbiotic and
    need to happen, not quite in “parallel”, but rather in lock-step. Thus, building
    desugaring for a typed language, where the syntactic sugar makes assumptions about
    types, is a little more intricate than doing so for an untyped language.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，诸如 e1 和 e2 这样的表达式无法进行类型检查，甚至无法可靠地识别为表达式，直到宏展开扩展了 type-case 的使用。因此，扩展取决于类型环境，而类型检查取决于扩展的结果。换句话说，这两者是共生的，需要发生，不完全是“并行”的，而是步调一致。因此，为具有类型的语言构建解糖，其中语法糖对类型做出假设，比为无类型的语言构建解糖要复杂一些。
- en: 15.2.5Types, Time, and Space
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.5 类型、时间和空间
- en: 'It is evident that types already bestow a performance benefit in safe languages.
    That is because the checks that would have been performed at run-time—<wbr>e.g.,
    + checking that both its arguments are indeed numbers—<wbr>are now performed statically.
    In a typed language, an annotation like : number already answers the question
    of whether or not something is of a particular a type; there is nothing to ask
    at run-time. As a result, these type-level predicates can (and need to) disappear
    entirely, and with them any need to use them in programs.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '显而易见，类型在安全语言中已经带来了性能优势。这是因为原本在运行时会执行的检查，比如检查其参数是否确实为数字，现在在静态环境下执行。在类型化的语言中，像
    : number 这样的注解已经回答了某物是否属于特定类型的问题；在运行时不需要再进行任何询问。因此，这些类型级别的断言可以（并且需要）完全消失，以及在程序中使用它们的任何需求。'
- en: This is at some cost to the developer, who must convince the static type system
    that their program does not induce type errors; due to the limitations of decidability,
    even programs that might have run without error might run afoul of the type system.
    Nevertheless, for programs that meet this requirement, types provide a notable
    execution time saving.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，这会带来一些成本，他们必须说服静态类型系统他们的程序不会引发类型错误；由于可决定性的限制，即使可能无错误地运行的程序也可能违反类型系统。然而，对于符合此要求的程序，类型提供了显著的执行时间节省。
- en: Now let’s discuss space. Until now, the language run-time system has needed
    to store information attached to every value indicating what its type is. This
    is how it can implement type-level predicates such as number?, which may be used
    both by developers and by primitives. If those predicates disappear, so does the
    space needed to hold information to implement them. Thus, type-tags are no longer
    necessary.They would, however, still be needed by the garbage collector, though
    other representations such as BIBOP can greatly reduce their space impact.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论空间问题。直到现在，语言运行时系统需要存储附加到每个值的信息，指示其类型是什么。这是它如何实现诸如 number? 这样的类型级谓词的方式，这些谓词可能被开发人员和原语同时使用。如果这些谓词消失，用于实现它们的空间也会消失。因此，类型标签不再是必要的。但是，垃圾收集器仍然需要它们，尽管其他表示形式如
    BIBOP 可以大大减少它们的空间影响。
- en: 'The type-like predicates still left are those for variants: BTmt? and BTnd?,
    in the example above. These must indeed be applied at run-time. For instance,
    as we have noted, selectors like BTnd-n must perform this check. Of course, some
    more optimizations are possible. Consider the code generated by desugaring the
    pattern-matcher: there is no need for the three selectors to implement this check,
    because control could only have gotten to them after BTnd? returned a true vlaue.
    Thus, the run-time system could provide just the desugaring level access to special
    unsafe primitives that do not perform the check, resulting in generated code such
    as this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然留下的类型谓词是变异的：BTmt? 和 BTnd?，如上例所示。这些确实必须在运行时应用。例如，正如我们所注意到的，像 BTnd-n 这样的选择器必须执行此检查。当然，还有一些更多的优化是可能的。考虑通过解糖模式匹配器生成的代码：这里没有必要为这三个选择器实现这个检查，因为控制只能在
    BTnd? 返回 true 值后才会到达它们。因此，运行时系统可以仅为解糖级别提供访问特殊不执行检查的不安全原语，从而生成类似以下的代码：
- en: '| (cond |'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (cond |'
- en: '|   [(BTmt? t) e1] |'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [(BTmt? t) e1] |'
- en: '|   [(BTnd? t) (let ([nv (BTnd-n/no-check t)] |'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [(BTnd? t) (let ([nv (BTnd-n/no-check t)] |'
- en: '|                    [lt (BTnd-l/no-check t)] |'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    [lt (BTnd-l/no-check t)] |'
- en: '|                    [rt (BTnd-r/no-check t)]) |'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    [rt (BTnd-r/no-check t)]) |'
- en: '|                e2)]) |'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                e2)]) |'
- en: The net result, however, is that the run-time representation must still store
    enough information to accurately answer these questions. However, previously it
    needed to use enough bits to record every possible type (and variant). Now, because
    the types have been statically segregated, for a type with no variants (e.g.,
    there is only one kind of string), there is no need to store any variant information
    at all; that means the run-time system can use all available bits to store actual
    dynamic values.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终结果是，运行时表示仍然必须存储足够的信息来准确回答这些问题。然而，以前它需要使用足够的位来记录每种可能的类型（和变体）。现在，由于类型已经静态分离，对于没有变体的类型（例如，只有一种字符串），根本不需要存储任何变体信息；这意味着运行时系统可以使用所有可用的位来存储实际动态值。
- en: In contrast, when variants are present, the run-time system must sacrifice bits
    to distinguish between the variants, but the number of variants within a type
    is obviously far smaller than the number of variants and types across all types.
    In the BTnum example above, there are only two variants, so the run-time system
    needs to use only one bit to record which variant of BTnum a value represents.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当存在变体时，运行时系统必须牺牲位来区分这些变体，但是一个类型内的变体数量明显远小于所有类型的变体和类型的数量。在上面的 BTnum 示例中，只有两种变体，因此运行时系统只需使用一位来记录值表示的
    BTnum 的哪种变体。
- en: Observe, in particular, that the type system’s segregation prevents confusion.
    If there are two different datatypes that each have two variants, in the untyped
    world all these four variants require distinct representations. In contrast, in
    the typed world these representations can overlap across types, because the static
    type system will ensure one type’s variants are never confused for that the another.
    Thus, types have a genuine space (saving representation) and time (eliminating
    run-time checks) performance benefit for programs.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意的是，类型系统的分离可以防止混淆。如果存在两种不同的数据类型，每种类型都有两个变体，在未类型化的世界中，所有这些四个变体都需要不同的表示。相比之下，在类型化的世界中，这些表示可以跨越类型重叠，因为静态类型系统将确保一个类型的变体永远不会被误认为是另一个类型的变体。因此，对于程序来说，类型确实具有真正的空间（节省表示）和时间（消除运行时检查）性能优势。
- en: 15.2.6Types and Mutation
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.6 类型与变异
- en: 'We have now covered most of the basic features of our core language other than
    mutation. In some ways, types have a simple interaction with mutation, and this
    is because in a classical setting, they don’t interact at all. Consider, for instance,
    the following untyped program:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了我们核心语言的大部分基本特性，除了突变。在某种程度上，类型与突变有着简单的交互，这是因为在传统设置中，它们根本不互动。例如，考虑以下未经类型化的程序：
- en: '| (let ([x 10]) |'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([x 10]) |'
- en: '|   (begin |'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (begin |'
- en: '|     (set! x 5) |'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (set! x 5) |'
- en: '|     (set! x "something"))) |'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (set! x "something"))) |'
- en: 'What is “the type” of x? It doesn’t really have one: for some time it’s a number,
    and later (note the temporal word) it’s a string. We simply can’t give it a type.
    In general, type checking is an atemporal activity: it is done once, before the
    program runs, and must hence be independent of the specific order in which programs
    execute. Keeping track of the precise values in the store is hence beyond the
    reach of a type-checker.The example above is, of course, easy to statically understand,
    but we should never be mislead by simple examples. Suppose instead we had a program
    like'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: x的“类型”是什么？它实际上没有一个固定的类型：有一段时间它是一个数字，稍后（注意时间词）它是一个字符串。我们根本无法给它一个类型。一般来说，类型检查是一种非时间性的活动：它在程序运行之前只进行一次，并且因此必须独立于程序执行的具体顺序。因此，跟踪存储中的精确值是超出类型检查器的能力范围的。上面的例子当然很容易静态理解，但我们不应该被简单的例子误导。假设我们有一个像下面这样的程序
- en: '| (let ([x 10]) |'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([x 10]) |'
- en: '|   (if (even? (read-number "Enter a number")) |'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (if (even? (read-number "输入一个数字")) |'
- en: '|     (set! x 5) |'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (set! x 5) |'
- en: '|     (set! x "something"))) |'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (set! x "something"))) |'
- en: Now it is literally impossible to reach any static conclusion about the type
    of x after the conditional finishes, because only at run-time can we know what
    the user might have entered.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在条件结束后，关于x的类型达到任何静态结论都是不可能的，因为只有在运行时我们才能知道用户可能输入了什么。
- en: 'To avoid this morass, traditional type checkers adopt a simple policy: types
    must be invariant across mutation. That is, a mutation operation—<wbr>whether
    variable mutation or structure mutation—<wbr>cannot change the type of the mutant.
    Thus, the above examples would not type in our type language so far. How much
    flexibility this gives the programmer is, however, a function of the type language.
    For instance, if we were to admit a more flexible type that stands for “number
    or string”, then the examples above would type, but x would always have this,
    less precise, type, and all uses of x would have to contend with its reduced specificity,
    an issue we will return to later [REF].'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种困境，传统类型检查器采用了一个简单的策略：类型必须在突变过程中保持不变。也就是说，突变操作——无论是变量突变还是结构突变——都不能改变突变体的类型。因此，上面的例子在我们的类型语言中到目前为止都无法通过类型检查。然而，程序员能够获得多少灵活性取决于类型语言。例如，如果我们允许一个更灵活的类型，代表“数字或字符串”，那么上面的例子就能通过类型检查，但是x将始终具有这种不太精确的类型，并且所有对x的使用都必须处理其降低的特定性，这是我们稍后将回到的问题[REF]。
- en: In short, mutation is easy to account for in a traditional type system because
    its rule is simply that, while the value can change in ways below the level of
    specificity of the type system, the type cannot change. In the case of an operation
    like set! (or our core language’s setC), this means the type of the assigned value
    must match that of the variable. In the case of structure mutation, such as boxes,
    it means the assigned value must match that the box’s contained type.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在传统类型系统中，突变很容易解释，因为其规则仅仅是，虽然值可以以类型系统的特定级别以下的方式改变，但类型不能改变。对于像set!（或我们核心语言的setC）这样的操作，这意味着分配值的类型必须与变量的类型匹配。对于结构突变，比如盒子，这意味着分配的值必须与盒子的包含类型匹配。
- en: '15.2.7The Central Theorem: Type Soundness'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.7中心定理：类型完整性
- en: 'We have seen earlier [REF] that certain type languages can offer very strong
    theorems about their programs: for instance, that all programs in the language
    terminate. In general, of course, we cannot obtain such a guarantee (indeed, we
    added general recursion precisely to let ourselves write unbounded loops). However,
    a meaningful type system—<wbr>indeed, anything to which we wish to bestow the
    noble title of a type systemWe have repeatedly used the term “type system”. A
    type system is usually a combination of three components: a language of types,
    a set of type rules, and an algorithm that applies these rules to programs. By
    largely presenting our type rules embedded in a function, we have blurred the
    distinction between the second and third of these, but can still be thought of
    as intellectually distinct.—<wbr>ought to provide some kind of meaningful guarantee
    that all typed programs enjoy. This is the payoff for the programmer: by typing
    this program, she can be certain that certain bad things will certainly not happen.
    Short of this, we have just a bug-finder; while it may be useful, it is not a
    sufficient basis for building any higher-level tools (e.g., for obtaining security
    or privacy or robustness guarantees).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过[REF]，某些类型语言可以为它们的程序提供非常强大的定理：例如，语言中的所有程序都终止。当然，总的来说，我们不能获得这样的保证（事实上，我们添加了一般递归，正是为了让自己编写无限循环）。然而，一个有意义的类型系统——确实，任何值得我们赋予“类型系统”这一尊贵称的东西我们已经多次使用了“类型系统”这个术语。一个类型系统通常是三个组成部分的组合：类型语言、类型规则集合和将这些规则应用于程序的算法。通过在一个函数中主要呈现我们的类型规则，我们已经模糊了这两者之间的区别，但仍然可以被视为在智力上是不同的。——应该提供某种有意义的保证，即所有带类型的程序都享有。这是程序员的回报：通过为这个程序编写类型，她可以确信某些不好的事情肯定不会发生。除此之外，我们只是一个错误查找器；虽然它可能有用，但它不足以构建任何高级工具的基础（例如，用于获得安全性、隐私或健壮性保证）。
- en: 'What theorem might we want of a type system? Remember that the type checker
    runs over the static program, before execution. In doing so, it is essentially
    making a prediction about the program’s behavior: for instance, when it states
    that a particular complex term has type num, it is effectively predicting that
    when run, that term will produce a numeric value. How do we know this prediction
    is sound, i.e., that the type checker never lies? Every type system should be
    accompanied by a theorem that proves this.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望类型系统有哪些定理？请记住，类型检查器在执行之前运行在静态程序上。在这样做时，它实际上在对程序的行为进行预测：例如，当它声明一个特定的复杂项具有类型num时，它实际上在预测当运行时，该项将产生一个数字值。我们怎么知道这个预测是正确的，即类型检查器从不撒谎？每个类型系统都应该伴随着一个定理来证明这一点。
- en: 'There is a good reason to be suspicious of a type system, beyond general skepticism.
    There are many differences between the way a type checker and a program evaluator
    work:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个类型系统，怀疑是有道理的，除了一般的怀疑之外。类型检查器和程序求值器之间有许多差异：
- en: The type checker only sees program text, whereas the evaluator runs over actual
    stores.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查器只看到程序文本，而求值器则运行在实际存储上。
- en: The type environment binds identifiers to types, whereas the evaluator’s environment
    binds identifiers to values or locations.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型环境将标识符绑定到类型，而求值器的环境将标识符绑定到值或位置。
- en: The type checker compresses (even infinite) sets of values into types, whereas
    the evaluator treats these distinctly.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查器将（甚至无限的）值集合压缩成类型，而求值器将它们区别对待。
- en: The type checker always terminates, whereas the evaluator might not.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查器总是终止的，而求值器可能不会。
- en: The type checker passes over the body of each expression only once, whereas
    the evaluator might pass over each body anywhere from zero to infinite times.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查器仅对每个表达式的主体经过一次，而求值器可能对每个主体经过零次到无限次。
- en: Thus, we should not assume that these will always correspond!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不应该假设这些总是对应的！
- en: The central result we wish to have for a given type-system is called soundness.
    It says this. Suppose we are given an expression (or program) e. We type-check
    it and conclude that its type is t. When we run e, let us say we obtain the value
    v. Then v will also have type t.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定类型系统，我们希望获得的中心结果称为声音性。它是这样说的。假设我们有一个表达式（或程序）e。我们对其进行类型检查，并得出其类型为t。当我们运行e时，假设我们得到值v。那么v也将具有类型t。
- en: The standard way of proving this theorem is to prove it in two parts, known
    as progress and preservation. Progress says that if a term passes the type-checker,
    it will be able to make a step of evaluation (unless it is already a value); preservation
    says that the result of this step will have the same type as the original. If
    we interleave these steps (first progress, then preservation; repeat), we can
    conclude that the final answer will indeed have the same type as the original,
    so the type system is indeed sound.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 证明这个定理的标准方法是分两部分证明，即进展和保持。进展指的是，如果一个术语通过了类型检查，它将能够进行一步评估（除非它已经是一个值）；保持指的是，这一步的结果将与原始类型相同。如果我们交错进行这些步骤（首先进展，然后保持；重复），我们可以得出最终答案确实与原始类型相同的结论，因此类型系统确实是正确的。
- en: 'For instance, consider this expression: (+ 5 (* 2 3)). It has the type num.
    In a sound type system, progress offers a proof that, because this term types,
    and is not already a value, it can take a step of execution—<wbr>which it clearly
    can. After one step the program reduces to (+ 5 6). Sure enough, as preservation
    proves, this has the same type as the original: num. Progress again says this
    can take a step, producing 11. Preservation again shows that this has the same
    type as the previous (intermediate) expressions: num. Now progress finds that
    we are at an answer, so there are no steps left to be taken, and our answer is
    of the same type as that given for the original expression.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个表达式：(+ 5 (* 2 3))。它的类型是num。在一个正确的类型系统中，进展提供了一个证明，因为这个术语有类型，并且不是一个值，它可以执行一步—显然可以。经过一步后，程序简化为(+
    5 6)。果然，保持证明，这与原始类型相同：num。进展再次表示这可以进行一步，产生11。保持再次显示，这与先前（中间）表达式的类型相同：num。现在进展发现我们得到了一个答案，因此没有剩余的步骤可执行，我们的答案与原始表达式给出的类型相同。
- en: 'However, this isn’t the entire story. There are two caveats:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是整个故事。有两个警告：
- en: The program may not produce an answer at all; it might loop forever. In this
    case, the theorem strictly speaking does not apply. However, we can still observe
    that every intermediate term still has the same type, so the program is computing
    meaningfully even if it isn’t producing a value.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序可能根本不会产生答案；它可能永远循环。在这种情况下，严格来说定理并不适用。然而，我们仍然可以观察到每个中间术语仍然具有相同的类型，因此即使程序不产生值，它仍然在有意义地计算。
- en: Any rich enough language has properties that cannot be decided statically (and
    others that perhaps could be, but the language designer chose to put off until
    run-time). When one of these properties fails—<wbr>e.g., the array index being
    within bounds—<wbr>there is no meaningful type for the program. Thus, implicit
    in every type soundness theorem is some set of published, permitted exceptions
    or error conditions that may occur. The developer who uses a type system implicitly
    signs on to accepting this set.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何足够丰富的语言都具有无法静态决定的属性（以及其他可能可以静态决定的属性，但语言设计者选择推迟到运行时）。当这些属性之一失败时—例如，数组索引超出范围—程序就没有有意义的类型。因此，每个类型正确性定理中都隐含着一些已发布的、允许的异常或错误条件集合，可能会发生。使用类型系统的开发人员隐含地同意接受这一集合。
- en: As an example of the latter set, the user of a typical typed language acknowledges
    that vector dereference, list indexing, and so on may all yield exceptions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 作为后一种集合的例子，典型类型化语言的用户承认，向量解引用、列表索引等都可能产生异常。
- en: 'The latter caveat looks like a cop-out. In fact, it is easy to forget that
    it is really a statement about what cannot happen at run-time: any exception not
    in this set will provably not be raised. Of course, in languages designed with
    static types in the first place, it is not clear (except by loose analogy) what
    these exceptions might be, because there would be no need to define them. But
    when we retrofit a type system onto an existing programming language—<wbr>especially
    languages with only dynamic enforcement, such as Racket or Python—<wbr>then there
    is already a well-defined set of exceptions, and the type-checker is explicitly
    stating that some set of those exceptions (such as “non-function found in application
    position” or “method not found”) will simply never occur. This is therefore the
    payoff that the programmer receives in return for accepting the type system’s
    syntactic restrictions.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种警告看起来像是在推诿责任。事实上，很容易忘记这实际上是关于运行时不可能发生的一个声明：任何不在这个集合中的异常都将不会被触发。当然，在首先设计静态类型的语言中，不清楚（除了通过宽泛的类比）这些异常可能是什么，因为不需要定义它们。但是当我们在现有编程语言上添加类型系统—尤其是只有动态强制执行的语言，例如
    Racket 或 Python—时，已经有一个明确定义的异常集合，并且类型检查器明确声明了其中一些异常集（例如“在应用位置找不到非函数”或“找不到方法”）将永远不会发生。因此，这就是程序员接受类型系统的语法限制所得到的回报。
- en: 15.3Extensions to the Core
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 核心的扩展
- en: Now that we have a basic typed language, let’s explore how we can extend it
    to obtain a more useful programming language.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的类型化语言，让我们探讨如何扩展它以获得一个更有用的编程语言。
- en: 15.3.1Explicit Parametric Polymorphism
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1 显式参数化多态
- en: Which of these is the same?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中哪一个是相同的？
- en: List<String>
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: List<String>
- en: ''
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: List<String>
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: List<String>
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (listof string)
  id: totrans-328
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: (字符串列表)
- en: Actually, none of these is quite the same. But the first and third are very
    alike, because the first is in Java and the third in our typed language, whereas
    the second, in C++, is different. All clear? No? Good, read on!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些都不太相同。但是第一个和第三个非常相似，因为第一个是在 Java 中，第三个是在我们的类型化语言中，而第二个在 C++ 中是不同的。清楚了吗？没有？好的，继续读下去！
- en: 15.3.1.1Parameterized Types
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1.1 参数化类型
- en: The language we have been programming in already demonstrates the value of parametric
    polymorphism. For instance, the type of map is given as
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编程的语言已经展示了参数化多态的价值。例如，map 的类型是这样给出的
- en: '| ((''a -> ''b) (listof ''a) -> (listof ''b)) |'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((''a -> ''b) (’a列表) -> (’b列表)) |'
- en: 'which says that for all types ’a and ’b, map consumes a function that generates
    ’b values from ’a values, and a list of ’a values, and generates the corresponding
    list of ’b values. Here, ’a and ’b are not concrete types; rather, they are type
    variables (in our terminology, these should properly be called “type identifiers”
    because they don’t change within the course of an instantiation; however, we will
    stick to the traditional terminology).A different way to understand this is that
    there is actually an infinite family of map functions. For instance, there is
    a map that has this type:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示对于所有类型 ’a 和 ’b，map 消耗一个从 ’a 值生成 ’b 值的函数，以及 ’a 值的列表，并生成相应的 ’b 值列表。这里，’a 和
    ’b 不是具体类型；而是类型变量（在我们的术语中，这些应该适当地称为“类型标识符”，因为它们在实例化过程中不会改变；然而，我们将坚持传统的术语）。理解这一点的另一种方法是，实际上有一个无限的
    map 函数家族。例如，有一个 map 具有这种类型：
- en: '| ((number -> string) (listof number) -> (listof string)) |'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((数 -> 字符串) (字符串列表) -> (字符串列表)) |'
- en: 'and another one of this type (nothing says the types have to be base types):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个属于这种类型的（没有说类型必须是基本类型）：
- en: '| ((number -> (number -> number)) (listof number) -> (listof (number -> number)))
    |'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((数 -> (数 -> 数)) (数列表) -> ((数 -> 数)列表)) |'
- en: 'and yet another one of this type (nothing says ’a and ’b can’t be the same):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个属于这种类型的（没有说 ’a 和 ’b 不能相同）：
- en: '| ((string -> string) (listof string) -> (listof string)) |'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((字符串 -> 字符串) (字符串列表) -> (字符串列表)) |'
- en: 'and so on. Because they have different types, they would need different names:
    map_num_str, map_num_num->num, map_str_str, and so on. But that would make them
    different functions, so we’d have to always refer to a specific map rather than
    each of the generic ones.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。因为它们有不同的类型，它们需要不同的名称：map_num_str、map_num_num->num、map_str_str 等。但那将使它们成为不同的函数，所以我们必须总是引用一个特定的
    map 而不是每一个通用的 map。
- en: 'Obviously, it is impossible to load all these functions into our standard library:
    there’s an infinite number of these! We’d rather have a way to obtain each of
    these functions on demand. Our naming convention offers a hint: it is as if map
    takes two parameters, which are types. Given the pair of types as arguments, we
    can then obtain a map that is customized to that particular type. This kind of
    parameterization over types is called parametric polymorphism.Not to be confused
    with the “polymorphism” of objects, which we will discuss below [REF].'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将所有这些函数加载到我们的标准库中是不可能的：这些函数有无限多个！我们宁愿有一种方法能够按需获取每个这些函数。我们的命名约定提供了一个提示：就像
    map 接受两个参数，它们是类型。给定一对类型作为参数，然后我们可以获得一个根据特定类型定制的 map。这种类型上的参数化称为参数多态性。不要与对象的“多态性”混淆，我们将在下面讨论。
- en: 15.3.1.2Making Parameters Explicit
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1.2 明确参数
- en: In other words, we’re effectively saying that map is actually a function of
    perhaps four arguments, two of them types and two of them actual values (a function
    and a list). In a language with explicit types, we might try to write
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们实际上是在说 map 实际上是一个函数，可能有四个参数，其中两个是类型，另外两个是实际值（一个函数和一个列表）。在一个具有显式类型的语言中，我们可能会尝试编写
- en: '| (define (map [a : ???] [b : ???] [f : (a -> b)] [l : (listof a)]) : (listof b)
    |'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (map [a : ???] [b : ???] [f : (a -> b)] [l : (listof a)]) : (listof
    b) |'
- en: '|   ...) |'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ...) |'
- en: but this raises some questions. First, what goes in place of the ???? These
    are the types of a and b. But if a and b are themselves going to be replaced with
    types, then what is the type of a type? Second, do we really want to be calling
    map with four arguments on every instantiation? Third, do we really mean to take
    the type parameters first before any actual values? The answers to these questions
    actually lead to a very rich space of polymorphic type systems, most of which
    we will not explore here.I recommend reading Pierce’s Types and Programming Languages
    for a modern, accessible introduction.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这引发了一些问题。首先，???? 应该填什么？这些是 a 和 b 的类型。但如果 a 和 b 本身将被类型替换，那么类型的类型是什么呢？其次，我们真的想在每次实例化时都使用四个参数来调用
    map 吗？第三，我们真的想在任何实际值之前先取类型参数吗？这些问题的答案实际上导致了一个非常丰富的多态类型系统空间，我们大部分不会在这里探讨。我建议阅读皮尔斯的《类型与编程语言》以获得现代、易于理解的介绍。
- en: Observe that once we start parameterizing, more code than we expect ends up
    being parameterized. For instance, consider the type of the humble cons. Its type
    really is parametric over the type of values in the list (even though it doesn’t
    actually depend on those values!—<wbr>more on that in a bit [REF]) so every use
    of cons must be instantiated at the appropriate type. For that matter, even empty
    must be instantiated to create an empty list of the correct type! Of course, Java
    and C++ programmers are familiar with this pain.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦我们开始参数化，比我们预期的代码更多地被参数化了。例如，考虑简单的 cons 的类型。它的类型确实是针对列表中值的类型进行参数化的（即使它实际上并不依赖于这些值！——稍后会详细说明）。因此，对
    cons 的每次使用都必须以适当的类型进行实例化。同样，即使是空的也必须被实例化以创建正确类型的空列表！当然，Java 和 C++ 程序员都熟悉这种痛苦。
- en: 15.3.1.3Rank-1 Polymorphism
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1.3 排名-1 多态性
- en: 'Instead, we will limit ourselves to one particularly useful and tractable point
    in this space, which is the type system of Standard ML, of the typed language
    of this book, of earlier versions of Haskell, roughly that of Java and C# with
    generics, and roughly that obtained using templates in C++. This language defines
    what is called predicative, rank-1, or prenex polymorphism. It answers the above
    questions thus: nothing, no, and yes. Let’s explore this below.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将限制自己在这个空间中的一个特别有用且易处理的点，即本书的类型化语言的类型系统、较早版本的 Haskell 的类型系统、Java 和 C# 的泛型以及在
    C++ 中使用模板大致相同。这种语言定义了所谓的谓词、排名-1 或前置多态性。它对上述问题的答案如下：没有、不、是的。让我们在下面探讨一下。
- en: 'We first divide the world of types into two groups. The first group consists
    of the type language we’ve used until, but extended to include type variables;
    these are called monotypes. The second group, known as polytypes, consists of
    parameterized types; these are conventionally written with a ∀ prefix, a list
    of type variables, and then a type expression that might use these variables.
    Thus, the type of map would be:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将类型世界分成两组。第一组包括我们一直使用的类型语言，但扩展为包括类型变量；这些称为单态。第二组，称为多态，包括参数化类型；这些通常以∀前缀、类型变量列表，然后是可能使用这些变量的类型表达式来书写。因此，map
    的类型将是：
- en: '| ∀ a, b : ((''a -> ''b) (listof ''a) -> (listof ''b)) |'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ∀ a, b : ((''a -> ''b) (listof ''a) -> (listof ''b)) |'
- en: 'Since “∀” is the logic symbol for “for all”, you would read this as: “for all
    types ’a and ’b, the type of map is...”.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: “∀”是逻辑符号“对于所有”的符号，你可以这样阅读：“对于所有类型’a和’b，map的类型是…”。
- en: In rank-1 polymorphism, the type variables can only be substituted with monotypes.
    (Furthermore, these can only be concrete types, because there would be nothing
    left to substitute any remaining type variables.) As a result, we obtain a clear
    separation between the type variable-parameters and regular parameters. We don’t
    need to provide a “type annotation” for the type variables because we know precisely
    what kind of thing they can be. This produces a relatively clean language that
    still offers considerable expressive power.Impredicative languages erase the distinction
    between monotypes and polytypes, so a type variable can be instantiated with another
    polymorphic type.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在秩-1多态中，类型变量只能用单类型替换。（此外，这些只能是具体类型，因为不会剩下任何类型变量可替换。）因此，我们获得了类型变量参数和常规参数之间的明确分离。我们不需要为类型变量提供“类型注释”，因为我们确切地知道它们可以是什么类型。这产生了一种相对清洁的语言，仍然提供了相当大的表达能力。非预测性语言抹去了单类型和多类型之间的区别，因此类型变量可以用另一个多态类型实例化。
- en: 'Observe that because type variables can only be replaced with monotypes, they
    are all independent of each other. As a result, all type parameters can be brought
    to the front of the parameter list. This is what enables us to write types in
    the form ∀ tv, ... : t where the tv are type variables and t is a monotype (that
    might refer to those variables). This justifies not only the syntax but also the
    name “prenex”. It will prove to also be useful in the implementation.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于类型变量只能被单类型替换，它们彼此独立。因此，所有类型参数都可以被带到参数列表的前面。这就使我们能够以∀ tv，…：t的形式编写类型，其中tv是类型变量，t是单类型（可能引用这些变量）。这不仅证明了语法，还证明了“前言”的名称。这也将在实现中证明是有用的。
- en: 15.3.1.4Interpreting Rank-1 Polymorphism as Desugaring
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1.4将秩-1多态解释为解糖
- en: 'The simplest implementation of this feature is to view it as a form of desugaring:
    this is essentially the interpretation taken by C++. (Put differently, because
    C++ has a macro system in the form of templates, by a happy accident it obtains
    a form of rank-1 polymorphism through the use of templates.) For instance, imagine
    we had a new syntactic form, define-poly, which takes a name, a type variable,
    and a body. On every provision of a type to the name, it replaces the type variable
    with the given type in the body. Thus:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这一特性的最简单实现是将其视为一种解糖形式：这基本上是C++所采用的解释方式。（换句话说，因为C++具有模板形式的宏系统，由于一个幸运的巧合，它通过使用模板获得了一种秩-1多态形式。）例如，想象一下我们有一个新���语法形式define-poly，它接受一个名称、一个类型变量和一个主体。在为名称提供类型时，它会在主体中用给定的类型替换类型变量。因此：
- en: '| (define-poly (id t) (lambda ([x : t]) : t x)) |'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-poly (id t) (lambda ([x : t]) : t x)) |'
- en: 'defines an identity function by first defining id to be polymorphic: given
    a concrete type for t, it yields a procedure of one argument of type (t -> t)
    (where t is appropriately substituted). Thus we can instantiate id at many different
    types—<wbr>'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过将id定义为多态来定义一个恒等函数：给定t的具体类型，它产生一个类型为（t -> t）的一个参数过程（其中t被适当替换）。因此，我们可以在许多不同类型上实例化id—<wbr>
- en: '| (define id_num (id number)) |'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define id_num (id number)) |'
- en: '| (define id_str (id string)) |'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define id_str (id string)) |'
- en: '—<wbr>thereby obtaining identity functions at each of those types: (test (id_num
    5) 5) (test (id_str "x") "x") In contrast, expressions like (id_num "x") (id_str
    5) will, as we would expect, fail to type-check (rather than fail at run-time).In
    case you’re curious, here’s the implementation. For simplicity, we assume there
    is only one type parameter; this is easy to generalize using .... We will not
    only define a macro for define-poly, it will in turn define a macro:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: —<wbr>从而在每种类型上获得恒等函数：（test（id_num 5）5）（test（id_str“x”）“x”）相比之下，表达式（id_num“x”）（id_str
    5）将无法通过类型检查（而不是在运行时失败）。如果你感兴趣，这是实现。为简单起见，我们假设只有一个类型参数；这很容易推广使用….我们不仅将为define-poly定义一个宏，它将反过来定义一个宏：
- en: '| (define-syntax define-poly |'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax define-poly |'
- en: '|   (syntax-rules () |'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-rules () |'
- en: '|     [(_ (name tyvar) body) |'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(_ (name tyvar) body) |'
- en: '|      (define-syntax (name stx) |'
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (define-syntax (name stx) |'
- en: '|        (syntax-case stx () |'
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        (syntax-case stx () |'
- en: '|          [(_ type) |'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          [(_ type) |'
- en: '|           (with-syntax ([tyvar #''type]) |'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (with-syntax ([tyvar #''type]) |'
- en: '|             #''body)]))])) |'
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             #''body)]))])) |'
- en: Thus, given a definition such as
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到这样的定义
- en: '| (define-poly (id t) (lambda ([x : t]) : t x)) |'
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-poly (id t) (lambda ([x : t]) : t x)) |'
- en: 'the language creates a macro named id: the part that begins with (define-syntax
    (name ...) ...) (where, in this example, name is id). An instantiation of id,
    such as (id number), replaces t the type variable, tyvar, with the given type.
    To circumvent hygiene, we use with-syntax to force all uses of the type variable
    (tyvar) to actually be replaced with the given type. Thus, in effect,'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 语言创建了一个名为 id 的宏：从（define-syntax（name ...）...）开始的部分（在这个例子中，name 是 id）。id 的实例化，比如（id
    number），用给定的类型替换类型变量 tyvar。为了规避卫生问题，我们使用 with-syntax 强制所有类型变量（tyvar）的使用实际上被给定的类型替换。因此，实际上，
- en: '| (define id_num (id number)) |'
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define id_num (id number)) |'
- en: turns into
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '| (define id_num (lambda ([x : number]) : number x)) |'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define id_num (lambda ([x : number]) : number x)) |'
- en: However, this approach has two important limitations.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有两个重要的限制。
- en: 'Let’s try to define a recursive polymorphic function, such as filter. Earlier
    we have said that we ought to instantiate every single polymorphic value (such
    as even cons and empty) with types, but to keep our code concise we’ll rely on
    the fact that the underlying typed language already does this, and focus just
    on type parameters for filter. Here’s the code:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试定义一个递归的多态函数，比如 filter。之前我们说过，我们应该为每个多态值（如 even cons 和 empty）实例化类型，但为了保持代码简洁，我们将依赖底层类型化语言已经做到这一点，并只关注
    filter 的类型参数。以下是代码：
- en: '| (define-poly (filter t) |'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-poly (filter t) |'
- en: '|   (lambda ([f : (t -> boolean)] [l : (listof t)]) : (listof t) |'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda ([f : (t -> boolean)] [l : (listof t)]) : (listof t) |'
- en: '|     (cond |'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (cond |'
- en: '|       [(empty? l) empty] |'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(empty? l) empty] |'
- en: '|       [(cons? l) (if (f (first l)) |'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(cons? l) (if (f (first l)) |'
- en: '|                      (cons (first l) |'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (cons (first l) |'
- en: '|                            ((filter t) f (rest l))) |'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            ((filter t) f (rest l))) |'
- en: '|                      ((filter t) f (rest l)))]))) |'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      ((filter t) f (rest l)))]))) |'
- en: Observe that at the recursive uses of filter, we must instantiate it with the
    appropriate type.This is a perfectly good definition. There’s just one problem.
    When we try to use it—<wbr>e.g.,
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 filter 的递归使用中，我们必须用适当的类型实例化它。这是一个非常好的定义。只有一个问题。当我们尝试使用它时，例如，
- en: '| (define filter_num (filter number)) |'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define filter_num (filter number)) |'
- en: DrRacket does not terminate. Specifically, macro expansion does not terminate,
    because it is repeatedly trying to make new copies of the code of filter. If,
    in contrast, we write the function as follows, expansion terminates—<wbr>
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DrRacket 不会终止。具体来说，宏展开不会终止，因为它一直在尝试制作 filter 代码的新副本。相反，如果我们将函数写成以下形式，展开就会终止，
- en: '| (define-poly (filter2 t) |'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-poly (filter2 t) |'
- en: '|   (letrec ([fltr |'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (letrec ([fltr |'
- en: '|             (lambda ([f : (t -> boolean)] [l : (listof t)]) : (listof t)
    |'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|             (lambda ([f : (t -> boolean)] [l : (listof t)]) : (listof t)
    |'
- en: '|               (cond |'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (cond |'
- en: '|                 [(empty? l) empty] |'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [(empty? l) empty] |'
- en: '|                 [(cons? l) (if (f (first l)) |'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [(cons? l) (if (f (first l)) |'
- en: '|                                (cons (first l) (fltr f (rest l))) |'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                (cons (first l) (fltr f (rest l))) |'
- en: '|                                (fltr f (rest l)))]))]) |'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                (fltr f (rest l)))]))]) |'
- en: '|     fltr)) |'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|     fltr)) |'
- en: but this needlessly pushes pain onto the user. Indeed, some template expanders
    will cache previous values of expansion and avoid re-generating code when given
    the same parameters. (Racket cannot do this because, in general, the body of a
    macro can depend on mutable variables and values and even perform input-output,
    so Racket cannot guarantee that a given input will always generate the same output.)
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但这只是把痛苦推给了用户。事实上，一些模板扩展器将缓存先前的扩展值，并在给定相同参数时避免重新生成代码。（Racket 不能这样做，因为一般来说，宏的主体可能依赖于可变变量和值，甚至执行输入输出，因此
    Racket 不能保证给定的输入总是生成相同的输出。）
- en: 'Consider two instantiations of the identity function. We cannot compare id_num
    and id_str because they are of different types, but even if they are of the same
    type, they are not eq?:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑两个 identity 函数的实例化。我们无法比较 id_num 和 id_str，因为它们是不同类型的，但即使它们是相同类型，它们也不是 eq?：
- en: '| (test (eq? (id number) (id number)) #f) |'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (eq? (id number) (id number)) #f) |'
- en: This is because each use of id creates a new copy of the body. Now even if the
    optimization we mentioned above were applied, so for the same type there is only
    one code body, there would still be different code bodies for different typesIndeed,
    C++ templates are notorious for creating code bloat; this is one of the reasons.—<wbr>but
    even this is unnecessary! There’s absolutely nothing in the body of id, for instance,
    that actually depends on the type of the argument. Indeed, the entire infinite
    family of id functions can share just one implementation. The simple desugaring
    strategy fails to provide this.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为每次使用id都会创建一个新的函数体副本。即使我们上面提到的优化应用了，所以对于相同类型只有一个代码体，对于不同类型仍然会有不同的代码体。实际上，C++模板因创建代码膨胀而臭名昭著；这是其中一个原因。——但即使如此也是不必要的！例如，id函数体中实际上没有任何依赖于参数类型的内容。事实上，整个无限系列的id函数可以共享一个实现。简单的解糖策略无法做到这一点。
- en: In other words, the desugaring based strategy, which is essentially an implementation
    by substitution, has largely the same problems we saw earlier with regards to
    substitution as an implementation of parameter instantiation. However, in other
    cases substitution also gives us a ground truth for what we expect as the program’s
    behavior. The same will be true with polymorphism, as we will soon see [REF].
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，基于解糖的策略，本质上是一种替换实现，与替换作为参数实例化的实现相比，基本上存在与之前相同的问题。然而，在其他情况下，替换还为我们提供了对程序行为的期望的真实性。与多态性相同，我们很快将会看到
    [REF]。
- en: Observe that one virtue to the desugaring strategy is that it does not require
    our type checker to “know” about polymorphism. Rather, the core type language
    can continue to be monomorphic, and all the (rank-1) polymorphism is handled entirely
    through expansion. This offers a cheap strategy for adding polymorphism to a language,
    though—<wbr>as C++ shows—<wbr>it also introduces significant overheads.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解糖策略的一个优点是它不需要我们的类型检查器“了解”多态性。相反，核心类型语言可以继续是单态的，而所有（第一级）多态性完全通过扩展处理。这为向语言添加多态性提供了一种廉价的策略，尽管——如C++所示——它也引入了显着的开销。
- en: Finally, though we have only focused on functions, the preceding discussions
    applies equally well to data structures.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管我们只关注函数，但前面的讨论同样适用于数据结构。
- en: 15.3.1.5Alternate Implementations
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1.5替代实现
- en: 'There are other implementation strategies that don’t suffer from these problems.
    We won’t go into them here, but the essence of at least some of them is the “caching”
    approach we sketched above. Because we can be certain that, for a given set of
    type parameters, we will always get the same typed body, we never need to instantiate
    a polymorphic function at the same type twice. This avoids the infinite loop.
    If we type-check the instantiated body once, we can avoid checking at other instantiations
    of the same type (because the body will not have changed). Furthermore, we do
    not need to retain the instantiated sources: once we have checked the expanded
    program, we can dispose of the expanded terms and retain just one copy at run-time.
    This avoids all the problems discussed in the pure desugaring strategy shown above,
    while retaining the benefits.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他实施策略不会受到这些问题的影响。我们不会在这里详细介绍它们，但至少其中一些的本质是我们上面概述的“缓存”方法。因为我们可以确定，对于给定的类型参数集，我们总是会得到相同类型的函数体，我们永远不需要在相同类型上两次实例化多态函数。这避免了无限循环。如果我们一次对实例化的函数体进行类型检查，我们就可以避免在相同类型的其他实例化上进行检查（因为函数体不会改变）。此外，我们也不需要保留实例化的源代码：一旦我们检查了扩展程序，我们就可以丢弃扩展术语，只保留运行时的一个副本。这避免了上面纯解糖策略中讨论的所有问题，同时保留了好处。
- en: Actually, we are being a little too glib. One of the benefits of static types
    is that they enable us to pick more precise run-time representations. For instance,
    a static type can tell us whether we have a 32-bit or 64-bit number, or for that
    matter a 32-bit value or a 1-bit value (effectively, a boolean). A compiler can
    then generate specialized code for each representation, taking advantage of how
    the bits are laid out (for example, 32 booleans can be packed into a single 32-bit
    word). Thus, after type-checking at each used type, the polymorphic instantiator
    may keep track of all the special types at which a function or data structure
    was used, and provide this information to the compiler for code-generation. This
    will then result in several copies of the function, none of which are eq? with
    each other—<wbr>but for good reason and, because their operations are truly different,
    rightly so.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，我们有点太轻率了。静态类型的一个好处是，它们使我们能够选择更精确的运行时表示。例如，静态类型可以告诉我们是 32 位还是 64 位的数字，或者是
    32 位值还是 1 位值（实际上，是一个布尔值）。编译器然后可以为每个表示生成专门的代码，利用位的布局方式（例如，32 个布尔值可以打包到一个 32 位的字中）。因此，在每个使用的类型进行类型检查后，多态实例化器可以跟踪函数或数据结构使用的所有特殊类型，并将此信息提供给编译器进行代码生成。然后，这将导致函数的多个副本，它们彼此不等同，但有很好的原因，并且因为它们的操作确实不同，所以是正确的。
- en: 15.3.1.6Relational Parametricity
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1.6 关系参数化
- en: There’s one last detail we must address regarding polymorphism.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 关于多态性，还有一个细节我们必须解决。
- en: We earlier said that a function like cons doesn’t depend on the specific values
    of its arguments. This is also true of map, filter, and so on. When map and filter
    want to operate on individual elements, they take as a parameter another function
    which in turn is responsible for making decisions about how to treat the elements;
    map and filter themselves simply obey their parameter functions.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过像 cons 这样的函数不依赖于其参数的具体值。这也适用于 map、filter 等函数。当 map 和 filter 想要操作单个元素时，它们接受另一个函数作为参数，而这个函数则负责决定如何处理元素；map
    和 filter 本身只是遵循其参数函数的规则。
- en: One way to “test” whether this is true is to substitute some different values
    in the argument list, and a correspondingly different parameter function. That
    is, imagine we have a relation between two sets of values; we convert the list
    elements according to the relation, and the parameter function as well. The question
    is, will the output from map and filter also be predictable by the relation? If,
    for some input, this was not true of the output of map, then it must be that map
    inspected the actual values and did something with that information. But in fact
    this won’t happen for map, or indeed most of the standard polymorphic functions.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一种“测试”这个命题是否正确的方法是替换参数列表中的一些不同值，以及相应不同的参数函数。也就是说，想象我们有两组值之间的关系；我们根据这个关系转换列表元素，以及参数函数。问题是，map
    和 filter 的输出是否也可以通过这个关系来预测？如果对于某些输入，map 的输出不符合这个关系，那么必然是因为 map 检查了实际的值，并根据这些信息执行了某些操作。但实际上，这种情况不会发生在
    map 上，或者说是大多数标准的多态函数上。
- en: 'Functions that obey this relational rule are called relationally parametricRead
    Wadler’s Theorems for Free! and Reynolds’s Types, Abstraction and Parametric Polymorphism..
    This is another very powerful property that types give us, because they tell us
    there is a strong limit on the kinds of operations such polymorphic functions
    can perform: essentially, that they can drop, duplicate, and rearrange elements,
    but not directly inspect and make decisions on them.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这种关系规则的函数被称为关系参数化。这是类型给我们带来的另一个非常强大的属性，因为它告诉我们这些多态函数能执行的操作有很强的限制：基本上，它们可以丢弃、复制和重新排列元素，但不能直接检查和做出决策。
- en: 'At first this sounds very impressive (and it is!), but on inspection you might
    realize this doesn’t square with your experience. In Java, for instance, a polymorphic
    method can still use instanceof to check which particular kind of value it obtained
    at run-time, and change its behavior accordingly. Such a method would indeed not
    be relationally parametric!On the Web, you will often find this property described
    as the inability of a function to inspect the argument—<wbr>which is not quite
    right. Indeed, relational parametricity can equally be viewed as a statement of
    the weakness of the language: that it permits only a very limited set of operations.
    (You could still inspect the type—<wbr>but not act upon what you learned, which
    makes the inspection pointless. Therefore, a run-time system that wants to simulate
    relational parametricity would have to remove operations like instanceof as well
    as various proxies to it: for instance, adding 1 to a value and catching exceptions
    would reveal whether the value is a number.) Nevertheless, it is a very elegant
    and surprising result, and shows the power of program reasoning possible with
    rich type systems.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这听起来非常令人印象深刻（而且确实如此！），但仔细检查后，您可能会意识到这与您的经验不符。例如，在Java中，一个多态方法仍然可以使用instanceof来检查在运行时获得的特定类型的值，并相应地更改其行为。这样的方法确实不是关系参数化的！在网络上，您经常会发现这种属性被描述为函数无法检查参数的能力—<wbr>这并不完全正确。事实上，关系参数化同样可以被视为语言弱点的陈述：它只允许一组非常有限的操作。（您仍然可以检查类型—<wbr>但不能根据所学到的内容采取行动，这使得检查毫无意义。因此，一个想要模拟关系参数化的运行时系统必须删除诸如instanceof以及各种代理的操作：例如，将值加1并捕获异常将会显示该值是否为数字。）尽管如此，这是一个非常优雅和令人惊讶的结果，展示了具有丰富类型系统可能实现的程序推理能力。
- en: 15.3.2Type Inference
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2类型推断
- en: Writing polymorphic type instantiations everywhere can be an awfully frustrating
    process, as users of many versions of Java and C++ can attest. Imagine if in our
    programs, every single time we wrote first or rest, we had to also instantiate
    it at a type! The reason we have been able to avoid this fate is because our language
    implements type inference. This is what enables us to write the definition
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中到处写多态类型实例化可能是一个非常令人沮丧的过程，许多Java和C++的用户可以证明这一点。想象一下，如果在我们的程序中，每次我们写first或rest时，还必须为其实例化一个类型！我们能够避免这种命运的原因是因为我们的语言实现了类型推断。这就是使我们能够编写定义
- en: '| (define (mapper f l) |'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （定义（mapper f l） |'
- en: '|   (cond |'
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   （条件 |'
- en: '|     [(empty? l) empty] |'
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [（l为空？）空] |'
- en: '|     [(cons? l) (cons (f (first l)) (mapper f (rest l)))])) |'
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [（cons？ l）（cons （f （first l）） （mapper f （rest l））]）） |'
- en: and have the programming environment automatically declare that
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 并让编程环境自动声明
- en: '| > mapper |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| > 映射器 |'
- en: '| - ((''a -> ''b) (listof ''a) -> (listof ''b)) |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| - （''a -> ''b）（''a的列表）->（''b的列表） |'
- en: Not only is this the correct type, this is a very general type! The process
    of being able to derive such general types just from the program structure feels
    almost magical. Now let’s look behind the curtain.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅是正确的类型，而且是一个非常通用的类型！能够仅通过程序结构推导出这样通用类型的过程几乎感觉像是魔术。现在让我们看看幕后。
- en: First, let’s understand what type inference is doing. Some people mistakenly
    think of languages with inference as having no type declarations, with inference
    taking their place. This is confused at multiple levels. For one thing, even in
    languages with inference, programmers are free (and for documentation purposes,
    often encouraged—<wbr>as you have been)Sometimes, inference is also undecidable
    and programmers have no choice but to declare some of the types. Finally, writing
    explicit annotations can greatly reduce indecipherable error messages. to declare
    types. Furthemore, in the absence of such declarations, it is not quite clear
    what inference actually means.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解类型推断在做什么。有些人错误地认为具有推断的语言没有类型声明，推断取代了它们。这在多个层面上是混淆的。首先，即使在具有推断的语言中，程序员也可以自由地（并且出于文档目的，通常被鼓励—<wbr>就像您一直在做的那样）有时，推断也是不可判定的，程序员别无选择，只能声明一些类型。最后，编写显式注释可以大大减少难以理解的错误消息。声明类型。此外，在没有这些声明的情况下，推断实际意味着什么并不太清楚。
- en: Instead, it is better to think of the underlying language as being fully, explicitly
    typed—<wbr>just like the polymorphic language we have just studied [REF]. We will
    simply say that we are free to leave the type annotations after the :’s blank,
    and assume some programming environment feature will fill them in for us. (And
    if we can go that far, we can drop the :’s and extra embellishments as well, and
    let them all be inserted automatically. Thus, inference becomes simply a user
    convenience for alleviating the burden of writing type annotations, but the language
    underneath is explicitly typed.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，更好的想法是将底层语言视为完全、明确标注类型的—<wbr>就像我们刚刚学习的多态语言[REF]一样。我们只需说我们可以将冒号后面的类型注释留空，并假设某个编程环境特性会为我们填充它们。（如果我们可以做到这一点，我们也可以去掉冒号和额外的修饰，让它们都自动插入。因此，推断只是一个方便用户减轻写类型注释负担的功能，但底层语言是明确标注类型的。
- en: 'How do we even think about what inference does? Suppose we have an expression
    (or program) e, written in an explicitly typed language: i.e., e has type annotations
    everywhere they are required. Now suppose we erase all annotations in e, and use
    a procedure infer to deduce them back.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何思考推断的作用？假设我们有一个表达式（或程序）e，写在一个明确标注类型的语言中：即，e在需要的地方都有类型注释。现在假设我们擦除e中的所有注释，并使用一个推断过程来推断它们。
- en: Do Now!
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做！
- en: What property do we expect of infer?
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们期望推断具有什么属性？
- en: 'We could demand many things of it. One might be that it produces precisely
    those annotations that e originally had. This is problematic for many reasons,
    not least that e might not even type-check, in which case how could infer possibly
    know what they were (and hence should be)? This might strike you as a pedantic
    trifle: after all, if e didn’t type-check, how can erasing its annotations and
    filling them back in make it do so? Since neither program type-checks, who cares?'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以要求它做很多事情。其中之一可能是它产生准确那些我们最初拥有的注释。这在很多方面都是有问题的，最重要的是，e可能甚至无法通过类型检查，那么推断怎么可能知道它们是什么（因此应该是什么）？这可能让你觉得这是一个琐碎的小事：毕竟，如果e没有通过类型检查，擦除其注释并重新填写它们能让它通过吗？既然两个程序都无法通过类型检查，谁在乎呢？
- en: Do Now!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做！
- en: Is this reasoning correct?
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种推理正确吗？
- en: Suppose e is
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 假设e是
- en: '| (lambda ([x : number]) : string x) |'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (lambda ([x : number]) : string x) |'
- en: This procedure obviously fails to type-check. But if we erase the type annotations—<wbr>obtaining
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程显然无法通过类型检查。但如果我们擦除类型注释——<wbr>获得
- en: '| (lambda (x) x) |'
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (lambda (x) x) |'
- en: '—<wbr>we equally obviously obtain a typeable function! Therefore, a more reasonable
    demand might be that if the original e type-checks, then so must the version with
    annotations replaced by inferred types. This one-directional implication is useful
    in two ways:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: —<wbr>我们同样显然得到一个可类型化的函数！因此，一个更合理的要求可能是，如果原始的e通过了类型检查，那么用推断类型替换注释的版本也必须通过。这种单向蕴含在两个方面都很有用：
- en: It does not say what must happen if e fails to type-check, i.e., it does not
    preclude the type inference algorithm we have, which makes the faultily-typed
    identity function above typeable.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它并没有说明如果e无法通过类型检查会发生什么，即，它并没有排除我们目前拥有的使上面错误类型的身份函数可类型化的类型推断算法。
- en: 'More importantly, it assures us that we lose nothing by employing type inference:
    no program that was previously typeable will now cease to be so. That means we
    can focus on using explicit annotations where we want to, but will not be forced
    to do so.Of course, this only holds if inference is decidable.'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更重要的是，它向我们保证我们通过使用类型推断不会损失任何东西：以前可类型化的程序现在不会停止可类型化。这意味着我们可以专注于在我们想要的地方使用明确的注释，但不会被迫这样做。当然，这仅在推断是可判定的情况下成立。
- en: 'We might also expect that both versions type to the same type, but that is
    not a given: the function'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能也期望这两个版本的类型相同，但这并不是一定的：函数
- en: '| (lambda ([x : number]) : number x) |'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (lambda ([x : number]) : number x) |'
- en: types to (number -> number), whereas applying inference to it after erasing
    types yields a much more general type. Therefore, relating these types and giving
    a precise definition of type equality is not trivial, though we will briefly return
    to this issue later [REF].
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为(number -> number)，而在擦除类型后应用推断后，得到一个更一般的类型。因此，关联这些类型并给出类型相等的精确定义并不是简单的，尽管我们稍后将简要回到这个问题[REF]。
- en: With these preliminaries out of the way, we are now ready to delve into the
    mechanics of type inference. The most important thing to note is that our simple,
    recursive-descent type-checking algorithm [REF] will no longer work. That was
    possible because we already had annotations on all function boundaries, so we
    could descend into function bodies carrying information about those annotations
    in the type environment. Sans these annotations, it is not clear how to descend.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些准备工作，我们现在准备深入探讨类型推断的机制。最重要的一点是，我们简单的递归下降类型检查算法[REF]将不再适用。这是可能的，因为我们已经在所有函数边界上有了注释，所以我们可以降入函数体时携带关于这些注释的信息在类型环境中。没有这些注释，如何下降并不清楚。
- en: 'In fact, it is not clear that there is any particular direction that makes
    more sense than another. In a definition like mapper above, each fragment of code
    influences the other. For instance, applying empty?, cons?, first, and rest to
    l all point to its being a list. But a list of what? We can’t tell from any of
    those operations. However, the fact that we apply f to each (or indeed, any) first
    element means the list members must be of a type that can be passed to f. Similarly,
    we know the output must be a list because of cons and empty. But what are its
    elements? They must be the return type of f. Finally, note something very subtle:
    when the argument list is empty, we return empty, not l (which we know is bound
    to empty at that point). Using the former leaves the type of the return free to
    be any kind of list at all (constrained only by what f returns); using the latter
    would force it to be the same type as the argument list.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，并不清楚有什么特定的方向比其他方向更有意义。在上面的 mapper 定义中，每段代码都会影响其他部分。例如，将 empty?、cons?、first
    和 rest 应用于 l 都指向它是一个列表。但是一个什么样的列表？我们无法从这些操作中得知。然而，我们对每个（或者说，任何）第一个元素应用 f 的事实意味着列表成员必须是可以传递给
    f 的类型。同样，我们知道输出必须是一个列表，因为有 cons 和 empty。但它的元素是什么？它们必须是 f 的返回类型。最后，注意到一些非常微妙的东西：当参数列表为空时，我们返回
    empty，而不是 l（我们知道此时 l 绑定到 empty）。使用前者使得返回的类型可以是任何类型的列表（仅受 f 返回的限制）；使用后者将强制它与参数列表的类型相同。
- en: All this information is in the function. But how do we extract it systematically
    and in an algorithm that terminates and enjoys the property we have stated above?
    We do this in two steps. First we generate constraints, based on program terms,
    on what the types must be. Then we solve constraints to identify inconsistencies
    and join together constraints spread across the function body. Each step is relatively
    simple, but the combination creates magic.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都在函数中。但我们如何系统地提取它，并在一个终止且具有我们上面所述属性的算法中提取它呢？我们分两步来做。首先，我们基于程序术语生成约束，确定类型必须是什么。然后，我们解决约束，识别不一致性，并将散布在函数体中的约束合并在一起。每一步都相对简单，但组合起来就会产生魔力。
- en: 15.3.2.1Constraint Generation
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2.1 约束生成
- en: 'Our goal, ultimately, is to find a type to fill into every type annotation
    position. It will prove to be just as well to find a type for every expression.
    A moment’s thought will show that this is likely necessary anyway: for instance,
    how can we determine the type to put on a function without knowing the type of
    its body? It is also sufficient, in that if every expression has had its type
    calculated, this will include the ones that need annotations.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终目标是找到一个类型填充到每个类型注释位置。找到每个表达式的类型同样重要。稍加思考就会发现，这可能是必要的：例如，我们如何确定在不知道其主体类型的情况下在函数上放置类型？这也足够了，因为如果每个表达式的类型都已计算出来，那么这将包括那些需要注释的表达式。
- en: First, we must generate constraints to (later) solve. Constraint generation
    walks the program source, emitting appropriate constraints on each expression,
    and returns this set of constraints. It works by recursive descent mainly for
    simplicity; it really computes a set of constraints, so the order of traversal
    and generation really does not matter in principle—<wbr>so we may as well pick
    recursive descent, which is easy—<wbr>though for simplicity we will use a list
    to represent this set.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须生成约束条件以便（稍后）解决。约束生成会遍历程序源代码，在每个表达式上发出适当的约束，并返回这组约束。它主要通过递归下降来实现简单性；实际上它确实计算出一组约束，因此在原则上遍历和生成的顺序并不重要—<wbr>所以我们可能会选择递归下降，这很容易—<wbr>尽管为了简单起见，我们将使用列表来表示这组约束。
- en: What are constraints? They are simply statements about the types of expressions.
    In addition, though the binding instances of variables are not expressions, we
    must calculate their types too (because a function requires both argument and
    return types). In general, what can we say about the type of an expression?
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是什么？它们只是关于表达式类型的陈述。此外，尽管变量的绑定实例不是表达式，但我们也必须计算它们的类型（因为函数需要参数和返回类型）。一般来说，我们能对表达式的类型说些什么？
- en: That it is related to the type of some identifier.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它与某个标识符的类型相关。
- en: That it is related to the type of some other expression.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它与其他表达式的类型相关。
- en: That it is a number.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个数字。
- en: That it is a function, whose domain and range types are presumably further constrained.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个函数，其定义域和值域类型可能受到进一步限制。
- en: 'Thus, we define the following two datatypes:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义以下两种数据类型：
- en: '| (define-type Constraints |'
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Constraints |'
- en: '|   [eqCon (lhs : Term) (rhs : Term)]) |'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [eqCon (lhs : Term) (rhs : Term)]) |'
- en: '|   |'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define-type Term |'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Term |'
- en: '|   [tExp (e : ExprC)] |'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [tExp (e : ExprC)] |'
- en: '|   [tVar (s : symbol)] |'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [tVar (s : symbol)] |'
- en: '|   [tNum] |'
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [tNum] |'
- en: '|   [tArrow (dom : Term) (rng : Term)]) |'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [tArrow (dom : Term) (rng : Term)]) |'
- en: 'Now we can define the process of generating constraints:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义生成约束的过程：
- en: '[<constr-gen>](#(elem._(chunk._~3cconstr-gen~3e~3a1))) ::='
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[<constr-gen>](#(elem._(chunk._~3cconstr-gen~3e~3a1))) ::='
- en: '| (define (cg [e : ExprC]) : (listof Constraints) |'
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (cg [e : ExprC]) : (listof Constraints) |'
- en: '|   (type-case ExprC e |'
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case ExprC e |'
- en: '|     [<constr-gen-numC-case>](#(elem._(chunk._~3cconstr-gen-num.C-case~3e~3a1)))
    |'
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<constr-gen-numC-case>](#(elem._(chunk._~3cconstr-gen-num.C-case~3e~3a1)))
    |'
- en: '|     [<constr-gen-idC-case>](#(elem._(chunk._~3cconstr-gen-id.C-case~3e~3a1)))
    |'
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<constr-gen-idC-case>](#(elem._(chunk._~3cconstr-gen-id.C-case~3e~3a1)))
    |'
- en: '|     [<constr-gen-plusC/multC-case>](#(elem._(chunk._~3cconstr-gen-plus.C/mult.C-case~3e~3a1)))
    |'
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<constr-gen-plusC/multC-case>](#(elem._(chunk._~3cconstr-gen-plus.C/mult.C-case~3e~3a1)))
    |'
- en: '|     [<constr-gen-appC-case>](#(elem._(chunk._~3cconstr-gen-app.C-case~3e~3a1)))
    |'
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<constr-gen-appC-case>](#(elem._(chunk._~3cconstr-gen-app.C-case~3e~3a1)))
    |'
- en: '|     [<constr-gen-lamC-case>](#(elem._(chunk._~3cconstr-gen-lam.C-case~3e~3a1)))))
    |'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<constr-gen-lamC-case>](#(elem._(chunk._~3cconstr-gen-lam.C-case~3e~3a1)))))
    |'
- en: 'When the expression is a number, all we can say is that we expect the type
    of the expression to be numeric:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式是一个数字时，我们唯一能说的是我们期望表达式的类型是数字：
- en: '[<constr-gen-numC-case>](#(elem._(chunk._~3cconstr-gen-num.C-case~3e~3a1)))
    ::='
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[<constr-gen-numC-case>](#(elem._(chunk._~3cconstr-gen-num.C-case~3e~3a1)))
    ::='
- en: '[numC (_) (list (eqCon (tExp e) (tNum)))]'
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[numC (_) (list (eqCon (tExp e) (tNum)))]'
- en: This might sound trivial, but what we don’t know is what other expectations
    are being made of this expression by those containing it. Thus, there is the possibility
    that some outer expression will contradict the assertion that this expression’s
    type must be numeric, leading to a type error.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能微不足道，但我们不知道的是，包含它的外部表达式对该表达式还有什么其他期望。因此，存在着一种可能性，即一些外部表达式将与该表达式的类型必须是数字的断言相矛盾，从而导致类型错误。
- en: 'For an identifier, we simply say that the type of the expression is whatever
    we expect to be the type of that identifier:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个标识符，我们只是说表达式的类型是我们期望的标识符类型：
- en: '[<constr-gen-idC-case>](#(elem._(chunk._~3cconstr-gen-id.C-case~3e~3a1))) ::='
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[<constr-gen-idC-case>](#(elem._(chunk._~3cconstr-gen-id.C-case~3e~3a1))) ::='
- en: '[idC (s) (list (eqCon (tExp e) (tVar s)))]'
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[idC (s) (list (eqCon (tExp e) (tVar s)))]'
- en: If the context limits its type, then this expression’s type will automatically
    be limited, and must then be consistent with what its context expects of it.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上下文限制了其类型，那么这个表达式的类型将自动受到限制，并且必须与其上下文对其期望的一致。
- en: Addition gives us our first look at a contextual constraint. For an addition
    expression, we must first make sure we generate (and return) constraints in the
    two sub-expressions, which might be complex. That done, what do we expect? That
    each of the sub-expressions be of numeric type. (If the form of one of the sub-expressions
    demands a type that is not numeric, this will lead to a type error.) Finally,
    we assert that the entire expression’s type is itself numeric.append3 is just
    a three-argument version of append.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 加法让我们首次看到上下文约束。对于加法表达式，我们必须首先确保在两个子表达式中生成（和返回）约束，这可能是复杂的。完成后，我们期望什么？我们期望每个子表达式都是数字类型。（如果一个子表达式的形式要求的类型不是数字，这将导致类型错误。）最后，我们断言整个表达式的类型本身是数字。append3只是append的三参数版本。
- en: '[<constr-gen-plusC/multC-case>](#(elem._(chunk._~3cconstr-gen-plus.C/mult.C-case~3e~3a1)))
    ::='
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[<constr-gen-plusC/multC-case>](#(elem._(chunk._~3cconstr-gen-plus.C/mult.C-case~3e~3a1)))
    ::='
- en: '| [plusC (l r) (append3 (cg l) |'
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [plusC (l r) (append3 (cg l) |'
- en: '|                       (cg r) |'
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (cg r) |'
- en: '|                       (list (eqCon (tExp l) (tNum)) |'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (list (eqCon (tExp l) (tNum)) |'
- en: '|                             (eqCon (tExp r) (tNum)) |'
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                             (eqCon (tExp r) (tNum)) |'
- en: '|                             (eqCon (tExp e) (tNum))))] |'
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                             (eqCon (tExp e) (tNum))))] |'
- en: The case for multC is identical other than the variant name.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 多元C的情况与变种名称除外是相同的。
- en: Now we get to the other two interesting cases, function declaration and application.
    In both cases, we must remember to generate and return constraints of the sub-expressions.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看另外两种有趣的情况，即函数声明和应用。在这两种情况下，我们都必须记得生成并返回子表达式的约束。
- en: 'In a function definition, the type of the function is a function (“arrow”)
    type, whose argument type is that of the formal parameter, and whose return type
    is that of the body:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，函数的类型是函数（“箭头”）类型，其参数类型是形式参数的类型，返回类型是主体的类型：
- en: '[<constr-gen-lamC-case>](#(elem._(chunk._~3cconstr-gen-lam.C-case~3e~3a1)))
    ::='
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[<constr-gen-lamC-case>](#(elem._(chunk._~3cconstr-gen-lam.C-case~3e~3a1)))
    ::='
- en: '| [lamC (a b) (append (cg b) |'
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [lamC (a b) (append (cg b) |'
- en: '|                     (list (eqCon (tExp e) (tArrow (tVar a) (tExp b)))))]
    |'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                     (list (eqCon (tExp e) (tArrow (tVar a) (tExp b)))))]
    |'
- en: 'Finally, we have applications. We cannot directly state a constraint on the
    type of the application. Rather, we can say that the function in the application
    position must consume arguments of the actual parameter expression’s type, and
    return types of the application expression’s type:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有应用程序。我们不能直接陈述应用程序类型的约束。相反，我们可以说，应用程序位置的函数必须消耗实际参数表达式类型的参数，并返回应用程序表达式类型的类型：
- en: '[<constr-gen-appC-case>](#(elem._(chunk._~3cconstr-gen-app.C-case~3e~3a1)))
    ::='
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[<constr-gen-appC-case>](#(elem._(chunk._~3cconstr-gen-app.C-case~3e~3a1)))
    ::='
- en: '| [appC (f a) (append3 (cg f) |'
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [appC (f a) (append3 (cg f) |'
- en: '|                      (cg a) |'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (cg a) |'
- en: '|                      (list (eqCon (tExp f) (tArrow (tExp a) (tExp e)))))]
    |'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (list (eqCon (tExp f) (tArrow (tExp a) (tExp e)))))]
    |'
- en: And that’s it! We have finished generating constraints; now we just have to
    solve them.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经完成了生成约束的过程；现在我们只需要解决它们。
- en: 15.3.2.2Constraint Solving Using Unification
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2.2使用统一解决约束
- en: 'The process used to solve constraints is known as unification. A unifier is
    given a set of equations. Each equation maps a variable to a term, whose datatype
    is above. Note one subtle point: we actually have two kinds of variables. Both
    tvar and tExp are “variables”, the former evidently so but the latter equally
    so because we need to solve for the types of these expressions. (An alternate
    formulation would introduce fresh type variables for each expression, but we would
    still need a way to identify which ones correspond to which expression, which
    eq? on the expressions already does automatically. Also, this would generate far
    larger constraint sets, making visual inspection daunting.)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解决约束的过程称为统一。一个统一器被赋予一组方程。每个方程将一个变量映射到一个项，其数据类型如上所示。请注意一个微妙的问题：我们实际上有两种类型的变量。
    tvar和tExp都是“变量”，前者显然如此，但后者同样如此，因为我们需要解决这些表达式的类型。（另一种形式将为每个表达式引入新的类型变量，但我们仍然需要一种方法来标识哪些变量对应于哪些表达式，这样，已经在表达式上eq的将自动执行。此外，这将生成更大的约束集合，使视觉检查令人生畏。）
- en: 'For our purposes, the goal of unification is generate a substitution, or mapping
    from variables to terms that do not contain any variables. This should sound familiar:
    we have a set of simultaneous equations in which each variable is used linearly;
    such equations are solved using Gaussian elimination. In that context, we know
    that we can end up with systems that are both under- and over-constrained. The
    same thing can happen here, as we will soon see.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，统一的目标是生成一个替换，或者从不包含任何变量的项到变量的映射。这应该听起来很熟悉：我们有一组同时方程，其中每个变量都被线性使用；这样的方程使用高斯消元法解决。在这种情况下，我们知道我们可能会得到既不完全受限也不完全受限的系统。同样的情况也可能发生在这里，我们很快就会看到。
- en: The unification algorithm works iteratively over the set of constraints. Because
    each constraint equation has two terms and each term can be one of four kinds,
    there are essentially sixteen cases to consider. Fortunately, we can cover all
    sixteen with fewer actual code cases.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 统一算法在约束集合上迭代工作。因为每个约束方程有两个项，每个项可以是四种中的一种，因此基本上有十六种情况要考虑。幸运的是，我们可以用更少的实际代码案例来涵盖所有十六种情况。
- en: The algorithm begins with the set of all constraints, and the empty substitution.
    Each constraint is considered once and removed from the set, so in principle the
    termination argument should be utterly simple, but it will prove to be only slightly
    more tricky in reality. As constraints are disposed, the substitution set tends
    to grow. When all constraints have been disposed, unification returns the final
    substitution set.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 算法从所有约束集合和空替换开始。每个约束只考虑一次并从集合中移除，因此原则上终止参数应该非常简单，但实际上会稍微棘手一些。随着约束的消失，替换集合倾向于增长。当所有约束都被处理完毕时，统一返回最终的替换集合。
- en: For a given constraint, the unifier examines the left-hand-side of the equation.
    If it is a variable, it is now ripe for elimination. The unifier adds the variable’s
    right-hand-side to the substitution and, to truly eliminate it, replaces all occurrences
    of the variable in the substitution with the this right-hand-side. In practice
    this needs to be implemented efficiently; for instance, using a mutational representation
    of these variables can avoid having to search-and-replace all occurrences. However,
    in a setting where we might need to backtrack (as we will, in the presence of
    unification [REF]), the mutational implementation has its own disadvantages.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的约束条件，统一器检查方程的左侧。如果它是一个变量，那么现在它已经准备好被消除了。统一器将变量的右侧加入到替换中，并且为了真正消除它，用该右侧替换替换中的变量的所有出现。在实践中，这需要高效地实现；例如，使用这些变量的可变表示可以避免不得不搜索和替换所有出现。然而，在我们可能需要回溯的情况下（正如我们将在统一存在的情况下所做的那样[REF]），可变实现有它自己的缺点。
- en: Do Now!
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: Did you notice the subtle error above?
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你注意到上面微妙的错误了吗？
- en: 'The subtle error is this. We said that the unifier eliminates the variable
    by replacing all instances of it in the substitution. However, that assumes that
    the right-hand-side does not contain any instances of the same variable. Otherwise
    we have a circular definition, and it becomes impossible to perform this particular
    substitution. For this reason, unifiers include a occurs check: a check for whether
    the same variable occurs on both sides and, if it does, decline to unify.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微妙的错误就在这里。我们说统一器通过替换替换中的所有实例来消除变量。然而，这假设右侧不包含相同变量的任何实例。否则我们就有了循环定义，并且执行这个特定的替换变得不可能。因此，统一器包括一个出现检查：检查是否在两边都出现相同的变量，如果是，则拒绝统一。
- en: Do Now!
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: Construct a term whose constraints would trigger the occurs check.
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构造一个触发发生检查的约束的项。
- en: Do you remember ω?
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得 ω 吗？
- en: Let us now consider the implementation of unification. It is traditional to
    denote the substitution by the Greek letter Θ.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑统一的实现。传统上用希腊字母 Θ 表示替换。
- en: '| (define-type-alias Subst (listof Substitution)) |'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义类型别名 替换 (替换列表)) |'
- en: '| (define-type Substitution |'
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义类型 替换 |'
- en: '|   [sub [var : Term] [is : Term]]) |'
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [sub [var : 项] [是 : 项]]) |'
- en: '|   |'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define (unify [cs : (listof Constraints)]) : Subst |'
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (统一 [cs : (约束列表)]) : 替换 |'
- en: '|   (unify/Θ cs empty)) |'
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (统一/Θ cs empty)) |'
- en: 'Let’s get the easy parts out of the way:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先把简单的部分处理掉：
- en: '[<unify/Θ>](#(elem._(chunk._~3cunify/~ce~98~3e~3a1))) ::='
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[<统一/Θ>](#(elem._(chunk._~3cunify/~ce~98~3e~3a1))) ::='
- en: '| (define (unify/Θ [cs : (listof Constraints)] [Θ : Subst]) : Subst |'
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (unify/Θ [cs : (约束列表)] [Θ : 替换]) : 替换 |'
- en: '|   (cond |'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (条件 |'
- en: '|     [(empty? cs) Θ] |'
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(空? cs) Θ] |'
- en: '|     [(cons? cs) |'
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(cons? cs) |'
- en: '|      (let ([l (eqCon-lhs (first cs))] |'
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (让 ([l (eqCon-lhs (第一个 cs))] |'
- en: '|            [r (eqCon-rhs (first cs))]) |'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            [r (eqCon-rhs (第一个 cs))]) |'
- en: '|        (type-case Term l |'
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        (类型-情况 项 l |'
- en: '|          [<unify/Θ-tVar-case>](#(elem._(chunk._~3cunify/~ce~98-t.Var-case~3e~3a1)))
    |'
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          [<统一/Θ-tVar-case>](#(elem._(chunk._~3cunify/~ce~98-t.Var-case~3e~3a1)))
    |'
- en: '|          [<unify/Θ-tExp-case>](#(elem._(chunk._~3cunify/~ce~98-t.Exp-case~3e~3a1)))
    |'
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          [<统一/Θ-tExp-case>](#(elem._(chunk._~3cunify/~ce~98-t.Exp-case~3e~3a1)))
    |'
- en: '|          [<unify/Θ-tNum-case>](#(elem._(chunk._~3cunify/~ce~98-t.Num-case~3e~3a1)))
    |'
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          [<统一/Θ-tNum-case>](#(elem._(chunk._~3cunify/~ce~98-t.Num-case~3e~3a1)))
    |'
- en: '|          [<unify/Θ-tArrow-case>](#(elem._(chunk._~3cunify/~ce~98-t.Arrow-case~3e~3a1)))))]))
    |'
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          [<统一/Θ-tArrow-case>](#(elem._(chunk._~3cunify/~ce~98-t.Arrow-case~3e~3a1)))))]))
    |'
- en: 'Now we’re ready for the heart of unification. We will depend on a function,
    extend+replace, with this signature: (Term Term Subst -> Subst). We expect this
    to perform the occurs test and, if it fails (i.e., there is no circularity), extends
    the substituion and replaces all existing instances of the first term with the
    second in the substitution. Similarly, we will assume the existence of lookup:
    (Term subst -> (optionof Term))'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备进行统一的核心部分。我们将依赖一个带有这个签名的函数，extend+replace：(Term Term Subst -> Subst)。我们期望它执行出现测试，如果失败（即没有循环），则扩展替换并在替换中替换第一个术语的所有现有实例为第二个术语。类似地，我们将假设lookup的存在：(Term
    subst -> (optionof Term))
- en: Exercise
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Define extend+replace and lookup.
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义extend+replace和lookup。
- en: 'If the left-hand of a constraint equation is a variable, we first look it up
    in the substitution. If it is present, we replace the current constraint with
    a new one; otherwise, we extend the substitution:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果约束方程的左侧是一个变量，我们首先在替换中查找它。如果存在，则用新约束替换当前约束；否则，我们扩展替换：
- en: '[<unify/Θ-tVar-case>](#(elem._(chunk._~3cunify/~ce~98-t.Var-case~3e~3a1)))
    ::='
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '[<统一/Θ-tVar-case>](#(elem._(chunk._~3cunify/~ce~98-t.Var-case~3e~3a1))) ::='
- en: '| [tVar (s) (type-case (optionof Term) (lookup l Θ) |'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [tVar (s) (type-case (optionof Term) (lookup l Θ) |'
- en: '|             [some (bound) |'
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [some (bound) |'
- en: '|                   (unify/Θ (cons (eqCon bound r) |'
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   (统一/Θ (cons (eqCon bound r) |'
- en: '|                                  (rest cs)) |'
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                  (rest cs)) |'
- en: '|                            Θ)] |'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            Θ)] |'
- en: '|             [none () |'
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [无 () |'
- en: '|                   (unify/Θ (rest cs) |'
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   (统一/Θ (rest cs) |'
- en: '|                            (extend+replace l r Θ))])] |'
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (extend+replace l r Θ))])] |'
- en: 'The same logic applies when it is an expression designator:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式标识符时，逻辑相同：
- en: '[<unify/Θ-tExp-case>](#(elem._(chunk._~3cunify/~ce~98-t.Exp-case~3e~3a1)))
    ::='
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '[<统一/Θ-tExp-case>](#(elem._(chunk._~3cunify/~ce~98-t.Exp-case~3e~3a1))) ::='
- en: '| [tExp (e) (type-case (optionof Term) (lookup l Θ) |'
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [tExp (e) (type-case (optionof Term) (lookup l Θ) |'
- en: '|             [some (bound) |'
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [some (bound) |'
- en: '|                   (unify/Θ (cons (eqCon bound r) |'
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   (统一/Θ (cons (eqCon bound r) |'
- en: '|                                  (rest cs)) |'
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                  (rest cs)) |'
- en: '|                            Θ)] |'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            Θ)] |'
- en: '|             [none () |'
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [无 () |'
- en: '|                   (unify/Θ (rest cs) |'
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   (统一/Θ (rest cs) |'
- en: '|                            (extend+replace l r Θ))])] |'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (extend+replace l r Θ))])] |'
- en: 'If it is a base type, such as a number, then we examine the right-hand side.
    There are four possibilities, for the four different kinds of terms:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是基本类型，比如数字，那么我们检查右侧。有四种可能性，对应四种不同类型的术语：
- en: If it is a number, then we have an equation that claims that the type num is
    the same as the type num, which is patently true. We can therefore ignore this
    constraint—<wbr>because it tells us nothing new—<wbr>and move on to the remainder.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是一个数字，那么我们有一个方程声称类型num与类型num相同，这显然是真实的。因此，我们可以忽略这个约束—<wbr>因为它没有告诉我们任何新信息—<wbr>并继续处理其余部分。
- en: You should, of course, question why such a constraint would have come about
    in the first place. Clearly, our constraint generator did not generate such constraints.
    However, a prior extension to the current substitution might have resulted in
    this situation. Indeed, in practice we will encounter several of these.
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，你应该质疑为什么这样一个约束会首次出现。显然，我们的约束生成器没有生成这样的约束。然而，当前替换的先前扩展可能导致这种情况。实际上，在实践中我们会遇到几种这样的情况。
- en: If it is a function type, then we clearly have a type error, because numeric
    and function types are disjoint. Again, we would never have generated such a constraint
    directly, but it must have resulted from a prior substitution.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是函数类型，则显然存在类型错误，因为数字类型和函数类型是不相交的。再次强调，我们永远不会直接生成这样的约束，但它必定是由先前的替换导致的。
- en: It could have been one of the two variable kinds. However, we have carefully
    arranged our constraint generator to never put these on the right-hand-side. Furthermore,
    substitution will not introduce them on the right-hand-side, either. Therefore,
    these two cases cannot occur.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能是两种变量种类之一。然而，我们已经仔细安排我们的约束生成器，永远不会将这些放在右侧。此外，替换也不会在右侧引入它们。因此，这两种情况不会发生。
- en: This results in the following code:[<unify/Θ-tNum-case>](#(elem._(chunk._~3cunify/~ce~98-t.Num-case~3e~3a1)))
    ::=
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下代码：[<统一/Θ-tNum-case>](#(elem._(chunk._~3cunify/~ce~98-t.Num-case~3e~3a1)))
    ::=
- en: '| [tNum () (type-case Term r |'
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [tNum () (type-case Term r |'
- en: '|            [tNum () (unify/Θ (rest cs) Θ)] |'
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            [tNum () (统一/Θ (rest cs) Θ)] |'
- en: '|            [else (error ''unify "number and something else")])] |'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            [else (error ''unify "数字和其他内容")])] |'
- en: Finally, we left with function types. Here the argument is almost exactly the
    same as for numeric types.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们留下了函数类型。在这里，论证几乎与数值类型完全相同。
- en: '[<unify/Θ-tArrow-case>](#(elem._(chunk._~3cunify/~ce~98-t.Arrow-case~3e~3a1)))
    ::='
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[<unify/Θ-tArrow-case>](#(elem._(chunk._~3cunify/~ce~98-t.Arrow-case~3e~3a1)))
    ::='
- en: '| [tArrow (d r) (type-case Term r |'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [tArrow (d r) (type-case Term r |'
- en: '|                 [tArrow (d2 r2) |'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [tArrow (d2 r2) |'
- en: '|                         (unify/Θ (cons (eqCon d d2) |'
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (unify/Θ (cons (eqCon d d2) |'
- en: '|                                        (cons (eqCon r r2) |'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                        (cons (eqCon r r2) |'
- en: '|                                              cs)) |'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                              cs)) |'
- en: '|                                  Θ)] |'
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                  Θ)] |'
- en: '|                 [else (error ''unify "arrow and something else")])] |'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [else (error ''unify "箭头和其他内容")])] |'
- en: Note that we do not always shrink the size of the constraint set, so a simple
    argument does not suffice for proving termination. Instead, we must make an argument
    based on the size of the constraint set, and on the size of the substitution (including
    the number of variables in it).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们并不总是缩小约束集的大小，因此简单的论证并不足以证明终止性。相反，我们必须基于约束集的大小以及替换的大小（包括其中的变量数量）进行论证。
- en: The algorithm above is very general in that it works for all sorts of type terms,
    not only numbers and functions. We have used numbers as a stand-in for all form
    of base types; functions, similarly, stand for all constructed types, such as
    listof and vectorof.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 上述算法非常通用，适用于各种类型术语，不仅仅是数字和函数。我们已经将数字用作所有基本类型的替代品；同样，函数代表所有构造类型，例如listof和vectorof。
- en: With this, we are done. Unification produces a substitution. We can now traverse
    the substitution and find the types of all the expressions in the program, then
    insert the type annotations accordingly. A theorem, which we will not prove here,
    dictates that the success of the above process implies that the program would
    have typed-checked, so we need not explicitly run the type-checker over this program.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们完成了。统一化产生了一个替换。我们现在可以遍历替换并找到程序中所有表达式的类型，然后相应地插入类型注释。一个定理，我们在这里不会证明，规定了上述过程的成功意味着程序将会通过类型检查，因此我们不需要在此程序上显式运行类型检查器。
- en: Observe, however, that the nature of a type error has now changed dramatically.
    Previously, we had a recursive-descent algorithm that walked a expressions using
    a type environment. The bindings in the type environment were programmer-declared
    types, and could hence be taken as (intended) authoritative specifications of
    types. As a result, any mismatch was blamed on the expressions, and reporting
    type errors was simple (and easy to understand). Here, however, a type error is
    a failure to notify. The unification failure is based on events that occur at
    the confluence of two smart algorithms—<wbr>constraint generation and unification—<wbr>and
    hence are not necessarily comprehensible to the programmer. In particular, the
    equational nature of these constraints means that the location reported for the
    error, and the location of the “true” error, could be quite far apart. As a result,
    producing better error messages remains an active research area.In practice the
    algorithm will maintain metadata on which program source terms were involved and
    probably on the history of unification, to be able to trace errors back to the
    source program.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，类型错误的性质现在发生了显著变化。以前，我们有一个递归下降算法，使用类型环境遍历表达式。类型环境中的绑定是程序员声明的类型，因此可以被视为（预期的）权威类型规范。因此，任何不匹配都归咎于表达式，并报告类型错误是简单的（易于理解）。然而，在这里，类型错误是一种未通知的失败。统一失败基于两个智能算法——约束生成和统一——发生的事件，因此不一定可以被程序员理解。特别是，这些约束的等式性质意味着报告错误的位置和“真正”错误的位置可能相距甚远。因此，生成更好的错误消息仍然是一个活跃的研究领域。在实践中，该算法将维护有关涉及的程序源项以及可能的统一历史的元数据，以便能够将错误追溯到源程序。
- en: Finally, remember that the constraints may not precisely dictate the type of
    all variables. If the system of equations is over-constrained, then we get clashes,
    resulting in type errors. If instead the system is under-constrained, that means
    we don’t have enough information to make definitive statements about all expressions.
    For instance, in the expression (lambda (x) x) we do not have enough constraints
    to indicate what the type of x, and hence of the entire expression, must be. This
    is not an error; it simply means that x is free to be any type at all. In other
    words, its type is “the type of x -> the type of x” with no other constraints.
    The types of these underconstrained identifiers are presented as type variables,
    so the above expression’s type might be reported as (’a -> ’a).
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，约束可能不会准确地规定所有变量的类型。如果方程组过于约束，那么我们就会得到冲突，从而导致类型错误。如果相反，系统过于约束，那么意味着我们没有足够的信息来对所有表达式做出明确的陈述。例如，在表达式(lambda
    (x) x)中，我们没有足够的约束来指示x的类型，因此也无法确定整个表达式的类型。这不是一个错误；它只是意味着x可以是任何类型。换句话说，它的类型是“x的类型
    -> x的类型”，没有其他约束。这些欠约束标识符的类型被表示为类型变量，因此上述表达式的类型可能被报告为（'a -> 'a）。
- en: 'The unification algorithm actually has a wonderful property: it automatically
    computes the most general types for an expression, also known as principal types.
    That is, any actual type the expression can have can be obtained by instantiating
    the inferred type variables with actual types. This is a remarkable result: in
    another example of computers beating humans, it says that no human can generate
    a more general type than the above algorithm can!'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 统一算法实际上具有一种奇妙的属性：它自动计算出表达式的最一般类型，也称为主类型。也就是说，表达式可以具有的任何实际类型都可以通过用实际类型实例化推断出的类型变量来获得。这是一个了不起的结果：在计算机战胜人类的另一个例子中，它表明没有人可以生成比上述算法更一般的类型！
- en: 15.3.2.3Let-Polymorphism
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2.3Let-多态
- en: 'Unfortunately, though these type variables are superficially similar to the
    polymorphism we had earlier [REF], they are not. Consider the following program:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管这些类型变量在表面上与我们之前拥有的多态性相似[REF]，但它们并不相同。考虑以下程序：
- en: '| (let ([id (lambda (x) x)]) |'
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([id (lambda (x) x)]) |'
- en: '|   (if (id true) |'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (if (id true) |'
- en: '|       (id 5) |'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (id 5) |'
- en: '|       (id 6))) |'
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (id 6))) |'
- en: 'If we write it with explicit type annotations, it type-checks:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用显式类型注释来写，它会通过类型检查：
- en: '| (if ((id boolean) true) |'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (if ((id boolean) true) |'
- en: '|     ((id number) 5) |'
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     ((id number) 5) |'
- en: '|     ((id number) 6)) |'
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     ((id number) 6)) |'
- en: However, if we use type inference, it does not! That is because the ’a’s in
    the type of id unify either with boolean or with number, depending on the order
    in which the constraints are processed. At that point id effectively becomes either
    a (boolean -> boolean) or (number -> number) function. At the use of id of the
    other type, then, we get a type error!
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们使用类型推断，情况就不一样了！这是因为类型id中的'a会与布尔值或数字统一，这取决于约束处理的顺序。在那一点上，id实际上会成为一个布尔值->布尔值函数或数字->数字函数。在使用另一种类型的id时，我们会得到一个类型错误！
- en: 'The reason for this is because the types we have inferred through unification
    are not actually polymorphic. This is important to remember: just because you
    type variables, you haven’t seen polymorphism! The type variables could be unified
    at the next use, at which point you end up with a mere monomorphic function. Rather,
    true polymorphism only obtains when you have true instantiation of type variables.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们通过统一推断的类型实际上并不是多态的。这一点很重要：仅仅因为你有类型变量，并不意味着你已经见识过多态性！类型变量可能在下次使用时被统一，而你最终得到的只是一个单纯的单态函数。相反，真正的多态性只有在类型变量真正实例化时才会产生。
- en: In languages with true polymorphism, then, constraint generation and unification
    are not enough. Instead, languages like ML, Haskell, and even our typed programming
    language, implement something colloquially called let-polymorphism. In this strategy,
    when a term with type variables is bound in a lexical context, the type is automatically
    promoted to be a quantified one. At each use, the term is effectively automatically
    instantiated.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有真正多态性的语言中，约束生成和统一不足以满足需求。相反，像ML、Haskell甚至我们的类型编程语言这样的语言，实现了俗称的 let-多态。在这种策略中，当一个带有类型变量的项在词法上下文中被绑定时，类型会自动提升为量化类型。在每次使用时，该项实际上会自动实例化。
- en: 'There are many implementation strategies that will accomplish this. The most
    naive (and unsatisfying) is to merely copy the code of the bound identifier; thus,
    each use of id above gets its own copy of (lambda (x) x), so each gets its own
    type variables. The first might get the type (’a -> ’a), the second (’b  -> ’b),
    the third (’c -> ’c), and so on. None of these type variables clash, so we get
    the effect of polymorphism. Obviously, this not only increases program size, it
    also does not work in the presence of recursion. However, it gives us insight
    into a better solution: instead of copying the code, why not just copy the type?
    Thus at each use, we create a renamed copy of the inferred type: id’s (’a -> ’a)
    becomes (’b -> ’b) at the first use, and so on, thus achieving the same effect
    as copying code but without its burdens. Because all these strategies effectively
    mimic copying code, however, they only work within a lexical context.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多实现策略可以完成这个任务。最简单（也是最不令人满意的）的方法是仅仅复制绑定标识符的代码；因此，以上每个 id 的使用都会得到自己的 (lambda
    (x) x) 的副本，因此每个都会有自己的类型变量。第一个可能得到类型 (’a -> ’a)，第二个 (’b -> ’b)，第三个 (’c -> ’c)，依此类推。这些类型变量都不会冲突，因此我们获得了多态的效果。显然，这不仅增加了程序的大小，而且在存在递归的情况下也无法工作。然而，这为我们提供了更好解决方案的见解：与其复制代码，为什么不只复制类型呢？因此，在每个使用处，我们都会创建推断类型的重命名副本：id
    的 (’a -> ’a) 在第一次使用时变为 (’b -> ’b)，依此类推，从而实现与复制代码相同的效果，但没有它的负担。然而，由于所有这些策略实际上都模拟了复制代码的行为，它们只在词法上下文中起作用。
- en: 15.3.3Union Types
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3 联合类型
- en: 'Suppose we want to construct a list of zoo animals, of which there are many
    kinds: armadillos, boa constrictors, and so on. Currently, we are forced to create
    a new datatype: “In Texas, there ain’t nothing in the middle of the road but a
    yellow line and dead armadillos.”—<wbr>Jim Hightower'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想构造一个动物园动物的列表，其中有许多种类：犰狳、蟒蛇等。目前，我们被迫创建一个新的数据类型：“在德克萨斯州，路中间什么也没有，只有一条黄线和死去的犰狳。”—<wbr>Jim
    Hightower
- en: '| (define-type Animal |'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义类型 Animal |'
- en: '|   [armadillo (alive? : boolean)] |'
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [犰狳 (alive? : boolean)] |'
- en: '|   [boa (length : number)]) |'
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [蟒蛇 (length : number)]) |'
- en: 'and make a list of these: (listof Animal). The type Animal therefore represents
    a “union” of armadillo and boa, except the only way to construct such unions is
    to make a new type every time: if we want to represent the union of animals and
    plants, we need'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 并制作这些的列表：(动物的列表)。因此，类型 Animal 表示了犰狳和蟒蛇的“联合”，除非唯一的构造这种联合的方式是每次都创建一个新类型：如果我们想表示动物和植物的联合，我们需要
- en: '| (define-type LivingThings |'
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义类型 LivingThings |'
- en: '|   [animal (a : Animal)] |'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [动物 (a : Animal)] |'
- en: '|   [plant (p : Plant)]) |'
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [植物 (p : Plant)]) |'
- en: so an actual animal is now one extra “level” deep. These datatypes are called
    tagged unions or discriminated unions, because we must introduce explicit tags
    (or discriminators), such as animal and plant, to tell them apart. In turn, a
    structure can only reside inside a datatype declaration; we have had to create
    datatypes with just one variant, such as
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个实际的动物现在多了一个额外的“级别”。这些数据类型被称为带标签的联合或可辨识联合，因为我们必须引入显式标签（或辨别符），如动物和植物，来将它们区分开来。反过来，一个结构体只能存在于数据类型声明内部；我们不得不创建只有一个变体的数据类型，比如
- en: '| (define-type Constraints |'
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义类型 Constraints |'
- en: '|   [eqCon (lhs : Term) (rhs : Term)]) |'
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [eqCon (lhs : Term) (rhs : Term)]) |'
- en: to hold the datatype, and everywhere we’ve had to use the type Constraints because
    eqCon is not itself a type, only a variant that can be distinguished at run-time.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 来保存数据类型，而我们到处都必须使用类型 Constraints，因为 eqCon 本身不是一种类型，它只是一个在运行时可以区分的变体。
- en: Either way, the point of a union type is to represent a disjunction, or “or”.
    A value’s type is one of the types in the union. A value usually belongs to only
    one of the types in the union, though this is a function of precisely how the
    union types are defined, whether there are rules for normalizing them, and so
    on.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，联合类型的目的是表示一个析取，或“或”。一个值的类型是联合中的一个类型。一个值通常只属于联合中的一个类型，尽管这取决于联合类型的定义方式，是否有规则来对其进行归一化，等等。
- en: 15.3.3.1Structures as Types
  id: totrans-604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3.1 结构体作为类型
- en: A natural reaction to this might be, why not lift this restriction? Why not
    allow each structure to exist on its own, and define a type to be a union of some
    collection of structures? After all, in languages ranging from C to Racket, programmers
    can define stand-alone structures without having to wrap them in some other type
    with a tag constructor! For instance, in raw Racket, we can write
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的自然反应可能是，为什么不取消这个限制？为什么不允许每个结构独立存在，并定义一个类型为一些结构集合的联合？毕竟，在从C到Racket的各种语言中，程序员可以定义独立的结构，而无需将它们包装在带有标签构造函数的其他类型中！例如，在原始的Racket中，我们可以写
- en: '| (struct armadillo (alive?)) |'
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (struct armadillo (alive?)) |'
- en: '| (struct boa (length)) |'
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (struct boa (length)) |'
- en: and a comment that says
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 并附上一条注释
- en: '| ;; An Animal is either |'
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;; 一个动物要么是 |'
- en: '| ;; - (armadillo <boolean>) |'
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;; - (armadillo <boolean>) |'
- en: '| ;; - (boa <number>) |'
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;; - (boa <number>) |'
- en: 'but without enforced static types, the comparison is messy. However, we can
    more directly compare with Typed Racket, a typed form of Racket that is built
    into DrRacket. Here is the same typed code:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 但是没有强制的静态类型，比较会变得混乱。然而，我们可以更直接地与Typed Racket进行比较，这是Racket的一种带类型的形式，内置于DrRacket中。以下是相同的带类型代码：
- en: '| #lang [typed/racket](http://docs.racket-lang.org/ts-reference/index.html)
    |'
  id: totrans-613
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| #lang [typed/racket](http://docs.racket-lang.org/ts-reference/index.html)
    |'
- en: '|   |'
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (struct: armadillo ([alive? : Boolean])) |'
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (struct: armadillo ([alive? : Boolean])) |'
- en: '| (struct: boa ([length : Real])) ;; feet |'
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (struct: boa ([length : Real])) ;; feet |'
- en: 'We can now define functions that consume values of type boa without any reference
    to armadillos:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义消耗蟒蛇类型值的函数，而无需提及犰狳：
- en: '| ;; http://en.wikipedia.org/wiki/Boa_constrictor#Size_and_weight |'
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ;; http://en.wikipedia.org/wiki/Boa_constrictor#Size_and_weight |'
- en: '| (define: (big-one? [b : boa]) : Boolean |'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define: (big-one? [b : boa]) : Boolean |'
- en: '|   (> (boa-length b) 8)) |'
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (> (boa-length b) 8)) |'
- en: 'In fact, if we apply this function to any other type, including an armadillo—<wbr>(big-one?
    (armadillo true))—<wbr>we get a static error. This is because armadillos are no
    more related to boas than numbers or strings are.Of course, we can still define
    a union of these types:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们将这个函数应用于任何其他类型，包括犰狳—<wbr>(big-one? (armadillo true))—<wbr>我们会得到一个静态错误。这是因为犰狳与蟒蛇或数字或字符串一样没有关联。当然，我们仍然可以定义这些类型的联合：
- en: '| (define-type Animal (U armadillo boa)) |'
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Animal (U armadillo boa)) |'
- en: 'and functions over it:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 并对其进行函数操作：
- en: '| (define: (safe-to-transport? [a : Animal]) : Boolean |'
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define: (safe-to-transport? [a : Animal]) : Boolean |'
- en: '|   (cond |'
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (cond |'
- en: '|     [(boa? a) (not (big-one? a))] |'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(boa? a) (not (big-one? a))] |'
- en: '|     [(armadillo? a) (armadillo-alive? a)])) |'
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(armadillo? a) (armadillo-alive? a)])) |'
- en: Whereas before we had one type with two variants, now we have three types. It
    just so happens that two of the types form a union of convenience to define a
    third.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 以前我们有一个具有两个变体的类型，现在我们有三种类型。碰巧两种类型形成了一个便利的联合来定义第三种类型。
- en: 15.3.3.2Untagged Unions
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3.2未标记联合
- en: 'It might appear that we still need to have discriminative tags, but we don’t.
    In languages with union types, the effect of the optionof type constructor is
    often obtained by combining the intended return type with a disjoint one representing
    failure or noneness. For instance, here is the moral equivalent of (optionof number):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们仍然需要有区分性的标签，但实际上不需要。在具有联合类型的语言中，选项类型构造函数的效果通常通过将预期的返回类型与表示失败或无效的不同类型结合来实现。例如，这是（number的选项）的道德等价物：
- en: '| (define-type MaybeNumber (U Number Boolean)) |'
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type MaybeNumber (U Number Boolean)) |'
- en: 'For that matter, Boolean may itself be a union of True and False, as it is
    in Typed Racket, so a more accurate simulation of the option type would be:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，布尔值本身可能是True和False的联合，就像在Typed Racket中一样，因此选项类型的更准确的模拟可能是：
- en: '| (define-type MaybeNumber (U Number False)) |'
  id: totrans-633
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type MaybeNumber (U Number False)) |'
- en: More generally, we could define
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，我们可以定义
- en: '| (struct: none ()) |'
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (struct: none ()) |'
- en: '| (define-type (Maybeof T) (U T none)) |'
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type (Maybeof T) (U T none)) |'
- en: 'which would work for all types, because none is a new, distinct type that cannot
    be confused for any other. This gives us the same benefit as the optionof type,
    except the value we want is not buried one level deep inside a some structure,
    but is rather available immediately. For instance, consider member, which has
    this Typed Racket type:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这对所有类型都适用，因为none是一个新的、独特的类型，��会与任何其他类型混淆。这给我们带来了与选项类型相同的好处，只是我们想要的值不是埋在某个结构的一级深处，而是立即可用。例如，考虑member，它具有以下Typed
    Racket类型：
- en: '| (All (a) (a (Listof a) -> (U False (Listof a)))) |'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (All (a) (a (Listof a) -> (U False (Listof a)))) |'
- en: 'If the element is not found, member returns false. Otherwise, it returns the
    list starting from the element onward (i.e., the first element of the list will
    be the desired element):'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到元素，member返回false。否则，它将返回从该元素开始的列表（即，列表的第一个元素将是所需的元素）：
- en: '| > (member 2 (list 1 2 3)) |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| > (member 2 (list 1 2 3)) |'
- en: '| ''(2 3) |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| ''(2 3) |'
- en: To convert this to use Maybeof, we can write
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为使用Maybeof，我们可以编写
- en: '| (define: (t) (in-list? [e : t] [l : (Listof t)]) : (Maybeof (Listof t)) |'
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define: (t) (in-list? [e : t] [l : (Listof t)]) : (Maybeof (Listof t)) |'
- en: '|   (let ([v (member e l)]) |'
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([v (member e l)]) |'
- en: '|     (if v |'
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (if v |'
- en: '|         v |'
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         v |'
- en: '|         (none)))) |'
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (none)))) |'
- en: which, if the element is not found, returns the value (none), but if it is found,
    still returns a list
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到元素，则返回值(none)，但如果找到，则仍然返回一个列表
- en: '| > (in-list? 2 (list 1 2 3)) |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| > (in-list? 2 (list 1 2 3)) |'
- en: '| ''(2 3) |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| ''(2 3) |'
- en: so that there is no need to remove the list from a some wrapper.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无需从某个包装器中删除列表。
- en: 15.3.3.3Discriminating Untagged Unions
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3.3区分未标记的联合
- en: It’s one thing to put values into unions; we have to also consider how to take
    them out, in a well-typed manner. In our ML-like type system, we use a stylized
    notation—<wbr>type-case in our language, pattern-matching in ML—<wbr>to identify
    and pull apart the pieces. In particular, when we write
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 将值放入联合是一回事；我们还必须考虑如何以良好类型的方式取出它们。在我们的类似ML的类型系统中，我们使用一种风格化的符号—<wbr>在我们的语言中是type-case，在ML中是模式匹配—<wbr>来识别和分解这些部分。特别是，当我们写
- en: '| (define (safe-to-transport? [a : Animal]) : boolean |'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (safe-to-transport? [a : Animal]) : boolean |'
- en: '|   (type-case Animal a |'
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case Animal a |'
- en: '|     [armadillo (a?) a?] |'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [armadillo (a?) a?] |'
- en: '|     [boa (l) (not (big-one? l))])) |'
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [boa (l) (not (big-one? l))])) |'
- en: the type of a remains the same in the entire expression. The identifiers a?
    and l are bound to a boolean and numeric value, respectively, and big-one? must
    now be written to consume those types, not armadillo and boa. Put in different
    terms, we cannot have a function big-one? that consumes boas, because there is
    no such type.In contrast, with union types, we do have the boa type. Therefore,
    we follow the principle that the act of asking predicates of a value narrows the
    type. For instance, in the cond case
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: a的类型在整个表达式中保持不变。标识符a?和l分别绑定到布尔值和数值，big-one?现在必须编写以消耗这些类型，而不是armadillo和boa。换句话说，我们不能有一个消耗boas的函数big-one?，因为没有这种类型。相反，对于联合类型，我们确实有boa类型。因此，我们遵循这样一个原则，即向值询问谓词会缩小类型。例如，在cond情况中
- en: '| [(boa? a) (not (big-one? a))] |'
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(boa? a) (not (big-one? a))] |'
- en: though a begins as type Animal, after it passes the boa? test, the type checker
    is expected to narrow its type to just the boa branch, so that the application
    of big-one? is well-typed. In turn, in the rest of the conditional its type is
    not boa—<wbr>in this case, that leaves only one possibility, armadillo. This puts
    greater pressure on the type-checker’s ability to test and recognize certain patterns—<wbr>known
    as if-splitting—<wbr>without which it would be impossible to program with union
    types; but it can always default to recognizing just those patterns that the ML-like
    system would have recognized, such as pattern-matching or type-case.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然a最初是Animal类型，但在通过boa?测试后，类型检查器应将其类型缩小为仅boa分支，以便big-one?的应用是良好类型的。反过来，在条件的其余部分中，它的类型不是boa—<wbr>在这种情况下，只剩下一种可能性，即armadillo。这对类型检查器测试和识别某些模式的能力施加了更大的压力—<wbr>称为if-splitting—<wbr>没有这些模式，使用联合类型将是不可能的；但它总是可以默认识别仅那些类似ML系统将识别的模式，例如模式匹配或type-case。
- en: 15.3.3.4Retrofitting Types
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3.4类型改造
- en: It is unsurprising that Typed Racket uses union types. They are especially useful
    when retrofitting types onto existing programming languages whose programs were
    not defined with an ML-like type discipline in mind, such as in scripting languages.
    A common principle of such retrofitted types is to statically catch as many dynamic
    exceptions as possible. Of course, the checker must ultimately reject some programs,Unless
    it implements an interesting idea called soft typing, which rejects no programs
    but provides information about points where the program would not have been typeable.
    and if it rejects too many programs that would have run without an error, developers
    are unlikely to adopt it. Because these programs were written without type-checking
    in mind, the type checker may therefore need to go to heroic lengths to accept
    what are considered reasonable idioms in the language.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 并不奇怪 Typed Racket 使用联合类型。它们在为现有编程语言添加类型时特别有用，这些编程语言的程序并没有考虑到类似 ML 的类型纪律，比如脚本语言。这种后续添加类型的常见原则是尽可能静态地捕获尽量多的动态异常。当然，类型检查器最终必须拒绝一些程序，除非它实现了一个有趣的称为软类型的想法，它不会拒绝任何程序，但会提供有关程序无法被类型化的点的信息。如果它拒绝了太多本来可以正常运行的程序，开发者就不太可能采用它。因为这些程序是在没有考虑类型检查的情况下编写的，所以类型检查器可能需要采取英雄式的措施来接受在语言中被认为是合理习惯的东西。
- en: 'Consider the following JavaScript function:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的 JavaScript 函数：
- en: '| var slice = function (arr, start, stop) { |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| var slice = function (arr, start, stop) { |'
- en: '|   var result = []; |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '|   var result = []; |'
- en: '|   for (var i = 0; i <= stop - start; i++) { |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '|   for (var i = 0; i <= stop - start; i++) { |'
- en: '|     result[i] = arr[start + i]; |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '|     result[i] = arr[start + i]; |'
- en: '|   } |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '|   } |'
- en: '|   return result; |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '|   return result; |'
- en: '| } |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: It consumes an array and two indices, and produces the sub-array between those
    indices. For instance, slice([5, 7, 11, 13], 0, 2) produces [5, 7, 11].In JavaScript,
    however, developers are free to leave out any or all trailing arguments to a function.
    Every elided argument is given a special value, undefined, and it is up to the
    function to cope with this. For instance, a typical implementation of splice would
    let the user drop the third argument; the following definition
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个数组和两个索引，并生成这些索引之间的子数组。例如，slice([5, 7, 11, 13], 0, 2) 产生 [5, 7, 11]。然而在
    JavaScript 中，开发者可以自由地忽略函数的任意尾随参数。每个省略的参数都被赋予一个特殊值，undefined，并且由函数来处理这种情况。例如，splice
    的典型实现会让用户省略第三个参数；下面是定义
- en: '| var slice = function (arr, start, stop) { |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| var slice = function (arr, start, stop) { |'
- en: '|   if (typeof stop == "undefined") |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '|   if (typeof stop == "undefined") |'
- en: '|     stop = arr.length - 1; |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '|     stop = arr.length - 1; |'
- en: '|   var result = []; |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '|   var result = []; |'
- en: '|   for (var i = 0; i <= stop - start; i++) { |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '|   for (var i = 0; i <= stop - start; i++) { |'
- en: '|     result[i] = arr[start + i]; |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '|     result[i] = arr[start + i]; |'
- en: '|   } |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '|   } |'
- en: '|   return result; |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '|   return result; |'
- en: '| } |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: 'automatically returns the subarray until the end of the array: thus, slice([5,
    7, 11, 13], 2) returns [11, 13].In Typed JavaScript,Built at Brown by Arjun Guha
    and others. See [our Web site](http://www.jswebtools.org/). a programmer can explicitly
    indicate a function’s willingness to accept fewer arguments by giving a parameter
    the type U Undefined, giving it the type'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 自动返回数组直到末尾的子数组：因此，slice([5, 7, 11, 13], 2) 返回 [11, 13]。在 Typed JavaScript 中，在
    Brown 大学由 Arjun Guha 和其他人构建。请参见 [我们的网站](http://www.jswebtools.org/)。程序员可以通过给参数赋予类型
    U Undefined 来显式指示函数接受更少的参数，从而将其类型定义为
- en: '| ∀ t : (Array[t] * Int * (Int U Undefined) -> Array[t]) |'
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ∀ t : (Array[t] * Int * (Int U Undefined) -> Array[t]) |'
- en: In principle, this means there is a potential type error at the expression stop
    - start, because stop may not be a number. However, the assignment to stop sets
    it to a numeric type precisely when it was elided by the user. In other words,
    in all control paths, stop will eventually have a numeric type before the subtraction
    occurs, so this function is well-typed. Of course, this requires the type-checker
    to be able to reason about both control-flow (through the conditional) and state
    (through the assignment) to ensure that this function is well-typed; but Typed
    JavaScript can, and can thus bless functions such as this.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 从原理上讲，这意味着表达式 stop - start 可能存在潜在的类型错误，因为 stop 可能不是一个数字。然而，对 stop 的赋值在用户省略时将其设置为数值类型。换句话说，在所有控制路径中，在减法发生之前，stop
    最终都会具有数值类型，因此此函数是类型正确的。当然，这要求类型检查器能够推理控制流（通过条件语句）和状态（通过赋值语句），以确保此函数是类型正确的；但是 Typed
    JavaScript 可以做到这一点，因此可以为此类函数提供保证。
- en: 15.3.3.5Design Choices
  id: totrans-684
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3.5 设计选择
- en: In languages with union types, it is common to have
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 使用联合类型的语言，通常会有
- en: Stand-alone structure types (often represented using classes), rather than datatypes
    with variants.
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的结构类型（通常使用类表示），而不是具有变体的数据类型。
- en: Ad hoc collections of structures to represent particular types.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时收集结构以表示特定类型。
- en: The use of sentinel values to represent failure.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用哨兵值表示失败。
- en: To convert programs written in this style to an ML-like type discipline would
    be extremely onerous. Therefore, many retrofitted type systems adopt union types
    to ease the process of typing.Of the three properties above, the first seems morally
    neutral, but the other two warrant more discussion. We will address them in reverse
    order.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 将按照这种风格编写的程序转换为类似 ML 的类型规则将是非常繁重的。因此，许多后期添加的类型系统采用联合类型来简化类型化过程。在上述三个属性中，第一个属性似乎是道德上中立的，但其他两个值得更多讨论。我们将逆序讨论它们。
- en: Let’s tackle sentinels first. In many cases, sentinels ought to be replaced
    with exceptions, but in many languages, exceptions can be very costly. Thus, developers
    prefer to make a distinction between truly exceptional situations—<wbr>that ought
    not occur—<wbr>and situations that are expected in the normal course of operation.
    Checking whether an element is in a list and failing to find it is clearly in
    the latter category (if we already knew the element was or wasn’t present, there
    would be no need to run this predicate). In the latter case, using sentinels is
    reasonable.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们先来解决哨兵问题。在许多情况下，哨兵应该被异常替代，但在许多语言中，异常可能非常昂贵。因此，开发人员更喜欢区分真正异常的情况——这种情况不应该发生——和在正常操作过程中预期到的情况。检查一个元素是否在列表中，并且找不到它显然属于后一种情况（如果我们已经知道元素是否存在，那么就不需要运行此谓词）。在后一种情况下，使用哨兵是合理的。
- en: However, we must square this with the observation that failure to check for
    exceptional sentinel values is a common source of error—<wbr>and indeed, security
    flaws—<wbr>in C programs. This is easy to reconcile. In C, the sentinel is of
    the same type (or at least, effectively the same type) as the regular return value,
    and furthermore, there are no run-time checks. Therefore, the sentinel can be
    used as a legitimate value without a type error. As a result, a sentinel of 0
    can be treated as an address into which to allocate data, thus potentially crashing
    the system. In contrast, our sentinel is of a truly new type that cannot be used
    in any computation. We can easily reason about this by observing that no existing
    functions in our language consume values of type none.
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们必须将这一观察结果与未检查异常哨兵值的事实相协调，这是 C 程序中错误的常见源头，甚至是安全漏洞。这很容易协调。在 C 中，哨兵与常规返回值的类型相同（或至少在效果上相同），而且没有运行时检查。因此，哨兵可以作为合法值使用，而不会产生类型错误。因此，哨兵的值为
    0 可以被视为一个地址，用于分配数据，从而可能导致系统崩溃。相比之下，我们的哨兵是一个全新类型，不能用于任何计算中。我们可以通过观察到我们的语言中不存在消耗
    none 类型值的现有函数来轻松地理解这一点。
- en: Setting aside the use of “ad hoc”, which is pejorative, are different groupings
    of a set of structures a good idea? In fact, such groupings occur even in programs
    using an ML-like discipline, when programmers want to carve different sub-universes
    of a larger one. For instance, ML programmers use a type like
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂时搁置“临时”的使用，这是带有贬义的，不同的结构集合是一个好主意吗？实际上，即使在使用类似 ML 的学科的程序中，当程序员想要划分一个较大集合的不同子宇宙时，这种分组也会发生。例如，ML
    程序员使用类似于
- en: '| (define-type SExp |'
  id: totrans-693
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type SExp |'
- en: '|   [numSexp (n : number)] |'
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numSexp (n : number)] |'
- en: '|   [strSexp (s : string)] |'
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [strSexp (s : string)] |'
- en: '|   [listSexp (l : (listof SExp))]) |'
  id: totrans-696
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [listSexp (l : (listof SExp))]) |'
- en: to represent s-expressions. If a function now operates on just some subset of
    these terms—<wbr>say just numbers and lists of numbers—<wbr>they must create a
    fresh type, and convert values between the two types even though their underlying
    representations are essentially identical. As another example, consider the set
    of CPS expressions. This is clearly a subset of all possible expressions, but
    if we were to create a fresh datatype for it, we would not be able to use any
    existing programs that process expressions—<wbr>such as the interpreter.
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于表示 s 表达式。如果一个函数现在只对这些术语的某个子集进行操作——比如只对数字和数字列表进行操作——他们必须创建一个新类型，并在这两种类型之间转换值，即使它们的底层表示基本上是相同的。另一个例子是考虑
    CPS 表达式集。这显然是所有可能表达式的一个子集，但如果我们为它创建一个新的数据类型，我们将无法使用任何处理表达式的现有程序——比如解释器。
- en: In other words, union types appear to be a reasonable variation on the ML-style
    type system we have seen earlier. However, even within union types there are design
    variations, and these have consequences. For instance, can the type system create
    new unions, or are user-defined (and named) unions permitted? That is, can an
    expression like this
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，联合类型似乎是我们之前见过的 ML 风格类型系统的一个合理变体。然而，即使在联合类型中也存在设计变化，这些变化会产生后果。例如，类型系统能否创建新的联合，或者是否允许用户定义（并命名）联合？也就是说，像这样的表达式是否允许
- en: '| (if (phase-of-the-moon) |'
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (if (phase-of-the-moon) |'
- en: '|     10 |'
  id: totrans-700
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     10 |'
- en: '|     true) |'
  id: totrans-701
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     true) |'
- en: 'be allowed to type (to (U Number Boolean)), or is it a type error to introduce
    unions that have not previously been named and explicitly identified? Typed Racket
    provides the former: it will construct truly ad hoc unions. This is arguably better
    for importing existing code into a typed setting, because it is more flexible.
    However, it is less clear whether this is a good design for writing new code,
    because unions the programmer did not intend can occur and there is no way to
    prevent them. This offers an unexplored corner in the design space of programming
    languages.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 允许类型（到（U Number Boolean）），还是引入以前未命名和显式标识的联合是类型错误？Typed Racket 提供了前者：它将构造真正的特设联合。这对于将现有代码导入到类型设置中可能更灵活，因为它更加灵活。然而，是否这是编写新代码的良好设计并不清楚，因为程序员不打算的联合可能会发生，而且没有办法阻止它们。这为编程语言设计空间中的一个未探索的角落提供了可能性。
- en: 15.3.4Nominal Versus Structural Systems
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.4 命名型与结构型系统
- en: In our initial type-checker, two types were considered equivalent if they had
    the same structure. In fact, we offered no mechanism for naming types at all,
    so it is not clear what alternative we had.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最初的类型检查器中，如果两种类型具有相同的结构，则认为它们是等价的。实际上，我们根本没有提供命名类型的机制，因此不清楚我们还有什么其他选择。
- en: Now consider Typed Racket. A developer can write
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 Typed Racket。一个开发者可以编写
- en: '| (define-type NB1 (U Number Boolean)) |'
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type NB1 (U Number Boolean)) |'
- en: '| (define-type NB2 (U Number Boolean)) |'
  id: totrans-707
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type NB2 (U Number Boolean)) |'
- en: followed by
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 随后
- en: '| (define: v : NB1 5) |'
  id: totrans-709
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define: v : NB1 5) |'
- en: Suppose the developer also defines the function
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 假设开发者还定义了函数
- en: '| (define: (f [x : NB2]) : NB2 x) |'
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define: (f [x : NB2]) : NB2 x) |'
- en: 'and tries to apply f to v, i.e., (f v): should this application type or not?'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 并尝试将 f 应用于 v，即 (f v)：此应用是否应该进行类型检查？
- en: There are two perfectly reasonable interpretations. One is to say that v was
    declared to be of type NB1, which is a different name than NB2, and hence should
    be considered a different type, so the above application should result in an error.
    Such a system is called nominal, because the name of a type is paramount for determining
    type equality.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种完全合理的解释。一种是说 v 被声明为 NB1 类型，这是一个不同于 NB2 的名称，因此应该被视为不同的类型，因此上述应用应该导致错误。这样的系统被称为命名型，因为类型的名称对于确定类型相等性至关重要。
- en: In contrast, another interpretation is that because the structure of NB1 and
    NB2 are identical, there is no way for a developer to write a program that behaves
    differently on values of these two types, so these two types should be considered
    identical.If you want to get especially careful, you would note that there is
    a difference between being considered the same and actually being the same. We
    won’t go into this issue here, but consider the implication for a compiler writer
    choosing representations of values, especially in a language that allows run-time
    inspection of the static types of values. Such a type system is called structural,
    and would successfully type the above expression. (Typed Racket follows a structural
    discipline, again to reduce the burden of importing existing untyped code, which—<wbr>in
    Racket—<wbr>is usually written with a structural interpretation in mind. In fact,
    Typed Racket not only types (f v), it prints the result as having type NB1, despite
    the return type annotation on f!)
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，另一种解释是因为 NB1 和 NB2 的结构相同，所以开发者无法编写在这两种类型的值上行为不同的程序，因此这两种类型应该被视为相同。如果你想特别小心，你会注意到被认为相同和实际上相同之间存在区别。我们不会在这里讨论这个问题，但考虑一下对于编译器编写者选择值的表示方式的影响，尤其是在一种允许运行时检查值的静态类型的语言中。这样的类型系统被称为结构化的，并且会成功地为上述表达式提供类型。（Typed
    Racket 遵循结构化原则，再次减轻了导入现有的非类型代码的负担，这些代码——<wbr>在 Racket 中——<wbr>通常是以结构化解释为前提编写的。实际上，Typed
    Racket 不仅为 (f v) 提供了类型，它还将结果打印为具有类型 NB1，尽管在 f 上有返回类型的注释！）
- en: 'The difference between nominal and structural typing is most commonly contentious
    in object-oriented languages, and we will return to this issue briefly later [REF].
    However, the point of this section is to illustrate that these questions are not
    intrinsically about “objects”. Any language that permits types to be named—<wbr>as
    all must, for programmer sanity—<wbr>must contend with this question: is naming
    merely a convenience, or are the choices of names intended to be meaningful? Choosing
    the former answer leads to structural typing, while choosing the latter leads
    down the nominal path.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 名义类型和结构类型之间的区别在面向对象的语言中最常见的是有争议的，我们稍后会简要回到这个问题上[REF]。然而，本节的重点是说明这些问题并不本质上是关于“对象”的。任何允许类型被命名的语言——<wbr>正如所有的语言都必须，为了程序员的理智——<wbr>都必须处理这个问题：命名只是一种便利，还是选择的名称打算具有意义？选择前者的答案导致结构类型，而选择后者则走上了名义路径。
- en: 15.3.5Intersection Types
  id: totrans-716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.5 交集类型
- en: Since we’ve just explored union types, you must naturally wonder whether there
    are also intersection types. Indeed there are.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们刚刚探讨了联合类型，你自然会想知道是否也有交集类型。的确有。
- en: 'If a union type means that a value (of that type) belongs to one of the types
    in the union, an intersection type clearly means the value belongs to all the
    types in the intersection: a conjunction, or “and”. This might seem strange: how
    can a value belong to more than one type?'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 如果联合类型意味着一个值（该类型的值）属于联合中的一个类型，则交集类型明确意味着该值属于交集中所有类型：一个连接词，或者“与”。这可能看起来很奇怪：一个值如何属于多个类型？
- en: As a concrete answer, consider overloaded functions. For instance, in some languages
    + operates on both numbers and strings; given two numbers it produces a number,
    and given two strings it produces a string. In such a language, what is the proper
    type for +? It is not (number number -> number) alone, because that would reject
    its use on strings. By the same reasoning, it is not (string string -> string)
    alone either. It is not even
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的答案，考虑重载函数。例如，在某些语言中，+可同时作用于数字和字符串；给定两个数字，它会产生一个数字，给定两个字符串，它会产生一个字符串。在这样的语言中，+的适当类型是什么？它不仅仅是（number
    number -> number），因为这将拒绝其在字符串上的使用。按照同样的推理，它也不是（string string -> string）单独的。甚至不是
- en: '| (U (number number -> number) |'
  id: totrans-720
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （U （number number -> number） |'
- en: '|    (string string -> string)) |'
  id: totrans-721
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    （string string -> string））|'
- en: 'because + is not just one of these functions: it truly is both of them. We
    could ascribe the type'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 + 不仅仅是这些函数中的一个：它确实是它们两个。我们可以指定类型
- en: '| ((number U string) (number U string) -> (number U string)) |'
  id: totrans-723
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((number U string) (number U string) -> (number U string)) |'
- en: reflecting the fact that each argument, and the result, can be only one of these
    types, not both. Doing so, however, leads to a loss of precision.Do Now!
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 反映了每个参数和结果只能是这些类型中的一个，而不是两者兼而有之。然而，这样做会导致精度损失。现在做！
- en: In what way does this type lose precision?
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种类型在哪些方面失去了精度？
- en: Observe that with this type, the return type on all invocations is (number U
    string). Thus, on every return we must distinguish beween numeric and string returns,
    or else we will get a type error. Thus, even though we know that if given two
    numeric arguments we will get a numeric result, this information is lost to the
    type system.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于此类型，在所有调用中返回类型都是（number U string）。因此，每次返回时，我们必须区分数值和字符串返回，否则将出现类型错误。因此，即使我们知道如果给定两个数字参数，我们将得到一个数字结果，这些信息也会丢失到类型系统中。
- en: More subtly, this type permits each argument’s type to be chosen independently
    of the other. Thus, according to this type, the invocation (+ 3 "x") is perfectly
    valid (and produces a value of type (number U string)). But of course the addition
    operation we have specified is not defined for these inputs at all!
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 更微妙的是，这种类型允许每个参数的类型独立选择。因此，根据这种类型，调用（+ 3 "x"）是完全有效的（并产生类型为（number U string）的值）。但当然，我们指定的加法运算对这些输入根本没有定义！
- en: Thus the proper type to ascribe this form of addition is
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，适当的类型来描述这种加法形式是
- en: '| (∧ (number number -> number) |'
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (∧ （number number -> number） |'
- en: '|    (string string -> string)) |'
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    （string string -> string））|'
- en: where ∧ should be reminiscent of the conjunction operator in logic. This permits
    invocation with two numbers or two strings, but nothing else. An invocation with
    two numbers has a numeric result type; one with two strings has a string result
    type; and nothing else. This corresponds precisely to our intended behavior for
    overloading (sometimes also called ad hoc polymorphism). Observe that this only
    handles a finite number of overloaded cases.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 其中∧应该让人联想到逻辑中的合取运算符。这允许使用两个数字或两个字符串进行调用，但不能使用其他类型。使用两个数字进行调用会得到一个数字结果类型；使用两个字符串进行调用会得到一个字符串结果类型；其他情况则不行。这与我们对重载（有时也称为特定多态）的预期行为完全一致。请注意，这只处理有限数量的重载情况。
- en: 15.3.6Recursive Types
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.6递归类型
- en: Now that we’ve seen union types, it pays to return to our original recursive
    datatype formulation. If we accept the variants as type constructors, can we write
    the recursive type as a union over these? For instance, returning to BTnum, shouldn’t
    we be able to describe it as equivalent to
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了联合类型，回到我们最初的递归数据类型的制定。如果我们接受变体作为类型构造函数，我们能否将递归类型写成对这些变体的联合？例如，回到BTnum，我们不应该能够将其描述为等价于
- en: '| ((BTmt) U (BTnd number BTnum BTnum)) |'
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((BTmt) U (BTnd number BTnum BTnum)) |'
- en: thereby showing that BTmt is a zero-ary constructor, and BTnd takes three parameters?
    Except, what are the types of those three parameters? In the type we’ve written
    above, BTnum is either built into the type language (which is unsatisfactory)
    or unbound. Perhaps we mean
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 从而表明BTmt是一个零元构造函数，BTnd需要三个参数？但是，这三个参数的类型是什么？在我们上面写的类型中，BTnum要么是内置于类型语言中（这是不令人满意的），要么是未绑定的。也许我们的意思是
- en: '| BTnum = ((BTmt) U (BTnd number BTnum BTnum)) |'
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTnum = ((BTmt) U (BTnd number BTnum BTnum)) |'
- en: Except now we have an equation that has no obvious solution (remember ω?).This
    situation should be familiar from recursion in values [REF]. Then, we invented
    a recursive function constructor (and showed its implementation) to circumvent
    this problem. We similarly need a recursive type constructor. This is conventionally
    called μ (the Greek letter “mu”). With it, we would write the above type as
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在我们有一个没有明显解决方案的等式（记得ω吗？）。这种情况应该是递归值中熟悉的。然后，我们发明了一个递归函数构造函数（并展示了其实现）来规避这个问题。我们同样需要一个递归类型构造函数。这通常被称为μ（希腊字母“mu”）。有了它，我们可以将上面的类型写成
- en: '| μ BTnum : ((BTmt) U (BTnd number BTnum BTnum)) |'
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| μ BTnum : ((BTmt) U (BTnd number BTnum BTnum)) |'
- en: 'μ is a binding construct; it binds BTnum to the entire type written after it,
    including the recursive binding of BTnum itself. In practice, of course, this
    entire recursive type is the one we wish to call BTnum:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: μ是一个绑定构造；它将BTnum绑定到其后的整个类型，包括BTnum本身的递归绑定。实际上，这整个递归类型就是我们希望称为BTnum的类型：
- en: '| BTnum = μ BTnum : ((BTmt) U (BTnd number BTnum BTnum)) |'
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTnum = μ BTnum : ((BTmt) U (BTnd number BTnum BTnum)) |'
- en: 'Though this looks like a circular definition, notice that the name BTnum on
    the right does not depend on the one to the left of the equation: i.e., we could
    rewrite this as'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像是一个循环定义，但请注意等式右侧的BTnum名称不依赖于左侧的名称：也就是说，我们可以将其重写为
- en: '| BTnum = μ T : ((BTmt) U (BTnd number T T)) |'
  id: totrans-742
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| BTnum = μ T : ((BTmt) U (BTnd number T��T)) |'
- en: 'In other words, this definition of BTnum truly can be thought of as syntactic
    sugar and replaced everywhere in the program without fear of infinite regress.At
    a semantic level, there are usually two very different ways of thinking about
    the meaning of types bound by μ: they can be interpreted as isorecursive or equirecursive.
    The distinction between these is, however, subtle and beyond the scope of this
    chapter.This material is covered especially well in Pierce’s book. It suffices
    to note that a recursive type can be treated as equivalent to its unfolding. For
    instance, if we define a numeric list type as'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，BTnum的这个定义确实可以被视为语法糖，并且可以在程序中随处替换而不必担心无限回归。在语义层面上，通常有两种非常不同的方式来思考被μ绑定的类型的含义：它们可以被解释为等价递归或同构递归。然而，这两者之间的区别是微妙的，超出了本章的范围。这方面的材料在皮尔斯的书中特别详细地介绍。值得注意的是，递归类型可以被视为等价于其展开。例如，如果我们将一个数字列表类型定义为
- en: '| NumL = μ T : ((MtL) U (ConsL number T)) |'
  id: totrans-744
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| NumL = μ T : ((MtL) U (ConsL number T)) |'
- en: then
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: '|   μ T : ((MtL) U (ConsL number T)) |'
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   μ T : ((MtL) U (ConsL number T)) |'
- en: '| = (MtL) U (ConsL number (μ T : ((MtL) U (ConsL number T)))) |'
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| = (MtL) U (ConsL number (μ T : ((MtL) U (ConsL number T)))) |'
- en: '| = (MtL) U (ConsL number (MtL)) |'
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| = (MtL) U (ConsL number (MtL)) |'
- en: '|         U (ConsL number (ConsL number (μ T : ((MtL) U (ConsL number T)))))
    |'
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         U (ConsL number (ConsL number (μ T : ((MtL) U (ConsL number T)))))
    |'
- en: 'and so on (iso- and equi-recursiveness differ in precisely what the notion
    of equality is: definitional equality or isomorphism). At each step we simply
    replace the T parameter with the entire type. As with value recursion, this means
    we can “get another” ConsL constructor upon demand. Put differently, the type
    of a list can be written as the union of zero or arbitrarily many elements; this
    is the same as the type that consists of zero, one, or arbitrarily many elements;
    and so on. Any lists of numbers fits all (and precisely) these types.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 等等（iso- 和 equi- 递归在何时认为相等的概念上有所不同：定义相等或同构）。在每一步中，我们只需用整个类型替换 T 参数。与值递归一样，这意味着我们可以根据需要“再获得”一个
    ConsL 构造函数。换句话说，列表的类型可以写成零个或任意多个元素的并集；这与由零个、一个或任意多个元素组成的类型相同；等等。任何数字列表都符合所有（且准确地）这些类型。
- en: Observe that even with this informal understanding of μ, we can now provide
    a type to ω, and hence to Ω.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使对 μ 的这种非正式理解，我们现在也可以为 ω 提供一个类型，从而为 Ω 提供一个类型。
- en: Exercise
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Ascribe types to ω and Ω.
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为 ω 和 Ω 赋予类型。
- en: 15.3.7Subtyping
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.7子类型化
- en: 'Imagine we have a typical binary tree definition; for simplicity, we’ll assume
    that all the values are numbers. We will write this in Typed Racket to illustrate
    a point:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个典型的二叉树定义；为简单起见，我们假设所有值都是数字。我们将在 Typed Racket 中编写这个示例以阐明一个观点：
- en: '| #lang [typed/racket](http://docs.racket-lang.org/ts-reference/index.html)
    |'
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| #lang [typed/racket](http://docs.racket-lang.org/ts-reference/index.html)
    |'
- en: '|   |'
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define-struct: mt ()) |'
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-struct: mt ()) |'
- en: '| (define-struct: nd ([v : Number] [l : BT] [r : BT])) |'
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-struct: nd ([v : Number] [l : BT] [r : BT])) |'
- en: '| (define-type BT (U mt nd)) |'
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type BT (U mt nd)) |'
- en: 'Now consider some concrete tree values:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一些具体的树值：
- en: '| > (mt) |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
  zh: '| > (mt) |'
- en: '| - : mt |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '| - : mt |'
- en: '| #<mt> |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '| #<mt> |'
- en: '| > (nd 5 (mt) (mt)) |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '| > (nd 5 (mt) (mt)) |'
- en: '| - : nd |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '| - : nd |'
- en: '| #<nd> |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '| #<nd> |'
- en: 'Observe that each structure constructor makes a value of its own type, not
    a value of type BT. But consider the expression (nd 5 (mt) (mt)): the definition
    of nd declares that the sub-trees must be of type BT, and yet we are able to successfully
    give it values of type mt.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个结构构造函数都生成其自己类型的值，而不是 BT 类型的值。但考虑表达式 (nd 5 (mt) (mt))：nd 的定义声明子树必须是 BT 类型，然而我们成功地给它赋予了
    mt 类型的值。
- en: Obviously, it is not coincidental that we have defined BT in terms of mt and
    nd. However, it does indicate that when type-checking, we cannot simply be checking
    for function equality, at least not as we have so far. Instead, we must be checking
    that one type “fits into” the other. This notion of fitting is called subtyping
    (and the act of being fit, subsumption).
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们将 BT 定义为 mt 和 nd 的组合并非巧合。然而，这表明在类型检查时，我们不能简单地检查函数相等性，至少不是我们迄今为止所做的那样。相反，我们必须检查一个类型是否“适合”另一个类型。这种适合的概念称为子类型化（以及适合的行为，包容性）。
- en: 'The essence of subtyping is to define a relation, usually denoted by <:, that
    relates pairs of types. We say S <: T if a value of type S can be given where
    a value of type T is expected: in other words, subtyping formalizes the notion
    of substitutability (i.e., anywhere a value of type T was expected, it can be
    replaced with—<wbr>substituted by—<wbr>a value of type S). When this holds, S
    is called the subtype and T the supertype. It is useful (and usually accurate)
    to take a subset interpretation: if the values of S are a subset of T, then an
    expression expecting T values will not be unpleasantly surprised to receive only
    S values.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '子类型的本质是定义一个关系，通常用 <: 表示，它将类型对联系起来。我们说 S <: T 如果类型为 S 的值可以在期望类型为 T 的地方给出：换句话说，子类型化形式化了可替代性的概念（即，在期望类型为
    T 的地方，可以用类型为 S 的值替换）。当这种情况成立时，S 被称为子类型，T 被称为超类型。采用子集解释是有用的（通常也是准确的）：如果 S 的值是 T
    的一个子集，那么期望 T 值的表达式将不会因为只接收到 S 值而感到不愉快。'
- en: 'Subtyping has a pervasive effect on the type system. We have to reexamine every
    kind of type and understand its interaction with subtyping. For base types, this
    is usually quite obvious: disjoint types like number, string, etc., are all unrelated
    to each other. (In languages where one base type is used to represent another—<wbr>for
    instance, in some scripting languages numbers are merely strings written with
    a special syntax, and in other languages, booleans are merely numbers—<wbr>there
    might be subtyping relationships even between base types, but these are not common.)
    However, we do have to consider how subtyping interacts with every single compound
    type constructor.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型对类型系统具有普遍影响。我们必须重新审视每种类型，并了解它与子类型的相互作用。对于基本类型，这通常是很明显的：像 number、string 等不相交的类型彼此无关。（在某些脚本语言中，一个基本类型用于表示另一个基本类型—<wbr>例如，在一些脚本语言中，数字只是用特殊语法编写的字符串，而在其他语言中，布尔值只是数字—<wbr>这种情况下，甚至可能存在基本类型之间的子类型关系，但这些情况并不常见。）然而，我们必须考虑子类型与每个复合类型构造器的相互作用。
- en: In fact, even our very diction about types has to change. Suppose we have an
    expression of type T. Normally, we would say that it produces values of type T.
    Now, we should be careful to say that it produces values of up to or at most T,
    because it may only produce values of a subtype of T. Thus every reference to
    a type should implicitly be cloaked in a reference to the potential for subtyping.
    To avoid pestering you I will refrain from doing this, but be wary that it is
    possible to make reasoning errors by not keeping this implicit interpretation
    in mind.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，甚至我们关于类型的措辞也必须改变。假设我们有一个类型为 T 的表达式。通常来说，我们会说它生成类型为 T 的值。现在，我们应该小心地说它生成最多或至多类型为
    T 的值，因为它可能只生成 T 的子类型的值。因此，对类型的每个引用都应隐含地涉及到子类型的潜在性。为了避免打扰你，我将避免这样做，但请注意不考虑这种隐含解释可能会导致推理错误。
- en: 15.3.7.1Unions
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.7.1联合
- en: Let us see how unions interact with subtyping. Clearly, every sub-union is a
    subtype of the entire union. In our running example, clearly every mt value is
    also a BT; likewise for nd. Thus,
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看联合如何与子类型相互作用。显然，每个子联合都是整个联合的子类型。在我们的运行示例中，显然每个 mt 值也是一个 BT；nd 也是如此。因此，
- en: '| mt <: BT |'
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| mt <: BT |'
- en: '| nd <: BT |'
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| nd <: BT |'
- en: As a result, (mt) also has type BT, thus enabling the expression (nd 5 (mt)
    (mt)) to itself type, and to have the type nd—<wbr>and hence, also the type BT.
    In general,
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，(mt) 也具有类型 BT，从而使表达式 (nd 5 (mt) (mt)) 自身具有类型，并且具有类型 nd—<wbr>因此，也具有类型 BT。一般来说，
- en: '| S <: (S U T) |'
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| S <: (S U T) |'
- en: '| T <: (S U T) |'
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| T <: (S U T) |'
- en: (we write what seems to be the same rule twice just to make clear it doesn’t
    matter which “side” of the union the subtype is on). This says that a value of
    S can be thought of as a value of S U T, because any expression of type S U T
    can indeed contain a value of type S.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: (我们写了似乎是相同规则两次，只是为了明确它不管子类型在联合的“哪一边”。) 这意味着 S 的值可以被认为是 S U T 的值，因为任何类型为 S U
    T 的表达式确实可以包含类型为 S 的值。
- en: 15.3.7.2Intersections
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.7.2交集
- en: 'While we’re at it, we should also briefly visit intersections. As you might
    imagine, intersections behave dually:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我们还应该简要讨论交集。正如你可能想象的那样，交集的行为是对偶的：
- en: '| (S ∧ T) <: S |'
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (S ∧ T) <: S |'
- en: '| (S ∧ T) <: T |'
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (S ∧ T) <: T |'
- en: 'To convince yourself of this, take the subset interpretation: if a value is
    both S and T, then clearly it is either one of them.Do Now!'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让自己相信这一点，采用子集解释：如果一个值既是 S 又是 T，那么显然它是其中的一个。现在就做吧！
- en: Why are the following two not valid subsumptions?
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么以下两个不是有效的子摄取？
- en: ''
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(S U T) <: S'
  id: totrans-788
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (S U T) <: S
- en: ''
  id: totrans-789
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-790
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'T <: (S ∧ T)'
  id: totrans-791
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: T <: (S ∧ T)
- en: The first is not valid because a value of type T is a perfectly valid element
    of type (S U T). For instance, a number is a member of type (string U number).
    However, a number cannot be supplied where a value of type string is expected.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不是有效的，因为类型为 T 的值是类型为 (S U T) 的元素的完全有效成员。例如，数字是 (string U number) 类型的成员。然而，数字不能被提供给期望类型为
    string 的值的位置。
- en: As for the second, in general, a value of type T is not also a value of type
    S. Any consumer of a (S ∧ T) value is expecting to be able to treat it as both
    a T and a S, and the latter is not justified. For instance, given our overloaded
    + from before, if T is (number number -> number), then a function of this type
    will not know how to operate on strings.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第二个，一般来说，类型为 T 的值不是类型为 S 的值。任何 (S ∧ T) 值的使用者都期望能够将其视为 T 和 S，但后者是不合理的。例如，给定我们之前重载的
    +，如果 T 是 (number number -> number)，那么这种类型的函数将不知道如何操作字符串。
- en: 15.3.7.3Functions
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.7.3函数
- en: 'We have seen one more constructor: functions.We have also seen parametric datatypes.
    In this edition, exploring subtyping for them is left as an exercise for the reader.
    We must therefore determine the rules for subtyping when either type can be a
    function. Since we usually assume functions are disjoint from all other types,
    we therefore only need to consider when one function type is a subtype of another:
    i.e., when is'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了另一个构造器：函数。我们还看到了参数化数据类型。在本版本中，探索它们的子类型化被留作读者的练习。因此，我们必须确定当任一类型都可以是函数时的子类型化规则。由于我们通常假设函数与所有其他类型不相交，因此我们只需要考虑一个函数类型何时是另一个函数类型的子类型：即，
- en: '| (S1 -> T1) <: (S2 -> T2) |'
  id: totrans-796
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (S1 -> T1) <: (S2 -> T2) |'
- en: '? For convenience, let us call the type (S1 -> T1) as f1, and (S2 -> T2) as
    f2. The question then is, if an expression is expecting functions of the f2 type,
    when can we safely give it functions with the f1 type? It is easiest to think
    through this using the subset interpretation.'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，让我们将类型 (S1 -> T1) 称为 f1，(S2 -> T2) 称为 f2。那么问题就是，如果一个表达式期望 f2 类型的函数，我们何时可以安全地给它
    f1 类型的函数？使用子集解释最容易思考这个问题。
- en: 'Consider a use of the f2 type. It returns values of type T2. Thus, the context
    surrounding the function application is satisfied with values of type T2. Clearly,
    if T1 is the same as T2, the use of f2 would continue to type; similarly, if T1
    consists of a subset of T2 values, it would still be fine. The only problem is
    if T1 has more values than T2, because the context would then encounter unexpected
    values that would result in undefined behavior. In other words, we need that T1
    <: T2. Observe that the “direction” of containment is the same as that for the
    entire function type; this is called covariance (both vary in the same direction).
    This is perhaps precisely what you expected.'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑一下 f2 类型的使用。它返回类型为 T2 的值。因此，函数应用周围的上下文会使用类型为 T2 的值。显然，如果 T1 和 T2 相同，那么使用
    f2 会继续类型；同样，如果 T1 包含 T2 值的子集，那也没问题。唯一的问题是如果 T1 的值比 T2 多，因为上下文会遇到意外的值，导致未定义的行为。换句话说，我们需要
    T1 <: T2。注意“包含”的“方向”与整个函数类型的方向相同；这被称为协变（两者在相同方向上变化）。这或许正是你期望的。'
- en: 'By the same token, you might expect covariance in the argument position as
    well: namely, that S1 <: S2. This would be predictable, and wrong. Let’s see why.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '凭借同样的道理，你可能也期望参数位置的协变：即 S1 <: S2。这是可预测的，但是错误的。让我们看看为什么。'
- en: 'An application of a function with f2 type is providing parameter values of
    type S2. Suppose we instead substitute the function with one of type f1. If we
    had that S1 <: S2, that would mean that the new function accepts only values of
    typeS1—<wbr>a strictly smaller set. That means there may be some inputs—<wbr>specifically
    those in S2 that are not in S1—<wbr>that the application is free to provide on
    which the substituted function is not defined, again resulting in undefined behavior.
    To avoid this, we have to make the subsumption go in the other direction: the
    substituting function should accept at least as many inputs as the one it replaces.
    Thus we need S2 <: S1, and say the function position is contravariant: it goes
    against the direction of subtyping.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '应用 f2 类型的函数是提供类型为 S2 的参数值。假设我们用 f1 类型的函数替换它。如果 S1 <: S2，那么意味着新函数只接受类型为 S1 的值——一个严格较小的集合。这意味着可能会有一些输入——特别是那些在
    S2 中但不在 S1 中的输入——应用可以提供但替换函数未定义的输入，再次导致未定义的行为。为了避免这种情况，我们必须让包含关系反过来：替换函数应该接受至少与其替换的函数相同数量的输入。因此我们需要
    S2 <: S1，并且说函数位置是反变的：它与子类型化的方向相反。'
- en: 'Putting together these two observations, we obtain a subtyping rule for functions
    (and hence also methods):'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个观察结果综合起来，我们得到了函数（因此也包括方法）的子类型规则：
- en: '| (S2 <: S1) and (T1 <: T2) => (S1 -> T1) <: (S2 -> T2) |'
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (S2 <: S1) and (T1 <: T2) => (S1 -> T1) <: (S2 -> T2) |'
- en: 15.3.7.4Implementing Subtyping
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.7.4 实现子类型化
- en: 'Of course, these rules assume that we have modified the type-checker to respect
    subtyping. The essence of subtyping is a rule that says, if an expression e is
    of type S, and S <: T, then e also has type T. While this sounds intuitive, it
    is also immediately problematic for two reasons:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，这些规则假设我们已经修改了类型检查器以遵守子类型化。子类型化的本质是一条规则，它说，如果表达式 e 的类型是 S，并且 S <: T，则 e 也具有类型
    T。尽管听起来很直观，但由于两个原因，它也立即存在问题：'
- en: Until now all of our type rules have been syntax-driven, which is what enabled
    us to write a recursive-descent type-checker. Now, however, we have a rule that
    applies to all expressions, so we can no longer be sure when to apply it.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的类型规则都是基于语法的，这就是我们能够编写递归下降类型检查器的原因。然而，现在，我们有一个适用于所有表达式的规则，所以我们无法确定何时应用它。
- en: There could be many levels of subtyping. As a result, it is no longer obvious
    when to “stop” subtyping. In particular, whereas before type-checking was able
    to calculate the type of an expression, now we have many possible types for each
    expression; if we return the “wrong” one, we might get a type error (due to that
    not being the type expected by the context) even though there exists some other
    type that was the one expected by the context.
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在许多级别的子类型。因此，不再明显何时“停止”子类型化。特别是，以前在类型检查中能够计算表达式的类型，现在我们对于每个表达式可能有许多可能的类型；如果我们返回了“错误”的类型，那么可能会得到类型错误（因为那不是上下文所期望的类型），即使存在一些其他类型，它是上下文所期望的类型。
- en: 'What these two issues point to is that the description of subtyping we are
    giving here is fundamentally declarative: we are saying what must be true, but
    not showing how to turn it into an algorithm. For each actual type language, there
    is a less or more interesting problem in turning this into algorithmic subtyping:
    an actual algorithm that realizes a type-checker (ideally one that types exactly
    those programs that would have typed under the declarative regime, i.e., one that
    is both sound and complete).'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题指出的是，我们在这里给出的子类型描述基本上是声明性的：我们说了什么是真的，但没有展示如何将其转化为算法。对于每种实际类型语言，将这一点转化为算法子类型化存在一个更或者更少有趣的问题：一个实际的算法实现了一个类型检查器（理想情况下，它可以对在声明性制度下也会有类型的程序进行类型化，即，一个既是完备又是完全的）。
- en: 15.3.8Object Types
  id: totrans-808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.8对象类型
- en: 'As we’ve mentioned earlier, types for objects are typically riven into two
    camps: nominal and structural. Nominal types are familiar to most programmers
    through Java, so I won’t say much about them here. Structural types for objects
    dictate that an object’s type is itself a structured object, consisting of names
    of fields and their types. For instance, an object with two methods, add1 and
    sub1 [REF], would have the type'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，对象的类型通常被分为两派：名义和结构。名义类型对大多数程序员来说是熟悉的，通过 Java，所以我在这里不会多说。对象的结构类型规定对象的类型本身是一个结构化对象，由字段的名称和它们的类型组成。例如，一个具有两个方法
    add1 和 sub1 [REF] 的对象将具有类型
- en: '| {add1 : (number -> number), sub1 : (number -> number)} |'
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| {add1 : (number -> number), sub1 : (number -> number)} |'
- en: '(For future reference, let’s call this type addsub.) Type-checking would then
    follow along predictable lines: for field access we would simply ensure the field
    exists and would use its declared type for the dereference expression; for method
    invocation we would have to ensure not only that the member exists but that it
    has a function type. So far, so straightforward.Object types become complicated
    for many reasons:Whole books are therefore devoted to this topic. Abadi and Carelli’s
    A Theory of Objects is important but now somewhat dated. Bruce’s Foundations of
    Object-Oriented Languages: Types and Semantics is more modern, and also offers
    more gentle exposition. Pierce covers all the necessary theory beautifully.'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: （供以后参考，让我们将这种类型称为 addsub。）类型检查然后将沿着可预测的线路进行：对于字段访问，我们只需确保字段存在，并使用其声明的类型进行解引用表达式；对于方法调用，我们不仅要确保成员存在，还要确保它具有函数类型。到目前为止，一切都很简单明了。对象类型因许多原因变得复杂：因此有很多书籍专门讨论这个主题。阿巴迪和卡雷利的《对象理论》是重要的，但现在有些过时了。布鲁斯的《面向对象语言的基础：类型和语义》更现代化，也提供了更温和的阐述。皮尔斯很好地涵盖了所有必要的理论。
- en: Self-reference. What is the type of self? It must the same type as the object
    itself, since any operation that can be applied to the object from the “outside”
    can also be applied to it from the “inside” using self. This means object types
    are recursive types.
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自引用。self 的类型是什么？它必须与对象本身的类型相同，因为任何从“外部”可以应用于对象的操作也可以使用 self 从“内部”应用于它。这意味着对象类型是递归类型。
- en: 'Access controls: private, public, and other restrictions. These lead to a distinction
    in the type of an object from “outside” and “inside”.'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制：私有、公共和其他限制。这导致对象的类型在“外部”和“内部”有所区别。
- en: Inheritance. Not only do we have to give a type to the parent object(s), what
    is visible along inheritance paths may, again, differ from what is visible from
    the “outside”.
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承。我们不仅需要为父对象（们）赋予类型，沿着继承路径可见的内容可能与从“外部”可见的内容再次不同。
- en: The interplay between multiple-inheritance and subtyping.
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重继承与子类型之间的相互作用。
- en: The relationship between classes and interfaces in languages like Java, which
    has a run-time cost.
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类与接口之间的关系，例如像Java这样的语言，它具有运行时成本。
- en: Mutation.
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突变。
- en: Casts.
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制类型转换。
- en: Snakes on a plane.
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞机上的蛇。
- en: and so on. Some of these problems simplify in the presence of nominal types,
    because given a type’s name we can determine everything about its behavior (the
    type declarations effectively become a dictionary through which the object’s description
    can be looked up on demand), which is one argument in favor of nominal typing.Note
    that Java’s approach is not the only way to build a nominal type system. We have
    already argued that Java’s class system needlessly restricts the expressive power
    of programmers [REF]; in turn, Java’s nominal type system needlessly conflates
    types (which are interface descriptions) and implementations. It is, therefore,
    possible to have much better nominal type systems than Java’s. Scala, for instance,
    takes significant steps in this direction.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。在名义类型存在时，其中一些问题变得简化了，因为给定类型的名称，我们可以确定关于它的行为的一切（类型声明有效地成为了一个字典，通过它可以根据需要查找对象的描述），这是支持名义类型的一个论点。请注意，Java的方法不是构建名义类型系统的唯一方法。我们已经证明了Java的类系统无谓地限制了程序员的表达能力[参考文献]；反过来，Java的名义类型系统无谓地混淆了类型（这些是接口描述）和实现。因此，可能存在比Java更好的名义类型系统。例如，Scala在这个方向上迈出了重要的步伐。
- en: 'A full exposition of these issues will take much more room than we have here.
    For now, we will limit ourselves to one interesting question. Remember that we
    said subtyping forces us to consider every type constructor? The structural typing
    of objects introduces one more: the object type constructor. We therefore have
    to understand its interaction with subtyping.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些问题的全面阐述将占用比我们这里拥有的空间更多。目前，我们将限制自己只讨论一个有趣的问题。记得我们说过子类型强迫我们考虑每个类型构造函数吗？对象的结构化类型引入了一个额外的构造函数：对象类型构造函数。因此，我们必须理解它与子类型之间的相互作用。
- en: Before we do, let’s make sure we understand what an object type even means.
    Consider the type addsub above, which lists two methods. What objects can be given
    this type? Obviously, an object with just those two methods, with precisely those
    two types, is eligible. Equally obviously, an object with only one and not the
    other of those two methods, no matter what else it has, is not. But the phrase
    “no matter what else it has” is meant to be leading. What if an object represents
    an arithmetic package that also contains methods + and *, in addition to the above
    two (all of the appropriate type)? In that case we certainly have an object that
    can supply those two methods, so the arithmetic package certainly has type addsub.
    Its other methods are simply inaccessible using type addsub.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们确保我们理解什么是对象类型。考虑上面的 addsub 类型，它列出了两个方法。哪些对象可以具有这种类型？显然，只具有这两种方法的对象，精确地具有这两种类型的对象是合格的。同样明显的是，只具有这两种方法中的一种而不具有另一种的对象，无论它还具有什么，都是不合格的。但短语“不管它还有什么其他内容”是带有引导意味的。如果一个对象代表一个算术包，除了上面的两个方法之外，还包含
    + 和 * 方法，那么我们当然有一个可以提供这两个方法的对象，因此这个算术包当然具有 addsub 类型。使用 addsub 类型时，其它方法只是无法访问的。
- en: 'Let us write out the type of this package, in full, and call this type as+*:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完整地写出这个包的类型，并称这个类型为 as+*：
- en: '| {add1  : (number -> number), |'
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| {add1  : (number -> number), |'
- en: '|  sub1  : (number -> number), |'
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  sub1  : (number -> number), |'
- en: '|  +     : (number number -> number), |'
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  +     : (number number -> number), |'
- en: '|  *     : (number number -> number)} |'
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  *     : (number number -> number)} |'
- en: 'What we have just argued is that an object of type as+* should also be allowed
    to claim the type addsub, which means it can be substituted in any context expecting
    a value of type addsub. In other words, we have just said that we want as+* <:
    addsub:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '我们刚刚讨论的是类型为 as+* 的对象也应该允许声明类型 addsub，这意味着它可以替换为期望类型 addsub 的任何上下文中的值。换句话说，我们刚刚说过我们希望
    as+* <: addsub：'
- en: '| {add1  : (number -> number),           {add1 : (number -> number), |'
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| {add1  : (number -> number),           {add1 : (number -> number), |'
- en: '|  sub1  : (number -> number),        <:  sub1 : (number -> number)} |'
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  sub1  : (number -> number),        <:  sub1 : (number -> number)} |'
- en: '|  +     : (number number -> number), |'
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  +     : (number number -> number), |'
- en: '|  *     : (number number -> number)} |'
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  *     : (number number -> number)} |'
- en: 'This may momentarily look confusing: we’ve said that subtyping follows set
    inclusion, so we would expect the smaller set on the left and the larger set on
    the right. Yet, it looks like we have a “larger type” (certainly in terms of character
    count) on the left and a “smaller type” on the right.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来令人困惑：我们说子类型遵循集合包含，因此我们期望左侧有较小的集合，右侧有较大的集合。然而，看起来我们左侧有一个“较大的类型”（从字符数来看确实如此），右侧有一个“较小的类型”。
- en: To understand why this is sound, it helps to develop the intuition that the
    “larger” the type, the fewer values it can have. Every object that has the four
    methods on the left clearly also has the two methods on the right. However, there
    are many objects that have the two methods on the right that fail to have all
    four on the left. If we think of a type as a constraint on acceptable value shapes,
    the “bigger” type imposes more constraints and hence admits fewer values. Thus,
    though the types may appear to be of the wrong sizes, everything is well because
    the sets of values they subscribe are of the expected sizes.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这为什么是正确的，有助于发展这样的直觉：类型越“大”，它可以具有的值就越少。每个具有左侧四个方法的对象显然也具有右侧的两个方法。然而，有许多对象具有右侧的两个方法，但却不具有左侧的所有四个方法。如果我们将类型视为对可接受值形状的约束，则“较大”的类型会施加更多约束，因此接受的值会更少。因此，尽管类型可能看起来大小不对，但一切都很好，因为它们订阅的值集合的大小是符合预期的。
- en: 'More generally, this says that by dropping fields from an object’s type, we
    obtain a supertype. This is called width subtyping, because the subtype is “wider”,
    and we move up the subtyping hierarchy by adjusting the object’s “width”. We see
    this even in the nominal world of Java: as we go up the inheritance chain a class
    has fewer and fewer methods and fields, until we reach Object, the supertype of
    all classes, which has the fewest. Thus for all class types C in Java, C <: Object.Somewhat
    confusingly, the terms narrowing and widening are sometimes used, but with what
    some might consider the opposite meaning. To widen is to go from subtype to supertype,
    because it goes from a “narrower” (smaller) to a “wider” (bigger) set. These terms
    evolved independently, but unfortunately not consistently.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '更一般地说，这意味着通过从对象类型中删除字段，我们得到一个超类型。这被称为宽度子类型，因为子类型更“宽”，我们通过调整对象的“宽度”向上移动子类型层次结构。即使在
    Java 的命名世界中也能看到这一点：当我们沿着继承链向上移动时，一个类的方法和字段越来越少，直到我们到达 Object，所有类的超类型，它具有最少的方法和字段。因此，对于
    Java 中的所有类类型 C，C <: Object。有些令人困惑的是，有时候会使用缩小和扩大这些术语，但有些人可能认为含义相反。扩大是指从子类型到超类型，因为它从“较窄”（较小）的集合到“较宽”（较大）的集合。这些术语发展独立地，但不幸的是不一致地。'
- en: As you might expect, there is another important form of subtyping, which is
    within a given member. This simply says that any particular member can be subsumed
    to a supertype in its corresponding position. For obvious reasons, this form is
    called depth subtyping.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会预料到，还有另一种重要的子类型形式，即在给定成员内部的子类型。这只是说任何特定的成员都可以被其对应位置的超类型包含。出于明显的原因，这种形式被称为深度子类型。
- en: Exercise
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Construct two examples of depth subtyping. In one, give the field itself an
    object type, and use width subtyping to subtype that field. In the other, give
    the field a function type.
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建两个深度子类型的示例。在一个示例中，给字段本身一个对象类型，并使用宽度子类型来对该字段进行子类型化。在另一个示例中，给字段一个函数类型。
- en: Java has limited depth subtyping, preferring types to be invariant down the
    object hierarchy because this is a safe option for conventional mutation.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: Java 具有有限的深度子类型，倾向于使类型在对象层次结构下不变，因为这是常规突变的安全选择。
- en: The combination of width and depth subtyping cover the most interesting cases
    of object subtyping. A type system that implemented only these two would, however,
    needlessly annoy programmers. Other convenient (and mathematically necessary)
    rules include the ability to permute names, reflexivity (every type is a subtype
    of itself, because it is more convenient to interpret the subtype relationship
    as ⊆), and transitivity. Languages like Typed JavaScript employ all these features
    to provide maximum flexibility to programmers.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度子类型和深度子类型的组合涵盖了对象子类型的最有趣的情况。然而，只实现这两种类型的类型系统将不必要地使程序员感到恼火。其他方便的（也是数学上必要的）规则包括能够对名称进行置换，自反性（每种类型都是其自身的子类型，因为将子类型关系解释为
    ⊆ 更方便），以及传递性。像 Typed JavaScript 这样的语言利用所有这些特性为程序员提供最大的灵活性。
