["```\n(: eval : FLANG SubstCache -> FLANG);; evaluates FLANG expressions by reducing them to expressions(define (eval expr sc)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (arith-op + (eval l sc) (eval r sc))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l sc) (eval r sc))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l sc) (eval r sc))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l sc) (eval r sc))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (extend bound-id (eval named-expr sc) sc))]\u00a0 \u00a0 [(Id name) (lookup name sc)]\u00a0 \u00a0 [(Fun bound-id bound-body) expr]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  (let ([fval (eval fun-expr sc)])\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(Fun bound-id bound-body)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (extend bound-id (eval arg-expr sc) sc))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"`call' expects a function, got: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]))\n```", "```\n(: run : String -> Number);; evaluate a FLANG program contained in a string(define (run str)\u00a0 (let ([result (eval (parse str) empty-subst)])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a non-number: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])))\n```", "```\n#lang pl(define-type FLANG\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 FLANG FLANG]\u00a0 [Sub\u00a0 FLANG FLANG]\u00a0 [Mul\u00a0 FLANG FLANG]\u00a0 [Div\u00a0 FLANG FLANG]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol FLANG FLANG]\u00a0 [Fun\u00a0 Symbol FLANG]\u00a0 [Call FLANG FLANG])(: parse-sexpr : Sexpr -> FLANG);; parses s-expressions into FLANGs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'fun more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'fun (list (symbol: name)) body)\u00a0 \u00a0 \u00a0 \u00a0 (Fun name (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `fun' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list 'call fun arg)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Call (parse-sexpr fun) (parse-sexpr arg))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> FLANG);; parses a string containing a FLANG expression to a FLANG AST(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)));; a type for substitution caches:(define-type SubstCache = (Listof (List Symbol FLANG)))(: empty-subst : SubstCache)(define empty-subst null)(: extend : Symbol FLANG SubstCache -> SubstCache);; extend a given substitution cache with a new mapping(define (extend name val sc)\u00a0 (cons (list name val) sc))(: lookup : Symbol SubstCache -> FLANG);; lookup a symbol in a substitution cache, return the value it is;; bound to (or throw an error if it isn't bound)(define (lookup name sc)\u00a0 (let ([cell (assq name sc)])\u00a0 \u00a0 (if cell\u00a0 \u00a0 \u00a0 (second cell)\u00a0 \u00a0 \u00a0 (error 'lookup \"no binding for ~s\" name))))(: Num->number : FLANG -> Number);; convert a FLANG number to a Racket one(define (Num->number e)\u00a0 (cases e\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [else (error 'arith-op \"expected a number, got: ~s\" e)]))(: arith-op : (Number Number -> Number) FLANG FLANG -> FLANG);; gets a Racket numeric binary operator, and uses it within a FLANG;; `Num' wrapper(define (arith-op op expr1 expr2)\u00a0 (Num (op (Num->number expr1) (Num->number expr2))))(: eval : FLANG SubstCache -> FLANG);; evaluates FLANG expressions by reducing them to expressions(define (eval expr sc)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (arith-op + (eval l sc) (eval r sc))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l sc) (eval r sc))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l sc) (eval r sc))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l sc) (eval r sc))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (extend bound-id (eval named-expr sc) sc))]\u00a0 \u00a0 [(Id name) (lookup name sc)]\u00a0 \u00a0 [(Fun bound-id bound-body) expr]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  (let ([fval (eval fun-expr sc)])\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(Fun bound-id bound-body)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (extend bound-id (eval arg-expr sc) sc))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"`call' expects a function, got: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]))(: run : String -> Number);; evaluate a FLANG program contained in a string(define (run str)\u00a0 (let ([result (eval (parse str) empty-subst)])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a non-number: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])));; tests(test (run \"{call {fun {x} {+ x 1}} 4}\")\u00a0 \u00a0 \u00a0 => 5)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add3 1}}\")\u00a0 \u00a0 \u00a0 => 4)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {add1 {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add1 {call add3 x}}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{with {identity {fun {x} x}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {foo {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call {call identity foo} 123}}}\")\u00a0 \u00a0 \u00a0 => 124)(test (run \"{call {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {y} {+ x y}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 4}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {f {fun {y} {+ x y}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 5}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call f 4}}}}\")\u00a0 \u00a0 \u00a0 => \"???\")(test (run \"{call {call {fun {x} {call x 1}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {x} {fun {y} {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 123}\")\u00a0 \u00a0 \u00a0 => 124)\n```"]