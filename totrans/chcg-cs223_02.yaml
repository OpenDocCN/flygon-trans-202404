- en: Introduction to ML in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using [Elm v0.14](http://elm-lang.org/blog/announce/0.14.elm). If
    there are minor language revisions released throughout the quarter, we will decide
    whether or not to upgrade. You should [get Elm up and running as soon as possible](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/assignments/HW0.html)
    to make sure that you have a working development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump in with some examples at the REPL (read-eval-print loop).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Basic Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Numeric literals without a decimal point are described by the type variable
    `number`, which describes both `Int`s and `Float`s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One way to read the last line above is "for every type `number` such that `number`
    = `Int` or `number` = `Float`, 3 has type `number`." In other words, "3 has type
    `Int` and `Float`" and depending on how the expression is used, the Elm type checker
    will choose to *instantiate* the type variable `number` with one of these types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with Haskell, think of `number` as a type class that is
    "baked in" to the language. Elm does not have general support for type classes,
    but it does have a few special purpose type classes like `number`.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuples package two or more expressions into a single expression. The type of
    a tuple records the number of components and each of their types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lone expressions prefer to remain alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like in most functional languages, all functions take exactly one argument and
    return exactly one value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple arguments in *uncurried* style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple arguments in *curried* style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Partial application* of curried functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we wanted to restrict our `plus` function to `Int`s rather than arbitrary
    `number`s? We need some way to "cast" a `number` to an `Int`. Although the [`Basics`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Basics)
    library does not provide such a `toInt` function, we can define something to help
    ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't quite have the type `number -> Int` we sought... but on second
    thought, we don't really need a casting function of that type. Why not?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Type Annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Elm, like most ML dialects, automatically infers most types. Nevertheless, it
    is often good practice to manually declare type annotations for "top-level" definitions
    (we will see "local" definitions shortly).
  prefs: []
  type: TYPE_NORMAL
- en: In an Elm source file (e.g. [`IntroML.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/IntroML.elm)),
    a top-level definition can be preceded by a type annotation. The type checker
    will check whether the implementation actually satisfies the type you've declared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that by using an explicit annotation for `plusInt`, we avoid the need
    to use the roundabout `toInt` function from before. In fact, we can refactor the
    definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This version really emphasizes the fact that our *implementation* of `plusInt`
    is more general than the API (i.e. type) exposed to *clients* of the function.
    Designing software is full of decisions like this one.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we've started putting definitions in source files, how do we import
    them from the REPL and from other files? Notice that the file [`IntroML.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/IntroML.elm)
    defines a module of the same name, which can be imported in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: The following `import` will require all imported definitions to be qualified
    for use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another option is to specify which definitions to import and use with qualification.
    No other definitions from `IntroML` will be accessible, even with qualification.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: But, you can import the same module again to allow qualified access to other
    members.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `\` character to enter a multi-line expression in the
    REPL. If, instead, the two `import` expressions are entered sequentially in the
    REPL, then the more recent one seems to take precedence. This will not be the
    case in source files, however. This will turn out to be useful when working with
    `List`s soon.
  prefs: []
  type: TYPE_NORMAL
- en: You can also import all definitions for use without qualification.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can also define an abbreviation for the imported module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Whew, that was a lot of choices! This kind of flexibility will come in handy,
    because it can be hard to remember where functions are defined when importing
    many modules. Furthermore, many modules will define functions with popular names,
    such as `map` and `foldr`, so qualified access will be needed.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we had started to use some library functions without
    any `import`s. That's because [`Basics`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Basics),
    as well as a few other very common libraries such as [`Maybe`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Maybe),
    are opened [by default](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/).
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conditional expressions must return the same type of value on both branches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There's a handy syntax for multi-way if-expressions, which makes writing nested
    conditionals very neat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[`Basics`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Basics)
    defines `otherwise` to be a synonym for `True`, which can improve readability
    in multi-way conditionals.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although multi-way conditionals are great, they do introduce one potential pitfall
    compared to writing out nested conditionals. What happens if *none* of the predicates
    (a.k.a. "guards" or "where-clauses") evaluates to `True`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Ah, a run-time error. Notice that this same expression cannot be written with
    conditionals because they always require an `else` branch to be specified. No
    need to fret too much, just make sure you are handling all cases in a multi-way
    conditional, because the type checker will not help you with this kind of error.
  prefs: []
  type: TYPE_NORMAL
- en: What about if *multiple* predicates evaluate to `True`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As expected, each of the predicates is tested in top-down order, and the first
    one satisfied wins. Again, notice that the type checker doesn't complain that
    the second clause will *never* evaluate at run-time. Although this is pretty easy
    to see in this case, in general identifying unreachable code is undecidable.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing to know about conditionals: whitespace matters. Make sure that
    all of your patterns are aligned, and you''ll do just fine.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type variables are identifiers that start with a lower case letter and are often
    a single character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `number` type discussed above, this function type should be read
    as having an implicit "forall" at the beginning that "defines" the scope of the
    type variable: "for all types `a`, `choose` has type `Bool -> a -> a -> a`.'
  prefs: []
  type: TYPE_NORMAL
- en: When calling a polymorphic function such as `choose`, Elm (like other ML dialects)
    will automatically *instantiate* the type variables with type arguments appropriately
    based on the value arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These function calls can be thought of as taking type arguments (one for each
    type universally quantified type variable for the function) that are automatically
    inferred by the type checker. If the syntax of Elm were to allow explicit type
    instantiations, the above expressions might look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Imagine that polymorphic types in Elm required an explicit forall quantifier.
    The result of instantiating a polymorphic type with a type argument `T` is obtained
    by *substituting* bound occurrences of the type variable with `T`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Just as the particular choices of program variables does not matter, neither
    do the particular choices of type variables. So polymorphic types are equivalent
    up to renaming. For example, `choose` can be annotated with polymorphic types
    that choose a different variable name than `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All of these types are equivalent. After typechecking your function, however,
    Elm may choose to overrule your choice of type variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: What happens if `choose` is annotated as follows?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `choose` function typechecks with this annotation, but this type is more
    restrictive than the earlier ones. Remember that `number`, as discussed earlier,
    can only be instantiated with the types `Int` and `Float`. This special handling
    of the particular variable `number` — as opposed to other identifiers — is the
    way that Elm shoehorns a limited form of type classes into the language. It's
    a pretty interesting design choice!
  prefs: []
  type: TYPE_NORMAL
- en: While we are on the subject, there is another special purpose type variable
    called `comparable` that is used to describe types that are, well, comparable
    using an ordering relation. See [`Basics`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Basics)
    for more info.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Digression: Bug Hunting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take note that there seems to be an [open compiler bug](https://github.com/elm-lang/elm-compiler/issues/694)
    where polymorphic types may be printed incorrectly. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The types inferred for `id1` and `id2` are what we expect, but not so for `id3`
    and `id4`. The purported types for the latter two are correct, but they seem unnecessarily
    restrictive, reusing the (bound) type variable `b` rather than choosing different
    variables for arguments `c` and `d`.
  prefs: []
  type: TYPE_NORMAL
- en: As a way to investigate the issue a bit, we can put the following annotated
    definition in [`IntroML.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/IntroML.elm)
    to see what the compiler says.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lo and behold, `id5` typechecks with the suitably general type that we ascribed,
    but the type displayed in the REPL is not equivalent modulo renaming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do a bit more investigating to try to determine whether the bug manifests
    itself in the type *assigned* to `id5` or only in the type that is *printed* for
    `id5`. The following interaction suggests the latter, more benign bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Cool, maybe we have some potential for investigative journalism... or not. In
    any case, bugs even in mature software are a fact of life, so we can't expect
    the compiler to be perfect yet. That said, the language and tools are already
    quite robust (thanks to the community!), which we will make quite good use of
    in this course.
  prefs: []
  type: TYPE_NORMAL
- en: When we come across bugs like this, we can help each other troubleshoot issues
    on Piazza (the "`elm`" tag seems like a reasonable choice); carefully look for
    known open issues in the [compiler](https://github.com/elm-lang/elm-compiler/issues),
    [REPL](https://github.com/elm-lang/elm-repl/issues), [standard libraries](https://github.com/elm-lang/elm-package/issues/),
    and [reactor](https://github.com/elm-lang/elm-reactor/issues); look for relevant
    discussions on the [Elm mailing list](https://groups.google.com/forum/#!forum/elm-discuss);
    and write constructive, clear bug reports to submit to the language community.
    You may even catch the bug and decide to become an Elm contributor!
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Without further ado, lists. Notice the `import` to bring the "cons" operator
    into scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There isn't currently a way to import *all* infix operators from a module for
    unqualified use, nor is there support for qualified operators, but there are [proposals](https://groups.google.com/forum/#!searchin/elm-discuss/operator/elm-discuss/1BSng3MWIq0/ZGaFp4PoabQJ)
    for such features.
  prefs: []
  type: TYPE_NORMAL
- en: For those keeping score, the list syntax above is part OCaml (`(::)` for cons
    rather than `(:)`) and part Haskell (`,` to separate elements rather than `;`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s syntactic shorthand for numeric ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`String`s are not lists of `Char`s like they are in Haskell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Pattern matching to destruct lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple cases on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Non-exhaustive patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As with multi-way conditionals, whitespace matters for pattern matching. Make
    sure your `cases` line up nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The classics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following emphasizes that the lambda above is *eta-expanded*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The *eta-reduced* version is nicer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Datatypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists are a built-in *inductive datatype*. You can define your own datatypes
    (or "disjoint sums" or "sums-of-products"). Each type constructor is defined with
    one or more data constructors, each of which is defined to "hold" zero or more
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Non-nullary data constructors are themselves functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Use datatypes to simulate "heterogeneous" lists of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Pattern matching is the (only) way to "use," or "destruct," constructed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As before, be careful with non-exhaustive and redundant patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Types for Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our "head" function `hd` above fails with a run-time error when its argument
    is non-empty. Another way to deal with error cases is to track them explicitly,
    by introducing data values that are used explicitly to represent the error, or
    the lack of a meaningful answer.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'describes two kinds of values: ones labeled `YesInt` that *do* come bundled
    with an `Int`, and ones labeled `NoInt` that do *not* come bundled with any other
    data. In other words, the latter can be used to encode when there is no meaningful
    `Int` to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Ah, much better than a run-time error!
  prefs: []
  type: TYPE_NORMAL
- en: This `MaybeInt` type is defined to work only with `Int`s, but the same pattern
    — the presence or absence of a meaningful result — will emerge with all different
    types of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphic datatypes to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As when calling polymorphic functions, type variables for type constructors
    like `MaybeData` get instantiated to particular type arguments in order to match
    the kinds of values it is being used with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphic datatypes and polymorphic functions make a formidable duo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '"For every type `a`, `NoData` has type `a`." Cool, `NoData` is a polymorphic
    *constant* and its type may be instantiated, or specialized, depending on how
    it is used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MaybeData` pattern is so common that there''s a library called [`Maybe`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Maybe)
    that provides the following type, which is like ours but with different names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: There's also a related library and type called [`Result`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Result)
    that generalizes the `Maybe` pattern. Check them out, and also see [`IntroML.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/IntroML.elm)
    for a couple simple examples.
  prefs: []
  type: TYPE_NORMAL
- en: Infix Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a bunch of really useful infix operators in [Basics](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Basics),
    so take a look around. Make sure to visit `(<|)`, `(|>)`, `(<<)`, and `(>>)`,
    which can be used to write elegant chains of function applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let-Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we have worked only with top-level definitions. Elm's `let`-expressions
    allow the definition of variables that are "local" to the enclosing scope. As
    with other language features, whitespace matters so make sure equations are aligned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'No need to write so many `let`s and `in`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Too many local variables can sometimes obscure meaning (just as too few variables
    can). In this case, the "pipelined" definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: and, better yet, the definition by function composition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: are, arguably, more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Required
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Syntax Reference](http://elm-lang.org/learn/Syntax.elm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Libraries: [`Basics`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Basics),
    [`Maybe`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Maybe), [`List`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/List)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look through some of the [Elm Examples](http://elm-lang.org/Examples.elm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look through more of the [Standard Libraries](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you would like to see the syntax and features of two other ML dialects, Standard
    ML and OCaml, take a look at [this](http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html)
    and [this](http://adam.chlipala.net/mlcomp/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
