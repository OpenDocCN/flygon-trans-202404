["```\ntype coin = Penny | Nickel | Dime | Quarter\n\n```", "```\nlet value (c : coin) : float =\n  match c with\n    Penny -> 0.01\n  | Nickel -> 0.05\n  | Dime -> 0.10\n  | Quarter -> 0.25\n\n```", "```\nlet bad_value (c : coin) : float =\n  let penny = Penny in\n    match c with\n      penny -> 0.01\n    | Nickel -> 0.05\n    | Dime -> 0.10\n    | Quarter -> 0.25\n\n```", "```\nlet bad_value2 (c : coin) : float =\n  let penny = Penny in\n    if c = penny then 0.01\n    else if c = Nickel then 0.05\n    else if c = Dime then 0.10\n    else if c = Quarter then 0.25\n    else raise (Failure \"impossible!\")\n\n```", "```\nlet bad_value2 (c : coin) : float =\n  let penny = Penny in\n    match c with\n      random_variable_name -> 0.01\n    | Nickel -> 0.05\n    | Dime -> 0.10\n    | Quarter -> 0.25\n\n```", "```\nlet bad_value3 (c : coin) : float =\n  let penny = Penny in\n    match c with\n      _ -> 0.01\n    | Nickel -> 0.05\n    | Dime -> 0.10\n    | Quarter -> 0.25\n\n```", "```\nlet id = e (* a value declaration *)\nlet id = e in ... (* a value declaration *)\nlet id (arg : s) : t = e (* a function declaration *)\nlet id (arg1 : s1) (arg2 : s2) : t = e (* a function declaration *)\nmatch e with\n  id -> ... (* a pattern match *)\n\n```", "```\nif id = e then ... else ...\nid + 3\n\n```", "```\nlet bad_value (c : coin) : float =\n  let penny = Penny in\n    match c with\n      penny -> 0.01\n    | Nickel -> 0.05\n    | Dime -> 0.10\n    | Quarter -> 0.25\n\n```", "```\nmatch e with\n  Add (x, y) :: t -> x + y\n| ...\n\n```", "```\nmatch e with\n  Add (x, y) :: _ -> x + y\n| ...\n\n```", "```\n(*1*)   let f ((x : int), (y : int)) : int =\n(*2*)     let x = y in\n(*3*)     let y = x in\n(*4*)     let (y, x) = (x, y * y) in\n(*5*)     match (y, x) with\n(*6*)       (x, 1) -> 0\n(*7*)     | (x, y) -> x\n(*8*)   in f (2, 3)\n\n```", "```\ntype 'a list = [] | :: of 'a * 'a list\n\n```", "```\n[];;\n*- : 'a list = []*\nlet it = 2 :: [];;\n*val it : int list = [2]*\nlet both = 1 :: it;;\n*val both : int list = [1; 2]*\nlet both2 =\nmatch both with\n  x :: lst -> lst \n| [] -> [];;\n*val both2 : int list = [2]*\nlet both3 =\nmatch both2 with\n  x :: lst -> lst \n| [] -> [];;\n(* we don't \"recover polymorphism\" here; it would be unsafe in general *)\n*val both3 : int list = []*\nboth = 1 :: 2 :: [];; \n(* we can test lists for equality if we can test their elements *)\n*- : bool = true*\nmatch both with\n  [x; y] -> x + y (* we can use bracket notation in patterns *)\n| _ -> 0;;\n*- : int = 3*\n[[]];;\n*- : 'a list list = [[]]*\n\n```", "```\nmatch [\"hello\"; \"goodbye\"] with\n  s :: _ -> s ^ \" hello\";;\n*Warning P: this pattern-matching is not exhaustive. Here is an example of a value that is not matched: []*\n\n```", "```\nval List.length : 'a list -> int\nval @ : ('a list * 'a list) -> 'a list\t\t(* append two lists *)\nval List.hd : 'a list -> 'a\nval List.tl : 'a list -> 'a list\nval List.nth : ('a list * int) -> 'a\n\n```", "```\n# type ('a, 'b) ortype = Left of 'a | Right of 'b | Both of 'a * 'b;;\n*type ('a, 'b) ortype = Left of 'a | Right of 'b | Both of 'a * 'b*\n# Left 2;;\n*- : (int, 'a) ortype = Left 2*\n# Right \"hello\";;\n*- : ('a, string) ortype = Right \"hello\"*\n# Both (true, 'a');;\n*- : (bool, char) ortype = Both (true, 'a')*\n\n```", "```\ntype 'a option = Some of 'a | None\n\n```"]