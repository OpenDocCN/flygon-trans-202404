["```\nq_0         =  ...             -- |front| = |back| = m\nq_1         =  dequeue q_0\nq_2         =  dequeue q_1\n           ... \nq_m         =  dequeue q_m_minus_1\nq_m_plus_1  =  dequeue q_m \n```", "```\ntype Queue a = Q { front : LazyList a, back : LazyList a } \n```", "```\nempty = mkQ nil nil\n\nnil = lazy (\\_ -> Nil) \n```", "```\nisEmpty (Q {front, back}) =\n  case force front of\n    Nil -> True\n    _   -> False \n```", "```\nenqueue x (Q {front, back}) =\n  checkFront front (lazy (\\_ -> Cons x back))\n\ndequeue (Q {front, back}) = case force front of\n  Nil       -> Nothing\n  Cons _ f' -> Just (checkFront f' back)\n\npeek (Q {front, back}) = case force front of\n  Nil      -> Nothing\n  Cons x _ -> Just x \n```", "```\ncheckFront f b = case force f of\n  Nil -> mkQ (reverse b) nil\n  _   -> mkQ f b \n```", "```\ncheckFront f b = case force f of\n  Nil -> mkQ (lazy (\\_ -> force (reverse b))) nil\n  _   -> mkQ f b \n```", "```\nfront `append` reverse back \n```", "```\ntype Queue a = Q Int (LazyList a) Int (LazyList a) \n```", "```\nnil = lazy (\\_ -> Nil)\n\nempty = Q 0 nil 0 nil\n\nisEmpty (Q i _ _ _) = i == 0 \n```", "```\npeek (Q i front j back) =\n  if | i == 0    -> Nothing\n     | otherwise -> Just (head front) \n```", "```\nenqueue x (Q i front j back) =\n  if | j < i     -> Q i front (j+1) (lazy (\\_ -> Cons x back))\n     | otherwise -> Q (i+j+1) (front `append` reverse back) 0 nil \n```", "```\ndequeue (Q i front j back) =\n  if | i == 0    -> Nothing\n     | i == j    -> Just (Q (i+j-1) (tail front `append` reverse back) 0 nil)\n     | otherwise -> Just (Q (i-1) (tail front) j back) \n```", "```\nenqueue x (Q i front j back) =\n  check i front (j+1) (lazy (\\_ -> Cons x back))\n\ndequeue (Q i front j back) =\n  if | i == 0    -> Nothing\n     | otherwise -> Just (check (i-1) (tail front) j back)\n\ncheck i front j back =\n  if | j > i     -> Q (i+j) (front `append` reverse back) 0 nil\n     | otherwise -> Q i front j back \n```", "```\ntype Queue a = Q Int (LazyList a) Int (List a) \n```", "```\nfront `append'` List.reverse back \n```", "```\nappend' : LazyList a -> List a -> LazyList a \n```", "```\ntype Queue a = Q Int (Lazy (List a)) Int (List a) \n```", "```\nforce front ++ List.reverse back \n```", "```\ntype Queue a = Q (List a) Int (Lazy (List a)) Int (List a) \n```", "```\ncheck pre i front j back =\n  if | j <= i    -> checkPre pre i front j back\n     | otherwise ->\n         let front' = lazy (\\_ -> force front ++ List.reverse back) in\n         checkPre pre (i+j) front' 0 []\n\ncheckPre pre i front j back =\n  case pre of\n    [] -> Q (force front) i front j back\n    _  -> Q pre i front j back \n```", "```\nempty = Q [] 0 (lazy (\\_ -> [])) 0 []\n\nisEmpty (Q _ i _ _ _) = i == 0 \n```", "```\nenqueue x (Q pre i front j back) = check pre i front (j+1) (x::back)\n\npeek (Q pre _ _ _ _) = maybeHead pre\n\nmaybeHead xs = case xs of {[] -> Nothing; x::_ -> Just x} \n```", "```\ndequeue (Q pre i front j back) =\n  if | i == 0    -> Nothing\n     | otherwise -> let pre'   = List.tail pre in\n                    let front' = lazy (\\_ -> List.tail (force front)) in\n                    Just (check pre' (i-1) front' j back) \n```"]