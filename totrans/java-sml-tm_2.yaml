- en: Style
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风格
- en: Style
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风格
- en: There are many aspects to programming style, from the mundane questions of where
    to place braces and new lines through to the more interesting questions of how
    you design and structure your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编程风格有许多方面，从放置大括号和换行符的平凡问题到如何设计和构造代码的更有趣的问题。
- en: This section looks at all of these aspects, starting with the more abstract
    concerns before drilling down to the more concrete.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将从更抽象的问题开始，然后深入到更具体的问题。
- en: Although static analysis tools can measure aspects of many of the things discussed
    in most cases they cannot make break-the-build decisions about whether the code
    is good. A skilled human is required to make trade offs and apply discretion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管静态分析工具可以衡量许多讨论中讨论的事物的方面，但在大多数情况下，它们无法就代码是否良好做出破坏性的决定。需要熟练的人来权衡和谨慎应用。
- en: Consider Code Generators Carefully
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仔细考虑代码生成器
- en: Summary
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Code generators can automatically implement certain types of functionality,
    saving time and eliminating the possibility of certain classes of bugs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成器可以自动实现某些类型的功能，节省时间并消除某些类别的错误可能性。
- en: Although they have much to recommend them, code generators also have a cost
    that should be considered carefully before incorporating them into your project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们有很多值得推荐的地方，但代码生成器也有一个需要在将其纳入项目之前仔细考虑的成本。
- en: Favor generators that allow a clear separation between generated and non-generated
    functionality, but make sure you understand the trade-offs you are making before
    including any generator into your project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 偏爱允许生成功能和非生成功能之间明确分离的生成器，但在将任何生成器纳入项目之前，请确保您了解所做的权衡。
- en: Details
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详情
- en: 'Code generators can be grouped into three general types:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成器可以分为三种一般类型：
- en: Boilerplate generators
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样板生成器
- en: Compile time annotation processors
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时注解处理器
- en: Runtime generators/frameworks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时生成器/框架
- en: Boilerplate Generators
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样板生成器
- en: 'Boilerplate generators are the simplest form of code generation. They can be
    further split into :'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 样板生成器是代码生成的最简单形式。它们可以进一步分为：
- en: Generators that insert code into existing classes (e.g. methods auto generated
    by an IDE).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码插入现有类中的生成器（例如IDE自动生成的方法）。
- en: Generators that produce scaffolding that is checked into version control and
    modified.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成产生脚手架的代码，这些代码被检入版本控制并进行修改。
- en: Generators that produce new classes from a model. The generated code is not
    normally checked into version control.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模型生成新类的生成器。生成的代码通常不会被检入版本控制。
- en: We recommend that the first type are using sparingly, if at all. This is discussed
    further in "Know How to Implement Hashcode and Equals".
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议第一种类型的使用要谨慎，如果有的话。这在"了解如何实现Hashcode和Equals"中进一步讨论。
- en: Generating code from a model (such as a schema or grammar) can be a useful approach
    as long as the generated code is not modified and is packaged separately. If generated
    and non-generated code are packaged within the same module then this can start
    to cause friction (see below).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从模型（如模式或语法）生成代码可能是一种有用的方法，只要生成的代码不被修改并且被单独打包。如果生成的代码和非生成的代码打包在同一个模块中，那么这可能开始引起摩擦（见下文）。
- en: Compile Time Annotation Processors
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译时注解处理器
- en: JSR 269 introduced a standard framework for processing annotations at build
    time. Several tools exist that use JSR 269 to generate code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JSR 269引入了一个标准框架，用于在构建时处理注解。存在几种工具使用JSR 269生成代码。
- en: Most use the annotated classes purely as input, from which new classes are generated.
    Often, the new classes extend or implement the annotated class or interface but
    remain separate. These are really just a subset of model based boilerplate generators
    where the model input model is annotated Java classes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数仅将带注解的类作为输入，从中生成新类。通常，新类扩展或实现带注解的类或接口，但仍保持独立。这实际上只是基于模型的样板生成器的一个子集，其中输入模型是带注解的Java类。
- en: Some (such as project Lombok) update the annotated classes themselves, adding
    additional behavior. This is likely to increase both surprise and friction which
    are discussed below.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些（如项目Lombok）会更新带注解的类本身，添加额外的行为。这可能会增加*惊喜*和*摩擦*，下文将讨论这些问题。
- en: Downsides
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺点
- en: There are clearly a lot of upsides to code generators, so why wouldn't they
    always make sense?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，代码生成器有很多优点，那么为什么它们不总是合理呢？
- en: The main issues they cause are *surprise* and *friction*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它们引起的主要问题是*惊喜*和*摩擦*。
- en: Surprise
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 惊喜
- en: If you generate code at compile or runtime the you are no longer programming
    in Java.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编译或运行时生成代码，那么你就不再是在编写Java代码了。
- en: You are programming in an augmented Java that does things that developers maintaining
    the code may not be aware of.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在编写一个增强版的Java，它会做一些维护代码的开发者可能不知道的事情。
- en: It may do things that they do not expect.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会做一些他们意想不到的事情。
- en: It may break fundamental assumptions that programmers have about what can or
    cannot happen within their code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会打破程序员对于代码中可以发生什么或不能发生什么的基本假设。
- en: Runtime generators will usually generate more surprise than compile time systems
    - they add an element of *magic* that breaks the usual Java rules. Runtime generators
    also often weaken type safety, moving classes of problem a developer would normally
    expect to occur at compile time to runtime.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时生成器通常会比编译时系统生成更多的惊喜 - 它们添加了一个打破通常Java规则的*魔法*元素。运行时生成器通常也会削弱类型安全性，将开发者通常期望在编译时发生的问题类别移动到运行时。
- en: The first time a developer encounters a code generator in a project, everything
    it does will be surprising.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者在项目中第一次遇到代码生成器时，它所做的一切都会让人惊讶。
- en: After a period of learning, most of the surprise should go away but each developer
    will need to go through this learning period. The learning involved can be significant
    - gaining a complete understanding of framework such as Spring is, for example,
    a significant effort.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段学习之后，大部分的惊喜应该会消失，但每个开发者都需要经历这个学习期。所涉及的学习可能是显著的 - 比如完全理解Spring这样的框架是一个显著的努力。
- en: The most worrying problem is when there is still some surprise left after the
    initial learning period.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人担忧的问题是在最初的学习期之后仍然存在一些惊喜。
- en: If you find yourself asking the question "could this be because of the code
    generator?" when something unexpected happens with your system, and having to
    eliminate that possibility each time, then you have introduced a very real cost
    into your project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在系统出现意外情况时你发现自己问自己“这可能是因为代码生成器吗？”并且每次都必须排除这种可能性，那么你已经为项目引入了一个非常真实的成本。
- en: Friction
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 摩擦
- en: Code using compile-time generators will not import cleanly into IDEs unless
    the IDE understands how to run the generator. Even when the system is supported
    by an IDE it may require plugins to be installed, configuration options to be
    set etc.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译时生成器的代码在IDE中不会干净地导入，除非IDE知道如何运行生成器。即使系统受到IDE的支持，也可能需要安装插件、设置配置选项等。
- en: The amount of friction, and how often it is encountered, will depend on the
    IDE and the quality of the support. There may be little friction and it may only
    be encountered when a new developer joins a project. Or it may be considerable
    and triggered each time code is cleaned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 摩擦的程度以及遇到的频率将取决于IDE和支持的质量。可能会有很少的摩擦，只有在新开发者加入项目时才会遇到。或者可能会很大，并且每次清理代码时都会触发。
- en: The most effective way to reduce the friction is to package the generated code
    separately from the code that depends upon it. The generated code then becomes
    a normal binary dependency and the fact that it is automated becomes an internal
    implementation detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 减少摩擦的最有效方法是将生成的代码与依赖它的代码分开打包。生成的代码然后成为一个正常的二进制依赖项，而它是自动化的事实则成为一个内部实现细节。
- en: While this works well, it may also have a downside. It may create artificial
    modules. If the code was not auto-generated, would it have made sense to package
    it as a separate module?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样做效果很好，但也可能有一个缺点。它可能会创建人为的模块。如果代码不是自动生成的，那么将其打包为单独的模块是否有意义呢？
- en: Runtime generators do not usually introduce much friction, although sometimes
    issues might be experienced if javaagents are not present when running tests from
    the IDE.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时生成器通常不会引入太多摩擦，尽管有时在从IDE运行测试时缺少javaagents可能会遇到问题。
- en: The Trade-off
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 折衷
- en: So those are the issues.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些就是问题所在。
- en: Surprise and friction sound like minor concerns compared to the promise of functionality
    for free, but their impact can be significant.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与免费功能的承诺相比，惊喜和摩擦听起来像是次要问题，但它们的影响可能是显著的。
- en: Whether or not it makes sense to introduce a code generator often depends on
    how much it will be used. If there is a large amount of functionality that can
    be auto-generated then it probably makes sense, if the amount is relatively small
    it may be best to stick with vanilla Java.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是否引入代码生成器是否有意义通常取决于它将被使用的程度。如果有大量功能可以自动生成，那么可能是有意义的，如果数量相对较小，最好还是坚持使用原始的Java。
- en: Optimise For Readability
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为可读性进行优化
- en: Optimize for Readability not Performance
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化可读性而非性能
- en: Summary
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Don't optimize your code prematurely.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过早优化您的代码。
- en: Concentrate on making it simple and understandable instead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 集中精力使其简单易懂。
- en: Details
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: Many new programmers worry about the performance of each method they write,
    avoid code they expect to be inefficient and write in a style that attempts to
    minimize object allocations, method calls, assignments or other factors they expect
    to have a cost.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新程序员担心他们编写的每个方法的性能，避免他们认为效率低下的代码，并以试图最小化对象分配、方法调用、赋值或其他他们认为会产生成本的因素的风格编写。
- en: Although it often decreases readability and increases complexity, most micro-performance
    optimization provides no performance benefit at all.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它通常降低可读性并增加复杂性，但大多数微性能优化根本不提供性能优势。
- en: Within the context in which we work, performance should be one of the concerns
    considered last. Instead, attention should be paid to making code as simple and
    readable as possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们工作的环境中，性能应该是最后考虑的问题之一。相反，应该注意使代码尽可能简单和可读。
- en: If a performance issue arises, profiling should be used to identify where the
    problems actually lie.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现性能问题，应使用性能分析来确定问题实际所在。
- en: This does not mean the performance should be disregarded completely, but it
    should always be trumped by code readability and simplicity until it can be proven
    that there is a real benefit to optimization. Where code can be written in a more
    efficient manner without **any** increase in complexity or trade-off with readability
    then the (presumed) more efficient code should be preferred.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着性能应完全被忽略，但它应始终被代码的可读性和简单性所取代，直到可以证明优化有真正的好处为止。如果可以以更有效的方式编写代码而不增加任何复杂性或牺牲可读性，则应优先选择（假定）更有效的代码。
- en: Prefer Readable Code To Comments
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢可读性高的代码而不是注释
- en: Prefer Readable Code to Comments
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更喜欢可读性高的代码而不是注释
- en: Summary
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Use comments only to explain what you cannot make the code itself explain.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用评论解释代码本身无法解释的内容。
- en: If you are about to write a comment, first think if there is a way you could
    change the code so that it would be understandable without comments.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要写评论，请首先考虑是否有办法更改代码，使其无需注释即可理解。
- en: Details
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: From Clean Code by Robert C Martin.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Robert C Martin的《代码整洁之道》。
- en: '*"Nothing can be quite so helpful as a well-placed comment. Nothing can clutter
    up a module more than frivolous dogmatic comments. Nothing can be quite so damaging
    as an old crufty comment that propagates lies and misinformation."*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*“没有什么比一个恰到好处的评论更有帮助。没有什么比轻率的教条性评论更能混淆模块。没有什么比一个传播谎言和错误信息的陈旧评论更有害。”*'
- en: Comments should be used only to explain the intent behind code that cannot be
    refactored to explain itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 评论应仅用于解释无法重构以自我解释的代码背后的意图。
- en: '*Bad*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*糟糕*'
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Better*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*更好*'
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A comment is only useful if it explains something that the code itself cannot.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在解释代码本身无法解释的内容时，注释才有用。
- en: This means that any comments you do write should provide the **why**, not the
    what or the how
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您写的任何评论都应提供**为什么**，而不是**什么**或**如何**
- en: '*Bad*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*糟糕*'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Better*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*更好*'
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Better still*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*更好*'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the functional intent has been captured in the method name, the comment
    has been used solely to provide some context as to why the logic makes sense.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，功能意图已经在方法名中体现出来，注释仅用于提供一些上下文，解释为什么逻辑是合理的。
- en: The magic number might also be replaced with a constant.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法数字也可以替换为常量。
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The comment arguably still adds value however - if nothing else it gives a reader
    unfamiliar with the topic two key phrases to search for on the web.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，评论可能仍然有价值 - 至少它给了不熟悉该主题的读者两个关键短语在网上搜索。
- en: Javadoc Judiciously
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎使用Javadoc
- en: Javadoc Judiciously
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谨慎使用Javadoc
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Javadoc can help document code but often there are better ways to do so. Think
    carefully before deciding to write it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc可以帮助文档化代码，但通常有更好的方法来做到这一点。在决定编写之前，请仔细考虑。
- en: Details
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: Javadoc is Good
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Javadoc是好的
- en: Javadoc is invaluable for external teams that must consume your code without
    access to the source.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无法访问源代码的外部团队来说，Javadoc是无价的。
- en: All externally consumed code should have javadoc for its public methods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有外部使用的代码应该为其公共方法编写Javadoc。
- en: Ensure that all such javadoc concentrates on *what* a method does, not *how*
    it does it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有这样的Javadoc都集中在方法做什么，而不是如何做到这一点。
- en: Javadoc is Bad
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Javadoc是糟糕的
- en: Javadoc duplicates information that ought to be clear from the code itself and
    carries a constant maintenance cost.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc重复了应该从代码本身清晰看出的信息，并带来了持续的维护成本。
- en: If it is not updated in tandem with the code then it becomes misleading.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不与代码同步更新，那么它就会变得误导。
- en: Do not Javadoc code that will be consumed and maintained only by your immediate
    team. Instead spend effort ensuring that the code speaks for itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为只有你的团队使用和维护的代码编写Javadoc。相反，努力确保代码本身清晰表达。
- en: Remember Kiss And Yagni
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住Kiss和Yagni
- en: Remember KISS and YAGNI
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记住KISS和YAGNI
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Keep your design as simple as possible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能保持设计简单。
- en: Create only the functionality you need now - not what you think you might need
    in the future.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 只创建你现在需要的功能 - 而不是你认为未来可能需要的功能。
- en: Details
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: The KISS (Keep It Simple, Stupid) and YAGNI (You Ain't Going To Need It) acronyms
    provide good advice that is worth remembering while coding.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: KISS（保持简单，傻瓜）和YAGNI（你不会需要它）的首字母缩写提供了值得在编码时记住的好建议。
- en: KISS advises that we keep our code and designs as simple as possible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: KISS建议我们尽可能保持代码和设计简单。
- en: Few people would disagree with this, but unfortunately it is not always obvious
    what *simple* means.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有人会不同意这一点，但不幸的是，*简单*并不总是明显的含义。
- en: Given two solutions to a problem which one is simpler?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个问题的两个解决方案，哪个更简单？
- en: The one with the least lines of code?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个代码行数最少？
- en: The one with the least number of classes?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个类数量最少？
- en: The one that uses fewer third party dependencies?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个使用的第三方依赖更少？
- en: The one with fewer branch statements?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个分支语句更少？
- en: The one where the logic is most explicit?
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个逻辑最明确？
- en: The one which is consistent with a solution used elsewhere?
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个与其他地方使用的解决方案一致？
- en: All of the above are reasonable definitions of *simple*. None of them is the
    single definition always makes sense to follow.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以上所有都是*简单*的合理定义。没有一个是单一的定义总是有意义遵循。
- en: Recognizing simple isn't easy and keeping things simple takes a lot of work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到简单并不容易，保持事物简单需要大量工作。
- en: If we could somehow measure the complexity of our software, we would find that
    there is some minimum value that each piece of software must contain.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够衡量软件的复杂性，我们会发现每个软件片段都必须包含一些最小值。
- en: If the software were any simpler, then it would be less functional.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件再简单一点，那它就会更少功能。
- en: Real programs will always contain this *inherent complexity* plus a bit. This
    extra complexity is the *accidental complexity* we have added because we are less
    than perfect.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的程序总是包含这种*固有复杂性*加上一点。这额外的复杂性是我们添加的*偶然复杂性*，因为我们不完美。
- en: Telling accidental complexity apart from inherent complexity is of course also
    hard.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 区分偶然复杂性和固有复杂性当然也很困难。
- en: Fortunately YAGNI gives us some useful advice on how to keep things simple without
    having to tell accidental and inherent complexity apart.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，YAGNI给了我们一些建议，如何保持事物简单，而不必区分偶然和固有复杂性。
- en: The more a system does, the higher its overall complexity will be. If we make
    a system that does less, it will be simpler - it will have less *inherent complexity*
    and less *accidental complexity*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 系统做的越多，整体复杂性就越高。如果我们制作一个功能更少的系统，它将更简单 - 它将具有更少的*固有复杂性*和更少的*偶然复杂性*。
- en: Your goal is, therefore, to create the minimum amount of functionality that
    solves the problems you have right **now**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的目标是创建解决当前问题的最少功能。
- en: Don't implement things because you think you might need them later. Implement
    in the future if you need it.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要实现你认为将来可能需要的功能。如果需要，就在未来实现。
- en: Don't try and make things "flexible" or "configurable". Make them do just what
    they need to do - parameterize them at the point you have a need to do so.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要试图使事物“灵活”或“可配置”。让它们只做它们需要做的事情 - 在需要的时候对其进行参数化。
- en: If you create more than the minimum amount of functionality, you will have more
    code to debug, understand and maintain from that point forward until someone has
    the confidence to delete it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建的功能超过最小量，你将有更多代码需要调试、理解和维护，直到有人有信心删除它。
- en: Prefer Composition
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更倾向于组合
- en: Prefer Composition to Inheritance
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更倾向于组合而非继承
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Composition usually results in more flexible designs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 组合通常会导致更灵活的设计。
- en: First consider using composition, then fall back to using inheritance only when
    composition does not seem to be a good fit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑使用组合，然后只有在组合似乎不合适时才退而使用继承。
- en: Details
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Composition means building things by adding other things together. Inheritance
    is building things by extending behavior based on an existing class by creating
    a child classes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 组合意味着通过将其他东西添加到一起来构建事物。继承是通过扩展基于现有类的行为来构建事物的。
- en: 'To take a minimal example- If there is a requirement for a class to accept
    and store String values, some programmers new to Java will reach for inheritance
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个最小的例子来说- 如果一个类需要接受并存储 String 值的要求，一些新接触 Java 的程序员会选择继承如下：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The same functionality can be implemented using composition.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的功能可以使用组合来实现。
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Despite requiring more code, an experienced Java programmer would not even consider
    the first approach. So why is it that the second version is preferable?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管需要更多的代码，但有经验的 Java 程序员甚至不会考虑第一种方法。那么为什么第二个版本更可取呢？
- en: There are several overlapping explanations, we'll start with the most abstract
    and move on to more practical ones.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种重叠的解释，我们将从最抽象的开始，然后转向更实用的解释。
- en: Inheritance is a Strong Relationship
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承是一个强关系
- en: Inheritance is used to model an IS-A relationship - i.e. we are saying that
    our `InheritanceAbuse` class is an ArrayList and we should be able to pass one
    to any piece of code that accepts an ArrayList.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 继承用于建模一个 IS-A 关系 - 即，我们在说我们的`InheritanceAbuse`类是一个 ArrayList，我们应该能够将其传递给接受 ArrayList
    的任何代码片段。
- en: Composition creates a HAS-A relationship; this is a weaker relationship and
    we should always favor weaker relationships in our code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 组合创建了一个 HAS-A 关系；这是一个较弱的关系，我们应该始终在我们的代码中更倾向于较弱的关系。
- en: So favoring composition over inheritance is just one specific instance of the
    more general advice to favor weak relationships between our classes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更青睐组合而不是继承只是更一般的建议的一个具体实例，即更青睐我们类之间的弱关系。
- en: Using inheritance makes sense when there is an IS-A relationship there but it
    is an inappropriate mechanism to use purely for reusing code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在 IS-A 关系时使用继承是有意义的，但纯粹为了重用代码而使用继承是不适当的机制。
- en: Inheritance Breaks Encapsulation
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承破坏了封装
- en: The inheritance implementation fails to encapsulate an implementation detail
    - that we're storing things in an ArrayList.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 继承实现未封装一个实现细节 - 我们正在一个 ArrayList 中存储东西。
- en: 'The interface to our class includes all sort of methods from ArrayList such
    as:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类的接口包括从 ArrayList 中提取的各种方法，例如：
- en: clear
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除
- en: remove
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除
- en: contains
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含
- en: Do these methods make sense for our class? If someone calls them, could it interfere
    with the logic in `performBusinessLogic`?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法对我们的类有意义吗？如果有人调用它们，是否会干扰`performBusinessLogic`中的逻辑？
- en: We don't know enough about what our example class is meant to do to answer these
    questions definitively, but the answer is most likely that we would prefer not
    to expose these methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的示例类的作用了解不够，无法明确回答这些问题，但答案很可能是我们宁愿不暴露这些方法。
- en: If we switch from ArrayList to some other list implementation this is visible
    to the classes clients. Code that previously compiled may now break even if no
    methods specific to ArrayList are called - the change of type alone might cause
    compilation failures.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 ArrayList 切换到其他列表实现，则此更改对类的客户端可见。即使不调用特定于 ArrayList 的方法，以前编译的代码现在可能会中断
    - 仅仅更改类型就可能导致编译失败。
- en: We Can Only Do This Once
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们只能这样做一次
- en: Java doesn't support multiple inheritance so we only get to pick one thing to
    extend. If our class also needed to store Integers then inheritance isn't even
    an option so we'd have to use composition.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Java 不支持多重继承，所以我们只能选择一个要扩展的东西。如果我们的类还需要存储整数，那么继承甚至都不是一个选项，所以我们必须使用组合。
- en: Composition is inherently more flexible in single inheritance languages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一继承语言中，组合本质上更加灵活。
- en: Composition Aids Testing
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组合有助于测试
- en: This is not relevant to our simple example, but it is trivial to test how classes
    linked together by composition interact. It is far harder when inheritance is
    used.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们简单示例无关，但通过组合连接在一起的类如何交互是微不足道的。当使用继承时，测试它们之间的交互要困难得多。
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is easy to inject a mock into `MyClass`. Tricks exist to isolate the code
    in `MyUntestableClass` from `SomeDependency` for the purpose of unit testing,
    but they are far more involved.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将模拟对象注入`MyClass`很容易。存在一些技巧来将`MyUntestableClass`中的代码与`SomeDependency`隔离，以进行单元测试，但它们要复杂得多。
- en: Inheritance is Static
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承是静态的
- en: Inheritance sets a fixed relationship between concrete classes at compile time.
    With composition it is possible to swap in different concrete classes at runtime.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 继承在编译时设置了具体类之间的固定关系。使用组合可以在运行时替换不同的具体类。
- en: Again composition is inherently more flexible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，组合本质上更灵活。
- en: Interface Inheritance
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口继承
- en: The advice to prefer composition to inheritance refers to *implementation inheritance*
    (i.e. extending a class). The disadvantages discussed above do not apply to *interface
    inheritance* (i.e. implementing an interface).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于使用组合而不是继承的建议是指*实现继承*（即扩展类）。上述讨论的缺点不适用于*接口继承*（即实现接口）。
- en: In fact, the design choice you often have to make is between implementation
    inheritance or a combination of composition and interface inheritance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您经常需要做的设计选择是实现继承还是组合和接口继承的结合。
- en: In these situations, the advice is still to prefer the approach that uses composition.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，建议仍然倾向于使用组合的方法。
- en: 'For example, the well known composition based Decorator pattern:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，众所周知的基于组合的装饰者模式：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Could also be implemented using inheritance
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用继承实现
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But, again, this solution would be less flexible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，再次说，这种解决方案会更不灵活。
- en: With the composition based version we can decorate any `Processor`. With the
    inheritance version we would need to re-implement the decorator for each concrete
    type to which we wished to add the upper case behavior.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组合的版本，我们可以装饰任何`Processor`。使用继承版本，我们需要为每个我们希望添加大写行为的具体类型重新实现装饰者。
- en: Many common OO patterns rely on the combination of Composition and interface
    inheritance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的OO模式依赖于组合和接口继承的结合。
- en: When to Use Implementation Inheritance
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用实现继承
- en: Almost anything that can be achieved with implementation inheritance can also
    be achieved using the combination of interface inheritance and composition.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何可以使用实现继承实现的内容也可以使用接口继承和组合的结合实现。
- en: So when should implementation inheritance be used?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么何时应该使用实现继承呢？
- en: Implementation inheritance has one single advantage over composition - it's
    less verbose.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承在编写时比较简洁。
- en: So implementation inheritance should be used when **both** of the following
    conditions are met
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当**同时**满足以下两个条件时，应该使用实现继承
- en: There is an IS-A relationship to be modelled
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个需要建模的IS-A关系
- en: The composition based approach would result in too much boilerplate code
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于组合的方法将导致过多的样板代码
- en: The 2nd point is unfortunately entirely subjective.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点遗憾地完全是主观的。
- en: Keep It Solid
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符合SOLID原则
- en: Keep It SOLID
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符合SOLID原则
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: The SOLID acronym provides some guidance on design that you should follow.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID首字母缩写提供了一些应该遵循的设计指导。
- en: '**S**ingle Responsibility Principle'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**'
- en: '**O**pen Closed Principle'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**'
- en: '**L**iskov Substitution Principle'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**'
- en: '**I**nterface Segregation Principle'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**'
- en: '**D**ependency Inversion Principle'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转原则**'
- en: Details
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Single Responsibility Principle
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Separate your concerns - a class should do one thing and one thing only. To
    put it another way, a class should have a single reason to change.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的关注点分开 - 一个类应该只做一件事情。换句话说，一个类应该只有一个改变的理由。
- en: Open / Closed Principle
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开闭原则
- en: You should be able to extend behavior, without modifying existing code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够扩展行为，而无需修改现有代码。
- en: '*".. you should design modules that never change. When requirements change,
    you extend the behavior of such modules by adding new code, not by changing old
    code that already works."*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*"… 您应该设计永远不会更改的模块。当需求变化时，通过添加新代码来扩展此类模块的行为，而不是通过更改已经运作的旧代码。"*'
- en: '*— Robert Martin*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*— 罗伯特·马丁*'
- en: An indication that you might not be following this principle is the presence
    of `switch` statements or `if/else` logic in your code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表明您可能没有遵循这一原则的迹象是您的代码中存在`switch`语句或`if/else`逻辑。
- en: Liskov Substitution Principle
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: Derived classes must be substitutable for their base classes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类必须能替换其基类。
- en: One indication that you are breaking this principle is the presence of `instanceof`
    statements in your code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 表明您违反这一原则的一个迹象是您的代码中存在`instanceof`语句。
- en: Interface Segregation Principle
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The Interface Segregation Principle states that clients should not be forced
    to implement interfaces they don't use; prefer small, tailored interfaces to large,
    catch-all ones.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则规定，客户端不应被强制实现他们不使用的接口；更喜欢小而精细的接口而不是大而笼统的接口。
- en: One indication that you might be breaking this principle is the presence of
    empty methods or methods throwing `OperationNotSupportedException` in your code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏这个原则的一个迹象是在你的代码中存在空方法或抛出 `OperationNotSupportedException` 的方法。
- en: Dependency Inversion Principle
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖反转原则。
- en: High-level modules should not depend upon low-level modules. Both should depend
    upon abstractions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 高层模块不应该依赖于低层模块。两者都应该依赖于抽象。
- en: Abstractions should never depend upon details. Details should depend upon abstractions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象不应该依赖于细节。细节应该依赖于抽象。
- en: 'In practice this means you should follow one of two patterns:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着你应该遵循以下两种模式之一：
- en: Package the interfaces a 'high-level' component depends upon with that component
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“高级”组件所依赖的接口与该组件一起打包。
- en: Package the interface a component depends upon separately from both the client
    and implementation
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件所依赖的接口与客户端和实现分开打包。
- en: This first approach is classic dependency inversions (contrast it with the traditional
    approach of have the high level component depend upon the lower layers).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一种方法是经典的依赖反转（与将高级组件依赖于较低层的传统方法相对比）。
- en: The second approach is known as the "Separated Interface Pattern". It is a little
    more heavy weight, but also more flexible as it makes no assumption about who
    should own the interface.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法被称为“分离的接口模式”。它稍微重量级一些，但更加灵活，因为它不做任何关于谁应该拥有接口的假设。
- en: An indication that you are breaking this principle is the presence of package
    cycles within your code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏这个原则的一个迹象是你的代码中存在循环依赖。
- en: Keep Your Code Dry
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持你的代码干燥。
- en: Keep Your Code DRY
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持你的代码干燥。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要。
- en: Don't Repeat Yourself (DRY) - avoid writing the same logic more than once.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重复自己（DRY）- 避免多次编写相同的逻辑。
- en: Every time you copy and paste code, flick yourself in the eye. This is a great
    disincentive to doing it again but over time may cause blindness.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每次复制粘贴代码时，都给自己眼睛一击。这是一个很好的阻止复制粘贴的办法，但随着时间的推移可能会导致失明。
- en: Details
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节。
- en: If the same logic is required more than once then it should not be duplicated;
    it should instead, be extracted to a well named class or method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同样的逻辑需要多次，则不应该重复；而应该提取到一个命名合适的类或方法中。
- en: This will be both easier to read and easier to maintain because a change will
    only be required in one place should the logic need to change.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更易于阅读和维护，因为逻辑需要更改时只需要在一个地方进行更改。
- en: '*Bad*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*糟糕的*'
- en: '[PRE12]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Better*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*更好的*'
- en: '[PRE13]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Things are a little trickier when we have similar but not identical logic.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有类似但不相同的逻辑时，事情就会变得有些棘手。
- en: Although it is quick and easy, the worst thing we can do is copy and paste.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很快很容易，但我们能做的最糟糕的事情就是复制粘贴。
- en: '**Terrible**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**可怕的**'
- en: '[PRE14]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This seemed quick and easy now, but is the start of a codebase that will suck
    time each time we try to understand or change it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来很快很容易，但这是一个每次我们试图理解或改变它时都会消耗时间的代码库的开始。
- en: A straightforward but very limited approach to re-use code is to introduce Boolean
    flags.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单但非常有限的重用代码的方法是引入布尔标志。
- en: '**Not great**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**不是太好**'
- en: '[PRE15]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is ugly and gets worse as the number of possibilities increases.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这很丑陋，在可能性增加时会变得更糟。
- en: A much more scalable approach is to use the Strategy pattern.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 更可扩展的方法是使用策略模式。
- en: 'If we introduce an interface:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们引入一个接口：
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we can use it as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样使用它：
- en: '**Better**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的**'
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Java 7 version is quite verbose due to the anonymous inner class boiler
    plate.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于匿名内部类样板代码，Java 7 版本相当冗长。
- en: Arguably, Boolean flags might be preferable for very simple cases such as this
    but, if we extract the logic in `performSideEffect` and `performDifferentSideEffect`
    methods into top-level classes implementing `WidgetAction`, then the Strategy
    version becomes compelling.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，对于非常简单的情况，布尔标志可能更可取，但是，如果我们将 `performSideEffect` 和 `performDifferentSideEffect`
    方法中的逻辑提取到实现 `WidgetAction` 的顶级类中，那么策略版本就变得令人信服。
- en: In Java 8, there is little question that the Strategy pattern is preferable
    in even the simplest of cases.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中，即使在最简单的情况下，策略模式也是更可取的。
- en: '**Better with Java 8**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Java 8 更好**'
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We do not need to introduce our own interface - the built-in `Consumer<T>` is
    enough. We should consider introducing one if the `doThings` method were exposed
    publicly or if the logic in `performSideEffect` was complex enough to pull into
    a top-level class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要引入自己的接口 - 内置的`Consumer<T>`就足够了。如果`doThings`方法被公开暴露，或者`performSideEffect`中的逻辑足够复杂以至于需要提取到顶层类中，我们应该考虑引入一个接口。
- en: The loop might also be converted to a pipeline.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 循环也可以转换为管道。
- en: '**As a pipeline**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**作为管道**'
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Prefer Reversible Decisions
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢可逆的决策
- en: Prefer Reversible Decisions
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更喜欢可逆的决策
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Prefer design decisions that will be easy to change.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 更喜欢易于更改的设计决策。
- en: Details
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: Many of the decisions you make while designing your code will eventually turn
    out to be wrong.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计代码时做出的许多决策最终会被证明是错误的。
- en: If you can make your decisions reversible by containing their consequences and
    adding abstractions then this future change will not matter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以通过包含其后果和添加抽象使决策可逆，那么这种未来的变化就不重要。
- en: For example - if you introduce a third party library and reference it throughout
    your code, then you have made high the cost of reversing the decision to use that
    library. If you constrain it to a single location and create an interface for
    it, the cost of reversing the decision is low.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 - 如果您引入第三方库并在整个代码中引用它，那么撤销使用该库的决定的成本就会很高。如果将其限制在一个位置并为其创建一个接口，则撤销决定的成本就很低。
- en: But don't forget KISS and YAGNI - if your abstractions complicate the design
    then it is better to leave them out.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要忘记KISS和YAGNI - 如果您的抽象使设计复杂化，那么最好将其排除。
- en: Make Dependencies Explicit
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确表明依赖关系
- en: Make Dependencies Explicit and Visible
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确和可见地表明依赖关系
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Make sure that the dependencies of a class are clearly visible.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 确保类的依赖关系是清晰可见的。
- en: Always inject dependencies into a class using its constructor. Do not use other
    methods such as setters or annotations on fields.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用构造函数将依赖项注入类中。不要使用其他方法，如setter或字段上的注解。
- en: Never introduce dependencies using hidden routes such as `Singletons` or `ThreadLocals`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用隐藏路径（如`Singletons`或`ThreadLocals`）引入依赖关系。
- en: Details
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: Code is easier to understand if the interfaces and classes that each object
    depends on are conspicuous and visible.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个对象依赖的接口和类都是显眼可见的，代码就更容易理解。
- en: The most visible dependencies are the ones that are injected into a method as
    a parameter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最显眼的依赖关系是作为参数注入方法中的依赖关系。
- en: Less visible are the ones stored as fields but, depending on how those fields
    are populated, the dependencies can still be relatively easy to discover.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 存储为字段的依赖关系不太显眼，但是根据这些字段如何填充，依赖关系仍然相对容易发现。
- en: Constructor Injection
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: Constructor dependency injection clearly communicates an object's dependencies
    in a single location and ensures objects are only ever created in valid states.
    It allows fields to be made **final** so that their life cycle is unambiguous.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数依赖注入清晰地传达了对象的依赖关系，并确保对象只能在有效状态下创建。它允许字段被设为**final**，以便它们的生命周期是明确的。
- en: This is the only way in which dependencies should be injected.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是注入依赖关系的唯一方式。
- en: Setter Injection
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Setter注入
- en: Setter injection increases the number of possible states an object could be
    in. Many of those states will be invalid.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Setter注入增加了对象可能处于的状态数量。其中许多状态将是无效的。
- en: If setter injection is used, a class can be constructed in a half-initialized
    state. What constitutes a fully-initialized state can only be determined by examining
    the code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用setter注入，类可能以半初始化状态构造。什么构成完全初始化状态只能通过检查代码来确定。
- en: '**Bad**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕**'
- en: '[PRE20]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, a `NullPointerException` will be thrown if `Foo` is constructed without
    calling `setBar`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果构造`Foo`时没有调用`setBar`，将抛出`NullPointerException`。
- en: '**Better**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好**'
- en: '[PRE21]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, it is clear that we must supply a `Bar` as we are unable to construct
    the class without it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，很明显我们必须提供一个`Bar`，因为没有它我们无法构造这个类。
- en: Field Annotations
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字段注解
- en: While annotations on fields seem convenient they mean that the dependency will
    not be visible in the public API. They also tie construction of your class to
    the frameworks that understand them and prevent fields from being made final.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字段上的注解看起来很方便，但这意味着依赖关系在公共API中不可见。它们还将类的构造与理解它们的框架联系起来，并阻止字段被设为final。
- en: Field annotations should not be used.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该使用字段注解。
- en: If you are working with a dependency injection framework such as Spring, either
    move construction of your objects into configuration classes or restrict the use
    on annotations to constructors. Both methods allow your classes to be constructed
    normally and ensure that all dependencies are visible.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用诸如 Spring 等依赖注入框架，请将对象的构建移动到配置类中或将注解的使用限制在构造函数上。这两种方法都允许正常构造您的类，并确保所有依赖关系可见。
- en: Hidden Dependencies
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 隐藏的依赖
- en: Anything that is not injected into a class using a constructor or as a method
    parameter is a hidden dependency.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不是使用构造函数或方法参数注入到类中的东西都是隐藏的依赖。
- en: These are evil.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是邪恶的。
- en: They are pulled in from `Singletons`, `ThreadLocals`, static method calls or
    by simply calling `new`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是从`Singletons`，`ThreadLocals`，静态方法调用或者简单地调用`new`引入的。
- en: '**Bad**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**不好**'
- en: '[PRE22]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we must ensure that the `Database` class is in a valid state before calling
    the `doThings` method of the code below, but we have no way of knowing this without
    looking through every line of code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须确保在调用下面代码的 `doThings` 方法之前 `Database` 类处于有效状态，但是我们没有办法知道这一点，除非查看每一行代码。
- en: '**Better**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好**'
- en: '[PRE23]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Injecting via the constructor makes the dependency clearly visible.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造函数注入使依赖性清晰可见。
- en: By definition, hidden dependencies are hard to discover but they have a second
    issue - they are also hard to replace.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，隐藏的依赖是难以发现的，但它们还有第二个问题 - 它们也难以替换。
- en: Seams
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Seams
- en: Seams are a concept introduced by Michael Feathers in "Working Effectively with
    legacy code"
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Seams 是由 Michael Feathers 在 "Working Effectively with legacy code" 中介绍的一个概念。
- en: 'He defines it as:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 他定义它为：
- en: '"a place where you can alter behavior in your program without editing in that
    place."'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"一个可以在程序中修改行为而不在该地方编辑的地方。"'
- en: In the original version of `HiddenDependencies` if we wanted to replace `Database`
    with a mock or stub we could only do so if the singleton provided some method
    to modify the instance it returns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HiddenDependencies` 的原始版本中，如果我们想要用一个模拟或存根来替换 `Database`，我们只能在单例提供一些方法来修改它返回的实例的情况下这样做。
- en: '**Not a good approach**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**不是一个好方法**'
- en: '[PRE24]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This approach introduces a seam but does not address our concerns around visibility.
    The dependency remains hidden.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法引入了一个接缝，但并未解决我们对可见性的担忧。依赖性仍然隐藏。
- en: If we used this approach, our codebase would remain hard to understand and we
    would find ourselves constantly fighting test order dependencies.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采用这种方法，我们的代码库将仍然难以理解，我们将不断地与测试顺序依赖进行斗争。
- en: With constructor injection, we gain a seam and make the dependency visible.
    Even if `Database` is a singleton, we are still able to isolate our code from
    it for testing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数注入，我们获得了一个接缝并使依赖性可见。即使 `Database` 是一个单例，我们仍然可以将我们的代码与之隔离以进行测试。
- en: Prefer Immutable Objects
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢不可变对象
- en: Prefer Immutable Objects
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更喜欢不可变对象
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概要
- en: Where possible, create objects that cannot be changed - especially if those
    objects will be long-lived or globally accessible.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，创建不能被更改的对象 - 特别是如果这些对象将是长期存在或全局可访问的。
- en: Details
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Mutable state makes programs harder to understand and maintain.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可变状态使程序变得更难理解和维护。
- en: When objects are short-lived, and do not leave method scope, mutable state causes
    few problems. Writes and reads will be close together and there will be a clear
    order in which this happens.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的生命周期短暂且不离开方法范围时，可变状态几乎不会造成问题。写入和读取将会紧密地相邻，并且会有一个清晰的顺序。
- en: For longer-lived objects, things are more complex.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较长寿命的对象，情况更加复杂。
- en: If an object escapes from a method then it may be accessed from more than one
    location within the code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象从一个方法中逃逸出来，那么它可能会在代码中的多个位置被访问到。
- en: We must start by assuming that anything that can happen to these objects will.
    We can only confirm that certain situations do not occur by examining the whole
    program.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先假设这些对象可能发生的任何事情都会发生。我们只能通过检查整个程序来确认某些情况不会发生。
- en: The set of things that might happen to an immutable object is far smaller than
    for a mutable one. By constraining how long lived objects can behave we have made
    things simpler. There are fewer possibilities that we must consider.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 与可变对象相比，不可变对象可能发生的事情的范围要小得多。通过限制长期存在的对象的行为方式，我们使事情变得更简单。我们需要考虑的可能性更少。
- en: Unfortunately, it is not always easy to tell from a class definition what the
    lifecycle of objects of that type will be. Perhaps only short-lived instances
    will be created. Perhaps only long-lived ones. Perhaps a mixture of the two.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，从类定义中并不总是容易看出该类型对象的生命周期将是什么样的。也许只会创建短寿实例。也许只会创建长寿实例。也许两者都有。
- en: If we design immutable classes by default we do not need to worry about this.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们默认设计不可变类，我们就不需要担心这个问题。
- en: The Problem With Mutable Objects
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可变对象的问题
- en: If we have a very simple class such as `Foo`
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个非常简单的类，比如`Foo`
- en: '[PRE25]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We would need to search our codebase for all usages of it to establish the
    following :'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要搜索我们的代码库以确定以下内容：
- en: It is Never Accessed from Multiple Threads
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从多个线程中永远不会访问
- en: '`Foo` is not thread safe.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foo`不是线程安全的。'
- en: Writes to longs are not atomic and nothing within `Foo` itself establishes a
    happens-before relationship between the field write and read.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对long的写入不是原子的，`Foo`本身没有建立字段写入和读取之间的happens-before关系。
- en: If `setId` and `getId` are ever called from different threads we might get back
    stale or garbage values.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`setId`和`getId`从不同线程调用，我们可能会得到过时或垃圾值。
- en: '`setId` Is Never Called After `Foo` Has Been Placed in a Set'
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在`Foo`被放入集合后从未调用`setId`
- en: The `hashcode` of this class relies on a mutable field. If we modify it after
    we place it in a set then our program will not behave as we expect.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的`hashcode`依赖于一个可变字段。如果我们在将其放入集合后修改它，那么我们的程序将不会按照我们的期望行为。
- en: The Flow of Our Data
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们数据的流动
- en: Even if our program behaves correctly, we need to do work in order to understand
    how it functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的程序表现正确，我们仍需要做一些工作来理解它的功能。
- en: '`setId` can be called at any point after the object is created. We can, therefore,
    only understand how data flows through our program by looking for all calls to
    `setId` - perhaps there are several, perhaps there is only one. The only way we
    can discover this is by examining the entire program.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`setId`可以在对象创建后的任何时候调用。因此，我们只能通过查找所有对`setId`的调用来理解数据在程序中的流动方式 - 可能有几个，也可能只有一个。我们能发现这一点的唯一方法是检查整个程序。'
- en: Immutable Objects
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不可变对象
- en: If we can make our objects immutable we gain guarantees that mean we do not
    need to worry about how our objects are used.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以使我们的对象不可变，我们将获得保证，无需担心对象的使用方式。
- en: '[PRE26]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It no longer matters if `Foo` is long or short lived.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foo`是长寿还是短寿已经不再重要。'
- en: It is inherently thread-safe.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 它本质上是线程安全的。
- en: We know that whatever value we construct it with will remain until it dies.
    There is only one possible point where data is written so we do not need to search
    for others.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们构造的任何值都将保持不变直到它死去。只有一个可能的数据写入点，因此我们不需要搜索其他地方��
- en: Annotations
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注解
- en: The example uses the JSR3051 `javax.annotation.concurrent.Immutable` annotation.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用JSR3051 `javax.annotation.concurrent.Immutable`注解。
- en: This does not in any way change the object's functionality but provides a way
    to communicate the intent of this being an immutable class. Static analysis tools
    such as [Mutablility Detector](https://github.com/MutabilityDetector/MutabilityDetector)
    can check if this intent has been violated.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不以任何方式改变对象的功能，但提供了一种传达这个类是不可变的意图的方式。静态分析工具，比如[Mutablility Detector](https://github.com/MutabilityDetector/MutabilityDetector)，可以检查这个意图是否被违反。
- en: We can tell at a glance that `Foo` is immutable as it has final fields of a
    well known immutable type.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼就能看出`Foo`是不可变的，因为它有一个已知的不可变类型的final字段。
- en: The `final` keyword ensures only that the reference a field points to will not
    change.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`关键字只确保字段指向的引用不会改变。'
- en: If the field were of type `Bar` then we would not know if it were mutable or
    not without examining `Bar` to see if it too were immutable. Even if we were not
    using a static analysis tool the use of the `Immutable` annotation would make
    this assessment faster.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段是`Bar`类型，那么我们不知道它是否可变，除非检查`Bar`以查看它是否也是不可变的。即使我们不使用静态分析工具，使用`Immutable`注解也会加快这一评估过程。
- en: Instead of updating the state of immutable objects, we create new instances
    that retain the state we do not wish to modify.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是更新不可变对象的状态，我们创建保留我们不希望修改的状态的新实例。
- en: This pattern seems strange to some Java programmers at first, but the programming
    model is similar to how the familiar `String` class works.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对一些Java程序员来说起初似乎很奇怪，但编程模型类似于熟悉的`String`类的工作方式。
- en: '[PRE27]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Instances of `Bar` with new values can be obtained by calling `withAString`
    and `withAnInt`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过调用`withAString`和`withAnInt`获得具有新值的`Bar`实例。
- en: The JSR305 `javax.annotation.CheckReturnValue` enables static analysis tools
    such as [Error Prone](https://github.com/google/error-prone) to issue a warning
    if a mistake is made such as in the code below.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: JSR305 `javax.annotation.CheckReturnValue` 允许静态分析工具（如 [Error Prone](https://github.com/google/error-prone)）在发现错误（例如下面的代码中）时发出警告。
- en: '[PRE28]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The call here to `withAnInt` achieves nothing because the return value is not
    stored. Most likely, the programmer intended to write:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里调用 `withAnInt` 不会产生任何效果，因为返回值没有存储。最有可能的是，程序员打算写：
- en: '[PRE29]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When to Use Mutable Objects
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用可变对象
- en: Mutable objects require slightly less boilerplate to create than immutable ones.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象比不可变对象稍微少些样板代码。
- en: If you know that a class will only ever be used to create short-lived, local
    objects then you might consider making it mutable. But you must weigh this against
    the additional work required to ensure that the class is only ever used in this
    fashion as the codebase grows.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道一个类只会用于创建短暂的局部对象，那么你可能会考虑使其可变。但是你必须权衡这一点，因为随着代码库的增长，需要确保该类只用于这种方式会增加额外的工作量。
- en: Options exist to auto-generate both immutable and mutable classes, thereby removing
    mutable objects' main advantage. Two of these options are discussed further in
    "Know How to Implement Hashcode and Equals".
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 存在选项可以自动生成不可变和可变类，从而消除了可变对象的主要优势。这些选项中的两个在“了解如何实现 Hashcode 和 Equals”中进一步讨论。
- en: Mutable objects used to be the norm in Java. As a result, many common frameworks
    require mutable objects. Persistence and serialization frameworks often require
    Java beans with no args constructors and setters. Other frameworks might require
    you to use two-stage construction with a lifecycle method such as init.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象曾经是 Java 中的常态。因此，许多常见的框架需要可变对象。持久化和序列化框架通常需要没有参数构造函数和设置器的 Java beans。其他框架可能要求您使用两阶段构造，其中包括初始化等生命周期方法。
- en: It is not always highlighted in the documentation but some long standing frameworks
    have been updated to support immutable objects.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文档中并不总是突出显示，但一些长期存在的框架已经更新以支持不可变对象。
- en: Jackson for example now allows constructors and factory methods to be annotated
    :-
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Jackson 现在允许构造函数和工厂方法进行注释：
- en: '[PRE30]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Other frameworks, such as Hibernate, can only be used with classes that provide
    a default constructor. Although they can be configured to set fields directly
    without the need for setters this causes more problems than it solves.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 其他框架，如 Hibernate，只能与提供默认构造函数的类一起使用。虽然它们可以配置为直接设置字段而无需使用设置器，但这样做会引起更多问题。
- en: If you are tied to a framework that requires mutability then you will need to
    use mutable objects where you interface with that framework.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你受限于一个需要可变性的框架，那么你将需要在与该框架进行接口时使用可变对象。
- en: Use A Consistent Code Layout
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用一致的代码布局
- en: Use a Consistent Code Layout Within Each Project
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在每个项目中使用一致的代码布局
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Agree and enforce a standard code formatting scheme within each codebase.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个代码库中达成一致并强制执行标准的代码格式方案。
- en: Detail
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: The way in which Java code is formatted and laid out is largely a matter of
    personal preference.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Java 代码的格式和布局主要是个人喜好的问题。
- en: Some styles (such as omitting braces in conditional statements) can arguably
    make certain types of bug slightly more likely.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有些风格（例如在条件语句中省略大括号）可以认为会使某些类型的错误稍微更有可能。
- en: Others might require more work to keep the code compliant (such as aligning
    fields into columns) but, to a first approximation, no particular scheme is greatly
    superior to any other.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 其他风格可能需要更多的工作来保持代码的一致性（例如将字段对齐成列），但是总的来说，没有哪种特定方案比其他方案优越得多。
- en: Despite this, programmers tend to have strong opinions on the matter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，程序员对此事往往有着强烈的意见。
- en: Every codebase should, however, have a single agreed formatting style which
    is consistently applied and is understood by everyone working on that codebase.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代码库都应该有一个统一的约定格式样式，该样式应该得到一致应用，并且被所有在该代码库上工作的人所理解。
- en: This prevents commit wars in which different team members re-format things to
    their personal preference. It also makes code easier to understand as there is
    a cognitive cost for the reader if formatting changes radically from file to file.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止提交战争，其中不同团队成员会根据个人喜好重新格式化代码。这也使得代码更易于理解，因为如果格式在文件之间发生根本性变化，则读者会有认知成本。
- en: Although there is value in consistency, there is also a cost.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一致性很重要，但也有成本。
- en: Unless there is already broad agreement across teams about how things should
    be formatted, trying to enforce one official set of rules is likely to create
    more ill will than benefit.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果团队之间已经就应该如何格式化内容达成广泛一致，试图强制执行一套官方规则很可能会带来更多的不满而非好处。
- en: A global preferred reference should therefore be set, but teams should be free
    to deviate from this as they see fit as long as a consistent style is used for
    the code they maintain.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 因此应该设置一个全局首选参考，但是团队应该自由地偏离这个参考，只要它们维护的代码使用一致的风格即可。
- en: Suggested Formatting Rules
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建议的格式化规则
- en: If your do not have your own strong preferences we suggest you follow the [Google
    Java Style](https://google.github.io/styleguide/javaguide.html).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有自己的强烈偏好，我们建议你遵循[Google Java Style](https://google.github.io/styleguide/javaguide.html)。
- en: These formatting rules are well thought out, clearly documented and not overly
    prescriptive.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式化规则经过深思熟虑，文档清晰，不过于规范。
- en: We will not describe them in any detail here, but code formatted to these rules
    will look something like the following :-
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细描述它们，但是按照这些规则格式化的代码将看起来类似于以下内容：
- en: '[PRE31]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, we suggest that the guidance in the Google guide on when to write Javadoc
    is ignored in favor of our own.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们建议忽略谷歌指南中关于何时编写 Javadoc 的指导，而采用我们自己的指导。
- en: Notable Points About This Style
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于这种风格的显著特点
- en: Spaces not Tabs
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用空格而不是制表符
- en: Tabs may appear differently depending on how an editor is configured. This will
    result in constant reformatting as different programmers adapt the file to their
    editor settings. Spaces avoid this problem.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 制表符的外观可能因编辑器的配置方式而有所不同。这将导致不同的程序员根据他们的编辑器设置不断重新格式化文件。使用空格可以避免这个问题。
- en: In some languages (e.g. JavaScript before the rise of code minifiers) tabs have/had
    an advantage as they reduced the size of the source file compared to using multiple
    spaces. The increase in size of the source file is of no relevance for Java.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中（例如，在代码最小化器出现之前的 JavaScript 中），制表符具有/曾经具有优势，因为它们可以减小源文件的大小，而不是使用多个空格。对于
    Java 来说，源文件的增加大小不相关。
- en: One True Brace Style
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 唯一的大括号风格
- en: There are various arguments about the supposed advantages of this style, but
    we suggest its use mainly because it is common in the Java community.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种风格的所谓优势有各种争论，但我们主要建议使用它是因为它在 Java 社区中很常见。
- en: Although simple `if else` statements can be more concisely written by omitting
    the braces we suggest that they are always included. This reduces the chance of
    a statement being placed outside the conditional when this was not the intent.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的`if else`语句可以通过省略大括号更简洁地编写，但我们建议始终包含它们。这样可以减少在意图不是这样时语句被放置在条件之外的机会。
- en: Group Methods For Easy Comprehension
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为易于理解而分组的方法
- en: Group Methods for Easy Comprehension
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为易于理解而分组的方法
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: The public methods of a class should appear at the top of the file, the private
    methods towards the bottom and any protected or package default methods in between.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 类的公共方法应该出现在文件的顶部，私有方法应该出现在底部，而任何受保护或包默认方法应该在它们之间。
- en: In addition to arranging by accessibility, they should also be ordered into
    a logical flow.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 除了按照可访问性排列外，它们还应该按照逻辑顺序排列。
- en: Detail
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: 'This scheme tries to achieve two goals:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 此方案试图实现两个目标：
- en: Highlight the public API by separating it from implementation detail
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将公共 API 与实现细节分离来突出显示公共 API
- en: Allow the reader to follow the logical flow with the minimal of scrolling
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许读者以最小的滚动量来跟随逻辑流
- en: To achieve the 2nd goal, methods should be arranged into logical groups, with
    methods always appearing above the ones they call.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现第二个目标，方法应该被分成逻辑组，其中方法始终出现在它们调用的方法之上。
- en: The two goals clearly conflict because grouping the public API methods together
    at the top of the file prevents grouping them with the implementation methods
    that they used. If this causes a large problem it may be an indication that the
    class has too many responsibilities and could be refactored into one or more smaller
    classes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个目标显然存在冲突，因为将公共 API 方法分组放置在文件顶部会阻止将它们与它们使用的实现方法分组在一起。如果这导致了一个大问题，那么这可能表明类承担了太多的责任，并且可以将其重构为一个或多个较小的类。
- en: Questions of the "correct" location of a method will also occur when an implementation
    method is called from multiple locations or methods have recursive relationships.
    There is, of course, no one right answer and any ordering that broadly meets the
    second goal may be used.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个实现方法从多个位置调用或方法具有递归关系时，也会出现方法的“正确”位置的问题。 当然，没有一个正确的答案，任何大致符合第二个目标的排序都可以使用。
- en: Constructors and static factory methods should usually be placed first in the
    class. The fact that a method is static should not, however, generally influence
    where it is placed.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和静态工厂方法通常应该放在类的第一位。 方法是静态的这一事实通常不会影响它应该放置的位置。
- en: '**Example**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**例子**'
- en: '[PRE32]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Fields should always be placed at the top of the class before any methods.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 字段应始终放在任何方法之前的类顶部。
- en: Keep Methods Small And Simple
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持方法小而简单
- en: Keep Methods Small and Simple
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持方法小而简单
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Keep methods small and simple.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 保持方法小而简单。
- en: Details
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: Small things are easier to understand than big things. Methods are no different.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 小东西比大东西更容易理解。 方法也不例外。
- en: One way to measure the size of a method is via the number of lines of code it
    contains.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含的代码行数来衡量方法的大小是一种方法。
- en: As a guide methods should not usually be longer than 7 lines in length. This
    is not a hard rule - just a guide of when to feel uncomfortable with a method's
    size.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 作为指南，方法的长度通常不应超过7行。这不是一个硬性规则 - 只是在何时感到不舒服的方法大小的指南。
- en: Another way to gauge the size of a method is to see how many possible paths
    there are through it. The *Cyclomatic complexity* of a method gives a measure
    of this - it will increase as the amount of conditional logic and number of loops
    grows.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通过方法的可能路径数量来衡量方法的大小是另一种方法。 方法的*Cyclomatic complexity*可用来衡量这一点 - 随着条件逻辑和循环数量的增加，它将增加。
- en: As a guide, methods should not usually have a complexity above 5\. Again, this
    is not a hard rule, just a guide of when to feel uncomfortable.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 作为指南，方法的复杂性通常不应超过5。再次强调，这不是一个硬性规则，只是在何时感到不舒服的指南。
- en: Your code will naturally contain some methods that are larger than others -
    some concepts are inherently more complex than others and the implementation will
    not become simpler if broken down further or expressed in a different way.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码自然会包含一些比其他方法更大的方法 - 有些概念本质上比其他概念更复杂，如果进一步拆分或以不同的方式表达，实现将不会变得更简单。
- en: 'But most large methods can be made smaller in one of three ways :'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 但大多数大型方法可以通过以下三种方式之一变得更小：
- en: Refactoring into a number of smaller methods
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构为多个较小的方法
- en: Re-expressing the logic
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新表达逻辑
- en: Using appropriate language features
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当的语言特性
- en: Splitting a Method into Smaller Concerns
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将方法拆分为较小的关注点
- en: Many large methods have smaller methods within them trying to find a way out.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型方法在其中有试图找到出路的较小方法。
- en: We can make our code easier to maintain by freeing them.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 通过释放它们可以使我们的代码更易于维护。
- en: '**Bad**'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕的**'
- en: '[PRE33]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Better**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的**'
- en: '[PRE34]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Re-expressing logic
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新表达逻辑
- en: '**Terrible**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**可怕的**'
- en: '[PRE35]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This can be easily re-expressed with less noise as :'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地重新表达，减少噪音：
- en: '**Better**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的**'
- en: '[PRE36]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or with a move to a more declarative style :'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 或采用更声明式的风格：
- en: '[PRE37]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Neither of the above changes alter the structure of our program or even affect
    the signature of the method. Both still reduce both line count and complexity
    while increasing readability.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以上两种变化都不会改变程序的结构，甚至不会影响方法的签名。 它们都减少了行数和复杂性，同时增加了可读性。
- en: Simplifying things with a series of higher impact changes that extract a model
    of our domain is, however, often the best approach.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一系列更高影响力的变化来简化事情，提取我们领域的模型通常是最好的方法。
- en: It is difficult to guess what this model might look like for our contrived example,
    but is likely that this conditional logic could be replaced with polymorphism.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 很难猜测我们构造的示例可能会是什么样子，但很可能可以用多态性替换这个条件逻辑。
- en: '[PRE38]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using Appropriate Language Features
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用适当的语言特性
- en: Methods are sometimes bloated by boilerplate that solves common programming
    problems. The need for some of this boilerplate has been removed by new language
    features.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 方法有时会因解决常见编程问题的模板代码而变得臃肿。 一些模板代码的需求已被新的语言特性所移除。
- en: 'Some of these *new* features aren''t all that new, but code is still written
    without them:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些*新*特性并不是那么新，但仍然有人在编写没有这些特性的代码：
- en: Java 5 Generics removes the need for ugly casts
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 5 泛型消除了丑陋的转换需求
- en: The Java 5 for-each-loop can replace code using iterators and indexed loops
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 5 的 for-each 循环可以替代使用迭代器和索引循环的代码
- en: The Java 7 try-with-resources can replace complex try, catch finally blocks
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 7 的 try-with-resources 可以替代复杂的 try、catch、finally 块
- en: The Java 7 multi-catch can replace repeated catch blocks
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 7 的多捕获可以替代重复的捕获块
- en: Java 8 lambda expressions can replace anonymous class boilerplate
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 lambda 表达式可以替代匿名类样板代码
- en: Methods Should Do One Thing
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法应该只做一件事
- en: Methods Should Do Only One Thing
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法应该只做一件事
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Methods should do only one thing.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 方法应该只做一件事。
- en: Details
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 详情
- en: A useful guide as to whether a function is doing only one thing is given in
    "Clean Code" by Robert C Martin.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 《代码整洁之道》中的一条有用指南是，一个函数是否只做一件事。
- en: '"another way to know that a function is doing more than “one thing” is if you
    can extract another function from it with a name that is not merely a restatement
    of its implementation."'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: “另一种了解函数是否做了超过“一件事”的方法是，如果您可以从中提取另一个函数，并且该函数的名称不仅仅是其实现的重新陈述。”
- en: '*Bad*'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '*糟糕*'
- en: '[PRE39]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Better*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '*更好*'
- en: '[PRE40]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*You''ve gone too far*'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '*你走得太远了*'
- en: '[PRE41]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Avoid Null
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免空值
- en: Avoid Null Whenever Possible
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽量避免使用空值
- en: Summary
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Null is a billion dollar mistake, make sure you know how to avoid using it in
    your code.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 空值是一个价值连城的错误，请确保知道如何在代码中避免使用它。
- en: 'Try to limit the times you or your clients need to write the following:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量减少您或您的客户需要编写以下内容的次数：
- en: '[PRE42]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Details
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: Although it is likely that libraries and frameworks you interact with will return
    null, you should try to ensure that this practice is isolated to third party code.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您与之交互的库和框架可能返回空值，但您应该尽量确保这种做法仅限于第三方代码。
- en: The core of your application should assume that it does not have to worry about
    null values.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序核心应该假设不必担心空值。
- en: 'Strategies to avoid null include :'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 避免空值的策略包括：
- en: The null object pattern - when you have something you think is optional
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空对象模式 - 当您认为某些内容是可选的时
- en: The type-safe null pattern (aka Option, Optional & Maybe) - when you need to
    express that an interface might not return something
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全的空模式（又称 Option、Optional 和 Maybe）- 当您需要表达接口可能不返回内容时
- en: Design by contract
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 契约式设计
- en: The Null Object Pattern
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空对象模式
- en: The null object pattern is the classic OO approach to avoiding null. You should
    use it whenever you think you have a dependency that you think is optional.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象模式是避免空值的经典面向对象方法。每当您认为有一个您认为是可选的依赖关系时，应该使用它。
- en: The pattern is very simple, just provide an implementation of the interface
    that does "nothing" or has a neutral behavior. This can then be safely referenced
    by its clients, with no need to check for null.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 模式非常简单，只需提供一个“什么也不做”或具有中立行为的接口实现。然后客户端可以安全地引用它，无需检查空值。
- en: Type-Safe Nulls (aka Optional)
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型安全的空值（又称 Optional）
- en: The type-safe null pattern is familiar in most functional programming languages
    where it is variously known as Maybe, Option or Optional. Java 8 finally adds
    an Optional type, but implementations are available for earlier versions via Guava
    and other libraries.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全的空模式在大多数函数式编程语言中都很常见，它们分别被称为 Maybe、Option 或 Optional。Java 8 最终添加了 Optional
    类型，但通过 Guava 和其他库，早期版本也提供了实现。
- en: It is a simple pattern. An Optional is basically just a box that can hold either
    one or zero values. You can check if the box is empty (using `isPresent`) and
    retrieve its value via a get method.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的模式。Optional 基本上只是一个可以容纳一个或零个值的盒子。您可以通过 `isPresent` 检查盒子是否为空，并通过 get 方法检索其值。
- en: Optional should be used whenever a public method might not return a value as
    part of normal program flow.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: Optional 应该在公共方法可能在正常程序流程中不返回值时使用。
- en: If you call get on an empty Optional, it will throw a `NoSuchElementException`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在空的 Optional 上调用 get，它将抛出 `NoSuchElementException`。
- en: It might not be immediately obvious what value Optional provides over just using
    null. If you need to check that an Optional has something in it before calling
    `get`, how is this different from checking a value is not null to avoid a `NullPointerException`?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不会立即明显 Optional 相对于仅使用空值提供了什么价值。如果您需要在调用 `get` 之前检查 Optional 中是否有内容，那么这与检查值不为空以避免
    `NullPointerException` 有何不同？
- en: There are several important differences.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个重要的区别。
- en: Firstly, if your method declares that it returns `Optional<Person>` then you
    can instantly see from the type signature that it might not return a value. If
    it only returned `Person` you would only know that it might return null if you
    looked at the source, tests or documentation.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你的方法声明返回 `Optional<Person>`，那么你可以立即从类型签名中看出它可能不会返回一个值。如果它只返回 `Person`，那么只有在查看源代码、测试或文档时才会知道它可能返回空值。
- en: Equally important, if you know that you always return `Optional` within your
    codebase when something might not be present, then you know at a glance that a
    method returning `Person` will always return a value and will never return null.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，如果你知道在代码库中总是返回 `Optional`，当某些东西可能不存在时，那么你一眼就知道返回 `Person` 的方法将始终返回一个值，永远不会返回空值。
- en: Finally, the preferred way to use Optionals is not to call the get method or
    to explicitly check if it contains a value. Instead the values that are contained
    (or not contained) in an Optional can be safely mapped, consumed and filtered
    by various method on the class.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 Optionals 的首选方式不是调用 get 方法或显式检查是否包含值。相反，Optional 中包含的值（或未包含的值）可以通过该类上的各种方法安全地映射、消费和过滤。
- en: In the simplest case a possibly empty Optional can be accessed by calling the
    `orElse` method which takes a default value to use if the Optional is empty.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，可以通过调用 `orElse` 方法来访问可能为空的 Optional，该方法接受一个默认值，如果 Optional 为空，则使用该默认值。
- en: As mentioned, the sweet spot for using Optionals is for the return types for
    methods. They should not generally be held as fields (use the null object pattern
    here instead) or passed to public methods (instead provide overloaded versions
    that do not require the parameter).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 Optionals 的最佳时机是方法的返回类型。它们通常不应作为字段保存（在这里使用空对象模式）或传递给公共方法（而是提供不需要该参数的重载版本）。
- en: One objection that is sometimes raised by Java programmers encountering Optional
    for the first time is that it is possible for an Optional to be null itself. While
    this is true, returning a null Optional from a method is a perverse thing to do
    and should be considered a coding error.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 Java 程序员第一次遇到 Optional 时提出的一个异议是，Optional 本身可能为空。虽然这是真的，但从方法返回空的 Optional
    是一种反常的做法，应该被视为编码错误。
- en: Static analysis rules exists that can check for code that returns null Optionals.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 存在可以检查返回空值 Optional 的静态分析规则。
- en: Design by Contract
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 契约式设计
- en: We wish for all code that we control to be able to ignore the existence of null
    (unless it interfaces with some third party code that forces us to consider it).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们控制的所有代码都能够忽略空值的存在（除非它与某些强制我们考虑空值的第三方代码进行交互）。
- en: '`Objects.requireNonNull` can be used to add a runtime assertion that null has
    not been passed to a method.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`Objects.requireNonNull` 可以用于添加一个运行时断言，确保空值未传递给方法。'
- en: Because your core code should generally assume that null will never be passed
    around, there is little value in documenting this behavior with tests; assertions
    add value because they ensure that an error occurs close to the point where the
    mistake was made.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你的核心代码通常应假设空值永远不会传递，所以用测试文档化这种行为的价值很小；断言很有价值，因为它们确保错误发生在错误产生的地方附近。
- en: We can also check this contract at build time.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在构建时检查这个契约。
- en: JSR-305 provides annotations that can be used to declare where null is acceptable.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: JSR-305 提供了可以用来声明接受空值的注释。
- en: Although JSR-305 is dormant, and shows no signs of being incorporated into Java
    in the near future, the annotations are available at the maven co-ordinates :-
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JSR-305 处于休眠状态，并且在不久的将来没有被纳入 Java 中的迹象，但这些注释可以在 maven 坐标处获得：-
- en: '[PRE43]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: They are supported by several static analysis tools including :-
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 它们受到几种静态分析工具的支持，包括：-
- en: '[Findbugs](http://findbugs.sourceforge.net/)'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Findbugs](http://findbugs.sourceforge.net/)'
- en: '[Error Prone](http://errorprone.info/)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Error Prone](http://errorprone.info/)'
- en: These can be configured to break the build when null is passed as a parameter
    where we do not expect it.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则可以配置为在不期望传递空值的参数时中断构建。
- en: Annotating every class, method or parameter with `@Nonnull` would quickly become
    tedious and it would be debatable whether the gain would be worth the amount of
    noise this would generate.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个类、方法或参数进行 `@Nonnull` 注释会很快变得乏味，而且是否值得产生这么多噪音是值得商榷的。
- en: Fortunately, it is possible to make `@Nonnull` the default by annotating a package
    in its package-info.java file as follows
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以通过在 package-info.java 文件中注释一个包来将 `@Nonnull` 设置为默认值，如下所示
- en: '[PRE44]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Sadly, sub-packages do not inherit their parent's annotations, so a package-info.java
    file must be created for each package.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，子包不继承其父级的注释，因此必须为每个包创建一个 package-info.java 文件。
- en: Once non null parameters have been made the default behavior, any parameters
    that do accept null can be annotated with `@Nullable`.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦非空参数成为默认行为，任何接受 null 的参数都可以用 `@Nullable` 进行注释。
- en: Use Final Liberally
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大量使用 final。
- en: Use Final Liberally
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大量使用 final。
- en: Summary
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Consider making final any variable or parameter that does not change.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使任何不会更改的变量或参数 final。
- en: Details
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Making parameters and variables that are assigned once final makes a method
    easier to understand because it constrains the things that could possibly happen
    within the code.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 使参数和只赋值一次的变量为 final 会使方法更易于理解，因为它限制了代码中可能发生的事情。
- en: It would be reasonable to make all parameters and assign-once variables final,
    but this needs to be weighed against the noise created by inserting the `final`
    keyword everywhere.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使所有参数和只赋值一次的变量 final 是合理的，但需要权衡在每处插入 `final` 关键字所带来的噪音。
- en: For short methods, whether the benefit outweighs the cost is arguable, but if
    a method is large and unwieldy then the case for making things final is much stronger.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 对于短方法来说，利弊是否超过成本是值得争议的，但如果一个方法又大又笨重，那么使事情变得 final 的理由就更加充分。
- en: Each team should agree a policy for making final variables.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队都应该就使变量 final 达成一致的政策。
- en: At a minimum, everything should be made final within large methods. This may
    also be extended to shorter methods at the team's discretion. A blanket policy
    has the advantage of being easy to automate/understand. A more nuanced policy
    is harder to communicate.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，大型方法中的所有内容都应该被设为 final。这也可以根据团队的意愿扩展到较短的方法。一项全面的政策具有易于自动化/理解的优势。更微妙的政策更难以沟通。
- en: When working with legacy code, making parameters and variables final is also
    a useful first step in gaining understanding of the method before re-factoring.
    Methods that have proved difficult to express in smaller chunks will also become
    easier to understand when single assignment variables are final.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理遗留代码时，使参数和变量 final 也是在重构之前了解方法的有用第一步。在单次赋值变量为 final 后，表现为难以表达为较小块的方法也将变得更容易理解。
- en: Provide No More Than One Worker Constructor
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供不超过一个工作构造函数。
- en: Provide no More Than One Worker Constructor
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供不超过一个工作构造函数。
- en: Summary
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Although a class may provide many constructors, only one should write to fields
    and initialize the class.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个类可能提供许多构造函数，但只有一个应该写入字段并初始化类。
- en: Details
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Having a single place where fields are assigned during construction makes it
    easy to understand the states that class can be constructed in.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造期间只有一个地方对字段进行赋值，这样可以很容易地了解该类可以在哪些状态下构造。
- en: Classes should not provide multiple constructors that set fields.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 类不应该提供设置字段的多个构造函数。
- en: '**Bad**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**不好的做法**'
- en: '[PRE45]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The duplication of values in the above code could be removed but it would remain
    confusing because the concern of initializing the class is spread across three
    locations.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中值的重复可以移除，但仍会令人困惑，因为初始化类的关注点分散在三个位置。
- en: If more fields were added it would be easy to forget to initialize them in the
    existing constructors.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加了更多的字段，很容易忘记在现有构造函数中初始化它们。
- en: Fortunately, we have made all fields final so this would give a compilation
    error. If the class was mutable, we would have a bug to discover at runtime.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经使所有字段都是 final，所以这会导致编译错误。如果类是可变的，我们将在运行时发现一个 bug。
- en: '**Better**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的做法**'
- en: '[PRE46]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Fields are now only written in one location, resulting in less duplication.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在字段只在一个地方编写，减少了重复。
- en: We can also see at a glance that `Foo` cannot be constructed with null values.
    In the previous version, this could only be determined by scanning three different
    locations.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以一眼看出 `Foo` 不能用 null 值构造。在之前的版本中，只能通过扫描三个不同的位置来确定。
- en: Following this pattern, it is difficult to forget to set a field even if it
    is non-final.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这个模式，即使是非 final 的字段也很难忘记设置。
- en: Avoid Checked Exceptions
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用已检查异常。
- en: Avoid Checked Exceptions
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用已检查异常。
- en: Summary
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Do not declare checked exceptions unless there is a clear course of action that
    should be taken when one is thrown.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 不要声明已检查异常，除非有明确的应该在抛出异常时采取的行动。
- en: Details
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Exceptions are for exceptional circumstances - design your code such that they
    are not thrown in scenarios that are expected to happen.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是用于异常情况的 - 设计你的代码，使其不会在预期发生的情况下抛出异常。
- en: This means that they should not be used for normal control flow.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们不应该用于正常的控制流程。
- en: Checked exceptions bloat and complicate code. You should avoid adding them to
    your API, except when there is a clear action that the caller can always take
    to recover from the error scenario.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 受检异常会使代码膨胀和复杂化。除非调用者总是可以采取明确的操作来从错误情况中恢复，否则应避免将它们添加到你的API中。
- en: This is surprisingly rare.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况非常罕见。
- en: If you are working with a library that uses checked exceptions, you can wrap
    them by re-throwing a runtime exception.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一个使用了受检异常的库，你可以通过重新抛出运行时异常来包装它们。
- en: When you do, be sure to maintain the stack trace.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，请确保保留堆栈跟踪。
- en: '[PRE47]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you have caught an `Exception` or a `Throwable`, so are unsure of the exact
    type, you can avoid creating unnecessary wrappers using Guava's `Throwables.propagate`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你捕获了一个`Exception`或`Throwable`，但不确定确切的类型，你可以使用Guava的`Throwables.propagate`来避免创建不必要的包装器。
- en: '[PRE48]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will wrap checked exceptions and re-throw unchecked exception as is.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包装受检异常并按原样重新抛出未检查的异常。
