- en: Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many aspects to programming style, from the mundane questions of where
    to place braces and new lines through to the more interesting questions of how
    you design and structure your code.
  prefs: []
  type: TYPE_NORMAL
- en: This section looks at all of these aspects, starting with the more abstract
    concerns before drilling down to the more concrete.
  prefs: []
  type: TYPE_NORMAL
- en: Although static analysis tools can measure aspects of many of the things discussed
    in most cases they cannot make break-the-build decisions about whether the code
    is good. A skilled human is required to make trade offs and apply discretion.
  prefs: []
  type: TYPE_NORMAL
- en: Consider Code Generators Carefully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code generators can automatically implement certain types of functionality,
    saving time and eliminating the possibility of certain classes of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Although they have much to recommend them, code generators also have a cost
    that should be considered carefully before incorporating them into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Favor generators that allow a clear separation between generated and non-generated
    functionality, but make sure you understand the trade-offs you are making before
    including any generator into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code generators can be grouped into three general types:'
  prefs: []
  type: TYPE_NORMAL
- en: Boilerplate generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile time annotation processors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime generators/frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boilerplate Generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Boilerplate generators are the simplest form of code generation. They can be
    further split into :'
  prefs: []
  type: TYPE_NORMAL
- en: Generators that insert code into existing classes (e.g. methods auto generated
    by an IDE).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators that produce scaffolding that is checked into version control and
    modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators that produce new classes from a model. The generated code is not
    normally checked into version control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We recommend that the first type are using sparingly, if at all. This is discussed
    further in "Know How to Implement Hashcode and Equals".
  prefs: []
  type: TYPE_NORMAL
- en: Generating code from a model (such as a schema or grammar) can be a useful approach
    as long as the generated code is not modified and is packaged separately. If generated
    and non-generated code are packaged within the same module then this can start
    to cause friction (see below).
  prefs: []
  type: TYPE_NORMAL
- en: Compile Time Annotation Processors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSR 269 introduced a standard framework for processing annotations at build
    time. Several tools exist that use JSR 269 to generate code.
  prefs: []
  type: TYPE_NORMAL
- en: Most use the annotated classes purely as input, from which new classes are generated.
    Often, the new classes extend or implement the annotated class or interface but
    remain separate. These are really just a subset of model based boilerplate generators
    where the model input model is annotated Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: Some (such as project Lombok) update the annotated classes themselves, adding
    additional behavior. This is likely to increase both surprise and friction which
    are discussed below.
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are clearly a lot of upsides to code generators, so why wouldn't they
    always make sense?
  prefs: []
  type: TYPE_NORMAL
- en: The main issues they cause are *surprise* and *friction*.
  prefs: []
  type: TYPE_NORMAL
- en: Surprise
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you generate code at compile or runtime the you are no longer programming
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: You are programming in an augmented Java that does things that developers maintaining
    the code may not be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: It may do things that they do not expect.
  prefs: []
  type: TYPE_NORMAL
- en: It may break fundamental assumptions that programmers have about what can or
    cannot happen within their code.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime generators will usually generate more surprise than compile time systems
    - they add an element of *magic* that breaks the usual Java rules. Runtime generators
    also often weaken type safety, moving classes of problem a developer would normally
    expect to occur at compile time to runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The first time a developer encounters a code generator in a project, everything
    it does will be surprising.
  prefs: []
  type: TYPE_NORMAL
- en: After a period of learning, most of the surprise should go away but each developer
    will need to go through this learning period. The learning involved can be significant
    - gaining a complete understanding of framework such as Spring is, for example,
    a significant effort.
  prefs: []
  type: TYPE_NORMAL
- en: The most worrying problem is when there is still some surprise left after the
    initial learning period.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself asking the question "could this be because of the code
    generator?" when something unexpected happens with your system, and having to
    eliminate that possibility each time, then you have introduced a very real cost
    into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Friction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Code using compile-time generators will not import cleanly into IDEs unless
    the IDE understands how to run the generator. Even when the system is supported
    by an IDE it may require plugins to be installed, configuration options to be
    set etc.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of friction, and how often it is encountered, will depend on the
    IDE and the quality of the support. There may be little friction and it may only
    be encountered when a new developer joins a project. Or it may be considerable
    and triggered each time code is cleaned.
  prefs: []
  type: TYPE_NORMAL
- en: The most effective way to reduce the friction is to package the generated code
    separately from the code that depends upon it. The generated code then becomes
    a normal binary dependency and the fact that it is automated becomes an internal
    implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: While this works well, it may also have a downside. It may create artificial
    modules. If the code was not auto-generated, would it have made sense to package
    it as a separate module?
  prefs: []
  type: TYPE_NORMAL
- en: Runtime generators do not usually introduce much friction, although sometimes
    issues might be experienced if javaagents are not present when running tests from
    the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The Trade-off
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So those are the issues.
  prefs: []
  type: TYPE_NORMAL
- en: Surprise and friction sound like minor concerns compared to the promise of functionality
    for free, but their impact can be significant.
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not it makes sense to introduce a code generator often depends on
    how much it will be used. If there is a large amount of functionality that can
    be auto-generated then it probably makes sense, if the amount is relatively small
    it may be best to stick with vanilla Java.
  prefs: []
  type: TYPE_NORMAL
- en: Optimise For Readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimize for Readability not Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't optimize your code prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: Concentrate on making it simple and understandable instead.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many new programmers worry about the performance of each method they write,
    avoid code they expect to be inefficient and write in a style that attempts to
    minimize object allocations, method calls, assignments or other factors they expect
    to have a cost.
  prefs: []
  type: TYPE_NORMAL
- en: Although it often decreases readability and increases complexity, most micro-performance
    optimization provides no performance benefit at all.
  prefs: []
  type: TYPE_NORMAL
- en: Within the context in which we work, performance should be one of the concerns
    considered last. Instead, attention should be paid to making code as simple and
    readable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: If a performance issue arises, profiling should be used to identify where the
    problems actually lie.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean the performance should be disregarded completely, but it
    should always be trumped by code readability and simplicity until it can be proven
    that there is a real benefit to optimization. Where code can be written in a more
    efficient manner without **any** increase in complexity or trade-off with readability
    then the (presumed) more efficient code should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer Readable Code To Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prefer Readable Code to Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use comments only to explain what you cannot make the code itself explain.
  prefs: []
  type: TYPE_NORMAL
- en: If you are about to write a comment, first think if there is a way you could
    change the code so that it would be understandable without comments.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From Clean Code by Robert C Martin.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Nothing can be quite so helpful as a well-placed comment. Nothing can clutter
    up a module more than frivolous dogmatic comments. Nothing can be quite so damaging
    as an old crufty comment that propagates lies and misinformation."*'
  prefs: []
  type: TYPE_NORMAL
- en: Comments should be used only to explain the intent behind code that cannot be
    refactored to explain itself.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bad*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Better*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A comment is only useful if it explains something that the code itself cannot.
  prefs: []
  type: TYPE_NORMAL
- en: This means that any comments you do write should provide the **why**, not the
    what or the how
  prefs: []
  type: TYPE_NORMAL
- en: '*Bad*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Better*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Better still*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the functional intent has been captured in the method name, the comment
    has been used solely to provide some context as to why the logic makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: The magic number might also be replaced with a constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The comment arguably still adds value however - if nothing else it gives a reader
    unfamiliar with the topic two key phrases to search for on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Javadoc Judiciously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Javadoc Judiciously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Javadoc can help document code but often there are better ways to do so. Think
    carefully before deciding to write it.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Javadoc is Good
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Javadoc is invaluable for external teams that must consume your code without
    access to the source.
  prefs: []
  type: TYPE_NORMAL
- en: All externally consumed code should have javadoc for its public methods.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that all such javadoc concentrates on *what* a method does, not *how*
    it does it.
  prefs: []
  type: TYPE_NORMAL
- en: Javadoc is Bad
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Javadoc duplicates information that ought to be clear from the code itself and
    carries a constant maintenance cost.
  prefs: []
  type: TYPE_NORMAL
- en: If it is not updated in tandem with the code then it becomes misleading.
  prefs: []
  type: TYPE_NORMAL
- en: Do not Javadoc code that will be consumed and maintained only by your immediate
    team. Instead spend effort ensuring that the code speaks for itself.
  prefs: []
  type: TYPE_NORMAL
- en: Remember Kiss And Yagni
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember KISS and YAGNI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep your design as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Create only the functionality you need now - not what you think you might need
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The KISS (Keep It Simple, Stupid) and YAGNI (You Ain't Going To Need It) acronyms
    provide good advice that is worth remembering while coding.
  prefs: []
  type: TYPE_NORMAL
- en: KISS advises that we keep our code and designs as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Few people would disagree with this, but unfortunately it is not always obvious
    what *simple* means.
  prefs: []
  type: TYPE_NORMAL
- en: Given two solutions to a problem which one is simpler?
  prefs: []
  type: TYPE_NORMAL
- en: The one with the least lines of code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one with the least number of classes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one that uses fewer third party dependencies?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one with fewer branch statements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one where the logic is most explicit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one which is consistent with a solution used elsewhere?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the above are reasonable definitions of *simple*. None of them is the
    single definition always makes sense to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing simple isn't easy and keeping things simple takes a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: If we could somehow measure the complexity of our software, we would find that
    there is some minimum value that each piece of software must contain.
  prefs: []
  type: TYPE_NORMAL
- en: If the software were any simpler, then it would be less functional.
  prefs: []
  type: TYPE_NORMAL
- en: Real programs will always contain this *inherent complexity* plus a bit. This
    extra complexity is the *accidental complexity* we have added because we are less
    than perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Telling accidental complexity apart from inherent complexity is of course also
    hard.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately YAGNI gives us some useful advice on how to keep things simple without
    having to tell accidental and inherent complexity apart.
  prefs: []
  type: TYPE_NORMAL
- en: The more a system does, the higher its overall complexity will be. If we make
    a system that does less, it will be simpler - it will have less *inherent complexity*
    and less *accidental complexity*
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is, therefore, to create the minimum amount of functionality that
    solves the problems you have right **now**.
  prefs: []
  type: TYPE_NORMAL
- en: Don't implement things because you think you might need them later. Implement
    in the future if you need it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't try and make things "flexible" or "configurable". Make them do just what
    they need to do - parameterize them at the point you have a need to do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you create more than the minimum amount of functionality, you will have more
    code to debug, understand and maintain from that point forward until someone has
    the confidence to delete it.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prefer Composition to Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composition usually results in more flexible designs.
  prefs: []
  type: TYPE_NORMAL
- en: First consider using composition, then fall back to using inheritance only when
    composition does not seem to be a good fit.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composition means building things by adding other things together. Inheritance
    is building things by extending behavior based on an existing class by creating
    a child classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take a minimal example- If there is a requirement for a class to accept
    and store String values, some programmers new to Java will reach for inheritance
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The same functionality can be implemented using composition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Despite requiring more code, an experienced Java programmer would not even consider
    the first approach. So why is it that the second version is preferable?
  prefs: []
  type: TYPE_NORMAL
- en: There are several overlapping explanations, we'll start with the most abstract
    and move on to more practical ones.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a Strong Relationship
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inheritance is used to model an IS-A relationship - i.e. we are saying that
    our `InheritanceAbuse` class is an ArrayList and we should be able to pass one
    to any piece of code that accepts an ArrayList.
  prefs: []
  type: TYPE_NORMAL
- en: Composition creates a HAS-A relationship; this is a weaker relationship and
    we should always favor weaker relationships in our code.
  prefs: []
  type: TYPE_NORMAL
- en: So favoring composition over inheritance is just one specific instance of the
    more general advice to favor weak relationships between our classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance makes sense when there is an IS-A relationship there but it
    is an inappropriate mechanism to use purely for reusing code.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance Breaks Encapsulation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The inheritance implementation fails to encapsulate an implementation detail
    - that we're storing things in an ArrayList.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface to our class includes all sort of methods from ArrayList such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: clear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: remove
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: contains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do these methods make sense for our class? If someone calls them, could it interfere
    with the logic in `performBusinessLogic`?
  prefs: []
  type: TYPE_NORMAL
- en: We don't know enough about what our example class is meant to do to answer these
    questions definitively, but the answer is most likely that we would prefer not
    to expose these methods.
  prefs: []
  type: TYPE_NORMAL
- en: If we switch from ArrayList to some other list implementation this is visible
    to the classes clients. Code that previously compiled may now break even if no
    methods specific to ArrayList are called - the change of type alone might cause
    compilation failures.
  prefs: []
  type: TYPE_NORMAL
- en: We Can Only Do This Once
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Java doesn't support multiple inheritance so we only get to pick one thing to
    extend. If our class also needed to store Integers then inheritance isn't even
    an option so we'd have to use composition.
  prefs: []
  type: TYPE_NORMAL
- en: Composition is inherently more flexible in single inheritance languages.
  prefs: []
  type: TYPE_NORMAL
- en: Composition Aids Testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is not relevant to our simple example, but it is trivial to test how classes
    linked together by composition interact. It is far harder when inheritance is
    used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to inject a mock into `MyClass`. Tricks exist to isolate the code
    in `MyUntestableClass` from `SomeDependency` for the purpose of unit testing,
    but they are far more involved.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is Static
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inheritance sets a fixed relationship between concrete classes at compile time.
    With composition it is possible to swap in different concrete classes at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Again composition is inherently more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advice to prefer composition to inheritance refers to *implementation inheritance*
    (i.e. extending a class). The disadvantages discussed above do not apply to *interface
    inheritance* (i.e. implementing an interface).
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the design choice you often have to make is between implementation
    inheritance or a combination of composition and interface inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In these situations, the advice is still to prefer the approach that uses composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the well known composition based Decorator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Could also be implemented using inheritance
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But, again, this solution would be less flexible.
  prefs: []
  type: TYPE_NORMAL
- en: With the composition based version we can decorate any `Processor`. With the
    inheritance version we would need to re-implement the decorator for each concrete
    type to which we wished to add the upper case behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Many common OO patterns rely on the combination of Composition and interface
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Implementation Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost anything that can be achieved with implementation inheritance can also
    be achieved using the combination of interface inheritance and composition.
  prefs: []
  type: TYPE_NORMAL
- en: So when should implementation inheritance be used?
  prefs: []
  type: TYPE_NORMAL
- en: Implementation inheritance has one single advantage over composition - it's
    less verbose.
  prefs: []
  type: TYPE_NORMAL
- en: So implementation inheritance should be used when **both** of the following
    conditions are met
  prefs: []
  type: TYPE_NORMAL
- en: There is an IS-A relationship to be modelled
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The composition based approach would result in too much boilerplate code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 2nd point is unfortunately entirely subjective.
  prefs: []
  type: TYPE_NORMAL
- en: Keep It Solid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep It SOLID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SOLID acronym provides some guidance on design that you should follow.
  prefs: []
  type: TYPE_NORMAL
- en: '**S**ingle Responsibility Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**pen Closed Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**iskov Substitution Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**nterface Segregation Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**ependency Inversion Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Separate your concerns - a class should do one thing and one thing only. To
    put it another way, a class should have a single reason to change.
  prefs: []
  type: TYPE_NORMAL
- en: Open / Closed Principle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should be able to extend behavior, without modifying existing code.
  prefs: []
  type: TYPE_NORMAL
- en: '*".. you should design modules that never change. When requirements change,
    you extend the behavior of such modules by adding new code, not by changing old
    code that already works."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*â€” Robert Martin*'
  prefs: []
  type: TYPE_NORMAL
- en: An indication that you might not be following this principle is the presence
    of `switch` statements or `if/else` logic in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Derived classes must be substitutable for their base classes.
  prefs: []
  type: TYPE_NORMAL
- en: One indication that you are breaking this principle is the presence of `instanceof`
    statements in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Interface Segregation Principle states that clients should not be forced
    to implement interfaces they don't use; prefer small, tailored interfaces to large,
    catch-all ones.
  prefs: []
  type: TYPE_NORMAL
- en: One indication that you might be breaking this principle is the presence of
    empty methods or methods throwing `OperationNotSupportedException` in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: High-level modules should not depend upon low-level modules. Both should depend
    upon abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions should never depend upon details. Details should depend upon abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice this means you should follow one of two patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Package the interfaces a 'high-level' component depends upon with that component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package the interface a component depends upon separately from both the client
    and implementation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This first approach is classic dependency inversions (contrast it with the traditional
    approach of have the high level component depend upon the lower layers).
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is known as the "Separated Interface Pattern". It is a little
    more heavy weight, but also more flexible as it makes no assumption about who
    should own the interface.
  prefs: []
  type: TYPE_NORMAL
- en: An indication that you are breaking this principle is the presence of package
    cycles within your code.
  prefs: []
  type: TYPE_NORMAL
- en: Keep Your Code Dry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep Your Code DRY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't Repeat Yourself (DRY) - avoid writing the same logic more than once.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you copy and paste code, flick yourself in the eye. This is a great
    disincentive to doing it again but over time may cause blindness.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the same logic is required more than once then it should not be duplicated;
    it should instead, be extracted to a well named class or method.
  prefs: []
  type: TYPE_NORMAL
- en: This will be both easier to read and easier to maintain because a change will
    only be required in one place should the logic need to change.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bad*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Better*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Things are a little trickier when we have similar but not identical logic.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is quick and easy, the worst thing we can do is copy and paste.
  prefs: []
  type: TYPE_NORMAL
- en: '**Terrible**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This seemed quick and easy now, but is the start of a codebase that will suck
    time each time we try to understand or change it.
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward but very limited approach to re-use code is to introduce Boolean
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: '**Not great**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is ugly and gets worse as the number of possibilities increases.
  prefs: []
  type: TYPE_NORMAL
- en: A much more scalable approach is to use the Strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we introduce an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Java 7 version is quite verbose due to the anonymous inner class boiler
    plate.
  prefs: []
  type: TYPE_NORMAL
- en: Arguably, Boolean flags might be preferable for very simple cases such as this
    but, if we extract the logic in `performSideEffect` and `performDifferentSideEffect`
    methods into top-level classes implementing `WidgetAction`, then the Strategy
    version becomes compelling.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 8, there is little question that the Strategy pattern is preferable
    in even the simplest of cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better with Java 8**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We do not need to introduce our own interface - the built-in `Consumer<T>` is
    enough. We should consider introducing one if the `doThings` method were exposed
    publicly or if the logic in `performSideEffect` was complex enough to pull into
    a top-level class.
  prefs: []
  type: TYPE_NORMAL
- en: The loop might also be converted to a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '**As a pipeline**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Prefer Reversible Decisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prefer Reversible Decisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prefer design decisions that will be easy to change.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the decisions you make while designing your code will eventually turn
    out to be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: If you can make your decisions reversible by containing their consequences and
    adding abstractions then this future change will not matter.
  prefs: []
  type: TYPE_NORMAL
- en: For example - if you introduce a third party library and reference it throughout
    your code, then you have made high the cost of reversing the decision to use that
    library. If you constrain it to a single location and create an interface for
    it, the cost of reversing the decision is low.
  prefs: []
  type: TYPE_NORMAL
- en: But don't forget KISS and YAGNI - if your abstractions complicate the design
    then it is better to leave them out.
  prefs: []
  type: TYPE_NORMAL
- en: Make Dependencies Explicit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make Dependencies Explicit and Visible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that the dependencies of a class are clearly visible.
  prefs: []
  type: TYPE_NORMAL
- en: Always inject dependencies into a class using its constructor. Do not use other
    methods such as setters or annotations on fields.
  prefs: []
  type: TYPE_NORMAL
- en: Never introduce dependencies using hidden routes such as `Singletons` or `ThreadLocals`.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code is easier to understand if the interfaces and classes that each object
    depends on are conspicuous and visible.
  prefs: []
  type: TYPE_NORMAL
- en: The most visible dependencies are the ones that are injected into a method as
    a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Less visible are the ones stored as fields but, depending on how those fields
    are populated, the dependencies can still be relatively easy to discover.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor Injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Constructor dependency injection clearly communicates an object's dependencies
    in a single location and ensures objects are only ever created in valid states.
    It allows fields to be made **final** so that their life cycle is unambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: This is the only way in which dependencies should be injected.
  prefs: []
  type: TYPE_NORMAL
- en: Setter Injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setter injection increases the number of possible states an object could be
    in. Many of those states will be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: If setter injection is used, a class can be constructed in a half-initialized
    state. What constitutes a fully-initialized state can only be determined by examining
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, a `NullPointerException` will be thrown if `Foo` is constructed without
    calling `setBar`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, it is clear that we must supply a `Bar` as we are unable to construct
    the class without it.
  prefs: []
  type: TYPE_NORMAL
- en: Field Annotations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While annotations on fields seem convenient they mean that the dependency will
    not be visible in the public API. They also tie construction of your class to
    the frameworks that understand them and prevent fields from being made final.
  prefs: []
  type: TYPE_NORMAL
- en: Field annotations should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with a dependency injection framework such as Spring, either
    move construction of your objects into configuration classes or restrict the use
    on annotations to constructors. Both methods allow your classes to be constructed
    normally and ensure that all dependencies are visible.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden Dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Anything that is not injected into a class using a constructor or as a method
    parameter is a hidden dependency.
  prefs: []
  type: TYPE_NORMAL
- en: These are evil.
  prefs: []
  type: TYPE_NORMAL
- en: They are pulled in from `Singletons`, `ThreadLocals`, static method calls or
    by simply calling `new`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we must ensure that the `Database` class is in a valid state before calling
    the `doThings` method of the code below, but we have no way of knowing this without
    looking through every line of code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Injecting via the constructor makes the dependency clearly visible.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, hidden dependencies are hard to discover but they have a second
    issue - they are also hard to replace.
  prefs: []
  type: TYPE_NORMAL
- en: Seams
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Seams are a concept introduced by Michael Feathers in "Working Effectively with
    legacy code"
  prefs: []
  type: TYPE_NORMAL
- en: 'He defines it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '"a place where you can alter behavior in your program without editing in that
    place."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the original version of `HiddenDependencies` if we wanted to replace `Database`
    with a mock or stub we could only do so if the singleton provided some method
    to modify the instance it returns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Not a good approach**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This approach introduces a seam but does not address our concerns around visibility.
    The dependency remains hidden.
  prefs: []
  type: TYPE_NORMAL
- en: If we used this approach, our codebase would remain hard to understand and we
    would find ourselves constantly fighting test order dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: With constructor injection, we gain a seam and make the dependency visible.
    Even if `Database` is a singleton, we are still able to isolate our code from
    it for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer Immutable Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prefer Immutable Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where possible, create objects that cannot be changed - especially if those
    objects will be long-lived or globally accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mutable state makes programs harder to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: When objects are short-lived, and do not leave method scope, mutable state causes
    few problems. Writes and reads will be close together and there will be a clear
    order in which this happens.
  prefs: []
  type: TYPE_NORMAL
- en: For longer-lived objects, things are more complex.
  prefs: []
  type: TYPE_NORMAL
- en: If an object escapes from a method then it may be accessed from more than one
    location within the code.
  prefs: []
  type: TYPE_NORMAL
- en: We must start by assuming that anything that can happen to these objects will.
    We can only confirm that certain situations do not occur by examining the whole
    program.
  prefs: []
  type: TYPE_NORMAL
- en: The set of things that might happen to an immutable object is far smaller than
    for a mutable one. By constraining how long lived objects can behave we have made
    things simpler. There are fewer possibilities that we must consider.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is not always easy to tell from a class definition what the
    lifecycle of objects of that type will be. Perhaps only short-lived instances
    will be created. Perhaps only long-lived ones. Perhaps a mixture of the two.
  prefs: []
  type: TYPE_NORMAL
- en: If we design immutable classes by default we do not need to worry about this.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem With Mutable Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we have a very simple class such as `Foo`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We would need to search our codebase for all usages of it to establish the
    following :'
  prefs: []
  type: TYPE_NORMAL
- en: It is Never Accessed from Multiple Threads
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`Foo` is not thread safe.'
  prefs: []
  type: TYPE_NORMAL
- en: Writes to longs are not atomic and nothing within `Foo` itself establishes a
    happens-before relationship between the field write and read.
  prefs: []
  type: TYPE_NORMAL
- en: If `setId` and `getId` are ever called from different threads we might get back
    stale or garbage values.
  prefs: []
  type: TYPE_NORMAL
- en: '`setId` Is Never Called After `Foo` Has Been Placed in a Set'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `hashcode` of this class relies on a mutable field. If we modify it after
    we place it in a set then our program will not behave as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: The Flow of Our Data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Even if our program behaves correctly, we need to do work in order to understand
    how it functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`setId` can be called at any point after the object is created. We can, therefore,
    only understand how data flows through our program by looking for all calls to
    `setId` - perhaps there are several, perhaps there is only one. The only way we
    can discover this is by examining the entire program.'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we can make our objects immutable we gain guarantees that mean we do not
    need to worry about how our objects are used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It no longer matters if `Foo` is long or short lived.
  prefs: []
  type: TYPE_NORMAL
- en: It is inherently thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: We know that whatever value we construct it with will remain until it dies.
    There is only one possible point where data is written so we do not need to search
    for others.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The example uses the JSR3051 `javax.annotation.concurrent.Immutable` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: This does not in any way change the object's functionality but provides a way
    to communicate the intent of this being an immutable class. Static analysis tools
    such as [Mutablility Detector](https://github.com/MutabilityDetector/MutabilityDetector)
    can check if this intent has been violated.
  prefs: []
  type: TYPE_NORMAL
- en: We can tell at a glance that `Foo` is immutable as it has final fields of a
    well known immutable type.
  prefs: []
  type: TYPE_NORMAL
- en: The `final` keyword ensures only that the reference a field points to will not
    change.
  prefs: []
  type: TYPE_NORMAL
- en: If the field were of type `Bar` then we would not know if it were mutable or
    not without examining `Bar` to see if it too were immutable. Even if we were not
    using a static analysis tool the use of the `Immutable` annotation would make
    this assessment faster.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of updating the state of immutable objects, we create new instances
    that retain the state we do not wish to modify.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern seems strange to some Java programmers at first, but the programming
    model is similar to how the familiar `String` class works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Instances of `Bar` with new values can be obtained by calling `withAString`
    and `withAnInt`.
  prefs: []
  type: TYPE_NORMAL
- en: The JSR305 `javax.annotation.CheckReturnValue` enables static analysis tools
    such as [Error Prone](https://github.com/google/error-prone) to issue a warning
    if a mistake is made such as in the code below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The call here to `withAnInt` achieves nothing because the return value is not
    stored. Most likely, the programmer intended to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When to Use Mutable Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mutable objects require slightly less boilerplate to create than immutable ones.
  prefs: []
  type: TYPE_NORMAL
- en: If you know that a class will only ever be used to create short-lived, local
    objects then you might consider making it mutable. But you must weigh this against
    the additional work required to ensure that the class is only ever used in this
    fashion as the codebase grows.
  prefs: []
  type: TYPE_NORMAL
- en: Options exist to auto-generate both immutable and mutable classes, thereby removing
    mutable objects' main advantage. Two of these options are discussed further in
    "Know How to Implement Hashcode and Equals".
  prefs: []
  type: TYPE_NORMAL
- en: Mutable objects used to be the norm in Java. As a result, many common frameworks
    require mutable objects. Persistence and serialization frameworks often require
    Java beans with no args constructors and setters. Other frameworks might require
    you to use two-stage construction with a lifecycle method such as init.
  prefs: []
  type: TYPE_NORMAL
- en: It is not always highlighted in the documentation but some long standing frameworks
    have been updated to support immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Jackson for example now allows constructors and factory methods to be annotated
    :-
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Other frameworks, such as Hibernate, can only be used with classes that provide
    a default constructor. Although they can be configured to set fields directly
    without the need for setters this causes more problems than it solves.
  prefs: []
  type: TYPE_NORMAL
- en: If you are tied to a framework that requires mutability then you will need to
    use mutable objects where you interface with that framework.
  prefs: []
  type: TYPE_NORMAL
- en: Use A Consistent Code Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use a Consistent Code Layout Within Each Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Agree and enforce a standard code formatting scheme within each codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way in which Java code is formatted and laid out is largely a matter of
    personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Some styles (such as omitting braces in conditional statements) can arguably
    make certain types of bug slightly more likely.
  prefs: []
  type: TYPE_NORMAL
- en: Others might require more work to keep the code compliant (such as aligning
    fields into columns) but, to a first approximation, no particular scheme is greatly
    superior to any other.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this, programmers tend to have strong opinions on the matter.
  prefs: []
  type: TYPE_NORMAL
- en: Every codebase should, however, have a single agreed formatting style which
    is consistently applied and is understood by everyone working on that codebase.
  prefs: []
  type: TYPE_NORMAL
- en: This prevents commit wars in which different team members re-format things to
    their personal preference. It also makes code easier to understand as there is
    a cognitive cost for the reader if formatting changes radically from file to file.
  prefs: []
  type: TYPE_NORMAL
- en: Although there is value in consistency, there is also a cost.
  prefs: []
  type: TYPE_NORMAL
- en: Unless there is already broad agreement across teams about how things should
    be formatted, trying to enforce one official set of rules is likely to create
    more ill will than benefit.
  prefs: []
  type: TYPE_NORMAL
- en: A global preferred reference should therefore be set, but teams should be free
    to deviate from this as they see fit as long as a consistent style is used for
    the code they maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Suggested Formatting Rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your do not have your own strong preferences we suggest you follow the [Google
    Java Style](https://google.github.io/styleguide/javaguide.html).
  prefs: []
  type: TYPE_NORMAL
- en: These formatting rules are well thought out, clearly documented and not overly
    prescriptive.
  prefs: []
  type: TYPE_NORMAL
- en: We will not describe them in any detail here, but code formatted to these rules
    will look something like the following :-
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, we suggest that the guidance in the Google guide on when to write Javadoc
    is ignored in favor of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Notable Points About This Style
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Spaces not Tabs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Tabs may appear differently depending on how an editor is configured. This will
    result in constant reformatting as different programmers adapt the file to their
    editor settings. Spaces avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: In some languages (e.g. JavaScript before the rise of code minifiers) tabs have/had
    an advantage as they reduced the size of the source file compared to using multiple
    spaces. The increase in size of the source file is of no relevance for Java.
  prefs: []
  type: TYPE_NORMAL
- en: One True Brace Style
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are various arguments about the supposed advantages of this style, but
    we suggest its use mainly because it is common in the Java community.
  prefs: []
  type: TYPE_NORMAL
- en: Although simple `if else` statements can be more concisely written by omitting
    the braces we suggest that they are always included. This reduces the chance of
    a statement being placed outside the conditional when this was not the intent.
  prefs: []
  type: TYPE_NORMAL
- en: Group Methods For Easy Comprehension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Group Methods for Easy Comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The public methods of a class should appear at the top of the file, the private
    methods towards the bottom and any protected or package default methods in between.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to arranging by accessibility, they should also be ordered into
    a logical flow.
  prefs: []
  type: TYPE_NORMAL
- en: Detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This scheme tries to achieve two goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Highlight the public API by separating it from implementation detail
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow the reader to follow the logical flow with the minimal of scrolling
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To achieve the 2nd goal, methods should be arranged into logical groups, with
    methods always appearing above the ones they call.
  prefs: []
  type: TYPE_NORMAL
- en: The two goals clearly conflict because grouping the public API methods together
    at the top of the file prevents grouping them with the implementation methods
    that they used. If this causes a large problem it may be an indication that the
    class has too many responsibilities and could be refactored into one or more smaller
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions of the "correct" location of a method will also occur when an implementation
    method is called from multiple locations or methods have recursive relationships.
    There is, of course, no one right answer and any ordering that broadly meets the
    second goal may be used.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and static factory methods should usually be placed first in the
    class. The fact that a method is static should not, however, generally influence
    where it is placed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Fields should always be placed at the top of the class before any methods.
  prefs: []
  type: TYPE_NORMAL
- en: Keep Methods Small And Simple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep Methods Small and Simple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep methods small and simple.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Small things are easier to understand than big things. Methods are no different.
  prefs: []
  type: TYPE_NORMAL
- en: One way to measure the size of a method is via the number of lines of code it
    contains.
  prefs: []
  type: TYPE_NORMAL
- en: As a guide methods should not usually be longer than 7 lines in length. This
    is not a hard rule - just a guide of when to feel uncomfortable with a method's
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to gauge the size of a method is to see how many possible paths
    there are through it. The *Cyclomatic complexity* of a method gives a measure
    of this - it will increase as the amount of conditional logic and number of loops
    grows.
  prefs: []
  type: TYPE_NORMAL
- en: As a guide, methods should not usually have a complexity above 5\. Again, this
    is not a hard rule, just a guide of when to feel uncomfortable.
  prefs: []
  type: TYPE_NORMAL
- en: Your code will naturally contain some methods that are larger than others -
    some concepts are inherently more complex than others and the implementation will
    not become simpler if broken down further or expressed in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'But most large methods can be made smaller in one of three ways :'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring into a number of smaller methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-expressing the logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using appropriate language features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting a Method into Smaller Concerns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many large methods have smaller methods within them trying to find a way out.
  prefs: []
  type: TYPE_NORMAL
- en: We can make our code easier to maintain by freeing them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Re-expressing logic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Terrible**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be easily re-expressed with less noise as :'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with a move to a more declarative style :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Neither of the above changes alter the structure of our program or even affect
    the signature of the method. Both still reduce both line count and complexity
    while increasing readability.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying things with a series of higher impact changes that extract a model
    of our domain is, however, often the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to guess what this model might look like for our contrived example,
    but is likely that this conditional logic could be replaced with polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using Appropriate Language Features
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Methods are sometimes bloated by boilerplate that solves common programming
    problems. The need for some of this boilerplate has been removed by new language
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these *new* features aren''t all that new, but code is still written
    without them:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 5 Generics removes the need for ugly casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java 5 for-each-loop can replace code using iterators and indexed loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java 7 try-with-resources can replace complex try, catch finally blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java 7 multi-catch can replace repeated catch blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 8 lambda expressions can replace anonymous class boilerplate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods Should Do One Thing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods Should Do Only One Thing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Methods should do only one thing.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A useful guide as to whether a function is doing only one thing is given in
    "Clean Code" by Robert C Martin.
  prefs: []
  type: TYPE_NORMAL
- en: '"another way to know that a function is doing more than â€œone thingâ€ is if you
    can extract another function from it with a name that is not merely a restatement
    of its implementation."'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bad*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Better*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*You''ve gone too far*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Avoid Null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoid Null Whenever Possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Null is a billion dollar mistake, make sure you know how to avoid using it in
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to limit the times you or your clients need to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is likely that libraries and frameworks you interact with will return
    null, you should try to ensure that this practice is isolated to third party code.
  prefs: []
  type: TYPE_NORMAL
- en: The core of your application should assume that it does not have to worry about
    null values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategies to avoid null include :'
  prefs: []
  type: TYPE_NORMAL
- en: The null object pattern - when you have something you think is optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type-safe null pattern (aka Option, Optional & Maybe) - when you need to
    express that an interface might not return something
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design by contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Null Object Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The null object pattern is the classic OO approach to avoiding null. You should
    use it whenever you think you have a dependency that you think is optional.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is very simple, just provide an implementation of the interface
    that does "nothing" or has a neutral behavior. This can then be safely referenced
    by its clients, with no need to check for null.
  prefs: []
  type: TYPE_NORMAL
- en: Type-Safe Nulls (aka Optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The type-safe null pattern is familiar in most functional programming languages
    where it is variously known as Maybe, Option or Optional. Java 8 finally adds
    an Optional type, but implementations are available for earlier versions via Guava
    and other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: It is a simple pattern. An Optional is basically just a box that can hold either
    one or zero values. You can check if the box is empty (using `isPresent`) and
    retrieve its value via a get method.
  prefs: []
  type: TYPE_NORMAL
- en: Optional should be used whenever a public method might not return a value as
    part of normal program flow.
  prefs: []
  type: TYPE_NORMAL
- en: If you call get on an empty Optional, it will throw a `NoSuchElementException`.
  prefs: []
  type: TYPE_NORMAL
- en: It might not be immediately obvious what value Optional provides over just using
    null. If you need to check that an Optional has something in it before calling
    `get`, how is this different from checking a value is not null to avoid a `NullPointerException`?
  prefs: []
  type: TYPE_NORMAL
- en: There are several important differences.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, if your method declares that it returns `Optional<Person>` then you
    can instantly see from the type signature that it might not return a value. If
    it only returned `Person` you would only know that it might return null if you
    looked at the source, tests or documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Equally important, if you know that you always return `Optional` within your
    codebase when something might not be present, then you know at a glance that a
    method returning `Person` will always return a value and will never return null.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the preferred way to use Optionals is not to call the get method or
    to explicitly check if it contains a value. Instead the values that are contained
    (or not contained) in an Optional can be safely mapped, consumed and filtered
    by various method on the class.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest case a possibly empty Optional can be accessed by calling the
    `orElse` method which takes a default value to use if the Optional is empty.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the sweet spot for using Optionals is for the return types for
    methods. They should not generally be held as fields (use the null object pattern
    here instead) or passed to public methods (instead provide overloaded versions
    that do not require the parameter).
  prefs: []
  type: TYPE_NORMAL
- en: One objection that is sometimes raised by Java programmers encountering Optional
    for the first time is that it is possible for an Optional to be null itself. While
    this is true, returning a null Optional from a method is a perverse thing to do
    and should be considered a coding error.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis rules exists that can check for code that returns null Optionals.
  prefs: []
  type: TYPE_NORMAL
- en: Design by Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We wish for all code that we control to be able to ignore the existence of null
    (unless it interfaces with some third party code that forces us to consider it).
  prefs: []
  type: TYPE_NORMAL
- en: '`Objects.requireNonNull` can be used to add a runtime assertion that null has
    not been passed to a method.'
  prefs: []
  type: TYPE_NORMAL
- en: Because your core code should generally assume that null will never be passed
    around, there is little value in documenting this behavior with tests; assertions
    add value because they ensure that an error occurs close to the point where the
    mistake was made.
  prefs: []
  type: TYPE_NORMAL
- en: We can also check this contract at build time.
  prefs: []
  type: TYPE_NORMAL
- en: JSR-305 provides annotations that can be used to declare where null is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Although JSR-305 is dormant, and shows no signs of being incorporated into Java
    in the near future, the annotations are available at the maven co-ordinates :-
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: They are supported by several static analysis tools including :-
  prefs: []
  type: TYPE_NORMAL
- en: '[Findbugs](http://findbugs.sourceforge.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Error Prone](http://errorprone.info/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can be configured to break the build when null is passed as a parameter
    where we do not expect it.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating every class, method or parameter with `@Nonnull` would quickly become
    tedious and it would be debatable whether the gain would be worth the amount of
    noise this would generate.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is possible to make `@Nonnull` the default by annotating a package
    in its package-info.java file as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, sub-packages do not inherit their parent's annotations, so a package-info.java
    file must be created for each package.
  prefs: []
  type: TYPE_NORMAL
- en: Once non null parameters have been made the default behavior, any parameters
    that do accept null can be annotated with `@Nullable`.
  prefs: []
  type: TYPE_NORMAL
- en: Use Final Liberally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use Final Liberally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider making final any variable or parameter that does not change.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making parameters and variables that are assigned once final makes a method
    easier to understand because it constrains the things that could possibly happen
    within the code.
  prefs: []
  type: TYPE_NORMAL
- en: It would be reasonable to make all parameters and assign-once variables final,
    but this needs to be weighed against the noise created by inserting the `final`
    keyword everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: For short methods, whether the benefit outweighs the cost is arguable, but if
    a method is large and unwieldy then the case for making things final is much stronger.
  prefs: []
  type: TYPE_NORMAL
- en: Each team should agree a policy for making final variables.
  prefs: []
  type: TYPE_NORMAL
- en: At a minimum, everything should be made final within large methods. This may
    also be extended to shorter methods at the team's discretion. A blanket policy
    has the advantage of being easy to automate/understand. A more nuanced policy
    is harder to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: When working with legacy code, making parameters and variables final is also
    a useful first step in gaining understanding of the method before re-factoring.
    Methods that have proved difficult to express in smaller chunks will also become
    easier to understand when single assignment variables are final.
  prefs: []
  type: TYPE_NORMAL
- en: Provide No More Than One Worker Constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provide no More Than One Worker Constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although a class may provide many constructors, only one should write to fields
    and initialize the class.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a single place where fields are assigned during construction makes it
    easy to understand the states that class can be constructed in.
  prefs: []
  type: TYPE_NORMAL
- en: Classes should not provide multiple constructors that set fields.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The duplication of values in the above code could be removed but it would remain
    confusing because the concern of initializing the class is spread across three
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: If more fields were added it would be easy to forget to initialize them in the
    existing constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we have made all fields final so this would give a compilation
    error. If the class was mutable, we would have a bug to discover at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Fields are now only written in one location, resulting in less duplication.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see at a glance that `Foo` cannot be constructed with null values.
    In the previous version, this could only be determined by scanning three different
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: Following this pattern, it is difficult to forget to set a field even if it
    is non-final.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Checked Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoid Checked Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not declare checked exceptions unless there is a clear course of action that
    should be taken when one is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exceptions are for exceptional circumstances - design your code such that they
    are not thrown in scenarios that are expected to happen.
  prefs: []
  type: TYPE_NORMAL
- en: This means that they should not be used for normal control flow.
  prefs: []
  type: TYPE_NORMAL
- en: Checked exceptions bloat and complicate code. You should avoid adding them to
    your API, except when there is a clear action that the caller can always take
    to recover from the error scenario.
  prefs: []
  type: TYPE_NORMAL
- en: This is surprisingly rare.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with a library that uses checked exceptions, you can wrap
    them by re-throwing a runtime exception.
  prefs: []
  type: TYPE_NORMAL
- en: When you do, be sure to maintain the stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If you have caught an `Exception` or a `Throwable`, so are unsure of the exact
    type, you can avoid creating unnecessary wrappers using Guava's `Throwables.propagate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will wrap checked exceptions and re-throw unchecked exception as is.
  prefs: []
  type: TYPE_NORMAL
