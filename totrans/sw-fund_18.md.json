["```\n\n```", "```\n\n    In the past couple of chapters, we've begun applying the\n    mathematical tools developed in the first part of the course to\n    studying the theory of a small programming language, Imp.\n\n*   We defined a type of *abstract syntax trees* for Imp, together with an *evaluation relation* (a partial function on states) that specifies the *operational semantics* of programs. \n\n     The language we defined, though small, captures some of the key features of full-blown languages like C, C++, and Java, including the fundamental notion of mutable state and some common control structures. \n\n*   We proved a number of *metatheoretic properties* \u2014 \"meta\" in the sense that they are properties of the language as a whole, rather than of particular programs in the language. These included: \n\n    *   determinism of evaluation \n\n    *   equivalence of some different ways of writing down the definitions (e.g., functional and relational definitions of arithmetic expression evaluation) \n\n    *   guaranteed termination of certain classes of programs \n\n    *   correctness (in the sense of preserving meaning) of a number of useful program transformations \n\n    *   behavioral equivalence of programs (in the [Equiv](Equiv.html) chapter).\n\n    If we stopped here, we would already have something useful: a set\n    of tools for defining and discussing programming languages and\n    language features that are mathematically precise, flexible, and\n    easy to work with, applied to a set of key properties.  All of\n    these properties are things that language designers, compiler\n    writers, and users might care about knowing.  Indeed, many of them\n    are so fundamental to our understanding of the programming\n    languages we deal with that we might not consciously recognize\n    them as \"theorems.\"  But properties that seem intuitively obvious\n    can sometimes be quite subtle (sometimes also subtly wrong!).\n\n    We'll return to the theme of metatheoretic properties of whole\n    languages later in the book when we discuss *types* and *type soundness*.  In this chapter, though, we turn to a different set\n    of issues.\n\n    Our goal is to carry out some simple examples of *program verification* \u2014 i.e., to use the precise definition of Imp to\n    prove formally that particular programs satisfy particular\n    specifications of their behavior.  We'll develop a reasoning\n    system called *Floyd-Hoare Logic* \u2014 often shortened to just\n    *Hoare Logic* \u2014 in which each of the syntactic constructs of Imp\n    is equipped with a generic \"proof rule\" that can be used to reason\n    compositionally about the correctness of programs involving this\n    construct.\n\n    Hoare Logic originated in the 1960s, and it continues to be the\n    subject of intensive research right up to the present day.  It\n    lies at the core of a multitude of tools that are being used in\n    academia and industry to specify and verify real software\n    systems. \n\n    Hoare Logic combines two beautiful ideas: a natural way of\n    writing down *specifications* of programs, and a *compositional proof technique* for proving that programs are correct with\n    respect to such specifications \u2014 where by \"compositional\" we mean\n    that the structure of proofs directly mirrors the structure of the\n    programs that they are about. \n\n    This chapter:\n\n*   A systematic method for reasoning about the correctness of particular programs in Imp\n\n    Goals:\n\n*   a natural notation for *program specifications* and\n\n*   a *compositional* proof technique for program correctness\n\n    Plan:\n\n*   assertions (Hoare Triples)\n\n*   proof rules\n\n*   decorated programs\n\n*   loop invariants\n\n*   examples\n\n```", "```\nDefinition Assertion := state \u2192 Prop.\n\n```", "```\nModule ExAssertions.\nDefinition as[1] : Assertion := fun st \u21d2 st X = 3.\nDefinition as[2] : Assertion := fun st \u21d2 st X \u2264 st Y.\nDefinition as[3] : Assertion :=\n\u00a0\u00a0fun st \u21d2 st X = 3 \u2228 st X \u2264 st Y.\nDefinition as[4] : Assertion :=\n\u00a0\u00a0fun st \u21d2 st Z * st Z \u2264 st X \u2227\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00ac (((S (st Z)) * (S (st Z))) \u2264 st X).\nDefinition as[5] : Assertion := fun st \u21d2 True.\nDefinition as[6] : Assertion := fun st \u21d2 False.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\nEnd ExAssertions.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fun\u00a0st\u00a0\u21d2\u00a0(st\u00a0Z)\u00a0*\u00a0(st\u00a0Z)\u00a0\u2264\u00a0m\u00a0\u2227\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00ac\u00a0((S\u00a0(st\u00a0Z))\u00a0*\u00a0(S\u00a0(st\u00a0Z))\u00a0\u2264\u00a0m)\n\n    we'll write just\n\n```", "```\nDefinition assert_implies (P Q : Assertion) : Prop :=\n\u00a0\u00a0\u2200st, P st \u2192 Q st.\n\nNotation \"P \u21fe Q\" := (assert_implies P Q)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 80) : hoare_spec_scope.\nOpen Scope hoare_spec_scope.\n\n```", "```\nNotation \"P \u21ff Q\" :=\n\u00a0\u00a0(P \u21fe Q \u2227 Q \u21fe P) (at level 80) : hoare_spec_scope.\n\n```", "```\nDefinition hoare_triple\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P:Assertion) (c:com) (Q:Assertion) : Prop :=\n\u00a0\u00a0\u2200st st',\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st'  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0P st  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0Q st'.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{P}}\u00a0c\u00a0{{Q}}.\n\n    (The traditional notation is {P} c {Q}, but single braces\n    are already used for other things in Coq.)\n\n```", "```\n\n#### Exercise: 1 star, optional (triples)\n\n    Paraphrase the following Hoare triples in English.\n\n```", "```\n\u00a0\u00a0\u00a01)\u00a0{{True}}\u00a0X\u00a0::=\u00a05\u00a0{{X\u00a0=\u00a05}}\n\n\u00a0\u00a0\u00a02)\u00a0{{X\u00a0=\u00a02}}\u00a0X\u00a0::=\u00a0X\u00a0+\u00a01\u00a0{{X\u00a0=\u00a03}}\n\n\u00a0\u00a0\u00a03)\u00a0{{True}}\u00a0X\u00a0::=\u00a05;\u00a0Y\u00a0::=\u00a00\u00a0{{X\u00a0=\u00a05}}\n\n\u00a0\u00a0\u00a04)\u00a0{{X\u00a0=\u00a02\u00a0\u2227\u00a0X\u00a0=\u00a03}}\u00a0X\u00a0::=\u00a05\u00a0{{X\u00a0=\u00a00}}\n\n\u00a0\u00a0\u00a05)\u00a0{{True}}\u00a0SKIP\u00a0{{False}}\n\n\u00a0\u00a0\u00a06)\u00a0{{False}}\u00a0SKIP\u00a0{{True}}\n\n\u00a0\u00a0\u00a07)\u00a0{{True}}\u00a0WHILE\u00a0True\u00a0DO\u00a0SKIP\u00a0END\u00a0{{False}}\n\n\u00a0\u00a0\u00a08)\u00a0{{X\u00a0=\u00a00}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0X\u00a0==\u00a00\u00a0DO\u00a0X\u00a0::=\u00a0X\u00a0+\u00a01\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{X\u00a0=\u00a01}}\n\n\u00a0\u00a0\u00a09)\u00a0{{X\u00a0=\u00a01}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0X\u00a0\u2260\u00a00\u00a0DO\u00a0X\u00a0::=\u00a0X\u00a0+\u00a01\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{X\u00a0=\u00a0100}}\n\n    \u2610 \n\n    (Note that we're using informal mathematical notations for\n   expressions inside of commands, for readability, rather than their\n   formal aexp and bexp encodings.  We'll continue doing so\n   throughout the chapter.) \n\n    To get us warmed up for what's coming, here are two simple\n   facts about Hoare triples.\n\n```", "```\n\n# Proof Rules\n\n    The goal of Hoare logic is to provide a *compositional*\n    method for proving the validity of specific Hoare triples.  That\n    is, we want the structure of a program's correctness proof to\n    mirror the structure of the program itself.  To this end, in the\n    sections below, we'll introduce a rule for reasoning about each of\n    the different syntactic forms of commands in Imp \u2014 one for\n    assignment, one for sequencing, one for conditionals, etc. \u2014 plus\n    a couple of \"structural\" rules for gluing things together.  We\n    will then be able to prove programs correct using these proof\n    rules, without ever unfolding the definition of hoare_triple.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Y\u00a0=\u00a01\u00a0}}\u00a0\u00a0X\u00a0::=\u00a0Y\u00a0\u00a0{{\u00a0X\u00a0=\u00a01\u00a0}}\n\n    In English: if we start out in a state where the value of Y\n    is 1 and we assign Y to X, then we'll finish in a\n    state where X is 1.  \n    That is, the property of being equal to 1 gets transferred \n    from Y to X. \n\n    Similarly, in\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0a\u00a0=\u00a01\u00a0}}\u00a0\u00a0X\u00a0::=\u00a0a\u00a0{{\u00a0X\u00a0=\u00a01\u00a0}}\n\n    is a valid Hoare triple. \n\n    This can be made even more general. To conclude that an\n    arbitrary property Q holds after X ::= a, we need to assume\n    that Q holds before X ::= a, but *with all occurrences of* X\n    replaced by a in Q. This leads to the Hoare rule for\n    assignment\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0(X\u00a0\u2264\u00a05)\u00a0[X\u00a0\u21a6\u00a0X\u00a0+\u00a01]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i.e.,\u00a0X\u00a0+\u00a01\u00a0\u2264\u00a05\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0(X\u00a0=\u00a03)\u00a0[X\u00a0\u21a6\u00a03]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i.e.,\u00a03\u00a0=\u00a03}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a03\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a03\u00a0}}\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0(0\u00a0\u2264\u00a0X\u00a0\u2227\u00a0X\u00a0\u2264\u00a05)\u00a0[X\u00a0\u21a6\u00a03]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i.e.,\u00a0(0\u00a0\u2264\u00a03\u00a0\u2227\u00a03\u00a0\u2264\u00a05)}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a03\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a00\u00a0\u2264\u00a0X\u00a0\u2227\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\n    To formalize the rule, we must first formalize the idea of\n    \"substituting an expression for an Imp variable in an assertion.\"\n    That is, given a proposition P, a variable X, and an\n    arithmetic expression a, we want to derive another proposition\n    P' that is just the same as P except that, wherever P\n    mentions X, P' should instead mention a.\n\n    Since P is an arbitrary Coq proposition, we can't directly\n    \"edit\" its text.  Instead, we can achieve the same effect by\n    evaluating P in an updated state:\n\n```", "```\n\n    That is, P [X \u21a6 a] stands for an assertion \u2014 let's call it P' \u2014 \n    that is just like P except that, wherever P looks up the \n    variable X in the current state, P' instead uses the value \n    of the expression a. \n\n    To see how this works, let's calculate what happens with a couple\n    of examples.  First, suppose P' is (X \u2264 5) [X \u21a6 3] \u2014 that\n    is, more formally, P' is the Coq expression\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0fun\u00a0st\u00a0\u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(fun\u00a0st'\u00a0\u21d2\u00a0st'\u00a0X\u00a0\u2264\u00a05)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(t_update\u00a0st\u00a0X\u00a03)\n\n    and further simplifies to\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0fun\u00a0st\u00a0\u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(3\u00a0\u2264\u00a05).\n\n    That is, P' is the assertion that 3 is less than or equal to\n    5 (as expected). \n\n    For a more interesting example, suppose P' is (X \u2264 5) [X \u21a6 X+1].  Formally, P' is the Coq expression\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0fun\u00a0st\u00a0\u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(((t_update\u00a0st\u00a0X\u00a0(aeval\u00a0st\u00a0(APlus\u00a0(AId\u00a0X)\u00a0(ANum\u00a01)))))\u00a0X)\u00a0\u2264\u00a05\n\n    and further simplifies to\n\n```", "```\nTheorem hoare_asgn : \u2200Q X a,\n\u00a0\u00a0{{Q [X \u21a6 a]}} (X ::= a) {{Q}}.\n\n    Proof.\n\u00a0\u00a0unfold [hoare_triple](Hoare.html#hoare_triple).\n\u00a0\u00a0intros Q X a st st' HE HQ.\n\u00a0\u00a0inversion HE. subst.\n\u00a0\u00a0unfold [assn_sub](Hoare.html#assn_sub) in HQ. assumption. Qed.\n\n```", "```\nExample assn_sub_example :\n\u00a0\u00a0{{(fun st \u21d2 st X = 3) [X \u21a6 ANum 3]}}\n\u00a0\u00a0(X ::= (ANum 3))\n\u00a0\u00a0{{fun st \u21d2 st X = 3}}.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0apply hoare_asgn. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a01)\u00a0{{\u00a0(X\u00a0\u2264\u00a05)\u00a0[X\u00a0\u21a6\u00a0X\u00a0+\u00a01]\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\n\u00a0\u00a0\u00a0\u00a02)\u00a0{{\u00a0(0\u00a0\u2264\u00a0X\u00a0\u2227\u00a0X\u00a0\u2264\u00a05)\u00a0[X\u00a0\u21a6\u00a03]\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a03\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a00\u00a0\u2264\u00a0X\u00a0\u2227\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\n    ...into formal statements (use the names assn_sub_ex[1] \n   and assn_sub_ex[2]) and use hoare_asgn to prove them.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, recommendedM (hoare_asgn_wrong)\n\n    The assignment rule looks backward to almost everyone the first\n    time they see it.  If it still seems puzzling, it may help\n    to think a little about alternative \"forward\" rules.  Here is a\n    seemingly natural one:\n\n           |\n\n                        (hoare_asgn_wrong) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{\u00a0True\u00a0}}\u00a0X\u00a0::=\u00a0a\u00a0{{\u00a0X\u00a0=\u00a0a\u00a0}}\n           |\n\n                     |\n\n    Give a counterexample showing that this rule is incorrect and \n    argue informally that it is really a counterexample.  (Hint: \n    The rule universally quantifies over the arithmetic expression \n    a, and your counterexample needs to exhibit an a for which \n    the rule doesn't work.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, advanced (hoare_asgn_fwd)\n\n    However, by using a *parameter* m (a Coq number) to remember the \n    original value of X we can define a Hoare rule for assignment \n    that does, intuitively, \"work forwards\" rather than backwards.\n\n           |\n\n                        (hoare_asgn_fwd) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{fun\u00a0st\u00a0\u21d2\u00a0P\u00a0st\u00a0\u2227\u00a0st\u00a0X\u00a0=\u00a0m}}\n           |\n\n                     |\n\n                        X\u00a0::=\u00a0a\n           |\n\n                     |\n\n                        {{fun\u00a0st\u00a0\u21d2\u00a0P\u00a0st'\u00a0\u2227\u00a0st\u00a0X\u00a0=\u00a0aeval\u00a0st'\u00a0a\u00a0}}\n           |\n\n                     |\n\n                        (where\u00a0st'\u00a0=\u00a0t_update\u00a0st\u00a0X\u00a0m)\n           |\n\n                     |\n\n    Note that we use the original value of X to reconstruct the\n    state st' before the assignment took place. Prove that this rule\n    is correct.  (Also note that this rule is more complicated than \n    hoare_asgn.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, advanced (hoare_asgn_fwd_exists)\n\n    Another way to define a forward rule for assignment is to\n    existentially quantify over the previous value of the assigned\n    variable.\n\n           |\n\n                        (hoare_asgn_fwd_exists) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{fun\u00a0st\u00a0\u21d2\u00a0P\u00a0st}}\n           |\n\n                     |\n\n                        X\u00a0::=\u00a0a\n           |\n\n                     |\n\n                        {{fun\u00a0st\u00a0\u21d2\u00a0\u2203m,\u00a0P\u00a0(t_update\u00a0st\u00a0X\u00a0m)\u00a0\u2227\n           |\n\n                     |\n\n                        st\u00a0X\u00a0=\u00a0aeval\u00a0(t_update\u00a0st\u00a0X\u00a0m)\u00a0a\u00a0}}\n           |\n\n                     |\n\n```", "```\n\n    \u2610\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{(X\u00a0=\u00a03)\u00a0[X\u00a0\u21a6\u00a03]}}\u00a0X\u00a0::=\u00a03\u00a0{{X\u00a0=\u00a03}},\n\n    follows directly from the assignment rule,\n\n```", "```\nTheorem hoare_consequence_pre : \u2200(P P' Q : Assertion) c,\n\u00a0\u00a0{{P'}} c {{Q}} \u2192\n\u00a0\u00a0P \u21fe P' \u2192\n\u00a0\u00a0{{P}} c {{Q}}.\n\n    Proof.\n\u00a0\u00a0intros P P' Q c Hhoare Himp.\n\u00a0\u00a0intros st st' Hc HP. apply (Hhoare st st').\n\u00a0\u00a0assumption. apply Himp. assumption. Qed.\n\nTheorem hoare_consequence_post : \u2200(P Q Q' : Assertion) c,\n\u00a0\u00a0{{P}} c {{Q'}} \u2192\n\u00a0\u00a0Q' \u21fe Q \u2192\n\u00a0\u00a0{{P}} c {{Q}}.\n\n    Proof.\n\u00a0\u00a0intros P Q Q' c Hhoare Himp.\n\u00a0\u00a0intros st st' Hc HP.\n\u00a0\u00a0apply Himp.\n\u00a0\u00a0apply (Hhoare st st').\n\u00a0\u00a0assumption. assumption. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0True\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a01\u00a0=\u00a01\u00a0}}\n\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a01\u00a0}}\n\n    Or, formally...\n\n```", "```\n\n    Finally, for convenience in proofs, we can state a combined\n    rule of consequence that allows us to vary both the precondition\n    and the postcondition at the same time.\n\n                        {{P'}}\u00a0c\u00a0{{Q'}}\n           |\n\n                     |\n\n                        P\u00a0\u21fe\u00a0P'\n           |\n\n                     |\n\n                        Q'\u00a0\u21fe\u00a0Q\n           |\n\n                        (hoare_consequence) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{P}}\u00a0c\u00a0{{Q}}\n           |\n\n                     |\n\n```", "```\n\n## Digression: The eapply Tactic\n\n    This is a good moment to take another look at the eapply tactic,\n    which we introduced briefly in the [Auto](Auto.html) chapter.\n\n    We had to write \"with (P' := ...)\" explicitly in the proof of\n    hoare_asgn_example1 and hoare_consequence above, to make sure\n    that all of the metavariables in the premises to the\n    hoare_consequence_pre rule would be set to specific\n    values.  (Since P' doesn't appear in the conclusion of\n    hoare_consequence_pre, the process of unifying the conclusion\n    with the current goal doesn't constrain P' to a specific\n    assertion.)\n\n    This is annoying, both because the assertion is a bit long and\n    also because, in hoare_asgn_example1, the very next thing we are\n    going to do \u2014 applying the hoare_asgn rule \u2014 will tell us\n    exactly what it should be!  We can use eapply instead of apply\n    to tell Coq, essentially, \"Be patient: The missing part is going\n    to be filled in later in the proof.\"\n\n```", "```\n\n    In general, eapply H tactic works just like apply H except\n    that, instead of failing if unifying the goal with the conclusion\n    of H does not determine how to instantiate all of the variables\n    appearing in the premises of H, eapply H will replace these\n    variables with *existential variables* (written ?nnn), which\n    function as placeholders for expressions that will be\n    determined (by further unification) later in the proof. \n\n    In order for Qed to succeed, all existential variables need to\n    be determined by the end of the proof. Otherwise Coq\n    will (rightly) refuse to accept the proof. Remember that the Coq\n    tactics build proof objects, and proof objects containing\n    existential variables are not complete.\n\n```", "```\n\n    Coq gives a warning after apply HP.  (The warnings look\n    different between Coq 8.4 and Coq 8.5\\.  In 8.4, the warning says\n    \"No more subgoals but non-instantiated existential variables.\"  In\n    8.5, it says \"All the remaining goals are on the shelf,\" meaning\n    that we've finished all our top-level proof obligations but along\n    the way we've put some aside to be done later, and we have not\n    finished those.)  Trying to close the proof with Qed gives an\n    error.\n\n```", "```\n\n    An additional constraint is that existential variables cannot be\n    instantiated with terms containing ordinary variables that did not\n    exist at the time the existential variable was created.  (The\n    reason for this technical restriction is that allowing such\n    instantiation would lead to inconsistency of Coq's logic.)\n\n```", "```\n\n    Doing apply HP' above fails with the following error:\n\n```", "```\nAbort.\n\nLemma silly2_fixed :\n\u00a0\u00a0\u2200(P : nat \u2192 nat \u2192 Prop) (Q : nat \u2192 Prop),\n\u00a0\u00a0(\u2203y, P 42 y) \u2192\n\u00a0\u00a0(\u2200x y : nat, P x y \u2192 Q x) \u2192\n\u00a0\u00a0Q 42.\nProof.\n\u00a0\u00a0intros P Q HP HQ. destruct HP as [y HP'].\n\u00a0\u00a0eapply HQ. apply HP'.\nQed.\n\n```", "```\nLemma silly2_eassumption : \u2200(P : nat \u2192 nat \u2192 Prop) (Q : nat \u2192 Prop),\n\u00a0\u00a0(\u2203y, P 42 y) \u2192\n\u00a0\u00a0(\u2200x y : nat, P x y \u2192 Q x) \u2192\n\u00a0\u00a0Q 42.\nProof.\n\u00a0\u00a0intros P Q HP HQ. destruct HP as [y HP']. eapply HQ. eassumption.\nQed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0+\u00a01\u00a0\u2264\u00a05\u00a0}}\u00a0\u00a0X\u00a0::=\u00a0X\u00a0+\u00a01\u00a0\u00a0{{\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a00\u00a0\u2264\u00a03\u00a0\u2227\u00a03\u00a0\u2264\u00a05\u00a0}}\u00a0\u00a0X\u00a0::=\u00a03\u00a0\u00a0{{\u00a00\u00a0\u2264\u00a0X\u00a0\u2227\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\n    ...into formal statements (name them assn_sub_ex[1]' and \n   assn_sub_ex[2]') and use hoare_asgn and hoare_consequence_pre \n   to prove them.\n\n```", "```\n\n    \u2610\n\n```", "```\nTheorem hoare_skip : \u2200P,\n\u00a0\u00a0\u00a0\u00a0\u00a0{{P}} SKIP {{P}}.\n\n    Proof.\n\u00a0\u00a0intros P st st' H HP. inversion H. subst.\n\u00a0\u00a0assumption. Qed.\n\n```", "```\nTheorem hoare_seq : \u2200P Q R c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0{{Q}} c[2] {{R}} \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0{{P}} c[1] {{Q}} \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0{{P}} c[1];;c[2] {{R}}.\n\n    Proof.\n\u00a0\u00a0intros P Q R c[1] c[2] H[1] H[2] st st' H[12] Pre.\n\u00a0\u00a0inversion H[12]; subst.\n\u00a0\u00a0apply (H[1] st'0 st'); try assumption.\n\u00a0\u00a0apply (H[2] st st'0); assumption. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0a\u00a0=\u00a0n\u00a0}}\n\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0a;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0n\u00a0}}\u00a0\u00a0\u00a0\u00a0<----\u00a0decoration\u00a0for\u00a0Q\n\u00a0\u00a0\u00a0\u00a0SKIP\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0n\u00a0}}\n\n    Here's an example of a program involving both assignment and\n    sequencing.\n\n```", "```\n\n    We typically use hoare_seq in conjunction with\n    hoare_consequence_pre and the eapply tactic, as in this\n    example. \n\n#### Exercise: 2 stars, recommended (hoare_asgn_example4)\n\n    Translate this \"decorated program\" into a formal proof:\n\n```", "```\nExample hoare_asgn_example4 :\n\u00a0\u00a0{{fun st \u21d2 True}} (X ::= (ANum 1);; Y ::= (ANum 2))\n\u00a0\u00a0{{fun st \u21d2 st X = 1 \u2227 st Y = 2}}.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{X\u00a0\u2264\u00a0Y}}\u00a0c\u00a0{{Y\u00a0\u2264\u00a0X}}\n\n    Your proof should not need to use unfold hoare_triple.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 starsM (hoarestate1)\n\n    Explain why the following proposition can't be proven:\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n## Conditionals\n\n    What sort of rule do we want for reasoning about conditional\n    commands?  \n\n    Certainly, if the same assertion Q holds after executing \n    either of the branches, then it holds after the whole conditional.  \n    So we might be tempted to write:\n\n                        {{P}}\u00a0c[1]\u00a0{{Q}}\n           |\n\n                     |\n\n                        {{P}}\u00a0c[2]\u00a0{{Q}}\n           |\n\n           |\n\n* * *\n\n           |\n\n                        {{P}}\u00a0IFB\u00a0b\u00a0THEN\u00a0c[1]\u00a0ELSE\u00a0c[2]\u00a0{{Q}}\n           |\n\n                     |\n\n    However, this is rather weak. For example, using this rule,\n   we cannot show \n\n```", "```\nDefinition bassn b : Assertion :=\n\u00a0\u00a0fun st \u21d2 (beval st b = true).\n\n```", "```\nLemma bexp_eval_true : \u2200b st,\n\u00a0\u00a0beval st b = true \u2192 (bassn b) st.\n\n    Proof.\n\u00a0\u00a0intros b st Hbe.\n\u00a0\u00a0unfold [bassn](Hoare.html#bassn). assumption. Qed.\n\nLemma bexp_eval_false : \u2200b st,\n\u00a0\u00a0beval st b = false \u2192 \u00ac ((bassn b) st).\n\n    Proof.\n\u00a0\u00a0intros b st Hbe contra.\n\u00a0\u00a0unfold [bassn](Hoare.html#bassn) in contra.\n\u00a0\u00a0rewrite \u2192 contra in Hbe. inversion Hbe. Qed.\n\n```", "```\nTheorem hoare_if : \u2200P Q b c[1] c[2],\n\u00a0\u00a0{{fun st \u21d2 P st \u2227 bassn b st}} c[1] {{Q}} \u2192\n\u00a0\u00a0{{fun st \u21d2 P st \u2227 ~(bassn b st)}} c[2] {{Q}} \u2192\n\u00a0\u00a0{{P}} (IFB b THEN c[1] ELSE c[2] FI) {{Q}}.\n\n    Proof.\n\u00a0\u00a0intros P Q b c[1] c[2] HTrue HFalse st st' HE HP.\n\u00a0\u00a0inversion HE; subst.\n\u00a0\u00a0- (*\u00a0b\u00a0is\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply (HTrue st st').\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0split. assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [bexp_eval_true](Hoare.html#bexp_eval_true). assumption.\n\u00a0\u00a0- (*\u00a0b\u00a0is\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply (HFalse st st').\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0split. assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [bexp_eval_false](Hoare.html#bexp_eval_false). assumption. Qed.\n\n```", "```\nExample if_example :\n\u00a0\u00a0\u00a0\u00a0{{fun st \u21d2 True}}\n\u00a0\u00a0IFB (BEq (AId X) (ANum 0))\n\u00a0\u00a0\u00a0\u00a0THEN (Y ::= (ANum 2))\n\u00a0\u00a0\u00a0\u00a0ELSE (Y ::= APlus (AId X) (ANum 1))\n\u00a0\u00a0FI\n\u00a0\u00a0\u00a0\u00a0{{fun st \u21d2 st X \u2264 st Y}}.\n\n    Proof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0apply [hoare_if](Hoare.html#hoare_if).\n\u00a0\u00a0- (*\u00a0Then\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre). apply [hoare_asgn](Hoare.html#hoare_asgn).\n\u00a0\u00a0\u00a0\u00a0unfold [bassn](Hoare.html#bassn), [assn_sub](Hoare.html#assn_sub), [t_update](Maps.html#t_update), [assert_implies](Hoare.html#assert_implies).\n\u00a0\u00a0\u00a0\u00a0simpl. intros st [_ H].\n\u00a0\u00a0\u00a0\u00a0apply [beq_nat_true](http://coq.inria.fr/library/Coq.Arith.EqNat.html#beq_nat_true) in H.\n\u00a0\u00a0\u00a0\u00a0rewrite H. omega.\n\u00a0\u00a0- (*\u00a0Else\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre). apply [hoare_asgn](Hoare.html#hoare_asgn).\n\u00a0\u00a0\u00a0\u00a0unfold [assn_sub](Hoare.html#assn_sub), [t_update](Maps.html#t_update), [assert_implies](Hoare.html#assert_implies).\n\u00a0\u00a0\u00a0\u00a0simpl; intros st _. omega.\n    Qed.\n\n```", "```\nTheorem if_minus_plus :\n\u00a0\u00a0{{fun st \u21d2 True}}\n\u00a0\u00a0IFB (BLe (AId X) (AId Y))\n\u00a0\u00a0\u00a0\u00a0THEN (Z ::= AMinus (AId Y) (AId X))\n\u00a0\u00a0\u00a0\u00a0ELSE (Y ::= APlus (AId X) (AId Z))\n\u00a0\u00a0FI\n\u00a0\u00a0{{fun st \u21d2 st Y = st X + st Z}}.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n### Exercise: One-sided conditionals\n\n#### Exercise: 4 starsM (if1_hoare)\n\n    In this exercise we consider extending Imp with \"one-sided\n    conditionals\" of the form IF[1] b THEN c FI. Here b is a\n    boolean expression, and c is a command. If b evaluates to\n    true, then command c is evaluated. If b evaluates to\n    false, then IF[1] b THEN c FI does nothing.\n\n    We recommend that you do this exercise before the ones that\n    follow, as it should help solidify your understanding of the\n    material. \n\n    The first step is to extend the syntax of commands and introduce\n    the usual notations.  (We've done this for you.  We use a separate\n    module to prevent polluting the global name space.)\n\n```", "```\n\n    Next we need to extend the evaluation relation to accommodate\n    IF[1] branches.  This is for you to do... What rule(s) need to be\n    added to ceval to evaluate one-sided conditionals?\n\n```", "```\n\n    Now we repeat (verbatim) the definition and notation of Hoare triples.\n\n```", "```\n\n    Finally, we (i.e., you) need to state and prove a theorem,\n    hoare_if[1], that expresses an appropriate Hoare logic proof rule\n    for one-sided conditionals. Try to come up with a rule that is\n    both sound and as precise as possible.\n\n```", "```\n\n    For full credit, prove formally hoare_if1_good that your rule is\n    precise enough to show the following valid Hoare triple:\n\n```", "```\nLemma hoare_if1_good :\n\u00a0\u00a0{{ fun st \u21d2 st X + st Y = st Z }}\n\u00a0\u00a0IF[1] BNot (BEq (AId Y) (ANum 0)) THEN\n\u00a0\u00a0\u00a0\u00a0X ::= APlus (AId X) (AId Y)\n\u00a0\u00a0FI\n\u00a0\u00a0{{ fun st \u21d2 st X = st Z }}.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nEnd If[1].\n\n```", "```\n\n## Loops\n\n    Finally, we need a rule for reasoning about while loops. \n\n    Suppose we have a loop\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{P}}\u00a0WHILE\u00a0b\u00a0DO\u00a0c\u00a0END\u00a0{{Q}}\n\n    is a valid triple. \n\n    First of all, let's think about the case where b is false at the\n    beginning \u2014 i.e., let's assume that the loop body never executes\n    at all.  In this case, the loop behaves like SKIP, so we might\n    be tempted to write: \n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{P}}\u00a0WHILE\u00a0b\u00a0DO\u00a0c\u00a0END\u00a0{{P\u00a0\u2227\u00a0\u00acb}}\n\n    What about the case where the loop body *does* get executed?\n    In order to ensure that P holds when the loop finally\n    exits, we certainly need to make sure that the command c\n    guarantees that P holds whenever c is finished.\n    Moreover, since P holds at the beginning of the first\n    execution of c, and since each execution of c\n    re-establishes P when it finishes, we can always assume\n    that P holds at the beginning of c.  This leads us to the\n    following rule: \n\n                        {{P}}\u00a0c\u00a0{{P}}\n           |\n\n           |\n\n* * *\n\n           |\n\n                        {{P}}\u00a0WHILE\u00a0b\u00a0DO\u00a0c\u00a0END\u00a0{{P\u00a0\u2227\u00a0~b}}\n           |\n\n                     |\n\n    This is almost the rule we want, but again it can be improved a\n    little: at the beginning of the loop body, we know not only that\n    P holds, but also that the guard b is true in the current\n    state.  This gives us a little more information to use in\n    reasoning about c (showing that it establishes the invariant by\n    the time it finishes).  This gives us the final version of the\n    rule:\n\n                        {{P\u00a0\u2227\u00a0b}}\u00a0c\u00a0{{P}}\n           |\n\n                        (hoare_while) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{P}}\u00a0WHILE\u00a0b\u00a0DO\u00a0c\u00a0END\u00a0{{P\u00a0\u2227\u00a0~b}}\n           |\n\n                     |\n\n    The proposition P is called an *invariant* of the loop.\n\n```", "```\n\n    One subtlety in the terminology is that calling some assertion P\n    a \"loop invariant\" doesn't just mean that it is preserved by the\n    body of the loop in question (i.e., {{P}} c {{P}}, where c is\n    the loop body), but rather that P *together with the fact that the loop's guard is true* is a sufficient precondition for c to\n    ensure P as a postcondition.\n\n    This is a slightly (but significantly) weaker requirement.  For\n    example, if P is the assertion X = 0, then P *is* an\n    invariant of the loop\n\n```", "```\nExample while_example :\n\u00a0\u00a0\u00a0\u00a0{{fun st \u21d2 st X \u2264 3}}\n\u00a0\u00a0WHILE (BLe (AId X) (ANum 2))\n\u00a0\u00a0DO X ::= APlus (AId X) (ANum 1) END\n\u00a0\u00a0\u00a0\u00a0{{fun st \u21d2 st X = 3}}.\n\n    Proof.\n\u00a0\u00a0eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post).\n\u00a0\u00a0apply [hoare_while](Hoare.html#hoare_while).\n\u00a0\u00a0eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre).\n\u00a0\u00a0apply [hoare_asgn](Hoare.html#hoare_asgn).\n\u00a0\u00a0unfold [bassn](Hoare.html#bassn), [assn_sub](Hoare.html#assn_sub), [assert_implies](Hoare.html#assert_implies), [t_update](Maps.html#t_update). simpl.\n\u00a0\u00a0\u00a0\u00a0intros st [H[1] H[2]]. apply [leb_complete](http://coq.inria.fr/library/Coq.Arith.Compare_dec.html#leb_complete) in H[2]. omega.\n\u00a0\u00a0unfold [bassn](Hoare.html#bassn), [assert_implies](Hoare.html#assert_implies). intros st [Hle Hb].\n\u00a0\u00a0\u00a0\u00a0simpl in Hb. destruct ([leb](http://coq.inria.fr/library/Coq.Arith.Compare_dec.html#leb) (st [X](Imp.html#X)) 2) eqn : Heqle.\n\u00a0\u00a0\u00a0\u00a0exfalso. apply Hb; reflexivity.\n\u00a0\u00a0\u00a0\u00a0apply [leb_iff_conv](http://coq.inria.fr/library/Coq.Arith.Compare_dec.html#leb_iff_conv) in Heqle. omega.\n    Qed.\n\n```", "```\nTheorem always_loop_hoare : \u2200P Q,\n\u00a0\u00a0{{P}} WHILE BTrue DO SKIP END {{Q}}.\n\n    Proof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros P Q.\n\u00a0\u00a0apply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre) with (P' := fun st : [state](Imp.html#state) \u21d2 [True](http://coq.inria.fr/library/Coq.Init.Logic.html#True)).\n\u00a0\u00a0eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post).\n\u00a0\u00a0apply [hoare_while](Hoare.html#hoare_while).\n\u00a0\u00a0- (*\u00a0Loop\u00a0body\u00a0preserves\u00a0invariant\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply [hoare_post_true](Hoare.html#hoare_post_true). intros st. apply [I](http://coq.inria.fr/library/Coq.Init.Logic.html#I).\n\u00a0\u00a0- (*\u00a0Loop\u00a0invariant\u00a0and\u00a0negated\u00a0guard\u00a0imply\u00a0postcondition\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. intros st [Hinv Hguard].\n\u00a0\u00a0\u00a0\u00a0exfalso. apply Hguard. reflexivity.\n\u00a0\u00a0- (*\u00a0Precondition\u00a0implies\u00a0invariant\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros st H. constructor. Qed.\n\n```", "```\n\n### Exercise: REPEAT\n\n#### Exercise: 4 stars, advancedM (hoare_repeat)\n\n    In this exercise, we'll add a new command to our language of\n    commands: REPEAT c UNTIL a END. You will write the\n    evaluation rule for repeat and add a new Hoare rule to the\n    language for programs involving it.  (You may recall that the\n    evaluation rule is given in an example in the [Auto](Auto.html) chapter.\n    Try to figure it out yourself here rather than peeking.)\n\n```", "```\n\n    REPEAT behaves like WHILE, except that the loop guard is\n    checked *after* each execution of the body, with the loop\n    repeating as long as the guard stays *false*.  Because of this,\n    the body will always execute at least once.\n\n```", "```\n\n    Add new rules for REPEAT to ceval below.  You can use the rules\n    for WHILE as a guide, but remember that the body of a REPEAT\n    should always execute at least once, and that the loop ends when\n    the guard becomes true.  Then update the ceval_cases tactic to\n    handle these added cases.\n\n```", "```\n\n    A couple of definitions from above, copied here so they use the\n    new ceval.\n\n```", "```\n\n    To make sure you've got the evaluation rules for REPEAT right,\n    prove that ex1_repeat evaluates correctly.\n\n```", "```\n\n    Now state and prove a theorem, hoare_repeat, that expresses an\n    appropriate proof rule for repeat commands.  Use hoare_while\n    as a model, and try to make your rule as precise as possible.\n\n```", "```\n\n    For full credit, make sure (informally) that your rule can be used\n    to prove the following valid Hoare triple:\n\n```", "```\nEnd RepeatExercise.\n\n```", "```\n\n# Summary\n\n    So far, we've introduced Hoare Logic as a tool for reasoning about\n    Imp programs.  In the reminder of this chapter we'll explore a\n    systematic way to use Hoare Logic to prove properties about\n    programs. The rules of Hoare Logic are:\n\n           |\n\n                        (hoare_asgn) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{Q\u00a0[X\u00a0\u21a6\u00a0a]}}\u00a0X::=a\u00a0{{Q}}\n           |\n\n                     |\n\n           |\n\n                        (hoare_skip) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{\u00a0P\u00a0}}\u00a0SKIP\u00a0{{\u00a0P\u00a0}}\n           |\n\n                     |\n\n                        {{\u00a0P\u00a0}}\u00a0c[1]\u00a0{{\u00a0Q\u00a0}}\n           |\n\n                     |\n\n                        {{\u00a0Q\u00a0}}\u00a0c[2]\u00a0{{\u00a0R\u00a0}}\n           |\n\n                        (hoare_seq) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{\u00a0P\u00a0}}\u00a0c[1];;c[2]\u00a0{{\u00a0R\u00a0}}\n           |\n\n                     |\n\n                        {{P\u00a0\u2227\u00a0\u00a0b}}\u00a0c[1]\u00a0{{Q}}\n           |\n\n                     |\n\n                        {{P\u00a0\u2227\u00a0~b}}\u00a0c[2]\u00a0{{Q}}\n           |\n\n                        (hoare_if) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{P}}\u00a0IFB\u00a0b\u00a0THEN\u00a0c[1]\u00a0ELSE\u00a0c[2]\u00a0FI\u00a0{{Q}}\n           |\n\n                     |\n\n                        {{P\u00a0\u2227\u00a0b}}\u00a0c\u00a0{{P}}\n           |\n\n                        (hoare_while) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{P}}\u00a0WHILE\u00a0b\u00a0DO\u00a0c\u00a0END\u00a0{{P\u00a0\u2227\u00a0~b}}\n           |\n\n                     |\n\n                        {{P'}}\u00a0c\u00a0{{Q'}}\n           |\n\n                     |\n\n                        P\u00a0\u21fe\u00a0P'\n           |\n\n                     |\n\n                        Q'\u00a0\u21fe\u00a0Q\n           |\n\n                        (hoare_consequence) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {{P}}\u00a0c\u00a0{{Q}}\n           |\n\n                     |\n\n    In the next chapter, we'll see how these rules are used to prove\n    that programs satisfy specifications of their behavior.\n\n```", "```\nModule Himp.\n\nInductive com : Type :=\n\u00a0\u00a0| CSkip : com\n\u00a0\u00a0| CAsgn : id \u2192 aexp \u2192 com\n\u00a0\u00a0| CSeq : com \u2192 com \u2192 com\n\u00a0\u00a0| CIf : bexp \u2192 com \u2192 com \u2192 com\n\u00a0\u00a0| CWhile : bexp \u2192 com \u2192 com\n\u00a0\u00a0| CHavoc : id \u2192 com.\n\nNotation \"'SKIP'\" :=\n\u00a0\u00a0CSkip.\nNotation \"X '::=' a\" :=\n\u00a0\u00a0(CAsgn X a) (at level 60).\nNotation \"c1 ;; c2\" :=\n\u00a0\u00a0(CSeq c[1] c[2]) (at level 80, right associativity).\nNotation \"'WHILE' b 'DO' c 'END'\" :=\n\u00a0\u00a0(CWhile b c) (at level 80, right associativity).\nNotation \"'IFB' e1 'THEN' e2 'ELSE' e3 'FI'\" :=\n\u00a0\u00a0(CIf e[1] e[2] e[3]) (at level 80, right associativity).\nNotation \"'HAVOC' X\" := (CHavoc X) (at level 60).\n\nReserved Notation \"c1 '/' st '\u21d3' st'\" (at level 40, st at level 39).\n\nInductive ceval : com \u2192 state \u2192 state \u2192 Prop :=\n\u00a0\u00a0| E_Skip : \u2200st : state, SKIP / st \u21d3 st\n\u00a0\u00a0| E_Ass : \u2200(st : state) (a[1] : aexp) (n : nat) (X : id),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aeval st a[1] = n \u2192 (X ::= a[1]) / st \u21d3 t_update st X n\n\u00a0\u00a0| E_Seq : \u2200(c[1] c[2] : com) (st st' st'' : state),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1] / st \u21d3 st' \u2192 c[2] / st' \u21d3 st'' \u2192 (c[1] ;; c[2]) / st \u21d3 st''\n\u00a0\u00a0| E_IfTrue : \u2200(st st' : state) (b[1] : bexp) (c[1] c[2] : com),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st b[1] = true \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1] / st \u21d3 st' \u2192 (IFB b[1] THEN c[1] ELSE c[2] FI) / st \u21d3 st'\n\u00a0\u00a0| E_IfFalse : \u2200(st st' : state) (b[1] : bexp) (c[1] c[2] : com),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st b[1] = false \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[2] / st \u21d3 st' \u2192 (IFB b[1] THEN c[1] ELSE c[2] FI) / st \u21d3 st'\n\u00a0\u00a0| E_WhileEnd : \u2200(b[1] : bexp) (st : state) (c[1] : com),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st b[1] = false \u2192 (WHILE b[1] DO c[1] END) / st \u21d3 st\n\u00a0\u00a0| E_WhileLoop : \u2200(st st' st'' : state) (b[1] : bexp) (c[1] : com),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st b[1] = true \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1] / st \u21d3 st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(WHILE b[1] DO c[1] END) / st' \u21d3 st'' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(WHILE b[1] DO c[1] END) / st \u21d3 st''\n\u00a0\u00a0| E_Havoc : \u2200(st : state) (X : id) (n : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(HAVOC X) / st \u21d3 t_update st X n\n\n\u00a0\u00a0where \"c1 '/' st '\u21d3' st'\" := (ceval c[1] st st').\n\n```", "```\nDefinition hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop :=\n\u00a0\u00a0\u2200st st', c / st \u21d3 st' \u2192 P st \u2192 Q st'.\n\nNotation \"{{ P }}  c  {{ Q }}\" := (hoare_triple P c Q)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 90, c at next level)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: hoare_spec_scope.\n\n```", "```\nDefinition havoc_pre (X : id) (Q : Assertion) : Assertion \n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nTheorem hoare_havoc : \u2200(Q : Assertion) (X : id),\n\u00a0\u00a0{{ havoc_pre X Q }} HAVOC X {{ Q }}.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nEnd Himp.\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]