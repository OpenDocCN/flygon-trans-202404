- en: '16Checking Program Invariants Dynamically: Contracts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16检查程序不变量的动态性：合同
- en: '|     [16.1 Contracts as Predicates](#(part._.Contracts_as_.Predicates)) |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [16.1 合同作为谓词](#(part._.Contracts_as_.Predicates)) |'
- en: '|     [16.2 Tags, Types, and Observations on Values](#(part._.Tags__.Types__and_.Observations_on_.Values))
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [16.2 标签、类型和对值的观察](#(part._.Tags__.Types__and_.Observations_on_.Values))
    |'
- en: '|     [16.3 Higher-Order Contracts](#(part._.Higher-.Order_.Contracts)) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [16.3 高阶合同](#(part._.Higher-.Order_.Contracts)) |'
- en: '|     [16.4 Syntactic Convenience](#(part._.Syntactic_.Convenience)) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|     [16.4 语法便利](#(part._.Syntactic_.Convenience)) |'
- en: '|     [16.5 Extending to Compound Data Structures](#(part._.Extending_to_.Compound_.Data_.Structures))
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|     [16.5 扩展到复合数据结构](#(part._.Extending_to_.Compound_.Data_.Structures))
    |'
- en: '|     [16.6 More on Contracts and Observations](#(part._.More_on_.Contracts_and_.Observations))
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|     [16.6 更多关于合同和观察](#(part._.More_on_.Contracts_and_.Observations)) |'
- en: '|     [16.7 Contracts and Mutation](#(part._.Contracts_and_.Mutation)) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|     [16.7 合同和突变](#(part._.Contracts_and_.Mutation)) |'
- en: '|     [16.8 Combining Contracts](#(part._.Combining_.Contracts)) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|     [16.8 合并合同](#(part._.Combining_.Contracts)) |'
- en: '|     [16.9 Blame](#(part._.Blame)) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|     [16.9 责备](#(part._.Blame)) |'
- en: Type systems offer rich and valuable ways to represent program invariants. However,
    they also represent an important trade-off, because not all non-trivial properties
    of programs can be verified staticallyThis is a formal property, known as [Rice’s
    Theorem](http://en.wikipedia.org/wiki/Rice's_theorem).. Furthermore, even if we
    can devise a method to settle a certain property statically, the burdens of annotation
    and computational complexity may be too great. Thus, it is inevitable that some
    of the properties we care about must either be ignored or settled only at run-time.
    Here, we will discuss run-time enforcement.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统提供了丰富而有价值的方法来表示程序不变量。然而，它们也代表着一个重要的权衡，因为并非所有程序的非平凡属性都可以静态验证，这是一个正式的属性，被称为[Rice's
    Theorem](http://en.wikipedia.org/wiki/Rice's_theorem)。此外，即使我们可以设计一种方法来静态解决某个属性，注释和计算复杂性的负担可能过重。因此，我们关心的一些属性不可避免地必须被忽略或仅在运行时解决。在这里，我们将讨论运行时执行。
- en: 'Virtually every programming language has some form of assertion mechanism that
    enables programmers to write properties that are richer than the language’s static
    type system permits. In languages without static types, these properties might
    start with simple type-like assertions: whether a parameter is numeric, for instance.
    However, the language of assertions is often the entire programming language,
    so any predicate can be used as an assertion: for instance, an implementation
    of a cryptography package might want to ensure certain parameters pass a primality
    test, or a balanced binary search-tree might want to ensure that its subtrees
    are indeed balanced and preserve the search-tree ordering.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种编程语言都有一种断言机制，使程序员能够编写比语言的静态类型系统允许的更丰富的属性。在没有静态类型的语言中，这些属性可能从简单的类似类型的断言开始：例如，一个参数是否是数字。然而，断言的语言通常是整个编程语言，因此任何谓词都可以用作断言：例如，加密包的实现可能希望确保某些参数通过素数测试，或者平衡的二叉搜索树可能希望确保其子树确实是平衡的并保留搜索树的顺序。
- en: 16.1Contracts as Predicates
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1合同作为谓词
- en: 'It is therefore easy to see how to implement simple contracts.In what follows
    we will use the language #lang plai, for two reasons. First, this better simulates
    programming in an untyped language. Second, for simplicity we will write type-like
    assertions as contracts, but in the typed language these will be flagged by the
    type-checker itself, not letting us see the run-time behavior. In effect, it is
    easier to “turn off” the type checker. However, contracts make perfect sense even
    in a typed world, because they enhance the set of invariants that a programmer
    can express. A contract embodies a predicate. It consumes a value and applies
    the predicate to the value. If the value passes the predicate, the contract returns
    the value unmolested; if the value fails, the contract reports an error. Its only
    behaviors are to return the supplied value or to error: it should not change the
    value in any way. In short, on values that pass the predicate, the contact itself
    acts as the identity function.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，很容易看出如何实现简单的合同。在接下来的内容中，我们将使用语言 #lang plai，有两个原因。首先，这更好地模拟了在无类型语言中编程。其次，为了简单起见，我们将将类型样式的断言写成合同，但在有类型的语言中，这些将被类型检查器本身标记，不让我们看到运行时行为。实际上，关闭类型检查器更容易。然而，合同即使在有类型的世界中也是有意义的，因为它们增强了程序员可以表达的不变性集合。合同体现了一个谓词。它消耗一个值并将谓词应用于该值。如果值通过了谓词，合同将返回该值；如果值失败，合同将报告一个错误。它的唯一行为是返回提供的值或报错：它不应以任何方式改变值。简而言之，在通过谓词的值上，合同本身就像是一个恒等函数。'
- en: 'We can encode this essence in the following function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下函数中编码这个本质：
- en: '| (define (make-contract pred?) |'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (make-contract pred?) |'
- en: '|   (lambda (val) |'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (val) |'
- en: '|     (if (pred? val) val (blame "violation")))) |'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (if (pred? val) val (blame "violation")))) |'
- en: '|   |'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define (blame s) (error ''contract "~a" s)) |'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (blame s) (error ''contract "~a" s)) |'
- en: 'Here’s an example contract:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例合同：
- en: '| (define non-neg?-contract |'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define non-neg?-contract |'
- en: '|   (make-contract |'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (make-contract |'
- en: '|    (lambda (n) (and (number? n) |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    (lambda (n) (and (number? n) |'
- en: '|                     (>= n 0))))) |'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                     (>= n 0))))) |'
- en: (In a typed language, the number? check would of course be unnecessary because
    it can be encoded—<wbr>and statically checked!—<wbr>in the type of the function
    using the contract.) Suppose we want to make sure we don’t get imaginary numbers
    when computing square roots; we might write
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: （在一个有类型的语言中，number? 检查当然是不必要的，因为它可以被编码—<wbr>并静态检查！—<wbr>在使用合同的函数类型中。）假设我们想确保在计算平方根时不会得到虚数；我们可能会写
- en: '| (define (real-sqrt-1 x) |'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (real-sqrt-1 x) |'
- en: '|   (sqrt (non-neg?-contract x))) |'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (sqrt (non-neg?-contract x))) |'
- en: 'In many languages assertions are written as statements rather than as expressions,
    so an alternate way to write this would be:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，断言是作为语句而不是表达式编写的，因此另一种编写方式是：
- en: '| (define (real-sqrt-2 x) |'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (real-sqrt-2 x) |'
- en: '|   (begin |'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (begin |'
- en: '|     (non-neg?-contract x) |'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (non-neg?-contract x) |'
- en: '|     (sqrt x))) |'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (sqrt x))) |'
- en: (In some cases this form is clearer because it states crisply at the beginning
    of the function what is expected of the parameters. It also enables parameters
    to be checked just once. Indeed, in some languages the contract can be written
    in the function header itself, thereby improving the information given in the
    interface.) Now if real-sqrt-1 or real-sqrt-2 are applied to 4 they produce 2,
    but if applied to -1 they raise a contract violation error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: （在某些情况下，这种形式更清晰，因为它在函数的开头清晰地说明了参数的期望。它还使得参数只需检查一次。实际上，在某些语言中，合同可以直接写在函数头部，从而提高接口中给定的信息。）现在如果将
    real-sqrt-1 或 real-sqrt-2 应用于 4，它们会产生 2，但如果应用于 -1，它们会引发合同违规错误。
- en: 16.2Tags, Types, and Observations on Values
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2标签、类型和值的观察
- en: At this point we’ve reproduced the essence of assertion systems in most languages.
    What else is there to say? Let’s suppose for a moment that our language is not
    statically typed. Then we will want to write assertions that reproduce at least
    traditional type-like invariants, if not more. make-contract above can capture
    all standard type-like properties such as checking for numbers, strings, and so
    on, assuming the appropriate predicates are either provided by the language or
    can be fashioned from the ones given. Or can it?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在大多数语言中复制了断言系统的本质。还有什么要说的？让我们假设一下，我们的语言不是静态类型的。那么我们将希望编写至少复制传统类型样式不变性的断言，如果可能的话更多。上面的
    make-contract 可以捕捉所有标准类型样式的属性，比如检查数字、字符串等，假设适当的谓词要么由语言提供，要么可以从给定的谓词中制作。或者可以吗？
- en: Recall that even our simplest type language had not just base types, like numbers,
    but also constructed types. While some of these, like lists and vectors, appear
    to not be very challenging, they are once we care about mutation, performance,
    and blame, which we discuss below. However, functions are immediately problematic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使是我们最简单的类型语言也不仅仅有基本类型，比如数字，还有构造类型。虽然其中一些，比如列表和向量，看起来似乎并不是很具有挑战性，但是一旦我们关心变异、性能和责任，它们就会变得复杂，我们将在下面讨论这些问题。然而，函数立即成为问题。
- en: 'As a working example, we will take the following function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个工作示例，我们将采用以下函数：
- en: '| (define d/dx |'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define d/dx |'
- en: '|   (lambda (f) |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (f) |'
- en: '|     (lambda (x) |'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (lambda (x) |'
- en: '|       (/ (- (f (+ x 0.001)) |'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (/ (- (f (+ x 0.001)) |'
- en: '|             (f x)) |'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             (f x)) |'
- en: '|          0.001)))) |'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          0.001)))) |'
- en: Statically, we would give this the type
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 静态地，我们会给这个类型
- en: '| ((number -> number) -> (number -> number)) |'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((number -> number) -> (number -> number)) |'
- en: (it consumes a function, and produces its derivative—<wbr>another function).
    Let us suppose we want to guard this with contracts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: （它接受一个函数，并产生其导数—<wbr>另一个函数）。假设我们想要用合同保护这个函数。
- en: 'The fundamental problem is that in most languages, we cannot directly express
    this as a predicate. Most language run-time systems store very limited information
    about the types of values—<wbr>so limited that, relative to the types we have
    seen so far, we should use a different name to describe this information; traditionally
    they are called tags.There have been a few efforts to preserve rich type information
    from the source program through lower levels of abstraction all the way down to
    assembly language, but these are research efforts. Sometimes tags coincide with
    what we might regard as types: for instance, a number will have a tag identifying
    it as a number (perhaps even a specific kind of number), a string will have a
    tag identifying it as a string, and so forth. Thus we can write predicates based
    on the values of these tags.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根本问题在于，在大多数语言中，我们无法直接将其表达为谓词。大多数语言运行时系统对值的类型存储的信息非常有限—<wbr>如此有限，以至于相对于我们迄今为止看到的类型，我们应该使用不同的名称来描述这些信息；传统上它们被称为标签。有一些努力通过从源程序到汇编语言的更低层抽象来保留丰富的类型信息，但这些都是研究工作。有时标签与我们可能认为的类型相符：例如，一个数字将具有标识它为数字的标签（甚至可能是特定类型的数字），一个字符串将具有标识它为字符串的标签，依此类推。因此，我们可以根据这些标签的值编写谓词。
- en: When we get to structured values, however, the situation is more complex. A
    vector would have a tag declaring it to be a vector, but not dictating what kinds
    of values its elements are (and they may not even all be of the same kind); however,
    a program can usually also obtain its size, and thus traverse it, to gather this
    information. (There is, however, more to be said about structured values below
    [REF].)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们涉及结构化值时，情况就更加复杂了。一个向量会有一个声明它是向量的标签，但不会规定其元素是什么类型的值（它们甚至可能不全是同一种类型）；然而，程序通常也可以获取其大小，从而遍历它，以收集这些信息。（然而，关于结构化值还有更多内容要讨论[REF]。）
- en: Do Now!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做！
- en: Write a contract that checks that a list consists solely of even numbers.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个检查列表是否完全由偶数组成的合同。
- en: 'Here it is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是：
- en: '| (define list-of-even?-contract |'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define list-of-even?-contract |'
- en: '|   (make-contract |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (make-contract |'
- en: '|    (lambda (l) |'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    (lambda (l) |'
- en: '|      (and (list? l) (andmap number? l) (andmap even? l))))) |'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (and (list? l) (andmap number? l) (andmap even? l))))) |'
- en: (Again, note that the first two questions need not be asked if we know, statically,
    that we have a list of numbers.) Similarly, an object might simply identify itself
    as an object, not providing additional information. But in languages that permit
    reflection on the object’s structure, a contract can still gather the information
    it needs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: （再次注意，如果我们静态地知道我们有一个数字列表，那么前两个问题就不需要问了。同样，一个对象可能只是将自己标识为一个对象，而不提供额外的信息。但是在允许反射对象结构的语言中，合同仍然可以收集所需的信息。）
- en: In every language, however, this becomes problematic when we encounter functions.
    We might think of a function as having a type for its domain and range, but to
    a run-time system, a function is just an opaque object with a function tag, and
    perhaps some very limited metadata (such as the function’s arity). The run-time
    system can hardly even tell whether the function consumes and produces functions—<wbr>as
    opposed to other kinds of values—<wbr>much less whether it consumes and produces
    ones of (number -> number) type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在每种语言中，当我们遇到函数时，这变得棘手。我们可能认为函数有一个针对其定义域和值域的类型，但对于运行时系统而言，函数只是一个带有函数标签的不透明对象，也许还带有一些非常有限的元数据（例如函数的元数）。运行时系统几乎无法判断函数是否消耗和产生函数，<wbr>而不是其他类型的值，<wbr>更不用说它是否消耗和产生（number
    -> number）类型的函数了。
- en: This problem is nicely embodied in the (misnamed) typeof operator in JavaScript.
    Given values of base types like numbers and strings, typeof returns a string to
    that effect (e.g., "number"). For objects, it returns "object". Most importantly,
    for functions it returns "function", with no additional information.For this reason,
    perhaps typeof is a bad name for this operator. It should have been called tagof
    instead, leaving open the possibility that future static type systems for JavaScript
    could provide a true typeof.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在JavaScript中的（错误命名的）typeof操作符中得到了很好的体现。对于基本类型（如数字和字符串）的值，typeof返回一个对应的字符串（例如，"number"）。对于对象，它返回"object"。最重要的是，对于函数，它返回"function"，没有其他附加信息。因此，也许typeof是这个操作符的一个糟糕的名称。它应该被称为tagof，留下了JavaScript未来的静态类型系统可以提供真正的typeof的可能性。
- en: To summarize, this means that at the point of being confronted with a function,
    a function contract can only check that it is, indeed, a function (and if it is
    not, that is clearly an error). It cannot check anything about the domain and
    range of the function. Should we give up?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这意味着在面对一个函数时，函数契约只能检查它确实是一个函数（如果不是，那显然是一个错误）。它不能检查函数的定义域和值域。我们应该放弃吗？
- en: 16.3Higher-Order Contracts
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3高阶契约
- en: To determine what to do, it helps to recall what sort of guarantee contracts
    provide in the first place. In real-sqrt-1 above, we demanded that the argument
    be non-negative. However, this is only checked if—<wbr>and when—<wbr>real-sqrt-1
    is actually used, and then only on the actual values that are passed to it. For
    instance, if the program contains this fragment
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定该做什么，最好回顾一下契约首先提供了什么样的保证。在上面的real-sqrt-1中，我们要求参数是非负的。然而，这仅在实际使用real-sqrt-1时进行检查，然后仅对传递给它的实际值进行检查。例如，如果程序包含以下片段
- en: '| (lambda () (real-sqrt-1 -1)) |'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (lambda () (real-sqrt-1 -1)) |'
- en: but this thunk is never invoked, the programmer would never see this contract
    violation. In fact, it may be that the thunk is not invoked on this run of the
    program, but in a later run it will be; thus, the program has a lurking contract
    error. For this reason, it is usually preferable to express invariants through
    static types; but where we do use contracts, we understand that it is with the
    caveat that we will only be notified of errors when the program is suitably exercised.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果这个惰性求值永远不被调用，程序员就永远看不到这个契约违规。事实上，也许在程序的这次运行中不会调用这个惰性求值，但在后续的运行中会调用它；因此，程序存在潜在的契约错误。出于这个原因，最好通过静态类型来表达不变式；但是当我们使用契约时，我们了解到，只有当程序被适当地运行时，我们才会收到错误通知。
- en: This is a useful insight, because it offers a solution to our problem with functions.
    We check, immediately, that the purported function value truly is a function.
    However, instead of ignoring the domain and range contracts, we defer them. We
    check the domain contract when (and each time) the function is actually applied
    to a value, and we check the range contract when the function actually returns
    a value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的见解，因为它提供了解决函数问题的方法。我们立即检查所谓的函数值确实是一个函数。然而，我们没有忽视定义域和值域契约，而是推迟了它们。当（每次）函数实际应用于一个值时，我们检查定义域契约，并且当函数实际返回一个值时，我们检查值域契约。
- en: 'This is clearly a different pattern than make-contract followed. Thus, we should
    give make-contract a more descriptive name: it checks immediate contracts (i.e.,
    those that can be checked in their entirety now).In the Racket contract system,
    immediate contracts are called flat. This term is slightly misleading, since they
    can also protect data structures.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是与make-contract的不同模式。因此，我们应该给make-contract一个更具描述性的名称：它检查立即合同（即，现在可以完全检查的合同）。在Racket合同系统中，立即合同称为flat。这个术语有点误导，因为它们也可以保护数据结构。
- en: '| (define (immediate pred?) |'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (immediate pred?) |'
- en: '|   (lambda (val) |'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (val) |'
- en: '|     (if (pred? val) val (blame val)))) |'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (if (pred? val) val (blame val)))) |'
- en: 'In contrast, a function contract takes two contracts as arguments—<wbr>representing
    checks to be made on the domain and range—<wbr>and returns a predicate. This is
    the predicate to apply on values purporting to satisfy that contract. First, this
    checks that the given value actually is a function: this part is still immediate.
    Then, we create a surrogate procedure that applies the “residual” contracts—<wbr>to
    check the domain and range—<wbr>but otherwise behaves the same as the original
    function.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，函数合同接受两个合同作为参数——表示要在定义域和值域上进行检查——并返回一个谓词。这是应用于声称满足该合同的值的谓词。首先，这检查给定值实际上是一个函数：这部分仍然是立即的。然后，我们创建一个替代者过程，应用“剩余”合同——检查定义域和值域——但在其他方面行为与原始函数相同。
- en: 'This creation of a surrogate represents a departure from the traditional assertion
    mechanism, which simply checks values and then leaves them alone. Instead, for
    functions we must use the created surrogate if we want contract checking. In general,
    therefore, it is useful to have a wrapper that consumes a contract and value,
    and creates a guarded version of that value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样一个替代者代表了与传统断言机制的分离，后者简单地检查值，然后将其保持不变。相反，对于函数，如果我们想要合同检查，我们必须使用创建的替代者。因此，一般来说，有一个消耗合同和值，并创建该值的受保护版本的包装器是有用的：
- en: '| (define (guard ctc val) (ctc val)) |'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (guard ctc val) (ctc val)) |'
- en: 'As a very simple example, let us suppose we want to wrap the add1 function
    in numeric contracts (with function, the constructor of function contracts, to
    be defined momentarily):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简单的例子，让我们假设我们想要在数字合同中包装add1函数（其中函数是函数合同的构造函数，稍后将定义）：
- en: '| (define a1 (guard (function (immediate number?) |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define a1 (guard (function (immediate number?) |'
- en: '|                             (immediate number?)) |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                             (immediate number?)) |'
- en: '|                   add1)) |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   add1)) |'
- en: 'We want a1 to be bound to essentially the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望a1被绑定到基本上以下代码：
- en: '| (define a1 |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define a1 |'
- en: '|   (lambda (x) |'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (x) |'
- en: '|     (num?-con (add1 (num?-con x))))) |'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (num?-con (add1 (num?-con x))))) |'
- en: 'Here, the (lambda (x) ...) is the surrogate; it applies two numeric contracts
    around the invocation of add1. Recall that contracts must behave like the identity
    function in the absence of violations, so this procedure has precisely the same
    behavior as add1 on non-violating uses.To achieve this, we use the following definition
    of function.For simplicity we assume single-argument functions here, but the extension
    to multiple arity is straightforward. Indeed, more complex contracts can even
    check for relationships between the arguments. Remember that we have to also ensure
    that the given value is truly a function (as add1 above indeed is, and can be
    checked immediately, which is why the check has disappeared by the time we bind
    the surrogate to a1):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，(lambda (x) ...) 是替代者；它在调用add1周围应用了两个数字合同。请记住，合同在没有违规行为时必须像恒等函数一样运行，因此在未违反使用时，此过程与非违反使用的add1完全相同。为了实现这一点，我们使用以下函数定义。为了简单起见，我们在这里假设单参数函数，但对于多个参数的扩展是直接的。事实上，更复杂的合同甚至可以检查参数之间的关系。请记住，我们还必须确保给定的值确实是一个函数（就像上面的add1确实是的，而且可以立即检查，这就是为什么在将替代者绑定到a1时检查已经消失的原因）：
- en: '| (define (function dom rng) |'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (function dom rng) |'
- en: '|   (lambda (val) |'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (val) |'
- en: '|     (if (procedure? val) |'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (if (procedure? val) |'
- en: '|         (lambda (x) (rng (val (dom x)))) |'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (lambda (x) (rng (val (dom x)))) |'
- en: '|         (blame val)))) |'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (blame val)))) |'
- en: 'To understand how this works, let us substitute arguments. To keep the resulting
    code readable, we will first construct the number? contract checker and give it
    a name:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，让我们替换参数。为了保持结果代码的可读性，我们将首先构造number?合同检查器并给它一个名字：
- en: '|   (define num?-con (immediate number?)) |'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (define num?-con (immediate number?)) |'
- en: '| = (define num?-con |'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| = (define num?-con |'
- en: '|     (lambda (val) |'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (lambda (val) |'
- en: '|       (if (number? val) val (blame val)))) |'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (如果（number? val）val (blame val)))) |'
- en: 'Now let’s return to the definition of a1. First we apply guard:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到a1的定义。首先我们应用保护：
- en: '| (define a1 |'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define a1 |'
- en: '|   ((function num?-con num?-con) |'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ((function num?-con num?-con) |'
- en: '|    add1)) |'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    add1)) |'
- en: 'Now we apply the function contract constructor:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用函数合同构造器：
- en: '| (define a1 |'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define a1 |'
- en: '|   ((lambda (val) |'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ((lambda (val) |'
- en: '|      (if (procedure? val) |'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (if (procedure? val) |'
- en: '|          (lambda (x) (num?-con (val (num?-con x)))) |'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (lambda (x) (num?-con (val (num?-con x)))) |'
- en: '|          (blame val))) |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (blame val))) |'
- en: '|    add1)) |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    add1)) |'
- en: 'Applying the left-left-lambda gives:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应用左-左-λ得：
- en: '| (define a1 |'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define a1 |'
- en: '|   (if (procedure? add1) |'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (if (procedure? add1) |'
- en: '|       (lambda (x) (num?-con (add1 (num?-con x)))) |'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (lambda (x) (num?-con (add1 (num?-con x)))) |'
- en: '|       (blame add1))) |'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (blame add1))) |'
- en: Notice that this immediately checks that the guarded value is indeed a function.
    Thus we get
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这立即检查受保护的值是否确实是一个函数。因此我们得到
- en: '| (define a1 |'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define a1 |'
- en: '|   (lambda (x) |'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (x) |'
- en: '|     (num?-con (add1 (num?-con x))))) |'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (num?-con (add1 (num?-con x))))) |'
- en: which is precisely the surrogate we desired, with the behavior of add1 on non-violating
    executions.Do Now!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这恰好是我们想要的替代品，具有对非违规执行的add1行为。现在做吧！
- en: How many ways are there to violate the above contract for add1?
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有多少种方式违反上述add1合同？
- en: 'There are three ways, corresponding to the three contract constructors:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式，对应三种合同构造器：
- en: the value wrapped might not be a function;
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包装的值可能不是一个函数；
- en: the wrapped value might be a function that is applied to a non-numeric value;
    or,
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包装的值可能是一个应用于非数字值的函数；或者，
- en: the wrapped value might be a function that consumes numbers but produces values
    of non-numeric type.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包装的值可能是一个接受数字但产生非数字类型值的函数。
- en: Exercise
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Write examples that perform each of these three violations, and observe the
    behavior of the contract system. Can you improve the error messages to better
    distinguish these cases?
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写执行这三种违规行为的示例，并观察合同系统的行为。您能改进错误消息以更好地区分这些情况吗？
- en: 'The same wrapping technique works for d/dx as well:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的封装技术也适用于d/dx：
- en: '| (define d/dx |'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define d/dx |'
- en: '|   (guard (function (function (immediate number?) (immediate number?)) |'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (guard (function (function (immediate number?) (immediate number?)) |'
- en: '|                    (function (immediate number?) (immediate number?))) |'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (function (immediate number?) (immediate number?))) |'
- en: '|          (lambda (f) |'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (lambda (f) |'
- en: '|            (lambda (x) |'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (lambda (x) |'
- en: '|              (/ (- (f (+ x 0.001)) |'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (/ (- (f (+ x 0.001)) |'
- en: '|                    (f x)) |'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (f x)) |'
- en: '|                 0.001))))) |'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 0.001))))) |'
- en: Exercise
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: There are seven ways to violate this contract, corresponding to each of the
    seven contract constructors. Violate each of them by passing arguments or modifying
    code, as needed. Can you improve error reporting to correctly identify each kind
    of violation?
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有七种违反这个合同的方式，对应七个合同构造器。通过传递参数或修改代码来违反它们中的每一个。您能改进错误报告以正确识别每种违规吗？
- en: 'Notice that the nested function contract defers the checking of the immediate
    contracts for two applications, rather than one. This is what we should expect,
    because immediate contracts only report problems with actual values, so they cannot
    report anything until applied to actual values. However, this does mean that the
    notion of “violation”’ is subtle: the function value passed to d/dx may in fact
    truly be in violation of the contract, but this violation will not be observed
    until numeric values are passed or returned.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，嵌套的函数合同延迟对两个应用的即时合同的检查，而不是一个。这是我们应该期望的，因为即时合同只报告实际值的问题，所以它们在应用到实际值之前无法报告任何问题。然而，这确实意味着“违反”的概念是微妙的：传递给d/dx的函数值实际上可能确实违反了合同，但是直到传递或返回数值才会观察到这种违反。
- en: 16.4Syntactic Convenience
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4语法便利
- en: 'Earlier we saw two styles of using flat contracts, as embodied in real-sqrt-1
    and real-sqrt-2. Both styles have disadvantages. The latter, which is reminiscent
    of traditional assertion systems, simply does not work for higher-order values,
    because it is the wrapped value that must be used in the computation. (Not surprisingly,
    traditional assertion systems only handle immediate contracts, so they fail to
    notice this subtlety.) The style in the former, where we wrap each use with a
    contract, works in theory but suffers from three downsides:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候我们看到了两种使用平面合约的风格，如real-sqrt-1和real-sqrt-2所体现的那样。这两种风格都有缺点。后者，让人想起传统的断言系统，简单地不能用于高阶值，因为计算必须使用包装后的值。(毫不奇怪，传统的断言系统只处理即时合同，所以它们未能注意到这种微妙之处。)在前者的风格中，我们将每个使用都用合约包装起来，在理论上是可行的，但存在三个缺点：
- en: The developer may forget to wrap some uses.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员可能会忘记包装一些用法。
- en: The contract is checked once per use, which is wasteful when there is more than
    one use.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次使用都会检查合约，当有多个使用时会浪费资源。
- en: The program comingles contract checking with its functional behavior, reducing
    readability.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序将合同检查与其功能行为混合在一起，降低了可读性。
- en: Fortunately, a judicious use of syntactic sugar can solve this problem in common
    cases. For instance, suppose we want to make it easy to attach contracts to function
    parameters, so a developer could write
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在常见情况下，适度使用语法糖可以解决这个问题。例如，假设我们想要方便地将合同附加到函数参数上，这样开发人员可以编写
- en: '| (define/contract (real-sqrt (x :: (immediate positive?))) |'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define/contract (real-sqrt (x :: (immediate positive?))) |'
- en: '|   (sqrt x)) |'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (sqrt x)) |'
- en: with the intent of guarding x with positive?, but performing the check only
    once, on function invocation. This should translate to, say,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以保护x为positive?，但只在函数调用时执行检查。这应该转换为，比如说，
- en: '| (define (real-sqrt new-x) |'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (real-sqrt new-x) |'
- en: '|   (let ([x (guard (immediate positive?) new-x)]) |'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([x (guard (immediate positive?) new-x)]) |'
- en: '|     (sqrt x))) |'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (sqrt x))) |'
- en: 'That is, the macro generates a fresh name for each identifier, then associates
    the name given by the user to the wrapped version of the value supplied to that
    fresh name. The following macro implements exactly this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，该宏为每个标识符生成一个新的名称，然后将用户给定的名称与提供给该新名称的值的包装版本关联起来。以下宏完全实现了这一点：
- en: '| (define-syntax (define/contract stx) |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (define/contract stx) |'
- en: '|   (syntax-case stx (::) |'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case stx (::) |'
- en: '|     [(_ (f (id :: c) ...) b) |'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(_ (f (id :: c) ...) b) |'
- en: '|      (with-syntax ([(new-id ...) (generate-temporaries #''(id ...))]) |'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (with-syntax ([(new-id ...) (generate-temporaries #''(id ...))]) |'
- en: '|        #''(define f |'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        #''(define f |'
- en: '|            (lambda (new-id ...) |'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (lambda (new-id ...) |'
- en: '|              (let ([id (guard c new-id)] |'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (let ([id (guard c new-id)] |'
- en: '|                    ...) |'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    ...) |'
- en: '|                b))))])) |'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                b))))])) |'
- en: With conveniences like this, designers of contract languages can improve the
    readability, efficiency, and robustness of contract use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 借助诸如此类的便利，合同语言的设计者可以提高合同使用的可读性、效率和健壮性。
- en: 16.5Extending to Compound Data Structures
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展到复合数据结构
- en: As we have already discussed, it appears easy to extend contracts to structured
    datatypes such as lists, vectors, and user-defined recursive datatypes. This only
    requires that the appropriate set of run-time observations be available. This
    will usually be the case, up to the resolution of types in the language. For instance,
    as we have discussed [REF], a language with datatypes does not require type predicates
    but will still offer predicates to distinguish the variants; this is case where
    type-level “contract” checking is best (and perhaps must) be left to the static
    type system, while the contacts assert more refined structural properties.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，扩展合同到结构化数据类型，如列表、向量和用户定义的递归数据类型，似乎很容易。这只需要确保适当的运行时观察可用即可。这通常是可能的，直到语言中的类型解析。例如，正如我们已经讨论过的[REF]，一种带有数据类型的语言不需要类型谓词，但仍将提供谓词来区分变体；这是一种情况，其中类型级别的“合同”检查最好（甚至必须）留给静态类型系统，而合同则断言更精细的结构性质。
- en: However, this strategy can run into significant performance problems. For instance,
    suppose we built a balanced binary search-tree to perform asymptotic logarithmic
    time (in the size of the tree) insertions and lookups. Now say we have wrapped
    this tree in a suitable contract. Sadly, the mere act of checking the contract
    visits the entire tree, thereby taking linear time! Ideally, therefore, we would
    prefer a strategy whereby the contract was already checked—<wbr>incrementally—<wbr>at
    the time of construction, and does not need to be checked again at the time of
    lookup.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种策略可能会遇到重大的性能问题。例如，假设我们构建了一个平衡二叉搜索树，以执行对数时间（相对于树的大小）的插入和查找。现在假设我们已经将这棵树包装在了一个合适的合同中。遗憾的是，仅仅检查合同的行为会访问整棵树，从而花费线性时间！因此，理想情况下，我们更希望一种策略，即在构建时已经增量地检查合同，并且在查找时不需要再次检查。
- en: Worse, both balancing and search-tree ordering are recursive properties. In
    principle, therefore, they attach to every sub-tree, and so should be applied
    on every recursive call. During insertion, which is a recursive procedure, the
    contract would be checked on every visited sub-tree. In a tree of size \(t\),
    the contract predicate applies to a sub-tree of \(t \over 2\) elements, then to
    a sub-sub-tree of \(t \over 4\) elements, and so on, resulting—<wbr>in the worst
    case—<wbr>in visiting a total of \(t \over 2\) + \(t \over 4\) + \(\cdots\) +
    \(t \over t\) elements...making our intended logarithmic-time insertion process
    take linear time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，平衡和搜索树排序都是递归属性。原则上，它们附加到每个子树上，因此应该在每个递归调用上应用。在插入期间，这是一个递归过程，合同将在每个访问的子树上进行检查。在大小为\(t\)的树中，合同谓词适用于\(t
    \over 2\)个元素的子树，然后适用于\(t \over 4\)个元素的子子树，依此类推，导致在最坏情况下访问总共\(t \over 2\) + \(t
    \over 4\) + \(\cdots\) + \(t \over t\)个元素...使得我们旨在实现对数时间插入过程花费线性时间。
- en: In both cases, there is ready mitigation available in many cases. Each value
    needs to be associated (either intrinsically, or by storage in a hash table) with
    the set of contracts it has already passed. Then, when a contract is ready to
    apply, it first checks whether the value has already been checked and, if it has,
    does not check again. This is essentially a form of memoization of contract checking
    and can thus reduce the algorithmic complexity of checking. Again, like memoization,
    this works best when the values are immutable. If the values can mutate and the
    contracts perform arbitrary computations, it may not be sound to perform this
    optimization.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，很多情况下都有现成的缓解方法可供使用。每个值都需要与其已经通过的一系列合同相关联（可以是固有的，也可以通过存储在哈希表中）。然后，当一个合同准备应用时，它首先检查该值是否已经被检查过，如果已经检查过，则不再重复检查。这本质上是合同检查的一种记忆化形式，因此可以减少检查的算法复杂度。同样地，就像记忆化一样，当值是不可变的时候，这种方法效果最好。如果值可以变化，并且合同执行任意计算，则执行此优化可能不安全。
- en: There is a subtler way in which we might examine the issue of data structures.
    As an example, consider the contract we wrote earlier to check that all values
    in a numeric list are even. Suppose we have wrapped a list in this contract, but
    are interested only in the first element of the list. Naturally, we are paying
    the cost of checking all the values in the list, which may take a very long time.
    More importantly, however, a user might argue that reporting a violation about
    the second element of the list is itself a violation of our expectation about
    contract-checking, since we did not actually use that element.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以更微妙的方式来考虑数据结构的问题。例如，考虑我们之前编写的合同，用于检查数字列表中的所有值是否都是偶数。假设我们已经将列表包装在此合同中，但只对列表的第一个元素感兴趣。自然而然地，我们要付出检查列表中所有值的成本，这可能需要很长时间。然而，更重要的是，用户可能会认为报告列表第二个元素的违规行为本身就违反了我们对合同检查的期望，因为我们实际上并没有使用该元素。
- en: 'This suggests deferring checking even for some values that could be checked
    immediately. For instance, the entire list could be turned into a wrapped value
    containing a deferred check, and each value is checked only when it is visited.
    This strategy might be attractive, but it is not trivial to code, and especially
    runs into problems in the presence of aliasing: if two different identifiers are
    referring to the same list, one with a contract guard and the other without, we
    have to ensure both of them function as expected (which usually means we cannot
    store any mutable state in the list itself).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，甚至可以推迟对一些可以立即检查的值的检查。例如，整个列表可以转换为一个包含延迟检查的封装值，并且只有在访问时才检查每个值。这种策略可能很吸引人，但编码起来并不是微不足道的，并且尤其在存在别名时会遇到问题：如果两个不同的标识符引用相同的列表，一个带有合约保护，另一个没有，我们必须确保它们都按预期工作（这通常意味着我们不能在列表本身存储任何可变状态）。
- en: 16.6More on Contracts and Observations
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.6 更多关于合约和观察
- en: 'A general problem for any contract implementation—<wbr>which is exacerbated
    by complex data—<wbr>is a curious one. Earlier, we complained that it was difficult
    to check function contracts because we have insufficient power to observe: all
    we can check is that a value is a function, and no more. In real languages, the
    problem for data structures is actually the opposite: we have too much ability
    to observe. For instance, if we implement a strategy of deferring checking of
    a list, we quite possibly need to use a structure to hold the actual list, and
    modify first and rest to get their values through this structure (after checking
    contracts). However, a procedure like list? might now return false rather than
    true because structures are not lists; therefore, list? needs to be re-bound to
    a procedure that also returns true on structures that represent these special
    deferred-contract lists. But the contract system author needs to also remember
    to tackle cons?, pair?, and goodness knows how many other procedures that all
    perform observations.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何合约实现来说，一个普遍的问题——这在处理复杂数据时变得更加严重——是一个耐人寻味的问题。早些时候，我们抱怨检查函数合约很困难，因为我们缺乏足够的观察能力：我们只能检查一个值是否是一个函数，仅此而已。而在实际的语言中，对于数据结构的问题实际上恰恰相反：我们有太多的观察能力。例如，如果我们实现了一个推迟检查列表的策略，我们很可能需要使用一个结构来保存实际的列表，并修改first和rest以通过这个结构获取它们的值（在检查合约之后）。然而，像list?这样的过程现在可能返回false而不是true，因为结构不是列表；因此，list?需要重新绑定到一个过程，该过程在表示这些特殊的延迟合约列表的结构上也返回true。但合约系统的作者还需要记住解决cons?、pair?以及其他许多执行观察的过程。
- en: 'In general, one observation is essentially impossible to “fix”: eq?. Normally,
    we have the property that every value is eq? to itself, even for functions. However,
    the wrapped value of a function is a new procedure that not only isn’t eq? to
    itself but probably shouldn’t be, because its behavior truly is different (though
    only on contract violations, and only after enough values have been supplied to
    observe the violation). However, this means that a program cannot surreptitiously
    guard itself, because the act of guarding can be observed. As a result, a malicious
    module can sometimes detect whether it is being passed guarded values, behaving
    normally when it is and abnormally only when it is not!'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，一个观察基本上是不可能“修复”的：eq?。通常，我们具有每个值都与自己eq?的属性，即使对于函数也是如此。然而，函数的包装值是一个新的过程，它不仅不等于自身，而且可能不应该等于自身，因为其行为确实是不同的（尽管只在合约违规时，且只在足够的值被提供以观察到违规之后）。然而，这意味着程序不能偷偷地保护自己，因为保护的行为是可观察到的。因此，一个恶意的模块有时可以检测到是否传递了受保护的值，只有在没有传递时才表现异常！
- en: 16.7Contracts and Mutation
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.7 合约和变异
- en: We should rightly be concerned about the interaction between contracts and mutation,
    and even more so when we have contracts that are either inherently deferred or
    have been implemented in a deferred fashion. There are two things to be concerned
    about. One is storing a contracted value in mutable state. The other is writing
    a contract for mutable state.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该对合约和突变之间的相互作用感到担忧，尤其是当我们的合约要么本质上是推迟的，要么以推迟的方式实现时。有两件事需要担心。一是将受合约保护的值存储在可变状态中。另一个是为可变状态编写合约。
- en: When we store a contracted value, the strategy of wrapping ensures that contract
    checking works gracefully. At each stage, a contract checks as much as it can
    with the value at hand, and creates a wrapped value embodying the residual check.
    Thus, even if this wrapped value is stored in mutable state and retrieved for
    use later, it still contains these checks, and they will be performed when the
    value is eventually used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们存储一个被约定的值时，包装策略确保了合同检查的顺利进行。在每个阶段，合同会尽可能地检查手头上的值，并创建一个包含剩余检查的包装值。因此，即使这个包装值存储在可变状态中并在以后被检索以供使用，它仍然包含这些检查，并且当值最终被使用时，这些检查将被执行。
- en: 'The other issue is writing contracts for mutable data, such as boxes and vectors.
    In this case we probably have to create a wrapper for the entire datatype that
    records the intended contract. Then, when a value inside the datatype is replaced
    with a new one, the operation that performs the update—<wbr>such as set-box!—<wbr>needs
    to retrieve the intended contract from the wrapper, apply it to the value, and
    store the wrapped value. Therefore, this requires changing the behavior of the
    data structure mutation operators to be sensitive to contracted values. However,
    mutation does not change the point at which violations are caught: right away
    for immediate contracts, upon (in)appropriate use for deferred ones.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是为可变数据编写合同，例如框和向量。在这种情况下，我们可能必须为整个数据类型创建一个记录预期合同的包装器。然后，当数据类型内的一个值被替换为一个新值时，执行更新的操作—<wbr>例如set-box!—<wbr>需要从包装器中检索预期的合同，将其应用于值，并存储包装的值。因此，这需要改变数据结构变异操作符的行为，以使其对约定值敏感。然而，变异并不改变违规被捕获的时机：立即合同立即被捕获，延迟合同在适当（不适当）使用时被捕获。
- en: 16.8Combining Contracts
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.8 合并合同
- en: Now that we’ve discussed combinators for all the basic datatypes, it’s natural
    to discuss combining contracts. Just as we saw unions [REF] and intersections
    [REF] for types, we should be considering unions and intersections (respectively,
    “or”s and “and”s), ; for that matter, we might also consider negation. However,
    contracts are only superficially like types, so we have to consider these questions
    in their own light for contracts rather than try to map the meanings we have learned
    from types to the sphere of contracts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了所有基本数据类型的组合器，自然而然地，我们应该讨论如何组合合同。正如我们在类型中看到的联合[REF]和交集[REF]一样，我们应该考虑联合和交集（分别是“或”和“与”）；此外，我们还可以考虑否定。然而，合同只是表面上类似于类型，因此我们必须根据合同的实际情况考虑这些问题，而不是试图将我们从类型中学到的含义映射到合同的领域。
- en: As always, the immediate case is straightforward. Union contracts combine with
    disjunction—<wbr>indeed, being predicates, their results can literally be combined
    with or—<wbr>and intersection contracts with conjunction. We apply the predicates
    in turn, with short-circuiting, and either generate an error or return the contracted
    value. Intersection contracts combine with conjunction (and). And negation contracts
    are simply the original immediate contract applied and the decision negated (with
    not).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，立即情况是很简单的。联合合同与析取组合—<wbr>实际上，作为谓词，它们的结果可以直接与或组合—<wbr>和交集合同与合取组合。我们依次应用谓词，进行短路，然后生成错误或返回约定值。交集合同与合取（与）。否定合同只是将原始的立即合同应用并将决定否定（用not）。
- en: 'Contract combination is much harder in the deferred, higher-order case. For
    instance, consider the negation of a function contract from numbers to numbers.
    What exactly does it mean to negate it? Does it mean the function should not accept
    numbers? Or that if it does, it should not produce them? Or both? And in particular,
    how do we enforce such a contract? How, for instance, do we check that a function
    does not accept numbers—<wbr>are we expecting that when given a number, it produces
    an error? But now consider the identity function wrapped with such a contract;
    since it clearly does not result in an error when given a number (or indeed any
    other value), does that mean we should wait until it produces a value, and if
    it does produce a number, reject it? But worst of all, note that this means we
    will be running functions on domains on which they are not defined: a sure recipe
    for destroying program invariants, polluting the heap, or crashing the program.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在延迟、高阶情况下，合并合同要困难得多。例如，考虑将函数合同从数字到数字的否定。究竟什么意思？它是否意味着函数不应该接受数字？还是说如果接受了数字，就不应该产生它们？还是两者兼而有之？特别是，我们如何执行这样的合同？例如，我们如何检查一个函数不接受数字——我们期望当给定一个数字时，它会产生一个错误吗？但现在考虑一下用这样一个合同包裹的恒等函数；因为显然当给定一个数字（或者任何其他值）时它不会产生错误，这是否意味着我们应该等到它产生一个值，如果它确实产生一个数字，我们就拒绝它？但最糟糕的是，请注意，这意味着我们将在其未定义的域上运行函数：这是摧毁程序不变量、污染堆或使程序崩溃的一种确定方法。
- en: Intersection contracts require values to pass all the sub-contracts. This means
    re-wrapping the higher-order value in something that checks all the domain sub-contracts
    as well as all the range sub-contracts. Failing to meet even one sub-contract
    means the value has failed the entire intersction.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 交集合同要求值通过所有的子合同。这意味着将高阶值重新包装成一些检查所有域子合同以及所有范围子合同的东西。未能满足一个子合同甚至意味着该值已经失败了整个交集。
- en: Union contracts are more subtle, because failing to meet any one sub-contract
    is not grounds for rejection. Rather, it simply means that that one sub-contract
    is no longer a candidate contract representing the wrapped value; the other sub-contracts
    might still be candidates, and only when no others are left must be reject the
    value. This means the implementation of union contracts must maintain memory of
    which sub-contracts have and have not yet passed—<wbr>memory, in this case, being
    a sophisticated term for the use of mutation.In a multi-threaded language like
    Racket, this also requires locks to avoid race conditions. As each sub-contract
    fails, it is removed from the list of candidates, while all the remaining ones
    continue to applied. When no candidates remain, the contract system must report
    a violation. The error report would presumably provide the actual values that
    eliminated each part of each sub-contract (keeping in mind that these may be nested
    multiple functions deep).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 联合合同更加微妙，因为不满足任何一个子合同并不意味着可以拒绝。相反，它只意味着那个子合同不再是代表包装值的候选合同；其他子合同可能仍然是候选合同，并且只有当没有其他合同时才必须拒绝该值。这意味着联合合同的实现必须保持哪些子合同已经通过和尚未通过的记忆——在这种情况下，记忆是使用突变的一种复杂术语。在像
    Racket 这样的多线程语言中，这还需要锁定以避免竞争条件。当每个子合同失败时，它都会从候选列表中移除，而所有剩余的子合同仍然继续应用。当没有候选合同时，合同系统必须报告一个违规。错误报告可能会提供消除每个子合同的每个部分的实际值（请记住，这些值可能会嵌套多个函数深）。
- en: The implemented versions of contract constructors and combinators in Racket
    place restrictions on the acceptable forms of sub-contracts. These enable implementations
    that are both efficient and yield useful error messages. Furthermore, the more
    extreme situations discussed above rarely occur in practice—<wbr>though now you
    know how to implement them if you need to.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中的合同构造器和组合器的实现版本对可接受的子合同形式施加了限制。这些限制使得实现既高效又能产生有用的错误消息。此外，上述更极端的情况在实践中很少发生——虽然现在你知道如果需要的话如何实现它们。
- en: 16.9Blame
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.9责备
- en: Let’s now return to the issue of reporting contract violations. By this I don’t
    mean what string to print, but the much more important question of what to report,
    which as we are about to see is really a semantic consideration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到报告合同违规的问题上。我指的不是要打印什么字符串，而是更重要的问题，即要报告什么，正如我们即将看到的那样，这实际上是一个语义上的考虑。
- en: 'To illustrate the problem recall our definition of d/dx above, and assume we
    were running it without any contract checking. Suppose now that we apply this
    function to the entirely inappropriate string-append (which neither consumes nor
    produces numbers). This simply produces a value:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '| > (define d/dx-sa (d/dx string-append)) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '(Observe that this would succeed even if contract checking were on, because
    the immediate portion of the function contract recognizes string-append to be
    a function.) Now suppose we apply d/dx-sa to a number, as we ought to be able
    to do:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '| > (d/dx-sa 10) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| string-append: contract violation |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '|   expected: string? |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '|   given: 10.001 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: 'Notice that the error report is deep inside the body of d/dx. On the one hand,
    this is entirely legitimate: that is where the improper application of string-append
    occurred. However, the fault is not that of d/dx at all—<wbr>rather, it is the
    fault of whatever body of code supplied string-append as a purportedly legitimate
    function from numbers to numbers. Except, however, the code that did so has long
    since fled the scene; it is no longer on the stack, and is hence outside the ambit
    of traditional error-reporting mechanisms.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is not a peculiarity of d/dx; in fact, it routinely occurs in
    large systems. This is because systems, especially with graphical, network, and
    other external interfaces, make heavy use of callbacks: functions (or methods)
    that register interest in some entity and are invoked to signal some status or
    value. (Here, d/dx is the moral equivalent of the graphics layer, and string-append
    is the callback that has been supplied to (and stored by) it.) Eventually, the
    system layer invokes the callback. If this results in an error, it is the fault
    of neither the system layer—<wbr>which was given a callback of purportedly the
    right contract—<wbr>nor of the callback itself, which presumably has legitimate
    uses but was improperly supplied to the function. Rather, the fault is of the
    entity that introduced these two entities. However, at this point the call stack
    contains only the callback (on top) and the system (below it)—<wbr>and the only
    guilty party is no longer present. These kinds of errors can therefore be extremely
    difficult to debug.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to extend the contract system to incorporate a notion of blame.
    The idea is to effectively record the introduction that resulted in a pair of
    components coming together, so that if a contract violation occurs between them,
    we can ascribe the failure to the expression that did the introduction. Observe
    that this is only really interesting in the context of functions, but for consistency
    we will extend blame to immediate contracts as well in a natural way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'For a function, notice that there are two possible points of failure: either
    it was given the wrong kind of value (the pre-condition), or it produced the wrong
    kind of value (the post-condition). It is important to distinguish these two cases
    because in the former case we should blame the environment—<wbr>in particular,
    the actual parameter expression—<wbr>whereas in the latter case (assuming the
    parameter has passed muster) we should blame the function itself. (The natural
    extension to immediate values is that we can only blame the value itself for not
    satisfying the contract, which is akin to the “post-condition”.)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数而言，注意到有两种可能的失败点：要么它被给了错误类型的值（前置条件），要么它产生了错误类型的值（后置条件）。区分这两种情况很重要，因为在前一种情况下，我们应该责备环境——<wbr>特别是，实际参数表达式——<wbr>而在后一种情况下（假设参数已经通过了审查），我们应该责备函数本身。（对于即时值的自然扩展是，我们只能责备值本身不满足合同，这类似于“后置条件”。）
- en: For contracts, we will introduce the terms positive and negative position. For
    a first-order function, the negative position is the pre-condition and the positive
    one the post-condition. Therefore, this might appear to be needless extra terminology.
    As we will soon see, however, these terms have a more general meaning.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于合同，我们将引入术语正位置和负位置。对于一阶函数，负位置是前置条件，正位置是后置条件。因此，这可能看起来是多余的额外术语。然而，正如我们很快将看到的，这些术语具有更一般的含义。
- en: 'We will now generalize the parameters consumed by contracts. Previously, immediate
    contracts consumed a predicate and function contracts consumed domain and range
    contracts. This will still be the case. However, what they each return will be
    a function of two arguments: labels for the positive and negative positions. (These
    labels can be drawn from any reasonable datatype: abstract syntax nodes, buffer
    offsets, or other descriptions. For simplicity, we will use strings.) Thus function
    contracts will close over the labels of these program positions, to later blame
    the provider of an invalid function.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将一般化合同消耗的参数。之前，即时合同消耗谓词，函数合同消耗域和范围合同。这仍然是这样。然而，它们各自返回的内容将是两个参数的函数：正位置和负位置的标签。（这些标签可以来自任何合理的数据类型：抽象语法节点、缓冲区偏移或其他描述。为简单起见，我们将使用字符串。）因此，函数合同将封闭于这些程序位置的标签，以后指责无效函数的提供者。
- en: 'The guard function is now responsible for passing through the labels of the
    contract application locations:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保护函数负责通过合同应用位置的标签：
- en: '| (define (guard ctc val pos neg) ((ctc pos neg) val)) |'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (guard ctc val pos neg) ((ctc pos neg) val)) |'
- en: 'and let us also have blame display the appropriate label (which we will pass
    to it from the contract implementations):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还让责备显示适当的标签（我们将从合同实现中传递给它）：
- en: '| (define (blame s) (error ''contract s)) |'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (blame s) (error ''contract s)) |'
- en: 'Suppose we are guarding the use of add1, as before. What are useful names for
    the positive and negative positions? The positive position is post-condition:
    i.e., any failure here must be blamed on the body of add1. The negative position
    is the pre-condition: i.e., any failure here must be blamed on the parameter to
    add1. Thus:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们像以前一样保护add1的使用。对于正位置和负位置来说，有哪些有用的名称呢？正位置是后置条件：即，在这里的任何失败都必须归咎于add1的主体。负位置是前置条件：即，在这里的任何失败都必须归咎于add1的参数。因此：
- en: '| (define a1 (guard (function (immediate number?) |'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define a1 (guard (function （即时数？） |'
- en: '|                             (immediate number?)) |'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                             （即时数？） |'
- en: '|                   add1 |'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   add1 |'
- en: '|                   "add1 body" |'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   "add1 body" |'
- en: '|                   "add1 input")) |'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   "add1 input")) |'
- en: 'Had we provided a non-function to guard, we would expect an error at the “post-condition”
    location: this is not really a failure of the post-condition, but surely the parameter
    cannot be blamed if the application failed to be a function. (However, this shows
    that we are really stretching the term “post-condition”, and the terms “positive”
    provides a useful alternative.) Because we trust the implementation of add1 to
    only produce numbers, we would expect it is impossible to fail the post-condition.
    However, we would expect an expression like (a1 "x") to trigger a pre-condition
    error, presumably signaling a contract error at the location "add1 input". In
    contrast, had we guarded a function that violates the post-condition, such as
    this,'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '| (define bad-a1 (guard (function (immediate number?) |'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                 (immediate number?)) |'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       number->string |'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       "bad-add1 body" |'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       "bad-add1 input")) |'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'we would expect blame to be ascribed to "bad-add1 body".Let us now see how
    to implement these contract constructors. For immediate contracts, we have seen
    that blame should be ascribed to the positive position:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (immediate pred?) |'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (lambda (pos neg) |'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (lambda (val) |'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (if (pred? val) val (blame pos))))) |'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: For functions, we might be tempted to write
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (function dom rng) |'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (lambda (pos neg) |'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (lambda (val) |'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (if (procedure? val) |'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|           (lambda (x) (dom (val (rng x)))) |'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|           (blame pos))))) |'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'but this fails to work in a very fundamental way: it violates the expected
    signature on contracts. That is because all contracts now expect to be given the
    labels of positive and negative positions, which means dom and rng cannot be used
    as above. (As another hint, we are using pos but not neg anywhere in the body,
    even though we have seen examples where we expect the position bound to neg to
    be blamed.) Instead, clearly, we somehow instantiate the domain and range contracts
    using pos and neg, so that they “know” and “remember” where a potentially violating
    function was applied.The most obvious reaction would be to instantiate these contract
    constructors with the same values of dom and rng:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (function dom rng) |'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (lambda (pos neg) |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (let ([dom-c (dom pos neg)] |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|           [rng-c (rng pos neg)]) |'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (lambda (val) |'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|         (if (procedure? val) |'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (lambda (x) (rng-c (val (dom-c x)))) |'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (blame pos)))))) |'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Now all the signatures match up, and we can run our contracts. But when we do
    so, the answers are a little strange. For instance, on our simplest contract violation
    example, we get
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '| > (a1 "x") |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| contract: add1 body |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: Huh? Maybe we should expand out the code of a1 to see what happened.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '|   (a1 "x") |'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| = (guard (function (immediate number?) |'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                    (immediate number?)) |'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          add1 |'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          "add1 body" |'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          "add1 input") |'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| = (((function (immediate number?) (immediate number?)) |'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| = (((function (immediate number?) (immediate number?)) |'
- en: '|     "add1 body" "add1 input") |'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     "add1 body" "add1 input") |'
- en: '|    add1) |'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    add1) |'
- en: '| = (let ([dom-c ((immediate number?) "add1 body" "add1 input")] |'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| = (let ([dom-c ((immediate number?) "add1 body" "add1 input")] |'
- en: '|         [rng-c ((immediate number?) "add1 body" "add1 input")]) |'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         [rng-c ((immediate number?) "add1 body" "add1 input")]) |'
- en: '|     (lambda (x) (rng-c (add1 (dom-c x))))) |'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (lambda (x) (rng-c (add1 (dom-c x))))) |'
- en: '| = (let ([dom-c (lambda (val) |'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| = (let ([dom-c (lambda (val) |'
- en: '|                  (if (number? val) val (blame "add1 body")))] |'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (if (number? val) val (blame "add1 body")))] |'
- en: '|         [rng-c (lambda (val) |'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         [rng-c (lambda (val) |'
- en: '|                  (if (number? val) val (blame "add1 body")))]) |'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (if (number? val) val (blame "add1 body")))]) |'
- en: '|     (lambda (x) (rng-c (add1 (dom-c x))))) |'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (lambda (x) (rng-c (add1 (dom-c x))))) |'
- en: 'Poor add1: it never stood a chance! The only blame label left is "add1 body",
    so it was the only thing that could ever be blamed.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 可怜的 add1：它从未有过机会！唯一剩下的责备标签是“add1 body”，所以它是唯一可能被责备的东西。
- en: We will return to this problem in a moment, but observe how in the above code,
    there are no real traces of the function contract left. All we have are immediate
    contracts, ready to blame actual values if and when they occur. This is perfectly
    consistent with what we said earlier [REF] about being able to observe only immediate
    values. Of course, this is only true for first-order functions; when we get to
    higher-order functions, this will no longer be true.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一会儿回到这个问题，但是请注意，在上述代码中，几乎没有真正的函数合同的痕迹留下。我们所拥有的只是即时合同，一旦发生就会责备实际值。这与我们之前关于只能观察到即时值的说法是完全一致的
    [REF]。当然，这仅适用于一阶函数；当我们涉及到高阶函数时，情况将不再如此。
- en: What went wrong? Notice that only the contract bound to rng-c ought to be blaming
    the body of add1. In contrast, the contract bound to dom-c ought to be blaming
    the input to add1. It’s almost as if, in the domain position of a function contract,
    the positive and negative labels should be...swapped.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 出了什么问题？请注意，只有绑定到 rng-c 的合同应该责怪 add1 的主体。相比之下，绑定到 dom-c 的合同应该责怪 add1 的输入。这就好像在函数合同的域位置中，正负标签应该被...交换了一样。
- en: If we consider the contract-guarded d/dx, we see that this is indeed the case.
    The key insight is that, when applying a function taken as a parameter, the “outside”
    becomes the “inside” and vice versa. That is, the body of d/dx—<wbr>which was
    in positive position—<wbr>is now the caller of the function to differentiate,
    putting that function’s body in positive position and the caller—<wbr>the body
    of d/dx—<wbr>in negative position. Thus, on the domain side of the contract, every
    nested function contract causes positive and negative positions to swap.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到受合同保护的 d/dx，我们确实可以看到这一点。关键的洞察力在于，当应用作为参数传递的函数时，“外部”变为“内部”，反之亦然。也就是说，d/dx
    的主体——<wbr>原本处于正位置——<wbr>现在成为要区分的函数的调用者，将该函数的主体放在正位置，而调用者——<wbr>d/dx 的主体——<wbr>处于负位置。因此，在合同的域方面，每个嵌套的函数合同都会导致正位置和负位置交换。
- en: On the range side, there is no need to swap. Consider again d/dx. The function
    it returns represents the derivative, so it should be given a number (representing
    the point at which to calculate the derivative) and it should return a number
    (the derivative at that point). The negative position of this function is indeed
    the client who uses the derivative function—<wbr>the pre-condition—<wbr>and the
    positive position is indeed the body of d/dx itself—<wbr>the post-condition—<wbr>since
    it is responsible for generating the derivative.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围一侧，没有必要交换。再次考虑一下 d/dx。它返回的函数表示导数，因此应该给它一个数字（表示计算导数的点），并且应该返回一个数字（该点的导数）。这个函数的负位置确实是使用导数函数的客户端——<wbr>前置条件——<wbr>而正位置确实是
    d/dx 本身的主体——<wbr>后置条件——<wbr>因为它负责生成导数。
- en: 'As a result, we obtain an updated, and correct, definition for the function
    constructor:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到了一个更新的，而且正确的函数构造器的定义：
- en: '| (define (function dom rng) |'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (function dom rng) |'
- en: '|   (lambda (pos neg) |'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (pos neg) |'
- en: '|     (let ([dom-c (dom neg pos)] |'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (let ([dom-c (dom neg pos)] |'
- en: '|           [rng-c (rng pos neg)]) |'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           [rng-c (rng pos neg)]) |'
- en: '|       (lambda (val) |'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (lambda (val) |'
- en: '|         (if (procedure? val) |'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (if (procedure? val) |'
- en: '|             (lambda (x) (rng-c (val (dom-c x)))) |'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             (lambda (x) (rng-c (val (dom-c x)))) |'
- en: '|             (blame pos)))))) |'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             (blame pos)))))) |'
- en: Exercise
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Apply this to our earlier example and confirm that we get the expected blame.
    Also expand the code manually to see why this happens.
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将此应用到我们之前的示例中，并确认我们得到了预期的责任。手动展开代码也可以看出为什么会发生这种情况。
- en: 'Suppose, further, we define d/dx with the labels "d/dx body" for its positive
    position and "d/dx input" for its negative. Say we supply the function number->string,
    which patently does not compute derivatives, and apply the result to 10:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步假设，我们用标签"d/dx body"表示它的正位置，用"d/dx input"表示它的负位置来定义d/dx。假设我们提供了显然不计算导数的函数number->string，并将结果应用于10：
- en: '| ((d/dx (guard (function (immediate number?) |'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((d/dx (guard (function (immediate number?) |'
- en: '|                         (immediate string?)) |'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (immediate string?)) |'
- en: '|               number->string |'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               number->string |'
- en: '|               "n->s body" |'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               "n->s body" |'
- en: '|               "n->s input")) |'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               "n->s input")) |'
- en: '|  10) |'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  10) |'
- en: This correctly indicates that the blame should be ascribed to the expression
    that fed number->string as a supposed numeric function to d/dx—<wbr>not to d/dx
    itself.Exercise
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这正确地表明责任应归因于将number->string作为一个假定为数值函数输入给d/dx的表达式—<wbr>而不是d/dx本身。练习
- en: Hand-evaluate d/dx, apply it to all the relevant violation examples, and confirm
    that the resulting blame is accurate. What happens if you supply d/dx with string->number
    with a function contract indicating it maps strings to numbers? What if you supply
    the same function with no contract at all?
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 手动评估d/dx，将其应用于所有相关的违例示例，并确认结果的责任是准确的。如果您向带有函数契约指示它将字符串映射到数字的字符串->数字提供d/dx会发生什么？如果您向相同的函数提供没有任何契约的情况会怎样？
