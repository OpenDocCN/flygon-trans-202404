["```\ndata Value:\n  | numV(n :: Number)\n  | closV(f :: ExprC, e :: List<Binding>)\n  | objV(ns :: List<String>, vs :: List<Value>)\nend\n```", "```\n| objC(ns :: List<String>, vs :: List<ExprC>)\n```", "```\n| objC(ns, vs) =>\n  obj-vs = eval-obj-vs(vs, nv, st)\n  ret(objV(ns, obj-vs.exprs), obj-vs.final-store)\n```", "```\n| msgC(o, n) =>\n  o-val = interp(o, nv, st)\n  msg = lookup-msg(n, o-val.v)\n  ret(msg, o-val.st)\n```", "```\ncheck: o-1(\"add1\")(5) is 6 end\n```", "```\nfun msg(o, m, a): o(m)(a) end\n```", "```\ncheck: msg(o-1, \"add1\", 5) is 6 end\n```", "```\ncheck: msg(o-1, \"add\" + \"1\", 5) is 6 end\n```", "```\no-1-1 = mk-object(\n  [list:\n    mtd(\"add1\", lam(x): x + 1 end),\n    mtd(\"sub1\", lam(x): x - 1 end) ] )\n```", "```\ndata Mtd:\n  | mtd(name :: String, value)\nend\n```", "```\nfun mk-object(n-vs):\n  lam(m):\n    fun lookup(locals):\n      cases (List) locals:\n        | empty => raise(\"message not found: \" + m)\n        | link(f, r) =>\n          if f.name == m: f.value else: lookup(r) end\n      end\n    end\n    lookup(n-vs)\n  end\nend\n```", "```\no-constr-1 =\n  lam(x):\n    mk-object( [list: mtd(\"addX\", lam(y): x + y end) ])\n  end\n\ncheck:\n  msg(o-constr-1(5), \"addX\", 3) is 8\n  msg(o-constr-1(2), \"addX\", 3) is 5\nend\n```", "```\no-state-1 =\n  lam(count):\n    var mut-count = count\n    mk-object(\n      [list:\n        mtd(\"inc\", lam(n): mut-count := mut-count + n end),\n        mtd(\"dec\", lam(n): mut-count := mut-count - n end),\n        mtd(\"get\", lam(_): mut-count end) ] )\n  end\n```", "```\ncheck:\n  o = o-state-1(5)\n  msg(o, \"inc\", 1)\n  msg(o, \"dec\", 1)\n  msg(o, \"get\", \"dummy\") is 5\nend\n```", "```\ncheck:\n  o1 = o-state-1(5)\n  o2 = o-state-1(5)\n  msg(o1, \"inc\", 1)\n  msg(o1, \"inc\", 1)\n  msg(o1, \"get\", \"dummy\") is 7\n  msg(o2, \"get\", \"dummy\") is 5\nend\n```", "```\nmk-bank-account =\n  block:\n    var counter = 0\n    lam(amount):\n      var balance = amount\n      counter := counter + 1\n      mk-object(\n        [list:\n          mtd(\"deposit\", lam(m): balance := balance + m end),\n          mtd(\"withdraw\", lam(m): balance := balance - m end),\n          mtd(\"balance\", lam(_): balance end),\n          mtd(\"how-many-accounts\", lam(_): counter end) ])\n    end\n  end\n```", "```\ncheck:\n  acc-1 = mk-bank-account(0)\n  msg(acc-1, \"how-many-accounts\", \"dummy\") is 1\n  acc-2 = mk-bank-account(100)\n  msg(acc-1, \"how-many-accounts\", \"dummy\") is 2\n  msg(acc-2, \"how-many-accounts\", \"dummy\") is 2\n  msg(acc-1, \"deposit\", 100)\n  msg(acc-1, \"withdraw\", 50)\n  msg(acc-2, \"deposit\", 10)\n  msg(acc-1, \"balance\", \"dummy\") is 50\n  msg(acc-2, \"balance\", \"dummy\") is 110\n  msg(acc-1, \"how-many-accounts\", \"dummy\") is 2\n  msg(acc-2, \"how-many-accounts\", \"dummy\") is 2\nend\n```", "```\no-self =\n  block:\n    var self = \"dummy\"\n    self :=\n      mk-object(\n          [list:\n            mtd(\"first\",\n              lam(v): msg(self, \"second\", v + 1) end),\n            mtd(\"second\",\n              lam(v): v + 1 end )])\n    self\n  end\n```", "```\ncheck: msg(o-self, \"first\", 5) is 7 end\n```", "```\no-self-no-state =\n  mk-object(\n    [list:\n      mtd(\"first\",\n        lam(self, v): smsg(self, \"second\", v + 1) end),\n      mtd(\"second\",\n        lam(self, v): v + 1 end )])\n```", "```\nfun smsg(o, m, a): o(m)(o, a) end\n```", "```\ncheck: smsg(o-self, \"first\", 5) is 7 end\n```", "```\nmt =\n  lam():\n    mk-object(\n      [list:\n        mtd(\"add\",\n          lam(self, _): 0 end) ])\n  end\n\nnode =\n  lam(v, l, r):\n    mk-object(\n      [list:\n        mtd(\"add\",\n          lam(self, _):\n            v\n              + smsg(l, \"add\", \"dummy\")\n              + smsg(r, \"add\", \"dummy\") end) ] )\n  end\n```", "```\na-tree =\n  node(10,\n    node(5, mt(), mt()),\n    node(15, node(6, mt(), mt()), mt()))\n```", "```\ncheck: smsg(a-tree, \"add\", \"dummy\") is (10 + 5 + 15 + 6) end\n```", "```\n| empty => raise(\"message not found: \" + m)\n```", "```\n| empty => parent-object(m)\n```", "```\nnode-size-ext =\n  fun(parent-object, v, l, r):\n    ...\n```", "```\nnode-size-ext =\n  lam(parent-maker, v, l, r):\n    parent-object = parent-maker(v, l, r)\n    mk-ext-object(parent-object,\n      [list:\n        mtd(\"size\",\n          lam(self, _):\n            1\n              + smsg(l, \"size\", \"dummy\")\n              + smsg(r, \"size\", \"dummy\") end) ] )\n  end\n```", "```\nfun node-size(v, l, r): node-size-ext(node, v, l, r) end\n```", "```\nfun mk-ext-object(parent, n-vs):\n  lam(m):\n    fun lookup(locals):\n      cases (List) locals:\n        | empty => parent(m)\n        | link(f, r) =>\n          if f.name == m: f.value else: lookup(r) end\n      end\n    end\n    lookup(n-vs)\n  end\nend\n```", "```\nmt-size-ext =\n  lam(parent-maker):\n    parent-object = parent-maker()\n    mk-ext-object(parent-object,\n      [list:\n        mtd(\"size\",\n          lam(self, _): 0 end) ])\n  end\n\nfun mt-size(): mt-size-ext(mt) end\n```", "```\na-tree-size =\n  node-size(10,\n    node-size(5, mt-size(), mt-size()),\n    node-size(15, node-size(6, mt-size(), mt-size()), mt-size()))\n```", "```\ncheck:\n  smsg(a-tree-size, \"add\", \"dummy\") is (10 + 5 + 15 + 6)\n  smsg(a-tree-size, \"size\", \"dummy\") is 4\nend\n```", "```\n> > fun empty-object(m):\n> >   raise(\"message not found: \" + m)\n> > end\n> > ```", "```\nclass NodeSize extends Node { ... }\n```", "```\ntype Add1Sub1 =\n  { add1 :: (Number -> Number),\n    sub1 :: (Number -> Number) }\n```", "```\ntype Arith =\n  { add1  :: (Number -> Number),\n    sub1  :: (Number -> Number),\n    plus  :: (Number, Number -> Number),\n    mult  :: (Number, Number -> Number) }\n```", "```\nfun f(a :: Arith) -> Number:\n  a.plus(2, 3)\nend\n```", "```\n{ add1  : (Number -> Number),            { add1 : (Number -> Number),\n  sub1  : (Number -> Number),          <:  sub1 : (Number -> Number) }\n  plus  : (Number, Number -> Number),\n  mult  : (Number, Number -> Number) }\n```", "```\nfun b2n(b :: Boolean01) -> Number:\n  if b == 0:  # alias for false\n    1\n  else if b == 1:  # alias for true\n    0\n  else:\n    raise('not valid number as Boolean01')\n  end\nend\n\nfun n2b(n :: Number) -> Boolean01:\n  if n == 0:\n    false  # alias for 0\n  else if n == 1:\n    true   # alias for 1\n  else:\n    raise('no valid Boolean01 for number')\n  end\nend\n\nfun n2n(n :: Number) -> Number:\n  n + 1\nend\n\nfun b2b(b :: Boolean01) -> Boolean01:\n  if b == 0:  # alias for false\n    true   # alias for 1\n  else if b == 1: # alias for true\n    false  # alias 0\n  else:\n    raise('not valid number as Boolean01')\n  end\nend\n```", "```\ntype N2N = (Number -> Number)\ntype B2B = (Boolean01 -> Boolean01)\ntype N2B = (Number -> Boolean01)\ntype B2N = (Boolean01 -> Number)\n```", "```\nfun p(op :: (A -> B)) -> B:\n  op(a-value)\nend\n```", "```\no :: Add1Sub1 = ...\n```", "```\ncrypto =\n  { private-key: ... ,\n    public-key: ...,\n    decrypt: fun(msg): ... end,\n    encrypt: fun(plain-text): ... end }\n```", "```\ntype PK =\n  { public-key: Number,\n    encrypt: (String -> String) }\n```", "```\nfor-dist :: PK = crypto\n```", "```\nfun proxy-for-crypto(c):\n  { public-key: c.public-key,\n    encrypt: c.encrypt }\nend\n\nproxy-dist = proxy-for-crypto(for-dist)\n```", "```\ntype Add1Sub1 =\n  \u03bc T . { add1 :: (T, Number -> Number),\n          sub1 :: (T, Number -> Number) }\n```"]