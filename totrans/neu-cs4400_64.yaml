- en: Implementing Objects with StateTuesday, February 28th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how several pieces of information can be encapsulate in
    a Racket closure that keeps them all; now we can do a little more — we can actually
    have mutable state, which leads to a natural way to implement objects. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'implements a constructor for `point` objects which keep two values and can
    move one of them. Note that the messages act as a form of methods, and that the
    values themselves are hidden and are accessible only through the interface that
    these messages make. For example, if these points correspond to some graphic object
    on the screen, we can easily incorporate a necessary screen update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and be sure that this is always done when the value changes — since there is
    no way to change the value except through this interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complete example would define functions that actually send these messages
    — here is a better implementation of a point object and the corresponding accessors
    and mutators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And a quick imitation of inheritance can be achieved using delegation to an
    instance of the super-class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how all of these could come from some preprocessing of a more normal-looking
    class definition form, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
