- en: Chapter 3\. Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding chapter prepared you to write Scheme programs using a small set
    of the most useful primitive syntactic forms and procedures. This chapter introduces
    a number of additional features and programming techniques that will allow you
    to write more sophisticated and efficient programs.
  prefs: []
  type: TYPE_NORMAL
- en: Section 3.1\. Syntactic Extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in Section [2.5](start.html#g21), the `let` syntactic form is merely
    a *syntactic extension* defined in terms of a `lambda` expression and a procedure
    application, both core syntactic forms. At this point, you might be wondering
    which syntactic forms are core forms and which are syntactic extensions, and how
    new syntactic extensions may be defined. This section provides some answers to
    these questions.
  prefs: []
  type: TYPE_NORMAL
- en: In truth, it is not necessary for us to draw a distinction between core forms
    and syntactic extensions, since once defined, a syntactic extension has exactly
    the same status as a core form. Drawing a distinction, however, makes understanding
    the language easier, since it allows us to focus attention on the core forms and
    to understand all others in terms of them.
  prefs: []
  type: TYPE_NORMAL
- en: It *is* necessary for a Scheme implementation to distinguish between core forms
    and syntactic extensions. A Scheme implementation expands syntactic extensions
    into core forms as the first step of compilation or interpretation, allowing the
    rest of the compiler or interpreter to focus only on the core forms. The set of
    core forms remaining after expansion to be handled directly by the compiler or
    interpreter is implementation-dependent, however, and may be different from the
    set of forms described as core here.
  prefs: []
  type: TYPE_NORMAL
- en: The exact set of syntactic forms making up the core of the language is thus
    subject to debate, although it must be possible to derive all other forms from
    any set of forms declared to be core forms. The set described here is among the
    simplest for which this constraint is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: The core syntactic forms include top-level `define` forms, constants, variables,
    procedure applications, `quote` expressions, `lambda` expressions, `if` expressions,
    and `set!` expressions. The grammar below describes the core syntax of Scheme
    in terms of these definitions and expressions. In the grammar, vertical bars ( | )
    separate alternatives, and a form followed by an asterisk ( * ) represents zero
    or more occurrences of the form. <variable> is any Scheme identifier. <datum>
    is any Scheme object, such as a number, list, symbol, or vector. <boolean> is
    either `#t` or `#f`, <number> is any number, <character> is any character, and
    <string> is any string. We have already seen examples of numbers, strings, lists,
    symbols, and booleans. See Chapter [6](objects.html#g106) or the formal syntax
    description starting on page [455](grammar.html#APPENDIXFORMALSYNTAX) for more
    on the object-level syntax of these and other objects.
  prefs: []
  type: TYPE_NORMAL
- en: '| <program> | ![<graphic>](ch3_8.gif) | <form>* |'
  prefs: []
  type: TYPE_TB
- en: '| <form> | ![<graphic>](ch3_8.gif) | <definition> &#124; <expression> |'
  prefs: []
  type: TYPE_TB
- en: '| <definition> | ![<graphic>](ch3_8.gif) | <variable definition> &#124; `(begin`
    <definition>*`)` |'
  prefs: []
  type: TYPE_TB
- en: '| <variable definition> | ![<graphic>](ch3_8.gif) | `(define` <variable> <expression>`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| <expression> | ![<graphic>](ch3_8.gif) | <constant> |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124; | <variable> |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124; | `(quote` <datum>`)` |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124; | `(lambda` <formals> <expression> <expression>*`)` |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124; | `(if` <expression> <expression> <expression>`)` |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124; | `(set!` <variable> <expression>`)` |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124; | <application> |'
  prefs: []
  type: TYPE_TB
- en: '| <constant> | ![<graphic>](ch3_8.gif) | <boolean> &#124; <number> &#124; <character>
    &#124; <string> |'
  prefs: []
  type: TYPE_TB
- en: '| <formals> | ![<graphic>](ch3_8.gif) | <variable> |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124; | `(`<variable>*`)` |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124; | `(`<variable> <variable>* `.` <variable>`)` |'
  prefs: []
  type: TYPE_TB
- en: '| <application> | ![<graphic>](ch3_8.gif) | `(`<expression> <expression>*`)`
    |'
  prefs: []
  type: TYPE_TB
- en: The grammar is ambiguous in that the syntax for procedure applications conflicts
    with the syntaxes for `quote`, `lambda`, `if`, and `set!` expressions. In order
    to qualify as a procedure application, the first <expression> must not be one
    of these keywords, unless the keyword has been redefined or locally bound.
  prefs: []
  type: TYPE_NORMAL
- en: The "defun" syntax for `define` given in Section [2.6](start.html#g25) is not
    included in the core, since definitions in that form are straightforwardly translated
    into the simpler `define` syntax. Similarly, the core syntax for `if` does not
    permit the `*alternative*` to be omitted, as did one example in Section [2.9](start.html#g40).
    An `if` expression lacking an `*alternative*` can be translated into the core
    syntax for `if` merely by replacing the missing subexpression with an arbitrary
    constant, such as `#f`.
  prefs: []
  type: TYPE_NORMAL
- en: A `begin` that contains only definitions is considered to be a definition in
    the grammar; this is permitted in order to allow syntactic extensions to expand
    into more than one definition. `begin` expressions, i.e., `begin` forms containing
    expressions, are not considered core forms. A `begin` expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(begin *e[1]* *e[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: is equivalent to the `lambda` application
  prefs: []
  type: TYPE_NORMAL
- en: '`((lambda () *e[1]* *e[2]* ...))`'
  prefs: []
  type: TYPE_NORMAL
- en: and hence need not be considered core.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established a set of core syntactic forms, let's turn to a
    discussion of syntactic extensions. Syntactic extensions are so called because
    they extend the syntax of Scheme beyond the core syntax. All syntactic extensions
    in a Scheme program must ultimately be derived from the core forms. One syntactic
    extension, however, may be defined in terms of another syntactic extension, as
    long as the latter is in some sense "closer" to the core syntax. Syntactic forms
    may appear anywhere an expression or definition is expected, as long as the extended
    form expands into a definition or expression as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic extensions are defined with `define-syntax`. `define-syntax` is similar
    to `define`, except that `define-syntax` associates a syntactic transformation
    procedure, or *transformer*, with a keyword (such as `let`), rather than associating
    a value with a variable. Here is how we might define `let` with `define-syntax`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax let'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x e) ...) b1 b2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x ...) b1 b2 ...) e ...)]))`
  prefs: []
  type: TYPE_NORMAL
- en: The identifier appearing after `define-syntax` is the name, or keyword, of the
    syntactic extension being defined, in this case `let`. The `syntax-rules` form
    is an expression that evaluates to a transformer. The item following `syntax-rules`
    is a list of *auxiliary keywords* and is nearly always `()`. An example of an
    auxiliary keyword is the `else` of `cond`. (Other examples requiring the use of
    auxiliary keywords are given in Chapter [8](syntax.html#g133).) Following the
    list of auxiliary keywords is a sequence of one or more *rules*, or *pattern/template*
    pairs. Only one rule appears in our definition of `let`. The pattern part of a
    rule specifies the form that the input must take, and the template specifies to
    what the input should be transformed.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern should always be a structured expression whose first element is
    an underscore ( `_` ). (As we will see in Chapter [8](syntax.html#g133), the use
    of `_` is only a convention, but it is a good one to follow.) If more than one
    rule is present, the appropriate one is chosen by matching the patterns, in order,
    against the input during expansion. It is a syntax violation if none of the patterns
    match the input.
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers other than an underscore or ellipsis appearing within a pattern
    are *pattern variables*, unless they are listed as auxiliary keywords. Pattern
    variables match any substructure and are bound to that substructure within the
    corresponding template. The notation `*pat* ...` in the pattern allows for zero
    or more expressions matching the ellipsis prototype `*pat*` in the input. Similarly,
    the notation `*expr* ...` in the template produces zero or more expressions from
    the ellipsis prototype `*expr*` in the output. The number of `*pat*`s in the input
    determines the number of `*expr*`s in the output; in order for this to work, any
    ellipsis prototype in the template must contain at least one pattern variable
    from an ellipsis prototype in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The single rule in our definition of `let` should be fairly self-explanatory,
    but a few points are worth mentioning. First, the syntax of `let` requires that
    the body contain at least one form; hence, we have specified `b1 b2 ...` instead
    of `b ...`, which might seem more natural. On the other hand, `let` does not require
    that there be at least one variable/value pair, so we were able to use, simply,
    `(x e) ...`. Second, the pattern variables `x` and `e`, though together within
    the same prototype in the pattern, are separated in the template; any sort of
    rearrangement or recombination is possible. Finally, the three pattern variables
    `x`, `e`, and `b2` that appear in ellipsis prototypes in the pattern also appear
    in ellipsis prototypes in the template. This is not a coincidence; it is a requirement.
    In general, if a pattern variable appears within an ellipsis prototype in the
    pattern, it cannot appear outside an ellipsis prototype in the template.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `and` below is somewhat more complex than the one for `let`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax and'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_) #t]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e) e]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e1 e2 e3 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (if e1 (and e2 e3 ...) #f)]))`
  prefs: []
  type: TYPE_NORMAL
- en: This definition is recursive and involves more than one rule. Recall that `(and)`
    evaluates to `#t`; the first rule takes care of this case. The second and third
    rules specify the base case and recursion steps of the recursion and together
    translate `and` expressions with two or more subexpressions into nested `if` expressions.
    For example, `(and a b c)` expands first into
  prefs: []
  type: TYPE_NORMAL
- en: '`(if a (and b c) #f)`'
  prefs: []
  type: TYPE_NORMAL
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: '`(if a (if b (and c) #f) #f)`'
  prefs: []
  type: TYPE_NORMAL
- en: and finally
  prefs: []
  type: TYPE_NORMAL
- en: '`(if a (if b c #f) #f)`'
  prefs: []
  type: TYPE_NORMAL
- en: With this expansion, if `a` and `b` evaluate to a true value, then the value
    is the value of `c`, otherwise `#f`, as desired.
  prefs: []
  type: TYPE_NORMAL
- en: The version of `and` below is simpler but, unfortunately, incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax and ; incorrect!'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_) #t]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (if e1 (and e2 ...) #f)]))`
  prefs: []
  type: TYPE_NORMAL
- en: The expression
  prefs: []
  type: TYPE_NORMAL
- en: '`(and (not (= x 0)) (/ 1 x))`'
  prefs: []
  type: TYPE_NORMAL
- en: should return the value of `(/ 1 x)` when `x` is not zero. With the incorrect
    version of `and`, the expression expands as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(if (not (= x 0)) (and (/ 1 x)) #f) ![<graphic>](ch3_9.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (= x 0)) (if (/ 1 x) (and) #f) #f) ![<graphic>](ch3_9.gif)
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (= x 0)) (if (/ 1 x) #t #f) #f)`
  prefs: []
  type: TYPE_NORMAL
- en: The final answer if `x` is not zero is `#t`, not the value of `(/ 1 x)`.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `or` below is similar to the one for `and` except that a temporary
    variable must be introduced for each intermediate value so that we can both test
    the value and return it if it is a true value. (A temporary variable is not needed
    for `and` since there is only one false value, `#f`.)
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax or'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_) #f]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e) e]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e1 e2 e3 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([t e1])
  prefs: []
  type: TYPE_NORMAL
- en: (if t t (or e2 e3 ...)))]))`
  prefs: []
  type: TYPE_NORMAL
- en: Like variables bound by `lambda` or `let`, identifiers introduced by a template
    are lexically scoped, i.e., visible only within expressions introduced by the
    template. Thus, even if one of the expressions `e2 e3 ...` contains a reference
    to `t`, the introduced binding for `t` does not "capture" those references. This
    is typically accomplished via automatic renaming of introduced identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: As with the simpler version of `and` given above, the simpler version of `or`
    below is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax or ; incorrect!'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_) #f]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([t e1])
  prefs: []
  type: TYPE_NORMAL
- en: (if t t (or e2 ...)))]))`
  prefs: []
  type: TYPE_NORMAL
- en: The reason is more subtle, however, and is the subject of Exercise [3.2.6](further.html#g61).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write out the expansion steps necessary to expand
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x (memv ''a ls)])'
  prefs: []
  type: TYPE_NORMAL
- en: (and x (memv 'b x)))`
  prefs: []
  type: TYPE_NORMAL
- en: into core forms.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write out the expansion steps necessary to expand
  prefs: []
  type: TYPE_NORMAL
- en: '`(or (memv x ''(a b c)) (list x))`'
  prefs: []
  type: TYPE_NORMAL
- en: into core forms.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`let*` is similar to `let` but evaluates its bindings in sequence. Each of
    the right-hand-side expressions is within the scope of the earlier bindings.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let* ([a 5] [b (+ a a)] [c (+ a b)])'
  prefs: []
  type: TYPE_NORMAL
- en: (list a b c)) ![<graphic>](ch3_0.gif) (5 10 15)`
  prefs: []
  type: TYPE_NORMAL
- en: '`let*` can be implemented as nested `let` expressions. For example, the `let*`
    expression above is equivalent to the nested `let` expressions below.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([a 5])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([b (+ a a)])
  prefs: []
  type: TYPE_NORMAL
- en: (let ([c (+ a b)])
  prefs: []
  type: TYPE_NORMAL
- en: (list a b c)))) ![<graphic>](ch3_0.gif) (5 10 15)`
  prefs: []
  type: TYPE_NORMAL
- en: Define `let*` with `define-syntax`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we saw in Section [2.9](start.html#g40), it is legal to omit the third, or
    *alternative*, subexpression of an `if` expression. Doing so, however, often leads
    to confusion. Scheme provides two syntactic forms, `when` and `unless`, that may
    be used in place of such "one-armed" `if` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`(when *test* *expr[1]* *expr[2]* ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (unless *test* *expr[1]* *expr[2]* ...)`
  prefs: []
  type: TYPE_NORMAL
- en: With both forms, `test` is evaluated first. For `when`, if `test` evaluates
    to true, the remaining forms are evaluated in sequence as if enclosed in an implicit
    `begin` expression. If `test` evaluates to false, the remaining forms are not
    evaluated, and the result is unspecified. `unless` is similar except that the
    remaining forms are evaluated only if `test` evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 3])'
  prefs: []
  type: TYPE_NORMAL
- en: (unless (= x 0) (set! x (+ x 1)))
  prefs: []
  type: TYPE_NORMAL
- en: (when (= x 4) (set! x (* x 2)))
  prefs: []
  type: TYPE_NORMAL
- en: x) ![<graphic>](ch3_0.gif) 8`
  prefs: []
  type: TYPE_NORMAL
- en: Define `when` as a syntactic extension in terms of `if` and `begin`, and define
    `unless` in terms of `when`.
  prefs: []
  type: TYPE_NORMAL
- en: Section 3.2\. More Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Section [2.8](start.html#g32), we saw how to define recursive procedures
    using top-level definitions. Before that, we saw how to create local bindings
    for procedures using `let`. It is natural to wonder whether a `let`-bound procedure
    can be recursive. The answer is no, at least not in a straightforward way. If
    you try to evaluate the expression
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([sum (lambda (ls)'
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (+ (car ls) (sum (cdr ls)))))])
  prefs: []
  type: TYPE_NORMAL
- en: (sum '(1 2 3 4 5)))`
  prefs: []
  type: TYPE_NORMAL
- en: it will probably raise an exception with a message to the effect that `sum`
    is undefined. This is because the variable `sum` is visible only within the body
    of the `let` expression and not within the `lambda` expression whose value is
    bound to `sum`. We can get around this problem by passing the procedure `sum`
    to itself as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([sum (lambda (sum ls)'
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (+ (car ls) (sum sum (cdr ls)))))])
  prefs: []
  type: TYPE_NORMAL
- en: (sum sum '(1 2 3 4 5))) ![<graphic>](ch3_0.gif) 15`
  prefs: []
  type: TYPE_NORMAL
- en: This works and is a clever solution, but there is an easier way, using `letrec`.
    Like `let`, the `letrec` syntactic form includes a set of variable-value pairs,
    along with a sequence of expressions referred to as the *body* of the `letrec`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `let`, the variables `*var* ...` are visible not only within the body
    of the `letrec` but also within `*expr* ...`. Thus, we can rewrite the expression
    above as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([sum (lambda (ls)'
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (+ (car ls) (sum (cdr ls)))))])
  prefs: []
  type: TYPE_NORMAL
- en: (sum '(1 2 3 4 5))) ![<graphic>](ch3_0.gif) 15`
  prefs: []
  type: TYPE_NORMAL
- en: Using `letrec`, we can also define mutually recursive procedures, such as the
    procedures `even?` and `odd?` that were the subject of Exercise [2.8.6](start.html#g38).
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([even?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (or (= x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (odd? (- x 1))))]
  prefs: []
  type: TYPE_NORMAL
- en: '[odd?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= x 0))
  prefs: []
  type: TYPE_NORMAL
- en: (even? (- x 1))))])
  prefs: []
  type: TYPE_NORMAL
- en: (list (even? 20) (odd? 20))) ![<graphic>](ch3_0.gif) (#t #f)`
  prefs: []
  type: TYPE_NORMAL
- en: In a `letrec` expression, `*expr* ...` are most often `lambda` expressions,
    though this need not be the case. One restriction on the expressions must be obeyed,
    however. It must be possible to evaluate each `*expr*` without evaluating any
    of the variables `*var* ...`. This restriction is always satisfied if the expressions
    are all `lambda` expressions, since even though the variables may appear within
    the `lambda` expressions, they cannot be evaluated until the resulting procedures
    are invoked in the body of the `letrec`. The following `letrec` expression obeys
    this restriction.
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([f (lambda () (+ x 2))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[x 1])'
  prefs: []
  type: TYPE_NORMAL
- en: (f)) ![<graphic>](ch3_0.gif) 3`
  prefs: []
  type: TYPE_NORMAL
- en: while the following does not.
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([y (+ x 2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[x 1])'
  prefs: []
  type: TYPE_NORMAL
- en: y)`
  prefs: []
  type: TYPE_NORMAL
- en: In this case, an exception is raised indicating that `x` is not defined where
    it is referenced.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `letrec` to hide the definitions of "help" procedures so that they
    do not clutter the top-level namespace. This is demonstrated by the definition
    of `list?` below, which follows the "hare and tortoise" algorithm outlined in
    Exercise [2.9.8](start.html#g48).
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (letrec ([race
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (h t)
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? h)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([h (cdr h)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? h)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (eq? h t))
  prefs: []
  type: TYPE_NORMAL
- en: (race (cdr h) (cdr t)))
  prefs: []
  type: TYPE_NORMAL
- en: (null? h)))
  prefs: []
  type: TYPE_NORMAL
- en: (null? h)))])
  prefs: []
  type: TYPE_NORMAL
- en: (race x x))))`
  prefs: []
  type: TYPE_NORMAL
- en: When a recursive procedure is called in only one place outside the procedure,
    as in the example above, it is often clearer to use a *named* `let` expression.
    Named `let` expressions take the following form.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let *name* ((*var* *expr*) ...)'
  prefs: []
  type: TYPE_NORMAL
- en: '*body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Named `let` is similar to unnamed `let` in that it binds the variables `*var* ...`
    to the values of `*expr* ...` within the body `*body[1]* *body[2]* ...`. As with
    unnamed `let`, the variables are visible only within the body and not within `*expr* ...`.
    In addition, the variable `*name*` is bound within the body to a procedure that
    may be called to recur; the arguments to the procedure become the new values for
    the variables `*var* ...`.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `list?` has been rewritten below to use named `let`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (let race ([h x] [t x])
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? h)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([h (cdr h)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? h)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (eq? h t))
  prefs: []
  type: TYPE_NORMAL
- en: (race (cdr h) (cdr t)))
  prefs: []
  type: TYPE_NORMAL
- en: (null? h)))
  prefs: []
  type: TYPE_NORMAL
- en: (null? h)))))`
  prefs: []
  type: TYPE_NORMAL
- en: Just as `let` can be expressed as a simple direct application of a `lambda`
    expression to arguments, named `let` can be expressed as the application of a
    recursive procedure to arguments. A named `let` of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(let *name* ((*var* *expr*) ...)'
  prefs: []
  type: TYPE_NORMAL
- en: '*body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: can be rewritten in terms of `letrec` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`((letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
  prefs: []
  type: TYPE_NORMAL
- en: '*name*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*expr* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, it can be rewritten as
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
  prefs: []
  type: TYPE_NORMAL
- en: (*name* *expr* ...))`
  prefs: []
  type: TYPE_NORMAL
- en: provided that the variable `*name*` does not appear free within `*expr* ...`.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in Section [2.8](start.html#g32), some recursion is essentially
    iteration and executes as such. When a procedure call is in tail position (see
    below) with respect to a `lambda` expression, it is considered to be a *tail call*,
    and Scheme systems must treat it *properly*, as a "goto" or jump. When a procedure
    tail-calls itself or calls itself indirectly through a series of tail calls, the
    result is *tail recursion*. Because tail calls are treated as jumps, tail recursion
    can be used for indefinite iteration in place of the more restrictive iteration
    constructs provided by other programming languages, without fear of overflowing
    any sort of recursion stack.
  prefs: []
  type: TYPE_NORMAL
- en: A call is in tail position with respect to a `lambda` expression if its value
    is returned directly from the `lambda` expression, i.e., if nothing is left to
    do after the call but to return from the `lambda` expression. For example, a call
    is in tail position if it is the last expression in the body of a `lambda` expression,
    the *consequent* or *alternative* part of an `if` expression in tail position,
    the last subexpression of an `and` or `or` expression in tail position, the last
    expression in the body of a `let` or `letrec` in tail position, etc. Each of the
    calls to `f` in the expressions below are tail calls, but the calls to `g` are
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda () (f (g)))'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (if (g) (f) (f)))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (let ([x 4]) (f)))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (or (g) (f)))`
  prefs: []
  type: TYPE_NORMAL
- en: In each case, the values of the calls to `f` are returned directly, whereas
    the calls to `g` are not.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion in general and named `let` in particular provide a natural way to
    implement many algorithms, whether iterative, recursive, or partly iterative and
    partly recursive; the programmer is not burdened with two distinct mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The following two definitions of `factorial` use named `let` expressions to
    compute the factorial, *n*!, of a nonnegative integer *n*. The first employs the
    recursive definition *n*! = *n* × (*n* - 1)!, where 0! is defined to be 1.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factorial'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let fact ([i n])
  prefs: []
  type: TYPE_NORMAL
- en: (if (= i 0)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: (* i (fact (- i 1)))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(factorial 0) ![<graphic>](ch3_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (factorial 1) ![<graphic>](ch3_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (factorial 2) ![<graphic>](ch3_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (factorial 3) ![<graphic>](ch3_0.gif) 6
  prefs: []
  type: TYPE_NORMAL
- en: (factorial 10) ![<graphic>](ch3_0.gif) 3628800`
  prefs: []
  type: TYPE_NORMAL
- en: The second is an iterative version that employs the iterative definition *n*!
    = *n* × (*n* - 1) × (*n* - 2) × ... × 1, using an accumulator, `a`, to hold the
    intermediate products.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factorial'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let fact ([i n] [a 1])
  prefs: []
  type: TYPE_NORMAL
- en: (if (= i 0)
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs: []
  type: TYPE_NORMAL
- en: (fact (- i 1) (* a i))))))`
  prefs: []
  type: TYPE_NORMAL
- en: A similar problem is to compute the *n*th Fibonacci number for a given *n*.
    The *Fibonacci numbers* are an infinite sequence of integers, 0, 1, 1, 2, 3, 5,
    8, etc., in which each number is the sum of the two preceding numbers in the sequence.
    A procedure to compute the *n*th Fibonacci number is most naturally defined recursively
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define fibonacci'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let fib ([i n])
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(= i 0) 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(= i 1) 1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (+ (fib (- i 1)) (fib (- i 2)))]))))'
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 0) ![<graphic>](ch3_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 1) ![<graphic>](ch3_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 2) ![<graphic>](ch3_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 3) ![<graphic>](ch3_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 4) ![<graphic>](ch3_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 5) ![<graphic>](ch3_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 6) ![<graphic>](ch3_0.gif) 8
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 20) ![<graphic>](ch3_0.gif) 6765
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 30) ![<graphic>](ch3_0.gif) 832040`
  prefs: []
  type: TYPE_NORMAL
- en: This solution requires the computation of the two preceding Fibonacci numbers
    at each step and hence is *doubly recursive*. For example, to compute `(fibonacci 4)`
    requires the computation of both `(fib 3)` and `(fib 2)`, to compute `(fib 3)`
    requires computing both `(fib 2)` and `(fib 1)`, and to compute `(fib 2)` requires
    computing both `(fib 1)` and `(fib 0)`. This is very inefficient, and it becomes
    more inefficient as `n` grows. A more efficient solution is to adapt the accumulator
    solution of the `factorial` example above to use two accumulators, `a1` for the
    current Fibonacci number and `a2` for the preceding one.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define fibonacci'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (let fib ([i n] [a1 1] [a2 0])
  prefs: []
  type: TYPE_NORMAL
- en: (if (= i 1)
  prefs: []
  type: TYPE_NORMAL
- en: a1
  prefs: []
  type: TYPE_NORMAL
- en: (fib (- i 1) (+ a1 a2) a1))))))`
  prefs: []
  type: TYPE_NORMAL
- en: Here, zero is treated as a special case, since there is no preceding value.
    This allows us to use the single base case `(= i 1)`. The time it takes to compute
    the *n*th Fibonacci number using this iterative solution grows linearly with *n*,
    which makes a significant difference when compared to the doubly recursive version.
    To get a feel for the difference, try computing `(fibonacci 35)` and `(fibonacci 40)`
    using both definitions to see how long each takes.
  prefs: []
  type: TYPE_NORMAL
- en: We can also get a feel for the difference by looking at a trace for each on
    small inputs. The first trace below shows the calls to `fib` in the non-tail-recursive
    version of `fibonacci`, with input 5.
  prefs: []
  type: TYPE_NORMAL
- en: '`|(fib 5)'
  prefs: []
  type: TYPE_NORMAL
- en: '| (fib 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '| |(fib 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(fib 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |1'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(fib 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |0'
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| |2'
  prefs: []
  type: TYPE_NORMAL
- en: '| |(fib 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| |1'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3'
  prefs: []
  type: TYPE_NORMAL
- en: '| (fib 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '| |(fib 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| |1'
  prefs: []
  type: TYPE_NORMAL
- en: '| |(fib 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '| |1'
  prefs: []
  type: TYPE_NORMAL
- en: '| 2'
  prefs: []
  type: TYPE_NORMAL
- en: '|5`'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how there are several calls to `fib` with arguments 2, 1, and 0. The
    second trace shows the calls to `fib` in the tail-recursive version, again with
    input 5.
  prefs: []
  type: TYPE_NORMAL
- en: '`|(fib 5 1 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '|(fib 4 1 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '|(fib 3 2 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '|(fib 2 3 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '|(fib 1 5 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '|5`'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, there is quite a difference.
  prefs: []
  type: TYPE_NORMAL
- en: The named `let` examples shown so far are either tail-recursive or not tail-recursive.
    It often happens that one recursive call within the same expression is tail-recursive
    while another is not. The definition of `factor` below computes the prime factors
    of its nonnegative integer argument. The first call to `f` is not tail-recursive,
    but the second one is.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factor'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([n n] [i 2])
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(>= i n) (list n)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(integer? (/ n i))'
  prefs: []
  type: TYPE_NORMAL
- en: (cons i (f (/ n i) i))]
  prefs: []
  type: TYPE_NORMAL
- en: '[else (f n (+ i 1))]))))'
  prefs: []
  type: TYPE_NORMAL
- en: (factor 0) ![<graphic>](ch3_0.gif) (0)
  prefs: []
  type: TYPE_NORMAL
- en: (factor 1) ![<graphic>](ch3_0.gif) (1)
  prefs: []
  type: TYPE_NORMAL
- en: (factor 12) ![<graphic>](ch3_0.gif) (2 2 3)
  prefs: []
  type: TYPE_NORMAL
- en: (factor 3628800) ![<graphic>](ch3_0.gif) (2 2 2 2 2 2 2 2 3 3 3 3 5 5 7)
  prefs: []
  type: TYPE_NORMAL
- en: (factor 9239) ![<graphic>](ch3_0.gif) (9239)`
  prefs: []
  type: TYPE_NORMAL
- en: A trace of the calls to `f`, produced in Chez Scheme by replacing `let` with
    `trace-let`, in the evaluation of `(factor 120)` below highlights the difference
    between the nontail calls and the tail calls.
  prefs: []
  type: TYPE_NORMAL
- en: '`|(f 120 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| (f 60 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| |(f 30 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (f 15 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (f 15 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(f 5 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(f 5 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(f 5 5)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(5)'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (3 5)'
  prefs: []
  type: TYPE_NORMAL
- en: '| |(2 3 5)'
  prefs: []
  type: TYPE_NORMAL
- en: '| (2 2 3 5)'
  prefs: []
  type: TYPE_NORMAL
- en: '|(2 2 2 3 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: A nontail call to `f` is shown indented relative to its caller, since the caller
    is still active, whereas tail calls appear at the same level of indentation.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Which of the recursive procedures defined in Section [3.2](further.html#g55)
    are tail-recursive, and which are not?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite `factor` using `letrec` to bind `f` in place of named `let`. Which version
    do you prefer?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Can the `letrec` expression below be rewritten using named `let`? If not, why
    not? If so, do it.
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([even?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (or (= x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (odd? (- x 1))))]
  prefs: []
  type: TYPE_NORMAL
- en: '[odd?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= x 0))
  prefs: []
  type: TYPE_NORMAL
- en: (even? (- x 1))))])
  prefs: []
  type: TYPE_NORMAL
- en: (even? 20))`
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite both definitions of `fibonacci` given in this section to count the number
    of recursive calls to `fib`, using a counter similar to the one used in the `cons-count`
    example of Section [2.9](start.html#g40). Count the number of recursive calls
    made in each case for several input values. What do you notice?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Augment the definition of `let` given in Section [3.1](further.html#g50) to
    handle named `let` as well as unnamed `let`, using two rules.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following definition of `or` is simpler than the one given in Section [3.1](further.html#g50).
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax or ; incorrect!'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_) #f]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([t e1])
  prefs: []
  type: TYPE_NORMAL
- en: (if t t (or e2 ...)))]))`
  prefs: []
  type: TYPE_NORMAL
- en: 'Say why it is not correct. [*Hint*: Think about what would happen if this version
    of `or` were used in the `even?` and `odd?` example given on page [66](further.html#defn:even?/odd?)
    for very large inputs.]'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The definition of `factor` is not the most efficient possible. First, no factors
    of *n* besides *n* itself can possibly be found beyond ![<graphic>](ch3_10.gif).
    Second, the division `(/ n i)` is performed twice when a factor is found. Third,
    after 2, no even factors can possibly be found. Recode `factor` to correct all
    three problems. Which is the most important problem to solve? Are there any additional
    improvements you can make?
  prefs: []
  type: TYPE_NORMAL
- en: Section 3.3\. Continuations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During the evaluation of a Scheme expression, the implementation must keep
    track of two things: (1) what to evaluate and (2) what to do with the value. Consider
    the evaluation of `(null? x)` within the expression below.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(if (null? x) (quote ()) (cdr x))`'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation must first evaluate `(null? x)` and, based on its value,
    evaluate either `(quote ())` or `(cdr x)`. "What to evaluate" is `(null? x)`,
    and "what to do with the value" is to make the decision which of `(quote ())`
    and `(cdr x)` to evaluate and to do so. We call "what to do with the value" the
    *continuation* of a computation.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, at any point during the evaluation of any expression, there is a continuation
    ready to complete, or at least *continue*, the computation from that point. Let's
    assume that `x` has the value `(a b c)`. We can isolate six continuations during
    the evaluation of `(if (null? x) (quote ()) (cdr x))`, the continuations waiting
    for
  prefs: []
  type: TYPE_NORMAL
- en: the value of `(if (null? x) (quote ()) (cdr x))`,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the value of `(null? x)`,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the value of `null?`,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the value of `x`,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the value of `cdr`, and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the value of `x` (again).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The continuation of `(cdr x)` is not listed because it is the same as the one
    waiting for `(if (null? x) (quote ()) (cdr x))`.
  prefs: []
  type: TYPE_NORMAL
- en: Scheme allows the continuation of any expression to be captured with the procedure
    `call/cc`. `call/cc` must be passed a procedure `*p*` of one argument. `call/cc`
    constructs a concrete representation of the current continuation and passes it
    to `*p*`. The continuation itself is represented by a procedure `*k*`. Each time
    `*k*` is applied to a value, it returns the value to the continuation of the `call/cc`
    application. This value becomes, in essence, the value of the application of `call/cc`.
  prefs: []
  type: TYPE_NORMAL
- en: If `*p*` returns without invoking `*k*`, the value returned by the procedure
    becomes the value of the application of `call/cc`.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the simple examples below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(call/cc'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (* 5 4))) ![<graphic>](ch3_0.gif) 20
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (* 5 (k 4)))) ![<graphic>](ch3_0.gif) 4
  prefs: []
  type: TYPE_NORMAL
- en: (+ 2
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (* 5 (k 4))))) ![<graphic>](ch3_0.gif) 6`
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, the continuation is captured and bound to `k`, but `k`
    is never used, so the value is simply the product of 5 and 4. In the second, the
    continuation is invoked before the multiplication, so the value is the value passed
    to the continuation, 4. In the third, the continuation includes the addition by
    2; thus, the value is the value passed to the continuation, 4, plus 2.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a less trivial example, showing the use of `call/cc` to provide a nonlocal
    exit from a recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define product'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (break)
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls ls])
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(null? ls) 1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(= (car ls) 0) (break 0)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (* (car ls) (f (cdr ls)))]))))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(product ''(1 2 3 4 5)) ![<graphic>](ch3_0.gif) 120'
  prefs: []
  type: TYPE_NORMAL
- en: (product '(7 3 8 0 1 9 5)) ![<graphic>](ch3_0.gif) 0`
  prefs: []
  type: TYPE_NORMAL
- en: The nonlocal exit allows `product` to return immediately, without performing
    the pending multiplications, when a zero value is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the continuation invocations above returns to the continuation while
    control remains within the procedure passed to `call/cc`. The following example
    uses the continuation after this procedure has already returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x (call/cc (lambda (k) k))])'
  prefs: []
  type: TYPE_NORMAL
- en: (x (lambda (ignore) "hi"))) ![<graphic>](ch3_0.gif) "hi"`
  prefs: []
  type: TYPE_NORMAL
- en: The continuation captured by this invocation of `call/cc` may be described as
    "Take the value, bind it to `x`, and apply the value of `x` to the value of `(lambda (ignore) "hi")`."
    Since `(lambda (k) k)` returns its argument, `x` is bound to the continuation
    itself; this continuation is applied to the procedure resulting from the evaluation
    of `(lambda (ignore) "hi")`. This has the effect of binding `x` (again!) to this
    procedure and applying the procedure to itself. The procedure ignores its argument
    and returns `"hi"`.
  prefs: []
  type: TYPE_NORMAL
- en: The following variation of the example above is probably the most confusing
    Scheme program of its size; it might be easy to guess what it returns, but it
    takes some thought to figure out why.
  prefs: []
  type: TYPE_NORMAL
- en: '`(((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!") ![<graphic>](ch3_0.gif) "HEY!"`'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `call/cc` is its own continuation, as in the preceding example.
    This is applied to the identity procedure `(lambda (x) x)`, so the `call/cc` returns
    a second time with this value. Then, the identity procedure is applied to itself,
    yielding the identity procedure. This is finally applied to `"HEY!"`, yielding
    `"HEY!"`.
  prefs: []
  type: TYPE_NORMAL
- en: Continuations used in this manner are not always so puzzling. Consider the following
    definition of `factorial` that saves the continuation at the base of the recursion
    before returning 1, by assigning the top-level variable `retry`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define retry #f)'
  prefs: []
  type: TYPE_NORMAL
- en: (define factorial
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc (lambda (k) (set! retry k) 1))
  prefs: []
  type: TYPE_NORMAL
- en: (* x (factorial (- x 1))))))`
  prefs: []
  type: TYPE_NORMAL
- en: With this definition, `factorial` works as we expect `factorial` to work, except
    it has the side effect of assigning `retry`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(factorial 4) ![<graphic>](ch3_0.gif) 24'
  prefs: []
  type: TYPE_NORMAL
- en: (retry 1) ![<graphic>](ch3_0.gif) 24
  prefs: []
  type: TYPE_NORMAL
- en: (retry 2) ![<graphic>](ch3_0.gif) 48`
  prefs: []
  type: TYPE_NORMAL
- en: The continuation bound to `retry` might be described as "Multiply the value
    by 1, then multiply this result by 2, then multiply this result by 3, then multiply
    this result by 4." If we pass the continuation a different value, i.e., not 1,
    we will cause the base value to be something other than 1 and hence change the
    end result.
  prefs: []
  type: TYPE_NORMAL
- en: '`(retry 2) ![<graphic>](ch3_0.gif) 48'
  prefs: []
  type: TYPE_NORMAL
- en: (retry 5) ![<graphic>](ch3_0.gif) 120`
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism could be the basis for a breakpoint package implemented with
    `call/cc`; each time a breakpoint is encountered, the continuation of the breakpoint
    is saved so that the computation may be restarted from the breakpoint (more than
    once, if desired).
  prefs: []
  type: TYPE_NORMAL
- en: Continuations may be used to implement various forms of multitasking. The simple
    "light-weight process" mechanism defined below allows multiple computations to
    be interleaved. Since it is *nonpreemptive*, it requires that each process voluntarily
    "pause" from time to time in order to allow the others to run.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define lwp-list ''())'
  prefs: []
  type: TYPE_NORMAL
- en: (define lwp
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (thunk)
  prefs: []
  type: TYPE_NORMAL
- en: (set! lwp-list (append lwp-list (list thunk)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define start
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([p (car lwp-list)])
  prefs: []
  type: TYPE_NORMAL
- en: (set! lwp-list (cdr lwp-list))
  prefs: []
  type: TYPE_NORMAL
- en: (p))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(define pause'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (lwp (lambda () (k #f)))
  prefs: []
  type: TYPE_NORMAL
- en: (start)))))`
  prefs: []
  type: TYPE_NORMAL
- en: The following light-weight processes cooperate to print an infinite sequence
    of lines containing `"hey!"`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(lwp (lambda () (let f () (pause) (display "h") (f))))'
  prefs: []
  type: TYPE_NORMAL
- en: (lwp (lambda () (let f () (pause) (display "e") (f))))
  prefs: []
  type: TYPE_NORMAL
- en: (lwp (lambda () (let f () (pause) (display "y") (f))))
  prefs: []
  type: TYPE_NORMAL
- en: (lwp (lambda () (let f () (pause) (display "!") (f))))
  prefs: []
  type: TYPE_NORMAL
- en: (lwp (lambda () (let f () (pause) (newline) (f))))
  prefs: []
  type: TYPE_NORMAL
- en: (start) ![<graphic>](ch3_0.gif) *hey!*
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) *hey!*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) *hey!*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) *hey!*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) ![<graphic>](ch3_3.gif)`'
  prefs: []
  type: TYPE_NORMAL
- en: See Section [12.11](examples.html#g208) for an implementation of *engines*,
    which support preemptive multitasking, with `call/cc`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.3.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use `call/cc` to write a program that loops indefinitely, printing a sequence
    of numbers beginning at zero. Do not use any recursive procedures, and do not
    use any assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.3.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite `product` without `call/cc`, retaining the feature that no multiplications
    are performed if any of the list elements are zero.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.3.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What would happen if a process created by `lwp` as defined above were to terminate,
    i.e., simply return without calling `pause`? Define a `quit` procedure that allows
    a process to terminate without otherwise affecting the `lwp` system. Be sure to
    handle the case in which the only remaining process terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.3.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time `lwp` is called, the list of processes is copied because `lwp` uses
    `append` to add its argument to the end of the process list. Modify the original
    `lwp` code to use the queue data type developed in Section [2.9](start.html#g40)
    to avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.3.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The light-weight process mechanism allows new processes to be created dynamically,
    although the example given in this section does not do so. Design an application
    that requires new processes to be created dynamically and implement it using the
    light-weight process mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Section 3.4\. Continuation Passing Style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed in the preceding section, a continuation waits for the value
    of each expression. In particular, a continuation is associated with each procedure
    call. When one procedure invokes another via a nontail call, the called procedure
    receives an implicit continuation that is responsible for completing what is left
    of the calling procedure's body plus returning to the calling procedure's continuation.
    If the call is a tail call, the called procedure simply receives the continuation
    of the calling procedure.
  prefs: []
  type: TYPE_NORMAL
- en: We can make the continuations explicit by encapsulating "what to do" in an explicit
    procedural argument passed along on each call. For example, the continuation of
    the call to `f` in
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([f (lambda (x) (cons ''a x))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[g (lambda (x) (cons ''b (f x)))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[h (lambda (x) (g (cons ''c x)))])'
  prefs: []
  type: TYPE_NORMAL
- en: (cons 'd (h '()))) ![<graphic>](ch3_0.gif) (d b a c)`
  prefs: []
  type: TYPE_NORMAL
- en: conses the symbol `b` onto the value returned to it, then returns the result
    of this cons to the continuation of the call to `g`. This continuation is the
    same as the continuation of the call to `h`, which conses the symbol `d` onto
    the value returned to it. We can rewrite this in *continuation-passing style*,
    or CPS, by replacing these implicit continuations with explicit procedures.
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([f (lambda (x k) (k (cons ''a x)))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[g (lambda (x k)'
  prefs: []
  type: TYPE_NORMAL
- en: (f x (lambda (v) (k (cons 'b v)))))]
  prefs: []
  type: TYPE_NORMAL
- en: '[h (lambda (x k) (g (cons ''c x) k))])'
  prefs: []
  type: TYPE_NORMAL
- en: (h '() (lambda (v) (cons 'd v))))`
  prefs: []
  type: TYPE_NORMAL
- en: Like the implicit continuation of `h` and `g` in the preceding example, the
    explicit continuation passed to `h` and on to `g`,
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (v) (cons ''d v))`'
  prefs: []
  type: TYPE_NORMAL
- en: conses the symbol `d` onto the value passed to it. Similarly, the continuation
    passed to `f`,
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (v) (k (cons ''b v)))`'
  prefs: []
  type: TYPE_NORMAL
- en: conses `b` onto the value passed to it, then passes this on to the continuation
    of `g`.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions written in CPS are more complicated, of course, but this style of
    programming has some useful applications. CPS allows a procedure to pass more
    than one result to its continuation, because the procedure that implements the
    continuation can take any number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define car&cdr'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p k)
  prefs: []
  type: TYPE_NORMAL
- en: (k (car p) (cdr p))))
  prefs: []
  type: TYPE_NORMAL
- en: (car&cdr '(a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  prefs: []
  type: TYPE_NORMAL
- en: (list y x))) ![<graphic>](ch3_0.gif) ((b c) a)
  prefs: []
  type: TYPE_NORMAL
- en: (car&cdr '(a b c) cons) ![<graphic>](ch3_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (car&cdr '(a b c a d) memv) ![<graphic>](ch3_0.gif) (a d)`
  prefs: []
  type: TYPE_NORMAL
- en: (This can be done with multiple values as well; see Section [5.8](control.html#g104).)
    CPS also allows a procedure to take separate "success" and "failure" continuations,
    which may accept different numbers of arguments. An example is `integer-divide`
    below, which passes the quotient and remainder of its first two arguments to its
    third, unless the second argument (the divisor) is zero, in which case it passes
    an error message to its fourth argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define integer-divide'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y success failure)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= y 0)
  prefs: []
  type: TYPE_NORMAL
- en: (failure "divide by zero")
  prefs: []
  type: TYPE_NORMAL
- en: (let ([q (quotient x y)])
  prefs: []
  type: TYPE_NORMAL
- en: (success q (- x (* q y)))))))
  prefs: []
  type: TYPE_NORMAL
- en: (integer-divide 10 3 list (lambda (x) x)) ![<graphic>](ch3_0.gif) (3 1)
  prefs: []
  type: TYPE_NORMAL
- en: (integer-divide 10 0 list (lambda (x) x)) ![<graphic>](ch3_0.gif) "divide by zero"`
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `quotient`, employed by `integer-divide`, returns the quotient
    of its two arguments, truncated toward zero.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit success and failure continuations can sometimes help to avoid the extra
    communication necessary to separate successful execution of a procedure from unsuccessful
    execution. Furthermore, it is possible to have multiple success or failure continuations
    for different flavors of success or failure, each possibly taking different numbers
    and types of arguments. See Sections [12.10](examples.html#g204) and [12.11](examples.html#g208)
    for extended examples that employ continuation-passing style.
  prefs: []
  type: TYPE_NORMAL
- en: At this point you might be wondering about the relationship between CPS and
    the continuations captured via `call/cc`. It turns out that any program that uses
    `call/cc` can be rewritten in CPS without `call/cc`, but a total rewrite of the
    program (sometimes including even system-defined primitives) might be necessary.
    Try to convert the `product` example on page [75](further.html#defn:product-call/cc)
    into CPS before looking at the version below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define product'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls k)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([break k])
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls ls] [k k])
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(null? ls) (k 1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(= (car ls) 0) (break 0)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (f (cdr ls)'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (k (* (car ls) x))))])))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(product ''(1 2 3 4 5) (lambda (x) x)) ![<graphic>](ch3_0.gif) 120'
  prefs: []
  type: TYPE_NORMAL
- en: (product '(7 3 8 0 1 9 5) (lambda (x) x)) ![<graphic>](ch3_0.gif) 0`
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.4.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the `reciprocal` example first given in Section [2.1](start.html#g5)
    to accept both success and failure continuations, like `integer-divide` above.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.4.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the `retry` example from page [75](further.html#retry) to use CPS.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.4.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the following expression in CPS to avoid using `call/cc`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocals'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (map (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (k "zero found")
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 x)))
  prefs: []
  type: TYPE_NORMAL
- en: ls)))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(reciprocals ''(2 1/3 5 1/4)) ![<graphic>](ch3_0.gif) (1/2 3 1/5 4)'
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocals '(2 1/3 0 5 1/4)) ![<graphic>](ch3_0.gif) "zero found"`
  prefs: []
  type: TYPE_NORMAL
- en: '[*Hint*: A single-list version of `map` is defined on page [46](start.html#defn:map1).]'
  prefs: []
  type: TYPE_NORMAL
- en: Section 3.5\. Internal Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Section [2.6](start.html#g25), we discussed top-level definitions. Definitions
    may also appear at the front of a `lambda`, `let`, or `letrec` body, in which
    case the bindings they create are local to the body.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define f (lambda (x) (* x x)))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 3])
  prefs: []
  type: TYPE_NORMAL
- en: (define f (lambda (y) (+ y x)))
  prefs: []
  type: TYPE_NORMAL
- en: (f 4)) ![<graphic>](ch3_0.gif) 7
  prefs: []
  type: TYPE_NORMAL
- en: (f 4) ![<graphic>](ch3_0.gif) 16`
  prefs: []
  type: TYPE_NORMAL
- en: Procedures bound by internal definitions can be mutually recursive, as with
    `letrec`. For example, we can rewrite the `even?` and `odd?` example from Section [3.2](further.html#g55)
    using internal definitions as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ()'
  prefs: []
  type: TYPE_NORMAL
- en: (define even?
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (or (= x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (odd? (- x 1)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define odd?
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= x 0))
  prefs: []
  type: TYPE_NORMAL
- en: (even? (- x 1)))))
  prefs: []
  type: TYPE_NORMAL
- en: (even? 20)) ![<graphic>](ch3_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can replace the use of `letrec` to bind `race` with an internal
    definition of `race` in our first definition of `list?`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (define race
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (h t)
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? h)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([h (cdr h)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? h)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (eq? h t))
  prefs: []
  type: TYPE_NORMAL
- en: (race (cdr h) (cdr t)))
  prefs: []
  type: TYPE_NORMAL
- en: (null? h)))
  prefs: []
  type: TYPE_NORMAL
- en: (null? h))))
  prefs: []
  type: TYPE_NORMAL
- en: (race x x)))`
  prefs: []
  type: TYPE_NORMAL
- en: In fact, internal variable definitions and `letrec` are practically interchangeable.
    The only difference, other than the obvious difference in syntax, is that variable
    definitions are guaranteed to be evaluated from left to right, while the bindings
    of a letrec may be evaluated in any order. So we cannot quite replace a `lambda`,
    `let`, or `letrec` body containing internal definitions with a `letrec` expression.
    We can, however, use `letrec*`, which, like `let*`, guarantees left-to-right evaluation
    order. A body of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *var* *expr[0]*)'
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch3_3.gif)'
  prefs: []
  type: TYPE_IMG
- en: '*expr[1]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*expr[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch3_3.gif)`'
  prefs: []
  type: TYPE_NORMAL
- en: is equivalent to a `letrec*` expression binding the defined variables to the
    associated values in a body comprising the expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec* ((*var* *expr[0]*) ...) *expr[1]* *expr[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, a `letrec*` of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec* ((*var* *expr[0]*) ...) *expr[1]* *expr[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: can be replaced with a `let` expression containing internal definitions and
    the expressions from the body as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ()'
  prefs: []
  type: TYPE_NORMAL
- en: (define *var* *expr[0]*)
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch3_3.gif)'
  prefs: []
  type: TYPE_IMG
- en: '*expr[1]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*expr[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch3_3.gif)'
  prefs: []
  type: TYPE_IMG
- en: )`
  prefs: []
  type: TYPE_NORMAL
- en: The seeming lack of symmetry between these transformations is due to the fact
    that `letrec*` expressions can appear anywhere an expression is valid, whereas
    internal definitions can appear only at the front of a body. Thus, in replacing
    a `letrec*` with internal definitions, we must generally introduce a `let` expression
    to hold the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between internal definitions and `letrec` or `letrec*` is
    that syntax definitions may appear among the internal definitions, while `letrec`
    and `letrec*` bind only variables.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 3])'
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax set-x!
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e) (set! x e)]))'
  prefs: []
  type: TYPE_NORMAL
- en: (set-x! (+ x x))
  prefs: []
  type: TYPE_NORMAL
- en: x) ![<graphic>](ch3_0.gif) 6`
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a syntactic extension established by an internal syntax definition,
    as with an internal variable definition, is limited to the body in which the syntax
    definition appears.
  prefs: []
  type: TYPE_NORMAL
- en: Internal definitions may be used in conjunction with top-level definitions and
    assignments to help modularize programs. Each module of a program should make
    visible only those bindings that are needed by other modules, while hiding other
    bindings that would otherwise clutter the top-level namespace and possibly result
    in unintended use or redefinition of those bindings. A common way of structuring
    a module is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *export-var* #f)'
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch3_3.gif)'
  prefs: []
  type: TYPE_IMG
- en: (let ()
  prefs: []
  type: TYPE_NORMAL
- en: (define *var* *expr*)
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch3_3.gif)'
  prefs: []
  type: TYPE_IMG
- en: '*init-expr*'
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch3_3.gif)'
  prefs: []
  type: TYPE_IMG
- en: (set! *export-var* *export-val*)
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch3_3.gif)'
  prefs: []
  type: TYPE_IMG
- en: )`
  prefs: []
  type: TYPE_NORMAL
- en: The first set of definitions establish top-level bindings for the variables
    we desire to export (make visible globally). The second set of definitions establish
    local bindings visible only within the module. The expressions `*init-expr* ...`
    perform any initialization that must occur after the local bindings have been
    established. Finally, the `set!` expressions assign the exported variables to
    the appropriate values.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of this form of modularization is that the bracketing `let` expression
    may be removed or "commented out" during program development, making the internal
    definitions top-level to facilitate interactive testing. This form of modularization
    also has several disadvantages, as we discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The following module exports a single variable, `calc`, which is bound to a
    procedure that implements a simple four-function calculator.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define calc #f)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ()
  prefs: []
  type: TYPE_NORMAL
- en: (define do-calc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek expr)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(number? expr) expr]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(and (list? expr) (= (length expr) 3))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([op (car expr)] [args (cdr expr)])
  prefs: []
  type: TYPE_NORMAL
- en: (case op
  prefs: []
  type: TYPE_NORMAL
- en: '[(add) (apply-op ek + args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(sub) (apply-op ek - args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(mul) (apply-op ek * args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(div) (apply-op ek / args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain ek "invalid operator" op)]))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain ek "invalid expression" expr)])))'
  prefs: []
  type: TYPE_NORMAL
- en: (define apply-op
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek op args)
  prefs: []
  type: TYPE_NORMAL
- en: (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define complain
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek msg expr)
  prefs: []
  type: TYPE_NORMAL
- en: (ek (list msg expr))))
  prefs: []
  type: TYPE_NORMAL
- en: (set! calc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (expr)
  prefs: []
  type: TYPE_NORMAL
- en: ; grab an error continuation ek
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek)
  prefs: []
  type: TYPE_NORMAL
- en: (do-calc ek expr))))))
  prefs: []
  type: TYPE_NORMAL
- en: (calc '(add (mul 3 2) -4)) ![<graphic>](ch3_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (calc '(div 1/2 1/6)) ![<graphic>](ch3_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (calc '(add (mul 3 2) (div 4))) ![<graphic>](ch3_0.gif) ("invalid expression" (div 4))
  prefs: []
  type: TYPE_NORMAL
- en: (calc '(mul (add 1 -2) (pow 2 7))) ![<graphic>](ch3_0.gif) ("invalid operator" pow)`
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses a `case` expression to determine which operator to apply.
    `case` is similar to `cond` except that the test is always the same: `(memv *val* (*key* ...))`,
    where `*val*` is the value of the first `case` subform and `(*key* ...)` is the
    list of items at the front of each `case` clause. The `case` expression in the
    example above could be rewritten using `cond` as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([temp op])'
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(memv temp ''(add)) (apply-op ek + args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(memv temp ''(sub)) (apply-op ek - args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(memv temp ''(mul)) (apply-op ek * args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(memv temp ''(div)) (apply-op ek / args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain ek "invalid operator" op)]))`'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.5.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Redefine `complain` in the `calc` example as an equivalent syntactic extension.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.5.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the `calc` example, the error continuation `ek` is passed along on each call
    to `apply-op`, `complain`, and `do-calc`. Move the definitions of `apply-op`,
    `complain`, and `do-calc` inward as far as necessary to eliminate the `ek` argument
    from the definitions and applications of these procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.5.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Eliminate the `call/cc` from `calc` and rewrite `complain` to raise an exception
    using `assertion-violation`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.5.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Extend `calc` to handle unary minus expressions, e.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '`(calc ''(minus (add 2 3))) ![<graphic>](ch3_0.gif) -5`'
  prefs: []
  type: TYPE_NORMAL
- en: and other operators of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Section 3.6\. Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the end of the preceding section, we discussed a form of modularization
    that involves assigning a set of top-level variables from within a `let` while
    keeping unpublished helpers local to the `let`. This form of modularization has
    several drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: It is unportable, because the behavior and even existence of an interactive
    top level is not guaranteed by the Revised⁶ Report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires assignments, which make the code appear somewhat awkward and may
    inhibit compiler analyses and optimizations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not support the publication of keyword bindings, since there is no analogue
    to `set!` for keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative that does not share these drawbacks is to create a library. A
    library exports a set of identifiers, each defined within the library or imported
    from some other library. An exported identifier need not be bound as a variable;
    it may be bound as a keyword instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following library exports two identifiers: the variable `gpa->grade` and
    the keyword `gpa`. The variable `gpa->grade` is bound to a procedure that takes
    a grade-point average (GPA), represented as a number, and returns the corresponding
    letter grade, based on a four-point scale. The keyword `gpa` names a syntactic
    extension whose subforms must all be letter grades and whose value is the GPA
    computed from those letter grades.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(library (grades)'
  prefs: []
  type: TYPE_NORMAL
- en: (export gpa->grade gpa)
  prefs: []
  type: TYPE_NORMAL
- en: (import (rnrs))
  prefs: []
  type: TYPE_NORMAL
- en: (define in-range?
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x n y)
  prefs: []
  type: TYPE_NORMAL
- en: (and (>= n x) (< n y))))
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax range-case
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules (- else)
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([tmp expr])
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(in-range? x tmp y) e1 e2 ...]'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '[else ee1 ee2 ...]))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ expr ((x - y) e1 e2 ...) ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([tmp expr])
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(in-range? x tmp y) e1 e2 ...]'
  prefs: []
  type: TYPE_NORMAL
- en: '...))]))'
  prefs: []
  type: TYPE_NORMAL
- en: (define letter->number
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (case x
  prefs: []
  type: TYPE_NORMAL
- en: '[(a)  4.0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(b)  3.0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(c)  2.0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(d)  1.0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(f)  0.0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (assertion-violation ''grade "invalid letter grade" x)])))'
  prefs: []
  type: TYPE_NORMAL
- en: (define gpa->grade
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (range-case x
  prefs: []
  type: TYPE_NORMAL
- en: '[(0.0 - 0.5) ''f]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(0.5 - 1.5) ''d]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(1.5 - 2.5) ''c]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(2.5 - 3.5) ''b]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else ''a])))'
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax gpa
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ g1 g2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (map letter->number '(g1 g2 ...))])
  prefs: []
  type: TYPE_NORMAL
- en: (/ (apply + ls) (length ls)))])))`
  prefs: []
  type: TYPE_NORMAL
- en: The name of the library is `(grades)`. This may seem like a funny kind of name,
    but all library names are parenthesized. The library imports from the standard
    `(rnrs)` library, which contains most of the primitive and keyword bindings we
    have used in this chapter and the last, and everything we need to implement `gpa->grade`
    and `gpa`.
  prefs: []
  type: TYPE_NORMAL
- en: Along with `gpa->grade` and `gpa`, several other syntactic extensions and procedures
    are defined within the library, but none of the others are exported. The ones
    that aren't exported are simply helpers for the ones that are. Everything used
    within the library should be familiar, except for the `apply` procedure, which
    is described on page [107](control.html#desc:apply).
  prefs: []
  type: TYPE_NORMAL
- en: If your Scheme implementation supports `import` in the interactive top level,
    you can test the two exports as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(import (grades))'
  prefs: []
  type: TYPE_NORMAL
- en: (gpa c a c b b) ![<graphic>](ch3_0.gif) 2.8
  prefs: []
  type: TYPE_NORMAL
- en: (gpa->grade 2.8) ![<graphic>](ch3_0.gif) b`
  prefs: []
  type: TYPE_NORMAL
- en: Chapter [10](libraries.html#g142) describes libraries in more detail and provides
    additional examples of their use.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.6.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modify `gpa` to handle "`x`" grades, which do not count in the grade-point average.
    Be careful to handle gracefully the situation where each grade is `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(import (grades))'
  prefs: []
  type: TYPE_NORMAL
- en: (gpa a x b c) ![<graphic>](ch3_0.gif) 3.0`
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.6.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Export from `(grades)` a new syntactic form, `distribution`, that takes a set
    of grades, like `gpa`, but returns a list of the form `((*n* *g*) ...)`, where
    `*n*` is the number of times `*g*` appears in the set, with one entry for each
    `*g*`. Have `distribution` call an unexported procedure to do the actual work.
  prefs: []
  type: TYPE_NORMAL
- en: '`(import (grades))'
  prefs: []
  type: TYPE_NORMAL
- en: (distribution a b a c c c a f b a) ![<graphic>](ch3_0.gif) ((4 a) (2 b) (3 c) (0 d) (1 f))`
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.6.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now read about output operations in Section [7.8](io.html#g129) and define a
    new export, `histogram`, as a procedure that takes a `*textual output port*` and
    a distribution, such as might be produced by `distribution`, and prints a histogram
    in the style illustrated by the example below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(import (grades))'
  prefs: []
  type: TYPE_NORMAL
- en: (histogram
  prefs: []
  type: TYPE_NORMAL
- en: (current-output-port)
  prefs: []
  type: TYPE_NORMAL
- en: (distribution a b a c c a c a f b a))
  prefs: []
  type: TYPE_NORMAL
- en: '*prints:*'
  prefs: []
  type: TYPE_NORMAL
- en: a: *****
  prefs: []
  type: TYPE_NORMAL
- en: b: **
  prefs: []
  type: TYPE_NORMAL
- en: c: ***
  prefs: []
  type: TYPE_NORMAL
- en: 'd:'
  prefs: []
  type: TYPE_NORMAL
- en: f: *`
  prefs: []
  type: TYPE_NORMAL
