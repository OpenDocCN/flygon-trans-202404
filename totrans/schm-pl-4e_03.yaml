- en: Chapter 3\. Going Further
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 深入了解
- en: The preceding chapter prepared you to write Scheme programs using a small set
    of the most useful primitive syntactic forms and procedures. This chapter introduces
    a number of additional features and programming techniques that will allow you
    to write more sophisticated and efficient programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章使您能够使用一小组最有用的原始句法形式和过程编写Scheme程序。本章介绍了许多额外功能和编程技术，这将使您能够编写更复杂和高效的程序。
- en: Section 3.1\. Syntactic Extension
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3.1节 句法扩展
- en: As we saw in Section [2.5](start.html#g21), the `let` syntactic form is merely
    a *syntactic extension* defined in terms of a `lambda` expression and a procedure
    application, both core syntactic forms. At this point, you might be wondering
    which syntactic forms are core forms and which are syntactic extensions, and how
    new syntactic extensions may be defined. This section provides some answers to
    these questions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第[2.5](start.html#g21)节中看到的，`let`句法形式仅仅是一个*句法扩展*，以`lambda`表达式和过程应用为核心句法形式来定义。此时，您可能想知道哪些句法形式是核心形式，哪些是句法扩展，以及如何定义新的句法扩展。本节将回答这些问题。
- en: In truth, it is not necessary for us to draw a distinction between core forms
    and syntactic extensions, since once defined, a syntactic extension has exactly
    the same status as a core form. Drawing a distinction, however, makes understanding
    the language easier, since it allows us to focus attention on the core forms and
    to understand all others in terms of them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们并不需要区分核心形式和句法扩展，因为一旦定义，句法扩展与核心形式具有完全相同的地位。然而，区分这两者可以使理解语言更容易，因为它允许我们将注意力集中在核心形式上，并以此理解所有其他形式。
- en: It *is* necessary for a Scheme implementation to distinguish between core forms
    and syntactic extensions. A Scheme implementation expands syntactic extensions
    into core forms as the first step of compilation or interpretation, allowing the
    rest of the compiler or interpreter to focus only on the core forms. The set of
    core forms remaining after expansion to be handled directly by the compiler or
    interpreter is implementation-dependent, however, and may be different from the
    set of forms described as core here.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scheme实现来说，区分核心形式和句法扩展是必要的。Scheme实现将句法扩展扩展为核心形式作为编译或解释的第一步，使得编译器或解释器的其余部分只需关注核心形式。然而，经过扩展后由编译器或解释器直接处理的核心形式集合是依赖于实现的，可能与此处描述的核心形式集合不同。
- en: The exact set of syntactic forms making up the core of the language is thus
    subject to debate, although it must be possible to derive all other forms from
    any set of forms declared to be core forms. The set described here is among the
    simplest for which this constraint is satisfied.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的句法形式集合构成了语言核心，因此存在争议，尽管必须能够从声明为核心形式的任何形式集合中推导出所有其他形式。这里描述的集合是满足这一约束条件的最简单之一。
- en: The core syntactic forms include top-level `define` forms, constants, variables,
    procedure applications, `quote` expressions, `lambda` expressions, `if` expressions,
    and `set!` expressions. The grammar below describes the core syntax of Scheme
    in terms of these definitions and expressions. In the grammar, vertical bars ( | )
    separate alternatives, and a form followed by an asterisk ( * ) represents zero
    or more occurrences of the form. <variable> is any Scheme identifier. <datum>
    is any Scheme object, such as a number, list, symbol, or vector. <boolean> is
    either `#t` or `#f`, <number> is any number, <character> is any character, and
    <string> is any string. We have already seen examples of numbers, strings, lists,
    symbols, and booleans. See Chapter [6](objects.html#g106) or the formal syntax
    description starting on page [455](grammar.html#APPENDIXFORMALSYNTAX) for more
    on the object-level syntax of these and other objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 核心句法形式包括顶层`define`形式、常量、变量、过程应用、`quote`表达式、`lambda`表达式、`if`表达式和`set!`表达式。下面的语法描述了Scheme的核心语法，其中使用这些定义和表达式。在语法中，竖线（ | ）分隔备选项，跟随星号（ * ）的形式表示该形式的零个或多个出现。
    <variable> 是任何Scheme标识符。 <datum> 是任何Scheme对象，如数字、列表、符号或向量。 <boolean> 是`#t`或`#f`，<number>
    是任何数字，<character> 是任何字符，<string> 是任何字符串。我们已经看到了数字、字符串、列表、符号和布尔值的示例。请参阅第[6](objects.html#g106)章或从第[455](grammar.html#APPENDIXFORMALSYNTAX)页开始的正式语法描述，了解这些和其他对象的对象级语法更多信息。
- en: '| <program> | ![<graphic>](ch3_8.gif) | <form>* |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| <program> | ![<graphic>](ch3_8.gif) | <form>* |'
- en: '| <form> | ![<graphic>](ch3_8.gif) | <definition> &#124; <expression> |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| <form> | ![<graphic>](ch3_8.gif) | <definition> &#124; <expression> |'
- en: '| <definition> | ![<graphic>](ch3_8.gif) | <variable definition> &#124; `(begin`
    <definition>*`)` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| <definition> | ![<graphic>](ch3_8.gif) | <variable definition> &#124; `(begin`
    <definition>*`)` |'
- en: '| <variable definition> | ![<graphic>](ch3_8.gif) | `(define` <variable> <expression>`)`
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| <variable definition> | ![<graphic>](ch3_8.gif) | `(define` <variable> <expression>`)`
    |'
- en: '| <expression> | ![<graphic>](ch3_8.gif) | <constant> |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| <expression> | ![<graphic>](ch3_8.gif) | <constant> |'
- en: '|  | &#124; | <variable> |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124; | <variable> |'
- en: '|  | &#124; | `(quote` <datum>`)` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124; | `(quote` <datum>`)` |'
- en: '|  | &#124; | `(lambda` <formals> <expression> <expression>*`)` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124; | `(lambda` <formals> <expression> <expression>*`)` |'
- en: '|  | &#124; | `(if` <expression> <expression> <expression>`)` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124; | `(if` <expression> <expression> <expression>`)` |'
- en: '|  | &#124; | `(set!` <variable> <expression>`)` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124; | `(set!` <variable> <expression>`)` |'
- en: '|  | &#124; | <application> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124; | <application> |'
- en: '| <constant> | ![<graphic>](ch3_8.gif) | <boolean> &#124; <number> &#124; <character>
    &#124; <string> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <constant> | ![<graphic>](ch3_8.gif) | <boolean> &#124; <number> &#124; <character>
    &#124; <string> |'
- en: '| <formals> | ![<graphic>](ch3_8.gif) | <variable> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <formals> | ![<graphic>](ch3_8.gif) | <variable> |'
- en: '|  | &#124; | `(`<variable>*`)` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124; | `(`<variable>*`)` |'
- en: '|  | &#124; | `(`<variable> <variable>* `.` <variable>`)` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124; | `(`<variable> <variable>* `.` <variable>`)` |'
- en: '| <application> | ![<graphic>](ch3_8.gif) | `(`<expression> <expression>*`)`
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <application> | ![<graphic>](ch3_8.gif) | `(`<expression> <expression>*`)`
    |'
- en: The grammar is ambiguous in that the syntax for procedure applications conflicts
    with the syntaxes for `quote`, `lambda`, `if`, and `set!` expressions. In order
    to qualify as a procedure application, the first <expression> must not be one
    of these keywords, unless the keyword has been redefined or locally bound.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 语法存在歧义，因为过程应用的语法与`quote`、`lambda`、`if`和`set!`表达式的语法冲突。为了符合过程应用的条件，第一个<expression>不能是这些关键字之一，除非关键字已被重新定义或在本地绑定。
- en: The "defun" syntax for `define` given in Section [2.6](start.html#g25) is not
    included in the core, since definitions in that form are straightforwardly translated
    into the simpler `define` syntax. Similarly, the core syntax for `if` does not
    permit the `*alternative*` to be omitted, as did one example in Section [2.9](start.html#g40).
    An `if` expression lacking an `*alternative*` can be translated into the core
    syntax for `if` merely by replacing the missing subexpression with an arbitrary
    constant, such as `#f`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[2.6](start.html#g25)节中给出的`define`的"defun"语法不包含在核心中，因为以那种形式的定义可以直接转换为更简单的`define`语法。同样，`if`的核心语法不允许省略`*alternative*`，就像第[2.9](start.html#g40)节中的一个例子那样。缺少`*alternative*`的`if`表达式可以通过用任意常量（如`#f`）替换缺失的子表达式来简单地转换为`if`的核心语法。
- en: A `begin` that contains only definitions is considered to be a definition in
    the grammar; this is permitted in order to allow syntactic extensions to expand
    into more than one definition. `begin` expressions, i.e., `begin` forms containing
    expressions, are not considered core forms. A `begin` expression of the form
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 仅包含定义的`begin`被视为语法中的定义；这是为了允许语法扩展扩展为多个定义。即，包含表达式的`begin`形式不被视为核心形式。形如
- en: '`(begin *e[1]* *e[2]* ...)`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`(begin *e[1]* *e[2]* ...)`'
- en: is equivalent to the `lambda` application
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于`lambda`应用
- en: '`((lambda () *e[1]* *e[2]* ...))`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`((lambda () *e[1]* *e[2]* ...))`'
- en: and hence need not be considered core.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此不需要被视为核心。
- en: Now that we have established a set of core syntactic forms, let's turn to a
    discussion of syntactic extensions. Syntactic extensions are so called because
    they extend the syntax of Scheme beyond the core syntax. All syntactic extensions
    in a Scheme program must ultimately be derived from the core forms. One syntactic
    extension, however, may be defined in terms of another syntactic extension, as
    long as the latter is in some sense "closer" to the core syntax. Syntactic forms
    may appear anywhere an expression or definition is expected, as long as the extended
    form expands into a definition or expression as appropriate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一组核心语法形式，让我们转向讨论语法扩展。语法扩展之所以被称为语法扩展，是因为它们将Scheme的语法扩展到核心语法之外。Scheme程序中的所有语法扩展最终都必须源自核心形式。然而，一个语法扩展可以根据另一个语法扩展来定义，只要后者在某种意义上更接近核心语法。语法形式可以出现在期望表达式或定义的任何地方，只要扩展形式适当地扩展为定义或表达式即可。
- en: Syntactic extensions are defined with `define-syntax`. `define-syntax` is similar
    to `define`, except that `define-syntax` associates a syntactic transformation
    procedure, or *transformer*, with a keyword (such as `let`), rather than associating
    a value with a variable. Here is how we might define `let` with `define-syntax`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 语法扩展是用`define-syntax`定义的。`define-syntax`类似于`define`，不同之处在于`define-syntax`将一个语法转换过程或*转换器*与关键字（如`let`）关联起来，而不是将一个值与变量关联起来。以下是我们如何使用`define-syntax`定义`let`的方法。
- en: '`(define-syntax let'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax let'
- en: (syntax-rules ()
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ ((x e) ...) b1 b2 ...)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ((x e) ...) b1 b2 ...)'
- en: ((lambda (x ...) b1 b2 ...) e ...)]))`
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (x ...) b1 b2 ...) e ...)]))`
- en: The identifier appearing after `define-syntax` is the name, or keyword, of the
    syntactic extension being defined, in this case `let`. The `syntax-rules` form
    is an expression that evaluates to a transformer. The item following `syntax-rules`
    is a list of *auxiliary keywords* and is nearly always `()`. An example of an
    auxiliary keyword is the `else` of `cond`. (Other examples requiring the use of
    auxiliary keywords are given in Chapter [8](syntax.html#g133).) Following the
    list of auxiliary keywords is a sequence of one or more *rules*, or *pattern/template*
    pairs. Only one rule appears in our definition of `let`. The pattern part of a
    rule specifies the form that the input must take, and the template specifies to
    what the input should be transformed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`define-syntax`之后出现的标识符是正在定义的语法扩展的名称或关键字，在本例中是`let`。`syntax-rules`形式是一个求值为转换器的表达式。`syntax-rules`后面的项目是一个*辅助关键字*列表，几乎总是`()`。辅助关键字的一个示例是`cond`的`else`。（需要使用辅助关键字的其他示例在第[8](syntax.html#g133)章中给出。）在辅助关键字列表之后是一个或多个*规则*或*模式/模板*对的序列。在我们对`let`的定义中只出现了一个规则。规则的模式部分指定输入必须采取的形式，模板指定输入应该转换为什么。
- en: The pattern should always be a structured expression whose first element is
    an underscore ( `_` ). (As we will see in Chapter [8](syntax.html#g133), the use
    of `_` is only a convention, but it is a good one to follow.) If more than one
    rule is present, the appropriate one is chosen by matching the patterns, in order,
    against the input during expansion. It is a syntax violation if none of the patterns
    match the input.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模式应始终是一个结构化表达式，其第一个元素是下划线（`_`）。 （正如我们将在第[8](syntax.html#g133)章中看到的，使用`_`仅仅是一种约定，但这是一个很好的遵循。）如果存在多个规则，则在扩展期间，按顺序匹配模式以选择适当的规则。如果没有任何模式与输入匹配，则属于语法违规。
- en: Identifiers other than an underscore or ellipsis appearing within a pattern
    are *pattern variables*, unless they are listed as auxiliary keywords. Pattern
    variables match any substructure and are bound to that substructure within the
    corresponding template. The notation `*pat* ...` in the pattern allows for zero
    or more expressions matching the ellipsis prototype `*pat*` in the input. Similarly,
    the notation `*expr* ...` in the template produces zero or more expressions from
    the ellipsis prototype `*expr*` in the output. The number of `*pat*`s in the input
    determines the number of `*expr*`s in the output; in order for this to work, any
    ellipsis prototype in the template must contain at least one pattern variable
    from an ellipsis prototype in the pattern.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式中出现的下划线或省略号之外的标识符是*模式变量*，除非它们被列为辅助关键字。模式变量匹配任何子结构，并在相应模板中绑定到该子结构。模式中的`*pat* ...`符号允许零个或多个与输入中省略号原型`*pat*`匹配的表达式。类似地，模板中的`*expr* ...`符号从输出中产生零个或多个与省略号原型`*expr*`匹配的表达式。输入中`*pat*`的数量决定输出中`*expr*`的数量；为了使其工作，模板中的任何省略号原型必须至少包含一个来自模式中省略号原型的模式变量。
- en: The single rule in our definition of `let` should be fairly self-explanatory,
    but a few points are worth mentioning. First, the syntax of `let` requires that
    the body contain at least one form; hence, we have specified `b1 b2 ...` instead
    of `b ...`, which might seem more natural. On the other hand, `let` does not require
    that there be at least one variable/value pair, so we were able to use, simply,
    `(x e) ...`. Second, the pattern variables `x` and `e`, though together within
    the same prototype in the pattern, are separated in the template; any sort of
    rearrangement or recombination is possible. Finally, the three pattern variables
    `x`, `e`, and `b2` that appear in ellipsis prototypes in the pattern also appear
    in ellipsis prototypes in the template. This is not a coincidence; it is a requirement.
    In general, if a pattern variable appears within an ellipsis prototype in the
    pattern, it cannot appear outside an ellipsis prototype in the template.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `let` 定义中的单个规则应该是相当不言自明的，但值得一提的是一些要点。首先，`let` 的语法要求体至少包含一个形式；因此，我们指定了 `b1 b2 ...`
    而不是 `b ...`，这可能看起来更自然。另一方面，`let` 不要求至少有一个变量/值对，因此我们能够简单地使用 `(x e) ...`。其次，在模式中一起的模式变量
    `x` 和 `e` 在模板中是分开的；任何形式的重新排列或重组都是可能的。最后，在模式中的省略原型中出现的三个模式变量 `x`、`e` 和 `b2` 也出现在模板中的省略原型中。这不是巧合；这是一个要求。一般来说，如果一个模式变量在模式中的省略原型中出现，它就不能在模板中的省略原型之外出现。
- en: The definition of `and` below is somewhat more complex than the one for `let`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `and` 的定义比 `let` 的定义稍微复杂一些。
- en: '`(define-syntax and'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义语法 和'
- en: (syntax-rules ()
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: (语法规则 ()
- en: '[(_) #t]'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_) #t]'
- en: '[(_ e) e]'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e) e]'
- en: '[(_ e1 e2 e3 ...)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 e3 ...)'
- en: (if e1 (and e2 e3 ...) #f)]))`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 e1 (和 e2 e3 ...) #f)]))
- en: This definition is recursive and involves more than one rule. Recall that `(and)`
    evaluates to `#t`; the first rule takes care of this case. The second and third
    rules specify the base case and recursion steps of the recursion and together
    translate `and` expressions with two or more subexpressions into nested `if` expressions.
    For example, `(and a b c)` expands first into
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义是递归的，涉及多个规则。记住 `(和)` 的值为 `#t`；第一个规则处理这种情况。第二和第三个规则指定了递归的基本情况和递归步骤，并一起将具有两个或更多子表达式的
    `and` 表达式转换为嵌套的 `if` 表达式。例如，`(和 a b c)` 首先扩展为
- en: '`(if a (and b c) #f)`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`(如果 a (和 b c) #f)`'
- en: then
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: '`(if a (if b (and c) #f) #f)`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`(如果 a (如果 b (和 c) #f) #f)`'
- en: and finally
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后
- en: '`(if a (if b c #f) #f)`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`(如果 a (如果 b c #f) #f)`'
- en: With this expansion, if `a` and `b` evaluate to a true value, then the value
    is the value of `c`, otherwise `#f`, as desired.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种扩展，如果 `a` 和 `b` 的值为真，则值为 `c`，否则为 `#f`，如所需。
- en: The version of `and` below is simpler but, unfortunately, incorrect.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `and` 版本更简单，但不幸的是，是错误的。
- en: '`(define-syntax and ; incorrect!'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义语法 和 ; 不正确！'
- en: (syntax-rules ()
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: (语法规则 ()
- en: '[(_) #t]'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_) #t]'
- en: '[(_ e1 e2 ...)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 ...)'
- en: (if e1 (and e2 ...) #f)]))`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 e1 (和 e2 ...) #f)]))
- en: The expression
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式
- en: '`(and (not (= x 0)) (/ 1 x))`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`(和 (非 (= x 0)) (/ 1 x))`'
- en: should return the value of `(/ 1 x)` when `x` is not zero. With the incorrect
    version of `and`, the expression expands as follows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `x` 不为零时应返回 `(/ 1 x)` 的值。使用不正确版本的 `and`，表达式扩展如下。
- en: '`(if (not (= x 0)) (and (/ 1 x)) #f) ![<graphic>](ch3_9.gif)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`(如果 (非 (= x 0)) (和 (/ 1 x)) #f) ![<graphic>](ch3_9.gif)'
- en: (if (not (= x 0)) (if (/ 1 x) (and) #f) #f) ![<graphic>](ch3_9.gif)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (非 (= x 0)) (如果 (/ 1 x) (和) #f) #f) ![<graphic>](ch3_9.gif)
- en: (if (not (= x 0)) (if (/ 1 x) #t #f) #f)`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (非 (= x 0)) (如果 (/ 1 x) #t #f) #f)`
- en: The final answer if `x` is not zero is `#t`, not the value of `(/ 1 x)`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 不为零，则最终答案是 `#t`，而不是 `(/ 1 x)` 的值。
- en: The definition of `or` below is similar to the one for `and` except that a temporary
    variable must be introduced for each intermediate value so that we can both test
    the value and return it if it is a true value. (A temporary variable is not needed
    for `and` since there is only one false value, `#f`.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `or` 的定义与 `and` 的定义类似，只是必须为每个中间值引入一个临时变量，以便我们既可以测试值又可以返回它，如果它是一个真值的话。（对于
    `and`，不需要临时变量，因为只有一个假值，`#f`。）
- en: '`(define-syntax or'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义语法 或'
- en: (syntax-rules ()
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: (语法规则 ()
- en: '[(_) #f]'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_) #f]'
- en: '[(_ e) e]'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e) e]'
- en: '[(_ e1 e2 e3 ...)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 e3 ...)'
- en: (let ([t e1])
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([t e1])
- en: (if t t (or e2 e3 ...)))]))`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`(如果 t t (或 e2 e3 ...)))]))`'
- en: Like variables bound by `lambda` or `let`, identifiers introduced by a template
    are lexically scoped, i.e., visible only within expressions introduced by the
    template. Thus, even if one of the expressions `e2 e3 ...` contains a reference
    to `t`, the introduced binding for `t` does not "capture" those references. This
    is typically accomplished via automatic renaming of introduced identifiers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 像由`lambda`或`let`绑定的变量一样，由模板引入的标识符是词法作用域的，即仅在模板引入的表达式中可见。因此，即使`e2 e3 ...`中的一个表达式包含对`t`的引用，对`t`的引入绑定也不会"捕获"这些引用。这通常通过引入标识符的自动重命名来实现。
- en: As with the simpler version of `and` given above, the simpler version of `or`
    below is incorrect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上面给出的`and`的简化版本一样，下面给出的`or`的简化版本是不正确的。
- en: '`(define-syntax or ; incorrect!'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax or ; incorrect!'
- en: (syntax-rules ()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_) #f]'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_) #f]'
- en: '[(_ e1 e2 ...)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 ...)'
- en: (let ([t e1])
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([t e1])
- en: (if t t (or e2 ...)))]))`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (if t t (or e2 ...)))]))`
- en: The reason is more subtle, however, and is the subject of Exercise [3.2.6](further.html#g61).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，原因更加微妙，这是练习[3.2.6](further.html#g61)的主题。
- en: Exercise 3.1.1
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Exercise 3.1.1
- en: Write out the expansion steps necessary to expand
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 写出扩展步骤，以展开
- en: '`(let ([x (memv ''a ls)])'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x (memv ''a ls)])'
- en: (and x (memv 'b x)))`
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: (and x (memv 'b x)))`
- en: into core forms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为核心形式。
- en: Exercise 3.1.2
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Exercise 3.1.2
- en: Write out the expansion steps necessary to expand
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 写出扩展步骤，以展开
- en: '`(or (memv x ''(a b c)) (list x))`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`(or (memv x ''(a b c)) (list x))`'
- en: into core forms.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为核心形式。
- en: Exercise 3.1.3
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Exercise 3.1.3
- en: '`let*` is similar to `let` but evaluates its bindings in sequence. Each of
    the right-hand-side expressions is within the scope of the earlier bindings.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`let*`类似于`let`，但按顺序评估其绑定。每个右侧表达式都在先前绑定的范围内。'
- en: '`(let* ([a 5] [b (+ a a)] [c (+ a b)])'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let* ([a 5] [b (+ a a)] [c (+ a b)])'
- en: (list a b c)) ![<graphic>](ch3_0.gif) (5 10 15)`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: (list a b c)) ![<graphic>](ch3_0.gif) (5 10 15)`
- en: '`let*` can be implemented as nested `let` expressions. For example, the `let*`
    expression above is equivalent to the nested `let` expressions below.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`let*`可以被实现为嵌套的`let`表达式。例如，上面的`let*`表达式等同于下面的嵌套`let`表达式。'
- en: '`(let ([a 5])'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([a 5])'
- en: (let ([b (+ a a)])
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([b (+ a a)])
- en: (let ([c (+ a b)])
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([c (+ a b)])
- en: (list a b c)))) ![<graphic>](ch3_0.gif) (5 10 15)`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (list a b c)))) ![<graphic>](ch3_0.gif) (5 10 15)`
- en: Define `let*` with `define-syntax`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`define-syntax`定义`let*`。
- en: Exercise 3.1.4
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Exercise 3.1.4
- en: As we saw in Section [2.9](start.html#g40), it is legal to omit the third, or
    *alternative*, subexpression of an `if` expression. Doing so, however, often leads
    to confusion. Scheme provides two syntactic forms, `when` and `unless`, that may
    be used in place of such "one-armed" `if` expressions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第[2.9](start.html#g40)节中看到的，省略`if`表达式的第三个或*替代*子表达式是合法的。然而，这样做通常会导致混淆。Scheme提供了两种语法形式，`when`和`unless`，可以用来替代这种"单臂"的`if`表达式。
- en: '`(when *test* *expr[1]* *expr[2]* ...)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`(when *test* *expr[1]* *expr[2]*...)'
- en: (unless *test* *expr[1]* *expr[2]* ...)`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (unless *test* *expr[1]* *expr[2]* ...)`
- en: With both forms, `test` is evaluated first. For `when`, if `test` evaluates
    to true, the remaining forms are evaluated in sequence as if enclosed in an implicit
    `begin` expression. If `test` evaluates to false, the remaining forms are not
    evaluated, and the result is unspecified. `unless` is similar except that the
    remaining forms are evaluated only if `test` evaluates to false.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种形式，首先评估`test`。对于`when`，如果`test`评估为真，则剩余的表达式按顺序评估，就好像被包含在隐式的`begin`表达式中一样。如果`test`评估为假，则不评估剩余的表达式，结果是未指定的。`unless`类似，只有当`test`评估为假时才评估剩余的表达式。
- en: '`(let ([x 3])'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 3])'
- en: (unless (= x 0) (set! x (+ x 1)))
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (unless (= x 0) (set! x (+ x 1)))
- en: (when (= x 4) (set! x (* x 2)))
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (when (= x 4) (set! x (* x 2)))
- en: x) ![<graphic>](ch3_0.gif) 8`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: x) ![<graphic>](ch3_0.gif) 8`
- en: Define `when` as a syntactic extension in terms of `if` and `begin`, and define
    `unless` in terms of `when`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以`if`和`begin`为基础定义`when`作为语法扩展，并以`when`为基础定义`unless`。
- en: Section 3.2\. More Recursion
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3.2节。更多递归
- en: In Section [2.8](start.html#g32), we saw how to define recursive procedures
    using top-level definitions. Before that, we saw how to create local bindings
    for procedures using `let`. It is natural to wonder whether a `let`-bound procedure
    can be recursive. The answer is no, at least not in a straightforward way. If
    you try to evaluate the expression
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[2.8](start.html#g32)节中，我们看到如何使用顶层定义来定义递归过程。在此之前，我们看到如何使用`let`为过程创建局部绑定。自然而然地会想知道`let`绑定的过程是否可以是递归的。答案是否定的，至少不是直接的方式。如果尝试评估表达式
- en: '`(let ([sum (lambda (ls)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([sum (lambda (ls)'
- en: (if (null? ls)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '0'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (+ (car ls) (sum (cdr ls)))))])
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (car ls) (sum (cdr ls)))))])
- en: (sum '(1 2 3 4 5)))`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (sum '(1 2 3 4 5)))`
- en: it will probably raise an exception with a message to the effect that `sum`
    is undefined. This is because the variable `sum` is visible only within the body
    of the `let` expression and not within the `lambda` expression whose value is
    bound to `sum`. We can get around this problem by passing the procedure `sum`
    to itself as follows.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会引发异常，并显示`sum`未定义的消息。这是因为变量`sum`仅在`let`表达式的主体中可见，而不在其值绑定到`sum`的`lambda`表达式中可见。我们可以通过将过程`sum`传递给自身来解决这个问题。
- en: '`(let ([sum (lambda (sum ls)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([sum (lambda (sum ls)'
- en: (if (null? ls)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '0'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (+ (car ls) (sum sum (cdr ls)))))])
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (car ls) (sum sum (cdr ls)))))])
- en: (sum sum '(1 2 3 4 5))) ![<graphic>](ch3_0.gif) 15`
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (sum sum '(1 2 3 4 5))) ![<graphic>](ch3_0.gif) 15`
- en: This works and is a clever solution, but there is an easier way, using `letrec`.
    Like `let`, the `letrec` syntactic form includes a set of variable-value pairs,
    along with a sequence of expressions referred to as the *body* of the `letrec`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效且聪明，但有一种更简单的方法，使用`letrec`。像`let`一样，`letrec`语法形式包括一组变量-值对，以及一系列被称为`letrec`的*body*表达式。
- en: '`(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: Unlike `let`, the variables `*var* ...` are visible not only within the body
    of the `letrec` but also within `*expr* ...`. Thus, we can rewrite the expression
    above as follows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与`let`不同，变量`*var* ...`不仅在`letrec`的主体中可见，而且在`*expr* ...`中也可见。因此，我们可以将上面的表达式重写如下。
- en: '`(letrec ([sum (lambda (ls)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ([sum (lambda (ls)'
- en: (if (null? ls)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '0'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (+ (car ls) (sum (cdr ls)))))])
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (car ls) (sum (cdr ls)))))])
- en: (sum '(1 2 3 4 5))) ![<graphic>](ch3_0.gif) 15`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (sum '(1 2 3 4 5))) ![<graphic>](ch3_0.gif) 15`
- en: Using `letrec`, we can also define mutually recursive procedures, such as the
    procedures `even?` and `odd?` that were the subject of Exercise [2.8.6](start.html#g38).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`letrec`，我们还可以定义相互递归的过程，比如练习[2.8.6](start.html#g38)中讨论的`even?`和`odd?`过程。
- en: '`(letrec ([even?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ([even?'
- en: (lambda (x)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (or (= x 0)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: (or (= x 0)
- en: (odd? (- x 1))))]
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: (odd? (- x 1))))]
- en: '[odd?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[odd?'
- en: (lambda (x)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (and (not (= x 0))
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (= x 0))
- en: (even? (- x 1))))])
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: (even? (- x 1))))])
- en: (list (even? 20) (odd? 20))) ![<graphic>](ch3_0.gif) (#t #f)`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: (list (even? 20) (odd? 20))) ![<graphic>](ch3_0.gif) (#t #f)`
- en: In a `letrec` expression, `*expr* ...` are most often `lambda` expressions,
    though this need not be the case. One restriction on the expressions must be obeyed,
    however. It must be possible to evaluate each `*expr*` without evaluating any
    of the variables `*var* ...`. This restriction is always satisfied if the expressions
    are all `lambda` expressions, since even though the variables may appear within
    the `lambda` expressions, they cannot be evaluated until the resulting procedures
    are invoked in the body of the `letrec`. The following `letrec` expression obeys
    this restriction.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`letrec`表达式中，`*expr* ...`通常是`lambda`表达式，尽管这不一定是必须的。然而，对表达式的一个限制必须遵守。必须能够在不评估任何变量`*var* ...`的情况下评估每个`*expr*`。然而，如果表达式都是`lambda`表达式，这个限制总是满足的，因为即使变量可能出现在`lambda`表达式中，也不能在`letrec`的主体中调用结果过程之前对其进行评估。以下`letrec`表达式遵守了这个限制。
- en: '`(letrec ([f (lambda () (+ x 2))]'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ([f (lambda () (+ x 2))]'
- en: '[x 1])'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[x 1])'
- en: (f)) ![<graphic>](ch3_0.gif) 3`
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: (f)) ![<graphic>](ch3_0.gif) 3`
- en: while the following does not.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 而以下则不会。
- en: '`(letrec ([y (+ x 2)]'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ([y (+ x 2)]`'
- en: '[x 1])'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[x 1])'
- en: y)`
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: y)`
- en: In this case, an exception is raised indicating that `x` is not defined where
    it is referenced.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，引发异常，指示在引用时未定义`x`。
- en: We can use `letrec` to hide the definitions of "help" procedures so that they
    do not clutter the top-level namespace. This is demonstrated by the definition
    of `list?` below, which follows the "hare and tortoise" algorithm outlined in
    Exercise [2.9.8](start.html#g48).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`letrec`来隐藏“帮助”程序的定义，以便它们不会混乱顶层命名空间。下面的`list?`定义演示了这一点，它遵循了练习[2.9.8](start.html#g48)中概述的“乌龟和兔子”算法。
- en: '`(define list?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define list?'
- en: (lambda (x)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (letrec ([race
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (letrec ([race
- en: (lambda (h t)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (h t)
- en: (if (pair? h)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (if (pair? h)
- en: (let ([h (cdr h)])
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([h (cdr h)])
- en: (if (pair? h)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (if (pair? h)
- en: (and (not (eq? h t))
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (eq? h t))
- en: (race (cdr h) (cdr t)))
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (race (cdr h) (cdr t)))
- en: (null? h)))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (null? h)))
- en: (null? h)))])
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (null? h)))])
- en: (race x x))))`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (race x x))))`
- en: When a recursive procedure is called in only one place outside the procedure,
    as in the example above, it is often clearer to use a *named* `let` expression.
    Named `let` expressions take the following form.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当递归过程仅在过程外的一个地方调用时，通常更清晰的做法是使用*命名*`let`表达式。命名的`let`表达式采用以下形式。
- en: '`(let *name* ((*var* *expr*) ...)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let *name* ((*var* *expr*) ...)'
- en: '*body[1]* *body[2]* ...)`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*body[1]* *body[2]* ...)`'
- en: Named `let` is similar to unnamed `let` in that it binds the variables `*var* ...`
    to the values of `*expr* ...` within the body `*body[1]* *body[2]* ...`. As with
    unnamed `let`, the variables are visible only within the body and not within `*expr* ...`.
    In addition, the variable `*name*` is bound within the body to a procedure that
    may be called to recur; the arguments to the procedure become the new values for
    the variables `*var* ...`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`let`的形式与未命名的`let`类似，它将变量`*var* ...`绑定到`*expr* ...`的值，并在`*body[1]* *body[2]* ...`中使用。与未命名的`let`一样，这些变量仅在body中可见，而不在`*expr* ...`中可见。此外，变量`*name*`在body中绑定到一个可调用的过程，可以用于递归调用；过程的参数成为变量`*var* ...`的新值。
- en: The definition of `list?` has been rewritten below to use named `let`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`list?`的定义已经被重写为使用命名为`let`。'
- en: '`(define list?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define list?'
- en: (lambda (x)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ( x )
- en: (let race ([h x] [t x])
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: (let race ([h x] [t x])
- en: (if (pair? h)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (if (pair? h)
- en: (let ([h (cdr h)])
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([h (cdr h)])
- en: (if (pair? h)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: (if (pair? h)
- en: (and (not (eq? h t))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (eq? h t))
- en: (race (cdr h) (cdr t)))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: (race (cdr h) (cdr t)))
- en: (null? h)))
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: (null? h)))
- en: (null? h)))))`
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: (null? h)))))`
- en: Just as `let` can be expressed as a simple direct application of a `lambda`
    expression to arguments, named `let` can be expressed as the application of a
    recursive procedure to arguments. A named `let` of the form
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`let`可以表示为将`lambda`表达式直接应用于参数一样，命名为`let`可以表示为将递归过程应用于参数。形式为
- en: '`(let *name* ((*var* *expr*) ...)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let *name* ((*var* *expr*) ...)'
- en: '*body[1]* *body[2]* ...)`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*body[1]* *body[2]* ...)`'
- en: can be rewritten in terms of `letrec` as follows.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式用`letrec`重写。
- en: '`((letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`((letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
- en: '*name*)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*name*)'
- en: '*expr* ...)`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*expr* ...)`'
- en: Alternatively, it can be rewritten as
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以重写为
- en: '`(letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
- en: (*name* *expr* ...))`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: (*name* *expr* ...))`
- en: provided that the variable `*name*` does not appear free within `*expr* ...`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设变量`*name*`在`*expr* ...`中不是自由的。
- en: As we discussed in Section [2.8](start.html#g32), some recursion is essentially
    iteration and executes as such. When a procedure call is in tail position (see
    below) with respect to a `lambda` expression, it is considered to be a *tail call*,
    and Scheme systems must treat it *properly*, as a "goto" or jump. When a procedure
    tail-calls itself or calls itself indirectly through a series of tail calls, the
    result is *tail recursion*. Because tail calls are treated as jumps, tail recursion
    can be used for indefinite iteration in place of the more restrictive iteration
    constructs provided by other programming languages, without fear of overflowing
    any sort of recursion stack.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第[2.8](start.html#g32)节中讨论的，一些递归本质上是迭代并且执行为迭代。当一个过程调用在相对于`lambda`表达式的尾部位置时（见下文），它被认为是*尾调用*，并且Scheme系统必须将其*正确*处理，作为"goto"或跳转。当一个过程尾调用自身或通过一系列尾调用间接调用自身时，结果是*尾递归*。由于尾调用被视为跳转，尾递归可以用于无限迭代，取代其他编程语言提供的更为限制的迭代构造，而无需担心溢出任何递归堆栈。
- en: A call is in tail position with respect to a `lambda` expression if its value
    is returned directly from the `lambda` expression, i.e., if nothing is left to
    do after the call but to return from the `lambda` expression. For example, a call
    is in tail position if it is the last expression in the body of a `lambda` expression,
    the *consequent* or *alternative* part of an `if` expression in tail position,
    the last subexpression of an `and` or `or` expression in tail position, the last
    expression in the body of a `let` or `letrec` in tail position, etc. Each of the
    calls to `f` in the expressions below are tail calls, but the calls to `g` are
    not.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个调用在相对于`lambda`表达式的尾部位置，那么它的值将直接从`lambda`表达式返回，即，如果在调用之后没有其他操作，只需从`lambda`表达式返回。例如，如果一个调用是`lambda`表达式体中的最后一个表达式，`if`表达式中的*consequent*或*alternative*部分处于尾部位置，`and`或`or`表达式的最后一个子表达式处于尾部位置，`let`或`letrec`体中的最后一个表达式处于尾部位置等，则该调用处于尾部位置。下面表达式中对`f`的每次调用都是尾调用，但对`g`的调用则不是。
- en: '`(lambda () (f (g)))'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda () (f (g)))'
- en: (lambda () (if (g) (f) (f)))
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (if (g) (f) (f)))
- en: (lambda () (let ([x 4]) (f)))
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (let ([x 4]) (f)))
- en: (lambda () (or (g) (f)))`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (or (g) (f)))`
- en: In each case, the values of the calls to `f` are returned directly, whereas
    the calls to `g` are not.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，对`f`的调用的值直接返回，而对`g`的调用则不会。
- en: Recursion in general and named `let` in particular provide a natural way to
    implement many algorithms, whether iterative, recursive, or partly iterative and
    partly recursive; the programmer is not burdened with two distinct mechanisms.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一般递归和特别是命名的`let`提供了一种自然的方式来实现许多算法，无论是迭代的、递归的还是部分迭代部分递归的；程序员不必负担两种不同的机制。
- en: The following two definitions of `factorial` use named `let` expressions to
    compute the factorial, *n*!, of a nonnegative integer *n*. The first employs the
    recursive definition *n*! = *n* × (*n* - 1)!, where 0! is defined to be 1.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下面两个关于`factorial`的定义使用了命名的`let`表达式来计算非负整数*n*的阶乘，*n*!。第一个采用了递归定义*n*! = *n* ×
    (*n* - 1)!，其中0!定义为1。
- en: '`(define factorial'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define factorial'
- en: (lambda (n)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (let fact ([i n])
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (let fact ([i n])
- en: (if (= i 0)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= i 0)
- en: '1'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: (* i (fact (- i 1)))))))`
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: (* i (fact (- i 1)))))))`
- en: '`(factorial 0) ![<graphic>](ch3_0.gif) 1'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`(factorial 0) ![<graphic>](ch3_0.gif) 1'
- en: (factorial 1) ![<graphic>](ch3_0.gif) 1
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: (factorial 1) ![<graphic>](ch3_0.gif) 1
- en: (factorial 2) ![<graphic>](ch3_0.gif) 2
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: (factorial 2) ![<graphic>](ch3_0.gif) 2
- en: (factorial 3) ![<graphic>](ch3_0.gif) 6
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: (factorial 3) ![<graphic>](ch3_0.gif) 6
- en: (factorial 10) ![<graphic>](ch3_0.gif) 3628800`
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: (factorial 10) ![<graphic>](ch3_0.gif) 3628800`
- en: The second is an iterative version that employs the iterative definition *n*!
    = *n* × (*n* - 1) × (*n* - 2) × ... × 1, using an accumulator, `a`, to hold the
    intermediate products.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是一个迭代版本，使用迭代定义*n*! = *n* × (*n* - 1) × (*n* - 2) × ... × 1，使用一个累加器`a`来保存中间乘积。
- en: '`(define factorial'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define factorial'
- en: (lambda (n)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (let fact ([i n] [a 1])
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: (let fact ([i n] [a 1])
- en: (if (= i 0)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= i 0)
- en: a
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: (fact (- i 1) (* a i))))))`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (fact (- i 1) (* a i))))))`
- en: A similar problem is to compute the *n*th Fibonacci number for a given *n*.
    The *Fibonacci numbers* are an infinite sequence of integers, 0, 1, 1, 2, 3, 5,
    8, etc., in which each number is the sum of the two preceding numbers in the sequence.
    A procedure to compute the *n*th Fibonacci number is most naturally defined recursively
    as follows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 计算给定*n*的第*n*个斐波那契数的类似问题。*斐波那契数*是一个无限整数序列，0, 1, 1, 2, 3, 5, 8等，其中每个数字是序列中前两个数字的和。计算第*n*个斐波那契数的过程最自然地递归定义如下。
- en: '`(define fibonacci'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define fibonacci'
- en: (lambda (n)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (let fib ([i n])
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: (let fib ([i n])
- en: (cond
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(= i 0) 0]'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[(= i 0) 0]'
- en: '[(= i 1) 1]'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[(= i 1) 1]'
- en: '[else (+ (fib (- i 1)) (fib (- i 2)))]))))'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (+ (fib (- i 1)) (fib (- i 2)))]))))'
- en: (fibonacci 0) ![<graphic>](ch3_0.gif) 0
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 0) ![<graphic>](ch3_0.gif) 0
- en: (fibonacci 1) ![<graphic>](ch3_0.gif) 1
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 1) ![<graphic>](ch3_0.gif) 1
- en: (fibonacci 2) ![<graphic>](ch3_0.gif) 1
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 2) ![<graphic>](ch3_0.gif) 1
- en: (fibonacci 3) ![<graphic>](ch3_0.gif) 2
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 3) ![<graphic>](ch3_0.gif) 2
- en: (fibonacci 4) ![<graphic>](ch3_0.gif) 3
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 4) ![<graphic>](ch3_0.gif) 3
- en: (fibonacci 5) ![<graphic>](ch3_0.gif) 5
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 5) ![<graphic>](ch3_0.gif) 5
- en: (fibonacci 6) ![<graphic>](ch3_0.gif) 8
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 6) ![<graphic>](ch3_0.gif) 8
- en: (fibonacci 20) ![<graphic>](ch3_0.gif) 6765
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 20) ![<graphic>](ch3_0.gif) 6765
- en: (fibonacci 30) ![<graphic>](ch3_0.gif) 832040`
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 30) ![<graphic>](ch3_0.gif) 832040`
- en: This solution requires the computation of the two preceding Fibonacci numbers
    at each step and hence is *doubly recursive*. For example, to compute `(fibonacci 4)`
    requires the computation of both `(fib 3)` and `(fib 2)`, to compute `(fib 3)`
    requires computing both `(fib 2)` and `(fib 1)`, and to compute `(fib 2)` requires
    computing both `(fib 1)` and `(fib 0)`. This is very inefficient, and it becomes
    more inefficient as `n` grows. A more efficient solution is to adapt the accumulator
    solution of the `factorial` example above to use two accumulators, `a1` for the
    current Fibonacci number and `a2` for the preceding one.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案在每一步都需要计算前两个斐波那契数，因此是*双重递归*的。例如，计算`(fibonacci 4)`需要计算`(fib 3)`和`(fib 2)`，计算`(fib 3)`需要计算`(fib 2)`和`(fib 1)`，计算`(fib 2)`需要计算`(fib 1)`和`(fib 0)`。这是非常低效的，并且随着`n`的增长而变得更加低效。一个更有效的解决方案是改编上面`factorial`示例的累加器解决方案，使用两个累加器，`a1`用于当前斐波那契数，`a2`用于前一个。
- en: '`(define fibonacci'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define fibonacci'
- en: (lambda (n)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (= n 0)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0)
- en: '0'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: (let fib ([i n] [a1 1] [a2 0])
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: (let fib ([i n] [a1 1] [a2 0])
- en: (if (= i 1)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= i 1)
- en: a1
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: a1
- en: (fib (- i 1) (+ a1 a2) a1))))))`
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (fib (- i 1) (+ a1 a2) a1))))))`
- en: Here, zero is treated as a special case, since there is no preceding value.
    This allows us to use the single base case `(= i 1)`. The time it takes to compute
    the *n*th Fibonacci number using this iterative solution grows linearly with *n*,
    which makes a significant difference when compared to the doubly recursive version.
    To get a feel for the difference, try computing `(fibonacci 35)` and `(fibonacci 40)`
    using both definitions to see how long each takes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: We can also get a feel for the difference by looking at a trace for each on
    small inputs. The first trace below shows the calls to `fib` in the non-tail-recursive
    version of `fibonacci`, with input 5.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`|(fib 5)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '| (fib 4)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '| |(fib 3)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 2)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(fib 1)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '| | |1'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(fib 0)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '| | |0'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 1)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '| |2'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '| |(fib 2)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 1)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 0)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '| | 0'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '| |1'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '| 3'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '| (fib 3)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '| |(fib 2)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 1)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '| | (fib 0)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '| | 0'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '| |1'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '| |(fib 1)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '| |1'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '| 2'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '|5`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Notice how there are several calls to `fib` with arguments 2, 1, and 0. The
    second trace shows the calls to `fib` in the tail-recursive version, again with
    input 5.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '`|(fib 5 1 0)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '|(fib 4 1 1)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '|(fib 3 2 1)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '|(fib 2 3 2)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '|(fib 1 5 3)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '|5`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, there is quite a difference.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The named `let` examples shown so far are either tail-recursive or not tail-recursive.
    It often happens that one recursive call within the same expression is tail-recursive
    while another is not. The definition of `factor` below computes the prime factors
    of its nonnegative integer argument. The first call to `f` is not tail-recursive,
    but the second one is.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factor'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([n n] [i 2])
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[(>= i n) (list n)]'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[(integer? (/ n i))'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: (cons i (f (/ n i) i))]
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[else (f n (+ i 1))]))))'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: (factor 0) ![<graphic>](ch3_0.gif) (0)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: (factor 1) ![<graphic>](ch3_0.gif) (1)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: (factor 12) ![<graphic>](ch3_0.gif) (2 2 3)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: (factor 3628800) ![<graphic>](ch3_0.gif) (2 2 2 2 2 2 2 2 3 3 3 3 5 5 7)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: (factor 9239) ![<graphic>](ch3_0.gif) (9239)`
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: A trace of the calls to `f`, produced in Chez Scheme by replacing `let` with
    `trace-let`, in the evaluation of `(factor 120)` below highlights the difference
    between the nontail calls and the tail calls.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`|(f 120 2)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '| (f 60 2)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '| |(f 30 2)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '| | (f 15 2)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '| | (f 15 3)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(f 5 3)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(f 5 4)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(f 5 5)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(5)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '| | (3 5)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '| |(2 3 5)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '| (2 2 3 5)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '|(2 2 2 3 5)`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: A nontail call to `f` is shown indented relative to its caller, since the caller
    is still active, whereas tail calls appear at the same level of indentation.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.1
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Which of the recursive procedures defined in Section [3.2](further.html#g55)
    are tail-recursive, and which are not?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.2
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite `factor` using `letrec` to bind `f` in place of named `let`. Which version
    do you prefer?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.3
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Can the `letrec` expression below be rewritten using named `let`? If not, why
    not? If so, do it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([even?'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: (or (= x 0)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: (odd? (- x 1))))]
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[odd?'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= x 0))
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: (even? (- x 1))))])
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: (even? 20))`
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2.4
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite both definitions of `fibonacci` given in this section to count the number
    of recursive calls to `fib`, using a counter similar to the one used in the `cons-count`
    example of Section [2.9](start.html#g40). Count the number of recursive calls
    made in each case for several input values. What do you notice?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写本节中给出的 `fibonacci` 的两个定义，以计算对 `fib` 的递归调用次��，使用类似于第 [2.9](start.html#g40)
    节中 `cons-count` 示例中使用的计数器。对几个输入值分别计算每种情况下进行的递归调用次数。您注意到了什么？
- en: Exercise 3.2.5
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.2.5
- en: Augment the definition of `let` given in Section [3.1](further.html#g50) to
    handle named `let` as well as unnamed `let`, using two rules.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 增强第 [3.1](further.html#g50) 节中给出的 `let` 的定义，以处理命名 `let` 和未命名 `let`，使用两个规则。
- en: Exercise 3.2.6
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.2.6
- en: The following definition of `or` is simpler than the one given in Section [3.1](further.html#g50).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`or` 的以下定义比第 [3.1](further.html#g50) 节中给出的更简单。'
- en: '`(define-syntax or ; incorrect!'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax or ; incorrect!'
- en: (syntax-rules ()
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_) #f]'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_) #f]'
- en: '[(_ e1 e2 ...)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 ...)'
- en: (let ([t e1])
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([t e1])
- en: (if t t (or e2 ...)))]))`
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`(if t t (or e2 ...)))]))`'
- en: 'Say why it is not correct. [*Hint*: Think about what would happen if this version
    of `or` were used in the `even?` and `odd?` example given on page [66](further.html#defn:even?/odd?)
    for very large inputs.]'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 说明为什么这不正确。[*提示*：考虑如果此版本的 `or` 用于第 [66](further.html#defn:even?/odd?) 页上给出的 `even?`
    和 `odd?` 示例中非常大的输入会发生什么。]
- en: Exercise 3.2.7
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.2.7
- en: The definition of `factor` is not the most efficient possible. First, no factors
    of *n* besides *n* itself can possibly be found beyond ![<graphic>](ch3_10.gif).
    Second, the division `(/ n i)` is performed twice when a factor is found. Third,
    after 2, no even factors can possibly be found. Recode `factor` to correct all
    three problems. Which is the most important problem to solve? Are there any additional
    improvements you can make?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`factor` 的定义不是最有效的。首先，除了 *n* 本身之外，*n* 的因子不可能在 ![<graphic>](ch3_10.gif) 之后找到。其次，当找到一个因子时，除法
    `(/ n i)` 会执行两次。第三，在 2 之后，不可能再找到偶数因子。重新编码 `factor` 以纠正所有三个问题。哪个问题最重要？您能做出其他改进吗？'
- en: Section 3.3\. Continuations
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3.3 节。延续
- en: 'During the evaluation of a Scheme expression, the implementation must keep
    track of two things: (1) what to evaluate and (2) what to do with the value. Consider
    the evaluation of `(null? x)` within the expression below.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估 Scheme 表达式时，实现必须跟踪两件事：(1) 要评估什么，以及 (2) 如何处理值。考虑以下表达式中 `(null? x)` 的评估。
- en: '`(if (null? x) (quote ()) (cdr x))`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`(if (null? x) (quote ()) (cdr x))`'
- en: The implementation must first evaluate `(null? x)` and, based on its value,
    evaluate either `(quote ())` or `(cdr x)`. "What to evaluate" is `(null? x)`,
    and "what to do with the value" is to make the decision which of `(quote ())`
    and `(cdr x)` to evaluate and to do so. We call "what to do with the value" the
    *continuation* of a computation.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 实现必须首先评估 `(null? x)`，并根据其值评估 `(quote ())` 或 `(cdr x)`。 "要评估什么" 是 `(null? x)`，"如何处理值"
    是决定评估 `(quote ())` 还是 `(cdr x)` 的决定，并执行。我们称"如何处理值"为计算的*延续*。
- en: Thus, at any point during the evaluation of any expression, there is a continuation
    ready to complete, or at least *continue*, the computation from that point. Let's
    assume that `x` has the value `(a b c)`. We can isolate six continuations during
    the evaluation of `(if (null? x) (quote ()) (cdr x))`, the continuations waiting
    for
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在任何表达式的评估过程中，在任何时刻都有一个延续准备完成，或至少*继续*从那一点开始的计算。假设 `x` 的值为 `(a b c)`。在评估 `(if (null? x) (quote ()) (cdr x))`
    过程中，我们可以分离出六个延续，等待
- en: the value of `(if (null? x) (quote ()) (cdr x))`,
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(if (null? x) (quote ()) (cdr x))` 的值，'
- en: the value of `(null? x)`,
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(null? x)` 的值，'
- en: the value of `null?`,
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`null?` 的值，'
- en: the value of `x`,
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x` 的值，'
- en: the value of `cdr`, and
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cdr` 的值，以及'
- en: the value of `x` (again).
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x` 的值（再次）。'
- en: The continuation of `(cdr x)` is not listed because it is the same as the one
    waiting for `(if (null? x) (quote ()) (cdr x))`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cdr x)` 的延续没有列出，因为它与等待 `(if (null? x) (quote ()) (cdr x))` 的延续相同。'
- en: Scheme allows the continuation of any expression to be captured with the procedure
    `call/cc`. `call/cc` must be passed a procedure `*p*` of one argument. `call/cc`
    constructs a concrete representation of the current continuation and passes it
    to `*p*`. The continuation itself is represented by a procedure `*k*`. Each time
    `*k*` is applied to a value, it returns the value to the continuation of the `call/cc`
    application. This value becomes, in essence, the value of the application of `call/cc`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme允许捕获任何表达式的续延，并将其传递给过程`call/cc`。`call/cc`必须传递一个参数的过程`*p*`。`call/cc`构造当前续延的具体表示，并将其传递给`*p*`。续延本身由过程`*k*`表示。每次将值应用于`*k*`时，它将值返回给`call/cc`应用的续延。这个值本质上成为`call/cc`应用的值。
- en: If `*p*` returns without invoking `*k*`, the value returned by the procedure
    becomes the value of the application of `call/cc`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*p*`在不调用`*k*`的情况下返回，则过程返回的值将成为`call/cc`应用的值。
- en: Consider the simple examples below.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的简单示例。
- en: '`(call/cc'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call/cc'
- en: (lambda (k)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (* 5 4))) ![<graphic>](ch3_0.gif) 20
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: (* 5 4))) ![<graphic>](ch3_0.gif) 20
- en: (call/cc
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (k)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (* 5 (k 4)))) ![<graphic>](ch3_0.gif) 4
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: (* 5 (k 4)))) ![<graphic>](ch3_0.gif) 4
- en: (+ 2
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 2
- en: (call/cc
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (k)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (* 5 (k 4))))) ![<graphic>](ch3_0.gif) 6`
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: (* 5 (k 4))))) ![<graphic>](ch3_0.gif) 6`
- en: In the first example, the continuation is captured and bound to `k`, but `k`
    is never used, so the value is simply the product of 5 and 4. In the second, the
    continuation is invoked before the multiplication, so the value is the value passed
    to the continuation, 4. In the third, the continuation includes the addition by
    2; thus, the value is the value passed to the continuation, 4, plus 2.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，续延被捕获并绑定到`k`，但`k`从未被使用，因此值只是5和4的乘积。在第二个示例中，在乘法之前调用了续延，因此值是传递给续延的值，即4。在第三个示例中，续延包括加法2；因此，值是传递给续延的值4，再加上2。
- en: Here is a less trivial example, showing the use of `call/cc` to provide a nonlocal
    exit from a recursion.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不太平凡的示例，展示了使用`call/cc`从递归中提供非局部退出的用法。
- en: '`(define product'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define product'
- en: (lambda (ls)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (call/cc
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (break)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (中断)
- en: (let f ([ls ls])
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([ls ls])
- en: (cond
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? ls) 1]'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? ls) 1]'
- en: '[(= (car ls) 0) (break 0)]'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[(= (car ls) 0) (break 0)]'
- en: '[else (* (car ls) (f (cdr ls)))]))))))`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (* (car ls) (f (cdr ls)))]))))))`'
- en: '`(product ''(1 2 3 4 5)) ![<graphic>](ch3_0.gif) 120'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`(product ''(1 2 3 4 5)) ![<graphic>](ch3_0.gif) 120'
- en: (product '(7 3 8 0 1 9 5)) ![<graphic>](ch3_0.gif) 0`
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: (product '(7 3 8 0 1 9 5)) ![<graphic>](ch3_0.gif) 0`
- en: The nonlocal exit allows `product` to return immediately, without performing
    the pending multiplications, when a zero value is detected.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 非局部退出允许`product`在检测到零值时立即返回，而不执行待处理的乘法。
- en: Each of the continuation invocations above returns to the continuation while
    control remains within the procedure passed to `call/cc`. The following example
    uses the continuation after this procedure has already returned.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每次续延调���在控制仍在传递给`call/cc`的过程内时返回续延。以下示例在此过程已经返回后使用续延。
- en: '`(let ([x (call/cc (lambda (k) k))])'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x (call/cc (lambda (k) k))])'
- en: (x (lambda (ignore) "hi"))) ![<graphic>](ch3_0.gif) "hi"`
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: (x (lambda (ignore) "hi"))) ![<graphic>](ch3_0.gif) "hi"`
- en: The continuation captured by this invocation of `call/cc` may be described as
    "Take the value, bind it to `x`, and apply the value of `x` to the value of `(lambda (ignore) "hi")`."
    Since `(lambda (k) k)` returns its argument, `x` is bound to the continuation
    itself; this continuation is applied to the procedure resulting from the evaluation
    of `(lambda (ignore) "hi")`. This has the effect of binding `x` (again!) to this
    procedure and applying the procedure to itself. The procedure ignores its argument
    and returns `"hi"`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次对`call/cc`的调用捕获的续延可以描述为“取值，将其绑定到`x`，并将`x`的值应用于`(lambda (ignore) "hi")`的值。”由于`(lambda (k) k)`返回其参数，`x`绑定到续延本身；这个续延应用于`(lambda (ignore) "hi")`的求值结果产生的过程。这样做的效果是将`x`（再次！）绑定到这个过程，并将过程应用于自身。过程忽略其参数并返回`"hi"`。
- en: The following variation of the example above is probably the most confusing
    Scheme program of its size; it might be easy to guess what it returns, but it
    takes some thought to figure out why.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例的以下变体可能是其规模最令人困惑的Scheme程序；猜测它返回什么可能很容易，但需要一些思考才能弄清楚为什么。
- en: '`(((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!") ![<graphic>](ch3_0.gif) "HEY!"`'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`(((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!") ![<graphic>](ch3_0.gif) "HEY!"`'
- en: The value of the `call/cc` is its own continuation, as in the preceding example.
    This is applied to the identity procedure `(lambda (x) x)`, so the `call/cc` returns
    a second time with this value. Then, the identity procedure is applied to itself,
    yielding the identity procedure. This is finally applied to `"HEY!"`, yielding
    `"HEY!"`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`call/cc`的值是它自己的延续，就像前面的例子一样。这被应用于恒等过程`(lambda (x) x)`，因此`call/cc`返回第二次带有这个值。然后，恒等过程应用于自身，产生恒等过程。最后，它被应用于`"嘿！"`，产生`"嘿！"`。'
- en: Continuations used in this manner are not always so puzzling. Consider the following
    definition of `factorial` that saves the continuation at the base of the recursion
    before returning 1, by assigning the top-level variable `retry`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用延续并不总是那么令人困惑。考虑以下定义的`factorial`，在返回1之前将递归基础处的延续保存下来，通过分配顶层变量`retry`。
- en: '`(define retry #f)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define retry #f)'
- en: (define factorial
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: (define factorial
- en: (lambda (x)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (if (= x 0)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= x 0)
- en: (call/cc (lambda (k) (set! retry k) 1))
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc (lambda (k) (set! retry k) 1))
- en: (* x (factorial (- x 1))))))`
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: (* x (factorial (- x 1))))))`
- en: With this definition, `factorial` works as we expect `factorial` to work, except
    it has the side effect of assigning `retry`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，`factorial`的工作方式符合我们对`factorial`的期望，只是它有一个副作用，即分配`retry`。
- en: '`(factorial 4) ![<graphic>](ch3_0.gif) 24'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`(factorial 4) ![<graphic>](ch3_0.gif) 24'
- en: (retry 1) ![<graphic>](ch3_0.gif) 24
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: (retry 1) ![<graphic>](ch3_0.gif) 24
- en: (retry 2) ![<graphic>](ch3_0.gif) 48`
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: (retry 2) ![<graphic>](ch3_0.gif) 48`
- en: The continuation bound to `retry` might be described as "Multiply the value
    by 1, then multiply this result by 2, then multiply this result by 3, then multiply
    this result by 4." If we pass the continuation a different value, i.e., not 1,
    we will cause the base value to be something other than 1 and hence change the
    end result.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到`retry`的延续可以描述为“将值乘以1，然后将此结果乘以2，然后将此结果乘以3，然后将此结果乘以4”。如果我们传递给延续一个不同的值，即不是1，我们将导致基础值不是1，从而改变最终结果。
- en: '`(retry 2) ![<graphic>](ch3_0.gif) 48'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`(retry 2) ![<graphic>](ch3_0.gif) 48'
- en: (retry 5) ![<graphic>](ch3_0.gif) 120`
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: (retry 5) ![<graphic>](ch3_0.gif) 120`
- en: This mechanism could be the basis for a breakpoint package implemented with
    `call/cc`; each time a breakpoint is encountered, the continuation of the breakpoint
    is saved so that the computation may be restarted from the breakpoint (more than
    once, if desired).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制可以作为使用`call/cc`实现的断点包的基础；每次遇到断点时，都会保存断点的延续，以便可以从断点重新启动计算（如果需要，可以多次）。
- en: Continuations may be used to implement various forms of multitasking. The simple
    "light-weight process" mechanism defined below allows multiple computations to
    be interleaved. Since it is *nonpreemptive*, it requires that each process voluntarily
    "pause" from time to time in order to allow the others to run.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 延续可用于实现各种形式的多任务处理。下面定义的简单“轻量级进程”机制允许��个计算交错进行。由于它是*非抢占式*的，因此需要每个进程自愿不时“暂停”，以便允许其他进程运行。
- en: '`(define lwp-list ''())'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define lwp-list ''())'
- en: (define lwp
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: (define lwp
- en: (lambda (thunk)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (thunk)
- en: (set! lwp-list (append lwp-list (list thunk)))))
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: (set! lwp-list (append lwp-list (list thunk)))))
- en: (define start
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: (define start
- en: (lambda ()
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (let ([p (car lwp-list)])
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([p (car lwp-list)])
- en: (set! lwp-list (cdr lwp-list))
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: (set! lwp-list (cdr lwp-list))
- en: (p))))`
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: (p))))`
- en: '`(define pause'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define pause'
- en: (lambda ()
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (call/cc
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (k)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (lwp (lambda () (k #f)))
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: (lwp (lambda () (k #f)))
- en: (start)))))`
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: (start)))))`
- en: The following light-weight processes cooperate to print an infinite sequence
    of lines containing `"hey!"`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 以下轻量级进程合作打印包含`"嘿！"`的无限序列的行。
- en: '`(lwp (lambda () (let f () (pause) (display "h") (f))))'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lwp (lambda () (let f () (pause) (display "h") (f))))'
- en: (lwp (lambda () (let f () (pause) (display "e") (f))))
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: (lwp (lambda () (let f () (pause) (display "e") (f))))
- en: (lwp (lambda () (let f () (pause) (display "y") (f))))
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: (lwp (lambda () (let f () (pause) (display "y") (f))))
- en: (lwp (lambda () (let f () (pause) (display "!") (f))))
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: (lwp (lambda () (let f () (pause) (display "!") (f))))
- en: (lwp (lambda () (let f () (pause) (newline) (f))))
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: (lwp (lambda () (let f () (pause) (newline) (f))))
- en: (start) ![<graphic>](ch3_0.gif) *hey!*
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: (start) ![<graphic>](ch3_0.gif) *嘿！*
- en: '![](ch3_ghostRightarrow.gif) *hey!*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) *嘿！*'
- en: '![](ch3_ghostRightarrow.gif) *hey!*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) *嘿！*'
- en: '![](ch3_ghostRightarrow.gif) *hey!*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) *嘿！*'
- en: '![](ch3_ghostRightarrow.gif) ![<graphic>](ch3_3.gif)`'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) ![<graphic>](ch3_3.gif)`'
- en: See Section [12.11](examples.html#g208) for an implementation of *engines*,
    which support preemptive multitasking, with `call/cc`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见第[12.11](examples.html#g208)节，了解支持使用`call/cc`进行抢占式多任务处理的*引擎*的实现。
- en: Exercise 3.3.1
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.3.1
- en: Use `call/cc` to write a program that loops indefinitely, printing a sequence
    of numbers beginning at zero. Do not use any recursive procedures, and do not
    use any assignments.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`call/cc`编写一个无限循环的程序，从零开始打印一系列数字。不要使用任何递归过程，也不要使用任何赋值。
- en: Exercise 3.3.2
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.3.2
- en: Rewrite `product` without `call/cc`, retaining the feature that no multiplications
    are performed if any of the list elements are zero.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`product`而不使用`call/cc`，保留如果列表元素中有任何零则不执行任何乘法的特性。
- en: Exercise 3.3.3
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.3.3
- en: What would happen if a process created by `lwp` as defined above were to terminate,
    i.e., simply return without calling `pause`? Define a `quit` procedure that allows
    a process to terminate without otherwise affecting the `lwp` system. Be sure to
    handle the case in which the only remaining process terminates.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由上述`lwp`定义创建的进程终止会发生什么？定义一个`quit`过程，允许进程在不影响`lwp`系统的情况下终止。务必处理仅剩的进程终止的情况。
- en: Exercise 3.3.4
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.3.4
- en: Each time `lwp` is called, the list of processes is copied because `lwp` uses
    `append` to add its argument to the end of the process list. Modify the original
    `lwp` code to use the queue data type developed in Section [2.9](start.html#g40)
    to avoid this problem.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`lwp`时，进程列表都会被复制，因为`lwp`使用`append`将其参数添加到进程列表的末尾。修改原始的`lwp`代码，使用第[2.9](start.html#g40)节中开发的队列数据类型来避免这个问题。
- en: Exercise 3.3.5
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.3.5
- en: The light-weight process mechanism allows new processes to be created dynamically,
    although the example given in this section does not do so. Design an application
    that requires new processes to be created dynamically and implement it using the
    light-weight process mechanism.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级进程机制允许动态创建新进程，尽管本节中给出的示例并未这样做。设计一个需要动态创建新进程的应用程序，并使用轻量级进程机制实现它。
- en: Section 3.4\. Continuation Passing Style
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3.4 节。延续传递风格
- en: As we discussed in the preceding section, a continuation waits for the value
    of each expression. In particular, a continuation is associated with each procedure
    call. When one procedure invokes another via a nontail call, the called procedure
    receives an implicit continuation that is responsible for completing what is left
    of the calling procedure's body plus returning to the calling procedure's continuation.
    If the call is a tail call, the called procedure simply receives the continuation
    of the calling procedure.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的，延续等待每个表达式的值。特别是，每个过程调用都与一个延续相关联。当一个过程通过非尾调用调用另一个过程时，被调用的过程接收一个负责完成调用过程剩余部分并返回到调用过程延续的隐式延续。如果调用是尾调用，则被调用的过程简单地接收调用过程的延续。
- en: We can make the continuations explicit by encapsulating "what to do" in an explicit
    procedural argument passed along on each call. For example, the continuation of
    the call to `f` in
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在每次调用中传递一个显式过程参数来使延续变得显式。例如，在对`f`的调用的延续中
- en: '`(letrec ([f (lambda (x) (cons ''a x))]'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ([f (lambda x) (cons ''a x))]`'
- en: '[g (lambda (x) (cons ''b (f x)))]'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[g (lambda x (cons ''b (f x)))]'
- en: '[h (lambda (x) (g (cons ''c x)))])'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[h (lambda x (g (cons ''c x)))])'
- en: (cons 'd (h '()))) ![<graphic>](ch3_0.gif) (d b a c)`
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons ''d (h ''())))` ![<graphic>](ch3_0.gif) (d b a c)`'
- en: conses the symbol `b` onto the value returned to it, then returns the result
    of this cons to the continuation of the call to `g`. This continuation is the
    same as the continuation of the call to `h`, which conses the symbol `d` onto
    the value returned to it. We can rewrite this in *continuation-passing style*,
    or CPS, by replacing these implicit continuations with explicit procedures.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 将符号`b`连接到返回给它的值上，然后将此连接的结果返回给对`g`的调用的延续。这个延续与对`h`的调用的延续相同，后者将符号`d`连接到返回给它的值上。我们可以通过用显式过程替换这些隐式延续来以*延续传递风格*或CPS重写这个。
- en: '`(letrec ([f (lambda (x k) (k (cons ''a x)))]'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec ([f (lambda (x k) (k (cons ''a x)))]`'
- en: '[g (lambda (x k)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[g (lambda x k'
- en: (f x (lambda (v) (k (cons 'b v)))))]
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`(f x (lambda v (k (cons ''b v)))))]`'
- en: '[h (lambda (x k) (g (cons ''c x) k))])'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[h (lambda x k (g (cons ''c x) k))])'
- en: (h '() (lambda (v) (cons 'd v))))`
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`(h ''() (lambda v) (cons ''d v))))`'
- en: Like the implicit continuation of `h` and `g` in the preceding example, the
    explicit continuation passed to `h` and on to `g`,
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面示例中的`h`和`g`的隐式延续一样，传递给`h`并传递给`g`的显式延续，
- en: '`(lambda (v) (cons ''d v))`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda v (cons ''d v))`'
- en: conses the symbol `d` onto the value passed to it. Similarly, the continuation
    passed to `f`,
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 将符号`d`连接到传递给它的值上。类似地，传递给`f`的延续，
- en: '`(lambda (v) (k (cons ''b v)))`'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda v (k (cons ''b v)))`'
- en: conses `b` onto the value passed to it, then passes this on to the continuation
    of `g`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 将`b`连接到传递给它的值上，然后将其传递给`g`的延续。
- en: Expressions written in CPS are more complicated, of course, but this style of
    programming has some useful applications. CPS allows a procedure to pass more
    than one result to its continuation, because the procedure that implements the
    continuation can take any number of arguments.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当以CPS编写的表达式当然更加复杂，但这种编程风格具有一些有用的应用。CPS允许一个过程向其延续传递多个结���，因为实现延续的过程可以接受任意数量的参数。
- en: '`(define car&cdr'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define car&cdr'
- en: (lambda (p k)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p k)
- en: (k (car p) (cdr p))))
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: (k (car p) (cdr p))))
- en: (car&cdr '(a b c)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: (car&cdr '(a b c)
- en: (lambda (x y)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (list y x))) ![<graphic>](ch3_0.gif) ((b c) a)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: (list y x))) ![<graphic>](ch3_0.gif) ((b c) a)
- en: (car&cdr '(a b c) cons) ![<graphic>](ch3_0.gif) (a b c)
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: (car&cdr '(a b c) cons) ![<graphic>](ch3_0.gif) (a b c)
- en: (car&cdr '(a b c a d) memv) ![<graphic>](ch3_0.gif) (a d)`
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: (car&cdr '(a b c a d) memv) ![<graphic>](ch3_0.gif) (a d)`
- en: (This can be done with multiple values as well; see Section [5.8](control.html#g104).)
    CPS also allows a procedure to take separate "success" and "failure" continuations,
    which may accept different numbers of arguments. An example is `integer-divide`
    below, which passes the quotient and remainder of its first two arguments to its
    third, unless the second argument (the divisor) is zero, in which case it passes
    an error message to its fourth argument.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: (这也可以用多个值来完成；参见第[5.8](control.html#g104)节。CPS还允许一个过程接受单独的“成功”和“失败”延续，它们可能接受不同数量的参数。下面是一个例子，`integer-divide`，它将其前两个参数的商和余数传递给第三个参数，除非第二个参数（除数）为零，此时它将错误消息传递给第四个参数。
- en: '`(define integer-divide'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define integer-divide'
- en: (lambda (x y success failure)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y success failure)
- en: (if (= y 0)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= y 0)
- en: (failure "divide by zero")
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: (failure "divide by zero")
- en: (let ([q (quotient x y)])
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([q (quotient x y)])
- en: (success q (- x (* q y)))))))
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: (success q (- x (* q y)))))))
- en: (integer-divide 10 3 list (lambda (x) x)) ![<graphic>](ch3_0.gif) (3 1)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: (integer-divide 10 3 list (lambda (x) x)) ![<graphic>](ch3_0.gif) (3 1)
- en: (integer-divide 10 0 list (lambda (x) x)) ![<graphic>](ch3_0.gif) "divide by zero"`
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: (integer-divide 10 0 list (lambda (x) x)) ![<graphic>](ch3_0.gif) "divide by zero"`
- en: The procedure `quotient`, employed by `integer-divide`, returns the quotient
    of its two arguments, truncated toward zero.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`quotient`，由`integer-divide`使用，返回其两个参数的商，向零截断。
- en: Explicit success and failure continuations can sometimes help to avoid the extra
    communication necessary to separate successful execution of a procedure from unsuccessful
    execution. Furthermore, it is possible to have multiple success or failure continuations
    for different flavors of success or failure, each possibly taking different numbers
    and types of arguments. See Sections [12.10](examples.html#g204) and [12.11](examples.html#g208)
    for extended examples that employ continuation-passing style.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的成功和失败延续有时可以帮助避免必须将过程的成功执行与失败执行分开所需的额外通信。此外，可以为不同类型的成功或失败拥有多个成功或失败延续，每个延续可能接受不同数量和类型的参数。请参见第[12.10](examples.html#g204)和第[12.11](examples.html#g208)节，这些节提供了使用延续传递风格的扩展示例。
- en: At this point you might be wondering about the relationship between CPS and
    the continuations captured via `call/cc`. It turns out that any program that uses
    `call/cc` can be rewritten in CPS without `call/cc`, but a total rewrite of the
    program (sometimes including even system-defined primitives) might be necessary.
    Try to convert the `product` example on page [75](further.html#defn:product-call/cc)
    into CPS before looking at the version below.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能想知道CPS与通过`call/cc`捕获的延续之间的关系。事实证明，任何使用`call/cc`的程序都可以在不使用`call/cc`的情况下以CPS方式重写，但可能需要对程序进行全面重写（有时甚至包括系统定义的原语）。在查看下面的版本之前，尝试将第[75](further.html#defn:product-call/cc)页上的`product`示例转换为CPS。
- en: '`(define product'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define product'
- en: (lambda (ls k)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls k)
- en: (let ([break k])
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([break k])
- en: (let f ([ls ls] [k k])
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([ls ls] [k k])
- en: (cond
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? ls) (k 1)]'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? ls) (k 1)]'
- en: '[(= (car ls) 0) (break 0)]'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[(= (car ls) 0) (break 0)]'
- en: '[else (f (cdr ls)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (f (cdr ls)'
- en: (lambda (x)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (k (* (car ls) x))))])))))`
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: (k (* (car ls) x))))])))))`
- en: '`(product ''(1 2 3 4 5) (lambda (x) x)) ![<graphic>](ch3_0.gif) 120'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`(product ''(1 2 3 4 5) (lambda (x) x)) ![<graphic>](ch3_0.gif) 120'
- en: (product '(7 3 8 0 1 9 5) (lambda (x) x)) ![<graphic>](ch3_0.gif) 0`
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: (product '(7 3 8 0 1 9 5) (lambda (x) x)) ![<graphic>](ch3_0.gif) 0`
- en: Exercise 3.4.1
  id: totrans-495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.4.1
- en: Rewrite the `reciprocal` example first given in Section [2.1](start.html#g5)
    to accept both success and failure continuations, like `integer-divide` above.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 首先重写第[2.1](start.html#g5)节中首次给出的`reciprocal`示例，以接受像上面的`integer-divide`一样的成功和失败延续。
- en: Exercise 3.4.2
  id: totrans-497
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.4.2
- en: Rewrite the `retry` example from page [75](further.html#retry) to use CPS.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 将第[75](further.html#retry)页的`retry`示例重写为使用CPS。
- en: Exercise 3.4.3
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习3.4.3
- en: Rewrite the following expression in CPS to avoid using `call/cc`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下表达式重写为CPS以避免使用`call/cc`。
- en: '`(define reciprocals'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define reciprocals'
- en: (lambda (ls)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (call/cc
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (k)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (map (lambda (x)
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: (map (lambda (x)
- en: (if (= x 0)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= x 0)
- en: (k "zero found")
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: (k "zero found")
- en: (/ 1 x)))
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 1 x)))
- en: ls)))))`
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: ls)))))`
- en: '`(reciprocals ''(2 1/3 5 1/4)) ![<graphic>](ch3_0.gif) (1/2 3 1/5 4)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocals ''(2 1/3 5 1/4)) ![<graphic>](ch3_0.gif) (1/2 3 1/5 4)'
- en: (reciprocals '(2 1/3 0 5 1/4)) ![<graphic>](ch3_0.gif) "zero found"`
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: (reciprocals '(2 1/3 0 5 1/4)) ![<graphic>](ch3_0.gif) "zero found"`
- en: '[*Hint*: A single-list version of `map` is defined on page [46](start.html#defn:map1).]'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[*提示*：`map`的单列表版本在第[46](start.html#defn:map1)页上定义。]'
- en: Section 3.5\. Internal Definitions
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3.5节。内部定义
- en: In Section [2.6](start.html#g25), we discussed top-level definitions. Definitions
    may also appear at the front of a `lambda`, `let`, or `letrec` body, in which
    case the bindings they create are local to the body.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[2.6](start.html#g25)节中，我们讨论了顶层定义。定义也可以出现在`lambda`、`let`或`letrec`主体的开头，这样它们创建的绑定将局限于主体。
- en: '`(define f (lambda (x) (* x x)))'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define f (lambda (x) (* x x)))'
- en: (let ([x 3])
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 3])
- en: (define f (lambda (y) (+ y x)))
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: (define f (lambda (y) (+ y x)))
- en: (f 4)) ![<graphic>](ch3_0.gif) 7
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: (f 4)) ![<graphic>](ch3_0.gif) 7
- en: (f 4) ![<graphic>](ch3_0.gif) 16`
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: (f 4) ![<graphic>](ch3_0.gif) 16`
- en: Procedures bound by internal definitions can be mutually recursive, as with
    `letrec`. For example, we can rewrite the `even?` and `odd?` example from Section [3.2](further.html#g55)
    using internal definitions as follows.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 过程通过内部定义可以相互递归，就像使用`letrec`一样。例如，我们可以使用内部定义重写第[3.2](further.html#g55)节中的`even?`和`odd?`示例如下。
- en: '`(let ()'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ()'
- en: (define even?
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: (define even?
- en: (lambda (x)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (or (= x 0)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: (or (= x 0)
- en: (odd? (- x 1)))))
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: (odd? (- x 1)))))
- en: (define odd?
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: (define odd?
- en: (lambda (x)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (and (not (= x 0))
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (= x 0))
- en: (even? (- x 1)))))
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: (even? (- x 1)))))
- en: (even? 20)) ![<graphic>](ch3_0.gif) #t`
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: (even? 20)) ![<graphic>](ch3_0.gif) #t`
- en: Similarly, we can replace the use of `letrec` to bind `race` with an internal
    definition of `race` in our first definition of `list?`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以用内部定义的`race`替换`letrec`来绑定`race`，在我们第一个`list?`定义中。
- en: '`(define list?'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define list?'
- en: (lambda (x)
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (define race
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: (define race
- en: (lambda (h t)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (h t)
- en: (if (pair? h)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: (if (pair? h)
- en: (let ([h (cdr h)])
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([h (cdr h)])
- en: (if (pair? h)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: (if (pair? h)
- en: (and (not (eq? h t))
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (eq? h t))
- en: (race (cdr h) (cdr t)))
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: (race (cdr h) (cdr t)))
- en: (null? h)))
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: (null? h)))
- en: (null? h))))
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: (null? h))))
- en: (race x x)))`
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: (race x x)))`
- en: In fact, internal variable definitions and `letrec` are practically interchangeable.
    The only difference, other than the obvious difference in syntax, is that variable
    definitions are guaranteed to be evaluated from left to right, while the bindings
    of a letrec may be evaluated in any order. So we cannot quite replace a `lambda`,
    `let`, or `letrec` body containing internal definitions with a `letrec` expression.
    We can, however, use `letrec*`, which, like `let*`, guarantees left-to-right evaluation
    order. A body of the form
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，内部变量定义和`letrec`几乎可以互换。除了语法上的明显差异之外，唯一的区别是，变量定义保证从左到右进行评估，而letrec的绑定可以以任何顺序进行评估。因此，我们不能完全用`letrec`表达式替换包含内部定义的`lambda`、`let`或`letrec`主体。但是，我们可以使用`letrec*`，它像`let*`���样，保证从左到右的评估顺序。形式为
- en: '`(define *var* *expr[0]*)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define *var* *expr[0]*)'
- en: '![<graphic>](ch3_3.gif)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch3_3.gif)'
- en: '*expr[1]*'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '*expr[1]*'
- en: '*expr[2]*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '*expr[2]*'
- en: '![<graphic>](ch3_3.gif)`'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '![<graphic>](ch3_3.gif)`'
- en: is equivalent to a `letrec*` expression binding the defined variables to the
    associated values in a body comprising the expressions.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于将定义的变量绑定到主体中的相关值的`letrec*`表达式。
- en: '`(letrec* ((*var* *expr[0]*) ...) *expr[1]* *expr[2]* ...)`'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec* ((*var* *expr[0]*) ...) *expr[1]* *expr[2]* ...)`'
- en: Conversely, a `letrec*` of the form
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，形式为`letrec*`的表达式
- en: '`(letrec* ((*var* *expr[0]*) ...) *expr[1]* *expr[2]* ...)`'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`(letrec* ((*var* *expr[0]*) ...) *expr[1]* *expr[2]* ...)`'
- en: can be replaced with a `let` expression containing internal definitions and
    the expressions from the body as follows.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用包含内部定义和主体中表达式的`let`表达式替换。
- en: '`(let ()'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ()'
- en: (define *var* *expr[0]*)
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: (define *var* *expr[0]*)
- en: '![<graphic>](ch3_3.gif)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch3_3.gif)'
- en: '*expr[1]*'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '*expr[1]*'
- en: '*expr[2]*'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '*expr[2]*'
- en: '![<graphic>](ch3_3.gif)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch3_3.gif)'
- en: )`
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: )`
- en: The seeming lack of symmetry between these transformations is due to the fact
    that `letrec*` expressions can appear anywhere an expression is valid, whereas
    internal definitions can appear only at the front of a body. Thus, in replacing
    a `letrec*` with internal definitions, we must generally introduce a `let` expression
    to hold the definitions.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换之间看似缺乏对称性，是因为`letrec*`表达式可以出现在任何表达式有效的地方，而内部定义只能出现在主体的开头。因此，在用内部定义替换`letrec*`时，通常必须引入一个`let`表达式来保存这些定义。
- en: Another difference between internal definitions and `letrec` or `letrec*` is
    that syntax definitions may appear among the internal definitions, while `letrec`
    and `letrec*` bind only variables.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 内部定义与`letrec`或`letrec*`之间的另一个区别是，语法定义可以出现在内部定义中，而`letrec`和`letrec*`只绑定变量。
- en: '`(let ([x 3])'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 3])'
- en: (define-syntax set-x!
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax set-x!
- en: (syntax-rules ()
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ e) (set! x e)]))'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e) (set! x e)]))'
- en: (set-x! (+ x x))
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: (set-x! (+ x x))
- en: x) ![<graphic>](ch3_0.gif) 6`
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: x) ![<graphic>](ch3_0.gif) 6`
- en: The scope of a syntactic extension established by an internal syntax definition,
    as with an internal variable definition, is limited to the body in which the syntax
    definition appears.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 由内部语法定义建立的语法扩展的作用域，与内部变量定义一样，仅限于语法定义出现的主体中。
- en: Internal definitions may be used in conjunction with top-level definitions and
    assignments to help modularize programs. Each module of a program should make
    visible only those bindings that are needed by other modules, while hiding other
    bindings that would otherwise clutter the top-level namespace and possibly result
    in unintended use or redefinition of those bindings. A common way of structuring
    a module is shown below.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 内部定义可以与顶层定义和赋值一起使用，以帮助模块化程序。程序的每个模块应该只公开其他模块需要的绑定，同时隐藏其他绑定，否则会使顶层命名空间混乱，并可能导致意外使用或重新定义这些绑定。一个常见的模块结构如下所示。
- en: '`(define *export-var* #f)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define *export-var* #f)'
- en: '![<graphic>](ch3_3.gif)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch3_3.gif)'
- en: (let ()
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: (let ()
- en: (define *var* *expr*)
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: (define *var* *expr*)
- en: '![<graphic>](ch3_3.gif)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch3_3.gif)'
- en: '*init-expr*'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '*init-expr*'
- en: '![<graphic>](ch3_3.gif)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch3_3.gif)'
- en: (set! *export-var* *export-val*)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: (set! *export-var* *export-val*)
- en: '![<graphic>](ch3_3.gif)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch3_3.gif)'
- en: )`
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: )`
- en: The first set of definitions establish top-level bindings for the variables
    we desire to export (make visible globally). The second set of definitions establish
    local bindings visible only within the module. The expressions `*init-expr* ...`
    perform any initialization that must occur after the local bindings have been
    established. Finally, the `set!` expressions assign the exported variables to
    the appropriate values.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组定义为我们希望导出（在全局可见）的变量建立了顶层绑定。第二组定义建立了仅在模块内可见的局部绑定。表达式`*init-expr* ...`执行在局部绑定建立后必须发生的任何初始化。最后，`set!`表达式将导出的变量分配给相应的值。
- en: An advantage of this form of modularization is that the bracketing `let` expression
    may be removed or "commented out" during program development, making the internal
    definitions top-level to facilitate interactive testing. This form of modularization
    also has several disadvantages, as we discuss in the next section.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化形式的一个优点是，在程序开发过程中，括号`let`表达式可以被移除或“注释掉”，使内部定义变为顶层，以便进行交互式测试。但这种模块化形式也有几个缺点，我们将在下一节讨论。
- en: The following module exports a single variable, `calc`, which is bound to a
    procedure that implements a simple four-function calculator.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模块导出一个名为`calc`的变量，该变量绑定到实现简单四则运算计算器的过程。
- en: '`(define calc #f)'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define calc #f)'
- en: (let ()
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: (let ()
- en: (define do-calc
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: (define do-calc
- en: (lambda (ek expr)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ek expr)
- en: (cond
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(number? expr) expr]'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '[(number? expr) expr]'
- en: '[(and (list? expr) (= (length expr) 3))'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[(and (list? expr) (= (length expr) 3))'
- en: (let ([op (car expr)] [args (cdr expr)])
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([op (car expr)] [args (cdr expr)])
- en: (case op
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: (case op
- en: '[(add) (apply-op ek + args)]'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '[(add) (apply-op ek + args)]'
- en: '[(sub) (apply-op ek - args)]'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '[(sub) (apply-op ek - args)]'
- en: '[(mul) (apply-op ek * args)]'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[(mul) (apply-op ek * args)]'
- en: '[(div) (apply-op ek / args)]'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[(div) (apply-op ek / args)]'
- en: '[else (complain ek "invalid operator" op)]))]'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (complain ek "invalid operator"��op)]))]'
- en: '[else (complain ek "invalid expression" expr)])))'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (complain ek "invalid expression" expr)])))'
- en: (define apply-op
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: (define apply-op
- en: (lambda (ek op args)
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ek op args)
- en: (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
- en: (define complain
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: (define complain
- en: (lambda (ek msg expr)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ek msg expr)
- en: (ek (list msg expr))))
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: (ek (list msg expr))))
- en: (set! calc
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: (set! calc
- en: (lambda (expr)
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (expr)
- en: ; grab an error continuation ek
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: ; grab an error continuation ek
- en: (call/cc
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (ek)
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ek)
- en: (do-calc ek expr))))))
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: (do-calc ek expr))))))
- en: (calc '(add (mul 3 2) -4)) ![<graphic>](ch3_0.gif) 2
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: (calc '(add (mul 3 2) -4)) ![<graphic>](ch3_0.gif) 2
- en: (calc '(div 1/2 1/6)) ![<graphic>](ch3_0.gif) 3
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: (calc '(div 1/2 1/6)) ![<graphic>](ch3_0.gif) 3
- en: (calc '(add (mul 3 2) (div 4))) ![<graphic>](ch3_0.gif) ("invalid expression" (div 4))
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: (calc '(add (mul 3 2) (div 4))) ![<graphic>](ch3_0.gif) ("无效表达式" (div 4))
- en: (calc '(mul (add 1 -2) (pow 2 7))) ![<graphic>](ch3_0.gif) ("invalid operator" pow)`
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: (calc '(mul (add 1 -2) (pow 2 7))) ![<graphic>](ch3_0.gif) ("无效运算符" pow)`
- en: 'This example uses a `case` expression to determine which operator to apply.
    `case` is similar to `cond` except that the test is always the same: `(memv *val* (*key* ...))`,
    where `*val*` is the value of the first `case` subform and `(*key* ...)` is the
    list of items at the front of each `case` clause. The `case` expression in the
    example above could be rewritten using `cond` as follows.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用`case`表达式来确定应用哪个运算符。`case`类似于`cond`，不同之处在于测试始终相同：`(memv *val* (*key* ...))`，其中`*val*`是第一个`case`子形式的值，`(*key* ...)`是每个`case`子句前面的项目列表。上面示例中的`case`表达式可以使用`cond`重写如下。
- en: '`(let ([temp op])'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([temp op])'
- en: (cond
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(memv temp ''(add)) (apply-op ek + args)]'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '[(memv temp ''(add)) (apply-op ek + args)]'
- en: '[(memv temp ''(sub)) (apply-op ek - args)]'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '[(memv temp ''(sub)) (apply-op ek - args)]'
- en: '[(memv temp ''(mul)) (apply-op ek * args)]'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '[(memv temp ''(mul)) (apply-op ek * args)]'
- en: '[(memv temp ''(div)) (apply-op ek / args)]'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '[(memv temp ''(div)) (apply-op ek / args)]'
- en: '[else (complain ek "invalid operator" op)]))`'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (complain ek "无效运算符" op)]))`'
- en: Exercise 3.5.1
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.5.1
- en: Redefine `complain` in the `calc` example as an equivalent syntactic extension.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calc`示例中重新定义`complain`为一个等效的语法扩展。
- en: Exercise 3.5.2
  id: totrans-626
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.5.2
- en: In the `calc` example, the error continuation `ek` is passed along on each call
    to `apply-op`, `complain`, and `do-calc`. Move the definitions of `apply-op`,
    `complain`, and `do-calc` inward as far as necessary to eliminate the `ek` argument
    from the definitions and applications of these procedures.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calc`示例中，错误继续`ek`在每次调用`apply-op`、`complain`和`do-calc`时都被传递。将`apply-op`、`complain`和`do-calc`的定义尽可能向内移动，以消除这些过程的定义和应用中的`ek`参数。
- en: Exercise 3.5.3
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.5.3
- en: Eliminate the `call/cc` from `calc` and rewrite `complain` to raise an exception
    using `assertion-violation`.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 从`calc`中消除`call/cc`，并重写`complain`以使用`assertion-violation`引发异常。
- en: Exercise 3.5.4
  id: totrans-630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.5.4
- en: Extend `calc` to handle unary minus expressions, e.g.,
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`calc`以处理一元减号表达式，例如，
- en: '`(calc ''(minus (add 2 3))) ![<graphic>](ch3_0.gif) -5`'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '`(calc ''(minus (add 2 3))) ![<graphic>](ch3_0.gif) -5`'
- en: and other operators of your choice.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他您选择的运算符。
- en: Section 3.6\. Libraries
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3.6 节。库
- en: 'At the end of the preceding section, we discussed a form of modularization
    that involves assigning a set of top-level variables from within a `let` while
    keeping unpublished helpers local to the `let`. This form of modularization has
    several drawbacks:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面一节的结尾，我们讨论了一种模块化形式，涉及从`let`内部分配一组顶层变量，同时将未发布的辅助程序保持在`let`的局部范围内。这种模块化形式有几个缺点：
- en: It is unportable, because the behavior and even existence of an interactive
    top level is not guaranteed by the Revised⁶ Report.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是不可移植的，因为交互式顶层的行为甚至存在性在修订⁶报告中并不保证。
- en: It requires assignments, which make the code appear somewhat awkward and may
    inhibit compiler analyses and optimizations.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要赋值，这使得代码看起来有些笨拙，可能会阻碍编译器的分析和优化。
- en: It does not support the publication of keyword bindings, since there is no analogue
    to `set!` for keywords.
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持关键字绑定的发布，因为对于关键字没有类似于`set!`的东西。
- en: An alternative that does not share these drawbacks is to create a library. A
    library exports a set of identifiers, each defined within the library or imported
    from some other library. An exported identifier need not be bound as a variable;
    it may be bound as a keyword instead.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不具有这些缺点的替代方法是创建一个库。库导出一组标识符，每个标识符在库内定义或从其他库导入。导出的标识符不必绑定为变量；它可以绑定为关键字。
- en: 'The following library exports two identifiers: the variable `gpa->grade` and
    the keyword `gpa`. The variable `gpa->grade` is bound to a procedure that takes
    a grade-point average (GPA), represented as a number, and returns the corresponding
    letter grade, based on a four-point scale. The keyword `gpa` names a syntactic
    extension whose subforms must all be letter grades and whose value is the GPA
    computed from those letter grades.'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库导出两个标识符：变量`gpa->grade`和关键字`gpa`。变量`gpa->grade`绑定到一个过程，该过程接受以数字表示的绩点平均值（GPA），并根据四分制返回相应的字母等级。关键字`gpa`命名一个语法扩展，其子形式必须全部是字母等级，其值是从这些字母等级计算出的GPA。
- en: '`(library (grades)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (grades)'
- en: (export gpa->grade gpa)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: (export gpa->grade gpa)
- en: (import (rnrs))
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: (导入 (rnrs))
- en: (define in-range?
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 in-range?
- en: (lambda (x n y)
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x n y)
- en: (and (>= n x) (< n y))))
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: (and (>= n x) (< n y))))
- en: (define-syntax range-case
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: (定义语法 range-case
- en: (syntax-rules (- else)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: (语法规则 (- else)
- en: '[(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])'
- en: (let ([tmp expr])
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([tmp expr])
- en: (cond
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(in-range? x tmp y) e1 e2 ...]'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '[(in-range? x tmp y) e1 e2 ...]'
- en: '...'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[else ee1 ee2 ...]))]'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '[else ee1 ee2 ...]))]'
- en: '[(_ expr ((x - y) e1 e2 ...) ...)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ expr ((x - y) e1 e2 ...) ...)'
- en: (let ([tmp expr])
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([tmp expr])
- en: (cond
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(in-range? x tmp y) e1 e2 ...]'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '[(in-range? x tmp y) e1 e2 ...]'
- en: '...))]))'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '...))]))'
- en: (define letter->number
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 letter->number
- en: (lambda (x)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (case x
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: (case x
- en: '[(a)  4.0]'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '[(a)  4.0]'
- en: '[(b)  3.0]'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '[(b)  3.0]'
- en: '[(c)  2.0]'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '[(c)  2.0]'
- en: '[(d)  1.0]'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '[(d)  1.0]'
- en: '[(f)  0.0]'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '[(f)  0.0]'
- en: '[else (assertion-violation ''grade "invalid letter grade" x)])))'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (断言违规 ''grade "无效的字母等级" x)])))'
- en: (define gpa->grade
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 gpa->grade
- en: (lambda (x)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (range-case x
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: (range-case x
- en: '[(0.0 - 0.5) ''f]'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '[(0.0 - 0.5) ''f]'
- en: '[(0.5 - 1.5) ''d]'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[(0.5 - 1.5) ''d]'
- en: '[(1.5 - 2.5) ''c]'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '[(1.5 - 2.5) ''c]'
- en: '[(2.5 - 3.5) ''b]'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '[(2.5 - 3.5) ''b]'
- en: '[else ''a])))'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '[else ''a])))'
- en: (define-syntax gpa
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: (定义语法 gpa
- en: (syntax-rules ()
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: (语法规则 ()
- en: '[(_ g1 g2 ...)'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ g1 g2 ...)'
- en: (let ([ls (map letter->number '(g1 g2 ...))])
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([ls (map letter->number '(g1 g2 ...))])
- en: (/ (apply + ls) (length ls)))])))`
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: (/ (apply + ls) (length ls)))])))`
- en: The name of the library is `(grades)`. This may seem like a funny kind of name,
    but all library names are parenthesized. The library imports from the standard
    `(rnrs)` library, which contains most of the primitive and keyword bindings we
    have used in this chapter and the last, and everything we need to implement `gpa->grade`
    and `gpa`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的名称是 `(grades)`。这可能看起来像一种有趣的名称，但所有库名称都是用括号括起来的。该库从标准库 `(rnrs)` 中导入，其中包含了本章和上一章中使用的大部分原始和关键字绑定，以及我们实现
    `gpa->grade` 和 `gpa` 所需的一切。
- en: Along with `gpa->grade` and `gpa`, several other syntactic extensions and procedures
    are defined within the library, but none of the others are exported. The ones
    that aren't exported are simply helpers for the ones that are. Everything used
    within the library should be familiar, except for the `apply` procedure, which
    is described on page [107](control.html#desc:apply).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `gpa->grade` 和 `gpa`，库中还定义了几个其他语法扩展和过程，但其他的都没有被导出。没有被导出的那些只是为被导出的那些提供帮助。库中使用的所有内容都应该很熟悉，除了
    `apply` 过程，该过程在第 [107](control.html#desc:apply) 页有描述。
- en: If your Scheme implementation supports `import` in the interactive top level,
    you can test the two exports as shown below.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Scheme 实现支持在交互式顶层使用 `import`，你可以像下面展示的那样测试这两个导出。
- en: '`(import (grades))'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '`(导入 (grades))'
- en: (gpa c a c b b) ![<graphic>](ch3_0.gif) 2.8
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: (gpa c a c b b) ![<graphic>](ch3_0.gif) 2.8
- en: (gpa->grade 2.8) ![<graphic>](ch3_0.gif) b`
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: (gpa->grade 2.8) ![<graphic>](ch3_0.gif) b`
- en: Chapter [10](libraries.html#g142) describes libraries in more detail and provides
    additional examples of their use.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 第 [10](libraries.html#g142) 章更详细地描述了库，并提供了它们使用的其他示例。
- en: Exercise 3.6.1
  id: totrans-689
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.6.1
- en: Modify `gpa` to handle "`x`" grades, which do not count in the grade-point average.
    Be careful to handle gracefully the situation where each grade is `x`.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `gpa` 以处理 "`x`" 等级，这些等级不计入平均绩点。要小心处理每个等级都是 `x` 的情况。
- en: '`(import (grades))'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '`(导入 (grades))'
- en: (gpa a x b c) ![<graphic>](ch3_0.gif) 3.0`
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: (gpa a x b c) ![<graphic>](ch3_0.gif) 3.0`
- en: Exercise 3.6.2
  id: totrans-693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.6.2
- en: Export from `(grades)` a new syntactic form, `distribution`, that takes a set
    of grades, like `gpa`, but returns a list of the form `((*n* *g*) ...)`, where
    `*n*` is the number of times `*g*` appears in the set, with one entry for each
    `*g*`. Have `distribution` call an unexported procedure to do the actual work.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `(grades)` 导出一个新的语法形式 `distribution`，它接受一组成绩，类似于 `gpa`，但返回一个形式为 `((*n* *g*) ...)`
    的列表，其中 `*n*` 是集合中 `*g*` 出现的次数，每个 `*g*` 都有一个条目。让 `distribution` 调用一个未导出的过程来执行实际工作。
- en: '`(import (grades))'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '`(导入 (grades))'
- en: (distribution a b a c c c a f b a) ![<graphic>](ch3_0.gif) ((4 a) (2 b) (3 c) (0 d) (1 f))`
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: (distribution a b a c c c a f b a) ![<graphic>](ch3_0.gif) ((4 a) (2 b) (3 c) (0 d) (1 f))`
- en: Exercise 3.6.3
  id: totrans-697
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 3.6.3
- en: Now read about output operations in Section [7.8](io.html#g129) and define a
    new export, `histogram`, as a procedure that takes a `*textual output port*` and
    a distribution, such as might be produced by `distribution`, and prints a histogram
    in the style illustrated by the example below.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 现在阅读第 [7.8](io.html#g129) 节关于输出操作的内容，并定义一个新的导出 `histogram`，作为一个过程，接受一个 `*文本输出端口*`
    和一个分布，例如 `distribution` 可能产生的，然后以示例所示的样式打印直方图。
- en: '`(import (grades))'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`(导入 (成绩))'
- en: (histogram
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: (直方图
- en: (current-output-port)
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: (当前输出端口)
- en: (distribution a b a c c a c a f b a))
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: (分布 a b a c c a c a f b a))
- en: '*prints:*'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出：*'
- en: a: *****
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: a: *****
- en: b: **
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: b: **
- en: c: ***
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: c: ***
- en: 'd:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 'd:'
- en: f: *`
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: f: *`
