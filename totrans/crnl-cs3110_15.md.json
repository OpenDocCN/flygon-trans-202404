["```\n\n  Many implementations of maps are possible. Here we use one of the simplest: *association lists*, which are lists of pairs, where each pair contains a (key,value) binding.\n\n```", "```\n\n  Once you understand this map abstraction, you're ready to understand the map abstraction provided by OCaml's standard library. Here's the documentation for version 4.01.0: [ http://caml.inria.fr/pub/docs/manual-ocaml-4.01/libref/Map.html](http://caml.inria.fr/pub/docs/manual-ocaml-4.01/libref/Map.html). Note the following differences with respect to our abstraction:\n\n    *   The input signature requires a comparison operator, generalizing our equality operator. This enables more efficient implementations of the map abstraction.\n\n    *   The output signature provides many more operations on map than our simple example did.\n\n    *   The functor does not bother to parameterize on a value type. Instead, it uses a polymorphic representation type `'a t`. The `'a` there is essentially our `value` type.\n\n    *   The implementation uses balanced binary trees instead of association lists.\n\n  You're also ready to understand the set abstraction provided by OCaml's standard library. Here's the documentation for version 4.01.0: [ http://caml.inria.fr/pub/docs/manual-ocaml-4.01/libref/Set.html](http://caml.inria.fr/pub/docs/manual-ocaml-4.01/libref/Set.html).\n\n  You should study both the Set and Map abstractions provided by OCaml to make sure you have a good understanding of functors. We suggest writing some code of your own to experiment with them!\n\n  A general implementation of polynomials\n\n  A *[ring](http://en.wikipedia.org/wiki/Ring_(mathematics))* is a mathematical structure consisting of a set of elements equipped with two operations + and * called addition and multiplication. These operations must satisfy specific requirements for the set to be a ring. The zero, written 0, is a member of the set such that for any element, a+0=a ; the one, written 1, is a member of the set such that for any element, a*1=a. See this page for more details. For instance, the set of integers with the usual + and * is a ring. The set of booleans with the or operator as + and the and operator as * is also a ring.\n\nPolynomials can be defined on any ring, since they only use the + and the * operations. We are going to define a MakePolynomial functor that takes a ring module as argument and creates a module for handling polynomials in that ring. This example was inspired by this page, and slightly modified.\n\nWe first define module types for a ring and a polynomial:\n\n```", "```\n\n  Now we can implement the MakePolynomial functor. In the following implementation, we implement polynomials using lists of (coefficient,power) pair, ordered by power; no coefficient shall be 0, and no power shall repeat. For example, the only valid implementation of 3*x^2+5 would be [(3,2);(5,0)].\n\n```", "```\n\n  Now we can create two examples with ints, and bools:\n\n```", "```\n\n  Here are examples of using the module IntPolynomial:\n\n```", "```\n\n  Finally, we can see that any set of polynomials on a variable X is itself a ring! By creating a polynomial type on that new ring, we get the polynomials in two variables, say X and Y:\n\n```", "```\n\n```", "```\n\n```"]