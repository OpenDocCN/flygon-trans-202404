- en: Church Numerals (contd.)Tuesday, February 21st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now define natural number addition — one simple idea is to get two encoded
    numbers `m` and `n`, then start with `x`, apply `f` on it `n` times by using it
    as a function, then apply `f` `m` more times on the result in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'or equivalently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another idea is to use `add1` and increment `n` by `m` using `add1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define multiplication of `m` and `n` quite easily — begin with
    addition — `(lambda (x) (+ n x))` is a function that expects an `x` and returns
    `(+ x n)` — it’s an increment-by-n function. But since all functions and applications
    are curried, this is actually the same as `(lambda (x) ((+ n) x))` which is the
    same as `(+ n)`. Now, what we want to do is repeat this operation `m` times over
    zero, which will add `n` to zero `m` times, resulting in `m` * `n`. The definition
    is therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An alternative approach is to consider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: for some encoded number `n` and a function `f` — this function is like `f`^`n`
    (f composed n times with itself). But remember that this is shorthand for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: and we know that `(lambda (x) (foo x))` is just like `foo` (if it is a function),
    so this is equivalent to just
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So `(n f)` is `f`^`n`, and in the same way `(m g)` is `g`^`m` — if we use `(n
    f)` for `g`, we get `(m (n f))` which is n self-compositions of `f`, self-composed
    m times. In other words, `(m (n f))` is a function that is like `m`*`n` applications
    of `f`, so we can define multiplication as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: which is the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The same principle can be used to define exponentiation (but now we have to
    be careful with the order since exponentiation is not commutative):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And there is a similar alternative here too —
  prefs: []
  type: TYPE_NORMAL
- en: a Church numeral `m` is the m-self-composition function,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and `(1 m)` is just like `m`^`1` which is the same as `m` (`1`=`identity`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and `(2 m)` is just like `m`^`2` — it takes a function `f`, self composes it
    `m` times, and self composes the result `m` times — for a total of `f`^`(m*m)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and `(3 m)` is similarly `f`^`(m*m*m)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: so `(n m)` is `f`^`(m^n)` (note that the first `^` is self-compositions, and
    the second one is a mathematical exponent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'so `(n m)` is a function that returns `m`^`n` self-compositions of an input
    function, Which means that `(n m)` is the Church numeral for `m`^`n`, so we get:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (define ^ (lambda (m n) (n m)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which basically says that any number encoding `n` is also the `?`^`n` operation.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is was not too complicated — but all so far all we did is write
    functions that increment their inputs in various ways. What about `sub1`? For
    that, we need to do some more work — we will need to encode booleans.
  prefs: []
  type: TYPE_NORMAL
