["```\ncheck:\n  [list: 1, 2, 3] is [list: 3, 2, 1, 1]\nend\n```", "```\ninsert-many :: (List<T>, Set<T> -> Set<T>)\n```", "```\ntype LSet = List\nmt-set = empty\n```", "```\nfun<T> size(s :: LSet<T>) -> Number:\n  s.length()\nend\n```", "```\n    [list: 1, 1]\n    ```", "```\n    [list: 1]\n    ```", "```\ninsert = link\n```", "```\nfun<T> size(s :: LSet<T>) -> Number:\n  cases (List) s:\n    | empty => 0\n    | link(f, r) =>\n      if r.member(f):\n        size(r)\n      else:\n        1 + size(r)\n      end\n  end\nend\n```", "```\n> > remove :: (Set<T>, T -> Set<T>)\n> > ```", "```\n> > one :: (Set<T> -> T)\n> > others :: (Set<T> -> T)\n> > ```", "```\n    num-expt(2, 6) * num-expt(3, 4) * num-expt(5, 5)\n    ```", "```\n    6 + 4 + 5\n    ```", "```\ndata BT:\n  | leaf\n  | node(v :: Number, l :: BT, r :: BT)\nend\n```", "```\nfun is-in-bt(e :: Number, s :: BT) -> Boolean:\n  cases (BT) s:\n    | leaf => false\n    | node(v, l, r) =>\n      if e == v:\n        true\n      else:\n        is-in-bt(e, l) or is-in-bt(e, r)\n      end\n  end\nend\n```", "```\n> > fun is-a-bst-buggy(b :: BT) -> Boolean:\n> >   cases (BT) b:\n> >     | leaf => true\n> >     | node(v, l, r) =>\n> >       (is-leaf(l) or (l.v <= v)) and\n> >       (is-leaf(r) or (v <= r.v)) and\n> >       is-a-bst-buggy(l) and\n> >       is-a-bst-buggy(r)\n> >   end\n> > end\n> > ```", "```\ncheck:\n  node(5, node(3, leaf, node(6, leaf, leaf)), leaf)\n    satisfies is-a-bst-buggy # FALSE!\nend\n```", "```\ntype BST = BT%(is-a-bst)\n```", "```\ntype TSet = BST\nmt-set = leaf\n```", "```\nfun is-in(e :: Number, s :: BST) -> Bool:\n  cases (BST) s:\n    | leaf => ...\n    | node(v, l :: BST, r :: BST) => ...\n      ... is-in(l) ...\n      ... is-in(r) ...\n  end\nend\n```", "```\nfun is-in(e :: Number, s :: BST) -> Boolean:\n  cases (BST) s:\n    | leaf => false\n    | node(v, l, r) =>\n      if e == v:\n        true\n      else if e < v:\n        is-in(e, l)\n      else if e > v:\n        is-in(e, r)\n      end\n  end\nend\n\nfun insert(e :: Number, s :: BST) -> BST:\n  cases (BST) s:\n    | leaf => node(e, leaf, leaf)\n    | node(v, l, r) =>\n      if e == v:\n        s\n      else if e < v:\n        node(v, insert(e, l), r)\n      else if e > v:\n        node(v, l, insert(e, r))\n      end\n  end\nend\n```", "```\ncheck:\n  insert(4, insert(3, insert(2, insert(1, mt-set)))) is\n  node(1, leaf,\n    node(2, leaf,\n      node(3, leaf,\n        node(4, leaf, leaf))))\nend\n```"]