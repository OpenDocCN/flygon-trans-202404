- en: Dictionaries and Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dictionaries are very similar to lists, but instead do not use indexes to reference
    values but keys.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0c0d53cc040c2f16d234cd2589f427cd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a refresher, here''s how you declare and access list values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, contrast that to the structure of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a dictionary: (The keys must be immutable, a.k.a strings, numbers,
    [tuples](https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences),
    but not lists!)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding to and Changing a dictionary key value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Useful Dictionary Operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over a dictionary's keys
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over a dictionary's values
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Deletion
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Homework Problem 7: Character Frequencies**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `char_freq()` that takes a string and builds a frequency listing
    of the characters contained in it. Represent the frequency listing as a Python
    dictionary with each letter as a key that stores the number of times that letter
    appears.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try it with something like `char_freq("abbabcbdbabdbdbabababcbcbab")`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Homework Problem 8.1: Caesar''s Ciphers**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `rotate_letters()` that takes in a number and creates a new
    mapping of lower case letters offset by that number. Return the new mapping as
    a dictionary such that the original letter is mapped to the shifted letter. For
    example, `rotate_letters(2)` would map `'a'`->`'c'`, `'b'`->`'d'`, `'c'`->`'e'`
    and so on.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Homework Problem 8.2: Caesar''s Ciphers**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `decode_cipher()` that takes in a dictionary of letter mappings
    and a cipher string (of only lower case letters). Return the decoded string that
    is created when every character is replaced by its mapping from the dictionary
    For example, `decode_cipher(rotate_letters(2), "abc")` should return `"cde"`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use this function to decode "jbj fpurzr vf terng" given that the letters had
    been shifted by 13.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now all the tools to learn a new topic which is called memoization!
    Memoization is the act of storing answers to computations (particularly computationally
    expensive ones) as you compute things so that if you are required to repeat that
    computation, you already have a memoized answer. Memoization is often seen in
    the context of improving the efficiency of a slow recursive process that makes
    repetitive computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the fibbonacci function which generates the nth fibbonacci number
    in the sequence. Recursively, the brute force definition of that process looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If n is sufficiently large, you'll be waiting a long time for fib to return.
    Consider that case the n is 5. We'll have to compute fib(5-2) and separately fib(5-1).
    But in computing fib(5-1) we'll have to recompute fib(5-2). Following this logic,
    you can see we'll end up with many unneccessary recomputations.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the recursion tree generated by calling fib(6). Can you spot
    all the overlapping computations?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9d7ca612333db0e774e186ffc09e1859.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To reduce our inefficiency, we should cache, or store, computations as they
    complete. Then, before doing any computation, we simple check our cache for whether
    we had already done that computation. Our cache can be created with a dictionary!
    The keys will correspond to the argument value and the values will correspond
    to the calculated computation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is kind of messy because the cache exists outside of your function. Alternatively,
    you can wrap the cache and function so that it is memoized within each call to
    the wrapper function. The cache will reset for each call to `memo_fib()` but at
    least within one call memoization occurs. In project 4, you'll write a better
    memoization routine that is less messy yet still memoized between calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Homework Problem 9: Memoized Product of Factorials**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a memoized accumulated product of factorials procedure in a similar fashion
    to `memo_fib`. You MUST use recursion.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Accumulated Factorial of 5 = 5! * 4! * 3! * 2! * 1!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
