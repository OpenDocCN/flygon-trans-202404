- en: Alternative Church EncodingTuesday, February 21st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, note that this is just one way to encode things — other encodings are
    possible. One alternative encoding is in the following code — it uses a list of
    `N` falses as the encoding for `N`. This encoding makes it easier to `add1` (just
    `cons` another `#f`), and to `sub1` (simply `cdr`). The tradeoff is that some
    arithmetics operations becomes more complicated, for example, the definition of
    `+` requires the fixpoint combinator. (As expected, some people want to see what
    can we do with a language without recursion, so they don’t like jumping to Y too
    fast.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting way to implement lists follows the pattern matching approach,
    where both pairs and the null value are represented by a function that serves
    as a kind of a `match` dispatcher. This function takes in two inputs — if it is
    the representation of null then it will return the first input, and if it is a
    pair, then it will apply the second input on the two parts of the pair. This is
    implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This might seem awkward, but it follows the intended use of pairs and null
    as a match-like construct. Here is an example, with the equivalent Racket code
    on the side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, it’s easy to implement our selectors and predicate using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The same approach can be used to define any kind of new data type in a way
    that looks like our own `define-type` definitions. For example, consider a much-simplified
    definition of the AE type we’ve seen early in the semester, and a matching `eval`
    definition as an example for using `cases`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the above approach now to write Schlac code that more than being
    equivalent, it’s also very similar in nature. Note that the type definition is
    replaced by two definitions for the two constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
