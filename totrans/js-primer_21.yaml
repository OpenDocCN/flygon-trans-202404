- en: 文字列
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/string/](https://jsprimer.net/basic/string/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: この章ではJavaScriptにおける文字列について学んでいきます。 まずは、文字列の作成方法や文字列の操作方法について見ていきます。 そして、文字列を編集して自由に文字列を作れるようになることがこの章の目的です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#create)*文字列を作成する*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列を作成するには、文字列リテラルを利用します。 「[データ型とリテラル](../data-type/)」の章でも紹介しましたが、文字列リテラルには`"`（ダブルクォート）、`''`（シングルクォート）、[PRE0]'
  prefs: []
  type: TYPE_NORMAL
- en: const double = "文字列";
  prefs: []
  type: TYPE_NORMAL
- en: console.log(double); // => "文字列"
  prefs: []
  type: TYPE_NORMAL
- en: const single = '文字列';
  prefs: []
  type: TYPE_NORMAL
- en: console.log(single); // => '文字列'
  prefs: []
  type: TYPE_NORMAL
- en: // どちらも同じ文字列
  prefs: []
  type: TYPE_NORMAL
- en: console.log(double === single);// => true
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]（バッククォート）が追加されました。 [PRE2]'
  prefs: []
  type: TYPE_NORMAL
- en: const multiline = `1行目
  prefs: []
  type: TYPE_NORMAL
- en: 2行目
  prefs: []
  type: TYPE_NORMAL
- en: 3行目`;
  prefs: []
  type: TYPE_NORMAL
- en: // \n は改行を意味する
  prefs: []
  type: TYPE_NORMAL
- en: console.log(multiline); // => "1行目\n2行目\n3行目"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: const str = "This book is \"js-primer\"";
  prefs: []
  type: TYPE_NORMAL
- en: console.log(str); // => 'This book is "js-primer"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: // JavaScriptエンジンが構文として解釈できないため、SyntaxErrorとなる
  prefs: []
  type: TYPE_NORMAL
- en: const invalidString = "1行目
  prefs: []
  type: TYPE_NORMAL
- en: 2行目
  prefs: []
  type: TYPE_NORMAL
- en: 3行目";
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]（バッククォート）すべての文字列リテラルの中で利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '| エスケープシーケンス | 意味 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\''` | シングルクォート |'
  prefs: []
  type: TYPE_TB
- en: '| `\"` | ダブルクォート |'
  prefs: []
  type: TYPE_TB
- en: '| `\`` | バッククォート |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | バックスラッシュ(`\`そのものを表示する) |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | 改行 |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | タブ |'
  prefs: []
  type: TYPE_TB
- en: '| `\uXXXX` | Code Unit(`\u`と4桁のHexDigit) |'
  prefs: []
  type: TYPE_TB
- en: '| `\u{X}` ... `\u{XXXXXX}` | Code Point（`\u{}`のカッコ中にHexDigit） |'
  prefs: []
  type: TYPE_TB
- en: このエスケープシーケンスを利用することで、先ほどの`"`（ダブルクォート）の中に改行（`\n`）を入力できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: また、`\`からはじまる文字は自動的にエスケープシーケンスとして扱われます。 しかし、`\a`のように定義されていないエスケープシーケンスは、`\`が単に無視され`a`という文字列として扱われます。
    これにより、`\`（バックスラッシュ）そのものを入力していたつもりが、その文字がエスケープシーケンスとして扱われてしまう問題があります。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`\_`という組み合わせのエスケープシーケンスはないため、`\`が無視された文字列として評価されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`\`（バックスラッシュ）そのものを入力したい場合は、`\\`のようにエスケープする必要があります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[](#concat)*文字列を結合する*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列を結合する簡単な方法は文字列結合演算子（`+`）を使う方法です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 変数と文字列を結合したい場合も文字列結合演算子で行えます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 特定の書式に文字列を埋め込むには、テンプレートリテラルを使うとより宣言的に書けます。
  prefs: []
  type: TYPE_NORMAL
- en: テンプレートリテラル中に`${変数名}`で書かれた変数は評価時に展開されます。 つまり、先ほどの文字列結合は次のように書けます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[](#get-char)*文字へのアクセス*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列の特定の位置にある文字にはインデックスを指定してアクセスできます。 これは、配列における要素へのアクセスにインデックスを指定するのと同じです。'
  prefs: []
  type: TYPE_NORMAL
- en: 文字列では`文字列[インデックス]`のように指定した位置（インデックス）の文字へアクセスできます。 インデックスの値は`0`以上`2^53 - 1`未満の整数が指定できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: また、存在しないインデックスへのアクセスでは配列やオブジェクトと同じように`undefined`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[](#string-at)*[ES2022] `String.prototype.at`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ES2022から`String.prototype.at`メソッドが追加されています。 Stringの`at`メソッドは、Arrayの`at`メソッドと同じく、相対的なインデックスを渡してその位置の文字へアクセスできます。
    `at`メソッドへ`-1`のようにマイナスのインデックスを渡した場合は、末尾から数えた位置の文字へアクセスできます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[](#what-is-string)*文字列とは*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*今まで何気なく「文字列」という言葉を利用していましたが、ここでいう文字列とはどのようなものでしょうか？　コンピュータのメモリ上に文字列の「ア」といった文字をそのまま保存できないため、0と1からなるビット列へ変換する必要があります。
    この文字からビット列へ変換することを符号化（エンコード）と呼びます。'
  prefs: []
  type: TYPE_NORMAL
- en: 一方で、変換後のビット列が何の文字なのかを管理する表が必要になります。 この文字に対応するIDの一覧表のことを符号化文字集合と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: 次の表は、Unicodeという文字コードにおける符号化文字集合からカタカナの一部分を取り出したものです。^([1](#fn_1)) Unicodeはすべての文字に対してID（Code
    Point）を振ることを目的に作成されている仕様です。
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 30A0 | ゠ | ァ | ア | ィ | イ | ゥ | ウ | ェ | エ | ォ | オ | カ | ガ | キ | ギ | ク |'
  prefs: []
  type: TYPE_TB
- en: '| 30B0 | グ | ケ | ゲ | コ | ゴ | サ | ザ | シ | ジ | ス | ズ | セ | ゼ | ソ | ゾ | タ |'
  prefs: []
  type: TYPE_TB
- en: '| 30C0 | ダ | チ | ヂ | ッ | ツ | ヅ | テ | デ | ト | ド | ナ | ニ | ヌ | ネ | ノ | ハ |'
  prefs: []
  type: TYPE_TB
- en: JavaScript（ECMAScript）は文字コードとしてUnicodeを採用し、文字をエンコードする方式としてUTF-16を採用しています。 UTF-16とは、それぞれの文字を16ビットのビット列に変換するエンコード方式です。
    Unicodeでは1文字を表すのに使う最小限のビットの組み合わせを**Code Unit**（符号単位）と呼び、UTF-16では各Code Unitのサイズが16ビット（2バイト）です。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードは、文字列を構成するCode Unitをhex値（16進数）にして表示する例です。 Stringの`charCodeAt`メソッドは、文字列の指定インデックスのCode
    Unitを整数として返します。 そのCode Unitの整数値をNumberの`toString`メソッドでhex値（16進数）にしています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 逆に、Code Unitをhex値（16進数）から文字へと変換するには`String.fromCharCode`メソッドを使います。 次のコードでは、16進数の整数リテラルである`0x`で記述したCode
    Unitから文字列へと変換しています （`0x`リテラルについては「[データ型とリテラル](../data-type/)」の章を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: これらの結果をまとめると、この文字列と文字列を構成するUTF-16のCode Unitとの関係は次のようになります。
  prefs: []
  type: TYPE_NORMAL
- en: '| インデックス | 0 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 文字列 | ア | オ | イ |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-16のCode Unit（16進数） | 0x30A2 | 0x30AA | 0x30A4 |'
  prefs: []
  type: TYPE_TB
- en: このように、JavaScriptにおける文字列は16ビットのCode Unitが順番に並んだものとして内部的に管理されています。 これは、ECMAScriptの内部表現としてUTF-16を採用しているだけで、JavaScriptファイル（ソースコードを書いたファイル）のエンコーディングとは関係ありません。そのため、JavaScriptファイル自体のエンコードは、UTF-16以外の文字コードであっても問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: UTF-16を利用していることはJavaScriptの内部的な表現であるため、気にする必要がないようにも思えます。 しかし、このJavaScriptがUTF-16を利用していることは、これから見ていくStringのAPIにも影響しています。
    このUTF-16と文字列については、次の章である「[文字列とUnicode](../string-unicode/)」で詳しく見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: ここでは、「JavaScriptの文字列の各要素はUTF-16のCode Unitで構成されている」ということだけを覚えておけば問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#split-join)*文字列の分解と結合*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列を配列へ分解するにはStringの`split`メソッドを利用できます。 一方、配列の要素を結合して文字列にするにはArrayの`join`メソッドを利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: この２つはよく組み合わせて利用されるため、合わせて見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: Stringの`split`メソッドは、第一引数に指定した区切り文字で文字列を分解した配列を返します。 次のコードでは、文字列を`・`で区切った配列を作成しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 分解してできた文字列の配列を結合して文字列を作る際に、Arrayの`join`メソッドが利用できます。 Arrayの`join`メソッドの第一引数には区切り文字を指定し、その区切り文字で結合した文字列を返します。
  prefs: []
  type: TYPE_NORMAL
- en: この２つを合わせれば、区切り文字を`・`から`、`へ変換する処理を次のように書くことができます。 `・`で文字列を分割（`split`）してから、区切り文字を`、`にして結合（`join`）すれば変換できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Stringの`split`メソッドの第一引数には正規表現も指定できます。 これを利用すると、次のように文字列をスペースで区切るような処理を簡単に書けます。
    `/\s+/`は1つ以上のスペースにマッチする正規表現オブジェクトを作成する正規表現リテラルです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[](#length)*文字列の長さ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Stringの`length`プロパティは文字列の要素数を返します。 文字列の構成要素はCode Unitであるため、`length`プロパティはCode
    Unitの個数を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: 次の文字列は3つの要素（Code Unit）が並んだものであるため、`length`プロパティは`3`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: また、空文字列は要素数が`0`であるため、`length`プロパティの結果も`0`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[](#compare)*文字列の比較*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列の比較には`===`（厳密比較演算子）を利用します。 次の条件を満たしていれば同じ文字列となります。'
  prefs: []
  type: TYPE_NORMAL
- en: 文字列の要素であるCode Unitが同じ順番で並んでいるか
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 文字列の長さ（length）は同じか
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 難しく書いていますが、同じ文字列同士なら`===`（厳密比較演算子）の結果は`true`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: また、`===`などの比較演算子だけではなく、 `>`、`<`、`>=`、`<=`など大小の関係演算子で文字列同士の比較もできます。
  prefs: []
  type: TYPE_NORMAL
- en: これらの関係演算子も、文字列の要素であるCode Unit同士を先頭から順番に比較します。 文字列からCode Unitの数値を取得するには、Stringの`charCodeAt`メソッドを利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`ABC`と`ABD`を比較した場合にどちらが大きい（Code Unitの値が大きい）かを比較しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: このように、関係演算子での文字列比較はCode Unit同士を比較しています。 この結果を予測することは難しく、また直感的ではない結果が生まれることも多いです。
    文字の順番は国や言語によっても異なるため、国際化（Internationalization）に関する知識も必要です。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptにおいても、[ECMA-402](https://www.ecma-international.org/publications-and-standards/standards/ecma-402/
    "Standard ECMA-402")というECMAScriptと関連する別の仕様として国際化についての取り決めがされています。 この国際化に関するAPIを定義した[Intl](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Intl)というビルトインオブジェクトもありますが、このAPIについての詳細は省略します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#slice)*文字列の一部を取得*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列からその一部を取り出したい場合には、Stringの`slice`メソッドや`substring`メソッドが利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`slice`メソッドについては、すでに配列で学んでいますが、基本的な動作は文字列でも同様です。 まずは`slice`メソッドについて見ていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: Stringの`slice`メソッドは、第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい文字列を返します。
    第二引数は省略でき、省略した場合は文字列の末尾まで含んだ新しい文字列を返します。
  prefs: []
  type: TYPE_NORMAL
- en: 位置にマイナスの値を指定した場合は文字列の末尾から数えた位置となります。 また、第一引数の位置が第二引数の位置より大きい場合、常に空の文字列を返します。
  prefs: []
  type: TYPE_NORMAL
- en: そのため、メソッドの引数の扱い方は[配列の`slice`メソッド](../array/#slice)と同様です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Stringの`substring`メソッドは、`slice`メソッドと同じく第一引数に開始位置、第二引数に終了位置を指定し、その範囲を取り出して新しい文字列を返します。
    第二引数を省略した場合の挙動も同様で、省略した場合は文字列の末尾が終了位置となります。
  prefs: []
  type: TYPE_NORMAL
- en: '`slice`メソッドとは異なる点として、位置にマイナスの値を指定した場合は常に`0`として扱われます。 また、第一引数の位置が第二引数の位置より大きい場合、第一引数と第二引数が入れ替わるという予想しにくい挙動となります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: このように、マイナスの位置や引数が交換される挙動はわかりやすいものとは言えません。 そのため、`slice`メソッドと`substring`メソッドに指定する引数は、どちらとも同じ結果となる範囲に限定したほうが直感的な挙動となります。
    つまり、指定するインデックスは0以上にして、第二引数を指定する場合は`第一引数の位置 < 第二引数の位置`にするということです。
  prefs: []
  type: TYPE_NORMAL
- en: Stringの`slice`メソッドは、`indexOf`メソッドなどの位置を取得するものと組み合わせて使うことが多いでしょう。 次のコードでは、`?`の位置を`indexOf`メソッドで取得し、それ以降の文字列を`slice`メソッドで切り出しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: また、配列とは異なりプリミティブ型の値である文字列は、`slice`メソッドと`substring`メソッド共に非破壊的です。 機能的な違いがほとんどないため、どちらを利用するかは好みの問題となるでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#search)*文字列の検索*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列の検索方法として、大きく分けて文字列による検索と正規表現による検索があります。'
  prefs: []
  type: TYPE_NORMAL
- en: 指定した文字列が文字列中に含まれているかを検索する方法として、Stringメソッドには取得したい結果ごとにメソッドが用意されています。 ここでは、次の3種類の結果を取得する方法について文字列と正規表現それぞれの検索方法を見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: マッチした箇所のインデックスを取得
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: マッチした文字列の取得
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: マッチしたかどうかの真偽値を取得
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](#search-by-string)*文字列による検索*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`String`オブジェクトには、指定した文字列で検索するメソッドが用意されています。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#search-index-by-string)*文字列によるインデックスの取得*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Stringの`indexOf`メソッドと`lastIndexOf`メソッドは、指定した文字列で検索し、その文字列が最初に現れたインデックスを返します。
    これらは配列のArrayの`indexOf`メソッドと同じで、厳密等価演算子（`===`）で文字列を検索します。 一致する文字列がない場合は`-1`を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: '`文字列.indexOf("検索文字列")`: 先頭から検索し、指定された文字列が最初に現れたインデックスを返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`文字列.lastIndexOf("検索文字列")`: 末尾から検索し、指定された文字列が最初に現れたインデックスを返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: どちらのメソッドも一致する文字列が複数個ある場合でも、指定した検索文字列を最初に見つけた時点で検索は終了します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[](#match-by-string)*文字列にマッチした文字列の取得*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*文字列を検索してマッチした文字列は、検索文字列そのものになるので自明です。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは`"Script"`という文字列で検索していますが、その検索文字列にマッチする文字列はもちろん`"Script"`になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[](#test-by-string)*真偽値の取得*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*「文字列」に「検索文字列」が含まれているかを検索する方法がいくつか用意されています。 次の3つのメソッドはES2015で導入されました。'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.startsWith(検索文字列)`^([ES2015]): 検索文字列が先頭にあるかの真偽値を返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.endsWith(検索文字列)`^([ES2015]): 検索文字列が末尾にあるかの真偽値を返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.includes(検索文字列)`^([ES2015]): 検索文字列を含むかの真偽値を返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 具体的な例をいくつか見てみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[](#regexp-object)*正規表現オブジェクト*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列による検索では、固定の文字列にマッチするものしか検索できません。 一方で正規表現による検索では、あるパターン（規則性）にマッチするという柔軟な検索ができます。'
  prefs: []
  type: TYPE_NORMAL
- en: 正規表現は正規表現オブジェクト（`RegExp`オブジェクト）として表現されます。 正規表現オブジェクトはマッチする範囲を決める`パターン`と正規表現の検索モードを指定する`フラグ`の2つで構成されます。
    正規表現のパターン内では、次の文字は**特殊文字**と呼ばれ、特別な意味を持ちます。特殊文字として解釈されないように入力する場合には`\`（バックスラッシュ）でエスケープする必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 正規表現オブジェクトを作成するには、正規表現リテラルと`RegExp`コンストラクタを使う2つの方法があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 正規表現リテラルは、`/`と`/`のリテラル内に正規表現のパターンを書くことで、正規表現オブジェクトを作成できます。 次のコードでは、`+`という1回以上の繰り返しを意味する特殊文字を使い、`a`が1回以上連続する文字列にマッチする正規表現オブジェクトを作成しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 正規表現オブジェクトを作成するもうひとつの方法として`RegExp`コンストラクタがあります。 `RegExp`コンストラクタでは、文字列から正規表現オブジェクトを作成できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`RegExp`コンストラクタを使って`a`が1文字以上連続している文字列にマッチする正規表現オブジェクトを作成しています。 これは先ほどの正規表現リテラルで作成した正規表現オブジェクトと同じ意味になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[](#difference-regexp-literal-regexp-constructor)*正規表現リテラルと`RegExp`コンストラクタの違い*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*正規表現リテラルと`RegExp`コンストラクタの違いとして、正規表現のパターンが評価されるタイミングの違いがあります。 正規表現リテラルは、ソースコードをロード（パース）した段階で正規表現のパターンが評価されます。
    一方で、`RegExp`コンストラクタでは通常の関数と同じように、`RegExp`コンストラクタを呼び出すまで正規表現のパターンは評価されません。'
  prefs: []
  type: TYPE_NORMAL
- en: 単独の`[`という不正なパターンである正規表現を例に、評価されているタイミングの違いを見てみます。 `[`は対になる`]`と組み合わせて利用する特殊文字であるため、正規表現のパターンに単独で書くと構文エラーの例外が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: 正規表現リテラルは、ソースコードのロード時に正規表現のパターンが評価されるため、 次のように`main`関数を呼び出していなくても構文エラー（`SyntaxError`）が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 一方で、`RegExp`コンストラクタは実行時に正規表現のパターンが評価されるため、 `main`関数を呼び出すことで初めて構文エラー（`SyntaxError`）が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: これを言い換えると、正規表現リテラルはコードを書いた時点で決まったパターンの正規表現オブジェクトを作成する構文です。 一方で、`RegExp`コンストラクタは変数と組み合わせるなど、実行時に変わることがあるパターンの正規表現オブジェクトを作成できます。
  prefs: []
  type: TYPE_NORMAL
- en: 例として、指定個数のホワイトスペース（空白文字）が連続した場合にマッチする正規表現オブジェクトで比較してみます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、正規表現リテラルを使って3つ連続するホワイトスペースにマッチする正規表現オブジェクトを作成しています。 `\s`はスペースやタブなどのホワイトスペースにマッチする特殊文字です。
    また、`{数字}`は指定した回数だけ繰り返しを意味する特殊文字です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 正規表現リテラルは、ロード時に正規表現のパターンが評価されるため、`\s`の連続する回数を動的に変更することはできません。 一方で、`RegExp`コンストラクタは、実行時に正規表現のパターンが評価されるため、変数を含んだ正規表現オブジェクトを作成できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`RegExp`コンストラクタで変数`spaceCount`の数だけ連続するホワイトスペースにマッチする正規表現オブジェクトを作成しています。
    注意点として、`\`（バックスラッシュ）自体が、文字列中ではエスケープ文字であることに注意してください。 そのため、`RegExp`コンストラクタの引数のパターン文字列では、バックスラッシュからはじまる特殊文字は`\`（バックスラッシュ）自体をエスケープする必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: このように、`RegExp`コンストラクタは文字列から正規表現オブジェクトを作成できますが、特殊文字のエスケープが必要となります。 そのため、正規表現リテラルで表現できる場合は、リテラルを利用したほうが簡潔でパフォーマンスもよいです。
    正規表現のパターンに変数を利用する場合などは、`RegExp`コンストラクタを利用します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#search-by-regexp)*正規表現による検索*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*正規表現による検索は、正規表現オブジェクトと対応した`String`オブジェクトまたは`RegExp`オブジェクトのメソッドを利用します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#search-index-by-regexp)*正規表現によるインデックスの取得*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Stringの`indexOf`メソッドの正規表現版ともいえるStringの`search`メソッドがあります。 `search`メソッドは正規表現のパターンにマッチした箇所のインデックスを返し、マッチする文字列がない場合は`-1`を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.indexOf(検索文字列)`: 指定された文字列にマッチした箇所のインデックスを返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.search(/パターン/)`: 指定された正規表現のパターンにマッチした箇所のインデックスを返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 次のコードでは、数字が3つ連続しているかを検索し、該当した箇所のインデックスを返しています。 `\d`は、1文字の数字（`0`から`9`）にマッチする特殊文字です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[](#match-by-regexp)*正規表現によるマッチした文字列の取得*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*文字列による検索では、検索した文字列そのものがマッチした文字列になります。 しかし、`search`メソッドの正規表現による検索は、正規表現パターンによる検索であるため、検索してマッチした文字列の長さは固定ではありません。
    つまり、次のようにStringの`search`メソッドでマッチしたインデックスのみを取得しても、実際にマッチした文字列がわかりません。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: そのため、マッチした文字列を取得するStringの`match`メソッドと`matchAll`メソッドが用意されています。 また、これらのメソッドは正規表現のマッチを文字列の最後まで繰り返す`g`フラグ（globalの略称）によって挙動が変わります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#match)*マッチした文字列の取得*'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*まずは、マッチした文字列を取得するStringの`match`メソッドから見ていきます。 `match`メソッドは、正規表現の`/パターン/`が`"文字列"`にマッチすると、マッチした文字列に関する情報を返すメソッドです。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`match`メソッドで検索した結果、正規表現にマッチする文字列がなかった場合は`null`を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`match`メソッドは正規表現の`g`フラグなしのパターンで検索した場合、最初にマッチしたものが見つかった時点で検索が終了します。 このときの`match`メソッドの返り値は、`index`プロパティと`input`プロパティをもった特殊な配列となります。
    `index`プロパティにはマッチした文字列の先頭のインデックスが、`input`プロパティには検索対象となった文字列全体が含まれています。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`/[a-zA-Z]+/`という正規表現は`a`から`Z`のどれかの文字が1つ以上連続しているものにマッチします。 この正規表現にマッチした文字列は、返り値の配列からインデックスアクセスで取得できます。
    `g`フラグなしでは、最初にマッチしたものを見つけた時点で検索が終了するので、返り値の配列には1つの要素しか含まれていません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`match`メソッドは正規表現の`g`フラグありのパターンで検索した場合、マッチしたすべての文字列を含んだ配列を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`/[a-zA-Z]+/g`という正規表現は`a`から`Z`のどれかの文字が1つ以上連続しているものに繰り返しマッチします。 この正規表現にマッチする箇所は"ABC"と"DE"の2つとなるため、`match`メソッドの返り値である配列にも2つの要素が含まれています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: このときの`match`メソッドの返り値である配列には`index`と`input`プロパティはありません。 なぜなら、複数の箇所にマッチする場合においては、1つの`index`プロパティでは意味が一意に決まらないためです。
  prefs: []
  type: TYPE_NORMAL
- en: Stringの`match`メソッドの挙動をまとめると次のようになります。
  prefs: []
  type: TYPE_NORMAL
- en: マッチしない場合は、`null`を返す
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: マッチした場合は、マッチした文字列を含んだ特殊な配列を返す
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 正規表現の`g`フラグがある場合は、マッチしたすべての結果を含んだただの配列を返す
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2020では、正規表現の`g`フラグを使った繰り返しマッチする場合においても、それぞれマッチした文字列ごとの情報を得るためのStringの`matchAll`が追加されています。
    `matchAll`メソッドは、マッチした結果をIteratorで返します。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`matchAll`メソッドでアルファベットにマッチする結果のIteratorオブジェクトを取得しています。 Iteratorオブジェクトは`for...of`構文で反復処理すると、Iteratorから値を1つずつ取り出して処理できます（詳細は「[ループと反復処理](../loop/)」の章を参照）。
    このときの反復処理で取得できる値は、それぞれのマッチした文字列と`index`と`input`プロパティを持つ特殊な配列となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: そのため、正規表現の`g`フラグを使った繰り返しマッチを行う場合には、`match`メソッドではなく`matchAll`メソッドを利用します。 また、`matchAll`メソッドは`g`フラグなしの正規表現はサポートしていないため、`g`フラグなしの正規表現を渡した場合は例外が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#match-capture-by-regexp)*マッチした文字列の一部を取得*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Stringの`match`メソッドと`matchAll`メソッドは、どちらも正規表現のキャプチャリングに対応しています。 キャプチャリングとは、正規表現中で`/パターン1(パターン2)/`のようにカッコで囲んだ部分を取り出すことです。
    このキャプチャリングによって、正規表現でマッチした一部分だけを取り出せます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`match`メソッドと`matchAll`メソッドはどちらもマッチした結果を配列として返します。'
  prefs: []
  type: TYPE_NORMAL
- en: そのマッチしているパターンにキャプチャが含まれている場合は、返り値の配列へキャプチャした部分が追加されていきます。 配列の先頭にはマッチした文字列全体が入り、順番にキャプチャリング（`(`と`)`）で囲んだ範囲が配列に含まれます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは、`ECMAScript 数字`の`数字`部分だけを取り出そうとしています。 Stringの`match`メソッドとキャプチャリングによって数字(`\d+`)にマッチする部分を取り出しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 正規表現の`g`フラグを使い繰り返し文字列にマッチする場合には、`matchAll`メソッドを利用します。 先ほども紹介したように、`match`メソッドは繰り返しマッチした場合に、それぞれ個別のマッチした情報を取得できないためです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`ES数字`の数字(`\d+`)にマッチする部分を取り出しています。 `matchAll`の返り値であるIteratorを反復処理することで、それぞれマッチしたキャプチャを取り出しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[](#regexp-exec)*[コラム] RegExp.prototype.execでのString.prototype.matchAll*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Stringの`matchAll`メソッドは、ES2020で導入されたメソッドです。 それまでは、RegExpの`exec`メソッドというStringの`match`メソッドによく似た挙動をするメソッドを利用して、Stringの`matchAll`メソッド相当の表現を実装していました。'
  prefs: []
  type: TYPE_NORMAL
- en: RegExpの`exec`メソッドは、引数に文字列を受け取るメソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: RegExpの`exec`メソッドは`g`フラグなしのパターンで検索した場合、マッチした最初の結果のみを含む特殊な配列を返します。 このときの`exec`メソッドの返り値である配列が`index`プロパティと`input`プロパティが追加された特殊な配列となるのは、Stringの`match`メソッドと同様です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: RegExpの`exec`メソッドは`g`フラグありのパターンで検索した場合も、マッチした最初の結果のみを含む特殊な配列を返します。 この点はStringの`match`メソッドとは異なります。
    また、最後にマッチした文字列末尾のインデックスを正規表現オブジェクトの`lastIndex`プロパティに記録します。 そしてもう一度`exec`メソッドを呼び出すと最後にマッチした末尾のインデックス（`lastIndex`プロパティの位置）から検索が開始されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: RegExpの`exec`メソッドの挙動をまとめると次のようになります。 正規表現の`g`フラグがない場合は、Stringの`match`メソッドと同じ結果です。
    一方で、正規表現の`g`フラグがある場合は、Stringの`match`メソッドとは異なる挙動をします。
  prefs: []
  type: TYPE_NORMAL
- en: マッチしない場合は、`null`を返す
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: マッチした場合は、マッチした文字列を含んだ特殊な配列を返す
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 正規表現の`g`フラグがある場合は、マッチした文字列を含んだ特殊な配列を返し、マッチした末尾のインデックスを正規表現オブジェクトの`lastIndex`プロパティに記録する
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: この正規表現の`g`フラグと`exec`メソッドで検索した場合に、`lastIndex`プロパティが検索ごとに更新される仕組みを利用して、マッチするすべての結果を取得できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、RegExpの`exec`メソッドを使い、アルファベットにマッチした結果を`matches`に保持しています。 `g`フラグがある場合の`exec`メソッドでは最後にマッチした位置が記録されているため、`while`文で反復処理して続きから検索しています。
    また、`exec`メソッドはマッチしなければ`null`を返すため、マッチするものがなくなればwhile文から自動的に脱出します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: このようにRegExpの`exec`メソッドと正規表現の`g`フラグを使い、Stringの`matchAll`メソッド相当の反復処理を実装していました。
    RegExpの`exec`はIteratorオブジェクトという反復処理のためのオブジェクトが導入される以前からあるメソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: Stringの`matchAll`がIteratorを扱うわかりやすい反復処理に比べて、RegExpの`exec`メソッドは`while`文などで手動で反復処理を書く必要があるため直感的ではありません。
    そのため、Stringの`matchAll`メソッドが利用できる場合に、RegExpの`exec`メソッドを利用する必要はありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#test-by-regexp)*真偽値を取得*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*正規表現オブジェクトを使って、そのパターンにマッチするかをテストするには、RegExpの`test`メソッドを利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 正規表現のパターンには、パターンの位置を指定する特殊文字があります。 そのため、「文字列による検索」で登場したメソッドは、特殊文字とRegExpの`test`メソッドで表現できます。
  prefs: []
  type: TYPE_NORMAL
- en: 'Stringの`startsWith`相当: `/^パターン/.test(文字列)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^` は先頭に一致する特殊文字'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stringの`endsWith`相当: `/パターン$/.test(文字列)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` は末尾に一致する特殊文字'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stringの`includes`相当: `/パターン/.test(文字列)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 具体的な例を見てみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: そのほかにも、正規表現では繰り返しや文字の集合などを特殊文字で表現できるため柔軟な検索が可能です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#string-or-regexp)*文字列と正規表現どちらを使うべきか*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Stringメソッドでの検索と同等のことは、正規表現でもできることがわかりました。 Stringメソッドと正規表現で同じ結果が得られる場合はどちらを利用するのがよいでしょうか？'
  prefs: []
  type: TYPE_NORMAL
- en: 正規表現は曖昧な検索に強く、特殊文字を使うことで柔軟な検索結果を得られます。 一方、曖昧であるため、コードを見ても何を検索しているかが正規表現のパターン自体からわからないことがあります。
  prefs: []
  type: TYPE_NORMAL
- en: 次の例は、`/`からはじまり`/`で終わる文字列かを判定しようとしています。 この判定を正規表現とStringメソッドを使ってそれぞれ実装しています （これは意図的に正規表現に不利な例となっています）。
  prefs: []
  type: TYPE_NORMAL
- en: 正規表現の場合、`/^\/.*\/$/`のようにパターンそのものを見ても何をしたいのかはひと目ではわかりにくいです。 Stringメソッドの場合は、`/`からはじまり`/`で終わるかを判定してることがそのままコードに表現できています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: このように、正規表現は柔軟で便利ですが、コード上から意図が消えてしまいやすいです。 そのため、正規表現を扱う際にはコメントや変数名で具体的な意図を補足したほうがよいでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: 「Stringメソッドと正規表現で同じ結果が得られる場合はどちらを利用するのがよいでしょうか？」という疑問に戻ります。 Stringメソッドで表現できることはStringメソッドで表現し、柔軟性や曖昧な検索が必要な場合はコメントとともに正規表現を利用するという方針を推奨します。
  prefs: []
  type: TYPE_NORMAL
- en: '正規表現についてより詳しくは[MDNの正規表現ドキュメント](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Regular_Expressions
    "正規表現 - JavaScript | MDN")や、コンソールで実行しながら試せる[regex101](https://regex101.com/ "Online
    regex tester and debugger: PHP, PCRE, Python, Golang and JavaScript")のようなサイトを参照してください。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#replace-delete)*文字列の置換/削除*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*文字列の一部を置換したり削除するにはStringの`replace`メソッドを利用します。 「[データ型とリテラル](../data-type/)」で説明したようにプリミティブ型である文字列は不変な特性を持ちます。
    そのため、文字列から一部の文字を削除するような操作はできません。'
  prefs: []
  type: TYPE_NORMAL
- en: つまり、`delete`演算子は文字列に対して利用できません。 strict modeでは、`delete`演算子で削除できないプロパティを削除しようとするとエラーが発生します。
    strict modeでない場合は、エラーも発生せず単に無視されます（詳細は「[JavaScriptとは](../introduction/)」の[strict
    mode](../introduction/#strict-mode)を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 代わりに、Stringの`replace`メソッドで、削除したい文字を取り除いた新しい文字列を返すことで削除を表現します。 `replace`メソッドは、**文字列**から第一引数の`検索文字列`または正規表現にマッチする部分を、第二引数の`置換文字列`へ置換します。
    第一引数には、文字列と正規表現を指定できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 次のように、`replace`メソッドで削除したい部分を空文字列へ置換することで、文字列を削除できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`replace`メソッドには正規表現も指定できます。 `g`フラグを有効化した正規表現を渡すことで、文字列からパターンにマッチするものをすべて置換できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 文字列から検索文字列にマッチするものをすべて置換する場合には、ES2021で追加されたStringの`replaceAll`メソッドも利用できます。 `replace`メソッドでは、最初に一致したものだけが置換されますが、`replaceAll`メソッドでは一致したものがすべて置換されます。
  prefs: []
  type: TYPE_NORMAL
- en: Stringの`replace`と`g`フラグ付きの正規表現を使った場合との違いとして、 Stringの`replaceAll`メソッドでは、正規表現ではなく文字列を使ってすべてを置換できます。
    そのため、正規表現では特殊な意味を持つ`?`のような文字列も検索文字列にそのまま書いて置換ができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`replace`メソッドと`replaceAll`メソッドでは、キャプチャした文字列を利用して複雑な置換処理もできます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`replace`メソッドと`replaceAll`メソッドの第二引数にはコールバック関数を渡せます。 第一引数の`パターン`にマッチした部分がコールバック関数の返り値で置換されます。
    コールバック関数の第一引数には`パターン`に一致した文字列全体、第二引数以降へキャプチャした文字列が順番に入ります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 例として、`2017-03-01`を`2017年03月01日`に置換する処理を書いてみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '`/(\d{4})-(\d{2})-(\d{2})/g`という正規表現が`"2017-03-01"`という文字列にマッチします。 コールバック関数の`year`、`month`、`day`にはそれぞれキャプチャした文字列が入り、
    マッチした文字列全体がコールバック関数の返り値に置換されます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[](#built)*文字列の組み立て*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*最後に文字列の組み立てについて見ていきましょう。 最初に述べたようにこの章の目的は、「自由に文字列を作れるようになること」です。'
  prefs: []
  type: TYPE_NORMAL
- en: 文字列を単純に結合したり置換することで新しい文字列を作れることがわかりました。 一方、構造的な文字列の場合は単純に結合するだけでは意味が異なってしまうことがあります。
  prefs: []
  type: TYPE_NORMAL
- en: ここでの構造的な文字列とは、URL文字列やファイルパス文字列といった文字列中にコンテキストを持っているものを指します。 たとえば、URL文字列は次のような構造を持っており、それぞれの要素に入る文字列の種類などが決められています（詳細は「[URL
    Standard](https://url.spec.whatwg.org/ "URL Standard")」を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: これらの文字列を作成する場合は、文字列結合演算子（`+`）で単純に結合するよりも専用の関数を用意するほうが安全です。
  prefs: []
  type: TYPE_NORMAL
- en: たとえば、次のように`baseURL`と`pathname`を渡し、それらを結合したURLにあるリソースを取得する`getResource`関数があるとします。
    この`getResource`関数には、ベースURL(`baseURL`)とパス（`pathname`）を引数に渡して利用します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: しかし、人によっては、`baseURL`の末尾には`/`が含まれると考える場合もあります。 `getResource`関数は、`baseURL`の末尾に`/`が含まれているケースを想定していませんでした。
    そのため、意図しないURLからリソースを取得するという問題が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: この問題が難しいところは、結合してできた`url`は文字列としては正しいため、エラーではないということです。 つまり、一見すると問題ないように見えますが、実際に動かしてみて初めてわかるような問題が生じやすいのです。
  prefs: []
  type: TYPE_NORMAL
- en: そのため、このような構造的な文字列を扱う場合は、専用の関数や専用のオブジェクトを作ることで安全に文字列を処理します。
  prefs: []
  type: TYPE_NORMAL
- en: 先ほどのような、URL文字列の結合を安全に行うには、入力される`baseURL`文字列の表記揺れを吸収する仕組みを作成します。 次の`baseJoin`関数はベースURLとパスを結合した文字列を返しますが、ベースURLの末尾に`/`があるかの揺れを吸収しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: ECMAScriptの範囲ではありませんが、URLやファイルパスといった典型的なものに対してはすでに専用のものがあります。 URLを扱うものとしてウェブ標準APIである[URL](https://developer.mozilla.org/ja/docs/Web/API/URL
    "URL - Web API インターフェイス | MDN")オブジェクト、ファイルパスを扱うものとしてはNode.jsのコアモジュールである[Path](https://nodejs.org/api/path.html
    "Path | Node.js v7.9.0 Documentation")モジュールなどがあります。専用の仕組みがある場合は、直接`+`演算子で結合するような文字列処理は避けるべきです。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#tagged-template-function)*[ES2015] タグつきテンプレート関数*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptでは、テンプレートとなる文字列に対して一部分だけを変更する処理を行う方法として、タグつきテンプレート関数があります。 タグつきテンプレート関数とは、`関数`テンプレート``
    という形式で記述する関数とテンプレートリテラルを合わせた表現です。 関数の呼び出しに`関数(`テンプレート`)`ではなく、`関数`テンプレート`` という書式を使っていることに注意してください。'
  prefs: []
  type: TYPE_NORMAL
- en: 通常の関数として呼び出した場合、関数の引数にはただの文字列が渡ってきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: しかし、`()`ではなく `関数`テンプレート`` と記述することで、`関数`が受け取る引数にはタグつきテンプレート向けの値が渡ってきます。 このとき、関数の第一引数にはテンプレートの中身が`${}`で区切られた文字列の配列、第二引数以降は`${}`の中に書いた式の評価結果が順番に渡されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: どちらも同じ関数ですが、`関数`テンプレート`` という書式で呼び出すと渡される引数が特殊な形になります。 そのため、タグつきテンプレートで利用する関数のことを**タグ関数**（Tag
    function）と呼び分けることにします。
  prefs: []
  type: TYPE_NORMAL
- en: まずは引数をどう扱うかを見ていくために、タグつきテンプレートの内容をそのまま結合して返す`stringRaw`というタグ関数を実装してみます。 Arrayの`reduce`メソッドを使うことで、テンプレートの文字列と変数を順番に結合できます（[`reduce`メソッド](../array/#array-reduce)については「[配列](../array/)」の章を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: ここで実装した`stringRaw`タグ関数と同様のものが、`String.raw`メソッド^([ES2015])として提供されています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: タグつきテンプレート関数を利用することで、テンプレートとなる文字列に対して特定の形式に変換したデータを埋め込むといったテンプレート処理が行えます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、テンプレート中の変数をURLエスケープしてから埋め込むタグつきテンプレート関数を定義しています。 `encodeURIComponent`関数は引数の値をURLエスケープする関数です。
    `escapeURL`では受け取った変数を`encodeURIComponent`関数でURLエスケープしてから埋め込んでいます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: このようにタグつきテンプレートリテラルを使うことで、コンテキストに応じた処理をつけ加えることができます。 この機能はJavaScript内にHTMLなどの別の言語やDSL（ドメイン固有言語）を埋め込む際に利用されることが多いです。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#string-summary)*終わりに*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では、JavaScriptにおける文字列(`String`オブジェクト)について紹介しました。 文字列処理するStringメソッドにはさまざまなものがあり、正規表現と組み合わせて使うものも含まれます。'
  prefs: []
  type: TYPE_NORMAL
- en: 正規表現は、正規表現のみで1冊の本が作れるようなJavaScript言語内にある別言語です。 詳細は[MDNの正規表現ドキュメント](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Regular_Expressions
    "正規表現 - JavaScript | MDN")なども参照してください。
  prefs: []
  type: TYPE_NORMAL
- en: 文字列は一見すると単純に見えますが、URLやパスといったコンテキストを持つものもあります。 それらの文字列を安全に扱うためには、コンテキストに応じた処理が必要になります。
    また、タグつきテンプレートリテラルを利用することで、テンプレート中の変数を自動でエスケープするといった処理を実現できます。
  prefs: []
  type: TYPE_NORMAL
- en: ¹. Unicodeのカタカナの一覧 [https://unicode-table.com/jp/#katakana](https://unicode-table.com/jp/#katakana)
    から取り出したテーブルです。 [↩](#reffn_1 "Jump back to footnote [1] in the text.")*****************************
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
