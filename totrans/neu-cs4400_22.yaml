- en: de Bruijn IndexesTuesday, January 24th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This whole story revolves around names, specifically, name capture is a problem
    that should always be avoided (it is one major source of PL headaches).
  prefs: []
  type: TYPE_NORMAL
- en: But are names the only way we can use bindings?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a least one alternative way: note that the only thing we used names
    for are for references. We don’t really care what the name is, which is pretty
    obvious when we consider the two WAE expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'or the two Racket function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these show a pair of expressions that we should consider as equal in
    some sense (this is called “alpha-equality”). The only thing we care about is
    what variable points where: the binding structure is the only thing that matters.
    In other words, as long as DrRacket produces the same arrows when we use Check
    Syntax, we consider the program to be the same, regardless of name choices (for
    argument names and local names, not for global names like `foo` in the above).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative idea uses this principle: if all we care about is where the
    arrows go, then simply get rid of the names… Instead of referencing a binding
    through its name, just specify which of the surrounding scopes we want to refer
    to. For example, instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'we can use a new “reference” syntax — `[N]` — and use this instead of the above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So the rules for `[N]` are — `[0]` is the value bound in the current scope,
    `[1]` is the value from the next one up etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, to do this translation, we have to know the precise scope rules.
    Two more complicated examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'is translated to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '(note how `x` appears as a different reference based on where it appeared in
    the original code.) Even more subtle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'is translated to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: because the inner `with` does not have its own named expression in its scope,
    so the named expression is immediately in the scope of the outer `with`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called “de Bruijn Indexes”: instead of referencing identifiers by their
    name, we use an index into the surrounding binding context. The major disadvantage,
    as can be seen in the above examples, is that it is not convenient for humans
    to work with. Specifically, the same identifier is referenced using different
    numbers, which makes it hard to understand what some code is doing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, practically all compilers use this for compiled code (think about
    stack pointers). For example, GCC compiles this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
