- en: The "Why use F#?" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “为什么使用 F#？”系列
- en: This series of posts will give you a guided tour through the main features of
    F# and then show you ways that F# can help you in your day-to-day development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列文章将为您带来对 F# 主要特性的指导之旅，然后向您展示 F# 如何在您的日常开发中帮助您。
- en: '[Introduction to the ''Why use F#'' series](why-use-fsharp-intro.html). An
    overview of the benefits of F#.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍“为什么使用 F#”系列](why-use-fsharp-intro.html)。F# 的好处概述。'
- en: '[F# syntax in 60 seconds](fsharp-in-60-seconds.html). A very quick overview
    on how to read F# code.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[60秒内了解 F# 语法](fsharp-in-60-seconds.html)。关于如何阅读 F# 代码的快速概述。'
- en: '[Comparing F# with C#: A simple sum](fvsc-sum-of-squares.html). In which we
    attempt to sum the squares from 1 to N without using a loop.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[比较 F# 与 C#：简单求和](fvsc-sum-of-squares.html)。我们尝试在不使用循环的情况下对 1 到 N 的平方进行求和。'
- en: '[Comparing F# with C#: Sorting](fvsc-quicksort.html). In which we see that
    F# is more declarative than C#, and we are introduced to pattern matching..'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[比较 F# 与 C#：排序](fvsc-quicksort.html)。我们看到 F# 比 C# 更具声明性，并且我们介绍了模式匹配。'
- en: '[Comparing F# with C#: Downloading a web page](fvsc-download.html). In which
    we see that F# excels at callbacks, and we are introduced to the ''use'' keyword.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[比较 F# 与 C#：下载网页](fvsc-download.html)。我们看到 F# 在回调方面表现出色，并且我们介绍了“use”关键字。'
- en: '[Four Key Concepts](key-concepts.html). The concepts that differentiate F#
    from a standard imperative language.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[四个关键概念](key-concepts.html)。区别 F# 与标准命令式语言的概念。'
- en: '[Conciseness](conciseness-intro.html). Why is conciseness important?.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简洁性](conciseness-intro.html)。为什么简洁性很重要？。'
- en: '[Type inference](conciseness-type-inference.html). How to avoid getting distracted
    by complex type syntax.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型推断](conciseness-type-inference.html)。如何避免被复杂的类型语法分散注意力。'
- en: '[Low overhead type definitions](conciseness-type-definitions.html). No penalty
    for making new types.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[低开销的类型定义](conciseness-type-definitions.html)。创建新类型没有代价。'
- en: '[Using functions to extract boilerplate code](conciseness-extracting-boilerplate.html).
    The functional approach to the DRY principle.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用函数提取样板代码](conciseness-extracting-boilerplate.html)。DRY 原则的函数式方法。'
- en: '[Using functions as building blocks](conciseness-functions-as-building-blocks.html).
    Function composition and mini-languages make code more readable.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用函数作为构建块](conciseness-functions-as-building-blocks.html)。函数组合和迷你语言使代码更易读。'
- en: '[Pattern matching for conciseness](conciseness-pattern-matching.html). Pattern
    matching can match and bind in a single step.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简洁的模式匹配](conciseness-pattern-matching.html)。模式匹配可以一步匹配和绑定。'
- en: '[Convenience](convenience-intro.html). Features that reduce programming drudgery
    and boilerplate code.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[便利性](convenience-intro.html)。减少编程单调和样板代码的特性。'
- en: '[Out-of-the-box behavior for types](convenience-types.html). Immutability and
    built-in equality with no coding.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型的即用即有行为](convenience-types.html)。不需要编码的不可变性和内建相等性。'
- en: '[Functions as interfaces](convenience-functions-as-interfaces.html). OO design
    patterns can be trivial when functions are used.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数作为接口](convenience-functions-as-interfaces.html)。当函数被使用时，OO 设计模式可以是微不足道的。'
- en: '[Partial Application](convenience-partial-application.html). How to fix some
    of a function''s parameters.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[部分应用](convenience-partial-application.html)。如何固定函数的一些参数。'
- en: '[Active patterns](convenience-active-patterns.html). Dynamic patterns for powerful
    matching.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[活动模式](convenience-active-patterns.html)。强大匹配的动态模式。'
- en: '[Correctness](correctness-intro.html). How to write ''compile time unit tests''.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正确性](correctness-intro.html)。如何编写‘编译时单元测试’。'
- en: '[Immutability](correctness-immutability.html). Making your code predictable.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[不可变性](correctness-immutability.html)。使您的代码可预测。'
- en: '[Exhaustive pattern matching](correctness-exhaustive-pattern-matching.html).
    A powerful technique to ensure correctness.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[穷举模式匹配](correctness-exhaustive-pattern-matching.html)。确保正确性的强大技术。'
- en: '[Using the type system to ensure correct code](correctness-type-checking.html).
    In F# the type system is your friend, not your enemy.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型系统确保正确代码](correctness-type-checking.html)。在 F# 中，类型系统是你的朋友，而不是你的敌人。'
- en: '[Worked example: Designing for correctness](designing-for-correctness.html).
    How to make illegal states unrepresentable.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：为正确性设计](designing-for-correctness.html)。如何使非法状态不可表示。'
- en: '[Concurrency](concurrency-intro.html). The next major revolution in how we
    write software?.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[并发性](concurrency-intro.html)。我们编写软件的下一次重大革命？。'
- en: '[Asynchronous programming](concurrency-async-and-parallel.html). Encapsulating
    a background task with the Async class.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[异步编程](concurrency-async-and-parallel.html)。用 Async 类封装后台任务。'
- en: '[Messages and Agents](concurrency-actor-model.html). Making it easier to think
    about concurrency.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消息和代理](concurrency-actor-model.html)。简化并发思考。'
- en: '[Functional Reactive Programming](concurrency-reactive.html). Turning events
    into streams.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数式响应式编程](concurrency-reactive.html)。将事件转换为流。'
- en: '[Completeness](completeness-intro.html). F# is part of the whole .NET ecosystem.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[完整性](completeness-intro.html)。F#是整个.NET生态系统的一部分。'
- en: '[Seamless interoperation with .NET libraries](completeness-seamless-dotnet-interop.html).
    Some convenient features for working with .NET libraries.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[与.NET库无缝互操作](completeness-seamless-dotnet-interop.html)。与.NET库一起工作的一些方便功能。'
- en: '[Anything C# can do...](completeness-anything-csharp-can-do.html). A whirlwind
    tour of object-oriented code in F#.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[任何C#可以做到的事情……](completeness-anything-csharp-can-do.html)。F#中面向对象代码的快速浏览。'
- en: '[Why use F#: Conclusion](why-use-fsharp-conclusion.html). .'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么使用 F#：结论](why-use-fsharp-conclusion.html)。'
- en: Introduction to the 'Why use F#' series
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《为什么使用 F#》系列介绍
- en: Introduction to the 'Why use F#' series
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《为什么使用 F#》系列介绍
- en: This series of posts will give you a guided tour through the main features of
    F# and then show you ways that F# can help you in your day-to-day development.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列的帖子将带你领略F#的主要特性，然后向你展示F#如何在你的日常开发中帮助你。
- en: Key benefits of F# compared with C#
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F# 相对于 C# 的主要优势
- en: 'If you are already familiar with C# or Java, you might be wondering why it
    would be worth learning yet another language. F# has some major benefits which
    I have grouped under the following themes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉C#或Java，你可能想知道为什么要学习另一种语言。F#有一些主要优点，我将其归为以下主题：
- en: '**Conciseness**. F# is not cluttered up with coding "noise" such as curly brackets,
    semicolons and so on. You almost never have to specify the type of an object,
    thanks to a powerful type inference system. And it generally takes less lines
    of code to solve the same problem.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**。F#不会被编码“噪音”所淹没，如花括号、分号等等。你几乎从不必指定对象的类型，这要归功于强大的类型推断系统。通常，解决同样的问题所需的代码行数更少。'
- en: '**Convenience**. Many common programming tasks are much simpler in F#. This
    includes things like creating and using complex type definitions, doing list processing,
    comparison and equality, state machines, and much more. And because functions
    are first class objects, it is very easy to create powerful and reusable code
    by creating functions that have other functions as parameters, or that combine
    existing functions to create new functionality.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方便性**。许多常见的编程任务在F#中要简单得多。这包括创建和使用复杂的类型定义，进行列表处理、比较和相等性、状态机等等。而且，由于函数是一等对象，通过创建将其他函数作为参数的函数，或者组合现有函数来创建新功能，非常容易创建强大且可重用的代码。'
- en: '**Correctness**. F# has a very powerful type system which prevents many common
    errors such as null reference exceptions. And in addition, you can often encode
    business logic using the type system itself, so that it is actually impossible
    to write incorrect code, because it is caught at compile time as a type error.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确性**。F#拥有非常强大的类型系统，可以防止许多常见的错误，如空引用异常。此外，通常可以使用类型系统本身对业务逻辑进行编码，因此实际上不可能编写错误的代码，因为它在编译时被检测为类型错误。'
- en: '**Concurrency**. F# has a number of built-in tools and libraries to help with
    programming systems when more than one thing at a time is happening. Asynchronous
    programming is directly supported, as is parallelism. F# also has a message queuing
    system, and excellent support for event handling and reactive programming. And
    because data structures are immutable by default, sharing state and avoiding locks
    is much easier.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性**。F#具有许多内置工具和库，可以帮助编写在发生多个事情时的系统。异步编程得到直接支持，同样也支持并行性。F#还有一个消息队列系统，并且对事件处理和响应式编程有很好的支持。由于数据结构默认是不可变的，因此共享状态和避免锁定要容易得多。'
- en: '**Completeness**. Although F# is a functional language at heart, it does support
    other styles which are not 100% pure, which makes it much easier to interact with
    the non-pure world of web sites, databases, other applications, and so on. In
    particular, F# is designed as a hybrid functional/OO language, so it can do almost
    everything that C# can do as well. Of course, F# integrates seamlessly with the
    .NET ecosystem, which gives you access to all the third party .NET libraries and
    tools. Finally, it is part of Visual Studio, which means you get a good editor
    with IntelliSense support, a debugger, and many plug-ins for unit tests, source
    control, and other development tasks.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**。尽管 F# 本质上是一种函数式语言，但它支持其他不是100%纯的样式，这使得与非纯净的网站、数据库、其他应用程序等交互变得更容易。特别是，F#
    被设计为一种混合功能/面向对象语言，因此它几乎可以做到与 C# 一样的所有事情。当然，F# 与 .NET 生态系统无缝集成，这使您可以访问所有第三方 .NET
    库和工具。最后，它是 Visual Studio 的一部分，这意味着您可以获得具有 IntelliSense 支持的良好编辑器、调试器以及用于单元测试、源代码控制和其他开发任务的许多插件。'
- en: In the rest of this series of posts, I will try to demonstrate each of these
    F# benefits, using standalone snippets of F# code (and often with C# code for
    comparison). I'll briefly cover all the major features of F#, including pattern
    matching, function composition, and concurrent programming. By the time you have
    finished this series, I hope that you will have been impressed with the power
    and elegance of F#, and you will be encouraged to use it for your next project!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列的其余文章中，我将尝试演示 F# 的每个优点，使用独立的 F# 代码片段（并经常与 C# 代码进行比较）。我将简要介绍 F# 的所有主要功能，包括模式匹配、函数组合和并发编程。希望在您完成本系列时，您对
    F# 的强大和优雅感到印象深刻，并且您将受到鼓舞，使用它进行下一个项目！
- en: How to read and use the example code
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何阅读和使用示例代码
- en: All the code snippets in these posts have been designed to be run interactively.
    I strongly recommend that you evaluate the snippets as you read each post. The
    source for any large code files will be linked to from the post.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文章中的所有代码片段都被设计为可交互运行。我强烈建议您在阅读每篇文章时评估代码片段。任何大型代码文件的源代码将链接到文章中。
- en: This series is not a tutorial, so I will not go too much into *why* the code
    works. Don't worry if you cannot understand some of the details; the goal of the
    series is just to introduce you to F# and whet your appetitite for learning it
    more deeply.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列不是教程，因此我不会过多地解释代码为什么有效。如果您无法理解一些细节，请不要担心；本系列的目标只是向您介绍 F# 并激发您对深入学习的兴趣。
- en: If you have experience in languages such as C# and Java, you have probably found
    that you can get a pretty good understanding of source code written in other similar
    languages, even if you aren't familiar with the keywords or the libraries. You
    might ask "how do I assign a variable?" or "how do I do a loop?", and with these
    answers be able to do some basic programming quite quickly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有 C# 和 Java 等语言的经验，您可能已经发现，即使您不熟悉关键字或库，您也可以相当好地理解用其他类似语言编写的源代码。您可能会问“如何分配变量？”或“如何进行循环？”通过这些答案，您可以很快进行一些基本的编程。
- en: This approach will not work for F#, because in its pure form there are no variables,
    no loops, and no objects. Don't be frustrated - it will eventually make sense!
    If you want to learn F# in more depth, there are some helpful tips on the ["learning
    F#"](index4.html) page.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对 F# 不起作用，因为在其纯粹形式中，没有变量、没有循环和没有对象。不要沮丧-它最终会有意义！如果您想更深入地了解 F#，请查看["学习 F#"](index4.html)
    页面上的一些有用提示。
- en: 'Comparing F# with C#: A simple sum'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '与 C# 比较 F#: 一个简单的求和'
- en: 'Comparing F# with C#: A simple sum'
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '与 C# 比较 F#: 一个简单的求和'
- en: 'To see what some real F# code looks like, let''s start with a simple problem:
    "sum the squares from 1 to N".'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要看看一些真实的 F# 代码是什么样子，让我们从一个简单的问题开始：“求 1 到 N 的平方和”。
- en: 'We''ll compare an F# implementation with a C# implementation. First, the F#
    code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 F# 实现与 C# 实现进行比较。首先是 F# 代码：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The mysterious looking `|>` is called the pipe operator. It just pipes the
    output of one expression into the input of the next. So the code for `sumOfSquares`
    reads as:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 神秘的 `|>` 被称为管道操作符。它只是将一个表达式的输出传送到下一个表达式的输入。因此，`sumOfSquares` 的代码如下所示：
- en: Create a list of 1 to n (square brackets construct a list).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 1 到 n 的列表（方括号构造一个列表）。
- en: Pipe the list into the library function called `List.map`, transforming the
    input list into an output list using the "square" function we just defined.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表传送到名为 `List.map` 的库函数中，使用我们刚刚定义的“square”函数转换输入列表为输出列表。
- en: Pipe the resulting list of squares into the library function called `List.sum`.
    Can you guess what it does?
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果列表的平方管道传递给名为`List.sum`的库函数。你能猜到它是做什么的吗？
- en: There is no explicit "return" statement. The output of `List.sum` is the overall
    result of the function.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有明确的“return”语句。`List.sum`的输出是函数的整体结果。
- en: Next, here's a C# implementation using the classic (non-functional) style of
    a C-based language. (A more functional version using LINQ is discussed later.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是一个使用经典（非函数式）C语言风格的C#实现。（稍后将讨论使用LINQ的更函数式的版本。）
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What are the differences?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么不同之处？
- en: The F# code is more compact
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#代码更加紧凑
- en: The F# code didn't have any type declarations
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#代码没有任何类型声明
- en: F# can be developed interactively
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#可以进行交互式开发
- en: Let's take each of these in turn.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个来看。
- en: Less code
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更少的代码
- en: The most obvious difference is that there is a lot more C# code. 13 C# lines
    compared with 3 F# lines (ignoring comments). The C# code has lots of "noise",
    things like curly braces, semicolons, etc. And in C# the functions cannot stand
    alone, but need to be added to some class ("SumOfSquaresHelper"). F# uses whitespace
    instead of parentheses, needs no line terminator, and the functions can stand
    alone.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的区别是有更多的C#代码。与3行F#代码（忽略注释）相比，有13行C#代码。C#代码有很多“噪音”，比如大括号、分号等。而且在C#中，函数不能独立存在，而是需要添加到某个类中（“SumOfSquaresHelper”）。F#使用空白代替括号，不需要行终止符，函数可以独立存在。
- en: In F# it is common for entire functions to be written on one line, as the "square"
    function is. The `sumOfSquares` function could also have been written on one line.
    In C# this is normally frowned upon as bad practice.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，通常整个函数都写在一行上，就像“square”函数一样。`sumOfSquares`函数也可以写在一行上。在C#中，这通常被视为不良做法。
- en: 'When a function does have multiple lines, F# uses indentation to indicate a
    block of code, which eliminates the need for braces. (If you have ever used Python,
    this is the same idea). So the `sumOfSquares` function could also have been written
    this way:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数有多行时，F#使用缩进来指示代码块，从而消除了大括号的需要。（如果你曾经使用过Python，这是相同的思路）。所以`sumOfSquares`函数也可以这样写：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only drawback is that you have to indent your code carefully. Personally,
    I think it is worth the trade-off.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是你必须仔细缩进代码。就我个人而言，我认为这是值得的。
- en: No type declarations
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有类型声明
- en: The next difference is that the C# code has to explicitly declare all the types
    used. For example, the `int i` parameter and `int SumOfSquares` return type. Yes,
    C# does allow you to use the "var" keyword in many places, but not for parameters
    and return types of functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个区别是，C#代码必须明确声明所使用的所有类型。例如，`int i`参数和`int SumOfSquares`返回类型。是的，C#确实允许您在许多地方使用“var”关键字，但不能用于函数的参数和返回类型。
- en: 'In the F# code we didn''t declare any types at all. This is an important point:
    F# looks like an untyped language, but it is actually just as type-safe as C#,
    in fact, even more so! F# uses a technique called "type inference" to infer the
    types you are using from their context. It works amazingly very well most of the
    time, and reduces the code complexity immensely.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#代码中，我们根本没有声明任何类型。这是一个重要的观点：F#看起来像是一种无类型的语言，但实际上它与C#一样类型安全，事实上，甚至更安全！F#使用一种称为“类型推断”的技术，从上下文中推断您正在使用的类型。它在大多数情况下工作得非常好，并极大地降低了代码复杂性。
- en: 'In this case, the type inference algorithm notes that we started with a list
    of integers. That in turn implies that the square function and the sum function
    must be taking ints as well, and that the final value must be an int. You can
    see what the inferred types are by looking at the result of the compilation in
    the interactive window. You''ll see something like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类型推断算法注意到我们从一个整数列表开始。这反过来意味着平方函数和求和函数也必须取整数，并且最终值必须是一个整数。您可以通过查看交互窗口中编译结果来查看推断出的类型。你会看到类似这样的东西：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: which means that the "square" function takes an int and returns an int.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着“square”函数接受一个整数并返回一个整数。
- en: 'If the original list had used floats instead, the type inference system would
    have deduced that the square function used floats instead. Try it and see:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始列表使用浮点数，类型推断系统会推断平方函数使用的是浮点数。试一试看：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The type checking is very strict! If you try using a list of floats (`[1.0..n]`)
    in the original `sumOfSquares` example, or a list of ints (`[1 ..n]`) in the `sumOfSquaresF`
    example, you will get a type error from the compiler.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查非常严格！如果您尝试在原始的`sumOfSquares`示例中使用一个浮点数列表（`[1.0..n]`），或者在`sumOfSquaresF`示例中使用一个整数列表（`[1
    ..n]`），您将从编译器那里收到一个类型错误。
- en: Interactive development
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式开发
- en: Finally, F# has an interactive window where you can test the code immediately
    and play around with it. In C# there is no easy way to do this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，F# 有一个交互式窗口，您可以立即测试代码并与其进行交互。而在 C# 中，没有简单的方法可以做到这一点。
- en: 'For example, I can write my square function and immediately test it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以编写我的平方函数并立即测试它：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When I am satisfied that it works, I can move on to the next bit of code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我确信它能正常工作时，我可以继续下一个代码片段。
- en: This kind of interactivity encourages an incremental approach to coding that
    can become addictive!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交互性鼓励一种渐进式的编码方法，可以让人上瘾！
- en: Furthermore, many people claim that designing code interactively enforces good
    design practices such as decoupling and explicit dependencies, and therefore,
    code that is suitable for interactive evaluation will also be code that is easy
    to test. Conversely, code that cannot be tested interactively will probably be
    hard to test as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多人声称，通过交互式设计代码可以强化良好的设计实践，例如解耦和显式依赖关系，因此，适用于交互式评估的代码也将是易于测试的代码。相反，无法进行交互式测试的代码可能也很难测试。
- en: The C# code revisited
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新审视 C# 代码
- en: My original example was written using "old-style" C#. C# has incorporated a
    lot of functional features, and it is possible to rewrite the example in a more
    compact way using the LINQ extensions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我的原始示例是使用“旧式”C#编写的。C# 已经融合了许多函数式特性，可以使用 LINQ 扩展以更简洁的方式重写示例。
- en: So here is another C# version -- a line-for-line translation of the F# code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个 C# 版本——F# 代码的逐行翻译。
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, in addition to the noise of the curly braces and periods and semicolons,
    the C# version needs to declare the parameter and return types, unlike the F#
    version.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了花括号、句点和分号的噪音之外，C# 版本需要声明参数和返回类型，而 F# 版本不需要。
- en: Many C# developers may find this a trivial example, but still resort back to
    loops when the logic becomes more complicated. In F# though, you will almost never
    see explicit loops like this. See for example, [this post on eliminating boilerplate
    from more complicated loops](http://fsharpforfunandprofit.com/posts/conciseness-extracting-boilerplate/).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 C# 开发者可能会觉得这个例子很琐碎，但当逻辑变得更加复杂时，他们仍然会回到循环中。但在 F# 中，你几乎不会看到像这样的显式循环。例如，参见 [这篇关于消除更复杂循环中样板代码的文章](http://fsharpforfunandprofit.com/posts/conciseness-extracting-boilerplate/)。
- en: 'Comparing F# with C#: Sorting'
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 F# 与 C# 进行比较：排序
- en: 'Comparing F# with C#: Sorting'
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 F# 与 C# 进行比较：排序
- en: In this next example, we will implement a quicksort-like algorithm for sorting
    lists and compare an F# implementation to a C# implementation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将实现一个类似快速排序的算法来对列表进行排序，并比较 F# 实现和 C# 实现。
- en: 'Here is the logic for a simplified quicksort-like algorithm:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的类似快速排序的算法的逻辑：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this is a simplified algorithm and is not optimized (and it does not
    sort in place, like a true quicksort); we want to focus on clarity for now.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个简化的算法，没有进行优化（也不是原地排序，像真正的快速排序一样）；我们现在要关注的是清晰度。
- en: 'Here is the code in F#:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 F# 中的代码：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again note that this is not an optimized implementation, but is designed to
    mirror the algorithm closely.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，这不是一个优化的实现，但是设计得与算法密切相关。
- en: 'Let''s go through this code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这段代码：
- en: There are no type declarations anywhere. This function will work on any list
    that has comparable items (which is almost all F# types, because they automatically
    have a default comparison function).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何地方都没有类型声明。这个函数将适用于任何具有可比较项的列表（几乎所有 F# 类型，因为它们自动具有默认比较函数）。
- en: The whole function is recursive -- this is signaled to the compiler using the
    `rec` keyword in "`let rec quicksort list =`".
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个函数都是递归的——这是通过 "`let rec quicksort list =`" 中的 `rec` 关键字向编译器发出的信号。
- en: 'The `match..with` is sort of like a switch/case statement. Each branch to test
    is signaled with a vertical bar, like so:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match..with` 有点像 switch/case 语句。每个要测试的分支都使用竖线表示，如下所示：'
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The "`match`" with `[]` matches an empty list, and returns an empty list.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`match`" 与 `[]` 匹配一个空列表，并返回一个空列表。'
- en: The "`match`" with `firstElem::otherElements` does two things.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`match`" 与 `firstElem::otherElements` 做了两件事。'
- en: First, it only matches a non-empty list.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它只匹配非空列表。
- en: Second, it creates two new values automatically. One for the first element called
    "`firstElem`", and one for the rest of the list, called "`otherElements`". In
    C# terms, this is like having a "switch" statement that not only branches, but
    does variable declaration and assignment *at the same time*.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它自动创建两个新值。一个用于第一个元素，称为 "`firstElem`"，另一个用于列表的其余部分，称为 "`otherElements`"。在
    C# 方面，这就像有一个 "switch" 语句，不仅分支，而且*同时*进行变量声明和赋值。
- en: The `->` is sort of like a lambda (`=>`) in C#. The equivalent C# lambda would
    look something like `(firstElem, otherElements) => do something`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->` 在某种程度上类似于 C# 中的 lambda (`=>`)。等效的 C# lambda 将类似于 `(firstElem, otherElements)
    => 执行某些操作`。'
- en: The "`smallerElements`" section takes the rest of the list, filters it against
    the first element using an inline lambda expression with the "`<`" operator and
    then pipes the result into the quicksort function recursively.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`smallerElements`" 部分获取列表的其余部分，使用内联的 lambda 表达式与第一个元素进行过滤，使用 "`<`" 运算符，然后将结果递归地传递到
    quicksort 函数中。'
- en: The "`largerElements`" line does the same thing, except using the "`>=`" operator
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`largerElements`" 行执行相同的操作，只是使用 "`>=`" 运算符'
- en: Finally the resulting list is constructed using the list concatenation function
    "`List.concat`". For this to work, the first element needs to be put into a list,
    which is what the square brackets are for.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，使用列表连接函数 "`List.concat`" 构造出结果列表。为了使其工作，第一个元素需要放入一个列表中，这就是方括号的作用。
- en: Again note there is no "return" keyword; the last value will be returned. In
    the "`[]`" branch the return value is the empty list, and in the main branch,
    it is the newly constructed list.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次注意没有 "return" 关键字；最后一个值将被返回。在 "`[]`" 分支中，返回值是空列表，在主分支中，它是新构造的列表。
- en: For comparison here is an old-style C# implementation (without using LINQ).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，这里是一个旧式的 C# 实现（不使用 LINQ）。
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Comparing the two sets of code, again we can see that the F# code is much more
    compact, with less noise and no need for type declarations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两组代码，我们可以再次看到 F# 代码更加紧凑，噪音更少，无需类型声明。
- en: Furthermore, the F# code reads almost exactly like the actual algorithm, unlike
    the C# code. This is another key advantage of F# -- the code is generally more
    declarative ("what to do") and less imperative ("how to do it") than C#, and is
    therefore much more self-documenting.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，F# 代码几乎与实际算法完全相同，而 C# 代码不然。这是 F# 的另一个关键优势 -- 代码通常更具声明性（"做什么"）而不是命令性（"如何做"），因此更具自我文档性。
- en: A functional implementation in C#
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中的函数式实现
- en: 'Here''s a more modern "functional-style" implementation using LINQ and an extension
    method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更现代的 "函数式风格" 实现，使用 LINQ 和一个扩展方法：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is much cleaner, and reads almost the same as the F# version. But unfortunately
    there is no way of avoiding the extra noise in the function signature.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更加清晰，几乎与 F# 版本相同。但不幸的是，在函数签名中无法避免额外的噪音。
- en: Correctness
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确性
- en: Finally, a beneficial side-effect of this compactness is that F# code often
    works the first time, while the C# code may require more debugging.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这种紧凑性的一个有益的副作用是，F# 代码通常第一次就可以工作，而 C# 代码可能需要更多的调试。
- en: Indeed, when coding these samples, the old-style C# code was incorrect initially,
    and required some debugging to get it right. Particularly tricky areas were the
    `for` loop (starting at 1 not zero) and the `CompareTo` comparison (which I got
    the wrong way round), and it would also be very easy to accidentally modify the
    inbound list. The functional style in the second C# example is not only cleaner
    but was easier to code correctly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在编写这些示例代码时，旧式的 C# 代码最初是不正确的，需要一些调试才能弄清楚。特别棘手的地方是 `for` 循环（从1开始而不是零）和 `CompareTo`
    比较（我把它搞反了），而且很容易意外修改传入的列表。第二个 C# 示例中的函数式风格不仅更清晰，而且更容易编写正确。
- en: 'But even the functional C# version has drawbacks compared to the F# version.
    For example, because F# uses pattern matching, it is not possible to branch to
    the "non-empty list" case with an empty list. On the other hand, in the C# code,
    if we forgot the test:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使是函数式的 C# 版本与 F# 版本相比也有缺点。例如，因为 F# 使用模式匹配，所以不可能在空列表中分支到 "非空列表" 情况。另一方面，在
    C# 代码中，如果我们忘记了测试：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'then the extraction of the first element:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后提取第一个元素：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'would fail with an exception. The compiler cannot enforce this for you. In
    your own code, how often have you used `FirstOrDefault` rather than `First` because
    you are writing "defensive" code. Here is an example of a code pattern that is
    very common in C# but is rare in F#:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现异常，程序会失败。编译器无法为您执行此操作。在您自己的代码中，您有多少次使用了 `FirstOrDefault` 而不是 `First`，因为您正在编写
    "防御性" 代码。这是一个在 C# 中非常常见但在 F# 中很少见的代码模式示例：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The one-step "pattern match and branch" in F# allows you to avoid this in many
    cases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，一步到位的 "模式匹配和分支" 允许您在许多情况下避免这种情况。
- en: Postscript
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后记
- en: The example implementation in F# above is actually pretty verbose by F# standards!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以上的 F# 示例实际上按照 F# 的标准相当冗长！
- en: 'For fun, here is what a more typically concise version would look like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，这是一个更典型简洁版本的例子：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Not bad for 4 lines of code, and when you get used to the syntax, still quite
    readable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅 4 行代码而已，而且当你习惯了语法后，仍然非常易读。
- en: 'Comparing F# with C#: Downloading a web page'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '比较 F# 和 C#: 下载网页'
- en: 'Comparing F# with C#: Downloading a web page'
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '比较 F# 和 C#: 下载网页'
- en: In this example, we will compare the F# and C# code for downloading a web page,
    with a callback to process the text stream.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将比较使用回调函数处理文本流的下载网页的 F# 和 C# 代码。
- en: We'll start with a straightforward F# implementation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的 F# 实现开始。
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s go through this code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码：
- en: The use of "open" at the top allows us to write "WebRequest" rather than "System.Net.WebRequest".
    It is similar to a "`using System.Net`" header in C#.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部使用 "open" 允许我们写 "WebRequest" 而不是 "System.Net.WebRequest"。这类似于 C# 中的 "`using
    System.Net`" 头文件。
- en: Next, we define the `fetchUrl` function, which takes two arguments, a callback
    to process the stream, and the url to fetch.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `fetchUrl` 函数，它接受两个参数，一个用于处理流的回调函数，以及要获取的 URL。
- en: 'We next wrap the url string in a Uri. F# has strict type-checking, so if instead
    we had written: `let req = WebRequest.Create(url)` the compiler would have complained
    that it didn''t know which version of `WebRequest.Create` to use.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将 url 字符串封装在一个 Uri 中。F# 具有严格的类型检查，因此如果我们写成了：`let req = WebRequest.Create(url)`，编译器会抱怨它不知道使用哪个版本的
    `WebRequest.Create`。
- en: When declaring the `response`, `stream` and `reader` values, the "`use`" keyword
    is used instead of "`let`". This can only be used in conjunction with classes
    that implement `IDisposable`. It tells the compiler to automatically dispose of
    the resource when it goes out of scope. This is equivalent to the C# "`using`"
    keyword.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明 `response`、`stream` 和 `reader` 值时，使用 "`use`" 关键字而不是 "`let`"。这只能与实现了 `IDisposable`
    接口的类一起使用。它告诉编译器在资源超出范围时自动处理资源。这相当于 C# 中的 "`using`" 关键字。
- en: The last line calls the callback function with the StreamReader and url as parameters.
    Note that the type of the callback does not have to be specified anywhere.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行调用带有 StreamReader 和 url 作为参数的回调函数。请注意，回调的类型无需在任何地方指定。
- en: Now here is the equivalent C# implementation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这里是等效的 C# 实现。
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As usual, the C# version has more 'noise'.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，C# 版本有更多的 "噪音"。
- en: There are ten lines just for curly braces, and there is the visual complexity
    of 5 levels of nesting*
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有十行仅仅是大括号，还有五级嵌套的视觉复杂性。
- en: All the parameter types have to be explicitly declared, and the generic `TResult`
    type has to be repeated three times.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数类型都必须显式声明，并且泛型 `TResult` 类型必须重复三次。
- en: '[* It''s true that in this particular example, when all the `using` statements
    are adjacent, the [extra braces and indenting can be removed](https://stackoverflow.com/questions/1329739/nested-using-statements-in-c-sharp),
    but in the more general case they are needed.]'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[* 在这个特定的例子中，当所有 `using` 语句都相邻时，可以移除[额外的大括号和缩进](https://stackoverflow.com/questions/1329739/nested-using-statements-in-c-sharp)，但在更一般的情况下，它们是必需的。]'
- en: Testing the code
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试代码
- en: 'Back in F# land, we can now test the code interactively:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 领域，我们现在可以交互式地测试代码了。
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, we have to resort to a type declaration for the reader parameter (`reader:IO.StreamReader`).
    This is required because the F# compiler cannot determine the type of the "reader"
    parameter automatically.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不得不为 reader 参数（`reader:IO.StreamReader`）进行类型声明。这是必需的，因为 F# 编译器无法自动确定 "reader"
    参数的类型。
- en: A very useful feature of F# is that you can "bake in" parameters in a function
    so that they don't have to be passed in every time. This is why the `url` parameter
    was placed *last* rather than first, as in the C# version. The callback can be
    setup once, while the url varies from call to call.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: F#的一个非常有用的特性是你可以在函数中“固定”参数，这样它们就不必每次都传递。这就是为什么`url`参数被放在*最后*而不是最前面，就像C#版本一样。回调可以设置一次，而url则在每次调用时变化。
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last line (using `List.map`) shows how the new function can be easily used
    in conjunction with list processing functions to download a whole list at once.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行（使用`List.map`）显示了如何将新函数轻松与列表处理函数结合使用，以一次下载整个列表。
- en: 'Here is the equivalent C# test code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是等价的C#测试代码：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, the code is a bit noisier than the F# code, with many explicit type references.
    More importantly, the C# code doesn't easily allow you to bake in some of the
    parameters in a function, so the callback must be explicitly referenced every
    time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，代码比F#代码更加嘈杂，有许多显式类型引用。更重要的是，C#代码不容易允许您在函数中固定一些参数，因此每次都必须显式引用回调。
- en: Four Key Concepts
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四个关键概念
- en: Four Key Concepts
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四个关键概念
- en: 'In the next few posts we''ll move on to demonstrating the themes of this series:
    conciseness, convenience, correctness, concurrency and completeness.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几篇文章中，我们将继续展示本系列的主题：简洁、便利、正确、并发和完备。
- en: 'But before that, let''s look at some of the key concepts in F# that we will
    meet over and over again. F# is different in many ways from a standard imperative
    language like C#, but there are a few major differences that are particularly
    important to understand:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但在此之前，让我们先看一些我们将一次又一次遇到的F#中的关键概念。F#在许多方面与标准的命令式语言（如C#）不同，但有一些特别重要的差异需要特别理解：
- en: '**Function-oriented** rather than object-oriented'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向函数**而不是面向对象'
- en: '**Expressions** rather than statements'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达式**而不是语句'
- en: '**Algebraic types** for creating domain models'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代数类型**用于创建领域模型'
- en: '**Pattern matching** for flow of control'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式匹配**用于控制流程'
- en: In later posts, these will be dealt with in much greater depth -- this is just
    a taster to help you understand the rest of this series.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的文章中，这些将会被更加深入地讨论——这只是一个开胃菜，帮助你理解本系列的其余内容。
- en: '![four key concepts](four-concepts2.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![四个关键概念](four-concepts2.png)'
- en: Function-oriented rather than object-oriented
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向函数而不是面向对象
- en: As you might expect from the term "functional programming", functions are everywhere
    in F#.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从术语“函数式编程”中预期的那样，函数在F#中无处不在。
- en: 'Of course, functions are first class entities, and can be passed around like
    any other value:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数是头等实体，可以像任何其他值一样传递：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But C# has first-class functions too, so what's so special about functional
    programming?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但是C#也有一流函数，那么函数式编程有什么特别之处呢？
- en: The short answer is that the function-oriented nature of F# infiltrates every
    part of the language and type system in a way that it does not in C#, so that
    things that are awkward or clumsy in C# are very elegant in F#.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案是，F#的面向函数的特性渗透到语言和类型系统的每个部分，而在C#中没有这样的情况，因此在C#中笨拙或繁琐的事情在F#中非常优雅。
- en: 'It''s hard to explain this in a few paragraphs, but here are some of the benefits
    that we will see demonstrated over this series of posts:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 很难用几段话来解释这一点，但以下是我们将在这一系列文章中看到的一些好处：
- en: '**Building with composition**. Composition is the ''glue'' that allows us build
    larger systems from smaller ones. This is not an optional technique, but is at
    the very heart of the functional style. Almost every line of code is a composable
    expression (see below). Composition is used to build basic functions, and then
    functions that use those functions, and so on. And the composition principle doesn''t
    just apply to functions, but also to types (the product and sum types discussed
    below).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用组合构建**。组合是让我们从小系统构建更大系统的“胶水”。这不是一种可选的技术，而是功能风格的核心。几乎每一行代码都是可组合的表达式（见下文）。组合用于构建基本函数，然后是使用这些函数的函数，依此类推。组合原则不仅适用于函数，还适用于类型（下面讨论的乘积和和类型）。'
- en: '**Factoring and refactoring**. The ability to factor a problem into parts depends
    how easily the parts can be glued back together. Methods and classes that might
    seem to be indivisible in an imperative language can often be broken down into
    surprisingly small pieces in a functional design. These fine-grained components
    typically consist of (a) a few very general functions that take other functions
    as parameters, and (b) other helper functions that specialize the general case
    for a particular data structure or application. Once factored out, the generalized
    functions allow many additional operations to be programmed very easily without
    having to write new code. You can see a good example of a general function like
    this (the fold function) in the [post on extracting duplicate code from loops](conciseness-extracting-boilerplate.html).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因式分解和重构**。将问题分解为部分的能力取决于这些部分如何容易地粘合在一起。在函数式设计中，在命令式语言中可能看起来不可分割的方法和类通常可以被分解为令人惊讶的小部分。这些细粒度组件通常包括（a）几个非常通用的函数，这些函数将其他函数作为参数，以及（b）其他帮助函数，这些函数为特定数据结构或应用程序专门化了一般情况。一旦分解出来，通用函数允许很容易地编程许多附加操作，而无需编写新代码。您可以在[从循环中提取重复代码的帖子](conciseness-extracting-boilerplate.html)中看到一个很好的通用函数的示例（fold函数）。'
- en: '**Good design**. Many of the principles of good design, such as "separation
    of concerns", "single responsibility principle", ["program to an interface, not
    an implementation"](convenience-functions-as-interfaces.html), arise naturally
    as a result of a functional approach. And functional code tends to be high level
    and declarative in general.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**良好的设计**。许多良好设计原则，如“关注点分离”，“单一职责原则”，[“针对接口编程，而不是实现”](convenience-functions-as-interfaces.html)，都是作为函数式方法的自然结果而产生的。而且，函数式代码通常在一般情况下是高级别和声明性的。'
- en: The following posts in this series will have examples of how functions can make
    code more concise and convenient, and then for a deeper understanding, there is
    a whole series on [thinking functionally](thinking-functionally.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列中的以下帖子将举例说明函数如何使代码更简洁和方便，然后为了更深入地理解，还有一个关于[函数式思维](thinking-functionally.html)的整个系列。
- en: Expressions rather than statements
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式而非语句
- en: In functional languages, there are no statements, only expressions. That is,
    every chunk of code always returns a value, and larger chunks are created by combining
    smaller chunks using composition rather than a serialized list of statements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，没有语句，只有表达式。也就是说，每个代码块总是返回一个值，并且较大的代码块是通过组合较小的代码块而不是序列化的语句列表来创建的。
- en: If you have used LINQ or SQL you will already be familiar with expression-based
    languages. For example, in pure SQL, you cannot have assignments. Instead, you
    must have subqueries within larger queries.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用过LINQ或SQL，您将已经熟悉基于表达式的语言。例如，在纯SQL中，您不能进行赋值。相反，您必须在较大的查询中使用子查询。
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: F# works in the same way -- every function definition is a single expression,
    not a set of statements.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: F#也是以相同的方式工作--每个函数定义都是一个单独的表达式，而不是一组语句。
- en: And it might not be obvious, but code built from expressions is both safer and
    more compact than using statements. To see this, let's compare some statement-based
    code in C# with the equivalent expression-based code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 而且可能并不明显，但是使用表达式构建的代码比使用语句更安全且更紧凑。为了看到这一点，让我们比较一些基于语句的C#代码与等效的基于表达式的代码。
- en: First, the statement-based code. Statements don't return values, so you have
    to use temporary variables that are assigned to from within statement bodies.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，基于语句的代码。语句不返回值，因此您必须使用从语句主体中分配的临时变量。
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because the `if-then` block is a statement, the `result` variable must be defined
    *outside* the statement but assigned to from *inside* the statement, which leads
    to issues such as:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`if-then`块是一个语句，所以`result`变量必须在语句之外被定义，但是从语句内部被分配，这会导致诸如以下问题：
- en: What initial value should `result` be set to?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`应该被设置为什么初始值？'
- en: What if I forget to assign to the `result` variable?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我忘记给`result`变量赋值会怎么样？
- en: What is the value of the `result` variable in the "else" case?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“else”情况下，`result`变量的值是多少？
- en: 'For comparison, here is the same code, rewritten in an expression-oriented
    style:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，这里是以面向表达式的风格重写的相同代码：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the expression-oriented version, none of these issues apply:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向表达式的版本中，这些问题都不适用：
- en: The `result` variable is declared at the same time that it is assigned. No variables
    have to be set up "outside" the expression and there is no worry about what initial
    value they should be set to.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result` 变量在赋值的同时声明。不需要在表达式之外设置变量，并且不用担心它们应该被设置为什么初始值。'
- en: The "else" is explicitly handled. There is no chance of forgetting to do an
    assignment in one of the branches.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “else”被明确处理。没有忘记在其中一个分支中进行赋值的机会。
- en: It is not possible to forget to assign `result`, because then the variable would
    not even exist!
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能忘记赋值 `result`，因为那样变量甚至都不存在！
- en: Expression-oriented style is not a choice in F#, and it is one of the things
    that requires a change of approach when coming from an imperative background.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式导向的风格在 F# 中不是一个选择，这是从命令式背景转变时需要改变方法的事情之一。
- en: Algebraic Types
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代数类型
- en: 'The type system in F# is based on the concept of **algebraic types**. That
    is, new compound types are built by combining existing types in two different
    ways:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的类型系统基于**代数类型**的概念。也就是说，通过两种不同的方式组合现有类型来构建新的复合类型：
- en: First, a combination of values, each picked from a set of types. These are called
    "product" types.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，一组值的组合，每个值从一组类型中选择。这些被称为“积”类型。
- en: Of, alternately, as a disjoint union representing a choice between a set of
    types. These are called "sum" types.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，作为表示一组类型选择的不相交并集。这些被称为“和”类型。
- en: 'For example, given existing types `int` and `bool`, we can create a new product
    type that must have one of each:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定现有类型 `int` 和 `bool`，我们可以创建一个必须包含每种类型的新积类型：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, we can create a new union/sum type that has a choice between
    each type:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以创建一个新的联合/和类型，其中每种类型之间有一个选择：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These "choice" types are not available in C#, but are incredibly useful for
    modeling many real-world cases, such as states in a state machine (which is a
    surprisingly common theme in many domains).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“选择”类型在 C# 中不可用，但对于建模许多现实情况非常有用，比如状态机中的状态（这在许多领域中是一个令人惊讶地常见的主题）。
- en: And by combining "product" and "sum" types in this way, it is easy to create
    a rich set of types that accurately models any business domain. For examples of
    this in action, see the posts on [low overhead type definitions](conciseness-type-definitions.html)
    and [using the type system to ensure correct code](correctness-type-checking).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式组合“积”和“和”类型，可以轻松创建一个丰富的类型集，准确地模拟任何业务领域。有关此操作的示例，请参见[低开销类型定义](conciseness-type-definitions.html)和[使用类型系统确保正确代码](correctness-type-checking)的文章。
- en: Pattern matching for flow of control
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于控制流的模式匹配
- en: 'Most imperative languages offer a variety of control flow statements for branching
    and looping:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数命令式语言提供了各种控制流语句用于分支和循环：
- en: '`if-then-else` (and the ternary version `bool ? if-true : if-false`)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if-then-else`（以及三元版本 `bool ? if-true : if-false`）'
- en: '`case` or `switch` statements'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case` 或 `switch` 语句'
- en: '`for` and `foreach` loops, with `break` and `continue`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 和 `foreach` 循环，带有 `break` 和 `continue`'
- en: '`while` and `until` loops'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 和 `until` 循环'
- en: and even the dreaded `goto`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至可怕的 `goto`
- en: F# does support some of these, but F# also supports the most general form of
    conditional expression, which is **pattern-matching**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: F# 确实支持其中一些，但 F# 也支持最一般形式的条件表达式，即**模式匹配**。
- en: 'A typical matching expression that replaces `if-then-else` looks like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 替换 `if-then-else` 的典型匹配表达式如下：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And the replacement of `switch` might look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 而替代 `switch` 可能看起来像这样：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, loops are generally done using recursion, and typically look something
    like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，循环通常使用递归完成，通常看起来像这样：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although the match expression seems unnecessarily complicated at first, you'll
    see that in practice it is both elegant and powerful.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然匹配表达式起初看起来不必要复杂，但实际上你会发现它既优雅又强大。
- en: For the benefits of pattern matching, see the post on [exhaustive pattern matching](correctness-exhaustive-pattern-matching),
    and for a worked example that uses pattern matching heavily, see the [roman numerals
    example](roman-numerals.html).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有关模式匹配的好处，请参见[穷尽模式匹配](correctness-exhaustive-pattern-matching)的文章，以及一个大量使用模式匹配的示例，请参见[罗马数字示例](roman-numerals.html)。
- en: Pattern matching with union types
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用联合类型进行模式匹配
- en: We mentioned above that F# supports a "union" or "choice" type. This is used
    instead of inheritance to work with different variants of an underlying type.
    Pattern matching works seamlessly with these types to create a flow of control
    for each choice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面提到 F# 支持“联合”或“选择”类型。这用于处理底层类型的不同变体，而不是使用继承。模式匹配与这些类型无缝配合，为每个选择创建控制流程。
- en: In the following example, we create a `Shape` type representing four different
    shapes and then define a `draw` function with different behavior for each kind
    of shape. This is similar to polymorphism in an object oriented language, but
    based on functions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们创建了一个代表四种不同形状的 `Shape` 类型，然后为每种形状定义了一个具有不同行为的 `draw` 函数。这类似于面向对象语言中的多态性，但基于函数。
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A few things to note:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一些需要注意的事项：
- en: As usual, we didn't have to specify any types. The compiler correctly determined
    that the shape parameter for the "draw" function was of type `Shape`.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，我们不必指定任何类型。编译器正确地确定了“draw”函数的形状参数的类型为 `Shape`。
- en: You can see that the `match..with` logic not only matches against the internal
    structure of the shape, but also assigns values based on what is appropriate for
    the shape.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以看到 `match..with` 逻辑不仅匹配了形状的内部结构，还根据形状适当地分配值。
- en: The underscore is similar to the "default" branch in a switch statement, except
    that in F# it is required -- every possible case must always be handled. If you
    comment out the line
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线类似于 switch 语句中的“默认”分支，只是在 F# 中是必需的 -- 必须始终处理每种可能的情况。如果你注释掉这行
- en: '[PRE31]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: see what happens when you compile!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 看看编译时会发生什么！
- en: These kinds of choice types can be simulated somewhat in C# by using subclasses
    or interfaces, but there is no built in support in the C# type system for this
    kind of exhaustive matching with error checking.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这类选择类型在 C# 中可以通过使用子类或接口进行某种程度的模拟，但在 C# 类型系统中没有内置支持这种具有错误检查的穷尽匹配。
- en: Conciseness
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁性
- en: Conciseness
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁性
- en: After having seen some simple code, we will now move on to demonstrating the
    major themes (conciseness, convenience, correctness, concurrency and completeness),
    filtered through the concepts of types, functions and pattern matching.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在看了一些简单的代码之后，我们现在将演示主要主题（简洁性、方便性、正确性、并发性和完整性），通过类型、函数和模式匹配的概念进行过滤。
- en: With the next few posts, we'll examine the features of F# that aid conciseness
    and readability.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几篇文章中，我们将研究 F# 的特性，这些特性有助于简洁和易读性。
- en: An important goal for most mainstream programming languages is a good balance
    of readability and conciseness. Too much conciseness can result in hard-to-understand
    or obfuscated code (APL anyone?), while too much verbosity can easily swamp the
    underlying meaning. Ideally, we want a high signal-to-noise ratio, where every
    word and character in the code contributes to the meaning of the code, and there
    is minimal boilerplate.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主流编程语言的一个重要目标是良好的可读性和简洁性的平衡。太多的简洁性可能导致难以理解或混淆的代码（APL 任何人？），而太多的冗长可能很容易淹没底层含义。理想情况下，我们希望有一个高信噪比，在代码的每个词和字符都对代码的含义做出贡献，并且有最少的样板代码。
- en: 'Why is conciseness important? Here are a few reasons:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么简洁性很重要？以下是一些原因：
- en: '**A concise language tends to be more declarative**, saying *what* the code
    should do rather than *how* to do it. That is, declarative code is more focused
    on the high-level logic rather than the nuts and bolts of the implementation.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁的语言往往更具声明性**，它说 *代码应该做什么* 而不是 *如何做*。也就是说，声明性代码更关注高层逻辑，而不是实现的细节。'
- en: '**It is easier to reason about correctness** if there are fewer lines of code
    to reason about!'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果要思考的代码行数较少，那么正确性就更容易理解！**'
- en: And of course, **you can see more code on a screen** at a time. This might seem
    trivial, but the more you can see, the more you can grasp as well.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，**你可以在屏幕上看到更多的代码**。这可能看起来微不足道，但你能看到的越多，你就能理解的越多。
- en: 'As you have seen, compared with C#, F# is generally much more concise. This
    is due to features such as:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，与 C# 相比，F# 通常更为简洁。这是由于诸如以下特性：
- en: '**Type inference** and **low overhead type definitions**. One of the major
    reasons for F#''s conciseness and readability is its type system. F# makes it
    very easy to create new types as you need them. They don''t cause visual clutter
    either in their definition or in use, and the type inference system means that
    you can use them freely without getting distracted by complex type syntax.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型推断**和**低开销的类型定义**。F#之所以简洁易读的一个重要原因就是其类型系统。F#使得根据需要创建新类型变得非常容易。它们在定义或使用时都不会造成视觉混乱，并且类型推断系统意味着您可以自由地使用它们，而不会被复杂的类型语法分散注意力。'
- en: '**Using functions to extract boilerplate code**. The DRY principle ("don''t
    repeat yourself") is a core principle of good design in functional languages as
    well as object-oriented languages. In F# it is extremely easy to extract repetitive
    code into common utility functions, which allows you to focus on the important
    stuff.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用函数提取样板代码**。DRY原则（“不要重复自己”）是函数式语言以及面向对象语言中良好设计的核心原则。在F#中，将重复的代码提取到常用实用函数中非常容易，这样可以让您专注于重要的事情。'
- en: '**Composing complex code from simple functions** and **creating mini-languages**.
    The functional approach makes it easy to create a set of basic operations and
    then combine these building blocks in various ways to build up more complex behaviors.
    In this way, even the most complex code is still very concise and readable.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由简单函数组合复杂代码**和**创建迷你语言**。函数式方法使得创建一组基本操作易如反掌，然后以各种方式组合这些构建块以构建更复杂的行为。通过这种方式，即使是最复杂的代码仍然非常简洁易读。'
- en: '**Pattern matching**. We''ve seen pattern matching as a glorified switch statement,
    but in fact it is much more general, as it can compare expressions in a number
    of ways, matching on values, conditions, and types, and then assign or extract
    values, all at the same time.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式匹配**。我们已经将模式匹配视为一个高级的switch语句，但实际上它要通用得多，因为它可以以多种方式比较表达式，匹配值、条件和类型，然后同时赋值或提取值。'
- en: Type inference
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: Type inference
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: As you have already seen, F# uses a technique called "type inference" to greatly
    reduce the number of type annotations that need to be explicitly specified in
    normal code. And even when types do need to be specified, the syntax is less longwinded
    compared to C#.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，F#使用一种称为“类型推断”的技术来大大减少需要在普通代码中显式指定的类型注解的数量。即使需要指定类型，与C#相比，语法也不那么冗长。
- en: 'To see this, here are some C# methods that wrap two standard LINQ functions.
    The implementations are trivial, but the method signatures are extremely complex:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这一点，这里有一些包装了两个标准LINQ函数的C#方法。这些实现是微不足道的，但是方法签名非常复杂：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And here are the exact F# equivalents, showing that no type annotations are
    needed at all!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 而这里是确切的F#等效代码，显示根本不需要任何类型注解！
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You might notice that the standard F# implementations for "filter" and "groupBy"
    have the parameters in exactly the opposite order from the LINQ implementations
    used in C#. The "source" parameter is placed last, rather than first. There is
    a reason for this, which will be explained in the [thinking functionally](thinking-functionally.html)
    series.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，“filter”和“groupBy”的标准F#实现与C#中使用的LINQ实现完全相反。将“source”参数放在最后，而不是首位。这有一个原因，将在[函数式思维](thinking-functionally.html)系列中解释。
- en: The type inference algorithm is excellent at gathering information from many
    sources to determine the types. In the following example, it correctly deduces
    that the `list` value is a list of strings.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断算法非常擅长从许多来源收集信息以确定类型。在下面的示例中，它正确推断出`list`值是一个字符串列表。
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And in this example, it correctly deduces that the `sumLengths` function takes
    a list of strings and returns an int.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这个示例中，它正确推断出`sumLengths`函数接受一个字符串列表并返回一个整数。
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Low overhead type definitions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低开销的类型定义
- en: Low overhead type definitions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低开销的类型定义
- en: In C#, there is a disincentive for creating new types ? the lack of type inference
    means you need to explicitly specify types in most places, resulting in brittleness
    and more visual clutter. As a result, there is always a temptation to create monolithic
    classes rather than modularizing them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，创建新类型有一个不利因素——缺乏类型推断意味着您需要在大多数地方显式指定类型，导致代码脆弱且视觉混乱更多。因此，总是有诱惑力去创建庞大的类，而不是将它们模块化。
- en: In F# there is no penalty for making new types, so it is quite common to have
    hundreds if not thousands of them. Every time you need to define a structure,
    you can create a special type, rather than reusing (and overloading) existing
    types such as strings and lists.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，创建新类型没有任何惩罚，因此拥有数百甚至数千个类型是相当常见的。每次需要定义结构时，您都可以创建一个特殊类型，而不是重用（并重载）现有类型，例如字符串和列表。
- en: This means that your programs will be more type-safe, more self documenting,
    and more maintainable (because when the types change you will immediately get
    compile-time errors rather than runtime errors).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您的程序将更加类型安全，更具自我文档化，并且更易于维护（因为当类型更改时，您将立即获得编译时错误而不是运行时错误）。
- en: 'Here are some examples of one-liner types in F#:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 F# 中一行类型的一些示例：
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: F# types and domain driven design
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 类型和领域驱动设计
- en: The conciseness of the type system in F# is particularly useful when doing domain
    driven design (DDD). In DDD, for each real world entity and value object, you
    ideally want to have a corresponding type. This can mean creating hundreds of
    "little" types, which can be tedious in C#.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行领域驱动设计（DDD）时，F# 类型系统的简洁性尤其有用。在 DDD 中，对于每个真实世界的实体和值对象，您理想情况下希望有一个相应的类型。这可能意味着创建数百个
    "小" 类型，在 C# 中可能会很烦琐。
- en: Furthermore, "value" objects in DDD should have structural equality, meaning
    that two objects containing the same data should always be equal. In C# this can
    mean more tedium in overriding `IEquatable<T>`, but in F#, you get this for free
    by default.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 DDD 中，"值" 对象应具有结构相等性，这意味着包含相同数据的两个对象应始终相等。在 C# 中，这可能意味着重写 `IEquatable<T>`
    更烦琐，但在 F# 中，默认情况下您可以免费获得此功能。
- en: To show how easy it is to create DDD types in F#, here are some example types
    that might be created for a simple "customer" domain.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示在 F# 中创建 DDD 类型是多么容易，这里是为一个简单的 "客户" 领域可能创建的一些示例类型。
- en: '[PRE37]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code fragment contains 17 type definitions in just a few lines, but with
    minimal complexity. How many lines of C# code would you need to do the same thing?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段仅几行就包含了 17 个类型定义，但复杂度很低。要做同样的事情，您需要多少行 C# 代码？
- en: Obviously, this is a simplified version with just the basic types ? in a real
    system, constraints and other methods would be added. But note how easy it is
    to create lots of DDD value objects, especially wrapper types for strings, such
    as "`ZipCode`" and "`Email`". By using these wrapper types, we can enforce certain
    constraints at creation time, and also ensure that these types don't get confused
    with unconstrained strings in normal code. The only "entity" type is the `CustomerAccount`,
    which is clearly indicated as having special treatment for equality and comparison.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这只是一个简化版本，只包含基本类型？在一个真实系统中，会添加约束和其他方法。但请注意，创建大量的 DDD 值对象是多么容易，特别是字符串的包装类型，例如"`ZipCode`"和"`Email`"。通过使用这些包装类型，我们可以在创建时强制执行某些约束，并确保这些类型在正常代码中不会与不受约束的字符串混淆。唯一的
    "实体" 类型是 `CustomerAccount`，明确指出了对等性和比较的特殊处理。
- en: For a more in-depth discussion, see the series called ["Domain driven design
    in F#"](domain-driven-design-in-fsharp.md).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更详细的讨论，请参阅名为 ["F# 中的领域驱动设计"](domain-driven-design-in-fsharp.md) 的系列。
- en: Using functions to extract boilerplate code
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数提取样板代码
- en: Using functions to extract boilerplate code
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数提取样板代码
- en: 'In the very first example in this series, we saw a simple function that calculated
    the sum of squares, implemented in both F# and C#. Now let''s say we want some
    new functions which are similar, such as:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列的第一个示例中，我们看到了一个简单的函数，该函数计算了平方和，分别在 F# 和 C# 中实现。现在让我们假设我们想要一些类似的新函数，例如：
- en: Calculating the product of all the numbers up to N
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算到 N 的所有数字的乘积
- en: Counting the sum of odd numbers up to N
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算到 N 的奇数之和
- en: The alternating sum of the numbers up to N
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到 N 的交替和的数字
- en: Obviously, all these requirements are similar, but how would you extract any
    common functionality?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，所有这些要求都是相似的，但您如何提取任何共同的功能？
- en: 'Let''s start with some straightforward implementations in C# first:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从一些简单的 C# 实现开始：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What do all these implementations have in common? The looping logic! As programmers,
    we are told to remember the DRY principle ("don''t repeat yourself"), yet here
    we have repeated almost exactly the same loop logic each time. Let''s see if we
    can extract just the differences between these three methods:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些实现有什么共同点？循环逻辑！作为程序员，我们被告知记住 DRY 原则（"不要重复你自己"），然而在这里我们几乎完全重复了每个方法中的相同循环逻辑。让我们看看是否可以仅提取这三种方法之间的差异：
- en: '| Function | Initial value | Inner loop logic |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 初始值 | 内部循环逻辑 |'
- en: '| --- | --- | --- |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Product | product=1 | Multiply the i''th value with the running total |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| Product | product=1 | 将第i个值与运行总和相乘 |'
- en: '| SumOfOdds | sum=0 | Add the i''th value to the running total if not even
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| SumOfOdds | sum=0 | 如果不是偶数，则将第i个值加到运行总和上 |'
- en: '| AlternatingSum | int sum = 0 bool isNeg = true | Use the isNeg flag to decide
    whether to add or subtract, and flip the flag for the next pass. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| AlternatingSum | int sum = 0 bool isNeg = true | 使用isNeg标志来决定是加还是减，并为下一次循环翻转标志。
    |'
- en: 'Is there a way to strip the duplicate code and focus on the just the setup
    and inner loop logic? Yes there is. Here are the same three functions in F#:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种方法可以消除重复的代码，只关注设置和内部循环逻辑？是的，有的。下面是相同的三个函数的F#版本：
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All three of these functions have the same pattern:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数都具有相同的模式：
- en: Set up the initial value
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置初始值
- en: Set up an action function that will be performed on each element inside the
    loop.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个在循环内每个元素上执行的动作函数。
- en: Call the library function `List.fold`. This is a powerful, general purpose function
    which starts with the initial value and then runs the action function for each
    element in the list in turn.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用库函数`List.fold`。这是一个功能强大的通用函数，它从初始值开始，然后依次对列表中的每个元素运行动作函数。
- en: 'The action function always has two parameters: a running total (or state) and
    the list element to act on (called "x" in the above examples).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 动作函数始终有两个参数：一个运行总和（或状态）和要操作的列表元素（在上面的示例中称为"x"）。
- en: In the last function, `alternatingSum`, you will notice that it used a tuple
    (pair of values) for the initial value and the result of the action. This is because
    both the running total and the `isNeg` flag must be passed to the next iteration
    of the loop -- there are no "global" values that can be used. The final result
    of the fold is also a tuple so we have to use the "snd" (second) function to extract
    the final total that we want.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个函数`alternatingSum`中，你会注意到它使用了一个元组（一对值）作为初始值和操作的结果。这是因为运行总和和`isNeg`标志都必须传递到循环的下一次迭代中
    -- 没有可以使用的"全局"值。折叠的最终结果也是一个元组，所以我们必须使用"snd"（第二个）函数来提取我们想要的最终总和。
- en: 'By using `List.fold` and avoiding any loop logic at all, the F# code gains
    a number of benefits:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`List.fold`并完全避免任何循环逻辑，F#代码获得了许多好处：
- en: '**The key program logic is emphasized and made explicit**. The important differences
    between the functions become very clear, while the commonalities are pushed to
    the background.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键的程序逻辑被强调并显式地表达出来**。这些函数之间的重要区别变得非常明显，而共同点则被推到了后台。'
- en: '**The boilerplate loop code has been eliminated**, and as a result the code
    is more condensed than the C# version (4-5 lines of F# code vs. at least 9 lines
    of C# code)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**繁琐的循环代码已经被消除**，结果代码比C#版本更加简洁（4-5行F#代码 vs. 至少9行C#代码）'
- en: '**There can never be a error in the loop logic** (such as off-by-one) because
    that logic is not exposed to us.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环逻辑中永远不会出现错误**（比如说错位一）因为这个逻辑对我们来说是不可见的。'
- en: 'By the way, the sum of squares example could also be written using `fold` as
    well:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，平方和的例子也可以使用`fold`来写：
- en: '[PRE40]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '"Fold" in C#'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中的"Fold"
- en: 'Can you use the "fold" approach in C#? Yes. LINQ does have an equivalent to
    `fold`, called `Aggregate`. And here is the C# code rewritten to use it:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在C#中使用"fold"方法吗？可以。LINQ确实有一个等价于`fold`的方法，叫做`Aggregate`。下面是重写为使用它的C#代码：
- en: '[PRE41]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Well, in some sense these implementations are simpler and safer than the original
    C# versions, but all the extra noise from the generic types makes this approach
    much less elegant than the equivalent code in F#. You can see why most C# programmers
    prefer to stick with explicit loops.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，从某种意义上说，这些实现比原始的C#版本更简单、更安全，但是来自通用类型的所有额外噪音使得这种方法比等效的F#代码不那么优雅。你可以看到，大多数C#程序员更喜欢使用显式循环。
- en: A more relevant example
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更相关的例子
- en: A slightly more relevant example that crops up frequently in the real world
    is how to get the "maximum" element of a list when the elements are classes or
    structs. The LINQ method 'max' only returns the maximum value, not the whole element
    that contains the maximum value.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中经常出现的一个稍微更相关的例子是，当元素是类或结构体时，如何获取列表的"最大"元素。LINQ方法'max'只返回最大值，而不是包含最大值的整个元素。
- en: 'Here''s a solution using an explicit loop:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用显式循环的解决方案：
- en: '[PRE42]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Doing this in LINQ seems hard to do efficiently (that is, in one pass), and
    has come up as a [Stack Overflow question](http://stackoverflow.com/questions/1101841/linq-how-to-perform-max-on-a-property-of-all-objects-in-a-collection-and-ret).
    Jon Skeet event wrote an [article about it](http://codeblog.jonskeet.uk/2005/10/02/a-short-case-study-in-linq-efficiency/).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在LINQ中这样做似乎很难高效地完成（即，在一次遍历中），并且已经出现了一个[Stack Overflow问题](http://stackoverflow.com/questions/1101841/linq-how-to-perform-max-on-a-property-of-all-objects-in-a-collection-and-ret)。Jon
    Skeet甚至写了一篇[关于此的文章](http://codeblog.jonskeet.uk/2005/10/02/a-short-case-study-in-linq-efficiency/)。
- en: Again, fold to the rescue!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，fold拯救！
- en: 'And here''s the C# code using `Aggregate`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`Aggregate`的C#代码：
- en: '[PRE43]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that this C# version returns null for an empty list. That seems dangerous
    -- so what should happen instead? Throwing an exception? That doesn't seem right
    either.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个C#版本对于空列表返回null。这似乎很危险--那么应该发生什么？抛出异常？这似乎也不对。
- en: 'Here''s the F# code using fold:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用fold的F#代码：
- en: '[PRE44]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The F# code has two parts:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: F#代码分为两部分：
- en: the `innerMaxNameAndSize` function is similar to what we have seen before.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innerMaxNameAndSize`函数与我们之前看到的类似。'
- en: the second bit, `match list with`, branches on whether the list is empty or
    not. With an empty list, it returns a `None`, and in the non-empty case, it returns
    a `Some`. Doing this guarantees that the caller of the function has to handle
    both cases.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分，`match list with`，根据列表是否为空进行分支。对于空列表，它返回`None`，而在非空情况下，它返回`Some`。这样做可以确保函数的调用者必须处理这两种情况。
- en: 'And a test:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个测试：
- en: '[PRE45]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Actually, I didn't need to write this at all, because F# already has a `maxBy`
    function!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我根本不需要写这个，因为F#已经有了`maxBy`函数！
- en: '[PRE46]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: But as you can see, it doesn't handle empty lists well. Here's a version that
    wraps the `maxBy` safely.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你所看到的，它不能很好地处理空列表。这里有一个包装`maxBy`的安��版本。
- en: '[PRE47]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using functions as building blocks
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数作为构建块
- en: Using functions as building blocks
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数作为构建块
- en: A well-known principle of good design is to create a set of basic operations
    and then combine these building blocks in various ways to build up more complex
    behaviors. In object-oriented languages, this goal gives rise to a number of implementation
    approaches such as "fluent interfaces", "strategy pattern", "decorator pattern",
    and so on. In F#, they are all done the same way, via function composition.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好设计的众所周知原则是创建一组基本操作，然后以各种方式组合这些构建块来构建更复杂的行为。在面向对象的语言中，这个目标引发了许多实现方法，如“流畅接口”、“策略模式”、“装饰者模式”等。在F#中，它们都是通过函数组合完成的。
- en: 'Let''s start with a simple example using integers. Say that we have created
    some basic functions to do arithmetic:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用整数的简单示例开始。假设我们已经创建了一些执行算术运算的基本函数：
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we want to create new functions that build on these:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要创建建立在这些基础上的新函数：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The "`>>`" operator is the composition operator. It means: do the first function,
    and then do the second.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: “`>>`”运算符是组合运算符。它的意思是：先执行第一个函数，然后执行第二个函数。
- en: Note how concise this way of combining functions is. There are no parameters,
    types or other irrelevant noise.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种组合函数的简洁性。没有参数、类型或其他无关的噪音。
- en: 'To be sure, the examples could also have been written less concisely and more
    explicitly as:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保，这些示例也可以写得不那么简洁，更加显式：
- en: '[PRE50]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'But this more explicit style is also a bit more cluttered:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种更显式的风格也有点混乱：
- en: In the explicit style, the x parameter and the parentheses must be added, even
    though they don't add to the meaning of the code.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显式风格中，即使x参数和括号并不增加代码的含义，也必须添加它们。
- en: And in the explicit style, the functions are written back-to-front from the
    order they are applied. In my example of `add2ThenMult3` I want to add 2 first,
    and then multiply. The `add2 >> mult3` syntax makes this visually clearer than
    `mult3(add2 x)`.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显式风格中，函数是按照它们被应用的顺序从后往前编写的。在我的`add2ThenMult3`示例中，我想先加2，然后再乘。`add2 >> mult3`的语法比`mult3(add2
    x)`在视觉上更清晰。
- en: 'Now let''s test these compositions:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试这些组合：
- en: '[PRE51]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Extending existing functions
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展现有函数
- en: Now say that we want to decorate these existing functions with some logging
    behavior. We can compose these as well, to make a new function with the logging
    built in.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要用一些日志记录行为装饰这些现有函数。我们也可以将它们组合起来，以便创建一个内置日志记录的新函数。
- en: '[PRE52]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our new function, `mult3ThenSquareLogged`, has an ugly name, but it is easy
    to use and nicely hides the complexity of the functions that went into it. You
    can see that if you define your building block functions well, this composition
    of functions can be a powerful way to get new functionality.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新函数 `mult3ThenSquareLogged` 的名称很难看，但使用起来很容易，并且很好地隐藏了其中涉及的函数的复杂性。你可以看到，如果你将构建块函数定义得很好，那么函数的这种组合方式可以是获得新功能的强大方法。
- en: But wait, there's more! Functions are first class entities in F#, and can be
    acted on by any other F# code. Here is an example of using the composition operator
    to collapse a list of functions into a single operation.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，这还不止！函数在 F# 中是一等公民实体，并且可以被任何其他 F# 代码所影响。以下是使用组合运算符将函数列表合并为单个操作的示例。
- en: '[PRE53]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Mini languages
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迷你语言
- en: Domain-specific languages (DSLs) are well recognized as a technique to create
    more readable and concise code. The functional approach is very well suited for
    this.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 特定领域的语言（DSL）被广泛认可为创建更易读和简洁的代码的技术。函数式方法非常适合这种情况。
- en: If you need to, you can go the route of having a full "external" DSL with its
    own lexer, parser, and so on, and there are various toolsets for F# that make
    this quite straightforward.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要的话，你可以采用完整的"外部"DSL，具有自己的词法分析器、解析器等等，而且有各种适用于 F# 的工具集可以使这一过程变得非常简单。
- en: But in many cases, it is easier to stay within the syntax of F#, and just design
    a set of "verbs" and "nouns" that encapsulate the behavior we want.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 但在许多情况下，留在 F# 的语法范围内并设计一组"动词"和"名词"来封装我们想要的行为会更容易。
- en: The ability to create new types concisely and then match against them makes
    it very easy to set up fluent interfaces quickly. For example, here is a little
    function that calculates dates using a simple vocabulary. Note that two new enum-style
    types are defined just for this one function.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 能够简洁地创建新类型，然后针对它们进行匹配，使得快速设置流畅接口变得非常容易。例如，下面是一个使用简单词汇计算日期的小函数。请注意，为了这一个函数，定义了两个新的枚举风格的类型。
- en: '[PRE54]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The example above only has one "verb", using lots of types for the "nouns".
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例只有一个"动词"，使用了许多类型作为"名词"。
- en: The following example demonstrates how you might build the functional equivalent
    of a fluent interface with many "verbs".
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何构建具有许多"动词"的函数式等效的流畅接口。
- en: Say that we are creating a drawing program with various shapes. Each shape has
    a color, size, label and action to be performed when clicked, and we want a fluent
    interface to configure each shape.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在创建一个具有各种形状的绘图程序。每个形状都有颜色、大小、标签和点击时执行的操作，并且我们希望使用流畅接口来配置每个形状。
- en: 'Here is an example of what a simple method chain for a fluent interface in
    C# might look like:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 C# 中用于流畅接口的简单方法链的示例：
- en: '[PRE55]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now the concept of "fluent interfaces" and "method chaining" is really only
    relevant for object-oriented design. In a functional language like F#, the nearest
    equivalent would be the use of the pipeline operator to chain a set of functions
    together.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“流畅接口”和“方法链”概念实际上只与面向对象设计相关。在像 F# 这样的函数式语言中，最接近的相当于使用管道运算符将一组函数链接在一起。
- en: 'Let''s start with the underlying Shape type:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从底层的 Shape 类型开始：
- en: '[PRE56]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We''ll add some basic functions:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些基本的函数：
- en: '[PRE57]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For "method chaining" to work, every function should return an object that can
    be used next in the chain. So you will see that the "`display`" function returns
    the shape, rather than nothing.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要使"方法链"工作，每个函数都应该返回一个可以在链中使用的对象。因此，你会发现"`display`"函数返回形状，而不是什么都不返回。
- en: Next we create some helper functions which we expose as the "mini-language",
    and will be used as building blocks by the users of the language.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一些辅助函数，将它们公开为"迷你语言"，并将被语言的用户用作构建块。
- en: '[PRE58]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice that `appendClickAction` takes a function as a parameter and composes
    it with the existing click action. As you start getting deeper into the functional
    approach to reuse, you start seeing many more "higher order functions" like this,
    that is, functions that act on other functions. Combining functions like this
    is one of the keys to understanding the functional way of programming.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`appendClickAction`接受一个函数作为参数，并将其与现有的点击操作组合起来。当你开始深入研究函数式的重用方法时，你会看到更多像这样的"高阶函数"，即作用于其他函数的函数。像这样组合函数是理解函数式编程方法的关键之一。
- en: Now as a user of this "mini-language", I can compose the base helper functions
    into more complex functions of my own, creating my own function library. (In C#
    this kind of thing might be done using extension methods.)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在作为这个“小语言”的用户，我可以将基础辅助函数组合成自己更复杂的函数，创建自己的函数库。（在 C# 中，这种事情可能使用扩展方法完成。）
- en: '[PRE59]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: I can then combine these functions together to create objects with the desired
    behavior.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以将这些函数组合在一起，以创建具有所需行为的对象。
- en: '[PRE60]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the second case, I actually pass two functions to `appendClickAction`, but
    I compose them into one first. This kind of thing is trivial to do with a well
    structured functional library, but it is quite hard to do in C# without having
    lambdas within lambdas.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我实际上将两个函数传递给 `appendClickAction`，但我先将它们组合成一个。这种事情在结构良好的函数库中非常容易做到，但在没有使用嵌套lambda的情况下，在
    C# 中做到这一点非常困难。
- en: Here is a more complex example. We will create a function "`showRainbow`" that,
    for each color in the rainbow, sets the color and displays the shape.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更复杂的例子。我们将创建一个名为 "`showRainbow`" 的函数，对彩虹中的每种颜色进行设置并显示形状。
- en: '[PRE61]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice that the functions are getting more complex, but the amount of code is
    still quite small. One reason for this is that the function parameters can often
    be ignored when doing function composition, which reduces visual clutter. For
    example, the "`showRainbow`" function does take a shape as a parameter, but it
    is not explicitly shown! This elision of parameters is called "point-free" style
    and will be discussed further in the ["thinking functionally"](thinking-functionally.html)
    series
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数变得更加复杂，但代码量仍然相当少。其中一个原因是在进行函数组合时，函数参数通常可以被忽略，这减少了视觉杂乱。例如，"`showRainbow`"
    函数确实将形状作为参数，但没有明确显示！这种参数省略称为“无点”风格，并将在 ["思考函数式"](thinking-functionally.html) 系列中进一步讨论
- en: Pattern matching for conciseness
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁性的模式匹配
- en: Pattern matching for conciseness
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁性的模式匹配
- en: So far we have seen the pattern matching logic in the `match..with` expression,
    where it seems to be just a switch/case statement. But in fact pattern matching
    is much more general ? it can compare expressions in a number of ways, matching
    on values, conditions, and types, and then assign or extract values, all at the
    same time.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在 `match..with` 表达式中看到了模式匹配逻辑，在那里它似乎只是一个 switch/case 语句。但实际上，模式匹配更加通用，它可以以多种方式比较表达式，匹配值、条件和类型，然后同时分配或提取值。
- en: Pattern matching will be discussed in depth in later posts, but to start with,
    here is a little taster of one way that it aids conciseness. We'll look at the
    way pattern matching is used for binding values to expressions (the functional
    equivalent of assigning to variables).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配将在后续帖子中深入讨论，但首先，我们来看一看它如何帮助简洁性。我们将研究模式匹配用于将值绑定到表达式（函数等价于分配给变量）的方式。
- en: 'In the following examples, we are binding to the internal members of tuples
    and lists directly:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们直接绑定到元组和列表的内部成员：
- en: '[PRE62]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can also bind values to the inside of complex structures such as records.
    In the following example, we will create an "`Address`" type, and then a "`Customer`"
    type which contains an address. Next, we will create a customer value, and then
    match various properties against it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将值绑定到诸如记录之类的复杂结构的内部。在以下示例中，我们将创建一个 "`Address`" 类型，然后创建一个包含地址的 "`Customer`"
    类型。接下来，我们将创建一个客户值，然后匹配各种属性。
- en: '[PRE63]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the last example, note how we could reach right into the `Address` substructure
    and pull out the street as well as the customer name.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，请注意我们如何可以直接访问 `Address` 子结构并提取出街道以及客户姓名。
- en: This ability to process a nested structure, extract only the fields you want,
    and assign them to values, all in a single step, is very useful. It removes quite
    a bit of coding drudgery, and is another factor in the conciseness of typical
    F# code.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 处理嵌套结构、仅提取所需字段并将它们分配给值的能力，所有这些都可以在单个步骤中完成，非常有用。它消除了相当多的编码繁琐，也是 F# 代码典型简洁的另一个因素。
- en: Convenience
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便利
- en: Convenience
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便利
- en: In the next set of posts, we will explore a few more features of F# that I have
    grouped under the theme of "convenience". These features do not necessarily result
    in more concise code, but they do remove much of the drudgery and boilerplate
    code that would be needed in C#.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的一系列帖子中，我们将探讨 F# 的一些更多功能，我将其归为“便利”主题下。这些功能不一定会导致更简洁的代码，但它们确实消除了在 C# 中需要的大量繁琐和样板代码。
- en: '**Useful "out-of-the-box" behavior for types**. Most types that you create
    will immediately have some useful behavior, such as immutability and built-in
    equality ? functionality that has to be explicitly coded for in C#.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型的有用的“开箱即用”行为**。你创建的大多数类型将立即具有一些有用的行为，例如不可变性和内置相等性 —— 这些功能在 C# 中必须显式编码。'
- en: '**All functions are "interfaces"**, meaning that many of the roles that interfaces
    play in object-oriented design are implicit in the way that functions work. And
    similarly, many object-oriented design patterns are unnecessary or trivial within
    a functional paradigm.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有函数都是“接口”**，这意味着函数的工作方式隐含地扮演着对象导向设计中接口扮演的许多角色。同样，许多对象导向设计模式在函数式范式中是不必要的或微不足道的。'
- en: '**Partial application**. Complicated functions with many parameters can have
    some of the parameters fixed or "baked in" and yet leave other parameters open.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分应用**。具有许多参数的复杂函数可以固定或“烘焙”部分参数，但仍然保持其他参数开放。'
- en: '**Active patterns**. Active patterns are a special kind of pattern where the
    pattern can be matched or detected dynamically, rather than statically. They are
    great for simplifying frequently used parsing and grouping behaviors.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动模式**。活动模式是一种特殊的模式，其中模式可以动态匹配或检测，而不是静态的。它们非常适合简化频繁使用的解析和分组行为。'
- en: Out-of-the-box behavior for types
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型的开箱即用行为
- en: Out-of-the-box behavior for types
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型的开箱即用行为
- en: One nice thing about F# is that most types immediately have some useful "out-of-the-box"
    behavior such as immutability and built-in equality, functionality that often
    has to be explicitly coded for in C#.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的一个好处是，大多数类型立即具有一些有用的“开箱即用”行为，例如不可变性和内置相等性，这些功能在 C# 中通常需要显式编码。
- en: By "most" F# types, I mean the core "structural" types such as tuples, records,
    unions, options, lists, etc. Classes and some other types have been added to help
    with .NET integration, but lose some of the power of the structural types.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的“大多数”F#类型指的是核心的“结构”类型，例如元组、记录、联合、选项、列表等。类和其他一些类型已经被添加以帮助与.NET集成，但失去了一些结构类型的功能。
- en: 'This built-in functionality for these core types includes:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心类型的内置功能包括：
- en: Immutability
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Pretty printing when debugging
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试时进行漂亮的打印
- en: Equality
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性
- en: Comparisons
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较
- en: Each of these is addressed below.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下面将详细介绍每一个。
- en: F# types have built-in immutability
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 类型具有内置的不可变性
- en: In C# and Java, it is has become good practice to create immutable classes whenever
    possible. In F#, you get this for free.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 和 Java 中，创建不可变类已经成为良好的做法。在 F# 中，你可以免费得到这一点。
- en: 'Here is an immutable type in F#:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 F# 中的一个不可变类型：
- en: '[PRE64]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And here is how the same type is typically coded in C#:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相同类型在 C# 中通常的编码方式：
- en: '[PRE65]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That's 10 lines to do the same thing as 1 line of F#.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要10行来完成与 F# 中的 1 行相同的事情。
- en: Most F# types have built-in pretty printing
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大多数 F# 类型都具有内置的漂亮打印功能
- en: In F#, you don't have to override `ToString()` for most types -- you get pretty
    printing for free!
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，你不必为大多数类型重写 `ToString()` —— 你可以免费获得漂亮打印！
- en: 'You have probably already seen this when running the earlier examples. Here
    is another simple example:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行之前的示例时，你可能已经见过这个了。这里是另一个简单的例子：
- en: '[PRE66]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE67]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Most F# types have built-in structural equality
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大多数 F# 类型都具有内置的结构相等性
- en: In C#, you often have to implement the `IEquatable` interface so that you can
    test for equality between objects. This is needed when using objects for Dictionary
    keys, for example.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你经常需要实现 `IEquatable` 接口，以便可以在对象之间测试相等性。例如，在使用对象作为字典键时就需要这样做。
- en: In F#, you get this for free with most F# types. For example, using the `PersonalName`
    type from above, we can compare two names straight away.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，对于大多数 F# 类型，你可以免费获得这个。例如，使用上面的 `PersonalName` 类型，我们可以立即比较两个姓名。
- en: '[PRE68]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Most F# types are automatically comparable
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大多数 F# 类型是自动可比较的
- en: In C#, you often have to implement the `IComparable` interface so that you can
    sort objects.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你经常需要实现 `IComparable` 接口，以便对对象进行排序。
- en: Again, in F#, you get this for free with most F# types. For example, here is
    a simple definition of a deck of cards.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在 F# 中，对于大多数 F# 类型，你可以免费获得这个。例如，这里是一副简单的卡牌的定义。
- en: '[PRE69]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can write a function to test the comparison logic:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个函数来测试比较逻辑：
- en: '[PRE70]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And let''s see how it works:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE71]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that the Ace of Hearts is automatically greater than the Two of Hearts,
    because the "Ace" rank value comes after the "Two" rank value.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，红心的 A 自动大于红心的 2，因为“Ace”等级值在“Two”等级值之后。
- en: But also note that the Two of Hearts is automatically greater than the Ace of
    Spades, because the Suit part is compared first, and the "Heart" suit value comes
    after the "Spade" value.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 但也要注意，红心的两对牌自动比黑桃的A对牌要大，因为首先比较的是花色部分，而“红心”花色值在“黑桃”值之后。
- en: 'Here''s an example of a hand of cards:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一手扑克牌的例子：
- en: '[PRE72]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: And as a side benefit, you get min and max for free too!
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 而且作为一个附带好处，你还免费获得了min和max！
- en: '[PRE73]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Functions as interfaces
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为接口
- en: Functions as interfaces
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为接口
- en: An important aspect of functional programming is that, in a sense, all functions
    are "interfaces", meaning that many of the roles that interfaces play in object-oriented
    design are implicit in the way that functions work.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个重要方面是，在某种程度上，所有函数都是“接口”，这意味着函数在对象导向设计中扮演的许多角色在函数工作方式中是隐含的。
- en: In fact, one of the critical design maxims, "program to an interface, not an
    implementation", is something you get for free in F#.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，“针对接口编程，而不是实现”这一关键设计准则是在F#中免费获得的。
- en: To see how this works, let's compare the same design pattern in C# and F#. For
    example, in C# we might want to use the "decorator pattern" to enhance some core
    code.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要看看这是如何工作的，让我们比较一下C#和F#中相同的设计模式。例如，在C#中，我们可能想要使用“装饰器模式”来增强一些核心代码。
- en: 'Let''s say that we have a calculator interface:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个计算器接口：
- en: '[PRE74]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And then a specific implementation:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个具体的实现：
- en: '[PRE75]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: And then if we want to add logging, we can wrap the core calculator implementation
    inside a logging wrapper.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们想要添加日志记录，我们可以将核心计算器实现包装在一个日志记录包装器中。
- en: '[PRE76]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: So far, so straightforward. But note that, for this to work, we must have defined
    an interface for the classes. If there had been no `ICalculator` interface, it
    would be necessary to retrofit the existing code.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很简单。但请注意，为了使这个工作，我们必须为类定义一个接口。如果没有`ICalculator`接口，那么必须对现有代码进行改造。
- en: And here is where F# shines. In F#, you can do the same thing without having
    to define the interface first. Any function can be transparently swapped for any
    other function as long as the signatures are the same.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 F# 的闪亮之处。在 F# 中，你可以做到同样的事情，而不必首先定义接口。只要签名相同，任何函数都可以被透明地替换为任何其他函数。
- en: Here is the equivalent F# code.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这是等效的 F# 代码。
- en: '[PRE77]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In other words, the signature of the function *is* the interface.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，函数的签名 *就是* 接口。
- en: Generic wrappers
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用包装器
- en: 'Even nicer is that by default, the F# logging code can be made completely generic
    so that it will work for *any* function at all. Here are some examples:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，默认情况下，F# 日志记录代码可以完全通用化，以便适用于*任何*函数。以下是一些示例：
- en: '[PRE78]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The new "wrapped" functions can be used anywhere the original functions could
    be used ? no one can tell the difference!
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 新的“包装”函数可以在原始函数可以使用的任何地方使用——没人能分辨出区别！
- en: '[PRE79]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Exactly the same generic wrapper approach can be used for other things. For
    example, here is a generic wrapper for timing a function.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 完全相同的通用包装方法可以用于其他事物。例如，这是一个计时函数的通用包装器。
- en: '[PRE80]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The ability to do this kind of generic wrapping is one of the great conveniences
    of the function-oriented approach. You can take any function and create a similar
    function based on it. As long as the new function has exactly the same inputs
    and outputs as the original function, the new can be substituted for the original
    anywhere. Some more examples:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用封装的能力是函数式方法的一个很大的便利之处。你可以取任何函数并基于它创建一个类似的函数。只要新函数的输入和输出与原始函数完全相同，新函数就可以在任何地方替代原始函数。还有一些更多的例子：
- en: It is easy to write a generic caching wrapper for a slow function, so that the
    value is only calculated once.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个通用的缓存包装器以使慢函数的值仅计算一次也很容易。
- en: It is also easy to write a generic "lazy" wrapper for a function, so that the
    inner function is only called when a result is needed
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个通用的“延迟”包装器以使函数仅在需要结果时被调用也很容易
- en: The strategy pattern
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: We can apply this same approach to another common design pattern, the "strategy
    pattern."
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种相同的方法应用到另一个常见的设计模式上，即“策略模式”。
- en: 'Let''s use the familiar example of inheritance: an `Animal` superclass with
    `Cat` and `Dog` subclasses, each of which overrides a `MakeNoise()` method to
    make different noises.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用继承的熟悉例子：一个带有`Cat`和`Dog`子类的`Animal`超类，每个子类都覆盖了一个`MakeNoise()`方法以发出不同的声音。
- en: In a true functional design, there are no subclasses, but instead the `Animal`
    class would have a `NoiseMaking` function that would be passed in with the constructor.
    This approach is exactly the same as the "strategy" pattern in OO design.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正的函数式设计中，没有子类，而是 `Animal` 类将具有一个通过构造函数传入的 `NoiseMaking` 函数。这种方法与 OO 设计中的 "策略"
    模式完全相同。
- en: '[PRE81]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note that again, we do not have to define any kind of `INoiseMakingStrategy`
    interface first. Any function with the right signature will work. As a consequence,
    in the functional model, the standard .NET "strategy" interfaces such as `IComparer`,
    `IFormatProvider`, and `IServiceProvider` become irrelevant.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，再次强调，我们不必首先定义任何 `INoiseMakingStrategy` 接口。任何具有正确签名的函数都可以工作。因此，在函数模型中，标准的.NET
    "策略"接口（如 `IComparer`、`IFormatProvider` 和 `IServiceProvider`）变得无关紧要。
- en: Many other design patterns can be simplified in the same way.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他设计模式也可以以同样的方式简化。
- en: Partial Application
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: Partial Application
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: A particularly convenient feature of F# is that complicated functions with many
    parameters can have some of the parameters fixed or "baked in" and yet leave other
    parameters open. In this post, we'll take a quick look at how this might be used
    in practice.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的一个特别方便的功能是，具有许多参数的复杂函数可以固定或 "烘焙" 其中一些参数，但留下其他参数。在本文中，我们将快速看一下这个在实践中可能如何使用。
- en: 'Let''s start with a very simple example of how this works. We''ll start with
    a trivial function:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始说明这是如何工作的。我们将从一个微不足道的函数开始：
- en: '[PRE82]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: But we can do something strange as well ? we can call the function with only
    one parameter!
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以做一些奇怪的事情--我们可以只用一个参数调用函数！
- en: '[PRE83]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The result is a new function that has the "42" baked in, and now takes only
    one parameter instead of two! This technique is called "partial application",
    and it means that, for any function, you can "fix" some of the parameters and
    leave other ones open to be filled in later.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新函数，其中的 "42" 已经固定，并且现在只需要一个参数而不是两个！这种技术称为 "部分应用"，它意味着，对于任何函数，您都可以 "固定"
    一些参数，而将其他参数留给稍后填充。
- en: '[PRE84]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With that under our belt, let''s revisit the generic logger that we saw earlier:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个技能，让我们重新审视一下之前看到的通用记录器：
- en: '[PRE85]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Unfortunately, I have hard-coded the logging operations. Ideally, I'd like to
    make this more generic so that I can choose how logging is done.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我已经将日志记录操作硬编码了。理想情况下，我想把这个做得更通用，这样我就可以选择如何进行日志记录。
- en: Of course, F# being a functional programming language, we will do this by passing
    functions around.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为一种函数式编程语言，F# 将通过传递函数来实现这一点。
- en: 'In this case we would pass "before" and "after" callback functions to the library
    function, like this:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会将 "before" 和 "after" 回调函数传递给库函数，像这样：
- en: '[PRE86]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can see that the logging function now has four parameters. The "before"
    and "after" actions are passed in as explicit parameters as well as the function
    and its input. To use this in practice, we just define the functions and pass
    them in to the library function along with the final int parameter:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到现在日志记录函数有四个参数。"before"和"after"操作作为显式参数传递，以及函数和它的输入。要在实践中使用这个，我们只需定义函数并将其与最后的int参数一起传递给库函数即可：
- en: '[PRE87]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This is a lot more flexible. I don't have to create a new function every time
    I want to change the behavior -- I can define the behavior on the fly.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更加灵活。我不必每次都创建一个新函数来改变行为--我可以动态定义行为。
- en: But you might be thinking that this is a bit ugly. A library function might
    expose a number of callback functions and it would be inconvenient to have to
    pass the same functions in over and over.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能会认为这有点丑陋。一个库函数可能会公开许多回调函数，每次都必须反复传递相同的函数会很不方便。
- en: Luckily, we know the solution for this. We can use partial application to fix
    some of the parameters. So in this case, let's define a new function which fixes
    the `before` and `after` functions, as well as the `add1` function, but leaves
    the final parameter open.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们知道这个问题的解决方案。我们可以使用部分应用来修复一些参数。因此，在这种情况下，让我们定义一个新函数，它修复了 `before` 和 `after`
    函数，以及 `add1` 函数，但保留了最后一个参数。
- en: '[PRE88]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The new "wrapper" function is called with just an int now, so the code is much
    cleaner. As in the earlier example, it can be used anywhere the original `add1`
    function could be used without any changes.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需用一个整数调用新的 "wrapper" 函数，所以代码更清晰了。与之前的示例一样，可以在不做任何更改的情况下在任何可以使用原始 `add1` 函数的地方使用它。
- en: '[PRE89]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The functional approach in C#
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 中的函数式方法
- en: In a classical object-oriented approach, we would probably have used inheritance
    to do this kind of thing. For instance, we might have had an abstract `LoggerBase`
    class, with virtual methods for "`before`" and "`after`" and the function to execute.
    And then to implement a particular kind of behavior, we would have created a new
    subclass and overridden the virtual methods as needed.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的面向对象方法中，我们可能会使用继承来完成这种事情。例如，我们可能有一个抽象的`LoggerBase`类，其中包含"`before`"和"`after`"的虚拟方法以及要执行的函数。然后，为了实现特定的行为，我们会创建一个新的子类，并根据需要重写虚拟方法。
- en: But classical style inheritance is now becoming frowned upon in object-oriented
    design, and composition of objects is much preferred. And indeed, in "modern"
    C#, we would probably write the code in the same way as F#, either by using events
    or by passing functions in.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '但是，在面向对象设计中，经典的风格继承现在越来越不受欢迎，对象的组合被更加青睐。而且，实际上，在“现代”的C#中，我们可能会像F#一样编写代码，无论是使用事件还是通过传递函数来实现。 '
- en: Here's the F# code translated into C# (note that I had to specify the types
    for each Action)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将F#代码翻译为C#的代码（请注意，我不得不为每个操作指定类型）。
- en: '[PRE90]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And here it is in use:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这是它的使用方式：
- en: '[PRE91]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In C#, this style of programming is required when using the LINQ libraries,
    but many developers have not embraced it fully to make their own code more generic
    and adaptable. And it's not helped by the ugly `Action<>` and `Func<>` type declarations
    that are required. But it can certainly make the code much more reusable.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，当使用LINQ库时，这种编程风格是必需的，但许多开发人员并没有完全接受它，以使他们自己的代码更通用和适应性更强。而且，需要的丑陋的`Action<>`和`Func<>`类型声明也没有帮助。但这确实可以使代码更具可重用性。
- en: Active patterns
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主动模式
- en: Active patterns
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主动模式
- en: F# has a special type of pattern matching called "active patterns" where the
    pattern can be parsed or detected dynamically. As with normal patterns, the matching
    and output are combined into a single step from the caller's point of view.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: F#有一种特殊类型的模式匹配称为“主动模式”，其中模式可以动态解析或检测。与普通模式一样，从调用者的角度来看，匹配和输出被合并为单个步骤。
- en: Here is an example of using active patterns to parse a string into an int or
    bool.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用主动模式将字符串解析为int或bool的示例。
- en: '[PRE92]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You don't need to worry about the complex syntax used to define the active pattern
    right now ? this is just an example so that you can see how they are used.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不需要担心用于定义主动模式的复杂语法？这只是一个例子，让你看看它们是如何使用的。
- en: Once these patterns have been set up, they can be used as part of a normal "`match..with`"
    expression.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些模式被设置好，它们就可以作为正常的"`match..with`"表达式的一部分使用。
- en: '[PRE93]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can see that from the caller's point of view, the matching with an `Int`
    or `Bool` is transparent, even though there is parsing going on behind the scenes.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到从调用者的角度来看，与`Int`或`Bool`的匹配是透明的，尽管在幕后进行了解析。
- en: A similar example is to use active patterns with regular expressions in order
    to both match on a regex pattern and return the matched value in a single step.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的示例是使用正则表达式的主动模式，以便在单个步骤中匹配正则表达式模式并返回匹配的值。
- en: '[PRE94]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Again, once this pattern has been set up, it can be used transparently as part
    of a normal match expression.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一旦设置了这种模式，它就可以作为正常匹配表达式的一部分透明地使用。
- en: '[PRE95]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'And for fun, here''s one more: the well-known [FizzBuzz challenge](http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html)
    written using active patterns.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 并且为了好玩，这里还有一个：著名的[FizzBuzz挑战](http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html)使用主动模式编写。
- en: '[PRE96]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Correctness
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确性
- en: Correctness
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确性
- en: As a programmer, you are constantly judging the code that you and others write.
    In an ideal world, you should be able to look at a piece of code and easily understand
    exactly what it does; and of course, being concise, clear and readable is a major
    factor in this.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个程序员，你不断地评判着你自己和其他人编写的代码。在理想的情况下，你应该能够看一段代码并轻松地理解它确切地做了什么；当然，简洁、清晰和可读性是其中的一个重要因素。
- en: But more importantly, you have to be able to convince yourself that the code
    *does what it is supposed to do*. As you program, you are constantly reasoning
    about code correctness, and the little compiler in your brain is checking the
    code for errors and possible mistakes.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是，你必须能够说服自己代码*确实完成了它应该完成的工作*。当你编写程序时，你不断地思考代码的正确性，你脑海中的小型编译器正在检查代码是否有错误和可能的错误。
- en: So how can a programming language help you with this?
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如何利用编程语言帮助你实现这一点？
- en: 'A modern imperative language like C# provides many ways that you are already
    familiar with: type checking, scoping and naming rules, access modifiers and so
    on. And, in recent versions, static code analysis and code contracts.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 像C#这样的现代命令式语言提供了许多你已经熟悉的方法：类型检查、作用域和命名规则、访问修饰符等等。而且，在最近的版本中，还有静态代码分析和代码合约。
- en: All these techniques mean that the compiler can take on a lot of the burden
    of checking for correctness. If you make a mistake, the compiler will warn you.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术意味着编译器可以承担大部分检查正确性的负担。如果你犯了一个错误，编译器会提醒你。
- en: 'But F# has some additional features that can have a huge impact on ensuring
    correctness. The next few posts will be devoted to four of them:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 但是F#有一些额外的功能，可以对确保正确性产生巨大的影响。接下来的几篇文章将专注于其中的四个：
- en: '**Immutability**, which enables code to behave much more predictably.'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**，使代码的行为更加可预测。'
- en: '**Exhaustive pattern matching**, which traps many common errors at compile
    time.'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**穷尽模式匹配**，可以在编译时捕获许多常见错误。'
- en: '**A strict type system**, which is your friend, not your enemy. You can use
    the static type checking almost as an instant "compile time unit test".'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严格的类型系统**，它是你的朋友，而不是你的敌人。你几乎可以将静态类型检查看作是即时的“编译时单元测试”。'
- en: '**An expressive type system** that can help you "make illegal states unrepresentable"*
    . We''ll see how to design a real-world example that demonstrates this.'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一种富有表现力的类型系统**，可以帮助你“使非法状态不可表示”。我们将看到如何设计一个真实世界的示例来演示这一点。'
- en: '[* Thanks to Yaron Minsky at Jane Street for this phrase.]'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '[* 感谢Jane Street的Yaron Minsky提供这句话。]'
- en: Immutability
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: Immutability
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: To see why immutability is important, let's start with a small example.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么不可变性很重要，让我们从一个小例子开始。
- en: Here's some simple C# code that processes a list of numbers.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些处理数字列表的简单C#代码。
- en: '[PRE97]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now let me test it:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我来测试一下：
- en: '[PRE98]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Everything works great, and the test passes, but I notice that I am creating
    the list twice ? surely I should refactor this out? So I do the refactoring, and
    here''s the new improved version:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很顺利，测试通过了，但我注意到我两次创建了列表？我肯定应该重构掉这个吧？所以我进行了重构，这是新的改进版本：
- en: '[PRE99]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: But now the test suddenly fails! Why would a refactoring break the test? Can
    you tell just by looking at the code?
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在测试突然失败了！为什么重构会导致测试失败？仅仅通过查看代码就能知道吗？
- en: The answer is, of course, that the list is mutable, and it is probable that
    the `OddNumbers` function is making destructive changes to the list as part of
    its filtering logic. Of course, in order to be sure, we would have to examine
    the code inside the `OddNumbers` function.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 答案当然是列表是可变的，并且很可能`OddNumbers`函数在其过滤逻辑中做出了破坏性的更改。当然，为了确保，我们必须检查`OddNumbers`函数内部的代码。
- en: In other words, when I call the `OddNumbers` function, I am unintentionally
    creating undesirable side effects.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我调用`OddNumbers`函数时，我无意中创建了不良的副作用。
- en: 'Is there a way to ensure that this cannot happen? Yes -- if the functions had
    used `IEnumerable` instead:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有办法确保这种情况不会发生？有 —— 如果函数使用了`IEnumerable`的话：
- en: '[PRE100]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In this case we can be confident that calling the `OddNumbers` function could
    not possibly have any effect on the list, and `EvenNumbers` would work correctly.
    What's more, we can know this *just by looking at the signatures*, without having
    to examine the internals of the functions. And if you try to make one of the functions
    misbehave by assigning to the list then you will get an error straight away, at
    compile time.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以确信调用`OddNumbers`函数不可能对列表产生任何影响，而`EvenNumbers`会正确工作。更重要的是，我们可以仅仅通过查看函数的签名就知道这一点，而不必检查函数的内部。如果你试图通过对列表进行赋值来使其中一个函数出现错误行为，那么编译时会立即报错。
- en: So `IEnumerable` can help in this case, but what if I had used a type such as
    `IEnumerable<Person>` instead of `IEnumerable<int>`? Could I still be as confident
    that the functions wouldn't have unintentional side effects?
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这种情况下`IEnumerable`可以帮助，但如果我使用`IEnumerable<Person>`而不是`IEnumerable<int>`这样的类型会怎样呢？我能像现在这样确信这些函数不会有意外的副作用吗？
- en: Reasons why immutability is important
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性的重要性的原因
- en: 'The example above shows why immutability is helpful. In fact, this is just
    the tip of the iceberg. There are a number of reasons why immutability is important:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例展示了为什么不可变性是有帮助的。实际上，这只是冰山一角。有许多原因说明为什么不可变性很重要：
- en: Immutable data makes the code predictable
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据使代码更可预测
- en: Immutable data is easier to work with
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据更容易处理
- en: Immutable data forces you to use a "transformational" approach
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据迫使你使用“转换”方法
- en: First, immutability makes the code **predictable**. If data is immutable, there
    can be no side-effects. If there are no side-effects, it is much, much, easier
    to reason about the correctness of the code.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，不可变性使代码**可预测**。如果数据是不可变的，就不会有副作用。如果没有副作用，就更容易推理代码的正确性。
- en: And when you have two functions that work on immutable data, you don't have
    to worry about which order to call them in, or whether one function will mess
    with the input of the other function. And you have peace of mind when passing
    data around (for example, you don't have to worry about using an object as a key
    in a hashtable and having its hash code change).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有两个作用于不可变数据的函数时，你不必担心调用它们的顺序，或者一个函数是否会干扰另一个函数的输入。在传递数据时，你可以放心（例如，你不必担心在哈希表中使用对象作为键并且其哈希码发生变化）。
- en: 'In fact, immutability is a good idea for the same reasons that global variables
    are a bad idea: data should be kept as local as possible and side-effects should
    be avoided.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，不可变性之所以是一个好主意，原因与全局变量是一个坏主意相同：数据应尽可能保持本地化，应避免副作用。
- en: Second, immutability is **easier to work with**. If data is immutable, many
    common tasks become much easier. Code is easier to write and easier to maintain.
    Fewer unit tests are needed (you only have to check that a function works in isolation),
    and mocking is much easier. Concurrency is much simpler, as you don't have to
    worry about using locks to avoid update conflicts (because there are no updates).
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，不可变性更**易于处理**。如果数据是不可变的，许多常见任务变得更加容易。编写代码更容易，维护更容易。需要更少的单元测试（只需检查函数在隔离环境中是否有效），模拟也更容易。并发性更简单，因为你不必担心使用锁来避免更新冲突（因为没有更新）。
- en: Finally, using immutability by default means that you start thinking differently
    about programming. You tend to think about **transforming** the data rather than
    mutating it in place.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，默认使用不可变性意味着你开始以不同的方式思考编程。你倾向于考虑**转换**数据而不是就地突变它。
- en: SQL queries and LINQ queries are good examples of this "transformational" approach.
    In both cases, you always transform the original data through various functions
    (selects, filters, sorts) rather than modifying the original data.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: SQL查询和LINQ查询是这种“转换”方法的好例子。在这两种情况下，你总是通过各种函数（选择、过滤、排序）转换原始数据，而不是修改原始数据。
- en: When a program is designed using a transformation approach, the result tends
    to be more elegant, more modular, and more scalable. And as it happens, the transformation
    approach is also a perfect fit with a function-oriented paradigm.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序使用转换方法设计时，结果往往更加优雅、模块化和可扩展。而恰好，转换方法也与面向函数的范式完美契合。
- en: How F# does immutability
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#如何实现不可变性
- en: 'We saw earlier that immutable values and types are the default in F#:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，不可变值和类型在F#中是默认的：
- en: '[PRE101]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Because of this, F# has a number of tricks to make life easier and to optimize
    the underlying code.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，F#有许多技巧可以让生活更轻松，并优化底层代码。
- en: 'First, since you can''t modify a data structure, you must copy it when you
    want to change it. F# makes it easy to copy another data structure with only the
    changes you want:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于无法修改数据结构，当你想要更改它时，必须复制它。F#使得仅使用你想要的更改轻松复制另一个数据结构：
- en: '[PRE102]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: And complex data structures are implemented as linked lists or similar, so that
    common parts of the structure are shared.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂数据结构实现为链表或类似结构，以便共享结构的常见部分。
- en: '[PRE103]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This technique ensures that, while you might appear to have hundreds of copies
    of a list in your code, they are all sharing the same memory behind the scenes.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术确保，虽然你的代码中可能看起来有数百个列表的副本，但它们实际上都在幕后共享同一内存。
- en: Mutable data
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变数据
- en: F# is not dogmatic about immutability; it does support mutable data with the
    `mutable` keyword. But turning on mutability is an explicit decision, a deviation
    from the default, and it is generally only needed for special cases such as optimization,
    caching, etc, or when dealing with the .NET libraries.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: F#对不可变性并不教条；它支持使用`mutable`关键字的可变数据。但打开可变性是一个明确的决定，是与默认值偏离的行为，通常只在特殊情况下才需要，比如优化、缓存等，或者处理.NET库时。
- en: In practice, a serious application is bound to have some mutable state if it
    deals with messy world of user interfaces, databases, networks and so on. But
    F# encourages the minimization of such mutable state. You can generally still
    design your core business logic to use immutable data, with all the corresponding
    benefits.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，一个严肃的应用程序如果涉及混乱的用户界面、数据库、网络等，就必然会有一些可变状态。但是 F# 鼓励最小化这种可变状态。通常情况下，你仍然可以设计你的核心业务逻辑来使用不可变数据，带来所有相应的好处。
- en: Exhaustive pattern matching
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详尽的模式匹配
- en: Exhaustive pattern matching
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详尽的模式匹配
- en: We briefly noted earlier that when pattern matching there is a requirement to
    match all possible cases. This turns out be a very powerful technique to ensure
    correctness.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前简要提到，在模式匹配时有一个要求，即匹配所有可能的情况。这实际上是一种确保正确性的非常强大的技术。
- en: Let's compare some C# to F# again. Here's some C# code that uses a switch statement
    to handle different types of state.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次比较一些 C# 和 F#。这里有一些使用 switch 语句处理不同状态类型的 C# 代码。
- en: '[PRE104]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This code will compile, but there is an obvious bug! The compiler couldn't see
    it ? can you? If you can, and you fixed it, would it stay fixed if I added another
    `State` to the list?
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会编译，但显然存在一个错误！编译器看不到它？你能看到吗？如果你能看到，并且修复了它，如果我添加了另一个 `State` 到列表中，它会保持修复吗？
- en: 'Here''s the F# equivalent:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 F# 的等价代码：
- en: '[PRE105]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Now try running this code. What does the compiler tell you?
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行这段代码。编译器告诉你什么？
- en: 'The fact that exhaustive matching is always done means that certain common
    errors will be detected by the compiler immediately:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 详尽匹配总是会做的事情，这意味着编译器会立即检测到某些常见的错误：
- en: A missing case (often caused when a new choice has been added due to changed
    requirements or refactoring).
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个缺失的情况（通常是由于需求变更或重构而添加了新选择导致的）。
- en: An impossible case (when an existing choice has been removed).
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不可能的情况（当现有选择被移除时）。
- en: A redundant case that could never be reached (the case has been subsumed in
    a previous case -- this can sometimes be non-obvious).
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个多余的情况，永远不会被触发（该情况已经包含在先前的情况中——有时这可能不明显）。
- en: Now let's look at some real examples of how exhaustive matching can help you
    write correct code.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些真实例子，看看详尽匹配如何帮助你编写正确的代码。
- en: Avoiding nulls with the Option type
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Option 类型避免空值
- en: 'We''ll start with an extremely common scenario where the caller should always
    check for an invalid case, namely testing for nulls. A typical C# program is littered
    with code like this:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个极其常见的场景开始，即调用者应始终检查无效情况，即测试空值。一个典型的 C# 程序中充斥着这样的代码：
- en: '[PRE106]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Unfortunately, this test is not required by the compiler. All it takes is for
    one piece of code to forget to do this, and the program can crash. Over the years,
    a huge amount of programming effort has been devoted to handling nulls ? the invention
    of nulls has even been called a [billion dollar mistake](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)!
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，编译器不要求进行这个测试。只需有一段代码忘记执行此操作，程序就会崩溃。多年来，大量的编程工作已经致力于处理空值——甚至有人称空值的发明为[十亿美元的错误](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)！
- en: In pure F#, nulls cannot exist accidentally. A string or object must always
    be assigned to something at creation, and is immutable thereafter.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯粹的 F# 中，空值不能意外存在。一个字符串或对象在创建时必须始终被分配给某个东西，并且在此后是不可变的。
- en: However, there are many situations where the *design intent* is to distinguish
    between valid and invalid values, and you require the caller to handle both cases.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多情况下，*设计意图* 是区分有效值和无效值，并且需要调用者处理这两��情况。
- en: In C#, this can be managed in certain situations by using nullable value types
    (such as `Nullable<int>`) to make the design decision clear. When a nullable is
    encountered the compiler will force you to be aware of it. You can then test the
    validity of the value before using it. But nullables do not work for standard
    classes (i.e. reference types), and it is easy to accidentally bypass the tests
    too and just call `Value` directly.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，可以通过使用可空值类型（如 `Nullable<int>`）在某些情况下管理这个问题，以明确设计决策。当遇到可空值时，编译器会强制你意识到它。然后你可以在使用之前测试值的有效性。但是对于标准类（即引用类型），可空值不起作用，而且很容易无意中绕过测试，直接调用
    `Value`。
- en: 'In F# there is a similar but more powerful concept to convey the design intent:
    the generic wrapper type called `Option`, with two choices: `Some` or `None`.
    The `Some` choice wraps a valid value, and `None` represents a missing value.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，有一个类似但更强大的概念来传达设计意图：名为`Option`的通用包装类型，有两种选择：`Some`或`None`。`Some`选择包装一个有效值，而`None`表示一个缺失的值。
- en: Here's an example where `Some` is returned if a file exists, but a missing file
    returns `None`.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，如果文件存在，则返回`Some`，但如果文件丢失，则返回`None`。
- en: '[PRE107]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If we want to do anything with these values, we must always handle both possible
    cases.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对这些值做任何事情，我们必须始终处理两种可能的情况。
- en: '[PRE108]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We have no choice about this. Not handling a case is a compile-time error, not
    a run-time error. By avoiding nulls and by using `Option` types in this way, F#
    completely eliminates a large class of null reference exceptions.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们别无选择。不处理某种情况是编译时错误，而不是运行时错误。通过避免空值，并在这种方式中使用`Option`类型，F#完全消除了大量的空引用异常。
- en: '[Caveat: F# does allow you to access the value without testing, just like C#,
    but that is considered extremely bad practice.]'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '[注意：F#确实允许您在不进行测试的情况下访问值，就像C#一样，但这被认为是极其不良的做法。]'
- en: Exhaustive pattern matching for edge cases
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界情况的穷尽模式匹配
- en: 'Here''s some C# code that creates a list by averaging pairs of numbers from
    an input list:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些创建列表的C#代码，通过对输入列表中的数字进行平均化来创建列表：
- en: '[PRE109]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: It compiles correctly, but it actually has a couple of issues. Can you find
    them quickly? If you're lucky, your unit tests will find them for you, assuming
    you have thought of all the edge cases.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以正确编译，但实际上有一些问题。你能快速找到它们吗？如果你幸运的话，你的单元测试会帮你找到它们，假设你已经考虑到了所有的边界情况。
- en: 'Now let''s try the same thing in F#:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在F#中尝试同样的事情：
- en: '[PRE110]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This code also has a bug. But unlike C#, this code will not even compile until
    I fix it. The compiler will tell me that I haven''t handled the case when I have
    a single item in my list. Not only has it found a bug, it has revealed a gap in
    the requirements: what should happen when there is only one item?'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也有一个错误。但与C#不同，除非我修复它，否则这段代码甚至不会编译。编译器会告诉我，我没有处理当列表中只有一个项目时的情况。它不仅发现了一个错误，还揭示了需求中的一个空白：当只有一个项目时应该发生什么？
- en: 'Here''s the fixed up version:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修复后的版本：
- en: '[PRE111]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As an additional benefit, the F# code is also much more self-documenting. It
    explicitly describes the consequences of each case. In the C# code, it is not
    at all obvious what happens if a list is empty or only has one item. You would
    have to read the code carefully to find out.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，F#代码也更具自我描述性。它明确描述了每种情况的后果。在C#代码中，如果列表为空或只有一个项目，发生了什么根本不明显。你必须仔细阅读代码才能找出。
- en: Exhaustive pattern matching as an error handling technique
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 穷尽模式匹配作为一种错误处理技术
- en: 'The fact that all choices must be matched can also be used as a useful alternative
    to throwing exceptions. For example consider the following common scenario:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选择必须匹配的事实也可以用作一个有用的替代方案来抛出异常。例如考虑以下常见情况：
- en: There is a utility function in the lowest tier of your app that opens a file
    and performs an arbitrary operation on it (that you pass in as a callback function)
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的最底层有一个实用函数，它打开一个文件并对其执行任意操作（您将其作为回调函数传入）。
- en: The result is then passed back up through to tiers to the top level.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将结果传递回到顶层的各个层。
- en: A client calls the top level code, and the result is processed and any error
    handling done.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端调用顶层代码，处理结果并进行任何错误处理。
- en: In a procedural or OO language, propagating and handling exceptions across layers
    of code is a common problem. Top level functions are not easily able to tell the
    difference between an exception that they should recover from (`FileNotFound`
    say) vs. an exception that they needn't handle (`OutOfMemory` say). In Java, there
    has been an attempt to do this with checked exceptions, but with mixed results.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式或面向对象语言中，跨代码层传播和处理异常是一个常见问题。顶层函数很难区分它们应该恢复的异常（比如`FileNotFound`）和不需要处理的异常（比如`OutOfMemory`）。在Java中，尝试使用已检查异常来解决这个问题，但效果参差不齐。
- en: In the functional world, a common technique is to create a new structure to
    hold both the good and bad possibilities, rather than throwing an exception if
    the file is missing.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式世界中，一个常见的技术是创建一个新的结构来保存好的和坏的可能性，而不是在文件丢失时抛出异常。
- en: '[PRE112]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The code demonstrates how `performActionOnFile` returns a `Result` object which
    has two alternatives: `Success` and `Failure`. The `Failure` alternative in turn
    has two alternatives as well: `FileNotFound` and `UnauthorizedAccess`.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码演示了`performActionOnFile`如何返回一个`Result`对象，该对象具有两个替代方案：`Success`和`Failure`。而`Failure`替代方案又有两个替代方案：`FileNotFound`和`UnauthorizedAccess`。
- en: 'Now the intermediate layers can call each other, passing around the result
    type without worrying what its structure is, as long as they don''t access it:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间层可以相互调用，传递结果类型而不担心其结构，只要它们不访问它：
- en: '[PRE113]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Because of type inference, the middle and top layers do not need to specify
    the exact types returned. If the lower layer changes the type definition at all,
    the intermediate layers will not be affected.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型推断，中间层和顶层不需要指定确切的返回类型。如果底层改变了类型定义，中间层不会受到影响。
- en: Obviously at some point, a client of the top layer does want to access the result.
    And here is where the requirement to match all patterns is enforced. The client
    must handle the case with a `Failure` or else the compiler will complain. And
    furthermore, when handling the `Failure` branch, it must handle the possible reasons
    as well. In other words, special case handling of this sort can be enforced at
    compile time, not at runtime! And in addition the possible reasons are explicitly
    documented by examining the reason type.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在某些时候，顶层的客户端确实想要访问结果。这就是强制要求匹配所有模式的要求。客户端必须处理`Failure`情况，否则编译器会抱怨。而且，当处理`Failure`分支时，还必须处理可能的原因。换句话说，这种特殊情况的处理可以在编译时强制执行，而不是在运行时！此外，通过检查原因类型，可能的原因还得到了明确的文档记录。
- en: 'Here is an example of a client function that accesses the top layer:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个访问顶层的客户端函数的示例：
- en: '[PRE114]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: You can see that this code must explicitly handle the `Success` and `Failure`
    cases, and then for the failure case, it explicitly handles the different reasons.
    If you want to see what happens if it does not handle one of the cases, try commenting
    out the line that handles `UnauthorizedAccess` and see what the compiler says.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，此代码必须显式处理`Success`和`Failure`情况，然后对于失败情况，它显式处理了不同的原因。如果您想看看如果不处理其中一个情况会发生什么，请尝试注释掉处理`UnauthorizedAccess`的行，看看编译器会说什么。
- en: Now it is not required that you always handle all possible cases explicitly.
    In the example below, the function uses the underscore wildcard to treat all the
    failure reasons as one. This can considered bad practice if we want to get the
    benefits of the strictness, but at least it is clearly done.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不需要总是显式处理所有可能的情况。在下面的示例中，该函数使用下划线通配符将所有失败原因视为一个。如果我们想要获得严格性的好处，这可能被认为是不良做法，但至少它明确地完成了。
- en: '[PRE115]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Now let's see all this code work in practice with some interactive tests.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看所有这些代码如何在实践中运作，进行一些交互式测试。
- en: First set up a good file and a bad file.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 首先设置一个好文件和一个坏文件。
- en: '[PRE116]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'And now test interactively:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行交互式测试：
- en: '[PRE117]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'I think you can see that this approach is very attractive:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为您可以看出，这种方法非常吸引人：
- en: Functions return error types for each expected case (such as `FileNotFound`),
    but the handling of these types does not need to make the calling code ugly.
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数为每个预期情况返回错误类型（如`FileNotFound`），但处理这些类型不需要使调用代码丑陋。
- en: Functions continue to throw exceptions for unexpected cases (such as `OutOfMemory`),
    which will generally be caught and logged at the top level of the program.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于意外情况（如`OutOfMemory`），函数继续抛出异常，这些异常通常会在程序的顶层被捕获和记录。
- en: This technique is simple and convenient. Similar (and more generic) approaches
    are standard in functional programming.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术简单而方便。类似（更通用）的方法在函数式编程中很常见。
- en: It is feasible to use this approach in C# too, but it is normally impractical,
    due to the lack of union types and the lack of type inference (we would have to
    specify generic types everywhere).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中使用这种方法是可行的，但通常是不切实际的，因为缺乏联合类型和类型推断（我们必须在所有地方指定泛型类型）。
- en: Exhaustive pattern matching as a change management tool
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详尽的模式匹配作为变更管理工具
- en: Finally, exhaustive pattern matching is a valuable tool for ensuring that code
    stays correct as requirements change, or during refactoring.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，详尽的模式匹配是确保代码在需求变化或重构期间保持正确性的有价值工具。
- en: 'Let''s say that the requirements change and we need to handle a third type
    of error: "Indeterminate". To implement this new requirement, change the first
    `Result` type as follows, and re-evaluate all the code. What happens?'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 假设需求变化，我们需要处理第三种类型的错误："不定"。为了实现这个新需求，将第一个`Result`类型更改如下，并重新评估所有代码。会发生什么？
- en: '[PRE118]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Or sometimes a requirements change will remove a possible choice. To emulate
    this, change the first `Result` type to eliminate all but one of the choices.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 或者有时候需求变更会删除一个可能的选择。为了模拟这一点，将第一个`Result`类型更改为仅保留一个选择。
- en: '[PRE119]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Now re-evaluate the rest of the code. What happens now?
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新评估其余的代码。现在会发生什么？
- en: This is very powerful! When we adjust the choices, we immediately know all the
    places which need to be fixed to handle the change. This is another example of
    the power of statically checked type errors. It is often said about functional
    languages like F# that "if it compiles, it must be correct".
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常强大的！当我们调整选择时，我们立即知道所有需要被修复以处理变更的地方。这是静态检查类型错误的另一个示例。关于像 F# 这样的函数式语言经常被说成是"如果它编译通过，那么它必定是正确的"。
- en: Using the type system to ensure correct code
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型系统确保代码正确
- en: Using the type system to ensure correct code
  id: totrans-652
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型系统确保代码正确
- en: You are familiar with static type checking through languages such as C# and
    Java. In these languages, the type checking is straightforward but rather crude,
    and can be seen as an annoyance compared with the freedom of dynamic languages
    such as Python and Ruby.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉通过像 C# 和 Java 这样的语言进行静态类型检查。在这些语言中，类型检查是直截了当但相当粗糙的，与像 Python 和 Ruby 这样的动态语言的自由相比，它可以被视为一种烦恼。
- en: But in F# the type system is your friend, not your enemy. You can use static
    type checking almost as an instant unit test ? making sure that your code is correct
    at compile time.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 F# 中，类型系统是你的朋友，而不是你的敌人。你几乎可以将静态类型检查视为即时单元测试？确保你的代码在编译时正确无误。
- en: 'In the earlier posts we have already seen some of the things that you can do
    with the type system in F#:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的帖子中，我们已经看到了在 F# 中使用类型系统可以做些什么：
- en: The types and their associated functions provide an abstraction to model the
    problem domain. Because creating types is so easy, there is rarely an excuse to
    avoid designing them as needed for a given problem, and unlike C# classes it is
    hard to create "kitchen-sink" types that do everything.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型及其相关函数提供了抽象来模拟问题领域。因为创建类型很容易，很少有借口可以避免根据给定问题的需要设计它们，与 C# 类不同，很难创建做"所有事情"的"厨房水槽"类型。
- en: Well defined types aid in maintenance. Since F# uses type inference, you can
    normally rename or restructure types easily without using a refactoring tool.
    And if the type is changed in an incompatible way, this will almost certainly
    create compile-time errors that aid in tracking down any problems.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义良好的类型有助于维护。由于 F# 使用类型推断，通常可以轻松地重命名或重新构造类型而无需使用重构工具。如果类型以不兼容的方式更改，这几乎肯定会创建编译时错误，有助于追踪任何问题。
- en: Well named types provide instant documentation about their roles in the program
    (and this documentation can never be out of date).
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好命名的类型提供了有关程序中其角色的即时文档（而此文档永远不会过时）。
- en: In this post and the next we will focus on using the type system as an aid to
    writing correct code. I will demonstrate that you can create designs such that,
    if your code actually compiles, it will almost certainly work as designed.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文和下一篇文章中，我们将重点介绍使用类型系统来帮助编写正确的代码。我将证明，你可以创建设计，以便如果你的代码实际上编译通过，它几乎肯定会按设计工作。
- en: Using standard type checking
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准类型检查
- en: In C#, you use the compile-time checks to validate your code without even thinking
    about it. For example, would you give up `List<string>` for a plain `List`? Or
    give up `Nullable<int>` and be forced to used `object` with casting? Probably
    not.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你使用编译时检查来验证你的代码，甚至都不用考虑它。例如，你会放弃`List<string>`以换取普通的`List`吗？或者放弃`Nullable<int>`并被迫使用带有转换的`object`吗？可能不会。
- en: But what if you could have even more fine-grained types? You could have even
    better compile-time checks. And this is exactly what F# offers.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你可以有更精细的类型呢？你可以获得更好的编译时检查。而这正是 F# 所提供的。
- en: The F# type checker is not that much stricter than the C# type checker. But
    because it is so easy to create new types without clutter, you can represent the
    domain better, and, as a useful side-effect, avoid many common errors.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: F# 类型检查器与 C# 类型检查器并没有太大的不同。但是因为创建新类型是如此容易而不会杂乱，你可以更好地表示领域，并且，作为一个有用的副作用，避免许多常见的错误。
- en: 'Here is a simple example:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE120]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: By wrapping the email address in a special type, we ensure that normal strings
    cannot be used as arguments to email specific functions. (In practice, we would
    also hide the constructor of the `EmailAddress` type as well, to ensure that only
    valid values could be created in the first place.)
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将电子邮件地址包装在特殊类型中，我们确保普通字符串不能作为电子邮件特定函数的参数。（实际上，我们还会隐藏 `EmailAddress` 类型的构造函数，以确保只能在第一次创建时创建有效值。）
- en: There is nothing here that couldn't be done in C#, but it would be quite a lot
    of work to create a new value type just for this one purpose, so in C#, it is
    easy to be lazy and just pass strings around.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么是不能在 C# 中完成的，但是为了仅此一目的创建一个新值类型会是相当多的工作，因此在 C# 中，可以很容易地偷懒并传递字符串。
- en: Additional type safety features in F#
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 中的其他类型安全功能
- en: Before moving on to the major topic of "designing for correctness", let's see
    a few of the other minor, but cool, ways that F# is type-safe.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论“为正确性设计”的主要主题之前，让我们看看 F# 是类型安全的其他一些次要但很酷的方式。
- en: Type-safe formatting with printf
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 printf 进行类型安全的格式化
- en: Here is a minor feature that demonstrates one of the ways that F# is more type-safe
    than C#, and how the F# compiler can catch errors that would only be detected
    at runtime in C#.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小功能，演示了 F# 比 C# 更类型安全的一种方式，并且 F# 编译器如何能够捕捉到在 C# 中仅在运行时检测到的错误。
- en: 'Try evaluating the following and look at the errors generated:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试评估以下内容并查看生成的错误：
- en: '[PRE121]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Unlike C#, the compiler analyses the format string and determines what the number
    and types of the arguments are supposed to be.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 不同，编译器分析格式字符串并确定参数的数量和类型应该是什么。
- en: This can be used to constrain the types of parameters without explicitly having
    to specify them. So for example, in the code below, the compiler can deduce the
    types of the arguments automatically.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来约束参数的类型，而无需明确指定它们。因此，例如，在下面的代码中，编译器可以自动推断参数的类型。
- en: '[PRE122]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Units of measure
  id: totrans-677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量单位
- en: F# has the ability to define units of measure and associate them with floats.
    The unit of measure is then "attached" to the float as a type and prevents mixing
    different types. This is another feature that can be very handy if you need it.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: F# 有能力定义测量单位并将其与浮点数关联起来。测量单位然后作为类型“附加”到浮点数上，并阻止混合不同类型。如果需要，这是另一个非常方便的功能。
- en: '[PRE123]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Type-safe equality
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型安全的相等性
- en: One final example. In C# any class can be equated with any other class (using
    reference equality by default). In general, this is a bad idea! For example, you
    shouldn't really be able to compare a string with a person at all.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子。在 C# 中，任何类都可以与任何其他类相等（默认情况下使用引用相等）。总的来说，这是一个坏主意！例如，你根本不应该比较一个字符串和一个人。
- en: 'Here is some C# code which is perfectly valid and compiles fine:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些完全有效且编译良好的 C# 代码：
- en: '[PRE124]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'If we write the identical code in F#, we get a compile-time error:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 F# 中编写相同的代码，我们会得到一个编译时错误：
- en: '[PRE125]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Chances are, if you are testing equality between two different types, you are
    doing something wrong.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在测试两种不同类型之间的相等性，那么你可能做错了什么。
- en: In F#, you can even stop a type being compared at all! This is not as silly
    as it seems. For some types, there may not be a useful default, or you may want
    to force equality to be based on a specific field rather than the object as whole.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，甚至可以完全停止比较类型！这并不像看起来那么愚蠢。对于某些类型，可能没有有用的默认值，或者您可能希望强制相等性基于特定字段而不是整个对象。
- en: 'Here is an example of this:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE126]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Worked example: Designing for correctness'
  id: totrans-690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作示例：为正确性设计
- en: 'Worked example: Designing for correctness'
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作示例：为正确性设计
- en: In this post, we'll see how you can design for correctness (or at least, for
    the requirements as you currently understand them), by which I mean that a client
    of a well designed model will not be able to put the system into an illegal state
    ? a state that doesn't meet the requirements. You literally cannot create incorrect
    code because the compiler will not let you.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将看到如何设计正确性（或者至少是根据目前理解的要求进行设计），我指的是一个良好设计的模型的客户端将无法使系统进入非法状态？即不符合要求的状态。你实际上无法创建不正确的代码，因为编译器不会让你这样做。
- en: For this to work, we do have to spend some time up front thinking about design
    and making an effort to encode the requirements into the types that you use. If
    you just use strings or lists for all your data structures, you will not get any
    benefit from the type checking.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们必须花一些时间来考虑设计，并努力将要求编码到你使用的类型中。如果你只是为所有数据结构使用字符串或列表，你将无法从类型检查中获得任何好处。
- en: We'll use a simple example. Let's say that you are designing an e-commerce site
    which has a shopping cart and you are given the following requirements.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的例子。假设你正在设计一个电子商务网站，其中有一个购物车，并且你得到了以下要求。
- en: You can only pay for a cart once.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能一次付款一个购物车。
- en: Once a cart is paid for, you cannot change the items in it.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦购物车付款，就不能更改其中的项目。
- en: Empty carts cannot be paid for.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空购物车不能付款。
- en: A bad design in C#
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的糟糕设计
- en: In C#, we might think that this is simple enough and dive straight into coding.
    Here is a straightforward implementation in C# that seems OK at first glance.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们可能认为这已经足够简单，直接开始编码。以下是一种在C#中看起来一开始似乎还可以的直接实现。
- en: '[PRE127]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Unfortunately, it''s actually a pretty bad design:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这实际上是一个相当糟糕的设计：
- en: One of the requirements is not even met. Can you see which one?
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个要求甚至都没有被满足。你能看出是哪一个吗？
- en: It has a major design flaw, and a number of minor ones. Can you see what they
    are?
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个主要的设计缺陷，以及一些次要的缺陷。你能看出它们是什么吗？
- en: So many problems in such a short piece of code!
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这么短的代码中有这么多问题！
- en: 'What would happen if we had even more complicated requirements and the code
    was thousands of lines long? For example, the fragment that is repeated everywhere:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有更复杂的要求，代码有数千行会发生什么？例如，到处重复的片段：
- en: '[PRE128]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: looks like it will be quite brittle if requirements change in some methods but
    not others.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来如果一些方法发生变化而其他方法没有变化，它将变得非常脆弱。
- en: 'Before you read the next section, think for a minute how you might better implement
    the requirements above in C#, with these additional requirements:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读下一节之前，想一分钟，你如何在C#中更好地实现上述要求，以及以下要求：
- en: If you try to do something that is not allowed in the requirements, you will
    get a *compile time error*, not a run time error. For example, you must create
    a design such that you cannot even call the `RemoveItem` method from an empty
    cart.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尝试做一些不符合要求的事情，你将得到一个*编译时错误*，而不是运行时错误。例如，你必须创建一个设计，以便你甚至不能从空购物车调用`RemoveItem`方法。
- en: The contents of the cart in any state should be immutable. The benefit of this
    is that if I am in the middle of paying for a cart, the cart contents can't change
    even if some other process is adding or removing items at the same time.
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何状态下购物车的内容都应该是不可变的。这样做的好处是，如果我正在支付购物车，即使其他进程同时添加或删除项目，购物车的内容也不会改变。
- en: A correct design in F#
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#中的正确设计
- en: 'Let''s step back and see if we can come up with a better design. Looking at
    these requirements, it''s obvious that we have a simple state machine with three
    states and some state transitions:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们退一步看看是否可以想出一个更好的设计。看着这些要求，很明显我们有一个简单的三状态状态机和一些状态转换： '
- en: A Shopping Cart can be Empty, Active or PaidFor
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车可以是空的、活动的或已付款的
- en: When you add an item to an Empty cart, it becomes Active
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你向空购物车添加项目时，它变为活动状态
- en: When you remove the last item from an Active cart, it becomes Empty
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你从活动购物车中移除最后一个项目时，它变为空
- en: When you pay for an Active cart, it becomes PaidFor
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你为活动购物车付款时，它变为已付款状态
- en: 'And now we can add the business rules to this model:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将业务规则添加到这个模型中：
- en: You can add an item only to carts that are Empty or Active
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能向空或活动的购物车添加项目
- en: You can remove an item only from carts that are Active
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能从活动的购物车中删除项目
- en: You can only pay for carts that are Active
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能为处于活动状态的购物车付款
- en: 'Here is the state diagram:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 这是状态图：
- en: '![Shopping Cart](ShoppingCart.png)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
  zh: '![购物车](ShoppingCart.png)'
- en: It's worth noting that these kinds of state-oriented models are very common
    in business systems. Product development, customer relationship management, order
    processing, and other workflows can often be modeled this way.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这些种类的基于状态的模型在商业系统中非常常见。产品开发、客户关系管理、订单处理和其他工作流程通常可以这样建模。
- en: 'Now we have the design, we can reproduce it in F#:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了设计，我们可以在F#中复制它：
- en: '[PRE129]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We create a type for each state, and `Cart` type that is a choice of any one
    of the states. I have given everything a distinct name (e.g. `PaidItems` and `UnpaidItems`
    rather than just `Items`) because this helps the inference engine and makes the
    code more self documenting.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个状态创建了一个类型，并创建了一个`Cart`类型，它是所有状态中的任意一个的选择。我为每样东西都取了一个不同的名称（例如`PaidItems`和`UnpaidItems`而不仅仅是`Items`），因为这有助于推理引擎，并使代码更具自解释性。
- en: This is a much longer example than the earlier ones! Don't worry too much about
    the F# syntax right now, but I hope that you can get the gist of the code, and
    see how it fits into the overall design.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个比之前的示例要长得多的示例！现在不要太担心F#语法，但我希望您能理解代码的要领，并看到它如何适应整体设计。
- en: Also, do paste the snippets into a script file and evaluate them for yourself
    as they come up.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 也要将代码片段粘贴到脚本文件中，并在出现时自行评估。
- en: Next we can create the operations for each state. The main thing to note is
    each operation will always take one of the States as input and return a new Cart.
    That is, you start off with a particular known state, but you return a `Cart`
    which is a wrapper for a choice of three possible states.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为每个状态创建操作。需要注意的主要事项是，每个操作始终将一个状态作为输入，并返回一个新的购物车。也就是说，您从一个特定的已知状态开始，但返回的是一个作为三种可能状态之一的选择的`Cart`。
- en: '[PRE130]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Next, we attach the operations to the states as methods
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将操作作为方法附加到状态上。
- en: '[PRE131]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: And we can create some cart level helper methods as well. At the cart level,
    we have to explicitly handle each possibility for the internal state with a `match..with`
    expression.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一些购物车级别的辅助方法。在购物车级别，我们必须使用`match..with`表达式显式处理内部状态的每种可能性。
- en: '[PRE132]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Testing the design
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试设计
- en: 'Let''s exercise this code now:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来练习这段代码：
- en: '[PRE133]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We now have an active cart with one item in it. Note that "`cartA`" is a completely
    different object from "`emptyCart`" and is in a different state.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含一个物品的活动购物车。请注意，“`cartA`”与“`emptyCart`”是完全不同的对象，并处于不同的状态。
- en: 'Let''s keep going:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续：
- en: '[PRE134]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: So far, so good. Again, all these are distinct objects in different states,
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。再次强调，所有这些都是不同状态的不同对象，
- en: 'Let''s test the requirement that you cannot remove items from an empty cart:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下不能从空购物车中移除物品的要求：
- en: '[PRE135]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: An error ? just what we want!
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 出错了？这正是我们想要的！
- en: Now say that we want to pay for a cart. We didn't create this method at the
    Cart level, because we didn't want to tell the client how to handle all the cases.
    This method only exists for the Active state, so the client will have to explicitly
    handle each case and only call the `Pay` method when an Active state is matched.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要支付购物车。我们没有在购物车级别创建此方法，因为我们不想告诉客户如何处理所有情况。此方法仅存在于活动状态，因此客户必须显式处理每种情况，并仅在匹配到活动状态时调用`Pay`方法。
- en: First we'll try to pay for cartA.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将尝试为cartA支付。
- en: '[PRE136]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The result was a paid cart.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个已支付的购物车。
- en: Now we'll try to pay for the emptyCart.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试为emptyCart支付款项。
- en: '[PRE137]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Nothing happens. The cart is empty, so the Active branch is not called. We might
    want to raise an error or log a message in the other branches, but no matter what
    we do we cannot accidentally call the `Pay` method on an empty cart, because that
    state does not have a method to call!
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 什么也没发生。购物车是空的，因此未调用Active分支。我们可能希望在其他分支中引发错误或记录消息，但无论我们做什么，都不能意外地在空购物车上调用`Pay`方法，因为该状态没有可调用的方法！
- en: The same thing happens if we accidentally try to pay for a cart that is already
    paid.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们意外地尝试为已经支付的购物车支付款项，结果会是一样的。
- en: '[PRE138]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You might argue that the client code above might not be representative of code
    in the real world ? it is well-behaved and already dealing with the requirements.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为上面的客户端代码可能不代表现实世界中的代码？它是行为良好的，并且已经处理了需求。
- en: 'So what happens if we have badly written or malicious client code that tries
    to force payment:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们有编写不良或恶意客户端代码试图强制支付会发生什么：
- en: '[PRE139]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: If we try to force it like this, we will get compile errors. There is no way
    the client can create code that does not meet the requirements.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像这样强行执行，我们将获得编译错误。客户端无法创建不符合要求的代码。
- en: Summary
  id: totrans-758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We have designed a simple shopping cart model which has many benefits over the
    C# design.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了一个简单的购物车模型，其优点远远超过了C#设计。
- en: It maps to the requirements quite clearly. It is impossible for a client of
    this API to call code that doesn't meet the requirements.
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与需求非常清晰地对应。这个API的客户端无法调用不符合要求的代码。
- en: Using states means that the number of possible code paths is much smaller than
    the C# version, so there will be many fewer unit tests to write.
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态意味着可能的代码路径数量要比 C# 版本小得多，因此要编写的单元测试要少得多。
- en: Each function is simple enough to probably work the first time, as, unlike the
    C# version, there are no conditionals anywhere.
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数都足够简单，可能第一次就能工作，因为与 C# 版本不同，这里没有任何条件语句。
- en: Analysis of the original C# code
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对原始的 C# 代码进行分析
- en: Now that you have seen the F# code, we can revisit the original C# code with
    fresh eyes. In case you were wondering, here are my thoughts as to what is wrong
    with the C# shopping cart example as designed.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过了 F# 代码，我们可以用新的眼光重新审视原始的 C# 代码。如果你想知道，这是我对设计的 C# 购物车示例有什么问题的看法。
- en: '*Requirement not met*: An empty cart can still be paid for.'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '*需求未满足*：一个空购物车仍然可以支付。'
- en: '*Major design flaw*: Overloading the payment amount to be a signal for IsPaidFor
    means that a zero paid amount can never lock down the cart. Are you sure it would
    never be possible to have a cart which is paid for but free of charge? The requirements
    are not clear, but what if this did become a requirement later? How much code
    would have to be changed?'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '*主要设计缺陷*：将支付金额重载为 IsPaidFor 的信号意味着零支付金额永远无法锁定购物车。你确定购物车永远不可能是已支付但免费的吗？要求不明确，但如果以后这成为要求呢？需要改变多少代码？'
- en: '*Minor design flaws*: What should happen when trying to remove an item from
    an empty cart? And what should happen when attempting to pay for a cart that is
    already paid for? Should we throw exceptions in these cases, or just silently
    ignore them? And does it make sense that a client should be able to enumerate
    the items in an empty cart? And this is not thread safe as designed; so what happens
    if a secondary thread adds an item to the cart while a payment is being made on
    the main thread?'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '*次要设计缺陷*：当尝试从空购物车中移除项目时应该发生什么？当尝试为已支付的购物车支付时应该发生什么？在这些情况下，我们应该抛出异常，还是只是静默地忽略它们？客户端能够枚举空购物车中的项目是否有意义？按设计来说这不是线程安全的；那么如果在主线程上进行付款时，辅助线程向购物车添加项目会发生什么？'
- en: That's quite a lot of things to worry about.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当多的事情需要担心。
- en: The nice thing about the F# design is none of these problems can even exist.
    So designing this way not only ensures correct code, but it also really reduces
    the cognitive effort to ensure that the design is bullet proof in the first place.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: F# 设计的好处是这些问题甚至都不存在。因此，这样设计不仅能确保正确的代码，而且还能真正减少确保设计一开始就是无懈可击的认知工作量。
- en: '*Compile time checking:* The original C# design mixes up all the states and
    transitions in a single class, which makes it very error prone. A better approach
    would be to create separate state classes (with a common base class say) which
    reduces complexity, but still, the lack of a built in "union" type means that
    you cannot statically verify that the code is correct. There are ways of doing
    "union" types in C#, but it is not idiomatic at all, while in F# it is commonplace.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译时检查*：原始的 C# 设计将所有状态和转换混合在一个单一的类中，这使得它非常容易出错。更好的方法是创建单独的状态类（比如说带有一个共同基类），这样可以减少复杂性，但是仍然，缺乏内置的“联合”类型意味着你不能静态验证代码是否正确。在
    C# 中有一些实现“联合”类型的方法，但这完全不符合惯例，而在 F# 中却很普遍。'
- en: 'Appendix: C# code for a correct solution'
  id: totrans-771
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录：正确解决方案的 C# 代码
- en: When faced with these requirements in C#, you might immediately think -- just
    create an interface!
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这些要求在 C# 中，你可能会立即想到 -- 只需创建一个接口！
- en: 'But it is not as easy as you might think. I have written a follow up post on
    this to explain why: [The shopping cart example in C#](../csharp/union-types-in-csharp.html).'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情并不像你想象的那么简单。我已经写了一篇后续文章来解释为什么：[C# 中的购物车示例](../csharp/union-types-in-csharp.html)。
- en: If you are interested to see what the C# code for a solution looks like, here
    it is below. This code meets the requirements above and guarantees correctness
    at *compile time*, as desired.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对看看解决方案的 C# 代码感兴趣，下面是它的代码。这段代码满足上述要求，并且像预期的那样在*编译时*保证了正确性。
- en: The key thing to note is that, because C# doesn't have union types, the implementation
    uses a ["fold" function](match-expression.html#folds), a function that has three
    function parameters, one for each state. To use the cart, the caller passes a
    set of three lambdas in, and the (hidden) state determines what happens.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要注意的是，因为 C# 没有联合类型，所以实现使用了一个["fold" 函数](match-expression.html#folds)，这个函数有三个函数参数，分别对应每种状态。为了使用购物车，调用者传入一组三个
    lambda 函数，而（隐藏的）状态决定了发生了什么。
- en: '[PRE140]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This approach means that the caller can never call the "wrong" function, such
    as "Pay" for the Empty state, because the parameter to the lambda will not support
    it. Try it and see!
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法意味着调用者永远不会调用“错误”的函数，例如对于 Empty 状态调用“Pay”，因为 lambda 的参数不支持它。试一下，看看！
- en: '[PRE141]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Concurrency
  id: totrans-779
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: Concurrency
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: We hear a lot about concurrency nowadays, how important it is, and how it is
    ["the next major revolution in how we write software"](http://www.gotw.ca/publications/concurrency-ddj.htm).
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 如今我们经常听到关于并发的话题，它有多么重要，以及它如何是["我们编写软件的下一个主要革命"](http://www.gotw.ca/publications/concurrency-ddj.htm)。
- en: So what do we actually mean by "concurrency" and how can F# help?
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们究竟是什么意思说“并发”，F# 又如何帮助呢？
- en: The simplest definition of concurrency is just "several things happening at
    once, and maybe interacting with each other". It seems a trivial definition, but
    the key point is that most computer programs (and languages) are designed to work
    serially, on one thing at a time, and are not well-equipped to handle concurrency.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 并发的最简单定义就是“同时发生几件事情，也许彼此相互作用”。这似乎是一个微不足道的定义，但关键点在于大多数计算机程序（和语言）都是设计为串行工作的，一次处理一件事情，并且不适合处理并发。
- en: 'And even if computer programs are written to handle concurrency, there is an
    even more serious problem: our brains do not do well when thinking about concurrency.
    It is commonly acknowledged that writing code that handles concurrency is extremely
    hard. Or I should say, writing concurrent code that is *correct* is extremely
    hard! It''s very easy to write concurrent code that is buggy; there might be race
    conditions, or operations might not be atomic, or tasks might be starved or blocked
    unnecessarily, and these issues are hard to find by looking at the code or using
    a debugger.'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 即使计算机程序被编写以处理并发，也存在一个更严重的问题：我们的大脑在思考并发时表现不佳。普遍认为编写处理并发的代码非常困难。或者我应该说，编写正确的并发代码非常困难！编写出有错误的并发代码非常容易；可能会出现竞争条件，或者操作可能不是原子的，或者任务可能会被无谓地饿死或阻塞，这些问题很难通过查看代码或使用调试器来找到。
- en: 'Before talking about the specifics of F#, let''s try to classify some of the
    common types of concurrency scenarios that we have to deal with as developers:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 F# 的具体内容之前，让我们试着对我们作为开发人员必须处理的一些常见并发场景进行分类：
- en: '**"Concurrent Multitasking"**. This is when we have a number of concurrent
    tasks (e.g. processes or threads) within our direct control, and we want them
    to communicate with each other and share data safely.'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"并发多任务"**。当我们控制一些并发任务（例如进程或线程），并希望它们安全地相互通信和共享数据时，我们就会遇到这种情况。'
- en: '**"Asynchronous" programming**. This is when we initiate a conversation with
    a separate system outside our direct control, and then wait for it to get back
    to us. Common cases of this are when talking to the filesystem, a database, or
    the network. These situations are typically I/O bound, so you want to do something
    else useful while you are waiting. These types of tasks are often *non-deterministic*
    as well, meaning that running the same program twice might give a different result.'
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"异步"编程**。这是当我们启动与我们直接控制之外的另一个系统的对话，然后等待它回复我们时发生的情况。这种情况的常见情况是与文件系统、数据库或网络通信。这些情况通常是
    I/O 绑定的，因此在等待期间，您希望做一些其他有用的事情。这些类型的任务通常也是*非确定性*的，这意味着两次运行相同的程序可能会得到不同的结果。'
- en: '**"Parallel" programming**. This is when we have a single task that we want
    to split into independant subtasks, and then run the subtasks in parallel, ideally
    using all the cores or CPUs that are available. These situations are typically
    CPU bound. Unlike the async tasks, parallelism is typically *deterministic*, so
    running the same program twice will give the same result.'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"并行"编程**。当我们有一个单一任务要拆分为独立的子任务，然后并行运行这些子任务时，这就是并行编程，理想情况下利用所有可用的核心或 CPU。这些情况通常是
    CPU 绑定的。与异步任务不同，并行性通常是*确定性*的，因此两次运行相同的程序将产生相同的结果。'
- en: '**"Reactive" programming**. This is when we do not initiate tasks ourselves,
    but are focused on listening for events which we then process as fast as possible.
    This situation occurs when designing servers, and when working with a user interface.'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"响应式"编程**。这是当我们自己不发起任务，而是专注于监听事件并尽快处理这些事件时发生的情况。这种情况发生在设计服务器和处理用户界面时。'
- en: 'Of course, these are vague definitions and overlap in practice. In general,
    though, for all these cases, the actual implementations that address these scenarios
    tend to use two distinct approaches:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: If there are lots of different tasks that need to share state or resources without
    waiting, then use a "buffered asynchronous" design.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are lots of identical tasks that do not need to share state, then use
    parallel tasks using "fork/join" or "divide and conquer" approaches.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# tools for concurrent programming
  id: totrans-793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'F# offers a number of different approaches to writing concurrent code:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: For multitasking and asynchronous problems, F# can directly use all the usual
    .NET suspects, such as `Thread` `AutoResetEvent`, `BackgroundWorker` and `IAsyncResult`.
    But it also offers a much simpler model for all types of async IO and background
    task management, called "asynchronous workflows". We will look at these in the
    next post.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative approach for asynchronous problems is to use message queues and
    the ["actor model"](http://en.wikipedia.org/wiki/Actor_model) (this is the "buffered
    asynchronous" design mentioned above). F# has a built in implementation of the
    actor model called `MailboxProcessor`. I am a big proponent of designing with
    actors and message queues, as it decouples the various components and allows you
    to think serially about each one.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For true CPU parallelism, F# has convenient library code that builds on the
    asynchronous workflows mentioned above, and it can also use the .NET [Task Parallel
    Library](http://msdn.microsoft.com/en-us/library/dd460717.aspx).
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the functional approach to event handling and reactive programming
    is quite different from the traditional approach. The functional approach treats
    events as "streams" which can be filtered, split, and combined in much the the
    same way that LINQ handles collections. F# has built in support for this model,
    as well as for the standard event-driven model.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming
  id: totrans-799
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post we'll have a look at a few ways to write asynchronous code in F#,
    and a very brief example of parallelism as well.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: Traditional asynchronous programming
  id: totrans-802
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted in the previous post, F# can directly use all the usual .NET suspects,
    such as `Thread` `AutoResetEvent`, `BackgroundWorker` and `IAsyncResult`.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example where we wait for a timer event to go off:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This shows the use of `AutoResetEvent` as a synchronization mechanism.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: A lambda is registered with the `Timer.Elapsed` event, and when the event is
    triggered, the AutoResetEvent is signalled.
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main thread starts the timer, does something else while waiting, and then
    blocks until the event is triggered.
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the main thread continues, about 2 seconds later.
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code above is reasonably straightforward, but does require you to instantiate
    an AutoResetEvent, and could be buggy if the lambda is defined incorrectly.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: Introducing asynchronous workflows
  id: totrans-811
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# has a built-in construct called "asynchronous workflows" which makes async
    code much easier to write. These workflows are objects that encapsulate a background
    task, and provide a number of useful operations to manage them.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the previous example rewritten to use one:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Here are the changes:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: the `AutoResetEvent` and lambda have disappeared, and are replaced by `let timerEvent
    = Control.Async.AwaitEvent (timer.Elapsed)`, which creates an `async` object directly
    from the event, without needing a lambda. The `ignore` is added to ignore the
    result.
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the `event.WaitOne()` has been replaced by `Async.RunSynchronously timerEvent`
    which blocks on the async object until it has completed.
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it. Both simpler and easier to understand.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: The async workflows can also be used with `IAsyncResult`, begin/end pairs, and
    other standard .NET methods.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: For example, here's how you might do an async file write by wrapping the `IAsyncResult`
    generated from `BeginWrite`.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Creating and nesting asynchronous workflows
  id: totrans-822
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous workflows can also be created manually. A new workflow is created
    using the `async` keyword and curly braces. The braces contain a set of expressions
    to be executed in the background.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: This simple workflow just sleeps for 2 seconds.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '*Note: the code `do! Async.Sleep 2000` is similar to `Thread.Sleep` but designed
    to work with asynchronous workflows.*'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: Workflows can contain *other* async workflows nested inside them. Within the
    braces, the nested workflows can be blocked on by using the `let!` syntax.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Cancelling workflows
  id: totrans-829
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One very convenient thing about async workflows is that they support a built-in
    cancellation mechanism. No special code is needed.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple task that prints numbers from 1 to 100:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'We can test it in the usual way:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Now let's say we want to cancel this task half way through. What would be the
    best way of doing it?
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: In C#, we would have to create flags to pass in and then check them frequently,
    but in F# this technique is built in, using the `CancellationToken` class.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: 'Here an example of how we might cancel the task:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: In F#, any nested async call will check the cancellation token automatically!
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case it was the line:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: As you can see from the output, this line is where the cancellation happened.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: Composing workflows in series and parallel
  id: totrans-843
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another useful thing about async workflows is that they can be easily combined
    in various ways: both in series and in parallel.'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s again create a simple workflow that just sleeps for a given time:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Here''s a version that combines two of these in series:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'And here''s a version that combines two of these in parallel:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Note: The #time command toggles the timer on and off. It only works in the
    interactive window, so this example must be sent to the interactive window in
    order to work corrrectly.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: We're using the `#time` option to show the total elapsed time, which, because
    they run in parallel, is 2 secs. If they ran in series instead, it would take
    3 seconds.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: Also you might see that the output is garbled sometimes because both tasks are
    writing to the console at the same time!
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: This last sample is a classic example of a "fork/join" approach, where a number
    of a child tasks are spawned and then the parent waits for them all to finish.
    As you can see, F# makes this very easy!
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: an async web downloader'
  id: totrans-855
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this more realistic example, we'll see how easy it is to convert some existing
    code from a non-asynchronous style to an asynchronous style, and the corresponding
    performance increase that can be achieved.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: 'So here is a simple URL downloader, very similar to the one we saw at the start
    of the series:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'And here is some code to time it:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Make a note of the time taken, and let's if we can improve on it!
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: Obviously the example above is inefficient -- only one web site at a time is
    visited. The program would be faster if we could visit them all at the same time.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: 'So how would we convert this to a concurrent algorithm? The logic would be
    something like:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a task for each web page we are downloading, and then for each task,
    the download logic would be something like:'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start downloading a page from a website. While that is going on, pause and let
    other tasks have a turn.
  id: totrans-865
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the download is finished, wake up and continue on with the task
  id: totrans-866
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, start all the tasks up and let them go at it!
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, this is quite hard to do in a standard C-like language. In C#
    for example, you have to create a callback for when an async task completes. Managing
    these callbacks is painful and creates a lot of extra support code that gets in
    the way of understanding the logic. There are some elegant solutions to this,
    but in general, the signal to noise ratio for concurrent programming in C# is
    very high*.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '[* As of the time of this writing. Future versions of C# will have the `await`
    keyword, which is similar to what F# has now.]'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: 'But as you can guess, F# makes this easy. Here is the concurrent F# version
    of the downloader code:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Note that the new code looks almost exactly the same as the original. There
    are only a few minor changes.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: The change from "`use resp =`" to "`use! resp =`" is exactly the change that
    we talked about above -- while the async operation is going on, let other tasks
    have a turn.
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also used the extension method `AsyncGetResponse` defined in the `CommonExtensions`
    namespace. This returns an async workflow that we can nest inside the main workflow.
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition the whole set of steps is contained in the "`async {...}`" wrapper
    which turns it into a block that can be run asynchronously.
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And here is a timed download using the async version.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The way this works is:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchUrlAsync` is applied to each site. It does not immediately start the
    download, but returns an async workflow for running later.'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set up all the tasks to run at the same time we use the `Async.Parallel`
    function
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally we call `Async.RunSynchronously` to start all the tasks, and wait for
    them all to stop.
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try out this code yourself, you will see that the async version is much
    faster than the sync version. Not bad for a few minor code changes! Most importantly,
    the underlying logic is still very clear and is not cluttered up with noise.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您自己尝试这段代码，您会发现异步版本比同步版本快得多。对于一些微小的代码更改来说，这并不算坏事！最重要的是，底层逻辑仍然非常清晰，没有被噪音淹没。
- en: 'Example: a parallel computation'
  id: totrans-883
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：一个并行计算
- en: To finish up, let's have another quick look at a parallel computation again.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们再次快速看一下并行计算。
- en: Before we start, I should warn you that the example code below is just to demonstrate
    the basic principles. Benchmarks from "toy" versions of parallelization like this
    are not meaningful, because any kind of real concurrent code has so many dependencies.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我应该警告你，下面的示例代码仅用于演示基本原则。像这样的“玩具”版本的并行化基准测试并没有意义，因为任何真正的并发代码都有很多依赖关系。
- en: And also be aware that parallelization is rarely the best way to speed up your
    code. Your time is almost always better spent on improving your algorithms. I'll
    bet my serial version of quicksort against your parallel version of bubblesort
    any day! (For more details on how to improve performance, see the [optimization
    series](optimization.md))
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，并行化很少是加速代码的最佳方法。你的时间几乎总是更好地花在改进算法上。我随时愿意拿我的串行快速排序版本与你的并行冒泡排序版本比试！（有关如何提高性能的更多详细信息，请参见[优化系列](optimization.md)）
- en: Anyway, with that caveat, let's create a little task that chews up some CPU.
    We'll test this serially and in parallel.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在这个警告的前提下，让我们创建一个消耗一些 CPU 的小任务。我们将串行和并行测试这个任务。
- en: '[PRE158]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Adjust the upper bounds of the loops as needed to make this run in about 0.2
    seconds.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要调整循环的上限，使其在大约 0.2 秒内运行。
- en: 'Now let''s combine a bunch of these into a single serial task (using composition),
    and test it with the timer:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将一堆这些任务组合成一个单一的串行任务（使用组合），并使用计时器进行测试：
- en: '[PRE159]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This should take about 4 seconds.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该大约需要 4 秒。
- en: 'Now in order to make the `childTask` parallelizable, we have to wrap it inside
    an `async`:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使`childTask`可并行化，我们必须将其包装在`async`中：
- en: '[PRE160]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: And to combine a bunch of asyncs into a single parallel task, we use `Async.Parallel`.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一堆异步操作组合成一个单一的并行任务，我们使用`Async.Parallel`。
- en: 'Let''s test this and compare the timings:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下并比较时间：
- en: '[PRE161]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: On a dual-core machine, the parallel version is about 50% faster. It will get
    faster in proportion to the number of cores or CPUs, of course, but sublinearly.
    Four cores will be faster than one core, but not four times faster.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 在双核机器上，并行版本大约快50%。当然，它会随着核心或 CPU 数量的增加而变得更快，但是次线性增长。四个核心会比一个核心快，但不会快四倍。
- en: On the other hand, as with the async web download example, a few minor code
    changes can make a big difference, while still leaving the code easy to read and
    understand. So in cases where parallelism will genuinely help, it is nice to know
    that it is easy to arrange.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，就像异步网络下载示例一样，一些微小的代码更改可能会产生很大的差异，同时仍然使代码易于阅读和理解。因此，在真正需要并行处理的情况下，知道很容易安排这一点是很好的。
- en: Messages and Agents
  id: totrans-900
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息和代理
- en: Messages and Agents
  id: totrans-901
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息和代理
- en: In this post, we'll look at the message-based (or actor-based) approach to concurrency.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将看一下基于消息（或基于 actor）的并发方法。
- en: In this approach, when one task wants to communicate with another, it sends
    it a message, rather than contacting it directly. The messages are put on a queue,
    and the receiving task (known as an "actor" or "agent") pulls the messages off
    the queue one at a time to process them.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，当一个任务想要与另一个任务通信时，它会发送一个消息，而不是直接联系。消息被放在队列中，接收任务（称为“actor”或“代理”）会逐个从队列中取出消息进行处理。
- en: This message-based approach has been applied to many situations, from low-level
    network sockets (built on TCP/IP) to enterprise wide application integration systems
    (for example MSMQ or IBM WebSphere MQ).
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于消息的方法已经应用于许多情况，从低级网络套接字（建立在 TCP/IP 上）到企业范围的应用集成系统（例如 MSMQ 或 IBM WebSphere
    MQ）。
- en: 'From a software design point of view, a message-based approach has a number
    of benefits:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件设计的角度来看，基于消息的方法有许多好处：
- en: You can manage shared data and resources without locks.
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以管理共享数据和资源而无需锁定。
- en: You can easily follow the "single responsibility principle", because each agent
    can be designed to do only one thing.
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以轻松遵循“单一职责原则”，因为每个代理可以设计为只做一件事。
- en: 'It encourages a "pipeline" model of programming with "producers" sending messages
    to decoupled "consumers", which has additional benefits:'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The queue acts as a buffer, eliminating waiting on the client side.
  id: totrans-909
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is straightforward to scale up one side or the other of the queue as needed
    in order to maximize throughput.
  id: totrans-910
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors can be handled gracefully, because the decoupling means that agents can
    be created and destroyed without affecting their clients.
  id: totrans-911
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From a practical developer's point of view, what I find most appealing about
    the message-based approach is that when writing the code for any given actor,
    you don't have to hurt your brain by thinking about concurrency. The message queue
    forces a "serialization" of operations that otherwise might occur concurrently.
    And this in turn makes it much easier to think about (and write code for) the
    logic for processing a message, because you can be sure that your code will be
    isolated from other events that might interrupt your flow.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: With these advantages, it is not surprising that when a team inside Ericsson
    wanted to design a programming language for writing highly-concurrent telephony
    applications, they created one with a message-based approach, namely Erlang. Erlang
    has now become the poster child for the whole topic, and has created a lot of
    interest in implementing the same approach in other languages.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: How F# implements a message-based approach
  id: totrans-914
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# has a built-in agent class called `MailboxProcessor`. These agents are very
    lightweight compared with threads - you can instantiate tens of thousands of them
    at the same time.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: These are similar to the agents in Erlang, but unlike the Erlang ones, they
    do *not* work across process boundaries, only in the same process. And unlike
    a heavyweight queueing system such as MSMQ, the messages are not persistent. If
    your app crashes, the messages are lost.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: But these are minor issues, and can be worked around. In a future series, I
    will go into alternative implementations of message queues. The fundamental approach
    is the same in all cases.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple agent implementation in F#:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The `MailboxProcessor.Start` function takes a simple function parameter. That
    function loops forever, reading messages from the queue (or "inbox") and processing
    them.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: I have added the #nowarn "40" pragma to avoid the warning "FS0040",
    which can be safely ignored in this case.*'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the example in use:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'In the rest of this post we''ll look at two slightly more useful examples:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: Managing shared state without locks
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialized and buffered access to shared IO
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both of these cases, a message based approach to concurrency is elegant,
    efficient, and easy to program.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: Managing shared state
  id: totrans-928
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the shared state problem first.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: 'A common scenario is that you have some state that needs to be accessed and
    changed by multiple concurrent tasks or threads. We''ll use a very simple case,
    and say that the requirements are:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: A shared "counter" and "sum" that can be incremented by multiple tasks concurrently.
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to the counter and sum must be atomic -- we must guarantee that they
    will both be updated at the same time.
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The locking approach to shared state
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using locks or mutexes is a common solution for these requirements, so let's
    write some code using a lock, and see how it performs.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: First let's write a static `LockedCounter` class that protects the state with
    locks.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Some notes on this code:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: This code is written using a very imperative approach, with mutable variables
    and locks
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public `Add` method has explicit `Monitor.Enter` and `Monitor.Exit` expressions
    to get and release the lock. This is the same as the `lock{...}` statement in
    C#.
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've also added a stopwatch to measure how long a client has to wait to get
    the lock.
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core "business logic" is the `updateState` method, which not only updates
    the state, but adds a small random wait as well to emulate the time taken to do
    the processing.
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s test it in isolation:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Next, we''ll create a task that will try to access the counter:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: In this case, when there is no contention at all, the wait times are all 0.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens when we create 10 child tasks that all try to access the counter
    at once:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Oh dear! Most tasks are now waiting quite a while. If two tasks want to update
    the state at the same time, one must wait for the other's work to complete before
    it can do its own work, which affects performance.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: And if we add more and more tasks, the contention will increase, and the tasks
    will spend more and more time waiting rather than working.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: The message-based approach to shared state
  id: totrans-951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how a message queue might help us. Here''s the message based version:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Some notes on this code:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: The core "business logic" is again in the `updateState` method, which has almost
    the same implementation as the earlier example, except the state is immutable,
    so that a new state is created and returned to the main loop.
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent reads messages (simple ints in this case) and then calls `updateState`
    method
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public method `Add` posts a message to the agent, rather than calling the
    `updateState` method directly
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code is written in a more functional way; there are no mutable variables
    and no locks anywhere. In fact, there is no code dealing with concurrency at all!
    The code only has to focus on the business logic, and is consequently much easier
    to understand.
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s test it in isolation:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Next, we''ll reuse a task we defined earlier, but calling `MessageBasedCounter.Add`
    instead:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Finally let's create 5 child tasks that try to access the counter at once.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: We can't measure the waiting time for the clients, because there is none!
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: Shared IO
  id: totrans-966
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A similar concurrency problem occurs when accessing a shared IO resource such
    as a file:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: If the IO is slow, the clients can spend a lot of time waiting, even without
    locks.
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple threads write to the resource at the same time, you can get corrupted
    data.
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both problems can be solved by using asynchronous calls combined with buffering
    -- exactly what a message queue does.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: In this next example, we'll consider the example of a logging service that many
    clients will write to concurrently. (In this trivial case, we'll just write directly
    to the Console.)
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: We'll first look at an implementation without concurrency control, and then
    at an implementation that uses message queues to serialize all requests.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: IO without serialization
  id: totrans-973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make the corruption very obvious and repeatable, let's first create
    a "slow" console that writes each individual character in the log message and
    pauses for a millisecond between each character. During that millisecond, another
    thread could be writing as well, causing an undesirable interleaving of messages.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Next, we will create a simple task that loops a few times, writing its name
    each time to the logger:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Next, we write a logging class that encapsulates access to the slow console.
    It has no locking or serialization, and is basically not thread-safe:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Now let's combine all these into a real example. We will create five child tasks
    and run them in parallel, all trying to write to the slow console.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Ouch! The output is very garbled!
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: Serialized IO with messages
  id: totrans-983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what happens when we replace `UnserializedLogger` with a `SerializedLogger`
    class that encapsulates a message queue.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: The agent inside `SerializedLogger` simply reads a message from its input queue
    and writes it to the slow console. Again there is no code dealing with concurrency
    and no locks are used.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'So now we can repeat the earlier unserialized example but using the `SerializedLogger`
    instead. Again, we create five child tasks and run them in parallel:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: What a difference! This time the output is perfect.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-990
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is much more to say about this message based approach. In a future series,
    I hope to go into much more detail, including discussion of topics such as:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: alternative implementations of message queues with MSMQ and TPL Dataflow.
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cancellation and out of band messages.
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: error handling and retries, and handling exceptions in general.
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to scale up and down by creating or removing child agents.
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: avoiding buffer overruns and detecting starvation or inactivity.
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional Reactive Programming
  id: totrans-997
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Reactive Programming
  id: totrans-998
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events are everywhere. Almost every program has to handle events, whether it
    be button clicks in the user interface, listening to sockets in a server, or even
    a system shutdown notification.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: 'And events are the basis of one of the most common OO design patterns: the
    "Observer" pattern.'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: But as we know, event handling, like concurrency in general, can be tricky to
    implement. Simple event logic is straightforward, but what about logic like "do
    something if two events happen in a row but do something different if only one
    event happens" or "do something if two events happen at roughly the same time".
    And how easy is it to combine these requirements in other, more complex ways?
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: Even you can successfully implement these requirements, the code tends to be
    spaghetti like and hard to understand, even with the best intentions.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: Is there a approach that can make event handling easier?
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: We saw in the previous post on message queues that one of the advantages of
    that approach was that the requests were "serialized" making it conceptually easier
    to deal with.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: There is a similar approach that can be used with events. The idea is to turn
    a series of events into an "event stream". Event streams then become quite like
    IEnumerables, and so the obvious next step is to treat them in much the the same
    way that LINQ handles collections, so that they can be filtered, mapped, split
    and combined.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: F# has built in support for this model, as well as for the more tradition approach.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: A simple event stream
  id: totrans-1007
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with a simple example to compare the two approaches. We'll implement
    the classic event handler approach first.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a utility function that will:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: create a timer
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: register a handler for the `Elapsed` event
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: run the timer for five seconds and then stop it
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Now test it interactively:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Now let's create a similar utility method to create a timer, but this time it
    will return an "observable" as well, which is the stream of events.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'And again test it interactively:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The difference is that instead of registering a handler directly with an event,
    we are "subscribing" to an event stream. Subtly different, and important.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: Counting events
  id: totrans-1022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this next example, we''ll have a slightly more complex requirement:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'To do this in a classic imperative way, we would probably create a class with
    a mutable counter, as below:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'We can reuse the utility functions we created earlier to test it:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Let''s see how we would do this same thing in a functional way:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Here we see how you can build up layers of event transformations, just as you
    do with list transformations in LINQ.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: The first transformation is `scan`, which accumulates state for each event.
    It is roughly equivalent to the `List.fold` function that we have seen used with
    lists. In this case, the accumulated state is just a counter.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: And then, for each event, the count is printed out.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this functional approach, we didn't have any mutable state, and
    we didn't need to create any special classes.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: Merging multiple event streams
  id: totrans-1035
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a final example, we'll look at merging multiple event streams.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a requirement based on the well-known "FizzBuzz" problem:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: First let's create some code that both implementations can use.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: We'll want a generic event type that captures the timer id and the time of the
    tick.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: And then we need a utility function to see if two events are simultaneous. We'll
    be generous and allow a time difference of up to 50ms.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: In the imperative design, we'll need to keep track of the previous event, so
    we can compare them. And we'll need special case code for the first time, when
    the previous event doesn't exist
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Now the code is beginning to get ugly fast! Already we have mutable state, complex
    conditional logic, and special cases, just for such a simple requirement.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: It does work, but are you sure the code is not buggy? Are you likely to accidentally
    break something if you change it?
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this imperative code is that it has a lot of noise that obscures
    the the requirements.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: Can the functional version do better? Let's see!
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create *two* event streams, one for each timer:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Next, we convert each event on the "raw" event streams into our FizzBuzz event
    type:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Now, to see if two events are simultaneous, we need to compare them from the
    two different streams somehow.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s actually easier than it sounds, because we can:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: 'combine the two streams into a single stream:'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then create pairs of sequential events
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then test the pairs to see if they are simultaneous
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then split the input stream into two new output streams based on that test
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the actual code to do this:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Finally, we can split the `nonSimultaneousStream` again, based on the event
    id:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Let''s review so far. We have started with the two original event streams and
    from them created four new ones:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '`combinedStream` contains all the events'
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simultaneousStream` contains only the simultaneous events'
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fizzStream` contains only the non-simultaneous events with id=3'
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buzzStream` contains only the non-simultaneous events with id=5'
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now all we need to do is attach behavior to each stream:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Let''s test it:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Here''s all the code in one complete set:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The code might seem a bit long winded, but this kind of incremental, step-wise
    approach is very clear and self-documenting.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of this style are:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: I can see that it meets the requirements just by looking at it, without even
    running it. Not so with the imperative version.
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a design point of view, each final "output" stream follows the single responsibility
    principle -- it only does one thing -- so it is very easy to associate behavior
    with it.
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code has no conditionals, no mutable state, no edge cases. It would be
    easy to maintain or change, I hope.
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is easy to debug. For example, I could easily "tap" the output of the `simultaneousStream`
    to see if it contains what I think it contains:'
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: This would be much harder in the imperative version.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1085
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional Reactive Programming (known as FRP) is a big topic, and we've only
    just touched on it here. I hope this introduction has given you a glimpse of the
    usefulness of this way of doing things.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more, see the documentation for the F# [Observable module](http://msdn.microsoft.com/en-us/library/ee370313),
    which has the basic transformations used above. And there is also the [Reactive
    Extensions (Rx)](http://msdn.microsoft.com/en-us/library/hh242985%28v=vs.103%29)
    library which shipped as part of .NET 4\. That contains many other additional
    transformations.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Completeness
  id: totrans-1088
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Completeness
  id: totrans-1089
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final set of posts, we will look at some other aspects of F# under the
    theme of "completeness".
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages coming from the academic world tend to focus on elegance
    and purity over real-world usefulness, while more mainstream business languages
    such as C# and Java are valued precisely because they are pragmatic; they can
    work in a wide array of situations and have extensive tools and libraries to meet
    almost every need. In other words, to be useful in the enterprise, a language
    needs to be *complete*, not just well-designed.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: F# is unusual in that it successfully bridges both worlds. Although all the
    examples so far have focused on F# as an elegant functional language, it does
    support an object-oriented paradigm as well, and can integrate easily with other
    .NET languages and tools. As a result, F# is not a isolated island, but benefits
    from being part of the whole .NET ecosystem.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: The other aspects that make F# "complete" are being an official .NET language
    (with all the support and documentation that that entails) and being designed
    to work in Visual Studio (which provides a nice editor with IntelliSense support,
    a debugger, and so on). These benefits should be obvious and won't be discussed
    here.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this last section, we''ll focus on two particular areas:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '**Seamless interoperation with .NET libraries**. Obviously, there can be a
    mismatch between the functional approach of F# and the imperative approach that
    is designed into the base libraries. We''ll look at some of the features of F#
    that make this integration easier.'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full support for classes and other C# style code**. F# is designed as a hybrid
    functional/OO language, so it can do almost everything that C# can do as well.
    We''ll have a quick tour of the syntax for these other features.'
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless interoperation with .NET libraries
  id: totrans-1097
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seamless interoperation with .NET libraries
  id: totrans-1098
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen many examples of F#'s use with the .NET libraries, such
    as using `System.Net.WebRequest` and `System.Text.RegularExpressions`. And the
    integration was indeed seamless.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: For more complex requirements, F# natively supports .NET classes, interfaces,
    and structures, so the interop is still very straightforward. For example, you
    can write an `ISomething` interface in C# and have the implementation be done
    in F#.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: But not only can F# call into existing .NET code, it can also expose almost
    any .NET API back to other languages. For example, you can write classes and methods
    in F# and expose them to C#, VB or COM. You can even do the above example backwards
    -- define an `ISomething` interface in F# and have the implementation be done
    in C#! The benefit of all this is that you don't have to discard any of your existing
    code base; you can start using F# for some things while retaining C# or VB for
    others, and pick the best tool for the job.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the tight integration though, there are a number of nice features
    in F# that often make working with .NET libraries more convenient than C# in some
    ways. Here are some of my favorites:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: You can use `TryParse` and `TryGetValue` without passing an "out" parameter.
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can resolve method overloads by using argument names, which also helps with
    type inference.
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use "active patterns" to convert .NET APIs into more friendly code.
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can dynamically create objects from an interface such as `IDisposable` without
    creating a concrete class.
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mix and match "pure" F# objects with existing .NET APIs
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TryParse and TryGetValue
  id: totrans-1108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TryParse` and `TryGetValue` functions for values and dictionaries are frequently
    used to avoid extra exception handling. But the C# syntax is a bit clunky. Using
    them from F# is more elegant because F# will automatically convert the function
    into a tuple where the first element is the function return value and the second
    is the "out" parameter.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Named arguments to help type inference
  id: totrans-1111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C# (and .NET in general), you can have overloaded methods with many different
    parameters. F# can have trouble with this. For example, here is an attempt to
    create a `StreamReader`:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The problem is that F# does not know if the argument is supposed to be a string
    or a stream. You could explicitly specify the type of the argument, but that is
    not the F# way!
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: Instead, a nice workaround is enabled by the fact that in F#, when calling methods
    in .NET libraries, you can specify named arguments.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: In many cases, such as the one above, just using the argument name is enough
    to resolve the type issue. And using explicit argument names can often help to
    make the code more legible anyway.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: Active patterns for .NET functions
  id: totrans-1118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many situations where you want to use pattern matching against .NET
    types, but the native libraries do not support this. Earlier, we briefly touched
    on the F# feature called "active patterns" which allows you to dynamically create
    choices to match on. This can be very for useful .NET integration.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: A common case is that a .NET library class has a number of mutually exclusive
    `isSomething`, `isSomethingElse` methods, which have to be tested with horrible
    looking cascading if-else statements. Active patterns can hide all the ugly testing,
    letting the rest of your code use a more natural approach.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: For example, here's the code to test for various `isXXX` methods for `System.Char`.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Once the choices are defined, the normal code can be straightforward:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Another common case is when you have to parse text or error codes to determine
    the type of an exception or result. Here's an example that uses an active pattern
    to parse the error number associated with `SqlExceptions`, making them more palatable.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set up the active pattern matching on the error number:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Now we can use these patterns when processing SQL commands:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Creating objects directly from an interface
  id: totrans-1130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# has another useful feature called "object expressions". This is the ability
    to directly create objects from an interface or abstract class without having
    to define a concrete class first.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, we create some objects that implement `IDisposable` using
    a `makeResource` helper function.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The example also demonstrates how the "`use`" keyword automatically disposes
    a resource when it goes out of scope. Here is the output:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Mixing .NET interfaces with pure F# types
  id: totrans-1136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to create instances of an interface on the fly means that it is
    easy to mix and match interfaces from existing APIs with pure F# types.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: For example, say that you have a preexisting API which uses the `IAnimal` interface,
    as shown below.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: But we want to have all the benefits of pattern matching, etc, so we have created
    pure F# types for cats and dogs instead of classes.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: But using this pure F# approach means that that we cannot pass the cats and
    dogs to the `showTheNoiseAnAnimalMakes` function directly.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: However, we don't have to create new sets of concrete classes just to implement
    `IAnimal`. Instead, we can dynamically create the `IAnimal` interface by extending
    the pure F# types.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Here is some test code:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: This approach gives us the best of both worlds. Pure F# types internally, but
    the ability to convert them into interfaces as needed to interface with libraries.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: Using reflection to examine F# types
  id: totrans-1148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# gets the benefit of the .NET reflection system, which means that you can
    do all sorts of interesting things that are not directly available to you using
    the syntax of the language itself. The `Microsoft.FSharp.Reflection` namespace
    has a number of functions that are designed to help specifically with F# types.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is a way to print out the fields in a record type, and the
    choices in a union type.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Anything C# can do...
  id: totrans-1152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anything C# can do...
  id: totrans-1153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As should be apparent, you should generally try to prefer functional-style code
    over object-oriented code in F#, but in some situations, you may need all the
    features of a fully fledged OO language ? classes, inheritance, virtual methods,
    etc.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: So just to conclude this section, here is a whirlwind tour of the F# versions
    of these features.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: Some of these will be dealt with in much more depth in a later series on .NET
    integration. But I won't cover some of the more obscure ones, as you can read
    about them in the MSDN documentation if you ever need them.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: Classes and interfaces
  id: totrans-1157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, here are some examples of an interface, an abstract class, and a concrete
    class that inherits from the abstract class.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Classes can have multiple constructors, mutable properties, and so on.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Generics
  id: totrans-1162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# supports generics and all the associated constraints.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Structs
  id: totrans-1165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# supports not just classes, but the .NET struct types as well, which can help
    to boost performance in certain cases.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Exceptions
  id: totrans-1168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# can create exception classes, raise them and catch them.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Extension methods
  id: totrans-1171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as in C#, F# can extend existing classes with extension methods.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Parameter arrays
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like C#'s variable length "params" keyword, this allows a variable length
    list of arguments to be converted to a single array parameter.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Events
  id: totrans-1177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# classes can have events, and the events can be triggered and responded to.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Delegates
  id: totrans-1180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# can do delegates.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Enums
  id: totrans-1183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# supports CLI enums types, which look similar to the "union" types, but are
    actually different behind the scenes.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Working with the standard user interface
  id: totrans-1186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, F# can work with the WinForms and WPF user interface libraries, just
    like C#.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: Here is a trivial example of opening a form and handling a click event.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Why use F#: Conclusion'
  id: totrans-1190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why use F#: Conclusion'
  id: totrans-1191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This completes the tour of F# features. I hope that the examples have given
    you some appreciation of the power of F# and functional programming. If you have
    any comments on the series as a whole, please leave them at the bottom of this
    page.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: In later series I hope to go deeper into data structures, pattern matching,
    list processing, asynchronous and parallel programming, and much more.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: But before those, I recommend you read the ["thinking functionally"](thinking-functionally.html)
    series, which will help you understand functional programming at a deeper level.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
