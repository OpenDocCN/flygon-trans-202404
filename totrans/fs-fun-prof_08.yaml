- en: The "Why use F#?" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This series of posts will give you a guided tour through the main features of
    F# and then show you ways that F# can help you in your day-to-day development.
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction to the ''Why use F#'' series](why-use-fsharp-intro.html). An
    overview of the benefits of F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F# syntax in 60 seconds](fsharp-in-60-seconds.html). A very quick overview
    on how to read F# code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comparing F# with C#: A simple sum](fvsc-sum-of-squares.html). In which we
    attempt to sum the squares from 1 to N without using a loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comparing F# with C#: Sorting](fvsc-quicksort.html). In which we see that
    F# is more declarative than C#, and we are introduced to pattern matching..'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comparing F# with C#: Downloading a web page](fvsc-download.html). In which
    we see that F# excels at callbacks, and we are introduced to the ''use'' keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Four Key Concepts](key-concepts.html). The concepts that differentiate F#
    from a standard imperative language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conciseness](conciseness-intro.html). Why is conciseness important?.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type inference](conciseness-type-inference.html). How to avoid getting distracted
    by complex type syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Low overhead type definitions](conciseness-type-definitions.html). No penalty
    for making new types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions to extract boilerplate code](conciseness-extracting-boilerplate.html).
    The functional approach to the DRY principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as building blocks](conciseness-functions-as-building-blocks.html).
    Function composition and mini-languages make code more readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pattern matching for conciseness](conciseness-pattern-matching.html). Pattern
    matching can match and bind in a single step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Convenience](convenience-intro.html). Features that reduce programming drudgery
    and boilerplate code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Out-of-the-box behavior for types](convenience-types.html). Immutability and
    built-in equality with no coding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functions as interfaces](convenience-functions-as-interfaces.html). OO design
    patterns can be trivial when functions are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partial Application](convenience-partial-application.html). How to fix some
    of a function''s parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Active patterns](convenience-active-patterns.html). Dynamic patterns for powerful
    matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Correctness](correctness-intro.html). How to write ''compile time unit tests''.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Immutability](correctness-immutability.html). Making your code predictable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exhaustive pattern matching](correctness-exhaustive-pattern-matching.html).
    A powerful technique to ensure correctness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the type system to ensure correct code](correctness-type-checking.html).
    In F# the type system is your friend, not your enemy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Worked example: Designing for correctness](designing-for-correctness.html).
    How to make illegal states unrepresentable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Concurrency](concurrency-intro.html). The next major revolution in how we
    write software?.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Asynchronous programming](concurrency-async-and-parallel.html). Encapsulating
    a background task with the Async class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Messages and Agents](concurrency-actor-model.html). Making it easier to think
    about concurrency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functional Reactive Programming](concurrency-reactive.html). Turning events
    into streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Completeness](completeness-intro.html). F# is part of the whole .NET ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Seamless interoperation with .NET libraries](completeness-seamless-dotnet-interop.html).
    Some convenient features for working with .NET libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Anything C# can do...](completeness-anything-csharp-can-do.html). A whirlwind
    tour of object-oriented code in F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why use F#: Conclusion](why-use-fsharp-conclusion.html). .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the 'Why use F#' series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to the 'Why use F#' series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This series of posts will give you a guided tour through the main features of
    F# and then show you ways that F# can help you in your day-to-day development.
  prefs: []
  type: TYPE_NORMAL
- en: Key benefits of F# compared with C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are already familiar with C# or Java, you might be wondering why it
    would be worth learning yet another language. F# has some major benefits which
    I have grouped under the following themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conciseness**. F# is not cluttered up with coding "noise" such as curly brackets,
    semicolons and so on. You almost never have to specify the type of an object,
    thanks to a powerful type inference system. And it generally takes less lines
    of code to solve the same problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convenience**. Many common programming tasks are much simpler in F#. This
    includes things like creating and using complex type definitions, doing list processing,
    comparison and equality, state machines, and much more. And because functions
    are first class objects, it is very easy to create powerful and reusable code
    by creating functions that have other functions as parameters, or that combine
    existing functions to create new functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Correctness**. F# has a very powerful type system which prevents many common
    errors such as null reference exceptions. And in addition, you can often encode
    business logic using the type system itself, so that it is actually impossible
    to write incorrect code, because it is caught at compile time as a type error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**. F# has a number of built-in tools and libraries to help with
    programming systems when more than one thing at a time is happening. Asynchronous
    programming is directly supported, as is parallelism. F# also has a message queuing
    system, and excellent support for event handling and reactive programming. And
    because data structures are immutable by default, sharing state and avoiding locks
    is much easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Completeness**. Although F# is a functional language at heart, it does support
    other styles which are not 100% pure, which makes it much easier to interact with
    the non-pure world of web sites, databases, other applications, and so on. In
    particular, F# is designed as a hybrid functional/OO language, so it can do almost
    everything that C# can do as well. Of course, F# integrates seamlessly with the
    .NET ecosystem, which gives you access to all the third party .NET libraries and
    tools. Finally, it is part of Visual Studio, which means you get a good editor
    with IntelliSense support, a debugger, and many plug-ins for unit tests, source
    control, and other development tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rest of this series of posts, I will try to demonstrate each of these
    F# benefits, using standalone snippets of F# code (and often with C# code for
    comparison). I'll briefly cover all the major features of F#, including pattern
    matching, function composition, and concurrent programming. By the time you have
    finished this series, I hope that you will have been impressed with the power
    and elegance of F#, and you will be encouraged to use it for your next project!
  prefs: []
  type: TYPE_NORMAL
- en: How to read and use the example code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the code snippets in these posts have been designed to be run interactively.
    I strongly recommend that you evaluate the snippets as you read each post. The
    source for any large code files will be linked to from the post.
  prefs: []
  type: TYPE_NORMAL
- en: This series is not a tutorial, so I will not go too much into *why* the code
    works. Don't worry if you cannot understand some of the details; the goal of the
    series is just to introduce you to F# and whet your appetitite for learning it
    more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience in languages such as C# and Java, you have probably found
    that you can get a pretty good understanding of source code written in other similar
    languages, even if you aren't familiar with the keywords or the libraries. You
    might ask "how do I assign a variable?" or "how do I do a loop?", and with these
    answers be able to do some basic programming quite quickly.
  prefs: []
  type: TYPE_NORMAL
- en: This approach will not work for F#, because in its pure form there are no variables,
    no loops, and no objects. Don't be frustrated - it will eventually make sense!
    If you want to learn F# in more depth, there are some helpful tips on the ["learning
    F#"](index4.html) page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing F# with C#: A simple sum'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing F# with C#: A simple sum'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see what some real F# code looks like, let''s start with a simple problem:
    "sum the squares from 1 to N".'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll compare an F# implementation with a C# implementation. First, the F#
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The mysterious looking `|>` is called the pipe operator. It just pipes the
    output of one expression into the input of the next. So the code for `sumOfSquares`
    reads as:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a list of 1 to n (square brackets construct a list).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pipe the list into the library function called `List.map`, transforming the
    input list into an output list using the "square" function we just defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pipe the resulting list of squares into the library function called `List.sum`.
    Can you guess what it does?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no explicit "return" statement. The output of `List.sum` is the overall
    result of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, here's a C# implementation using the classic (non-functional) style of
    a C-based language. (A more functional version using LINQ is discussed later.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What are the differences?
  prefs: []
  type: TYPE_NORMAL
- en: The F# code is more compact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The F# code didn't have any type declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# can be developed interactively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Less code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most obvious difference is that there is a lot more C# code. 13 C# lines
    compared with 3 F# lines (ignoring comments). The C# code has lots of "noise",
    things like curly braces, semicolons, etc. And in C# the functions cannot stand
    alone, but need to be added to some class ("SumOfSquaresHelper"). F# uses whitespace
    instead of parentheses, needs no line terminator, and the functions can stand
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: In F# it is common for entire functions to be written on one line, as the "square"
    function is. The `sumOfSquares` function could also have been written on one line.
    In C# this is normally frowned upon as bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function does have multiple lines, F# uses indentation to indicate a
    block of code, which eliminates the need for braces. (If you have ever used Python,
    this is the same idea). So the `sumOfSquares` function could also have been written
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The only drawback is that you have to indent your code carefully. Personally,
    I think it is worth the trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: No type declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next difference is that the C# code has to explicitly declare all the types
    used. For example, the `int i` parameter and `int SumOfSquares` return type. Yes,
    C# does allow you to use the "var" keyword in many places, but not for parameters
    and return types of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the F# code we didn''t declare any types at all. This is an important point:
    F# looks like an untyped language, but it is actually just as type-safe as C#,
    in fact, even more so! F# uses a technique called "type inference" to infer the
    types you are using from their context. It works amazingly very well most of the
    time, and reduces the code complexity immensely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the type inference algorithm notes that we started with a list
    of integers. That in turn implies that the square function and the sum function
    must be taking ints as well, and that the final value must be an int. You can
    see what the inferred types are by looking at the result of the compilation in
    the interactive window. You''ll see something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: which means that the "square" function takes an int and returns an int.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the original list had used floats instead, the type inference system would
    have deduced that the square function used floats instead. Try it and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The type checking is very strict! If you try using a list of floats (`[1.0..n]`)
    in the original `sumOfSquares` example, or a list of ints (`[1 ..n]`) in the `sumOfSquaresF`
    example, you will get a type error from the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, F# has an interactive window where you can test the code immediately
    and play around with it. In C# there is no easy way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I can write my square function and immediately test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When I am satisfied that it works, I can move on to the next bit of code.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of interactivity encourages an incremental approach to coding that
    can become addictive!
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, many people claim that designing code interactively enforces good
    design practices such as decoupling and explicit dependencies, and therefore,
    code that is suitable for interactive evaluation will also be code that is easy
    to test. Conversely, code that cannot be tested interactively will probably be
    hard to test as well.
  prefs: []
  type: TYPE_NORMAL
- en: The C# code revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My original example was written using "old-style" C#. C# has incorporated a
    lot of functional features, and it is possible to rewrite the example in a more
    compact way using the LINQ extensions.
  prefs: []
  type: TYPE_NORMAL
- en: So here is another C# version -- a line-for-line translation of the F# code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, in addition to the noise of the curly braces and periods and semicolons,
    the C# version needs to declare the parameter and return types, unlike the F#
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Many C# developers may find this a trivial example, but still resort back to
    loops when the logic becomes more complicated. In F# though, you will almost never
    see explicit loops like this. See for example, [this post on eliminating boilerplate
    from more complicated loops](http://fsharpforfunandprofit.com/posts/conciseness-extracting-boilerplate/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing F# with C#: Sorting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing F# with C#: Sorting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this next example, we will implement a quicksort-like algorithm for sorting
    lists and compare an F# implementation to a C# implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the logic for a simplified quicksort-like algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is a simplified algorithm and is not optimized (and it does not
    sort in place, like a true quicksort); we want to focus on clarity for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again note that this is not an optimized implementation, but is designed to
    mirror the algorithm closely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through this code:'
  prefs: []
  type: TYPE_NORMAL
- en: There are no type declarations anywhere. This function will work on any list
    that has comparable items (which is almost all F# types, because they automatically
    have a default comparison function).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole function is recursive -- this is signaled to the compiler using the
    `rec` keyword in "`let rec quicksort list =`".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `match..with` is sort of like a switch/case statement. Each branch to test
    is signaled with a vertical bar, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The "`match`" with `[]` matches an empty list, and returns an empty list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "`match`" with `firstElem::otherElements` does two things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, it only matches a non-empty list.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, it creates two new values automatically. One for the first element called
    "`firstElem`", and one for the rest of the list, called "`otherElements`". In
    C# terms, this is like having a "switch" statement that not only branches, but
    does variable declaration and assignment *at the same time*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `->` is sort of like a lambda (`=>`) in C#. The equivalent C# lambda would
    look something like `(firstElem, otherElements) => do something`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "`smallerElements`" section takes the rest of the list, filters it against
    the first element using an inline lambda expression with the "`<`" operator and
    then pipes the result into the quicksort function recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "`largerElements`" line does the same thing, except using the "`>=`" operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally the resulting list is constructed using the list concatenation function
    "`List.concat`". For this to work, the first element needs to be put into a list,
    which is what the square brackets are for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again note there is no "return" keyword; the last value will be returned. In
    the "`[]`" branch the return value is the empty list, and in the main branch,
    it is the newly constructed list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For comparison here is an old-style C# implementation (without using LINQ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Comparing the two sets of code, again we can see that the F# code is much more
    compact, with less noise and no need for type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the F# code reads almost exactly like the actual algorithm, unlike
    the C# code. This is another key advantage of F# -- the code is generally more
    declarative ("what to do") and less imperative ("how to do it") than C#, and is
    therefore much more self-documenting.
  prefs: []
  type: TYPE_NORMAL
- en: A functional implementation in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a more modern "functional-style" implementation using LINQ and an extension
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is much cleaner, and reads almost the same as the F# version. But unfortunately
    there is no way of avoiding the extra noise in the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: Correctness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, a beneficial side-effect of this compactness is that F# code often
    works the first time, while the C# code may require more debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, when coding these samples, the old-style C# code was incorrect initially,
    and required some debugging to get it right. Particularly tricky areas were the
    `for` loop (starting at 1 not zero) and the `CompareTo` comparison (which I got
    the wrong way round), and it would also be very easy to accidentally modify the
    inbound list. The functional style in the second C# example is not only cleaner
    but was easier to code correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'But even the functional C# version has drawbacks compared to the F# version.
    For example, because F# uses pattern matching, it is not possible to branch to
    the "non-empty list" case with an empty list. On the other hand, in the C# code,
    if we forgot the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'then the extraction of the first element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'would fail with an exception. The compiler cannot enforce this for you. In
    your own code, how often have you used `FirstOrDefault` rather than `First` because
    you are writing "defensive" code. Here is an example of a code pattern that is
    very common in C# but is rare in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The one-step "pattern match and branch" in F# allows you to avoid this in many
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Postscript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example implementation in F# above is actually pretty verbose by F# standards!
  prefs: []
  type: TYPE_NORMAL
- en: 'For fun, here is what a more typically concise version would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Not bad for 4 lines of code, and when you get used to the syntax, still quite
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing F# with C#: Downloading a web page'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing F# with C#: Downloading a web page'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will compare the F# and C# code for downloading a web page,
    with a callback to process the text stream.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a straightforward F# implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of "open" at the top allows us to write "WebRequest" rather than "System.Net.WebRequest".
    It is similar to a "`using System.Net`" header in C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we define the `fetchUrl` function, which takes two arguments, a callback
    to process the stream, and the url to fetch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We next wrap the url string in a Uri. F# has strict type-checking, so if instead
    we had written: `let req = WebRequest.Create(url)` the compiler would have complained
    that it didn''t know which version of `WebRequest.Create` to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When declaring the `response`, `stream` and `reader` values, the "`use`" keyword
    is used instead of "`let`". This can only be used in conjunction with classes
    that implement `IDisposable`. It tells the compiler to automatically dispose of
    the resource when it goes out of scope. This is equivalent to the C# "`using`"
    keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line calls the callback function with the StreamReader and url as parameters.
    Note that the type of the callback does not have to be specified anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now here is the equivalent C# implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the C# version has more 'noise'.
  prefs: []
  type: TYPE_NORMAL
- en: There are ten lines just for curly braces, and there is the visual complexity
    of 5 levels of nesting*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the parameter types have to be explicitly declared, and the generic `TResult`
    type has to be repeated three times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[* It''s true that in this particular example, when all the `using` statements
    are adjacent, the [extra braces and indenting can be removed](https://stackoverflow.com/questions/1329739/nested-using-statements-in-c-sharp),
    but in the more general case they are needed.]'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in F# land, we can now test the code interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have to resort to a type declaration for the reader parameter (`reader:IO.StreamReader`).
    This is required because the F# compiler cannot determine the type of the "reader"
    parameter automatically.
  prefs: []
  type: TYPE_NORMAL
- en: A very useful feature of F# is that you can "bake in" parameters in a function
    so that they don't have to be passed in every time. This is why the `url` parameter
    was placed *last* rather than first, as in the C# version. The callback can be
    setup once, while the url varies from call to call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The last line (using `List.map`) shows how the new function can be easily used
    in conjunction with list processing functions to download a whole list at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the equivalent C# test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Again, the code is a bit noisier than the F# code, with many explicit type references.
    More importantly, the C# code doesn't easily allow you to bake in some of the
    parameters in a function, so the callback must be explicitly referenced every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Four Key Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Four Key Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next few posts we''ll move on to demonstrating the themes of this series:
    conciseness, convenience, correctness, concurrency and completeness.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But before that, let''s look at some of the key concepts in F# that we will
    meet over and over again. F# is different in many ways from a standard imperative
    language like C#, but there are a few major differences that are particularly
    important to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function-oriented** rather than object-oriented'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expressions** rather than statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algebraic types** for creating domain models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pattern matching** for flow of control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In later posts, these will be dealt with in much greater depth -- this is just
    a taster to help you understand the rest of this series.
  prefs: []
  type: TYPE_NORMAL
- en: '![four key concepts](four-concepts2.png)'
  prefs: []
  type: TYPE_IMG
- en: Function-oriented rather than object-oriented
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might expect from the term "functional programming", functions are everywhere
    in F#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, functions are first class entities, and can be passed around like
    any other value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But C# has first-class functions too, so what's so special about functional
    programming?
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is that the function-oriented nature of F# infiltrates every
    part of the language and type system in a way that it does not in C#, so that
    things that are awkward or clumsy in C# are very elegant in F#.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s hard to explain this in a few paragraphs, but here are some of the benefits
    that we will see demonstrated over this series of posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building with composition**. Composition is the ''glue'' that allows us build
    larger systems from smaller ones. This is not an optional technique, but is at
    the very heart of the functional style. Almost every line of code is a composable
    expression (see below). Composition is used to build basic functions, and then
    functions that use those functions, and so on. And the composition principle doesn''t
    just apply to functions, but also to types (the product and sum types discussed
    below).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factoring and refactoring**. The ability to factor a problem into parts depends
    how easily the parts can be glued back together. Methods and classes that might
    seem to be indivisible in an imperative language can often be broken down into
    surprisingly small pieces in a functional design. These fine-grained components
    typically consist of (a) a few very general functions that take other functions
    as parameters, and (b) other helper functions that specialize the general case
    for a particular data structure or application. Once factored out, the generalized
    functions allow many additional operations to be programmed very easily without
    having to write new code. You can see a good example of a general function like
    this (the fold function) in the [post on extracting duplicate code from loops](conciseness-extracting-boilerplate.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good design**. Many of the principles of good design, such as "separation
    of concerns", "single responsibility principle", ["program to an interface, not
    an implementation"](convenience-functions-as-interfaces.html), arise naturally
    as a result of a functional approach. And functional code tends to be high level
    and declarative in general.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following posts in this series will have examples of how functions can make
    code more concise and convenient, and then for a deeper understanding, there is
    a whole series on [thinking functionally](thinking-functionally.html).
  prefs: []
  type: TYPE_NORMAL
- en: Expressions rather than statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In functional languages, there are no statements, only expressions. That is,
    every chunk of code always returns a value, and larger chunks are created by combining
    smaller chunks using composition rather than a serialized list of statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you have used LINQ or SQL you will already be familiar with expression-based
    languages. For example, in pure SQL, you cannot have assignments. Instead, you
    must have subqueries within larger queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: F# works in the same way -- every function definition is a single expression,
    not a set of statements.
  prefs: []
  type: TYPE_NORMAL
- en: And it might not be obvious, but code built from expressions is both safer and
    more compact than using statements. To see this, let's compare some statement-based
    code in C# with the equivalent expression-based code.
  prefs: []
  type: TYPE_NORMAL
- en: First, the statement-based code. Statements don't return values, so you have
    to use temporary variables that are assigned to from within statement bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `if-then` block is a statement, the `result` variable must be defined
    *outside* the statement but assigned to from *inside* the statement, which leads
    to issues such as:'
  prefs: []
  type: TYPE_NORMAL
- en: What initial value should `result` be set to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if I forget to assign to the `result` variable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the value of the `result` variable in the "else" case?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For comparison, here is the same code, rewritten in an expression-oriented
    style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the expression-oriented version, none of these issues apply:'
  prefs: []
  type: TYPE_NORMAL
- en: The `result` variable is declared at the same time that it is assigned. No variables
    have to be set up "outside" the expression and there is no worry about what initial
    value they should be set to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "else" is explicitly handled. There is no chance of forgetting to do an
    assignment in one of the branches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to forget to assign `result`, because then the variable would
    not even exist!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression-oriented style is not a choice in F#, and it is one of the things
    that requires a change of approach when coming from an imperative background.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The type system in F# is based on the concept of **algebraic types**. That
    is, new compound types are built by combining existing types in two different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a combination of values, each picked from a set of types. These are called
    "product" types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of, alternately, as a disjoint union representing a choice between a set of
    types. These are called "sum" types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, given existing types `int` and `bool`, we can create a new product
    type that must have one of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can create a new union/sum type that has a choice between
    each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These "choice" types are not available in C#, but are incredibly useful for
    modeling many real-world cases, such as states in a state machine (which is a
    surprisingly common theme in many domains).
  prefs: []
  type: TYPE_NORMAL
- en: And by combining "product" and "sum" types in this way, it is easy to create
    a rich set of types that accurately models any business domain. For examples of
    this in action, see the posts on [low overhead type definitions](conciseness-type-definitions.html)
    and [using the type system to ensure correct code](correctness-type-checking).
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for flow of control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most imperative languages offer a variety of control flow statements for branching
    and looping:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if-then-else` (and the ternary version `bool ? if-true : if-false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case` or `switch` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` and `foreach` loops, with `break` and `continue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while` and `until` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and even the dreaded `goto`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# does support some of these, but F# also supports the most general form of
    conditional expression, which is **pattern-matching**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical matching expression that replaces `if-then-else` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And the replacement of `switch` might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, loops are generally done using recursion, and typically look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Although the match expression seems unnecessarily complicated at first, you'll
    see that in practice it is both elegant and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: For the benefits of pattern matching, see the post on [exhaustive pattern matching](correctness-exhaustive-pattern-matching),
    and for a worked example that uses pattern matching heavily, see the [roman numerals
    example](roman-numerals.html).
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with union types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We mentioned above that F# supports a "union" or "choice" type. This is used
    instead of inheritance to work with different variants of an underlying type.
    Pattern matching works seamlessly with these types to create a flow of control
    for each choice.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we create a `Shape` type representing four different
    shapes and then define a `draw` function with different behavior for each kind
    of shape. This is similar to polymorphism in an object oriented language, but
    based on functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we didn't have to specify any types. The compiler correctly determined
    that the shape parameter for the "draw" function was of type `Shape`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see that the `match..with` logic not only matches against the internal
    structure of the shape, but also assigns values based on what is appropriate for
    the shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The underscore is similar to the "default" branch in a switch statement, except
    that in F# it is required -- every possible case must always be handled. If you
    comment out the line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: see what happens when you compile!
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of choice types can be simulated somewhat in C# by using subclasses
    or interfaces, but there is no built in support in the C# type system for this
    kind of exhaustive matching with error checking.
  prefs: []
  type: TYPE_NORMAL
- en: Conciseness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conciseness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having seen some simple code, we will now move on to demonstrating the
    major themes (conciseness, convenience, correctness, concurrency and completeness),
    filtered through the concepts of types, functions and pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: With the next few posts, we'll examine the features of F# that aid conciseness
    and readability.
  prefs: []
  type: TYPE_NORMAL
- en: An important goal for most mainstream programming languages is a good balance
    of readability and conciseness. Too much conciseness can result in hard-to-understand
    or obfuscated code (APL anyone?), while too much verbosity can easily swamp the
    underlying meaning. Ideally, we want a high signal-to-noise ratio, where every
    word and character in the code contributes to the meaning of the code, and there
    is minimal boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is conciseness important? Here are a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A concise language tends to be more declarative**, saying *what* the code
    should do rather than *how* to do it. That is, declarative code is more focused
    on the high-level logic rather than the nuts and bolts of the implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is easier to reason about correctness** if there are fewer lines of code
    to reason about!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And of course, **you can see more code on a screen** at a time. This might seem
    trivial, but the more you can see, the more you can grasp as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you have seen, compared with C#, F# is generally much more concise. This
    is due to features such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type inference** and **low overhead type definitions**. One of the major
    reasons for F#''s conciseness and readability is its type system. F# makes it
    very easy to create new types as you need them. They don''t cause visual clutter
    either in their definition or in use, and the type inference system means that
    you can use them freely without getting distracted by complex type syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using functions to extract boilerplate code**. The DRY principle ("don''t
    repeat yourself") is a core principle of good design in functional languages as
    well as object-oriented languages. In F# it is extremely easy to extract repetitive
    code into common utility functions, which allows you to focus on the important
    stuff.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composing complex code from simple functions** and **creating mini-languages**.
    The functional approach makes it easy to create a set of basic operations and
    then combine these building blocks in various ways to build up more complex behaviors.
    In this way, even the most complex code is still very concise and readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pattern matching**. We''ve seen pattern matching as a glorified switch statement,
    but in fact it is much more general, as it can compare expressions in a number
    of ways, matching on values, conditions, and types, and then assign or extract
    values, all at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have already seen, F# uses a technique called "type inference" to greatly
    reduce the number of type annotations that need to be explicitly specified in
    normal code. And even when types do need to be specified, the syntax is less longwinded
    compared to C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this, here are some C# methods that wrap two standard LINQ functions.
    The implementations are trivial, but the method signatures are extremely complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And here are the exact F# equivalents, showing that no type annotations are
    needed at all!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You might notice that the standard F# implementations for "filter" and "groupBy"
    have the parameters in exactly the opposite order from the LINQ implementations
    used in C#. The "source" parameter is placed last, rather than first. There is
    a reason for this, which will be explained in the [thinking functionally](thinking-functionally.html)
    series.
  prefs: []
  type: TYPE_NORMAL
- en: The type inference algorithm is excellent at gathering information from many
    sources to determine the types. In the following example, it correctly deduces
    that the `list` value is a list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And in this example, it correctly deduces that the `sumLengths` function takes
    a list of strings and returns an int.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Low overhead type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Low overhead type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, there is a disincentive for creating new types ? the lack of type inference
    means you need to explicitly specify types in most places, resulting in brittleness
    and more visual clutter. As a result, there is always a temptation to create monolithic
    classes rather than modularizing them.
  prefs: []
  type: TYPE_NORMAL
- en: In F# there is no penalty for making new types, so it is quite common to have
    hundreds if not thousands of them. Every time you need to define a structure,
    you can create a special type, rather than reusing (and overloading) existing
    types such as strings and lists.
  prefs: []
  type: TYPE_NORMAL
- en: This means that your programs will be more type-safe, more self documenting,
    and more maintainable (because when the types change you will immediately get
    compile-time errors rather than runtime errors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of one-liner types in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: F# types and domain driven design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The conciseness of the type system in F# is particularly useful when doing domain
    driven design (DDD). In DDD, for each real world entity and value object, you
    ideally want to have a corresponding type. This can mean creating hundreds of
    "little" types, which can be tedious in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, "value" objects in DDD should have structural equality, meaning
    that two objects containing the same data should always be equal. In C# this can
    mean more tedium in overriding `IEquatable<T>`, but in F#, you get this for free
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: To show how easy it is to create DDD types in F#, here are some example types
    that might be created for a simple "customer" domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code fragment contains 17 type definitions in just a few lines, but with
    minimal complexity. How many lines of C# code would you need to do the same thing?
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is a simplified version with just the basic types ? in a real
    system, constraints and other methods would be added. But note how easy it is
    to create lots of DDD value objects, especially wrapper types for strings, such
    as "`ZipCode`" and "`Email`". By using these wrapper types, we can enforce certain
    constraints at creation time, and also ensure that these types don't get confused
    with unconstrained strings in normal code. The only "entity" type is the `CustomerAccount`,
    which is clearly indicated as having special treatment for equality and comparison.
  prefs: []
  type: TYPE_NORMAL
- en: For a more in-depth discussion, see the series called ["Domain driven design
    in F#"](domain-driven-design-in-fsharp.md).
  prefs: []
  type: TYPE_NORMAL
- en: Using functions to extract boilerplate code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using functions to extract boilerplate code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the very first example in this series, we saw a simple function that calculated
    the sum of squares, implemented in both F# and C#. Now let''s say we want some
    new functions which are similar, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the product of all the numbers up to N
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting the sum of odd numbers up to N
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alternating sum of the numbers up to N
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, all these requirements are similar, but how would you extract any
    common functionality?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some straightforward implementations in C# first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What do all these implementations have in common? The looping logic! As programmers,
    we are told to remember the DRY principle ("don''t repeat yourself"), yet here
    we have repeated almost exactly the same loop logic each time. Let''s see if we
    can extract just the differences between these three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Initial value | Inner loop logic |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Product | product=1 | Multiply the i''th value with the running total |'
  prefs: []
  type: TYPE_TB
- en: '| SumOfOdds | sum=0 | Add the i''th value to the running total if not even
    |'
  prefs: []
  type: TYPE_TB
- en: '| AlternatingSum | int sum = 0 bool isNeg = true | Use the isNeg flag to decide
    whether to add or subtract, and flip the flag for the next pass. |'
  prefs: []
  type: TYPE_TB
- en: 'Is there a way to strip the duplicate code and focus on the just the setup
    and inner loop logic? Yes there is. Here are the same three functions in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'All three of these functions have the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the initial value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up an action function that will be performed on each element inside the
    loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the library function `List.fold`. This is a powerful, general purpose function
    which starts with the initial value and then runs the action function for each
    element in the list in turn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The action function always has two parameters: a running total (or state) and
    the list element to act on (called "x" in the above examples).'
  prefs: []
  type: TYPE_NORMAL
- en: In the last function, `alternatingSum`, you will notice that it used a tuple
    (pair of values) for the initial value and the result of the action. This is because
    both the running total and the `isNeg` flag must be passed to the next iteration
    of the loop -- there are no "global" values that can be used. The final result
    of the fold is also a tuple so we have to use the "snd" (second) function to extract
    the final total that we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `List.fold` and avoiding any loop logic at all, the F# code gains
    a number of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The key program logic is emphasized and made explicit**. The important differences
    between the functions become very clear, while the commonalities are pushed to
    the background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The boilerplate loop code has been eliminated**, and as a result the code
    is more condensed than the C# version (4-5 lines of F# code vs. at least 9 lines
    of C# code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There can never be a error in the loop logic** (such as off-by-one) because
    that logic is not exposed to us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the way, the sum of squares example could also be written using `fold` as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '"Fold" in C#'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Can you use the "fold" approach in C#? Yes. LINQ does have an equivalent to
    `fold`, called `Aggregate`. And here is the C# code rewritten to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Well, in some sense these implementations are simpler and safer than the original
    C# versions, but all the extra noise from the generic types makes this approach
    much less elegant than the equivalent code in F#. You can see why most C# programmers
    prefer to stick with explicit loops.
  prefs: []
  type: TYPE_NORMAL
- en: A more relevant example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A slightly more relevant example that crops up frequently in the real world
    is how to get the "maximum" element of a list when the elements are classes or
    structs. The LINQ method 'max' only returns the maximum value, not the whole element
    that contains the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a solution using an explicit loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Doing this in LINQ seems hard to do efficiently (that is, in one pass), and
    has come up as a [Stack Overflow question](http://stackoverflow.com/questions/1101841/linq-how-to-perform-max-on-a-property-of-all-objects-in-a-collection-and-ret).
    Jon Skeet event wrote an [article about it](http://codeblog.jonskeet.uk/2005/10/02/a-short-case-study-in-linq-efficiency/).
  prefs: []
  type: TYPE_NORMAL
- en: Again, fold to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s the C# code using `Aggregate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that this C# version returns null for an empty list. That seems dangerous
    -- so what should happen instead? Throwing an exception? That doesn't seem right
    either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the F# code using fold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The F# code has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: the `innerMaxNameAndSize` function is similar to what we have seen before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the second bit, `match list with`, branches on whether the list is empty or
    not. With an empty list, it returns a `None`, and in the non-empty case, it returns
    a `Some`. Doing this guarantees that the caller of the function has to handle
    both cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Actually, I didn't need to write this at all, because F# already has a `maxBy`
    function!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: But as you can see, it doesn't handle empty lists well. Here's a version that
    wraps the `maxBy` safely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using functions as building blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using functions as building blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-known principle of good design is to create a set of basic operations
    and then combine these building blocks in various ways to build up more complex
    behaviors. In object-oriented languages, this goal gives rise to a number of implementation
    approaches such as "fluent interfaces", "strategy pattern", "decorator pattern",
    and so on. In F#, they are all done the same way, via function composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example using integers. Say that we have created
    some basic functions to do arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to create new functions that build on these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The "`>>`" operator is the composition operator. It means: do the first function,
    and then do the second.'
  prefs: []
  type: TYPE_NORMAL
- en: Note how concise this way of combining functions is. There are no parameters,
    types or other irrelevant noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be sure, the examples could also have been written less concisely and more
    explicitly as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'But this more explicit style is also a bit more cluttered:'
  prefs: []
  type: TYPE_NORMAL
- en: In the explicit style, the x parameter and the parentheses must be added, even
    though they don't add to the meaning of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And in the explicit style, the functions are written back-to-front from the
    order they are applied. In my example of `add2ThenMult3` I want to add 2 first,
    and then multiply. The `add2 >> mult3` syntax makes this visually clearer than
    `mult3(add2 x)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s test these compositions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Extending existing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now say that we want to decorate these existing functions with some logging
    behavior. We can compose these as well, to make a new function with the logging
    built in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Our new function, `mult3ThenSquareLogged`, has an ugly name, but it is easy
    to use and nicely hides the complexity of the functions that went into it. You
    can see that if you define your building block functions well, this composition
    of functions can be a powerful way to get new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, there's more! Functions are first class entities in F#, and can be
    acted on by any other F# code. Here is an example of using the composition operator
    to collapse a list of functions into a single operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Mini languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Domain-specific languages (DSLs) are well recognized as a technique to create
    more readable and concise code. The functional approach is very well suited for
    this.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to, you can go the route of having a full "external" DSL with its
    own lexer, parser, and so on, and there are various toolsets for F# that make
    this quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: But in many cases, it is easier to stay within the syntax of F#, and just design
    a set of "verbs" and "nouns" that encapsulate the behavior we want.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to create new types concisely and then match against them makes
    it very easy to set up fluent interfaces quickly. For example, here is a little
    function that calculates dates using a simple vocabulary. Note that two new enum-style
    types are defined just for this one function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The example above only has one "verb", using lots of types for the "nouns".
  prefs: []
  type: TYPE_NORMAL
- en: The following example demonstrates how you might build the functional equivalent
    of a fluent interface with many "verbs".
  prefs: []
  type: TYPE_NORMAL
- en: Say that we are creating a drawing program with various shapes. Each shape has
    a color, size, label and action to be performed when clicked, and we want a fluent
    interface to configure each shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of what a simple method chain for a fluent interface in
    C# might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now the concept of "fluent interfaces" and "method chaining" is really only
    relevant for object-oriented design. In a functional language like F#, the nearest
    equivalent would be the use of the pipeline operator to chain a set of functions
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the underlying Shape type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add some basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For "method chaining" to work, every function should return an object that can
    be used next in the chain. So you will see that the "`display`" function returns
    the shape, rather than nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create some helper functions which we expose as the "mini-language",
    and will be used as building blocks by the users of the language.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `appendClickAction` takes a function as a parameter and composes
    it with the existing click action. As you start getting deeper into the functional
    approach to reuse, you start seeing many more "higher order functions" like this,
    that is, functions that act on other functions. Combining functions like this
    is one of the keys to understanding the functional way of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Now as a user of this "mini-language", I can compose the base helper functions
    into more complex functions of my own, creating my own function library. (In C#
    this kind of thing might be done using extension methods.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: I can then combine these functions together to create objects with the desired
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the second case, I actually pass two functions to `appendClickAction`, but
    I compose them into one first. This kind of thing is trivial to do with a well
    structured functional library, but it is quite hard to do in C# without having
    lambdas within lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a more complex example. We will create a function "`showRainbow`" that,
    for each color in the rainbow, sets the color and displays the shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the functions are getting more complex, but the amount of code is
    still quite small. One reason for this is that the function parameters can often
    be ignored when doing function composition, which reduces visual clutter. For
    example, the "`showRainbow`" function does take a shape as a parameter, but it
    is not explicitly shown! This elision of parameters is called "point-free" style
    and will be discussed further in the ["thinking functionally"](thinking-functionally.html)
    series
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for conciseness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching for conciseness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have seen the pattern matching logic in the `match..with` expression,
    where it seems to be just a switch/case statement. But in fact pattern matching
    is much more general ? it can compare expressions in a number of ways, matching
    on values, conditions, and types, and then assign or extract values, all at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching will be discussed in depth in later posts, but to start with,
    here is a little taster of one way that it aids conciseness. We'll look at the
    way pattern matching is used for binding values to expressions (the functional
    equivalent of assigning to variables).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, we are binding to the internal members of tuples
    and lists directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can also bind values to the inside of complex structures such as records.
    In the following example, we will create an "`Address`" type, and then a "`Customer`"
    type which contains an address. Next, we will create a customer value, and then
    match various properties against it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the last example, note how we could reach right into the `Address` substructure
    and pull out the street as well as the customer name.
  prefs: []
  type: TYPE_NORMAL
- en: This ability to process a nested structure, extract only the fields you want,
    and assign them to values, all in a single step, is very useful. It removes quite
    a bit of coding drudgery, and is another factor in the conciseness of typical
    F# code.
  prefs: []
  type: TYPE_NORMAL
- en: Convenience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Convenience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next set of posts, we will explore a few more features of F# that I have
    grouped under the theme of "convenience". These features do not necessarily result
    in more concise code, but they do remove much of the drudgery and boilerplate
    code that would be needed in C#.
  prefs: []
  type: TYPE_NORMAL
- en: '**Useful "out-of-the-box" behavior for types**. Most types that you create
    will immediately have some useful behavior, such as immutability and built-in
    equality ? functionality that has to be explicitly coded for in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All functions are "interfaces"**, meaning that many of the roles that interfaces
    play in object-oriented design are implicit in the way that functions work. And
    similarly, many object-oriented design patterns are unnecessary or trivial within
    a functional paradigm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial application**. Complicated functions with many parameters can have
    some of the parameters fixed or "baked in" and yet leave other parameters open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active patterns**. Active patterns are a special kind of pattern where the
    pattern can be matched or detected dynamically, rather than statically. They are
    great for simplifying frequently used parsing and grouping behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-the-box behavior for types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out-of-the-box behavior for types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One nice thing about F# is that most types immediately have some useful "out-of-the-box"
    behavior such as immutability and built-in equality, functionality that often
    has to be explicitly coded for in C#.
  prefs: []
  type: TYPE_NORMAL
- en: By "most" F# types, I mean the core "structural" types such as tuples, records,
    unions, options, lists, etc. Classes and some other types have been added to help
    with .NET integration, but lose some of the power of the structural types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This built-in functionality for these core types includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pretty printing when debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these is addressed below.
  prefs: []
  type: TYPE_NORMAL
- en: F# types have built-in immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C# and Java, it is has become good practice to create immutable classes whenever
    possible. In F#, you get this for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an immutable type in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is how the same type is typically coded in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: That's 10 lines to do the same thing as 1 line of F#.
  prefs: []
  type: TYPE_NORMAL
- en: Most F# types have built-in pretty printing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In F#, you don't have to override `ToString()` for most types -- you get pretty
    printing for free!
  prefs: []
  type: TYPE_NORMAL
- en: 'You have probably already seen this when running the earlier examples. Here
    is another simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Most F# types have built-in structural equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, you often have to implement the `IEquatable` interface so that you can
    test for equality between objects. This is needed when using objects for Dictionary
    keys, for example.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, you get this for free with most F# types. For example, using the `PersonalName`
    type from above, we can compare two names straight away.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Most F# types are automatically comparable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, you often have to implement the `IComparable` interface so that you can
    sort objects.
  prefs: []
  type: TYPE_NORMAL
- en: Again, in F#, you get this for free with most F# types. For example, here is
    a simple definition of a deck of cards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write a function to test the comparison logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that the Ace of Hearts is automatically greater than the Two of Hearts,
    because the "Ace" rank value comes after the "Two" rank value.
  prefs: []
  type: TYPE_NORMAL
- en: But also note that the Two of Hearts is automatically greater than the Ace of
    Spades, because the Suit part is compared first, and the "Heart" suit value comes
    after the "Spade" value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a hand of cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: And as a side benefit, you get min and max for free too!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Functions as interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions as interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important aspect of functional programming is that, in a sense, all functions
    are "interfaces", meaning that many of the roles that interfaces play in object-oriented
    design are implicit in the way that functions work.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, one of the critical design maxims, "program to an interface, not an
    implementation", is something you get for free in F#.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, let's compare the same design pattern in C# and F#. For
    example, in C# we might want to use the "decorator pattern" to enhance some core
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a calculator interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And then a specific implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: And then if we want to add logging, we can wrap the core calculator implementation
    inside a logging wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: So far, so straightforward. But note that, for this to work, we must have defined
    an interface for the classes. If there had been no `ICalculator` interface, it
    would be necessary to retrofit the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: And here is where F# shines. In F#, you can do the same thing without having
    to define the interface first. Any function can be transparently swapped for any
    other function as long as the signatures are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the equivalent F# code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the signature of the function *is* the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Generic wrappers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even nicer is that by default, the F# logging code can be made completely generic
    so that it will work for *any* function at all. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The new "wrapped" functions can be used anywhere the original functions could
    be used ? no one can tell the difference!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Exactly the same generic wrapper approach can be used for other things. For
    example, here is a generic wrapper for timing a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The ability to do this kind of generic wrapping is one of the great conveniences
    of the function-oriented approach. You can take any function and create a similar
    function based on it. As long as the new function has exactly the same inputs
    and outputs as the original function, the new can be substituted for the original
    anywhere. Some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to write a generic caching wrapper for a slow function, so that the
    value is only calculated once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also easy to write a generic "lazy" wrapper for a function, so that the
    inner function is only called when a result is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can apply this same approach to another common design pattern, the "strategy
    pattern."
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the familiar example of inheritance: an `Animal` superclass with
    `Cat` and `Dog` subclasses, each of which overrides a `MakeNoise()` method to
    make different noises.'
  prefs: []
  type: TYPE_NORMAL
- en: In a true functional design, there are no subclasses, but instead the `Animal`
    class would have a `NoiseMaking` function that would be passed in with the constructor.
    This approach is exactly the same as the "strategy" pattern in OO design.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note that again, we do not have to define any kind of `INoiseMakingStrategy`
    interface first. Any function with the right signature will work. As a consequence,
    in the functional model, the standard .NET "strategy" interfaces such as `IComparer`,
    `IFormatProvider`, and `IServiceProvider` become irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: Many other design patterns can be simplified in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partial Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A particularly convenient feature of F# is that complicated functions with many
    parameters can have some of the parameters fixed or "baked in" and yet leave other
    parameters open. In this post, we'll take a quick look at how this might be used
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a very simple example of how this works. We''ll start with
    a trivial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: But we can do something strange as well ? we can call the function with only
    one parameter!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The result is a new function that has the "42" baked in, and now takes only
    one parameter instead of two! This technique is called "partial application",
    and it means that, for any function, you can "fix" some of the parameters and
    leave other ones open to be filled in later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'With that under our belt, let''s revisit the generic logger that we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, I have hard-coded the logging operations. Ideally, I'd like to
    make this more generic so that I can choose how logging is done.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, F# being a functional programming language, we will do this by passing
    functions around.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case we would pass "before" and "after" callback functions to the library
    function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the logging function now has four parameters. The "before"
    and "after" actions are passed in as explicit parameters as well as the function
    and its input. To use this in practice, we just define the functions and pass
    them in to the library function along with the final int parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This is a lot more flexible. I don't have to create a new function every time
    I want to change the behavior -- I can define the behavior on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: But you might be thinking that this is a bit ugly. A library function might
    expose a number of callback functions and it would be inconvenient to have to
    pass the same functions in over and over.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we know the solution for this. We can use partial application to fix
    some of the parameters. So in this case, let's define a new function which fixes
    the `before` and `after` functions, as well as the `add1` function, but leaves
    the final parameter open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The new "wrapper" function is called with just an int now, so the code is much
    cleaner. As in the earlier example, it can be used anywhere the original `add1`
    function could be used without any changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The functional approach in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a classical object-oriented approach, we would probably have used inheritance
    to do this kind of thing. For instance, we might have had an abstract `LoggerBase`
    class, with virtual methods for "`before`" and "`after`" and the function to execute.
    And then to implement a particular kind of behavior, we would have created a new
    subclass and overridden the virtual methods as needed.
  prefs: []
  type: TYPE_NORMAL
- en: But classical style inheritance is now becoming frowned upon in object-oriented
    design, and composition of objects is much preferred. And indeed, in "modern"
    C#, we would probably write the code in the same way as F#, either by using events
    or by passing functions in.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the F# code translated into C# (note that I had to specify the types
    for each Action)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And here it is in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In C#, this style of programming is required when using the LINQ libraries,
    but many developers have not embraced it fully to make their own code more generic
    and adaptable. And it's not helped by the ugly `Action<>` and `Func<>` type declarations
    that are required. But it can certainly make the code much more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Active patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Active patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# has a special type of pattern matching called "active patterns" where the
    pattern can be parsed or detected dynamically. As with normal patterns, the matching
    and output are combined into a single step from the caller's point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of using active patterns to parse a string into an int or
    bool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to worry about the complex syntax used to define the active pattern
    right now ? this is just an example so that you can see how they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Once these patterns have been set up, they can be used as part of a normal "`match..with`"
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You can see that from the caller's point of view, the matching with an `Int`
    or `Bool` is transparent, even though there is parsing going on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: A similar example is to use active patterns with regular expressions in order
    to both match on a regex pattern and return the matched value in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Again, once this pattern has been set up, it can be used transparently as part
    of a normal match expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'And for fun, here''s one more: the well-known [FizzBuzz challenge](http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html)
    written using active patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Correctness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Correctness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a programmer, you are constantly judging the code that you and others write.
    In an ideal world, you should be able to look at a piece of code and easily understand
    exactly what it does; and of course, being concise, clear and readable is a major
    factor in this.
  prefs: []
  type: TYPE_NORMAL
- en: But more importantly, you have to be able to convince yourself that the code
    *does what it is supposed to do*. As you program, you are constantly reasoning
    about code correctness, and the little compiler in your brain is checking the
    code for errors and possible mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: So how can a programming language help you with this?
  prefs: []
  type: TYPE_NORMAL
- en: 'A modern imperative language like C# provides many ways that you are already
    familiar with: type checking, scoping and naming rules, access modifiers and so
    on. And, in recent versions, static code analysis and code contracts.'
  prefs: []
  type: TYPE_NORMAL
- en: All these techniques mean that the compiler can take on a lot of the burden
    of checking for correctness. If you make a mistake, the compiler will warn you.
  prefs: []
  type: TYPE_NORMAL
- en: 'But F# has some additional features that can have a huge impact on ensuring
    correctness. The next few posts will be devoted to four of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutability**, which enables code to behave much more predictably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exhaustive pattern matching**, which traps many common errors at compile
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A strict type system**, which is your friend, not your enemy. You can use
    the static type checking almost as an instant "compile time unit test".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An expressive type system** that can help you "make illegal states unrepresentable"*
    . We''ll see how to design a real-world example that demonstrates this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[* Thanks to Yaron Minsky at Jane Street for this phrase.]'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see why immutability is important, let's start with a small example.
  prefs: []
  type: TYPE_NORMAL
- en: Here's some simple C# code that processes a list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let me test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything works great, and the test passes, but I notice that I am creating
    the list twice ? surely I should refactor this out? So I do the refactoring, and
    here''s the new improved version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: But now the test suddenly fails! Why would a refactoring break the test? Can
    you tell just by looking at the code?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, of course, that the list is mutable, and it is probable that
    the `OddNumbers` function is making destructive changes to the list as part of
    its filtering logic. Of course, in order to be sure, we would have to examine
    the code inside the `OddNumbers` function.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, when I call the `OddNumbers` function, I am unintentionally
    creating undesirable side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there a way to ensure that this cannot happen? Yes -- if the functions had
    used `IEnumerable` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In this case we can be confident that calling the `OddNumbers` function could
    not possibly have any effect on the list, and `EvenNumbers` would work correctly.
    What's more, we can know this *just by looking at the signatures*, without having
    to examine the internals of the functions. And if you try to make one of the functions
    misbehave by assigning to the list then you will get an error straight away, at
    compile time.
  prefs: []
  type: TYPE_NORMAL
- en: So `IEnumerable` can help in this case, but what if I had used a type such as
    `IEnumerable<Person>` instead of `IEnumerable<int>`? Could I still be as confident
    that the functions wouldn't have unintentional side effects?
  prefs: []
  type: TYPE_NORMAL
- en: Reasons why immutability is important
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example above shows why immutability is helpful. In fact, this is just
    the tip of the iceberg. There are a number of reasons why immutability is important:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data makes the code predictable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable data is easier to work with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable data forces you to use a "transformational" approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, immutability makes the code **predictable**. If data is immutable, there
    can be no side-effects. If there are no side-effects, it is much, much, easier
    to reason about the correctness of the code.
  prefs: []
  type: TYPE_NORMAL
- en: And when you have two functions that work on immutable data, you don't have
    to worry about which order to call them in, or whether one function will mess
    with the input of the other function. And you have peace of mind when passing
    data around (for example, you don't have to worry about using an object as a key
    in a hashtable and having its hash code change).
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, immutability is a good idea for the same reasons that global variables
    are a bad idea: data should be kept as local as possible and side-effects should
    be avoided.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, immutability is **easier to work with**. If data is immutable, many
    common tasks become much easier. Code is easier to write and easier to maintain.
    Fewer unit tests are needed (you only have to check that a function works in isolation),
    and mocking is much easier. Concurrency is much simpler, as you don't have to
    worry about using locks to avoid update conflicts (because there are no updates).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using immutability by default means that you start thinking differently
    about programming. You tend to think about **transforming** the data rather than
    mutating it in place.
  prefs: []
  type: TYPE_NORMAL
- en: SQL queries and LINQ queries are good examples of this "transformational" approach.
    In both cases, you always transform the original data through various functions
    (selects, filters, sorts) rather than modifying the original data.
  prefs: []
  type: TYPE_NORMAL
- en: When a program is designed using a transformation approach, the result tends
    to be more elegant, more modular, and more scalable. And as it happens, the transformation
    approach is also a perfect fit with a function-oriented paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: How F# does immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw earlier that immutable values and types are the default in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Because of this, F# has a number of tricks to make life easier and to optimize
    the underlying code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, since you can''t modify a data structure, you must copy it when you
    want to change it. F# makes it easy to copy another data structure with only the
    changes you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: And complex data structures are implemented as linked lists or similar, so that
    common parts of the structure are shared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This technique ensures that, while you might appear to have hundreds of copies
    of a list in your code, they are all sharing the same memory behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# is not dogmatic about immutability; it does support mutable data with the
    `mutable` keyword. But turning on mutability is an explicit decision, a deviation
    from the default, and it is generally only needed for special cases such as optimization,
    caching, etc, or when dealing with the .NET libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, a serious application is bound to have some mutable state if it
    deals with messy world of user interfaces, databases, networks and so on. But
    F# encourages the minimization of such mutable state. You can generally still
    design your core business logic to use immutable data, with all the corresponding
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exhaustive pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly noted earlier that when pattern matching there is a requirement to
    match all possible cases. This turns out be a very powerful technique to ensure
    correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Let's compare some C# to F# again. Here's some C# code that uses a switch statement
    to handle different types of state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This code will compile, but there is an obvious bug! The compiler couldn't see
    it ? can you? If you can, and you fixed it, would it stay fixed if I added another
    `State` to the list?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the F# equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Now try running this code. What does the compiler tell you?
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that exhaustive matching is always done means that certain common
    errors will be detected by the compiler immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: A missing case (often caused when a new choice has been added due to changed
    requirements or refactoring).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An impossible case (when an existing choice has been removed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A redundant case that could never be reached (the case has been subsumed in
    a previous case -- this can sometimes be non-obvious).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at some real examples of how exhaustive matching can help you
    write correct code.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding nulls with the Option type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start with an extremely common scenario where the caller should always
    check for an invalid case, namely testing for nulls. A typical C# program is littered
    with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this test is not required by the compiler. All it takes is for
    one piece of code to forget to do this, and the program can crash. Over the years,
    a huge amount of programming effort has been devoted to handling nulls ? the invention
    of nulls has even been called a [billion dollar mistake](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)!
  prefs: []
  type: TYPE_NORMAL
- en: In pure F#, nulls cannot exist accidentally. A string or object must always
    be assigned to something at creation, and is immutable thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are many situations where the *design intent* is to distinguish
    between valid and invalid values, and you require the caller to handle both cases.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, this can be managed in certain situations by using nullable value types
    (such as `Nullable<int>`) to make the design decision clear. When a nullable is
    encountered the compiler will force you to be aware of it. You can then test the
    validity of the value before using it. But nullables do not work for standard
    classes (i.e. reference types), and it is easy to accidentally bypass the tests
    too and just call `Value` directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In F# there is a similar but more powerful concept to convey the design intent:
    the generic wrapper type called `Option`, with two choices: `Some` or `None`.
    The `Some` choice wraps a valid value, and `None` represents a missing value.'
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example where `Some` is returned if a file exists, but a missing file
    returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: If we want to do anything with these values, we must always handle both possible
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: We have no choice about this. Not handling a case is a compile-time error, not
    a run-time error. By avoiding nulls and by using `Option` types in this way, F#
    completely eliminates a large class of null reference exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Caveat: F# does allow you to access the value without testing, just like C#,
    but that is considered extremely bad practice.]'
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive pattern matching for edge cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s some C# code that creates a list by averaging pairs of numbers from
    an input list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: It compiles correctly, but it actually has a couple of issues. Can you find
    them quickly? If you're lucky, your unit tests will find them for you, assuming
    you have thought of all the edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try the same thing in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This code also has a bug. But unlike C#, this code will not even compile until
    I fix it. The compiler will tell me that I haven''t handled the case when I have
    a single item in my list. Not only has it found a bug, it has revealed a gap in
    the requirements: what should happen when there is only one item?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the fixed up version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: As an additional benefit, the F# code is also much more self-documenting. It
    explicitly describes the consequences of each case. In the C# code, it is not
    at all obvious what happens if a list is empty or only has one item. You would
    have to read the code carefully to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive pattern matching as an error handling technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fact that all choices must be matched can also be used as a useful alternative
    to throwing exceptions. For example consider the following common scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a utility function in the lowest tier of your app that opens a file
    and performs an arbitrary operation on it (that you pass in as a callback function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is then passed back up through to tiers to the top level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client calls the top level code, and the result is processed and any error
    handling done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a procedural or OO language, propagating and handling exceptions across layers
    of code is a common problem. Top level functions are not easily able to tell the
    difference between an exception that they should recover from (`FileNotFound`
    say) vs. an exception that they needn't handle (`OutOfMemory` say). In Java, there
    has been an attempt to do this with checked exceptions, but with mixed results.
  prefs: []
  type: TYPE_NORMAL
- en: In the functional world, a common technique is to create a new structure to
    hold both the good and bad possibilities, rather than throwing an exception if
    the file is missing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The code demonstrates how `performActionOnFile` returns a `Result` object which
    has two alternatives: `Success` and `Failure`. The `Failure` alternative in turn
    has two alternatives as well: `FileNotFound` and `UnauthorizedAccess`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the intermediate layers can call each other, passing around the result
    type without worrying what its structure is, as long as they don''t access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Because of type inference, the middle and top layers do not need to specify
    the exact types returned. If the lower layer changes the type definition at all,
    the intermediate layers will not be affected.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously at some point, a client of the top layer does want to access the result.
    And here is where the requirement to match all patterns is enforced. The client
    must handle the case with a `Failure` or else the compiler will complain. And
    furthermore, when handling the `Failure` branch, it must handle the possible reasons
    as well. In other words, special case handling of this sort can be enforced at
    compile time, not at runtime! And in addition the possible reasons are explicitly
    documented by examining the reason type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a client function that accesses the top layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this code must explicitly handle the `Success` and `Failure`
    cases, and then for the failure case, it explicitly handles the different reasons.
    If you want to see what happens if it does not handle one of the cases, try commenting
    out the line that handles `UnauthorizedAccess` and see what the compiler says.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is not required that you always handle all possible cases explicitly.
    In the example below, the function uses the underscore wildcard to treat all the
    failure reasons as one. This can considered bad practice if we want to get the
    benefits of the strictness, but at least it is clearly done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see all this code work in practice with some interactive tests.
  prefs: []
  type: TYPE_NORMAL
- en: First set up a good file and a bad file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'And now test interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'I think you can see that this approach is very attractive:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions return error types for each expected case (such as `FileNotFound`),
    but the handling of these types does not need to make the calling code ugly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions continue to throw exceptions for unexpected cases (such as `OutOfMemory`),
    which will generally be caught and logged at the top level of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique is simple and convenient. Similar (and more generic) approaches
    are standard in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: It is feasible to use this approach in C# too, but it is normally impractical,
    due to the lack of union types and the lack of type inference (we would have to
    specify generic types everywhere).
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive pattern matching as a change management tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, exhaustive pattern matching is a valuable tool for ensuring that code
    stays correct as requirements change, or during refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that the requirements change and we need to handle a third type
    of error: "Indeterminate". To implement this new requirement, change the first
    `Result` type as follows, and re-evaluate all the code. What happens?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Or sometimes a requirements change will remove a possible choice. To emulate
    this, change the first `Result` type to eliminate all but one of the choices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Now re-evaluate the rest of the code. What happens now?
  prefs: []
  type: TYPE_NORMAL
- en: This is very powerful! When we adjust the choices, we immediately know all the
    places which need to be fixed to handle the change. This is another example of
    the power of statically checked type errors. It is often said about functional
    languages like F# that "if it compiles, it must be correct".
  prefs: []
  type: TYPE_NORMAL
- en: Using the type system to ensure correct code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the type system to ensure correct code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are familiar with static type checking through languages such as C# and
    Java. In these languages, the type checking is straightforward but rather crude,
    and can be seen as an annoyance compared with the freedom of dynamic languages
    such as Python and Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: But in F# the type system is your friend, not your enemy. You can use static
    type checking almost as an instant unit test ? making sure that your code is correct
    at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the earlier posts we have already seen some of the things that you can do
    with the type system in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: The types and their associated functions provide an abstraction to model the
    problem domain. Because creating types is so easy, there is rarely an excuse to
    avoid designing them as needed for a given problem, and unlike C# classes it is
    hard to create "kitchen-sink" types that do everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well defined types aid in maintenance. Since F# uses type inference, you can
    normally rename or restructure types easily without using a refactoring tool.
    And if the type is changed in an incompatible way, this will almost certainly
    create compile-time errors that aid in tracking down any problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well named types provide instant documentation about their roles in the program
    (and this documentation can never be out of date).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this post and the next we will focus on using the type system as an aid to
    writing correct code. I will demonstrate that you can create designs such that,
    if your code actually compiles, it will almost certainly work as designed.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, you use the compile-time checks to validate your code without even thinking
    about it. For example, would you give up `List<string>` for a plain `List`? Or
    give up `Nullable<int>` and be forced to used `object` with casting? Probably
    not.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you could have even more fine-grained types? You could have even
    better compile-time checks. And this is exactly what F# offers.
  prefs: []
  type: TYPE_NORMAL
- en: The F# type checker is not that much stricter than the C# type checker. But
    because it is so easy to create new types without clutter, you can represent the
    domain better, and, as a useful side-effect, avoid many common errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: By wrapping the email address in a special type, we ensure that normal strings
    cannot be used as arguments to email specific functions. (In practice, we would
    also hide the constructor of the `EmailAddress` type as well, to ensure that only
    valid values could be created in the first place.)
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing here that couldn't be done in C#, but it would be quite a lot
    of work to create a new value type just for this one purpose, so in C#, it is
    easy to be lazy and just pass strings around.
  prefs: []
  type: TYPE_NORMAL
- en: Additional type safety features in F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on to the major topic of "designing for correctness", let's see
    a few of the other minor, but cool, ways that F# is type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Type-safe formatting with printf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a minor feature that demonstrates one of the ways that F# is more type-safe
    than C#, and how the F# compiler can catch errors that would only be detected
    at runtime in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try evaluating the following and look at the errors generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Unlike C#, the compiler analyses the format string and determines what the number
    and types of the arguments are supposed to be.
  prefs: []
  type: TYPE_NORMAL
- en: This can be used to constrain the types of parameters without explicitly having
    to specify them. So for example, in the code below, the compiler can deduce the
    types of the arguments automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Units of measure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: F# has the ability to define units of measure and associate them with floats.
    The unit of measure is then "attached" to the float as a type and prevents mixing
    different types. This is another feature that can be very handy if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Type-safe equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One final example. In C# any class can be equated with any other class (using
    reference equality by default). In general, this is a bad idea! For example, you
    shouldn't really be able to compare a string with a person at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some C# code which is perfectly valid and compiles fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'If we write the identical code in F#, we get a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Chances are, if you are testing equality between two different types, you are
    doing something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, you can even stop a type being compared at all! This is not as silly
    as it seems. For some types, there may not be a useful default, or you may want
    to force equality to be based on a specific field rather than the object as whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Worked example: Designing for correctness'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Worked example: Designing for correctness'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we'll see how you can design for correctness (or at least, for
    the requirements as you currently understand them), by which I mean that a client
    of a well designed model will not be able to put the system into an illegal state
    ? a state that doesn't meet the requirements. You literally cannot create incorrect
    code because the compiler will not let you.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we do have to spend some time up front thinking about design
    and making an effort to encode the requirements into the types that you use. If
    you just use strings or lists for all your data structures, you will not get any
    benefit from the type checking.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use a simple example. Let's say that you are designing an e-commerce site
    which has a shopping cart and you are given the following requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can only pay for a cart once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a cart is paid for, you cannot change the items in it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty carts cannot be paid for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bad design in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, we might think that this is simple enough and dive straight into coding.
    Here is a straightforward implementation in C# that seems OK at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, it''s actually a pretty bad design:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the requirements is not even met. Can you see which one?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a major design flaw, and a number of minor ones. Can you see what they
    are?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So many problems in such a short piece of code!
  prefs: []
  type: TYPE_NORMAL
- en: 'What would happen if we had even more complicated requirements and the code
    was thousands of lines long? For example, the fragment that is repeated everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: looks like it will be quite brittle if requirements change in some methods but
    not others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you read the next section, think for a minute how you might better implement
    the requirements above in C#, with these additional requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to do something that is not allowed in the requirements, you will
    get a *compile time error*, not a run time error. For example, you must create
    a design such that you cannot even call the `RemoveItem` method from an empty
    cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of the cart in any state should be immutable. The benefit of this
    is that if I am in the middle of paying for a cart, the cart contents can't change
    even if some other process is adding or removing items at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A correct design in F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s step back and see if we can come up with a better design. Looking at
    these requirements, it''s obvious that we have a simple state machine with three
    states and some state transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: A Shopping Cart can be Empty, Active or PaidFor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you add an item to an Empty cart, it becomes Active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you remove the last item from an Active cart, it becomes Empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you pay for an Active cart, it becomes PaidFor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And now we can add the business rules to this model:'
  prefs: []
  type: TYPE_NORMAL
- en: You can add an item only to carts that are Empty or Active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can remove an item only from carts that are Active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can only pay for carts that are Active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the state diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shopping Cart](ShoppingCart.png)'
  prefs: []
  type: TYPE_IMG
- en: It's worth noting that these kinds of state-oriented models are very common
    in business systems. Product development, customer relationship management, order
    processing, and other workflows can often be modeled this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the design, we can reproduce it in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: We create a type for each state, and `Cart` type that is a choice of any one
    of the states. I have given everything a distinct name (e.g. `PaidItems` and `UnpaidItems`
    rather than just `Items`) because this helps the inference engine and makes the
    code more self documenting.
  prefs: []
  type: TYPE_NORMAL
- en: This is a much longer example than the earlier ones! Don't worry too much about
    the F# syntax right now, but I hope that you can get the gist of the code, and
    see how it fits into the overall design.
  prefs: []
  type: TYPE_NORMAL
- en: Also, do paste the snippets into a script file and evaluate them for yourself
    as they come up.
  prefs: []
  type: TYPE_NORMAL
- en: Next we can create the operations for each state. The main thing to note is
    each operation will always take one of the States as input and return a new Cart.
    That is, you start off with a particular known state, but you return a `Cart`
    which is a wrapper for a choice of three possible states.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Next, we attach the operations to the states as methods
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: And we can create some cart level helper methods as well. At the cart level,
    we have to explicitly handle each possibility for the internal state with a `match..with`
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Testing the design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s exercise this code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: We now have an active cart with one item in it. Note that "`cartA`" is a completely
    different object from "`emptyCart`" and is in a different state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s keep going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. Again, all these are distinct objects in different states,
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the requirement that you cannot remove items from an empty cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: An error ? just what we want!
  prefs: []
  type: TYPE_NORMAL
- en: Now say that we want to pay for a cart. We didn't create this method at the
    Cart level, because we didn't want to tell the client how to handle all the cases.
    This method only exists for the Active state, so the client will have to explicitly
    handle each case and only call the `Pay` method when an Active state is matched.
  prefs: []
  type: TYPE_NORMAL
- en: First we'll try to pay for cartA.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The result was a paid cart.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll try to pay for the emptyCart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Nothing happens. The cart is empty, so the Active branch is not called. We might
    want to raise an error or log a message in the other branches, but no matter what
    we do we cannot accidentally call the `Pay` method on an empty cart, because that
    state does not have a method to call!
  prefs: []
  type: TYPE_NORMAL
- en: The same thing happens if we accidentally try to pay for a cart that is already
    paid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: You might argue that the client code above might not be representative of code
    in the real world ? it is well-behaved and already dealing with the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what happens if we have badly written or malicious client code that tries
    to force payment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: If we try to force it like this, we will get compile errors. There is no way
    the client can create code that does not meet the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have designed a simple shopping cart model which has many benefits over the
    C# design.
  prefs: []
  type: TYPE_NORMAL
- en: It maps to the requirements quite clearly. It is impossible for a client of
    this API to call code that doesn't meet the requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using states means that the number of possible code paths is much smaller than
    the C# version, so there will be many fewer unit tests to write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each function is simple enough to probably work the first time, as, unlike the
    C# version, there are no conditionals anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of the original C# code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have seen the F# code, we can revisit the original C# code with
    fresh eyes. In case you were wondering, here are my thoughts as to what is wrong
    with the C# shopping cart example as designed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Requirement not met*: An empty cart can still be paid for.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Major design flaw*: Overloading the payment amount to be a signal for IsPaidFor
    means that a zero paid amount can never lock down the cart. Are you sure it would
    never be possible to have a cart which is paid for but free of charge? The requirements
    are not clear, but what if this did become a requirement later? How much code
    would have to be changed?'
  prefs: []
  type: TYPE_NORMAL
- en: '*Minor design flaws*: What should happen when trying to remove an item from
    an empty cart? And what should happen when attempting to pay for a cart that is
    already paid for? Should we throw exceptions in these cases, or just silently
    ignore them? And does it make sense that a client should be able to enumerate
    the items in an empty cart? And this is not thread safe as designed; so what happens
    if a secondary thread adds an item to the cart while a payment is being made on
    the main thread?'
  prefs: []
  type: TYPE_NORMAL
- en: That's quite a lot of things to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about the F# design is none of these problems can even exist.
    So designing this way not only ensures correct code, but it also really reduces
    the cognitive effort to ensure that the design is bullet proof in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '*Compile time checking:* The original C# design mixes up all the states and
    transitions in a single class, which makes it very error prone. A better approach
    would be to create separate state classes (with a common base class say) which
    reduces complexity, but still, the lack of a built in "union" type means that
    you cannot statically verify that the code is correct. There are ways of doing
    "union" types in C#, but it is not idiomatic at all, while in F# it is commonplace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: C# code for a correct solution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When faced with these requirements in C#, you might immediately think -- just
    create an interface!
  prefs: []
  type: TYPE_NORMAL
- en: 'But it is not as easy as you might think. I have written a follow up post on
    this to explain why: [The shopping cart example in C#](../csharp/union-types-in-csharp.html).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested to see what the C# code for a solution looks like, here
    it is below. This code meets the requirements above and guarantees correctness
    at *compile time*, as desired.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing to note is that, because C# doesn't have union types, the implementation
    uses a ["fold" function](match-expression.html#folds), a function that has three
    function parameters, one for each state. To use the cart, the caller passes a
    set of three lambdas in, and the (hidden) state determines what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: This approach means that the caller can never call the "wrong" function, such
    as "Pay" for the Empty state, because the parameter to the lambda will not support
    it. Try it and see!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We hear a lot about concurrency nowadays, how important it is, and how it is
    ["the next major revolution in how we write software"](http://www.gotw.ca/publications/concurrency-ddj.htm).
  prefs: []
  type: TYPE_NORMAL
- en: So what do we actually mean by "concurrency" and how can F# help?
  prefs: []
  type: TYPE_NORMAL
- en: The simplest definition of concurrency is just "several things happening at
    once, and maybe interacting with each other". It seems a trivial definition, but
    the key point is that most computer programs (and languages) are designed to work
    serially, on one thing at a time, and are not well-equipped to handle concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'And even if computer programs are written to handle concurrency, there is an
    even more serious problem: our brains do not do well when thinking about concurrency.
    It is commonly acknowledged that writing code that handles concurrency is extremely
    hard. Or I should say, writing concurrent code that is *correct* is extremely
    hard! It''s very easy to write concurrent code that is buggy; there might be race
    conditions, or operations might not be atomic, or tasks might be starved or blocked
    unnecessarily, and these issues are hard to find by looking at the code or using
    a debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before talking about the specifics of F#, let''s try to classify some of the
    common types of concurrency scenarios that we have to deal with as developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Concurrent Multitasking"**. This is when we have a number of concurrent
    tasks (e.g. processes or threads) within our direct control, and we want them
    to communicate with each other and share data safely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"Asynchronous" programming**. This is when we initiate a conversation with
    a separate system outside our direct control, and then wait for it to get back
    to us. Common cases of this are when talking to the filesystem, a database, or
    the network. These situations are typically I/O bound, so you want to do something
    else useful while you are waiting. These types of tasks are often *non-deterministic*
    as well, meaning that running the same program twice might give a different result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"Parallel" programming**. This is when we have a single task that we want
    to split into independant subtasks, and then run the subtasks in parallel, ideally
    using all the cores or CPUs that are available. These situations are typically
    CPU bound. Unlike the async tasks, parallelism is typically *deterministic*, so
    running the same program twice will give the same result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"Reactive" programming**. This is when we do not initiate tasks ourselves,
    but are focused on listening for events which we then process as fast as possible.
    This situation occurs when designing servers, and when working with a user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, these are vague definitions and overlap in practice. In general,
    though, for all these cases, the actual implementations that address these scenarios
    tend to use two distinct approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are lots of different tasks that need to share state or resources without
    waiting, then use a "buffered asynchronous" design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are lots of identical tasks that do not need to share state, then use
    parallel tasks using "fork/join" or "divide and conquer" approaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# tools for concurrent programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'F# offers a number of different approaches to writing concurrent code:'
  prefs: []
  type: TYPE_NORMAL
- en: For multitasking and asynchronous problems, F# can directly use all the usual
    .NET suspects, such as `Thread` `AutoResetEvent`, `BackgroundWorker` and `IAsyncResult`.
    But it also offers a much simpler model for all types of async IO and background
    task management, called "asynchronous workflows". We will look at these in the
    next post.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative approach for asynchronous problems is to use message queues and
    the ["actor model"](http://en.wikipedia.org/wiki/Actor_model) (this is the "buffered
    asynchronous" design mentioned above). F# has a built in implementation of the
    actor model called `MailboxProcessor`. I am a big proponent of designing with
    actors and message queues, as it decouples the various components and allows you
    to think serially about each one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For true CPU parallelism, F# has convenient library code that builds on the
    asynchronous workflows mentioned above, and it can also use the .NET [Task Parallel
    Library](http://msdn.microsoft.com/en-us/library/dd460717.aspx).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the functional approach to event handling and reactive programming
    is quite different from the traditional approach. The functional approach treats
    events as "streams" which can be filtered, split, and combined in much the the
    same way that LINQ handles collections. F# has built in support for this model,
    as well as for the standard event-driven model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post we'll have a look at a few ways to write asynchronous code in F#,
    and a very brief example of parallelism as well.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional asynchronous programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted in the previous post, F# can directly use all the usual .NET suspects,
    such as `Thread` `AutoResetEvent`, `BackgroundWorker` and `IAsyncResult`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example where we wait for a timer event to go off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This shows the use of `AutoResetEvent` as a synchronization mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda is registered with the `Timer.Elapsed` event, and when the event is
    triggered, the AutoResetEvent is signalled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main thread starts the timer, does something else while waiting, and then
    blocks until the event is triggered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the main thread continues, about 2 seconds later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code above is reasonably straightforward, but does require you to instantiate
    an AutoResetEvent, and could be buggy if the lambda is defined incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing asynchronous workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# has a built-in construct called "asynchronous workflows" which makes async
    code much easier to write. These workflows are objects that encapsulate a background
    task, and provide a number of useful operations to manage them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the previous example rewritten to use one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: the `AutoResetEvent` and lambda have disappeared, and are replaced by `let timerEvent
    = Control.Async.AwaitEvent (timer.Elapsed)`, which creates an `async` object directly
    from the event, without needing a lambda. The `ignore` is added to ignore the
    result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the `event.WaitOne()` has been replaced by `Async.RunSynchronously timerEvent`
    which blocks on the async object until it has completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it. Both simpler and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The async workflows can also be used with `IAsyncResult`, begin/end pairs, and
    other standard .NET methods.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here's how you might do an async file write by wrapping the `IAsyncResult`
    generated from `BeginWrite`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Creating and nesting asynchronous workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous workflows can also be created manually. A new workflow is created
    using the `async` keyword and curly braces. The braces contain a set of expressions
    to be executed in the background.
  prefs: []
  type: TYPE_NORMAL
- en: This simple workflow just sleeps for 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: the code `do! Async.Sleep 2000` is similar to `Thread.Sleep` but designed
    to work with asynchronous workflows.*'
  prefs: []
  type: TYPE_NORMAL
- en: Workflows can contain *other* async workflows nested inside them. Within the
    braces, the nested workflows can be blocked on by using the `let!` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Cancelling workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One very convenient thing about async workflows is that they support a built-in
    cancellation mechanism. No special code is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple task that prints numbers from 1 to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test it in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Now let's say we want to cancel this task half way through. What would be the
    best way of doing it?
  prefs: []
  type: TYPE_NORMAL
- en: In C#, we would have to create flags to pass in and then check them frequently,
    but in F# this technique is built in, using the `CancellationToken` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here an example of how we might cancel the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: In F#, any nested async call will check the cancellation token automatically!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case it was the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, this line is where the cancellation happened.
  prefs: []
  type: TYPE_NORMAL
- en: Composing workflows in series and parallel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another useful thing about async workflows is that they can be easily combined
    in various ways: both in series and in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s again create a simple workflow that just sleeps for a given time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a version that combines two of these in series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a version that combines two of these in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: The #time command toggles the timer on and off. It only works in the
    interactive window, so this example must be sent to the interactive window in
    order to work corrrectly.'
  prefs: []
  type: TYPE_NORMAL
- en: We're using the `#time` option to show the total elapsed time, which, because
    they run in parallel, is 2 secs. If they ran in series instead, it would take
    3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Also you might see that the output is garbled sometimes because both tasks are
    writing to the console at the same time!
  prefs: []
  type: TYPE_NORMAL
- en: This last sample is a classic example of a "fork/join" approach, where a number
    of a child tasks are spawned and then the parent waits for them all to finish.
    As you can see, F# makes this very easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: an async web downloader'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this more realistic example, we'll see how easy it is to convert some existing
    code from a non-asynchronous style to an asynchronous style, and the corresponding
    performance increase that can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here is a simple URL downloader, very similar to the one we saw at the start
    of the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is some code to time it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Make a note of the time taken, and let's if we can improve on it!
  prefs: []
  type: TYPE_NORMAL
- en: Obviously the example above is inefficient -- only one web site at a time is
    visited. The program would be faster if we could visit them all at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how would we convert this to a concurrent algorithm? The logic would be
    something like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a task for each web page we are downloading, and then for each task,
    the download logic would be something like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start downloading a page from a website. While that is going on, pause and let
    other tasks have a turn.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the download is finished, wake up and continue on with the task
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, start all the tasks up and let them go at it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, this is quite hard to do in a standard C-like language. In C#
    for example, you have to create a callback for when an async task completes. Managing
    these callbacks is painful and creates a lot of extra support code that gets in
    the way of understanding the logic. There are some elegant solutions to this,
    but in general, the signal to noise ratio for concurrent programming in C# is
    very high*.
  prefs: []
  type: TYPE_NORMAL
- en: '[* As of the time of this writing. Future versions of C# will have the `await`
    keyword, which is similar to what F# has now.]'
  prefs: []
  type: TYPE_NORMAL
- en: 'But as you can guess, F# makes this easy. Here is the concurrent F# version
    of the downloader code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Note that the new code looks almost exactly the same as the original. There
    are only a few minor changes.
  prefs: []
  type: TYPE_NORMAL
- en: The change from "`use resp =`" to "`use! resp =`" is exactly the change that
    we talked about above -- while the async operation is going on, let other tasks
    have a turn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also used the extension method `AsyncGetResponse` defined in the `CommonExtensions`
    namespace. This returns an async workflow that we can nest inside the main workflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition the whole set of steps is contained in the "`async {...}`" wrapper
    which turns it into a block that can be run asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And here is a timed download using the async version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The way this works is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchUrlAsync` is applied to each site. It does not immediately start the
    download, but returns an async workflow for running later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set up all the tasks to run at the same time we use the `Async.Parallel`
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally we call `Async.RunSynchronously` to start all the tasks, and wait for
    them all to stop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try out this code yourself, you will see that the async version is much
    faster than the sync version. Not bad for a few minor code changes! Most importantly,
    the underlying logic is still very clear and is not cluttered up with noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: a parallel computation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish up, let's have another quick look at a parallel computation again.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, I should warn you that the example code below is just to demonstrate
    the basic principles. Benchmarks from "toy" versions of parallelization like this
    are not meaningful, because any kind of real concurrent code has so many dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: And also be aware that parallelization is rarely the best way to speed up your
    code. Your time is almost always better spent on improving your algorithms. I'll
    bet my serial version of quicksort against your parallel version of bubblesort
    any day! (For more details on how to improve performance, see the [optimization
    series](optimization.md))
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, with that caveat, let's create a little task that chews up some CPU.
    We'll test this serially and in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Adjust the upper bounds of the loops as needed to make this run in about 0.2
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s combine a bunch of these into a single serial task (using composition),
    and test it with the timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: This should take about 4 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in order to make the `childTask` parallelizable, we have to wrap it inside
    an `async`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: And to combine a bunch of asyncs into a single parallel task, we use `Async.Parallel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this and compare the timings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: On a dual-core machine, the parallel version is about 50% faster. It will get
    faster in proportion to the number of cores or CPUs, of course, but sublinearly.
    Four cores will be faster than one core, but not four times faster.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, as with the async web download example, a few minor code
    changes can make a big difference, while still leaving the code easy to read and
    understand. So in cases where parallelism will genuinely help, it is nice to know
    that it is easy to arrange.
  prefs: []
  type: TYPE_NORMAL
- en: Messages and Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messages and Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we'll look at the message-based (or actor-based) approach to concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, when one task wants to communicate with another, it sends
    it a message, rather than contacting it directly. The messages are put on a queue,
    and the receiving task (known as an "actor" or "agent") pulls the messages off
    the queue one at a time to process them.
  prefs: []
  type: TYPE_NORMAL
- en: This message-based approach has been applied to many situations, from low-level
    network sockets (built on TCP/IP) to enterprise wide application integration systems
    (for example MSMQ or IBM WebSphere MQ).
  prefs: []
  type: TYPE_NORMAL
- en: 'From a software design point of view, a message-based approach has a number
    of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: You can manage shared data and resources without locks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can easily follow the "single responsibility principle", because each agent
    can be designed to do only one thing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It encourages a "pipeline" model of programming with "producers" sending messages
    to decoupled "consumers", which has additional benefits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The queue acts as a buffer, eliminating waiting on the client side.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is straightforward to scale up one side or the other of the queue as needed
    in order to maximize throughput.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors can be handled gracefully, because the decoupling means that agents can
    be created and destroyed without affecting their clients.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From a practical developer's point of view, what I find most appealing about
    the message-based approach is that when writing the code for any given actor,
    you don't have to hurt your brain by thinking about concurrency. The message queue
    forces a "serialization" of operations that otherwise might occur concurrently.
    And this in turn makes it much easier to think about (and write code for) the
    logic for processing a message, because you can be sure that your code will be
    isolated from other events that might interrupt your flow.
  prefs: []
  type: TYPE_NORMAL
- en: With these advantages, it is not surprising that when a team inside Ericsson
    wanted to design a programming language for writing highly-concurrent telephony
    applications, they created one with a message-based approach, namely Erlang. Erlang
    has now become the poster child for the whole topic, and has created a lot of
    interest in implementing the same approach in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: How F# implements a message-based approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# has a built-in agent class called `MailboxProcessor`. These agents are very
    lightweight compared with threads - you can instantiate tens of thousands of them
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: These are similar to the agents in Erlang, but unlike the Erlang ones, they
    do *not* work across process boundaries, only in the same process. And unlike
    a heavyweight queueing system such as MSMQ, the messages are not persistent. If
    your app crashes, the messages are lost.
  prefs: []
  type: TYPE_NORMAL
- en: But these are minor issues, and can be worked around. In a future series, I
    will go into alternative implementations of message queues. The fundamental approach
    is the same in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple agent implementation in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The `MailboxProcessor.Start` function takes a simple function parameter. That
    function loops forever, reading messages from the queue (or "inbox") and processing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: I have added the #nowarn "40" pragma to avoid the warning "FS0040",
    which can be safely ignored in this case.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the example in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'In the rest of this post we''ll look at two slightly more useful examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing shared state without locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialized and buffered access to shared IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both of these cases, a message based approach to concurrency is elegant,
    efficient, and easy to program.
  prefs: []
  type: TYPE_NORMAL
- en: Managing shared state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the shared state problem first.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common scenario is that you have some state that needs to be accessed and
    changed by multiple concurrent tasks or threads. We''ll use a very simple case,
    and say that the requirements are:'
  prefs: []
  type: TYPE_NORMAL
- en: A shared "counter" and "sum" that can be incremented by multiple tasks concurrently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to the counter and sum must be atomic -- we must guarantee that they
    will both be updated at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The locking approach to shared state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using locks or mutexes is a common solution for these requirements, so let's
    write some code using a lock, and see how it performs.
  prefs: []
  type: TYPE_NORMAL
- en: First let's write a static `LockedCounter` class that protects the state with
    locks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Some notes on this code:'
  prefs: []
  type: TYPE_NORMAL
- en: This code is written using a very imperative approach, with mutable variables
    and locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public `Add` method has explicit `Monitor.Enter` and `Monitor.Exit` expressions
    to get and release the lock. This is the same as the `lock{...}` statement in
    C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've also added a stopwatch to measure how long a client has to wait to get
    the lock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core "business logic" is the `updateState` method, which not only updates
    the state, but adds a small random wait as well to emulate the time taken to do
    the processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s test it in isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a task that will try to access the counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: In this case, when there is no contention at all, the wait times are all 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens when we create 10 child tasks that all try to access the counter
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Oh dear! Most tasks are now waiting quite a while. If two tasks want to update
    the state at the same time, one must wait for the other's work to complete before
    it can do its own work, which affects performance.
  prefs: []
  type: TYPE_NORMAL
- en: And if we add more and more tasks, the contention will increase, and the tasks
    will spend more and more time waiting rather than working.
  prefs: []
  type: TYPE_NORMAL
- en: The message-based approach to shared state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how a message queue might help us. Here''s the message based version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Some notes on this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The core "business logic" is again in the `updateState` method, which has almost
    the same implementation as the earlier example, except the state is immutable,
    so that a new state is created and returned to the main loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent reads messages (simple ints in this case) and then calls `updateState`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public method `Add` posts a message to the agent, rather than calling the
    `updateState` method directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code is written in a more functional way; there are no mutable variables
    and no locks anywhere. In fact, there is no code dealing with concurrency at all!
    The code only has to focus on the business logic, and is consequently much easier
    to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s test it in isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll reuse a task we defined earlier, but calling `MessageBasedCounter.Add`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Finally let's create 5 child tasks that try to access the counter at once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: We can't measure the waiting time for the clients, because there is none!
  prefs: []
  type: TYPE_NORMAL
- en: Shared IO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A similar concurrency problem occurs when accessing a shared IO resource such
    as a file:'
  prefs: []
  type: TYPE_NORMAL
- en: If the IO is slow, the clients can spend a lot of time waiting, even without
    locks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple threads write to the resource at the same time, you can get corrupted
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both problems can be solved by using asynchronous calls combined with buffering
    -- exactly what a message queue does.
  prefs: []
  type: TYPE_NORMAL
- en: In this next example, we'll consider the example of a logging service that many
    clients will write to concurrently. (In this trivial case, we'll just write directly
    to the Console.)
  prefs: []
  type: TYPE_NORMAL
- en: We'll first look at an implementation without concurrency control, and then
    at an implementation that uses message queues to serialize all requests.
  prefs: []
  type: TYPE_NORMAL
- en: IO without serialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make the corruption very obvious and repeatable, let's first create
    a "slow" console that writes each individual character in the log message and
    pauses for a millisecond between each character. During that millisecond, another
    thread could be writing as well, causing an undesirable interleaving of messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a simple task that loops a few times, writing its name
    each time to the logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we write a logging class that encapsulates access to the slow console.
    It has no locking or serialization, and is basically not thread-safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Now let's combine all these into a real example. We will create five child tasks
    and run them in parallel, all trying to write to the slow console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Ouch! The output is very garbled!
  prefs: []
  type: TYPE_NORMAL
- en: Serialized IO with messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what happens when we replace `UnserializedLogger` with a `SerializedLogger`
    class that encapsulates a message queue.
  prefs: []
  type: TYPE_NORMAL
- en: The agent inside `SerializedLogger` simply reads a message from its input queue
    and writes it to the slow console. Again there is no code dealing with concurrency
    and no locks are used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we can repeat the earlier unserialized example but using the `SerializedLogger`
    instead. Again, we create five child tasks and run them in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: What a difference! This time the output is perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is much more to say about this message based approach. In a future series,
    I hope to go into much more detail, including discussion of topics such as:'
  prefs: []
  type: TYPE_NORMAL
- en: alternative implementations of message queues with MSMQ and TPL Dataflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cancellation and out of band messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: error handling and retries, and handling exceptions in general.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to scale up and down by creating or removing child agents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: avoiding buffer overruns and detecting starvation or inactivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events are everywhere. Almost every program has to handle events, whether it
    be button clicks in the user interface, listening to sockets in a server, or even
    a system shutdown notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'And events are the basis of one of the most common OO design patterns: the
    "Observer" pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: But as we know, event handling, like concurrency in general, can be tricky to
    implement. Simple event logic is straightforward, but what about logic like "do
    something if two events happen in a row but do something different if only one
    event happens" or "do something if two events happen at roughly the same time".
    And how easy is it to combine these requirements in other, more complex ways?
  prefs: []
  type: TYPE_NORMAL
- en: Even you can successfully implement these requirements, the code tends to be
    spaghetti like and hard to understand, even with the best intentions.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a approach that can make event handling easier?
  prefs: []
  type: TYPE_NORMAL
- en: We saw in the previous post on message queues that one of the advantages of
    that approach was that the requests were "serialized" making it conceptually easier
    to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: There is a similar approach that can be used with events. The idea is to turn
    a series of events into an "event stream". Event streams then become quite like
    IEnumerables, and so the obvious next step is to treat them in much the the same
    way that LINQ handles collections, so that they can be filtered, mapped, split
    and combined.
  prefs: []
  type: TYPE_NORMAL
- en: F# has built in support for this model, as well as for the more tradition approach.
  prefs: []
  type: TYPE_NORMAL
- en: A simple event stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with a simple example to compare the two approaches. We'll implement
    the classic event handler approach first.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a utility function that will:'
  prefs: []
  type: TYPE_NORMAL
- en: create a timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: register a handler for the `Elapsed` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: run the timer for five seconds and then stop it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Now test it interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Now let's create a similar utility method to create a timer, but this time it
    will return an "observable" as well, which is the stream of events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'And again test it interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that instead of registering a handler directly with an event,
    we are "subscribing" to an event stream. Subtly different, and important.
  prefs: []
  type: TYPE_NORMAL
- en: Counting events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this next example, we''ll have a slightly more complex requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this in a classic imperative way, we would probably create a class with
    a mutable counter, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reuse the utility functions we created earlier to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we would do this same thing in a functional way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Here we see how you can build up layers of event transformations, just as you
    do with list transformations in LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: The first transformation is `scan`, which accumulates state for each event.
    It is roughly equivalent to the `List.fold` function that we have seen used with
    lists. In this case, the accumulated state is just a counter.
  prefs: []
  type: TYPE_NORMAL
- en: And then, for each event, the count is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this functional approach, we didn't have any mutable state, and
    we didn't need to create any special classes.
  prefs: []
  type: TYPE_NORMAL
- en: Merging multiple event streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a final example, we'll look at merging multiple event streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a requirement based on the well-known "FizzBuzz" problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: First let's create some code that both implementations can use.
  prefs: []
  type: TYPE_NORMAL
- en: We'll want a generic event type that captures the timer id and the time of the
    tick.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: And then we need a utility function to see if two events are simultaneous. We'll
    be generous and allow a time difference of up to 50ms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: In the imperative design, we'll need to keep track of the previous event, so
    we can compare them. And we'll need special case code for the first time, when
    the previous event doesn't exist
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Now the code is beginning to get ugly fast! Already we have mutable state, complex
    conditional logic, and special cases, just for such a simple requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: It does work, but are you sure the code is not buggy? Are you likely to accidentally
    break something if you change it?
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this imperative code is that it has a lot of noise that obscures
    the the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Can the functional version do better? Let's see!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create *two* event streams, one for each timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we convert each event on the "raw" event streams into our FizzBuzz event
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Now, to see if two events are simultaneous, we need to compare them from the
    two different streams somehow.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s actually easier than it sounds, because we can:'
  prefs: []
  type: TYPE_NORMAL
- en: 'combine the two streams into a single stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then create pairs of sequential events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then test the pairs to see if they are simultaneous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then split the input stream into two new output streams based on that test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the actual code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can split the `nonSimultaneousStream` again, based on the event
    id:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review so far. We have started with the two original event streams and
    from them created four new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`combinedStream` contains all the events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simultaneousStream` contains only the simultaneous events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fizzStream` contains only the non-simultaneous events with id=3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buzzStream` contains only the non-simultaneous events with id=5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now all we need to do is attach behavior to each stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s all the code in one complete set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: The code might seem a bit long winded, but this kind of incremental, step-wise
    approach is very clear and self-documenting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of this style are:'
  prefs: []
  type: TYPE_NORMAL
- en: I can see that it meets the requirements just by looking at it, without even
    running it. Not so with the imperative version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a design point of view, each final "output" stream follows the single responsibility
    principle -- it only does one thing -- so it is very easy to associate behavior
    with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code has no conditionals, no mutable state, no edge cases. It would be
    easy to maintain or change, I hope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is easy to debug. For example, I could easily "tap" the output of the `simultaneousStream`
    to see if it contains what I think it contains:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: This would be much harder in the imperative version.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional Reactive Programming (known as FRP) is a big topic, and we've only
    just touched on it here. I hope this introduction has given you a glimpse of the
    usefulness of this way of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more, see the documentation for the F# [Observable module](http://msdn.microsoft.com/en-us/library/ee370313),
    which has the basic transformations used above. And there is also the [Reactive
    Extensions (Rx)](http://msdn.microsoft.com/en-us/library/hh242985%28v=vs.103%29)
    library which shipped as part of .NET 4\. That contains many other additional
    transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Completeness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Completeness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final set of posts, we will look at some other aspects of F# under the
    theme of "completeness".
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages coming from the academic world tend to focus on elegance
    and purity over real-world usefulness, while more mainstream business languages
    such as C# and Java are valued precisely because they are pragmatic; they can
    work in a wide array of situations and have extensive tools and libraries to meet
    almost every need. In other words, to be useful in the enterprise, a language
    needs to be *complete*, not just well-designed.
  prefs: []
  type: TYPE_NORMAL
- en: F# is unusual in that it successfully bridges both worlds. Although all the
    examples so far have focused on F# as an elegant functional language, it does
    support an object-oriented paradigm as well, and can integrate easily with other
    .NET languages and tools. As a result, F# is not a isolated island, but benefits
    from being part of the whole .NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The other aspects that make F# "complete" are being an official .NET language
    (with all the support and documentation that that entails) and being designed
    to work in Visual Studio (which provides a nice editor with IntelliSense support,
    a debugger, and so on). These benefits should be obvious and won't be discussed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this last section, we''ll focus on two particular areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Seamless interoperation with .NET libraries**. Obviously, there can be a
    mismatch between the functional approach of F# and the imperative approach that
    is designed into the base libraries. We''ll look at some of the features of F#
    that make this integration easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full support for classes and other C# style code**. F# is designed as a hybrid
    functional/OO language, so it can do almost everything that C# can do as well.
    We''ll have a quick tour of the syntax for these other features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless interoperation with .NET libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seamless interoperation with .NET libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen many examples of F#'s use with the .NET libraries, such
    as using `System.Net.WebRequest` and `System.Text.RegularExpressions`. And the
    integration was indeed seamless.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex requirements, F# natively supports .NET classes, interfaces,
    and structures, so the interop is still very straightforward. For example, you
    can write an `ISomething` interface in C# and have the implementation be done
    in F#.
  prefs: []
  type: TYPE_NORMAL
- en: But not only can F# call into existing .NET code, it can also expose almost
    any .NET API back to other languages. For example, you can write classes and methods
    in F# and expose them to C#, VB or COM. You can even do the above example backwards
    -- define an `ISomething` interface in F# and have the implementation be done
    in C#! The benefit of all this is that you don't have to discard any of your existing
    code base; you can start using F# for some things while retaining C# or VB for
    others, and pick the best tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the tight integration though, there are a number of nice features
    in F# that often make working with .NET libraries more convenient than C# in some
    ways. Here are some of my favorites:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `TryParse` and `TryGetValue` without passing an "out" parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can resolve method overloads by using argument names, which also helps with
    type inference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use "active patterns" to convert .NET APIs into more friendly code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can dynamically create objects from an interface such as `IDisposable` without
    creating a concrete class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mix and match "pure" F# objects with existing .NET APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TryParse and TryGetValue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TryParse` and `TryGetValue` functions for values and dictionaries are frequently
    used to avoid extra exception handling. But the C# syntax is a bit clunky. Using
    them from F# is more elegant because F# will automatically convert the function
    into a tuple where the first element is the function return value and the second
    is the "out" parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Named arguments to help type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C# (and .NET in general), you can have overloaded methods with many different
    parameters. F# can have trouble with this. For example, here is an attempt to
    create a `StreamReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that F# does not know if the argument is supposed to be a string
    or a stream. You could explicitly specify the type of the argument, but that is
    not the F# way!
  prefs: []
  type: TYPE_NORMAL
- en: Instead, a nice workaround is enabled by the fact that in F#, when calling methods
    in .NET libraries, you can specify named arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: In many cases, such as the one above, just using the argument name is enough
    to resolve the type issue. And using explicit argument names can often help to
    make the code more legible anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Active patterns for .NET functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many situations where you want to use pattern matching against .NET
    types, but the native libraries do not support this. Earlier, we briefly touched
    on the F# feature called "active patterns" which allows you to dynamically create
    choices to match on. This can be very for useful .NET integration.
  prefs: []
  type: TYPE_NORMAL
- en: A common case is that a .NET library class has a number of mutually exclusive
    `isSomething`, `isSomethingElse` methods, which have to be tested with horrible
    looking cascading if-else statements. Active patterns can hide all the ugly testing,
    letting the rest of your code use a more natural approach.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here's the code to test for various `isXXX` methods for `System.Char`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the choices are defined, the normal code can be straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Another common case is when you have to parse text or error codes to determine
    the type of an exception or result. Here's an example that uses an active pattern
    to parse the error number associated with `SqlExceptions`, making them more palatable.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set up the active pattern matching on the error number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use these patterns when processing SQL commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Creating objects directly from an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# has another useful feature called "object expressions". This is the ability
    to directly create objects from an interface or abstract class without having
    to define a concrete class first.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, we create some objects that implement `IDisposable` using
    a `makeResource` helper function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'The example also demonstrates how the "`use`" keyword automatically disposes
    a resource when it goes out of scope. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Mixing .NET interfaces with pure F# types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to create instances of an interface on the fly means that it is
    easy to mix and match interfaces from existing APIs with pure F# types.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say that you have a preexisting API which uses the `IAnimal` interface,
    as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: But we want to have all the benefits of pattern matching, etc, so we have created
    pure F# types for cats and dogs instead of classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: But using this pure F# approach means that that we cannot pass the cats and
    dogs to the `showTheNoiseAnAnimalMakes` function directly.
  prefs: []
  type: TYPE_NORMAL
- en: However, we don't have to create new sets of concrete classes just to implement
    `IAnimal`. Instead, we can dynamically create the `IAnimal` interface by extending
    the pure F# types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is some test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: This approach gives us the best of both worlds. Pure F# types internally, but
    the ability to convert them into interfaces as needed to interface with libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Using reflection to examine F# types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# gets the benefit of the .NET reflection system, which means that you can
    do all sorts of interesting things that are not directly available to you using
    the syntax of the language itself. The `Microsoft.FSharp.Reflection` namespace
    has a number of functions that are designed to help specifically with F# types.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is a way to print out the fields in a record type, and the
    choices in a union type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Anything C# can do...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anything C# can do...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As should be apparent, you should generally try to prefer functional-style code
    over object-oriented code in F#, but in some situations, you may need all the
    features of a fully fledged OO language ? classes, inheritance, virtual methods,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: So just to conclude this section, here is a whirlwind tour of the F# versions
    of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these will be dealt with in much more depth in a later series on .NET
    integration. But I won't cover some of the more obscure ones, as you can read
    about them in the MSDN documentation if you ever need them.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, here are some examples of an interface, an abstract class, and a concrete
    class that inherits from the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Classes can have multiple constructors, mutable properties, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# supports generics and all the associated constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# supports not just classes, but the .NET struct types as well, which can help
    to boost performance in certain cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# can create exception classes, raise them and catch them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Extension methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as in C#, F# can extend existing classes with extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Parameter arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like C#'s variable length "params" keyword, this allows a variable length
    list of arguments to be converted to a single array parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# classes can have events, and the events can be triggered and responded to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# can do delegates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# supports CLI enums types, which look similar to the "union" types, but are
    actually different behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Working with the standard user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, F# can work with the WinForms and WPF user interface libraries, just
    like C#.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a trivial example of opening a form and handling a click event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Why use F#: Conclusion'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why use F#: Conclusion'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This completes the tour of F# features. I hope that the examples have given
    you some appreciation of the power of F# and functional programming. If you have
    any comments on the series as a whole, please leave them at the bottom of this
    page.
  prefs: []
  type: TYPE_NORMAL
- en: In later series I hope to go deeper into data structures, pattern matching,
    list processing, asynchronous and parallel programming, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: But before those, I recommend you read the ["thinking functionally"](thinking-functionally.html)
    series, which will help you understand functional programming at a deeper level.
  prefs: []
  type: TYPE_NORMAL
