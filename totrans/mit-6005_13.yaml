- en: 'Reading 13: Interfaces'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The topic of today’s class is interfaces: separating the interface of an abstract
    data type from its implementation, and using Java `interface` types to enforce
    that separation.'
  prefs: []
  type: TYPE_NORMAL
- en: After today’s class, you should be able to define ADTs with interfaces, and
    write classes that implement interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,interfaces/rEFM6lvEQsY)'
  prefs: []
  type: TYPE_NORMAL
- en: Java’s `interface` is a useful language mechanism for expressing an abstract
    data type. An interface in Java is a list of method signatures, but no method
    bodies. A class *implements* an interface if it declares the interface in its
    `implements` clause, and provides method bodies for all of the interface’s methods.
    So one way to define an abstract data type in Java is as an interface, with its
    implementation as a class implementing that interface.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of this approach is that the interface specifies the contract
    for the client and nothing more. The interface is all a client programmer needs
    to read to understand the ADT. The client can’t create inadvertent dependencies
    on the ADT’s rep, because instance variables can’t be put in an interface at all.
    The implementation is kept well and truly separated, in a different class altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is that multiple different representations of the abstract
    data type can co-exist in the same program, as different classes implementing
    the interface. When an abstract data type is represented just as a single class,
    without an interface, it’s harder to have multiple representations. In the [`MyString`
    example from *Abstract Data Types*](../11-abstract-data-types/#example_different_representations_for_strings),
    `MyString` was a single class. We explored two different representations for `MyString`,
    but we couldn’t have both representations for the ADT in the same program.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s static type checking allows the compiler to catch many mistakes in implementing
    an ADT’s contract. For instance, it is a compile-time error to omit one of the
    required methods, or to give a method the wrong return type. Unfortunately, the
    compiler doesn’t check for us that the code adheres to the specs of those methods
    that are written in documentation comments.
  prefs: []
  type: TYPE_NORMAL
- en: For the details of how to define interfaces in Java, consult the [Java Tutorials
    section on interfaces](http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html).
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Java interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this Java interface and Java class, which are intended to implement
    an immutable set data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The line labeled `A` is a problem because Java interfaces can’t have constructors.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: The line labeled `B` is a problem because `Set` mentions `ArraySet`, but `ArraySet`
    also mentions `Set`, which is circular.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: The line labeled `B` is a problem because it isn’t representation-independent.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '`ArraySet` doesn’t correctly implement `Set` because it’s missing the `contains()`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '`ArraySet` doesn’t correctly implement `Set` because it includes a method that
    `Set` doesn’t have.'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '`ArraySet` doesn’t correctly implement `Set` because `ArraySet` is mutable
    while `Set` is immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Subtypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,subtypes/rHQxjghbGY4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that a *type* is a set of values. The Java [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    type is defined by an interface. If we think about all possible `List` values,
    none of them are `List` objects: we cannot create instances of an interface. Instead,
    those values are all `ArrayList` objects, or `LinkedList` objects, or objects
    of another class that implements `List`. A *subtype* is simply a subset of the
    *supertype*: `ArrayList` and `LinkedList` are subtypes of `List`.'
  prefs: []
  type: TYPE_NORMAL
- en: '“B is a subtype of A” means “every B is an A.” In terms of specifications:
    “every B satisfies the specification for A.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'That means B is only a subtype of A if B’s specification is at least as strong
    as A’s specification. When we declare a class that implements an interface, the
    Java compiler enforces part of this requirement automatically: for example, it
    ensures that every method in A appears in B, with a compatible type signature.
    Class B cannot implement interface A without implementing all of the methods declared
    in A.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the compiler cannot check that we haven’t weakened the specification in
    other ways: strengthening the precondition on some inputs to a method, weakening
    a postcondition, weakening a guarantee that the interface abstract type advertises
    to clients. If you declare a subtype in Java — implementing an interface is our
    current focus — then you must ensure that the subtype’s spec is at least as strong
    as the supertype’s.'
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Immutable shapes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define an interface for rectangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It follows that every square is a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Does `ImmutableSquare.getWidth()` satisfy the spec of `ImmutableRectangle.getWidth()`?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: Does `ImmutableSquare.getHeight()` satisfy the spec of `ImmutableRectangle.getHeight()`?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: Does the whole `ImmutableSquare` spec satisfy the `ImmutableRectangle` spec?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Mutable shapes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Surely every square is still a rectangle?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For each possible `MutableSquare.setSize(..)` implementation below, is it a
    valid implementation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <select class="form-control"><option>No – stronger precondition</option>,<option>Yes
    – weaker precondition</option>,<option>Yes – stronger postcondition</option>,<option>No
    – weaker postcondition</option>,<option>Specifications are incomparable</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <select class="form-control"><option>No – stronger precondition</option>,<option>Yes
    – weaker precondition</option>,<option>Yes – stronger postcondition</option>,<option>No
    – weaker postcondition</option>,<option>Specifications are incomparable</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <select class="form-control"><option>No – stronger precondition</option>,<option>Yes
    – weaker precondition</option>,<option>Yes – stronger postcondition</option>,<option>No
    – weaker postcondition</option>,<option>Specifications are incomparable</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <select class="form-control"><option>No – stronger precondition</option>,<option>Yes
    – weaker precondition</option>,<option>Yes – stronger postcondition</option>,<option>No
    – weaker postcondition</option>,<option>Specifications are incomparable</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: `MyString`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,example_mystring/yZiA4P1Yks8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit [`MyString`](../11-abstract-data-types/#example_different_representations_for_strings).
    Using an interface instead of a class for the ADT, we can support multiple implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll skip the static `valueOf` method and come back to it in a minute. Instead,
    let’s go ahead using a different technique from our [toolbox of ADT concepts in
    Java](../11-abstract-data-types/#realizing_adt_concepts_in_java): constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our first implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the optimized implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Compare these classes to the [implementations of `MyString` in *Abstract Data
    Types*](../11-abstract-data-types/#example_different_representations_for_strings).
    Notice how the code that previously appeared in static `valueOf` methods now appears
    in the constructors, slightly changed to refer to the rep of `this`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also notice the use of [`@Override`](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).
    This annotation informs the compiler that the method must have the same signature
    as one of the methods in the interface we’re implementing. But since the compiler
    already checks that we’ve implemented all of the interface methods, the primary
    value of `@Override` here is for readers of the code: it tells us to look for
    the spec of that method in the interface. Repeating the spec wouldn’t be DRY,
    but saying nothing at all makes the code harder to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And notice the private empty constructors we use to make new instances in `substring(..)`
    before we fill in their reps with data. We didn’t have to write these empty constructors
    before because Java provides them by default when we don’t declare any others.
    Adding the constructors that take `boolean b` means we have to declare the empty
    constructors explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know good ADTs scrupulously [preserve their own invariants](../12-abstraction-functions-rep-invariants/#invariants),
    these do-nothing constructors are a **bad** pattern: they don’t assign any values
    to the rep, and they certainly don’t establish any invariants. We should strongly
    consider revising the implementation. Since `MyString` is immutable, a starting
    point would be making all the fields `final`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'How will clients use this ADT? Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks very similar to the code we write to use the Java collections
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this pattern **breaks the abstraction barrier** we’ve worked
    so hard to build between the abstract type and its concrete representations. Clients
    must know the name of the concrete representation class. Because interfaces in
    Java cannot contain constructors, they must directly call one of the concrete
    class’ constructors. The spec of that constructor won’t appear anywhere in the
    interface, so there’s no static guarantee that different implementations will
    even provide the same constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, (as of Java 8) interfaces *are* allowed to contain static methods,
    so we can implement the creator operation `valueOf` as a static factory method
    in the interface `MyString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now a client can use the ADT without breaking the abstraction barrier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Code review
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the code for `FastMyString`. Which of these are useful criticisms:'
  prefs: []
  type: TYPE_NORMAL
- en: I wish the abstraction function was documented
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: I wish the representation invariant was documented
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: I wish the rep fields were `final` so they could not be reassigned
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: I wish the private constructor was public so clients could use it to construct
    empty strings
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: I wish the `charAt` specification did not expose that the rep contains individual
    characters
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: I wish the `charAt` implementation behaved more helpfully when `i` is greater
    than the length of the string
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Generic `Set<E>`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java’s collection classes provide a good example of the idea of separating interface
    and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider as an example one of the ADTs from the Java collections library,
    `Set`. `Set` is the ADT of finite sets of elements of some other type `E`. Here
    is a simplified version of the `Set` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Set` is an example of a *generic type*: a type whose specification is in terms
    of a placeholder type to be filled in later. Instead of writing separate specifications
    and implementations for `Set<String>`, `Set<Integer>`, and so on, we design and
    implement one `Set<E>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can match Java interfaces with our classification of ADT operations, starting
    with a creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make` operation is implemented as a static factory method. Clients will
    write code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<String> strings = Set.make();`'
  prefs: []
  type: TYPE_NORMAL
- en: and the compiler will understand that the new `Set` is a set of `String` objects.
    (We write `<E>` at the front of this signature because `make` is a static method.
    It needs its own generic type parameter, separate from the `E` we’re using in
    instance method specs.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next we have two observer methods. Notice how the specs are in terms of our
    abstract notion of a set; it would be malformed to mention the details of any
    particular implementation of sets with particular private fields. These specs
    should apply to any valid implementation of the set ADT.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The story for these mutators is basically the same as for the observers. We
    still write specs at the level of our abstract model of sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Java Tutorials, read these pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lesson: Interfaces](http://docs.oracle.com/javase/tutorial/collections/interfaces/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Set Interface](http://docs.oracle.com/javase/tutorial/collections/interfaces/set.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Set Implementations](http://docs.oracle.com/javase/tutorial/collections/implementations/set.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The List Interface](http://docs.oracle.com/javase/tutorial/collections/interfaces/list.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List Implementations](http://docs.oracle.com/javase/tutorial/collections/implementations/list.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Collection interfaces & implementations
  prefs: []
  type: TYPE_NORMAL
- en: Assume the following lines of code are run in sequence, and that any lines of
    code that don’t compile are simply commented out so that the rest of the code
    can compile.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses two methods from [`Collections`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html),
    so you might need to consult their documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Choose the most specific answer to each question.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`set` now points to:'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>a HashSet object</option>,<option>an object
    that implements the Set interface</option>,<option>null</option>,<option>this
    line won’t compile</option></select>(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`set` now points to:'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>a HashSet object</option>,<option>a Collections
    object</option>,<option>an object that implements the Set interface</option>,<option>null</option>,<option>this
    line won’t compile</option></select>(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`set` now points to:'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>a HashSet object</option>,<option>a Collections
    object</option>,<option>an object that implements the Set interface</option>,<option>null</option>,<option>this
    line won’t compile</option></select>(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`set` now points to:'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>a HashSet object</option>,<option>a Set
    object</option>,<option>an object that implements the Set interface</option>,<option>null</option>,<option>this
    line won’t compile</option></select>(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`set` now points to:'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>a HashSet object</option>,<option>an object
    that implements the Set interface</option>,<option>an object that implements the
    List interface</option>,<option>null</option>,<option>this line won’t compile</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[data:text/html,<style>body { font-family: "Helvetica Neue", Helvetica, Arial,
    sans-serif; }</style>Click a method name to see its Javadoc here.](data:text/html,<style>body
    { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }</style>Click
    a method name to see its Javadoc here.)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Generic Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we want to implement the generic `Set<E>` interface above. We can either
    write a non-generic implementation that replaces `E` with a specific type, or
    a generic implementation that keeps the placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic interface, non-generic implementation.** Let’s implement `Set<E>`
    for a *particular* type `E`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Abstraction Functions & Rep Invariants*](../12-abstraction-functions-rep-invariants/#rep_invariant_and_abstraction_function)
    we looked at `CharSet`, which represents a set of characters. The [example code
    for `CharSet`](https://github.com/mit6005/fa16-ex12-adt-examples/tree/master/src/charset)
    includes a generic [`Set` interface](https://github.com/mit6005/fa16-ex12-adt-examples/blob/master/src/charset/Set.java)
    and each of the implementations `CharSet1`/`2`/`3` declare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When the interface mentions placeholder type `E`, the `CharSet` implementations
    replace `E` with `Character`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The representations used by `CharSet1`/`2`/`3` are not suited for representing
    sets of arbitrary-type elements. The `String` reps, for example, cannot represent
    a `Set<Integer>` without careful work to define a new rep invariant and abstraction
    function that handles multi-digit numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic interface, generic implementation.** We can also implement the generic
    `Set<E>` interface without picking a type for `E`. In that case, we write our
    code blind to the actual type that clients will choose for `E`. Java’s [`HashSet`](http://docs.oracle.com/javase/8/docs/api/?java/util/HashSet.html)
    does that for `Set`. Its declaration looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A generic implementation can only rely on details of the placeholder types that
    are included in the interface’s specification. We’ll see in a future reading how
    `HashSet` relies on methods that every type in Java is required to implement —
    and only on those methods, because it can’t rely on methods declared in any specific
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Why Interfaces?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_13_interfaces,why_interfaces/hqCFnF0NjLs)'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are used pervasively in real Java code. Not every class is associated
    with an interface, but there are a few good reasons to bring an interface into
    the picture.
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation for both the compiler and for humans**. Not only does an interface
    help the compiler catch ADT implementation bugs, but it is also much more useful
    for a human to read than the code for a concrete implementation. Such an implementation
    intersperses ADT-level types and specs with implementation details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allowing performance trade-offs**. Different implementations of the ADT can
    provide methods with very different performance characteristics. Different applications
    may work better with different choices, but we would like to code these applications
    in a way that is representation-independent. From a correctness standpoint, it
    should be possible to drop in any new implementation of a key ADT with simple,
    localized code changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional methods**. `List` from the Java standard library marks all mutator
    methods as optional. By building an implementation that does not support these
    methods, we can provide immutable lists. Some operations are hard to implement
    with good enough performance on immutable lists, so we want mutable implementations,
    too. Code that doesn’t call mutators can be written to work automatically with
    either kind of list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods with intentionally underdetermined specifications**. An ADT for finite
    sets could leave unspecified the element order one gets when converting to a list.
    Some implementations might use slower method implementations that manage to keep
    the set representation in some sorted order, allowing quick conversion to a sorted
    list. Other implementations might make many methods faster by not bothering to
    support conversion to sorted lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple views of one class**. A Java class may implement multiple interfaces.
    For instance, a user interface widget displaying a drop-down list is natural to
    view as both a widget and a list. The class for this widget could implement both
    interfaces. In other words, we don’t implement an ADT multiple times just because
    we are choosing different data structures; we may make multiple implementations
    because many different sorts of objects may also be seen as special cases of the
    ADT, among other useful perspectives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More and less trustworthy implementations**. Another reason to implement
    an interface multiple times might be that it is easy to build a simple implementation
    that you believe is correct, while you can work harder to build a fancier version
    that is more likely to contain bugs. You can choose implementations for applications
    based on how bad it would be to get bitten by a bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Realizing ADT Concepts in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve now completed our [Java toolbox of ADT concepts](../11-abstract-data-types/#realizing_adt_concepts_in_java)
    from the first ADTs reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ADT concept | Ways to do it in Java | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| Abstract data type | Single class | [`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Interface + class(es) | [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    and [`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Enum | [`DayOfWeek`](http://docs.oracle.com/javase/8/docs/api/?java/time/DayOfWeek.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Creator operation | Constructor | [`ArrayList()`](http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static (factory) method | [`Collections.<wbr>singletonList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-),
    [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Constant | [`BigInteger.ZERO`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Observer operation | Instance method | [`List.get()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static method | [`Collections.max()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Producer operation | Instance method | [`String.trim()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static method | [`Collections.<wbr>unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mutator operation | Instance method | [`List.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static method | [`Collections.copy()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Representation | `private` fields |  |'
  prefs: []
  type: TYPE_TB
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose you have an abstract data type for rational numbers, similar to [the
    one we discussed in *Abstraction Functions & Rep Invariants*](../12-abstraction-functions-rep-invariants/#documenting_the_af_ri_and_safety_from_rep_exposure),
    which is currently represented as a Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You decide to change `RatNum` to a Java interface instead, along with an implementation
    class called `IntFraction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For each piece of code below from the old `RatNum` class, identify it and decide
    where it should go in the new interface—plus—implementation-class design.
  prefs: []
  type: TYPE_NORMAL
- en: Interface + implementation 1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  prefs: []
  type: TYPE_TB
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Interface + implementation 2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  prefs: []
  type: TYPE_TB
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Interface + implementation 3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  prefs: []
  type: TYPE_TB
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Interface + implementation 4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  prefs: []
  type: TYPE_TB
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Interface + implementation 5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  prefs: []
  type: TYPE_TB
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Interface + implementation 6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '| This piece of code is: (check all that apply)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer) | It should be put in:(missing answer)(missing answer)(missing answer)
    |'
  prefs: []
  type: TYPE_TB
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java interfaces help us formalize the idea of an abstract data type as a set
    of operations that must be supported by a type.
  prefs: []
  type: TYPE_NORMAL
- en: This helps make our code…
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs.** An ADT is defined by its operations, and interfaces do
    just that. When clients use an interface type, static checking ensures that they
    only use methods defined by the interface. If the implementation class exposes
    other methods — or worse, has visible representation — the client can’t accidentally
    see or depend on them. When we have multiple implementations of a data type, interfaces
    provide static checking of the method signatures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand.** Clients and maintainers know exactly where to look
    for the specification of the ADT. Since the interface doesn’t contain instance
    fields or implementations of instance methods, it’s easier to keep details of
    the implementation out of the specifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change.** We can easily add new implementations of a type by adding
    classes that implement interface. If we avoid constructors in favor of static
    factory methods, clients will only see the interface. That means we can switch
    which implementation class clients are using without changing their code at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
