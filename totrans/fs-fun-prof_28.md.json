["```\ninterface IConfiguration\n{   \n    string GetConfigFilename();\n} \n```", "```\nvar filename = config.GetConfigFilename();\n// open file\n// write new config\n// close file \n```", "```\ninterface IConfiguration\n{   \n    void SetConfig(string key, string value);\n} \n```", "```\nconfig.SetConfig(\"DontShowThisMessageAgain\", \"True\"); \n```", "```\nenum MessageFlag {\n   ShowThisMessageAgain,\n   DontShowThisMessageAgain\n   }\n\ninterface IConfiguration\n{   \n    void SetMessageFlag(MessageFlag value);\n    void SetConnectionString(ConnectionString value);\n    void SetBackgroundColor(Color value);\n} \n```", "```\ninterface IWarningMessageConfiguration\n{   \n    void SetMessageFlag(MessageFlag value);\n} \n```", "```\ninterface IWarningMessageConfiguration\n{   \n    void SetMessageFlag(MessageFlag value);\n} \n```", "```\nAction<MessageFlag> messageFlagCapability = // get function; \n```", "```\nlet messageFlagCapability = // get function; \n```", "```\ninterface IConfigurationCapabilities\n{   \n    Action<MessageFlag> SetMessageFlag();\n    Action<ConnectionString> SetConnectionString();\n    Action<Color> SetBackgroundColor();\n} \n```", "```\n// at startup\nvar messageFlagCapability = \n    configurationCapabilities.SetMessageFlag()\nvar appWindow = new ApplicationWindow(messageFlagCapability)\n\n// and in the UI class\nclass ApplicationWindow\n{\n    // pass in capability in the constructor \n    // just as you would an interface\n    ApplicationWindow(Action<MessageFlag> messageFlagCapability)\n    {  \n        // set fields\n    }\n\n    // setup the check box and register the \"OnCheckboxChecked\" handler\n\n    // use the capability when the event happens\n    void OnCheckboxChecked(CheckBox sender) {\n        messageFlagCapability(sender.IsChecked)\n    }\n} \n```", "```\nmodule Config =\n\n    type MessageFlag = ShowThisMessageAgain | DontShowThisMessageAgain\n    type ConnectionString = ConnectionString of string\n    type Color = System.Drawing.Color\n\n    type ConfigurationCapabilities = {\n        GetMessageFlag : unit -> MessageFlag \n        SetMessageFlag : MessageFlag -> unit\n        GetBackgroundColor : unit -> Color \n        SetBackgroundColor : Color -> unit\n        GetConnectionString  : unit -> ConnectionString \n        SetConnectionString : ConnectionString -> unit\n        }\n\n    // a private store for demo purposes\n    module private ConfigStore =\n        let mutable MessageFlag = ShowThisMessageAgain \n        let mutable BackgroundColor = Color.White\n        let mutable ConnectionString = ConnectionString \"\"\n\n    // public capabilities\n    let configurationCapabilities = {\n        GetMessageFlag = fun () -> ConfigStore.MessageFlag \n        SetMessageFlag = fun flag -> ConfigStore.MessageFlag <- flag\n        GetBackgroundColor = fun () -> ConfigStore.BackgroundColor\n        SetBackgroundColor = fun color -> ConfigStore.BackgroundColor <- color\n        SetConnectionString = fun _ -> () // ignore\n        GetConnectionString = fun () -> ConfigStore.ConnectionString \n        SetConnectionString = fun connStr -> ConfigStore.ConnectionString <- connStr\n        } \n```", "```\nmodule AnnoyingPopupMessage = \n    open System.Windows.Forms\n\n    let createLabel() = \n        new Label(Text=\"You clicked the main window\", Dock=DockStyle.Top)\n\n    let createMessageFlagCheckBox capabilities  = \n        let getFlag,setFlag = capabilities \n        let ctrl= new CheckBox(Text=\"Don't show this annoying message again\", Dock=DockStyle.Bottom)\n        ctrl.Checked <- getFlag()\n        ctrl.CheckedChanged.Add (fun _ -> ctrl.Checked |> setFlag)\n        ctrl   // return new control\n\n    let createOkButton (dialog:Form) = \n        let ctrl= new Button(Text=\"OK\",Dock=DockStyle.Bottom)\n        ctrl.Click.Add (fun _ -> dialog.Close())\n        ctrl\n\n    let createForm capabilities = \n        let form = new Form(Text=\"Annoying Popup Message\", Width=300, Height=150)\n        form.FormBorderStyle <- FormBorderStyle.FixedDialog\n        form.StartPosition <- FormStartPosition.CenterParent\n\n        let label = createLabel()\n        let messageFlag = createMessageFlagCheckBox capabilities\n        let okButton = createOkButton form\n        form.Controls.Add label \n        form.Controls.Add messageFlag \n        form.Controls.Add okButton \n        form \n```", "```\nmodule UserInterface = \n    open System.Windows.Forms\n    open System.Drawing\n\n    let showPopupMessage capabilities owner = \n        let getFlag,setFlag = capabilities \n        let popupMessage = AnnoyingPopupMessage.createForm (getFlag,setFlag) \n        popupMessage.Owner <- owner \n        popupMessage.ShowDialog() |> ignore // don't care about result\n\n    let showColorDialog capabilities owner = \n        let getColor,setColor = capabilities \n        let dlg = new ColorDialog(Color=getColor())\n        let result = dlg.ShowDialog(owner)\n        if result = DialogResult.OK then\n            dlg.Color |> setColor\n\n    let createClickMeLabel capabilities owner = \n        let getFlag,_ = capabilities \n        let ctrl= new Label(Text=\"Click me\", Dock=DockStyle.Fill, TextAlign=ContentAlignment.MiddleCenter)\n        ctrl.Click.Add (fun _ -> \n            if getFlag() then showPopupMessage capabilities owner)\n        ctrl  // return new control\n\n    let createChangeBackColorButton capabilities owner = \n        let ctrl= new Button(Text=\"Change background color\", Dock=DockStyle.Bottom)\n        ctrl.Click.Add (fun _ -> showColorDialog capabilities owner)\n        ctrl\n\n    let createResetMessageFlagButton capabilities = \n        let setFlag = capabilities \n        let ctrl= new Button(Text=\"Show popup message again\", Dock=DockStyle.Bottom)\n        ctrl.Click.Add (fun _ -> setFlag Config.ShowThisMessageAgain)\n        ctrl\n\n    let createMainForm capabilities = \n        // get the individual component capabilities from the parameter\n        let getFlag,setFlag,getColor,setColor = capabilities \n\n        let form = new Form(Text=\"Capability example\", Width=500, Height=300)\n        form.BackColor <- getColor() // update the form from the config\n\n        // transform color capability to change form as well\n        let newSetColor color = \n            setColor color           // change config\n            form.BackColor <- color  // change form as well \n\n        // transform flag capabilities from domain type to bool\n        let getBoolFlag() = \n            getFlag() = Config.ShowThisMessageAgain \n        let setBoolFlag bool = \n            if bool \n            then setFlag Config.ShowThisMessageAgain \n            else setFlag Config.DontShowThisMessageAgain \n\n        // set up capabilities for child objects\n        let colorDialogCapabilities = getColor,newSetColor \n        let popupMessageCapabilities = getBoolFlag,setBoolFlag\n\n        // setup controls with their different capabilities\n        let clickMeLabel = createClickMeLabel popupMessageCapabilities form\n        let changeColorButton = createChangeBackColorButton colorDialogCapabilities form\n        let resetFlagButton = createResetMessageFlagButton setFlag \n\n        // add controls\n        form.Controls.Add clickMeLabel \n        form.Controls.Add changeColorButton\n        form.Controls.Add resetFlagButton \n\n        form  // return form \n```", "```\nmodule Startup = \n\n    // set up capabilities\n    let configCapabilities = Config.configurationCapabilities\n    let formCapabilities = \n        configCapabilities.GetMessageFlag, \n        configCapabilities.SetMessageFlag,\n        configCapabilities.GetBackgroundColor,\n        configCapabilities.SetBackgroundColor\n\n    // start\n    let form = UserInterface.createMainForm formCapabilities \n    form.ShowDialog() |> ignore \n```", "```\npublic class CustomerDatabase\n{\n    public CustomerData GetCustomer(CustomerId id, IPrincipal principal) {  \n        if ( CustomerIdBelongsToPrincipal(id, principal) || \n             principal.IsInRole(\"CustomerAgent\") )\n        {\n            // get customer data\n        }\n        else\n        {\n            // throw authorization exception\n        }\n    }\n} \n```", "```\nlet getCustomer id principal = \n    if customerIdBelongsToPrincipal id principal ||\n       principal.IsInRole(\"CustomerAgent\") \n    then\n        // get customer data\n        Success \"CustomerData\"\n    else\n        Failure AuthorizationFailed \n```", "```\nclass CustomerDatabase\n{\n    // \"real\" code is hidden from public view\n    private CustomerData GetCustomer(CustomerId id) {  \n        // get customer data\n    }\n\n    // Get the capability to call GetCustomer\n    public Func<CustomerId,CustomerData> GetCustomerCapability(CustomerId id, IPrincipal principal)\n    {  \n        if ( CustomerIdBelongsToPrincipal(id, principal) || \n             principal.IsInRole(\"CustomerAgent\") )\n        {\n            // return the capability (the real method)\n            return GetCustomer;\n        }\n        else\n        {\n            // throw authorization exception\n        }\n    }\n} \n```", "```\nclass CustomerDatabase\n{\n    // \"real\" code is hidden from public view\n    private CustomerData GetCustomer(CustomerId id) {  \n        // get customer data\n    }\n\n    // Get the capability to call GetCustomer\n    public Func<CustomerData> GetCustomerCapability(CustomerId id, IPrincipal principal) {  \n        if ( CustomerIdBelongsToPrincipal(id, principal) || \n             principal.IsInRole(\"CustomerAgent\") )\n        {\n            // return the capability (the real method)\n            return ( () => GetCustomer(id) );\n        }\n        else\n        {\n            // throw authorization exception\n        }\n    }\n} \n```", "```\nclass CustomerDatabase\n{\n    // \"real\" code is hidden from public view\n    // and doesn't need any checking of identity or role\n    private CustomerData GetCustomer(CustomerId id) {  \n        // get customer data\n    }\n\n    // Get the capability to call GetCustomer. If not allowed, return None.\n    public Option<Func<CustomerData>> GetCustomerCapability(CustomerId id, IPrincipal principal)\n    {\n        if (CustomerIdBelongsToPrincipal(id, principal) ||\n             principal.IsInRole(\"CustomerAgent\"))\n        {\n            // return the capability (the real method)\n            return Option<Func<CustomerData>>.Some( () => GetCustomer(id) );\n        }\n        else\n        {\n            return Option<Func<CustomerData>>.None();\n        }\n    }\n} \n```", "```\n// not accessible to the business layer\ninternal class CustomerDatabase\n{\n    // \"real\" code is hidden from public view\n    private CustomerData GetCustomer(CustomerId id) {  \n        // get customer data\n    }\n}\n\n// accessible to the business layer\npublic class CustomerDatabaseCapabilityProvider\n{\n    CustomerDatabase _customerDatabase;\n\n    // Get the capability to call GetCustomer\n    public Option<Func<CustomerData>> GetCustomerCapability(CustomerId id, IPrincipal principal)\n    {\n        if (CustomerIdBelongsToPrincipal(id, principal) ||\n             principal.IsInRole(\"CustomerAgent\"))\n        {\n            // return the capability (the real method)\n            return Option<Func<CustomerData>>.Some( () => _customerDatabase.GetCustomer(id) );\n        }\n        else\n        {\n            return Option<Func<CustomerData>>.None();\n        }\n    }\n} \n```", "```\n/// not accessible to the business layer\nmodule internal CustomerDatabase = \n    let getCustomer (id:CustomerId) :CustomerData = \n        // get customer data\n\n/// accessible to the business layer \nmodule CustomerDatabaseCapabilityProvider =         \n\n    // Get the capability to call getCustomer\n    let getCustomerCapability (id:CustomerId) (principal:IPrincipal) = \n        let principalId = GetIdForPrincipal(principal)\n        if (principalId = id) || principal.IsInRole(\"CustomerAgent\") then\n            Some ( fun () -> CustomerDatabase.getCustomer id )\n        else\n            None \n```", "```\nmodule CustomerCapabilityFilter =         \n\n    // Get the capability to use any function that has a CustomerId parameter\n    // but only if the caller has the same customer id or is a member of the \n    // CustomerAgent role.\n    let onlyForSameIdOrAgents (id:CustomerId) (principal:IPrincipal) (f:CustomerId -> 'a) = \n        let principalId = GetIdForPrincipal(principal)\n        if (principalId = id) || principal.IsInRole(\"CustomerAgent\") then\n            Some (fun () -> f id)\n        else\n            None \n```", "```\nmodule internal CustomerDatabase = \n    let getCustomer (id:CustomerId) = \n        // get customer data \n    let updateCustomer (id:CustomerId) (data:CustomerData) = \n        // update customer data \n```", "```\nlet principal = // from context\nlet id = // from context\n\n// attempt to get the capabilities\nlet getCustomerOnlyForSameIdOrAgents = \n    onlyForSameIdOrAgents id principal CustomerDatabase.getCustomer\n\nlet updateCustomerOnlyForSameIdOrAgents = \n    onlyForSameIdOrAgents id principal CustomerDatabase.updateCustomer \n```", "```\nval getCustomerOnlyForSameIdOrAgents : \n      (unit -> CustomerData) option\nval updateCustomerOnlyForSameIdOrAgents : \n      (unit -> CustomerData -> unit) option \n```", "```\nmatch getCustomerOnlyForSameIdOrAgents with\n| Some cap -> // create child component and pass in the capability\n| None ->     // return error saying that you don't have the capability to get the data \n```", "```\nmodule CustomerCapabilityFilter =         \n\n    let onlyForSameId (id:CustomerId) (principal:IPrincipal) (f:CustomerId -> 'a) = \n        if customerIdBelongsToPrincipal id principal then\n            Some (fun () -> f id)\n        else\n            None\n\n    let onlyForAgents (id:CustomerId) (principal:IPrincipal) (f:CustomerId -> 'a) = \n        if principal.IsInRole(\"CustomerAgent\") then\n            Some (fun () -> f id)\n        else\n            None \n```", "```\n// given a list of capability options, \n// return the first good one, if any\nlet first capabilityList = \n    capabilityList |> List.tryPick id \n```", "```\nlet getCustomerOnlyForSameIdOrAgents = \n    let f = CustomerDatabase.getCustomer\n    let cap1 = onlyForSameId id principal f\n    let cap2 = onlyForAgents id principal f \n    first [cap1; cap2]\n// val getCustomerOnlyForSameIdOrAgents : (CustomerId -> CustomerData) option \n```", "```\nlet onlyIfDuringBusinessHours (time:DateTime) f = \n    if time.Hour >= 8 && time.Hour <= 17 then\n        Some f\n    else\n        None \n```", "```\n// given a capability option, restrict it\nlet restrict filter originalCap = \n    originalCap\n    |> Option.bind filter \n```", "```\nlet getCustomerOnlyForAgentsInBusinessHours = \n    let f = CustomerDatabase.getCustomer\n    let cap1 = onlyForAgents id principal f \n    let restriction f = onlyIfDuringBusinessHours (DateTime.Now) f\n    cap1 |> restrict restriction \n```", "```\nlet getCustomerOnlyForSameId = \n    let f = CustomerDatabase.getCustomer\n    onlyForSameId id principal f\n\nlet getCustomerOnlyForSameId_OrForAgentsInBusinessHours = \n    let cap1 = getCustomerOnlyForSameId\n    let cap2 = getCustomerOnlyForAgentsInBusinessHours \n    first [cap1; cap2] \n```", "```\n/// Uses of the capability will be audited\nlet auditable capabilityName f = \n    fun x -> \n        // simple audit log!\n        printfn \"AUDIT: calling %s with %A\" capabilityName  x\n        // use the capability\n        f x\n\n/// Allow the function to be called once only\nlet onlyOnce f = \n    let allow = ref true\n    fun x -> \n        if !allow then   //! is dereferencing not negation!\n            allow := false\n            f x\n        else\n            Failure OnlyAllowedOnce\n\n/// Return a pair of functions: the revokable capability, \n/// and the revoker function\nlet revokable f = \n    let allow = ref true\n    let capability = fun x -> \n        if !allow then  //! is dereferencing not negation!\n            f x\n        else\n            Failure Revoked\n    let revoker() = \n        allow := false\n    capability, revoker \n```", "```\nmodule internal CustomerDatabase = \n    let updatePassword (id,password) = \n        Success \"OK\" \n```", "```\nlet updatePasswordWithAudit x = \n    auditable \"updatePassword\" CustomerDatabase.updatePassword x \n```", "```\nupdatePasswordWithAudit (1,\"password\") \nupdatePasswordWithAudit (1,\"new password\") \n```", "```\nAUDIT: calling updatePassword with (1, \"password\")\nAUDIT: calling updatePassword with (1, \"new password\") \n```", "```\nlet updatePasswordOnce = \n    onlyOnce CustomerDatabase.updatePassword \n```", "```\nupdatePasswordOnce (1,\"password\") |> printfn \"Result 1st time: %A\"\nupdatePasswordOnce (1,\"password\") |> printfn \"Result 2nd time: %A\" \n```", "```\nResult 1st time: Success \"OK\"\nResult 2nd time: Failure OnlyAllowedOnce \n```", "```\nlet revokableUpdatePassword, revoker = \n    revokable CustomerDatabase.updatePassword \n```", "```\nrevokableUpdatePassword (1,\"password\") |> printfn \"Result 1st time before revoking: %A\"\nrevokableUpdatePassword (1,\"password\") |> printfn \"Result 2nd time before revoking: %A\"\nrevoker()\nrevokableUpdatePassword (1,\"password\") |> printfn \"Result 3nd time after revoking: %A\" \n```", "```\nResult 1st time before revoking: Success \"OK\"\nResult 2nd time before revoking: Success \"OK\"\nResult 3nd time after revoking: Failure Revoked \n```", "```\nmodule Domain = \n    open Rop\n\n    type CustomerId = CustomerId of int\n    type CustomerData = CustomerData of string\n    type Password = Password of string\n\n    type FailureCase = \n        | AuthenticationFailed of string\n        | AuthorizationFailed\n        | CustomerNameNotFound of string\n        | CustomerIdNotFound of CustomerId\n        | OnlyAllowedOnce\n        | CapabilityRevoked \n```", "```\ntype GetCustomerCap = unit -> SuccessFailure<CustomerData,FailureCase> \n```", "```\nmodule Capabilities = \n    open Rop\n    open Domain\n\n    // capabilities\n    type GetCustomerCap = unit -> SuccessFailure<CustomerData,FailureCase>\n    type UpdateCustomerCap = unit -> CustomerData -> SuccessFailure<unit,FailureCase>\n    type UpdatePasswordCap = Password -> SuccessFailure<unit,FailureCase>\n\n    type CapabilityProvider = {\n        /// given a customerId and IPrincipal, attempt to get the GetCustomer capability\n        getCustomer : CustomerId -> IPrincipal -> GetCustomerCap option\n        /// given a customerId and IPrincipal, attempt to get the UpdateCustomer capability\n        updateCustomer : CustomerId -> IPrincipal -> UpdateCustomerCap option\n        /// given a customerId and IPrincipal, attempt to get the UpdatePassword capability\n        updatePassword : CustomerId -> IPrincipal -> UpdatePasswordCap option \n        } \n```", "```\nmodule Authentication = \n    open Rop\n    open Domain \n\n    let customerRole = \"Customer\"\n    let customerAgentRole = \"CustomerAgent\"\n\n    let makePrincipal name role = \n        let iden = GenericIdentity(name)\n        let principal = GenericPrincipal(iden,[|role|])\n        principal :> IPrincipal\n\n    let authenticate name = \n        match name with\n        | \"Alice\" | \"Bob\" -> \n            makePrincipal name customerRole  |> Success\n        | \"Zelda\" -> \n            makePrincipal name customerAgentRole |> Success\n        | _ -> \n            AuthenticationFailed name |> Failure \n\n    let customerIdForName name = \n        match name with\n        | \"Alice\" -> CustomerId 1 |> Success\n        | \"Bob\" -> CustomerId 2 |> Success\n        | _ -> CustomerNameNotFound name |> Failure\n\n    let customerIdOwnedByPrincipal customerId (principle:IPrincipal) = \n        principle.Identity.Name\n        |> customerIdForName \n        |> Rop.map (fun principalId -> principalId = customerId)\n        |> Rop.orElse false \n```", "```\nmodule Authorization = \n    open Rop\n    open Domain \n\n    let onlyForSameId (id:CustomerId) (principal:IPrincipal) (f:CustomerId -> 'a) = \n        if Authentication.customerIdOwnedByPrincipal id principal then\n            Some (fun () -> f id)\n        else\n            None\n\n    let onlyForAgents (id:CustomerId) (principal:IPrincipal) (f:CustomerId -> 'a) = \n        if principal.IsInRole(Authentication.customerAgentRole) then\n            Some (fun () -> f id)\n        else\n            None\n\n    let onlyIfDuringBusinessHours (time:DateTime) f = \n        if time.Hour >= 8 && time.Hour <= 17 then\n            Some f\n        else\n            None\n\n    // constrain who can call a password update function\n    let passwordUpdate (id:CustomerId) (principal:IPrincipal) (f:CustomerId*Password -> 'a) = \n        if Authentication.customerIdOwnedByPrincipal id principal then\n            Some (fun password -> f (id,password))\n        else\n            None\n\n    // return the first good capability, if any\n    let first capabilityList = \n        capabilityList |> List.tryPick id\n\n    // given a capability option, restrict it\n    let restrict filter originalCap = \n        originalCap\n        |> Option.bind filter \n\n    /// Uses of the capability will be audited\n    let auditable capabilityName principalName f = \n        fun x -> \n            // simple audit log!\n            let timestamp = DateTime.UtcNow.ToString(\"u\")\n            printfn \"AUDIT: User %s used capability %s at %s\" principalName capabilityName timestamp \n            // use the capability\n            f x\n\n    /// Return a pair of functions: the revokable capability, \n    /// and the revoker function\n    let revokable f = \n        let allow = ref true\n        let capability = fun x -> \n            if !allow then  //! is dereferencing not negation!\n                f x\n            else\n                Failure CapabilityRevoked\n        let revoker() = \n            allow := false\n        capability, revoker \n```", "```\nmodule CustomerDatabase = \n    open Rop\n    open System.Collections.Generic\n    open Domain \n\n    let private db = Dictionary<CustomerId,CustomerData>()\n\n    let getCustomer id = \n        match db.TryGetValue id with\n        | true, value -> Success value \n        | false, _ -> Failure (CustomerIdNotFound id)\n\n    let updateCustomer id data = \n        db.[id] <- data\n        Success ()\n\n    let updatePassword (id:CustomerId,password:Password) = \n        Success ()   // dummy implementation \n```", "```\nmodule BusinessServices =\n    open Rop\n    open Domain\n\n    // use the getCustomer capability\n    let getCustomer capability =\n        match capability() with\n        | Success data -> printfn \"%A\" data\n        | Failure err -> printfn \".. %A\" err\n\n    // use the updateCustomer capability\n    let updateCustomer capability =\n        printfn \"Enter new data: \"\n        let customerData = Console.ReadLine() |> CustomerData\n        match capability () customerData  with\n        | Success _ -> printfn \"Data updated\" \n        | Failure err -> printfn \".. %A\" err\n\n    // use the updatePassword capability\n    let updatePassword capability =\n        printfn \"Enter new password: \"\n        let password = Console.ReadLine() |> Password\n        match capability password  with\n        | Success _ -> printfn \"Password updated\" \n        | Failure err -> printfn \".. %A\" err \n```", "```\nmodule UserInterface =\n    open Rop\n    open Domain\n    open Capabilities\n\n    type CurrentState = \n        | LoggedOut\n        | LoggedIn of IPrincipal\n        | CustomerSelected of IPrincipal * CustomerId\n        | Exit\n\n    /// do the actions available while you are logged out. Return the new state\n    let loggedOutActions originalState = \n        printfn \"[Login] enter Alice, Bob, Zelda, or Exit: \"\n        let action = Console.ReadLine()\n        match action with\n        | \"Exit\"  -> \n            // Change state to Exit\n            Exit\n        | name -> \n            // otherwise try to authenticate the name\n            match Authentication.authenticate name with\n            | Success principal -> \n                LoggedIn principal\n            | Failure err -> \n                printfn \".. %A\" err\n                originalState\n\n    /// do the actions available while you are logged in. Return the new state\n    let loggedInActions originalState (principal:IPrincipal) = \n        printfn \"[%s] Pick a customer to work on. Enter Alice, Bob, or Logout: \" principal.Identity.Name\n        let action = Console.ReadLine()\n\n        match action with\n        | \"Logout\"  -> \n            // Change state to LoggedOut\n            LoggedOut\n        // otherwise treat it as a customer name\n        | customerName -> \n            // Attempt to find customer \n            match Authentication.customerIdForName customerName with\n            | Success customerId -> \n                // found -- change state\n                CustomerSelected (principal,customerId)\n            | Failure err -> \n                // not found -- stay in originalState \n                printfn \".. %A\" err\n                originalState \n\n    let getAvailableCapabilities capabilityProvider customerId principal = \n        let getCustomer = capabilityProvider.getCustomer customerId principal \n        let updateCustomer = capabilityProvider.updateCustomer customerId principal \n        let updatePassword = capabilityProvider.updatePassword customerId principal \n        getCustomer,updateCustomer,updatePassword  \n\n    /// do the actions available when a selected customer is available. Return the new state\n    let selectedCustomerActions originalState capabilityProvider customerId principal = \n\n        // get the individual component capabilities from the provider\n        let getCustomerCap,updateCustomerCap,updatePasswordCap = \n            getAvailableCapabilities capabilityProvider customerId principal\n\n        // get the text for menu options based on capabilities that are present\n        let menuOptionTexts = \n            [\n            getCustomerCap |> Option.map (fun _ -> \"(G)et\");\n            updateCustomerCap |> Option.map (fun _ -> \"(U)pdate\");\n            updatePasswordCap |> Option.map (fun _ -> \"(P)assword\");\n            ] \n            |> List.choose id\n\n        // show the menu \n        let actionText =\n            match menuOptionTexts with\n            | [] -> \" (no other actions available)\"\n            | texts -> texts |> List.reduce (fun s t -> s + \", \" + t) \n        printfn \"[%s] (D)eselect customer, %s\" principal.Identity.Name actionText \n\n        // process the user action\n        let action = Console.ReadLine().ToUpper()\n        match action with\n        | \"D\" -> \n            // revert to logged in with no selected customer\n            LoggedIn principal\n        | \"G\" -> \n            // use Option.iter in case we don't have the capability\n            getCustomerCap \n              |> Option.iter BusinessServices.getCustomer \n            originalState  // stay in same state\n        | \"U\" -> \n            updateCustomerCap \n              |> Option.iter BusinessServices.updateCustomer \n            originalState  \n        | \"P\" -> \n            updatePasswordCap \n              |> Option.iter BusinessServices.updatePassword\n            originalState  \n        | _ -> \n            // unknown option\n            originalState  \n\n    let rec mainUiLoop capabilityProvider state =\n        match state with\n        | LoggedOut -> \n            let newState = loggedOutActions state \n            mainUiLoop capabilityProvider newState \n        | LoggedIn principal -> \n            let newState = loggedInActions state principal\n            mainUiLoop capabilityProvider newState \n        | CustomerSelected (principal,customerId) ->\n            let newState = selectedCustomerActions state capabilityProvider customerId principal \n            mainUiLoop capabilityProvider newState \n        | Exit -> \n            () // done \n\n    let start capabilityProvider  = \n        mainUiLoop capabilityProvider LoggedOut \n```", "```\nmodule Application=\n    open Rop\n    open Domain\n    open CustomerDatabase \n    open Authentication\n    open Authorization\n\n    let capabilities = \n\n        let getCustomerOnlyForSameId id principal  = \n            onlyForSameId id principal CustomerDatabase.getCustomer\n\n        let getCustomerOnlyForAgentsInBusinessHours id principal = \n            let f = CustomerDatabase.getCustomer\n            let cap1 = onlyForAgents id principal f \n            let restriction f = onlyIfDuringBusinessHours (DateTime.Now) f\n            cap1 |> restrict restriction \n\n        let getCustomerOnlyForSameId_OrForAgentsInBusinessHours id principal = \n            let cap1 = getCustomerOnlyForSameId id principal \n            let cap2 = getCustomerOnlyForAgentsInBusinessHours id principal \n            first [cap1; cap2]\n\n        let updateCustomerOnlyForSameId id principal  = \n            onlyForSameId id principal CustomerDatabase.updateCustomer\n\n        let updateCustomerOnlyForAgentsInBusinessHours id principal = \n            let f = CustomerDatabase.updateCustomer\n            let cap1 = onlyForAgents id principal f \n            let restriction f = onlyIfDuringBusinessHours (DateTime.Now) f\n            cap1 |> restrict restriction \n\n        let updateCustomerOnlyForSameId_OrForAgentsInBusinessHours id principal = \n            let cap1 = updateCustomerOnlyForSameId id principal \n            let cap2 = updateCustomerOnlyForAgentsInBusinessHours id principal \n            first [cap1; cap2]\n\n        let updatePasswordOnlyForSameId id principal = \n            let cap = passwordUpdate id principal CustomerDatabase.updatePassword\n            cap \n            |> Option.map (auditable \"UpdatePassword\" principal.Identity.Name) \n\n        // create the record that contains the capabilities\n        {\n        getCustomer = getCustomerOnlyForSameId_OrForAgentsInBusinessHours \n        updateCustomer = updateCustomerOnlyForSameId_OrForAgentsInBusinessHours \n        updatePassword = updatePasswordOnlyForSameId \n        }         \n\n    let start() = \n        // pass capabilities to UI\n        UserInterface.start capabilities \n```", "```\nif user.CanUpdate() then\n   doTheAction() \n```", "```\nif user.CanUpdate() then\n    // ignore\n\n// now do the action anyway!\ndoTheAction() \n```", "```\nlet updateCapability = // attempt to get the capability\n\nmatch updateCapability with\n| Some update -> update()  // call the function\n| None -> ()               // can't call the function \n```", "```\ntype AccessToken private() = \n\n    // create an AccessToken that allows access to a particular customer\n    static member getAccessToCustomer id principal = \n        let principalId = GetIdForPrincipal(principal)\n        if (principalId = id) || principal.IsInRole(\"CustomerAgent\") then\n            Some <| AccessToken() \n        else\n            None \n```", "```\nlet getCustomer (accessToken:AccessToken) (id:CustomerId) = \n    // get customer data\n\nlet updateCustomer (accessToken:AccessToken) (id:CustomerId) (data:CustomerData) = \n    // update database \n```", "```\nlet principal = // from context\nlet id = // from context\n\n// attempt to get an access token\nlet accessToken = AuthorizationService.AccessToken.getAccessToCustomer id principal \n```", "```\nlet getCustomerCapability = \n    accessToken |> Option.map CustomerDatabase.getCustomer \n```", "```\nmatch getCustomerCapability with\n| Some getCustomer -> getCustomer id\n| None -> Failure AuthorizationFailed // error \n```", "```\ntype AccessCustomer = AccessCustomer of CustomerId\ntype UpdatePassword = UpdatePassword of CustomerId \n```", "```\ntype AccessToken<'data> = private {data:'data} with \n    // but do allow read access to the data\n    member this.Data = this.data \n```", "```\n// create an AccessToken that allows access to a particular customer\nlet getAccessCustomerToken id principal = \n    if customerIdBelongsToPrincipal id principal ||\n        principal.IsInRole(\"CustomerAgent\") \n    then\n        Some {data=AccessCustomer id}\n    else\n        None   \n\n// create an AccessToken that allows access to UpdatePassword \nlet getUpdatePasswordToken id principal = \n    if customerIdBelongsToPrincipal id principal then\n        Some {data=UpdatePassword id}\n    else\n        None \n```", "```\nlet getCustomer (accessToken:AccessToken<AccessCustomer>) = \n    // get customer id\n    let (AccessCustomer id) = accessToken.Data\n\n    // now get customer data using the id\n    match db.TryGetValue id with\n    | true, value -> Success value \n    | false, _ -> Failure (CustomerIdNotFound id)\n\nlet updateCustomer (accessToken:AccessToken<AccessCustomer>) (data:CustomerData) = \n    // get customer id\n    let (AccessCustomer id) = accessToken.Data\n\n    // update database\n    db.[id] <- data\n    Success ()\n\nlet updatePassword (accessToken:AccessToken<UpdatePassword>) (password:Password) = \n    Success ()   // dummy implementation \n```", "```\nlet principal =  // from context\nlet customerId = // from context\n\n// attempt to get a capability\nlet getCustomerCap = \n    // attempt to get a token\n    let accessToken = AuthorizationService.getAccessCustomerToken customerId principal\n    match accessToken with\n    // if token is present pass the token to CustomerDatabase.getCustomer, \n    // and return a unit->CustomerData \n    | Some token -> \n        Some (fun () -> CustomerDatabase.getCustomer token)\n    | None -> None\n\n// use the capability, if available \nmatch getCustomerCap with\n| Some getCustomer -> getCustomer()\n| None -> Failure AuthorizationFailed // error \n```", "```\n// attempt to get a capability\nlet getUpdatePasswordCap = \n    let accessToken = AuthorizationService.getAccessCustomerToken customerId principal\n    match accessToken with\n    | Some token -> \n        Some (fun password -> CustomerDatabase.updatePassword token password)\n    | None -> None\n\nmatch getUpdatePasswordCap with\n| Some updatePassword -> \n    let password = Password \"p@ssw0rd\"\n    updatePassword password \n| None -> \n    Failure AuthorizationFailed // error \n```", "```\nerror FS0001: Type mismatch. Expecting a\n    AccessToken<Capabilities.UpdatePassword>    \nbut given a\n    AccessToken<Capabilities.AccessCustomer>    \nThe type 'Capabilities.UpdatePassword' does not match the type 'Capabilities.AccessCustomer' \n```", "```\nmodule Capabilities = \n    open Rop\n    open Domain\n\n    // each access token gets its own type\n    type AccessCustomer = AccessCustomer of CustomerId\n    type UpdatePassword = UpdatePassword of CustomerId\n\n    // capabilities\n    type GetCustomerCap = unit -> SuccessFailure<CustomerData,FailureCase>\n    type UpdateCustomerCap = CustomerData -> SuccessFailure<unit,FailureCase>\n    type UpdatePasswordCap = Password -> SuccessFailure<unit,FailureCase>\n\n    type CapabilityProvider = {\n        /// given a customerId and IPrincipal, attempt to get the GetCustomer capability\n        getCustomer : CustomerId -> IPrincipal -> GetCustomerCap option\n        /// given a customerId and IPrincipal, attempt to get the UpdateCustomer capability\n        updateCustomer : CustomerId -> IPrincipal -> UpdateCustomerCap option\n        /// given a customerId and IPrincipal, attempt to get the UpdatePassword capability\n        updatePassword : CustomerId -> IPrincipal -> UpdatePasswordCap option \n        } \n```", "```\n// the constructor is protected\ntype AccessToken<'data> = private {data:'data} with \n    // but do allow read access to the data\n    member this.Data = this.data\n\nlet onlyForSameId (id:CustomerId) (principal:IPrincipal) = \n    if Authentication.customerIdOwnedByPrincipal id principal then\n        Some {data=AccessCustomer id}\n    else\n        None\n\nlet onlyForAgents (id:CustomerId) (principal:IPrincipal)  = \n    if principal.IsInRole(Authentication.customerAgentRole) then\n        Some {data=AccessCustomer id}\n    else\n        None\n\nlet onlyIfDuringBusinessHours (time:DateTime) f = \n    if time.Hour >= 8 && time.Hour <= 17 then\n        Some f\n    else\n        None\n\n// constrain who can call a password update function\nlet passwordUpdate (id:CustomerId) (principal:IPrincipal) = \n    if Authentication.customerIdOwnedByPrincipal id principal then\n        Some {data=UpdatePassword id}\n    else\n        None \n```", "```\nlet getCustomer id = \n    // code\n\nlet updateCustomer id data = \n    // code\n\nlet updatePassword (id:CustomerId,password:Password) = \n    // code \n```", "```\nlet getCustomer (accessToken:AccessToken<AccessCustomer>) = \n    // get customer id\n    let (AccessCustomer id) = accessToken.Data\n\n    // now get customer data using the id\n    // as before\n\nlet updateCustomer (accessToken:AccessToken<AccessCustomer>) (data:CustomerData) = \n    // get customer id\n    let (AccessCustomer id) = accessToken.Data\n\n    // update database\n    // as before\n\nlet updatePassword (accessToken:AccessToken<UpdatePassword>) (password:Password) = \n    // as before \n```", "```\nlet getCustomerOnlyForSameId id principal  = \n    onlyForSameId id principal CustomerDatabase.getCustomer\n\nlet getCustomerOnlyForAgentsInBusinessHours id principal = \n    let cap1 = onlyForAgents id principal CustomerDatabase.getCustomer\n    let restriction f = onlyIfDuringBusinessHours (DateTime.Now) f\n    cap1 |> restrict restriction \n```", "```\nlet getCustomerOnlyForSameId id principal  = \n    let accessToken = Authorization.onlyForSameId id principal\n    accessToken |> tokenToCap CustomerDatabase.getCustomer \n\nlet getCustomerOnlyForAgentsInBusinessHours id principal = \n    let accessToken = Authorization.onlyForAgents id principal\n    let cap1 = accessToken |> tokenToCap CustomerDatabase.getCustomer \n    let restriction f = onlyIfDuringBusinessHours (DateTime.Now) f\n    cap1 |> restrict restriction \n```", "```\nlet tokenToCap f token =\n    token \n    |> Option.map (fun token -> \n        fun () -> f token) \n```"]