- en: 'WAE: Adding Bindings to AETuesday, January 24th'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PLAI §3](plai.pdf#chapter.3 "Substitution")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To add this to our language, we start with the BNF. We now call our language
    “WAE” (With+AE):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we had to introduce two new rules: one for introducing an identifier,
    and one for using it. This is common in many language specifications, for example
    `define-type` introduces a new type, and it comes with `cases` that allows us
    to destruct its instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `<id>` we need to use some form of identifiers, the natural choice in Racket
    is to use symbols. We can therefore write the corresponding type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The parser is easily extended to produce these syntax objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But note that this parser is inconvenient — if any of these expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'would result in a “bad syntax” error, which is not very helpful. To make things
    better, we can add another case for `with` expressions that are malformed, and
    give a more specific message in that case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'and finally, to group all of the parsing code that deals with `with` expressions
    (both valid and invalid ones), we can use a single case for both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And now we’re done with the syntactic part of the `with` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Quick note — why would we indent `With` like a normal function in code like
    this
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: instead of an indentation that looks like a `let`
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The reason for this is that the second indentation looks like a binding construct
    (eg, the indentation used in a `let` expression), but `With` is *not* a binding
    form — it’s a *plain function* because it’s at the Racket level. You should therefore
    keep in mind the huge difference between that `With` and the `with` that appears
    in WAE programs:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Another way to look at it: imagine that we intend for the language to be used
    by Spanish or Chinese speakers. In this case we would translate “`with`”:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: but we will *not* do the same for `With` if we (the language implementors) are
    English speakers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
