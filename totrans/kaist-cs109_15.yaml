- en: Higher-order methods of collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with collections, such as arrays or lists, we often use for-loops
    to perform some operation on all the elements of the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The interesting part of this loop is the print statement. Modern programming
    languages make it possible to write code that concentrates on this part, not on
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing a for-loop, we can use the forEach method of the collection.
    This is a higher-order method, that is, it takes a function object as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop above is changed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we learnt in the previous section, this can be simplified a bit, because
    the Scala compiler knows that the argument of forEach has to be a function object
    of type (String) -> Unit. Therefore we are allowed to omit the type of the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, there is only a single parameter, so we can replace it by the magic
    parameter name it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example where we use forEach to compute the sum of the elements
    of a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Again we used the shortcut syntax we used for the function literal x: Int ->
    sum += x.'
  prefs: []
  type: TYPE_NORMAL
- en: Any, all, count, and find
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Often one goes through the elements of a collection to determine one of the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the collection contain an element with a certain property?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do all the elements have the property?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many of the elements have the property?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find an element with the property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be done nicely using the higher-order methods any, all, count, and
    find. They all require a function object that maps the elements to Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Filtering a collection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often we want to pick a subset of a collection consisting of all the elements
    that satisfy a certain condition. The higher-order methods filter and filterNot
    can do this. Again, they take as argument a function object that maps an element
    to a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some basic examples, using the list from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that filterNot does the same as filter, but reverses the sense of the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some interesting filters using our file of 113809 English words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Filtering is the essence of the Sieve of Erathosthenes, so it is natural that
    we can write it concisely using filter ([primes.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/40-lambda/primes.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Transforming a collection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another common operation is to create a new collection by somehow transforming
    every element of the existing collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done using the higher-order function map. Its argument is a function
    object that maps the elements of the collection to its transformed value. The
    new collection can have the same or a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sorting a collection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have already seen that we can sort a list by using its sorted method. This
    always sorts the elements using the natural ordering of the element type.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to sort with a different ordering, we can use the higher-order methods
    sortedWith (which returns a new list) or sortWith (which sorts the given mutable
    list). They take as an argument a java.util.Comparator object to handle the comparison
    between elements of the list.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a Comparator object from a function object that maps two elements
    \(a\) and \(b\) to an Int. The function should return a negative integer if element
    \(a\) should appear before element \(b\) in the desired sorted order, a positive
    integer if \(a\) should appear after \(b\), and zero if \(a\) and \(b\) are considered
    equal in the sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It sorts the elements of the words list in order of decreasing length (and then
    we display only the first 10 elements).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that every comparable type already has a method compareTo(a, b), which
    returns a positive integer if \(a > b\), a negative integer if \(a < b\), and
    zero if \(a = b\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make use of this when building our own Comparator objects, for instance
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, we can do this even easier: There are methods sortedBy and sortBy
    that take a function object that maps the elements of the list to some other,
    comparable type R. The list is then sorted by the order on R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have sorted the words by their negative length, so the longest word comes
    first. If you find the negation a bit unlogical, you can instead write it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is actually longer, but perhaps easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: More higher-order methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Kotlin collections have many more higher-order methods. Here are few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'findLast finds the last element in a list satisfying the given property (remember
    that find would find the first element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'retainAll is like filter, but it modifies the MutableList itself, throwing
    away all elements that do not satisfy the property (while filter always returns
    a new list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'takeWhile and takeLastWhile return a new list with the elements from the beginning
    (or the end) of the given list that satisfy a property. Similary, dropWhile and
    dropLastWhile return the remaining elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'groupBy is a useful operation: It applies a function object to every element
    of the collection to obtain a "key" for that element. It then returns a map that
    maps these keys to lists of the original elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'flatMap is a very powerful operation: It applies a given function object to
    every element of the collection. The result of the function object should be a
    list (or set, or array). The result of flatMap is a list combining all these lists
    in the order of the original list.'
  prefs: []
  type: TYPE_NORMAL
- en: fold and reduce or other powerful operations that go a bit beyond the scope
    of this section. Learn about them later!
  prefs: []
  type: TYPE_NORMAL
