- en: Interop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interop is extraordinarily important if you want your language to succeed!
  prefs: []
  type: TYPE_NORMAL
- en: This is just a historical fact. A huge part of why C++ was so successful was
    that it was easy to migrate a massive C codebase. If you look at the JVM, you
    see Scala and Clojure carving out pretty big niches for themselves thanks to their
    nice interop story with Java. For industrial users, there is no point in having
    an amazing language with great guarantees if there is no way to slowly introduce
    it into an existing codebase. It is exactly the same in browsers too.
  prefs: []
  type: TYPE_NORMAL
- en: This section focuses on the major kinds of interop that you need when working
    in browsers.
  prefs: []
  type: TYPE_NORMAL
- en: How to communicate with external services using JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to embed Elm programs in existing HTML or React apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to communicate with existing JavaScript code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these types of interop are guided by the self-imposed constraints that
    (1) there must be a clear way to introduce Elm gradually into diverse environments
    and (2) Elm should not have to sacrifice its core design principles. In other
    words, **Elm should be great *and* it should be possible to use Elm at work.**
  prefs: []
  type: TYPE_NORMAL
- en: Advice on Introducing Elm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The correct path is to first use Elm in a small experiment. If the experiment
    goes bad, stop it! If it goes great, expand the experiment a bit more. Then just
    repeat this process until you are using Elm or not! History seems to suggest that
    there is no realistic way to translate an existing project into a new language
    all at once. You have to evolve gradually!
  prefs: []
  type: TYPE_NORMAL
- en: Every company I know of that introduced Elm into an existing codebase did it
    gradually. You need to make sure it is worth it. You probably need to do some
    pairing or mentorship to get your teammates comfortable. You may even want to
    use React as a stepping stone if you are on something before that. Basically,
    anything you can do to minimize risk and make the process feel gradual will improve
    your odds. Now none of this is as fun as just switching, but it has the great
    benefit of actually working out in practice.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section uses `elm-repl`. If you did not [install it](install.md) already,
    you can use the [online REPL](http://elmrepl.cuberoot.in/).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be sending lots of JSON in your programs. You use [the `Json.Decode`
    library](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode)
    to convert wild and crazy JSON into nicely structured Elm values.
  prefs: []
  type: TYPE_NORMAL
- en: The core concept for working with JSON is called a **decoder**. It decodes JSON
    values into Elm values. We will start out by looking at some very basic decoders
    and then look at how to put them together to handle more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Decoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the type signatures for a couple primitive decoders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These become useful when paired with the `decodeString` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we can do stuff like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So our little decoders let us turn strings of JSON values into a `Result` telling
    us how the conversion went.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can handle the simplest JSON values, how can we deal with more complex
    things like arrays and objects?
  prefs: []
  type: TYPE_NORMAL
- en: Combining Decoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cool thing about decoders is that they snap together like building blocks.
    So if we want to handle a list of values, we would reach for the [`list`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#list)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine this with all the primitive decoders now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So now we can handle JSON arrays. If we want to get extra crazy, we can even
    nest lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So that is `list`, but `Json.Decode` can handle many other data structures too.
    For example, [`dict`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#dict)
    helps you turn a JSON object into an Elm `Dict` and [`keyValuePairs`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#keyValuePairs)
    helps you turn a JSON object into an Elm list of keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We decode JSON objects with the [`field`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#field)
    function. It snaps together decoders just like `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So when you say `field "x" int` you are saying (1) I want a JSON object, (2)
    it should have a field `x`, and (3) the value at `x` should be an integer. So
    using it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `field "x" int` decoder only cares about field `x`. The object
    can have other fields with other content. That is all separate. But what happens
    when you want to get information from *many* fields? Well, we just need to put
    together many decoders. This is possible with functions like [`map2`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#map2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes in two different decoders. If they are both successful,
    it uses the given function to combine their results. So now we can put together
    two different decoders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that covers two fields, but what about three? Or four? The core library
    provides [`map3`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#map3),
    [`map4`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#map4),
    and others for handling larger objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you start working with larger JSON objects, it is worth checking out [`NoRedInk/elm-decode-pipeline`](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest).
    It builds on top of the core `Json.Decode` module described here and lets you
    write stuff like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can have `optional` and `hardcoded` fields as well. It is quite a nice library,
    so take a look!
  prefs: []
  type: TYPE_NORMAL
- en: Broader Context
  prefs:
  - PREF_BQ
  - PREF_H2
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By now you have seen a pretty big chunk of the actual `Json.Decode` API, so
    I want to give some additional context about how this fits into the broader world
    of Elm and web apps.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Validating Server Data
  prefs:
  - PREF_BQ
  - PREF_H3
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The conversion from JSON to Elm doubles as a validation phase. You are not just
    converting from JSON, you are also making sure that JSON conforms to a particular
    structure.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In fact, decoders have revealed weird data coming from NoRedInk’s *backend*
    code! If your server is producing unexpected values for JavaScript, the client
    just gradually crashes as you run into missing fields. In contrast, Elm recognizes
    JSON values with unexpected structure, so NoRedInk gives a nice explanation to
    the user and logs the unexpected value. This has actually led to some patches
    in their Ruby server!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A General Pattern
  prefs:
  - PREF_BQ
  - PREF_H3
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'JSON decoders are an example of a more general pattern in Elm. You see it whenever
    you want to wrap up complicated logic into small building blocks that snap together
    easily. Other examples include:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Random` — The `Random` library has the concept of a `Generator`. So a `Generator
    Int` creates random integers. You start with primitive building blocks that generate
    random `Int` or `Bool`. From there, you use functions like `list` and `map` to
    build up generators for fancier types.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Easing` — The Easing library has the concept of an `Interpolation`. An `Interpolation
    Float` describes how to slide between two floating point numbers. You start with
    interpolations for primitives like `Float` or `Color`. The cool thing is that
    these interpolations compose, so you can build them up for much fancier types.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As of this writing, there is some early work on Protocol Buffers (binary data
    format) that uses the same pattern. In the end you get a nice composable API for
    converting between Elm values and binary!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript Interop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At some point your Elm program is probably going to need to talk to JavaScript.
    We do this by (1) embedding Elm in HTML and (2) sending messages back and forth
    between Elm and JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](interop.png)'
  prefs: []
  type: TYPE_IMG
- en: This way we can have access to full power of JavaScript, the good and the bad,
    without giving up on all the things that are nice about Elm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Embed in HTML'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally when you run the Elm compiler, it will give you an HTML file that
    sets everything up for you. So running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Will result in a `index.html` file that you can just open up and start using.
    To do fancier stuff, we want to compile to JavaScript, so we modify the command
    slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the compiler will generate a JavaScript file that lets you initialize your
    program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is doing three important things:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a `<div>` that will hold the Elm program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We load the JavaScript generated by the Elm compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We grab the relevant node and initialize our Elm program in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So now we can set Elm up in any `<div>` we want. So if you are using React,
    you can create a component that just sets this kind of thing up. If you are using
    Angular or Ember or something else, it should not be too crazy either. Just take
    over a `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: The next section gets into how to get your Elm and JavaScript code to communicate
    with each other in a nice way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Talk to JavaScript'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two major ways for Elm and JavaScript to talk to each other: **ports**
    and **flags**.'
  prefs: []
  type: TYPE_NORMAL
- en: Ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say we have a nice Elm program and everything is going fine, but we want to
    use some JavaScript spell-checking library to get a feature done real quick. The
    final result is shown [here](https://gist.github.com/evancz/e69723b23958e69b63d5b5502b0edf90),
    and we will walk through the most important parts here.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, in Elm, **any communication with JavaScript goes through a port**. Think
    of it like a hole in the side of your Elm program where you can send values in
    and out. These work exactly like the commands and subscriptions from [the Architecture
    section](../architecture). Sending values out to JS is a command. Listening for
    values coming in from JS is a subscription. Pretty neat!
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we want to talk to this spell-checking library, our Elm program will
    need these additional declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can see the whole file [here](https://gist.github.com/evancz/e69723b23958e69b63d5b5502b0edf90),
    but these are the important additions:'
  prefs: []
  type: TYPE_NORMAL
- en: We change the `module` declaration to `port module`. This indicates that `port`
    declarations should be permitted. (Very few modules should have ports in them!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `check` port. On the Elm side, we can create commands like `check
    "badger"`, resulting in a `Cmd msg` that sends strings to the JS side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `suggestions` port. This one looks a bit fancier than the `check`
    port, but imagine that it is creating `Sub (List String)`. You are essentially
    subscribing to lists of strings sent into Elm from JS. So when the spell-checking
    library has a suggestion, it will send things through. Now, the type of `suggestions`
    is a bit fancier than that. You provide a function from `(List String -> msg)`
    so you can convert that list of strings to your `Msg` type immediately. This makes
    it easy to deal with in your `update` function, but it is just for convenience.
    The real point is to send a `List String` from JS into Elm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Okay, so after you run `elm-make Spelling.elm --output=spelling.js` you embed
    it in HTML like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so all the ports you declare in your Elm program will be available as
    fields of `app.ports`. In the code above, we access `app.ports.check` and `app.ports.suggestions`.
    They work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: We can subscribe to `app.ports.check`. Every time Elm says to send a value out,
    we will call this JavaScript function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can send values to `app.ports.suggestions`. So whenever we have some new
    suggestions for Elm, we just `send` them through.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that knowledge, we can communicate back and forth with JavaScript!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Elm validates all values coming in from JavaScript. In Elm we said
    we can only handle `List String` so we need to make sure that the JavaScript code
    does not break that contract! More about that [farther down this page](#customs-and-border-protection).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second way to talk to JavaScript is with *flags*. You can think of this
    as some static configuration for your Elm program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating a `Program` with the [`program`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#program)
    function, we can use the [`programWithFlags`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#programWithFlags).
    So say we want to get a value like this from JavaScript on initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We would set up our Elm program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And on the JavaScript side, we start the program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this is exactly the same as normal, but we provide an extra argument
    with all the flags we want.
  prefs: []
  type: TYPE_NORMAL
- en: Just like ports, the values sent in from JavaScript are validated to make sure
    JavaScript bugs stay in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Customs and Border Protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ports and flags must be careful about what values are allowed through. Elm is
    statically typed, so each port is fitted with some border protection code that
    ensures that type errors are kept out. Ports also do some conversions so that
    you get nice colloquial data structures in both Elm and JS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The particular types that can be sent in and out of ports are quite flexible,
    covering [all valid JSON values](http://www.json.org/). Specifically, incoming
    ports can handle all the following Elm types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Booleans and Strings** – both exist in Elm and JS!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numbers** – Elm ints and floats correspond to JS numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lists** – correspond to JS arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrays** – correspond to JS arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuples** – correspond to fixed-length, mixed-type JS arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Records** – correspond to JavaScript objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maybes** – `Nothing` and `Just 42` correspond to `null` and `42` in JS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Json** – [`Json.Encode.Value`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Encode#Value)
    corresponds to arbitrary JSON'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now say Elm wants a `List String`, but someone calls `app.ports.suggestions.send(42)`
    on the JavaScript side. We *know* it will cause issues in Elm, and we *know* the
    code producing invalid data is on the JS side. So rather than letting the bad
    data into Elm and cause a runtime exception *eventually* (the JavaScript way!)
    we throw a runtime exception *immediately* when you call `send` with invalid data.
    So we cannot solve the problem of invalid data in JavaScript, but we can at least
    make sure it stays on the JavaScript side!
  prefs: []
  type: TYPE_NORMAL
- en: Usage Advice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I showed an example where the ports were declared in the root module. This is
    not a strict requirement. You can actually create a `port module` that gets imported
    by various parts of your app.
  prefs: []
  type: TYPE_NORMAL
- en: It seems like it is probably best to just have one `port module` for your project
    so it is easier to figure out the API on the JavaScript side. I plan to improve
    tooling such that you can just ask though.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Port modules are not permitted in the package repository. Imagine
    you download an Elm package and it just doesn''t work. You read the docs and discover
    you *also* need to get some JS code and hook it up properly. Lame. Bad experience.
    Now imagine if you had this risk with *every* package out there. It just would
    feel crappy, so we do not allow that.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Historical Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now I know that this is not the typical interpretation of *language interop*.
    Usually languages just go for full backwards compatibility. So C code can be used
    *anywhere* in C++ code. You can replace C/C++ with Java/Scala or JavaScript/TypeScript.
    This is the easiest solution, but it forces you to make quite extreme sacrifices
    in the new language. All the problems of the old language now exist in the new
    one too. Hopefully less though.
  prefs: []
  type: TYPE_NORMAL
- en: Elm's interop is built on the observation that **by enforcing some architectural
    rules, you can make full use of the old language *without* making sacrifices in
    the new one.** This means we can keep making guarantees like "you will not see
    runtime errors in Elm" even as you start introducing whatever crazy JavaScript
    code you need.
  prefs: []
  type: TYPE_NORMAL
- en: So what are these architectural rules? Turns out it is just The Elm Architecture.
    Instead of embedding arbitrary JS code right in the middle of Elm, we use commands
    and subscriptions to send messages to external JavaScript code. So just like how
    the `WebSocket` library insulates you from all the crazy failures that might happen
    with web sockets, port modules insulate you from all the crazy failures that might
    happen in JavaScript. **It is like JavaScript-as-a-Service.**
  prefs: []
  type: TYPE_NORMAL
