- en: Evaluation of `with`Tuesday, January 24th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, to make this work, we will need to do some substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We basically want to say that to evaluate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'we need to evaluate `WAE2` with id substituted by `WAE1`. Formally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a more common syntax for substitution (quick: what do I mean by this
    use of “syntax”?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Side-note: this syntax originates with logicians who used `[x/v]e`, and later
    there was a convention that mimicked the more natural order of arguments to a
    function with `e[x->v]`, and eventually both of these got combined into `e[v/x]`
    which is a little confusing in that the left-to-right order of the arguments is
    not the same as for the `subst` function.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now all we need is an exact definition of substitution.
  prefs: []
  type: TYPE_NORMAL
- en: Note that substitution is not the same as evaluation, it’s only a part of the
    evaluation process. In the previous examples, when we evaluated the expression
    we did substitutions as well as the usual arithmetic operations that were already
    part of the AE evaluator. In this last definition there is still a missing evaluation
    step, see if you can find it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So let us try to define substitution now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitution (take 1): `e[v/i]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To substitute an identifier `i` in an expression `e` with an expression `v`,
    replace all identifiers in `e` that have the same name `i` by the expression `v`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This seems to work with simple expressions, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'however, we crash with an invalid syntax if we try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: — we got to an invalid expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we need to distinguish normal occurrences of identifiers, and
    ones that are used as new bindings. We need a few new terms for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binding Instance: a binding instance of an identifier is one that is used to
    name it in a new binding. In our `<WAE>` syntax, binding instances are only the
    `<id>` position of the `with` form.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scope: the scope of a binding instance is the region of program text in which
    instances of the identifier refer to the value bound in the binding instance.
    (Note that this definition actually relies on a definition of substitution, because
    that is what is used to specify how identifiers refer to values.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bound Instance (or Bound Occurrence): an instance of an identifier is bound
    if it is contained within the scope of a binding instance of its name.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Free Instance (or Free Occurrence): An identifier that is not contained in
    any binding instance of its name is said to be free.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using this we can say that the problem with the previous definition of substitution
    is that it failed to distinguish between bound instances (which should be substituted)
    and binding instances (which should not). So we try to fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitution (take 2): `e[v/i]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To substitute an identifier `i` in an expression `e` with an expression `v`,
    replace all instances of `i` that are not themselves binding instances with the
    expression `v`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'First of all, check the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: still work, and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'also works. However, if we try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'but we want that to be `8`: the inner `x` should be bound by the closest `with`
    that binds it.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the new definition of substitution that we have respects
    binding instances, but it fails to deal with their scope. In the above example,
    we want the inner `with` to *shadow* the outer `with`’s binding for `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitution (take 3): `e[v/i]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To substitute an identifier `i` in an expression `e` with an expression `v`,
    replace all instances of `i` that are not themselves binding instances, and that
    are not in any nested scope, with the expression `v`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This avoids bad substitution above, but it is now doing things too carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: which is an error because `x` is unbound (and there is reasonable no rule that
    we can specify to evaluate it).
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that our substitution halts at every new scope, in this case,
    it stopped at the new `y` scope, but it shouldn’t have because it uses a different
    name. In fact, that last definition of substitution cannot handle any nested scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Revise again:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitution (take 4): `e[v/i]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To substitute an identifier `i` in an expression `e` with an expression `v`,
    replace all instances of `i` that are not themselves binding instances, and that
    are not in any nested scope of `i`, with the expression `v`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'which, finally, is a good definition. This is just a little too mechanical.
    Notice that we actually refer to all instances of `i` that are not in a scope
    of a binding instance of `i`, which simply means all *free occurrences* of `i`
    — free in `e` (why? — remember the definition of “free”?):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitution (take 4b): `e[v/i]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To substitute an identifier `i` in an expression `e` with an expression `v`,
    replace all instances of `i` that are free in `e` with the expression `v`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Based on this we can finally write the code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: … and this is just the same as writing a formal “paper version” of the substitution
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have bugs: but we’ll need some more work to get to them.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Before we find the bugs, we need to see when and how substitution is used in
    the evaluation process.
  prefs: []
  type: TYPE_NORMAL
- en: To modify our evaluator, we will need rules to deal with the new syntax pieces
    — `with` expressions and identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we see an expression that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'we continue by *evaluating* `E1` to get a value `V1`, we then substitute the
    identifier `x` with the expression `V1` in `E2`, and continue by evaluating this
    new expression. In other words, we have the following evaluation rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So we know what to do with `with` expressions. How about identifiers? The main
    feature of `subst`, as said in the purpose statement, is that it leaves no free
    instances of the substituted variable around. This means that if the initial expression
    is valid (did not contain any free variables), then when we go from
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: the result is an expression that has *no* free instances of `x`. So we don’t
    need to handle identifiers in the evaluator — substitutions make them all go away.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now extend the formal definition of AE to that of WAE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re paying close attention, you might catch a potential problem in this
    definition: we’re substituting `eval(E1)` for `x` in `E2` — an operation that
    requires a WAE expression, but `eval(E1)` is a number. (Look at the type of the
    `eval` definition we had for AE, then look at the above definition of `subst`.)
    This seems like being overly pedantic, but we it will require some resolution
    when we get to the code. The above rules are easily coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `Num` expression in the marked line: evaluating the named expression
    gives us back a number — we need to convert this number into a syntax to be able
    to use it with `subst`. The solution is to use `Num` to convert the resulting
    number into a numeral (the syntax of a number). It’s not an elegant solution,
    but it will do for now.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, here are a few test cases. We use a new `test` special form which is
    part of the course plugin. The way to use `test` is with two expressions and an
    `=>` arrow — DrRacket evaluates both, and nothing will happen if the results are
    equal. If the results are different, you will get a warning line, but evaluation
    will continue so you can try additional tests. You can also use an `=error>` arrow
    to test an error message — use it with some text from the expected error, `?`
    stands for any single character, and `*` is a sequence of zero or more characters.
    (When you use `test` in your homework, the handin server will abort when tests
    fail.) We expect these tests to succeed (make sure that you understand *why* they
    should succeed).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Putting this all together, we get the following code; trying to run this code
    will raise an unexpected error…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops, this program still has problems that were caught by the tests — we encounter
    unexpected free identifier errors. What’s the problem now? In expressions like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'we forgot to substitute `x` in the expression that `y` is bound to. We need
    to the recursive substitute in both the with’s body expression as well as its
    named expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And *still* we have a problem… Now it’s
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'that halts with an error, but we want it to evaluate to `5`! Carefully trying
    out our substitution code reveals the problem: when we substitute `5` for the
    outer `x`, we don’t go inside the inner `with` because it has the same name —
    but we *do* need to go into its named expression. We need to substitute in the
    named expression even if the identifier is the *same* one we’re substituting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete (and, finally, correct) version of the code is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We started doing substitution, with a `let`-like form: `with`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reasons for using bindings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid writing expressions twice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: More expressive language (can express identity).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Duplicating is bad! (“DRY”: *Don’t Repeat Yourself*.)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids *static* redundancy.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid redundant computations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: More than *just* an optimization when it avoids exponential resources.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids *dynamic* redundancy.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BNF:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we had to introduce two new rules: one for introducing an identifier,
    and one for using it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parser:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to define substitution. Terms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding Instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scope.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bound Instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Free Instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After lots of attempts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e[v/i] — To substitute an identifier `i` in an expression `e` with an expression
    `v`, replace all instances of `i` that are free in `e` with the expression `v`.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Implemented the code, and again, needed to fix a few bugs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '(Note that the bugs that we fixed clarify the exact way that our scopes work:
    in `{with {x 2} {with {x {+ x 2}} x}}`, the scope of the first `x` is the `{+
    x 2}` expression.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then extended the AE evaluation rules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: and noted the possible type problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The above translated into a Racket definition for an `eval` function (with
    a hack to avoid the type issue):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
