- en: 'CS240h: Functional systems in Haskell'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm David Mazières
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spent most of my career working on OSes, Systems, and Security
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously used C++ and C, but started using Haskell 5 years ago
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Course partly inspired by my experience learning Haskell
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other instructor: Bryan O''Sullivan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has implemented many key Haskell libraries in widespread use today
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Co-wrote [*Real World Haskell*](http://book.realworldhaskell.org/), a great
    non-theoretical intro book
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Also plenty of systems experience (e.g., Linux early userspace code)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Course assistant: David Terei'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Member of the Haskell standards committee!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented [Safe Haskell](http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html)
    and GHC LLVM backend
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Haskell?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell's expressive power can improve productivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small language core provides big flexibility
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Code can be very concise, speeding development
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get best of both worlds from compiled and interpreted languages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Haskell makes code easier to understand and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can dive into complex libraries and understand *what* the code is doing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (*why* may be a different story, but conciseness leaves room for comments...)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Haskell can increase the robustness of systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong typing catches many bugs at compile time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional code permits better testing methodologies
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can parallelize non-concurrent code without changing semantics
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent programming abstractions resistant to data races
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Haskell lets you realize new types of functionality (DIFC, STM, ...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why take CS240h?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn to build systems in Haskell with reduced upfront cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historically, Haskell was a vehicle for language research.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The history is reflected in how the language is usually taught
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: CS240h will present the language more from a systems perspective
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn new, surprising, and effective programming techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some are applicable to other languages (though returning to other languages
    after Haskell can be frustrating)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You enjoy programming**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Haskell, you will think about programming in new ways
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You sometimes get frustrated with other languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe you've wanted to design a new language, or tend to "max-out" existing
    language features (macros, templates, overloading, etc.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Things that require changes to most languages can be done in a library with
    Haskell
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Administrivia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We assume some of you may have toyed with Haskell, others not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First week cover Haskell basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven't used Haskell, you should supplement by reading parts of [Bryan's
    book](http://book.realworldhaskell.org/) and/or on-line tutorials (such as [http://www.haskell.org/tutorial/](http://www.haskell.org/tutorial/)
    or [http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters)).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have used Haskell, you may still learn some things from these lectures
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rest of term covers more advanced techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final grade will be based on several factors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class attendance and participation **-- bring your laptop to class**
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scribing one of the lectures **-- need a volunteer for today**
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We plan to collect all the notes and distribute them freely on web
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Three small warm-up solo programming exercises
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A large final project & presentation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Final project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement a project of your choice in Haskell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects may be done in teams of 1-3 people
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Meet with one of the instructors to discuss project
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete and evaluate project and turn in short paper
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Final exam will be mini-conference where you present your work
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attending exam Tuesday, June 10th, 7:00pm-10:00pm is mandatory**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But by unanimous consent we could move this to Thursday June 5, 12:15-3:15pm.
    (And we would serve lunch...)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We encourage overlap of CS240h project with your research
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The programming techniques you learn in CS240h are likely orthogonal to whatever
    research you are doing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are okay with CS240h project also serving as another class project,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**provided the other instructor and all teammates (from both classes) approve**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting started with Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install [Haskell Platform](http://hackage.haskell.org/platform/) or [`cabal`](http://www.haskell.org/cabal/users-guide/)
    (sometimes `cabal-install`) + [GHC](http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a file called `hello.hs` with the following contents:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile your program to a native executable like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or run it in the [GHCI interpreter](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html)
    like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Haskell uses the `=` sign to declare *bindings*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Bound names cannot start with upper-case letters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bindings are separated by "`;`", which is usually auto-inserted by a [layout](http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7)
    rule
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A binding may declare a *function* of one or more arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function and arguments are separated by spaces (when defining or invoking)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Parentheses can wrap compound expressions, must do so for arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Haskell is a *pure* functional language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike variables in imperative languages, Haskell bindings are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*immutable* - can only bind a symbol once in a give scope (bound symbols still
    called "variables" since function arguments can vary across invocations)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*order-independent* - order of bindings in source code does not matter'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lazy* - definitions of symbols are evaluated only when needed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*recursive* - the bound symbol is in scope within its own definition'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to program without mutable variables?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C, we use mutable variables to create loops:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Haskell, use recursion to "re-bind" argument symbols in new scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Recursion often fills a similar need to mutable variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But the above Haskell factorial is inferior to the C one--why?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tail recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each recursive call may require a stack frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Haskell code requires `n` stack frames
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: By contrast, our C factorial ran in constant space
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, Haskell supports optimized *tail recursion*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function is tail recursive if it ends with a call to itself
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, `factorial n` multiplies by `n` *after* evaluating `factorial
    (n-1)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Idea: use *accumulator* argument to make calls tail recursive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here `loop` is tail recursive, compiles to an actual loop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Guards and `where` clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Guards* let you shorten function declarations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '"`|`" symbol introduces a guard'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Guards are evaluated top to bottom; the first `True` guard wins
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The system Prelude (standard library) defines `otherwise = True`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bindings can also end with `where` clauses--like inverted `let`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unlike `let`, a `where` clause scopes over multiple guarded definitions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is convenient for binding variables to use in guards
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tip: variable names'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inner functions (`loop`) often have arguments related to outer function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is legal to re-use variable names already in scope, but compiler will warn
    you
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical practice is to add `'` (prime) to the inner-function's argument
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Haskell accepts the `'` character in variables, except as first character
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Personally, I find this practice a bit error-prone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While learning Haskell, I repeatedly made the error of dropping primes, e.g.:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can avoid the problem by using the longer symbol name for the outer function
    (i.e., shorter name for shorter scope)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here accidentally typing "`factorial n0 = loop 1 n`" causes compile error
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Every expression and binding has a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some basic types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bool` - either `True` or `False`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Char` - a unicode code point (i.e., a character)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int` - fixed-size integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Integer` - an arbitrary-size integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Double` - an IEEE double-precision floating-point number'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*type1* `->` *type2* - a function from *type1* to *type2*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(`*type1*`,` *type2*`,` ...`,` *typeN*`)` - a tuple'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()` - a zero-tuple, pronounced *unit* (kind of like `void` in C); there is
    only one value of this type, also written `()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can declare the type of a symbol or expression with `::`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`::` has lower precedence than any function operators (including `+`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: More on types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function application happens one argument at a time (a.k.a. "*currying*")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So `add 2 3` is equivalent to `(add 2) 3`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(add 2)` takes 3 returns 5, so `(add 2) has type Integer -> Integer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`->` associates to the right, so parens usually omitted in multi-argument function
    types:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn ::` *argType1* `->` *argType2* `->` ... `->` *argTypeN* `->` *resultType*'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Usually the compiler can infer types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can ask [GHCI](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html)
    to show you inferred types with `:t`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Good practice to declare types of top-level bindings anyway (compiler warns
    if missing)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `data` keyword declares user-defined data types (like `struct` in C):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declares new type, `PointT` with constructor `PointC` containing two `Double`s
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deriving Show` means you can print the type (helpful in GHCI)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can also derive `Read`, `Eq`, `Ord`, `Enum`, `Bounded`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that data types and constructors *must* start with capital letters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Types and constructors can use the same name (often do), E.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One type can have multiple constructors (like a tagged union):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructors act like functions producing values of their types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`case` statements & function bindings "de-construct" values with *patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise: Rock, Paper, Scissors referee'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the following types for a rock-paper-scissors game:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function `outcome :: Move -> Move -> Outcome`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first move should be your own, the second your opponent's
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Should tell you if you won, lost, or tied
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Parameterized types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Types can have parameters sort of the way functions do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type parameters start with lower-case letters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some examples from the standard Prelude
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see these at work in GHCI:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the type of `Left True` contains a type variable, `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression `Left True` can be of type `Either Bool b` for any type `b`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an example of a feature called *parametric polymorphism*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: More deconstruction tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Special variable "`_`" can be bound but not used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use it when you don''t care about a value:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compiler warns if a bound variable not used; `_` avoids this
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can deconstruct types and bind variables within guards, E.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: though often there is a simpler way
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could define homogeneous lists with the `data` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But Haskell has built-in lists with syntactic sugar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of `List Integer`, the type is written `[Integer]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of `Cons`, the constructor is called `:` and is *infix*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of `Nil`, the empty list is called `[]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But there are even more convenient syntaxes for the same list:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `String` is just a list of `Char`, so `['a', 'b', 'c'] == "abc"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pattern match on literal lists and `String`s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some basic list functions in Prelude
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Note function `error :: String -> a` reports assertion failures'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing with `deriving Read` and `reads`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've been using "`deriving Show`" and `show` to print values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default `show` show gives you a valid Haskell expression
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '"`deriving Read`" lets you parse a value at run time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Problem: Might be 0, 1, or (if ambiguous) more possible parsings'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function `reads` parses and returns `[(value, string_with_rest_of_input)]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise: Using `reads`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a function to parse moves:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return `Just` move on successful parse, `Nothing` otherwise
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can optionally accept whitespace or parentheses if easier
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But should reject a string with any trailing content after move
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Possible solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `reads`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`reads` return type implicitly constrained by `parseMove`''s type declaration'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing `parseMove`'s type would make calling it difficult
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directly match keywords:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note how strings are constructors---you can pattern match on them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But this solution too finicky--won't except trailing carriage returns or spaces.
    If you did this change to using reads.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Being more permissive of line disciplines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If reading terminal input, different OSes have different disciplines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., might have trailing `"\n"` or `"\r\n"`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's tolerate trailing whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change your definition to:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Should now behave like this
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hoogle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's find the source code for GHC's `length` function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hoogle](http://www.haskell.org/hoogle/) is a search engine just for Haskell
    functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [http://www.haskell.org/hoogle/](http://www.haskell.org/hoogle/)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on *search plugin*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword "`haskell.org`" is too long for me--I change to "`ho`"
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's search for length... click on source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All those `#` marks are for "unboxed types", which are faster but not asymptotically
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The important point is that `len` is tail recursive
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I use Hoogle all the time, all the time when coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the source code is not hard to understand
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Length may be a bad starter example just because of unboxed types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Try examining the code of the functions you are using to understand them better
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: counting letters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's a function to count lower-case letters in a `String`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we fix `length`, `countLowerCase` might run in constant space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall Haskell evaluates expressions lazily... Means in most contexts values
    are interchangeable with function pointers (a.k.a. *thunks*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `String` is a `[Char]`, which is a type with two values, a *head* and *tail*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But until each of the *head* or *tail* is needed, it can be stored as a function
    pointer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So `length` will causes `filter` to produce `Char`s one at a time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length` does not hold on to characters once counted; can be garbage-collected
    at will'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's an even more concise definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The "`.`" operator provides function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '"`f . g`" is an ASCII approximation of mathematical "*f* ∘ *g*"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On previous slide, `countLowerCase`'s argument had name `str`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The new version doesn't name the argument, a style called *point-free*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition can be used almost like Unix pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise: Write the type of "`.`" without typing `:t (.)` into ghci'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you want to name the arguments but not the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Haskell allows anonymous functions through *lambda abstraction*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notation is `\`*variable(s)* `->` *body*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"`\`" is an ASCII approximation of "*λ*", so pronounced "lambda"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lambda abstractions can deconstruct values with patterns, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But note that guards or multiple bindings are not allowed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns must have the right constructor or will get run-time error
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Infix vs. Prefix notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen some infix functions & constructors: `+`, `*`, `/`, `.`, `||`,
    `:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, any binary function or constructor can be used infix or prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For functions and constructors composed of letters, digits, `_`, and `'`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prefix is the default: `add 1 2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Putting function in backticks makes it infix: `1 `add` 2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For functions starting with one of `!#$%&*+./<=>?@\^|-~` or constructors starting
    "`:`"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infix is default, Putting functions in parens makes them prefix, e.g., `(+)
    1 2`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For tuples, prefix constructors are `(,)`, `(,,)`, `(,,,)`, `(,,,,)`, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infix functions can be partially applied in a parenthesized *section*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fixity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most operators are just library functions in Haskell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very few operators reserved by language syntax
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (`..`, `:`, `::`, `=`, `\`, `|`, `<-`, `->`, `@`, `~`, `=>`, `--`)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can go crazy and define your own operators
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Or even use your own definitions instead of system ones
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Define precedence of infix operators with fixity declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keywords: `infixl`/`infixr`/`infix` for left/right/no associativity'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Syntax: *infix-keyword* [0-9] *function* [, *function* ...]'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowed wherever a type declaration is allowed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 is lowest allowed fixity precedence, 9 is highest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefix function application has fixity 10--higher than any infix call
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda abstractions, `else` clauses, and `let`...`in` clauses extend as far
    to the right as possible (meaning they never stop at any infix operator, no matter
    how low precedence)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixity of specific operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the fixity of the [standard operators](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820061):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can''t remember, use `:i` in [GHCI](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If GHCI doesn''t specify, means default: `infixl 9`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The "`infixr 0`" operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`$` is function application, but with lowest precedence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turns out to be quite useful for avoiding parentheses, E.g.:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`seq :: a -> b -> b` just returns value of second argument...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: but forces evaluation of the first argument before evaluating the second
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So when you are done, the first argument is a value, not a thunk
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`seq` has to be built into the compiler'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$!` combines `$` and `seq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Accumulators revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used an accumulator to avoid `n0` stack frames in `factorial`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, `acc` can contain a chain of thunks `n` long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(((1 * n) * (n - 1)) * (n - 2) ...)` -- Laziness means only evaluated when
    needed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GHC is smart enough not to build up thunks, but only if optimizing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can fix such problems using `$!` or `seq`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Hackage and cabal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Hackage](http://hackage.haskell.org/packages/) is a large collection of Haskell
    packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cabal](http://www.haskell.org/cabal/users-guide/) is a tool for browsing hackage
    and installing packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cabal comes with the [haskell platform](http://hackage.haskell.org/platform/)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `cabal update` to create `$HOME/.cabal`, download package database
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I highly recommend unconmenting and editing these two lines in `$HOME/.cabal/config`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: May want to add `$HOME/.cabal/bin` to your path
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I use the following shell alias
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'E.g., run: `cbi network`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs packages in `$HOME/.cabal`, and records them in `$HOME/.ghc`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To start fresh, must delete both `$HOME/.cabal` and `$HOME/.ghc`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and `import` syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell groups top-level bindings into *modules*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default module name is `Main`, as programs start at function `main` in `Main`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for `Main`, a module named *M* must reside in a file named *M*`.hs`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Module names are capitalized; I use lower-case file names for `Main` modules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's add this to the top of our source file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start module with "`module` *name* `where`" or "`module` *name* `(`*exported-symbol*[`,`
    ...]`) where`" (non-exported symbols provide modularity)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import` *module* - imports all symbols in *module*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import qualified` *module* `as` *ID* - prefixes imported symbols with *ID*`.`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import` *module* `(`*function1*[`,` *function2* ...]`)` - imports just the
    named functions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import` *module* `hiding (`*function1*[`,` *function2* ...]`)` - imports all
    but the named functions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do` notation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write a function to greet someone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type the following into a file `greet.hs`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or shortcut, type: `wget` [`cs240h.stanford.edu/greet1.hs`](http://cs240h.stanford.edu/greet1.hs)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now try running `main` in GHCI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do` notation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Greeting task requires some impure (non-functional) actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing a file handle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `do` block lets you sequence IO actions. In a `do` block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pat* `<-` *action* - binds *pat* (variable or constructor pattern) to result
    of executing *action*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let` *pat* `=` *pure-value* - binds *pat* to *pure-value* (no "`in` ..." required)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*action* - executes *action* and discards the result, or returns it if at end
    of block'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GHCI input is like `do` block (i.e., can use `<-`, need `let` for bindings)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do`/`let`/`case` won''t parse after prefix function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually say "`func $ do` ..."
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can also say "`func (do` ...`)`"
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the types of IO actions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`IO` is a parameterized type (just as `Maybe` is parameterized)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"`IO String`" means IO action that produces a `String` if executed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike `Maybe`, we won't use a constructor for `IO`, which is somewhat magic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What if we try to copy a line of input as follows?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Oops, `hPutStrLn` expects type `String`, while `hGetLine` returns an `IO String`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to de-construct an `IO [String]` to get a `[String]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can't use `case`, because we don't have a constructor for `IO`... Besides,
    the order and number of deconstructions of something like `hPutStr` matters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: That's the point of the `<-` operator in `do` blocks!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another way to see IO [[Peyton Jones]](http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/edea79b58977581b0611854652353d92.svg)'
  prefs: []
  type: TYPE_IMG
- en: '`hGetLine` and `hPutStrLn` return `IO` *actions* that can change the world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure code can manipulate such actions, but can't actually execute them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the special `main` action is ever executed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another way to see IO [[Peyton Jones]](http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/af3f3977085f7e6927e9d1eb35a502ed.svg)'
  prefs: []
  type: TYPE_IMG
- en: The `do` block builds a compound action from other actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sequences how actions will be applied to the real world
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When executed, applies `IO a` actions to the world, extracting values of type
    `a`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What action to execute next can depend on the value of the extracted `a`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Running `greet`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: What if you want to run it in GHCI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'No `*` before `Main` means no access to internal symbols (because compiled),
    need to say:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `return` function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we want `greet` to return the name of the person?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Last action is `hPutStrLn :: IO ()`; want to end with action returning `name`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This does not work:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Problem: every action in an `IO` do block must have type `IO a` for some `a`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: `return` function gives trivial `IO` action returning a particular
    value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note: **`return` is not control flow statement**, just a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Point-free IO composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall point-free function composition with "`.`" (fixity `infixr 9`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function `>>=` (pronounced "bind") allows point-free IO composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's re-write `greet` with point-free style to avoid variable `name`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note `>>=` composes left-to-right, while `.` goes right-to-left
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do` blocks are just [syntactic sugar](http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14)
    for calling `>>=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise: Rock, Paper, Scissors against the computer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a function to play a particular move against a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First argument is computer's move
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Read user's move from `Handle`, tell user whether s/he won/lost/tied
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Starter code: `wget` [`cs240h.stanford.edu/rock1.hs`](http://cs240h.stanford.edu/rock1.hs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A possible solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: More on polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen a bunch of polymorphic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are some more handy ones from Prelude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Parametric vs. ad hoc polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are actually *two* kinds of polymorphism at work here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*parametric polymorphism* -- does the same thing for every type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.g., `id :: a -> a` just passes the value through'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Works for every possible type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ad hoc polymorphism* -- does different things on different types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., `1 + 1` and `1.0 + 1.0` compute very different functions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., `show` converts value to `String`, depends entirely on input type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only works on types that support it (hence "`deriving Show`" in declarations)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., no way to `show` a function (type `Int -> Int`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and Instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ad-hoc polymorphic functions are called *methods* and declared with *classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The actual method for each type is defined in an *instance* declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A class declaration can also include default definitions for methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What''s the type of a function that calls `myShow`? Ask GHCI:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Context of a type declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type declarations can contain restrictions on type variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restrictions expressed with "`(`*class* *type-var*, ...`) =>`" at start of
    type, E.g.:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Can think of context as representing hidden *dictionary* arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you call `myPrint`, you explicitly give it a value of type `a`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But also implicitly give it a function pointer for type `a`'s `MyShow` instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Dreaded](http://www.haskell.org/haskellwiki/Monomorphism_restriction) [Monomorphism
    Restriction](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5)
    (DMR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say you want to cache result of super-expensive function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`cachedResult` will start as thunk, be executed once, then contain value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's think about the types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: + and 0 are overloaded, so `superExpensive` can return any `Num` you want
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why don''t we have `cachedResult :: (Num a) => a`?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall context restrictions are like hidden arguments... so would make `cachedResult`
    into a function, undermining our caching goal!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But how is compiler smart enough to save us here?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The DMR continued
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer: in this case, compiler is not actually that smart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heuristic: If it looks like a function, can infer *ad hoc* polymorphic types'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If it looks like anything else, no *ad hoc* polymorphism unless explicitly declared
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*parametric* polymorphic types can always be inferred (no hidden arguments)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What looks like a function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has to bind a single symbol (`f`), rather than a pattern (`(x, y) =` ..., `(Just
    x) =` ...)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Has to have at least one explicit argument (`f x =` ... ok, `f =` ... not)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How are monomorphic types inferred?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If bound symbol used elsewhere in module, infer type from use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If still ambiguous and type is of class `Num`, try `Integer` then `Double` (this
    sequence can be changed with a [`default` declaration](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4))
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If still ambiguous, compilation fails
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The DMR take-away message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of type restrictions as implicit dictionary arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler won't saddle non-function with implicit arguments
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This code will compile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But neither of these will:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I'd rather you heard it from me than from GHC...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Relatively easy to work around DMR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add type signatures to functions--a good idea anyway for top-level bindings,
    and sometimes necessary for `let` bindings
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Superclasses and instance contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One class may require all instances to be members of another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `Eq` contains '==' and '/=' methods, while `Ord` contains `<`, `>=`, `>`,
    `<=`, etc.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't make sense to have an `Ord` instance not also be an `Eq` instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ord` declares `Eq` as a superclass, using a context'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Don't need to write superclass restrictions in contexts--any function with an
    `Ord` dictionary can lookup the `Eq` dictionary
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, an instance may require a context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., define `myShow` for a list of items whose type is of class `MyShow`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Classes of parameterized types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can also have classes of parameterized types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Functor` is a class for parameterized types onto which you can map functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice there are no arguments/results of type `f`, rather types `f a` and `f
    b`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of a `Functor` is `Maybe`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: More `Functor`s
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are a `Functor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]` can be used as a prefix type constructor ("`[] Int`" means "`[Int]`")
    and can be used to declare instances'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IO` is a `Functor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So we could have said:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Kinds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens if you try to make an instance of `Functor` for `Int`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get `fmap :: (a -> b) -> Int a -> Int b`, but `Int` not parameterized'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler must keep track of all the different kinds of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One kind of type (e.g., `Int`, `Double`, `()`) directly describes values
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another kind of type requires a type parameter (`Maybe`, `[]`, `IO`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet another kind of type requires *two* type parameters (`Either`, `(,)`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameterized types are sometimes called *type constructors*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinds named using symbols ∗ and →, much like curried functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∗ is the kind of type that represents values (`Int`, `Double`, `()`, etc.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ∗ → ∗ is the kind of type with one parameter of type ∗ (`Maybe`, `IO`, etc.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ∗ → ∗ → ∗ is a type constructor with two arguments of kind ∗ (`Either`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, *a* → *b* means a type constructor that, applied to kind *a*, yields
    kind *b*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Monad` class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The entire first two lectures have been working up to this slide**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return` and `>>=` are actually methods of a class called `Monad`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This has far-reaching consequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the syntactic sugar of `do` blocks for non-IO purposes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many monadic functions are polymorphic in the `Monad`--invent a new monad, and
    you can still use much existing code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Maybe` monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System libraries define a `Monad` instance for `Maybe`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can use `Nothing` to indicate failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Might have a bunch of functions to extract fields from data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Threads success/failure state through system as `IO` threaded World
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Haskell is lazy, stops computing at first `Nothing`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Algebraic data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some data types have a large number of fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Quickly gets rather unwieldy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Algebraic data types let you label fields (like C `struct`s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's make an algebraic version of our `Point` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Algebraic types - initialization and matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Can initialize an Algebraic type by naming fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Uninitialized fields get value `undefined` - a thunk that throws an exception
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can also pattern-match on any subset of fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[*As-patterns*](http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-590003.17.1)
    are handy to bind a variable and pattern simultaneously (with `@`):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Algebraic types - access and update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can use field labels as access functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`xCoord` works anywhere you can use a function of type `Point -> Double`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One consequence: field labels share the same namespace as top-level bindings,
    and must be unique'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a special syntax for updating one or more fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Obviously doesn't update destructively, but returns new, modified `Point`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Very handy to maintain state in tail recursive functions and `Monads`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A few Miscellaneous points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `!` before a data field type makes it *strict* - i.e., can't be thunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In both cases above, the first `Int` cannot hold a thunk, but only a value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When initializing an algebraic datatype, it is mandatory to initialize all strict
    fields (since they cannot hold the `undefined` thunk).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: High-level Stream (TCP & Unix-domain) socket support in [`Network`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Low-level BSD socket functions in [`Network.Socket`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`getAddrInfo`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#v:getAddrInfo)
    looks up hostnames just like [[RFC3493]](http://tools.ietf.org/html/rfc3493) (returns
    `[`[`AddrInfo`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#t:AddrInfo)`]`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll stick to the higher-level functions today
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of `withTty`, let''s define `withClient` that uses TCP:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get code: `wget` [`cs240h.stanford.edu/rock2.hs`](http://cs240h.stanford.edu/rock2.hs)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try it like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
