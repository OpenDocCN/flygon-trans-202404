- en: 'CS240h: Functional systems in Haskell'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CS240h：Haskell中的功能系统
- en: I'm David Mazières
  id: totrans-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是David Mazières
- en: Spent most of my career working on OSes, Systems, and Security
  id: totrans-2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分职业生涯都在操作系统，系统和安全方面工作
- en: Previously used C++ and C, but started using Haskell 5 years ago
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前使用C++和C，但5年前开始使用Haskell
- en: Course partly inspired by my experience learning Haskell
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 课程在某种程度上受到我学习Haskell的经验的启发
- en: 'Other instructor: Bryan O''Sullivan'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一位讲师：Bryan O'Sullivan
- en: Has implemented many key Haskell libraries in widespread use today
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经实现了许多当今广泛使用的关键Haskell库
- en: Co-wrote [*Real World Haskell*](http://book.realworldhaskell.org/), a great
    non-theoretical intro book
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合著了[*现实世界的Haskell*](http://book.realworldhaskell.org/)，一本非常好的非理论入门书籍
- en: Also plenty of systems experience (e.g., Linux early userspace code)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也有很多系统经验（例如，Linux早期用户空间代码）
- en: 'Course assistant: David Terei'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 课程助教：David Terei
- en: Member of the Haskell standards committee!
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell标准委员会的成员！
- en: Implemented [Safe Haskell](http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html)
    and GHC LLVM backend
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了[安全Haskell](http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html)和GHC
    LLVM后端
- en: Why Haskell?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择Haskell？
- en: Haskell's expressive power can improve productivity
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell的表达能力可以提高生产力
- en: Small language core provides big flexibility
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小语言核心提供了很大的灵活性
- en: Code can be very concise, speeding development
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以非常简洁，加快开发速度
- en: Get best of both worlds from compiled and interpreted languages
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从编译和解释语言中获得最佳效果
- en: Haskell makes code easier to understand and maintain
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell使代码更易于理解和维护
- en: Can dive into complex libraries and understand *what* the code is doing
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以深入研究复杂的库并理解代码在做什么
- en: (*why* may be a different story, but conciseness leaves room for comments...)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （*为什么*可能是另一回事，但简洁性留下了评论的空间...)
- en: Haskell can increase the robustness of systems
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell可以增加系统的稳健性
- en: Strong typing catches many bugs at compile time
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型在编译时捕获了许多错误
- en: Functional code permits better testing methodologies
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式代码允许更好的测试方法
- en: Can parallelize non-concurrent code without changing semantics
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在不改变语义的情况下并行化非并发代码
- en: Concurrent programming abstractions resistant to data races
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程抽象对数据竞争具有抵抗力
- en: Haskell lets you realize new types of functionality (DIFC, STM, ...)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell让你实现新类型的功能（DIFC，STM，...）
- en: Why take CS240h?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么���择CS240h？
- en: Learn to build systems in Haskell with reduced upfront cost
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会在Haskell中以较低的前期成本构建系统
- en: Historically, Haskell was a vehicle for language research.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从历史上看，Haskell是语言研究的工具。
- en: The history is reflected in how the language is usually taught
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种语言通常的教学方式反映了其历史
- en: CS240h will present the language more from a systems perspective
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CS240h将更多地从系统角度呈现这门语言
- en: Learn new, surprising, and effective programming techniques
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习新的，令人惊讶的，有效的编程技术
- en: Some are applicable to other languages (though returning to other languages
    after Haskell can be frustrating)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些内容适用于其他语言（尽管在学习Haskell后返回其他语言可能会令人沮丧）
- en: '**You enjoy programming**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你喜欢编程**'
- en: With Haskell, you will think about programming in new ways
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Haskell，你将以新的方式思考编程
- en: You sometimes get frustrated with other languages
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有时会对其他语言感到沮丧
- en: Maybe you've wanted to design a new language, or tend to "max-out" existing
    language features (macros, templates, overloading, etc.)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许你想设计一种新语言，或者倾向于“最大化”现有语言功能（宏，模板，重载等）
- en: Things that require changes to most languages can be done in a library with
    Haskell
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数语言需要更改的事情可以在Haskell库中完成
- en: Administrivia
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行政事务
- en: We assume some of you may have toyed with Haskell, others not
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设你们中的一些人可能已经尝试过Haskell，其他人则没有
- en: First week cover Haskell basics
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一周涵盖Haskell基础知识
- en: If you haven't used Haskell, you should supplement by reading parts of [Bryan's
    book](http://book.realworldhaskell.org/) and/or on-line tutorials (such as [http://www.haskell.org/tutorial/](http://www.haskell.org/tutorial/)
    or [http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters)).
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有使用过Haskell，你应该通过阅读[Bryan的书的部分内容](http://book.realworldhaskell.org/)和/或在线教程（例如[http://www.haskell.org/tutorial/](http://www.haskell.org/tutorial/)或[http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters)）来补充。
- en: If you have used Haskell, you may still learn some things from these lectures
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用过Haskell，你可能仍然可以从这些讲座中学到一些东西
- en: Rest of term covers more advanced techniques
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本学期的其余时间将涵盖更高级的技术
- en: Final grade will be based on several factors
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终成绩将基于几个因素
- en: Class attendance and participation **-- bring your laptop to class**
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上课出勤和参与度 **-- 带上你的笔记本电脑**
- en: Scribing one of the lectures **-- need a volunteer for today**
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有人可以记录其中一堂课 **-- 今天需要志愿者**
- en: We plan to collect all the notes and distribute them freely on web
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们计划收集所有笔记并在网络上免费分发
- en: Three small warm-up solo programming exercises
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个小的热身个人编程练习
- en: A large final project & presentation
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个大型的最终项目和演示
- en: Final project
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终项目
- en: Implement a project of your choice in Haskell
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Haskell 中实现你选择的项目
- en: Projects may be done in teams of 1-3 people
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目可以由1-3人组成的团队完成
- en: Meet with one of the instructors to discuss project
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其中一位教师会面讨论项目
- en: Complete and evaluate project and turn in short paper
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成并评估项目，并提交简短的论文
- en: Final exam will be mini-conference where you present your work
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终考试将是一个迷你会议，在会议上你将展示你���工作
- en: '**Attending exam Tuesday, June 10th, 7:00pm-10:00pm is mandatory**'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参加6月10日周二晚上7:00-10:00的考试是强制性的**'
- en: But by unanimous consent we could move this to Thursday June 5, 12:15-3:15pm.
    (And we would serve lunch...)
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但如果一致同意，我们可以将其移至6月5日星期四，12:15-3:15pm。（我们会提供午餐...）
- en: We encourage overlap of CS240h project with your research
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们鼓励 CS240h 项目与你的研究重叠
- en: The programming techniques you learn in CS240h are likely orthogonal to whatever
    research you are doing
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在 CS240h 中学到的编程技巧很可能与你正在进行的研究无关
- en: We are okay with CS240h project also serving as another class project,
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对 CS240h 项目同时作为另一个班级项目表示满意，
- en: '**provided the other instructor and all teammates (from both classes) approve**'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**只要另一位教师和所有队友（来自两个班级）都同意**'
- en: Getting started with Haskell
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Haskell
- en: Install [Haskell Platform](http://hackage.haskell.org/platform/) or [`cabal`](http://www.haskell.org/cabal/users-guide/)
    (sometimes `cabal-install`) + [GHC](http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装[Haskell 平台](http://hackage.haskell.org/platform/)或[`cabal`](http://www.haskell.org/cabal/users-guide/)（有时是`cabal-install`）+
    [GHC](http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html)
- en: 'Create a file called `hello.hs` with the following contents:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`hello.hs`的文件，内容如下：
- en: '[PRE0]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Compile your program to a native executable like this:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的程序编译成本地可执行文件，如下所示：
- en: '[PRE1]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or run it in the [GHCI interpreter](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html)
    like this:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者在 [GHCI 解释器](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html)
    中运行如下：
- en: '[PRE2]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Bindings
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: 'Haskell uses the `=` sign to declare *bindings*:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell 使用`=`符号声明*绑定*：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Bound names cannot start with upper-case letters
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定的名称不能以大写字母开头
- en: Bindings are separated by "`;`", which is usually auto-inserted by a [layout](http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7)
    rule
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定由“`;`”分隔，通常由[布局](http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7)规则自动插入
- en: A binding may declare a *function* of one or more arguments
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绑定可以声明一个或多个参数的*函数*
- en: Function and arguments are separated by spaces (when defining or invoking)
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和参数之间用空格分隔（在定义或调用时）
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Parentheses can wrap compound expressions, must do so for arguments
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号可以包裹复合表达式，必须为参数这样做
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Haskell is a *pure* functional language
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Haskell 是一种*纯*函数式语言
- en: Unlike variables in imperative languages, Haskell bindings are
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与命令式语言中的变量不同，Haskell 中的绑定是
- en: '*immutable* - can only bind a symbol once in a give scope (bound symbols still
    called "variables" since function arguments can vary across invocations)'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变* - 在给定范围内只能绑定一个符号一次（尽管绑定的符号仍称为“变量”，因为函数参数可以在调用中变化）'
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*order-independent* - order of bindings in source code does not matter'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无序* - 源代码中绑定的顺序不重要'
- en: '*lazy* - definitions of symbols are evaluated only when needed'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*惰性* - 仅在需要时才评估符号的定义'
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*recursive* - the bound symbol is in scope within its own definition'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*递归* - 绑定符号在其自身定义范围内'
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to program without mutable variables?
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在没有可变变量的情况下编程？
- en: 'In C, we use mutable variables to create loops:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C 中，我们使用可变变量创建循环：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In Haskell, use recursion to "re-bind" argument symbols in new scope
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Haskell 中，使用递归在新范围中“重新绑定”参数符号
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Recursion often fills a similar need to mutable variables
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归经常填补了对可变变量的类似需求
- en: But the above Haskell factorial is inferior to the C one--why?
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但上述的 Haskell 阶乘函数比 C 的差--为什么？
- en: Tail recursion
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归
- en: Each recursive call may require a stack frame
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个递归调用可能需要一个栈帧
- en: This Haskell code requires `n` stack frames
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段 Haskell 代码需要`n`个栈帧
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By contrast, our C factorial ran in constant space
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比之下，我们的 C 阶乘在常量空间中运行
- en: Fortunately, Haskell supports optimized *tail recursion*
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸运的是，Haskell 支持优化的*尾递归*
- en: A function is tail recursive if it ends with a call to itself
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数以对自身的调用结束，则该函数是尾递归的
- en: Unfortunately, `factorial n` multiplies by `n` *after* evaluating `factorial
    (n-1)`
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，`factorial n`在评估`factorial (n-1)`之后才乘以`n`
- en: 'Idea: use *accumulator* argument to make calls tail recursive'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思路：使用 *累加器* 参数使调用尾递归
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here `loop` is tail recursive, compiles to an actual loop
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里 `loop` 是尾递归的，编译成实际循环
- en: Guards and `where` clauses
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Guards 和 `where` 子句
- en: '*Guards* let you shorten function declarations:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Guards* 让您缩短函数声明：'
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '"`|`" symbol introduces a guard'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`|`" 符号引入一个 guard'
- en: Guards are evaluated top to bottom; the first `True` guard wins
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guards 从上到下进行评估；第一个 `True` guard 胜出
- en: The system Prelude (standard library) defines `otherwise = True`
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统预定义库（标准库）定义 `otherwise = True`
- en: Bindings can also end with `where` clauses--like inverted `let`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定也可以以 `where` 子句结束--类似于反转的 `let`
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unlike `let`, a `where` clause scopes over multiple guarded definitions
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `let` 不同，`where` 子句作用于多个 guard 定义
- en: This is convenient for binding variables to use in guards
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对于绑定变量以在 guard 中使用很方便
- en: 'Tip: variable names'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示：变量名
- en: Inner functions (`loop`) often have arguments related to outer function
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部函数（`loop`）通常具有与外部函数相关的参数
- en: It is legal to re-use variable names already in scope, but compiler will warn
    you
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以重复使用已在作用域中的变量名，但编译器会警告您
- en: Typical practice is to add `'` (prime) to the inner-function's argument
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型做法是为内部函数的参数添加 `'`（撇号）
- en: Haskell accepts the `'` character in variables, except as first character
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell 接受 `'` 字符作为变量，但不能作为第一个字符
- en: Personally, I find this practice a bit error-prone
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就我个人而言，我觉得这种做法有点容易出错。
- en: 'While learning Haskell, I repeatedly made the error of dropping primes, e.g.:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在学习 Haskell 时，我反复犯了删除撇号的错误，例如：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can avoid the problem by using the longer symbol name for the outer function
    (i.e., shorter name for shorter scope)
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过为外部函数使用更长的符号名称（即，更短的作用域使用更短的名称）来避免问题
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here accidentally typing "`factorial n0 = loop 1 n`" causes compile error
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里意外地输入 "`factorial n0 = loop 1 n`" 导致编译错误
- en: Every expression and binding has a type
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个表达式和绑定都有一个类型
- en: 'Some basic types:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些基本类型：
- en: '`Bool` - either `True` or `False`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bool` - 要么 `True` 要么 `False`'
- en: '`Char` - a unicode code point (i.e., a character)'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Char` - 一个 Unicode 代码点（即，一个字符）'
- en: '`Int` - fixed-size integer'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int` - 固定大小的整数'
- en: '`Integer` - an arbitrary-size integer'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Integer` - 一个任意大小的整数'
- en: '`Double` - an IEEE double-precision floating-point number'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Double` - 一个 IEEE 双精度浮点数'
- en: '*type1* `->` *type2* - a function from *type1* to *type2*'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*type1* `->` *type2* - 从 *type1* 到 *type2* 的函数'
- en: '`(`*type1*`,` *type2*`,` ...`,` *typeN*`)` - a tuple'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(`*type1*`,` *type2*`,` ...`,` *typeN*`)` - 一个元组'
- en: '`()` - a zero-tuple, pronounced *unit* (kind of like `void` in C); there is
    only one value of this type, also written `()`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()` - 一个零元组，发音为 *unit*（类似于 C 语言中的 `void`）；这种类型只有一个值，也写作 `()`'
- en: You can declare the type of a symbol or expression with `::`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `::` 声明符号或表达式的类型
- en: '[PRE18]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`::` has lower precedence than any function operators (including `+`)'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::` 的优先级低于任何函数运算符（包括 `+`）'
- en: More on types
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于类型的内容
- en: Function application happens one argument at a time (a.k.a. "*currying*")
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应用逐个参数进行（也称为“柯里化”）
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So `add 2 3` is equivalent to `(add 2) 3`
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此 `add 2 3` 等同于 `(add 2) 3`
- en: '`(add 2)` takes 3 returns 5, so `(add 2) has type Integer -> Integer`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(add 2)` 接受 3 返回 5，所以 `(add 2)` 的类型为 Integer -> Integer'
- en: '`->` associates to the right, so parens usually omitted in multi-argument function
    types:'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->` 右结合，因此在多参数函数类型中通常省略括号：'
- en: '`fn ::` *argType1* `->` *argType2* `->` ... `->` *argTypeN* `->` *resultType*'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fn ::` *argType1* `->` *argType2* `->` ... `->` *argTypeN* `->` *resultType*'
- en: Usually the compiler can infer types
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常编译器可以推断类型
- en: You can ask [GHCI](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html)
    to show you inferred types with `:t`
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `:t` 让 [GHCI](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html)
    显示推断的类型
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Good practice to declare types of top-level bindings anyway (compiler warns
    if missing)
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好总是声明顶层绑定的类型（如果缺少，编译器会警告）
- en: User-defined data types
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的数据类型
- en: 'The `data` keyword declares user-defined data types (like `struct` in C):'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 关键字声明用户定义的数据类型（类似于 C 语言中的 `struct`）：'
- en: '[PRE21]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Declares new type, `PointT` with constructor `PointC` containing two `Double`s
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明新类型，`PointT`，带有包含两个 `Double` 的构造函数 `PointC`
- en: '`deriving Show` means you can print the type (helpful in GHCI)'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deriving Show` 意味着您可以打印该类型（在 GHCI 中很有帮助）'
- en: Can also derive `Read`, `Eq`, `Ord`, `Enum`, `Bounded`
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以派生 `Read`、`Eq`、`Ord`、`Enum`、`Bounded`
- en: Note that data types and constructors *must* start with capital letters
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意数据类型和构造函数 *必须* 以大写字母开头
- en: 'Types and constructors can use the same name (often do), E.g.:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型和构造函数可以使用相同的名称（通常如此），例如：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One type can have multiple constructors (like a tagged union):'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型可以有多个构造函数（类似于标记联合）：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using data types
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据类型
- en: Constructors act like functions producing values of their types
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数就像产生其类型值的函数
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`case` statements & function bindings "de-construct" values with *patterns*'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case`语句和函数绑定使用*模式*“解构”值'
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Exercise: Rock, Paper, Scissors referee'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：石头、剪刀、布裁判
- en: 'Given the following types for a rock-paper-scissors game:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定以下类型用于石头-剪刀-布游戏：
- en: '[PRE29]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define a function `outcome :: Move -> Move -> Outcome`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '定义一个函数`outcome :: Move -> Move -> Outcome`'
- en: The first move should be your own, the second your opponent's
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个移动应该是你自己的，第二个是对手的
- en: Should tell you if you won, lost, or tied
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该告诉你赢了、输了还是平局
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Answer
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Parameterized types
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带参数的类型
- en: Types can have parameters sort of the way functions do
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型可以像函数一样具有参数
- en: Type parameters start with lower-case letters
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型参数以小写字母开头
- en: Some examples from the standard Prelude
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些标准 Prelude 中的例子
- en: '[PRE32]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can see these at work in GHCI:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 GHCI 中看到这些工作原理：
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice the type of `Left True` contains a type variable, `b`
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意`Left True`的类型包含一个类型变量，`b`
- en: Expression `Left True` can be of type `Either Bool b` for any type `b`
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式`Left True`可以是类型`Either Bool b`，其中`b`是任意类型
- en: This is an example of a feature called *parametric polymorphism*
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种被称为*参数多态性*的特性的例子
- en: More deconstruction tips
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多解构提示
- en: Special variable "`_`" can be bound but not used
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊变量"`_`"可以被绑定但不被使用
- en: 'Use it when you don''t care about a value:'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你不关心一个值时使用它：
- en: '[PRE35]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Compiler warns if a bound variable not used; `_` avoids this
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器会警告如果一个绑定变量未被使用；`_`可以避免这种情况
- en: 'You can deconstruct types and bind variables within guards, E.g.:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在守卫内部解构类型并绑定变量，例如：
- en: '[PRE37]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: though often there is a simpler way
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管通常有更简单的方法
- en: '[PRE38]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Lists
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: We could define homogeneous lists with the `data` keyword
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用`data`关键字定义同质列表
- en: '[PRE39]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: But Haskell has built-in lists with syntactic sugar
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是 Haskell 内置了具有语法糖的列表
- en: Instead of `List Integer`, the type is written `[Integer]`
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型不再是`List Integer`，而是写作`[Integer]`
- en: Instead of `Cons`, the constructor is called `:` and is *infix*
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不再是`Cons`，而是被称为`:`且是*中缀*
- en: Instead of `Nil`, the empty list is called `[]`
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表不再是`Nil`，而是被称为`[]`
- en: '[PRE40]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But there are even more convenient syntaxes for the same list:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是对于同一个列表，还有更方便的语法：
- en: '[PRE41]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A `String` is just a list of `Char`, so `['a', 'b', 'c'] == "abc"`
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`String`只是一个`Char`列表，所以`['a', 'b', 'c'] == "abc"`
- en: You can pattern match on literal lists and `String`s
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以对字面列表和`String`进行模式匹配
- en: Some basic list functions in Prelude
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prelude 中的一些基本列表函数
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note function `error :: String -> a` reports assertion failures'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '注意函数`error :: String -> a`报告断言失败'
- en: Parsing with `deriving Read` and `reads`
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`deriving Read`和`reads`进行解析
- en: We've been using "`deriving Show`" and `show` to print values
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们一直在使用"`deriving Show`"和`show`来打印值
- en: By default `show` show gives you a valid Haskell expression
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`show`会给出一个有效的 Haskell 表达式
- en: '[PRE47]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '"`deriving Read`" lets you parse a value at run time'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`deriving Read`"让你在运行时解析一个值'
- en: '[PRE48]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Problem: Might be 0, 1, or (if ambiguous) more possible parsings'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题：可能有 0、1 或（如果模棱两可）更多可能的解析
- en: Function `reads` parses and returns `[(value, string_with_rest_of_input)]`
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`reads`解析并返回`[(value, string_with_rest_of_input)]`
- en: '[PRE49]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Exercise: Using `reads`'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：使用`reads`
- en: 'Write a function to parse moves:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数来解析移动：
- en: '[PRE50]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Return `Just` move on successful parse, `Nothing` otherwise
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功解析时返回`Just`移动，否则返回`Nothing`
- en: Can optionally accept whitespace or parentheses if easier
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果更容易的话，可以选择接受空格或括号
- en: But should reject a string with any trailing content after move
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是应该拒绝在移动后有任何尾随内容的字符串
- en: 'Examples of use:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Possible solutions
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的解决方案
- en: 'Use `reads`:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`reads`：
- en: '[PRE52]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`reads` return type implicitly constrained by `parseMove`''s type declaration'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reads`的返回类型隐式受到`parseMove`的类型声明的约束'
- en: Removing `parseMove`'s type would make calling it difficult
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除`parseMove`的类型会使调用它变得困难
- en: 'Directly match keywords:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接匹配关键字：
- en: '[PRE53]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note how strings are constructors---you can pattern match on them
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意字符串是构造函数---你可以对它们进行模式匹配
- en: But this solution too finicky--won't except trailing carriage returns or spaces.
    If you did this change to using reads.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是这种解决方案太过挑剔--不会接受尾随回车或空格。如果你做了这个改变，使用`reads`。
- en: Being more permissive of line disciplines
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更宽容地处理行规则
- en: If reading terminal input, different OSes have different disciplines
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果读取终端输入，不同的操作系统有不同的规则
- en: E.g., might have trailing `"\n"` or `"\r\n"`
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，可能有尾随`"\n"`或`"\r\n"`
- en: Let's tolerate trailing whitespace
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们容忍尾随空格
- en: 'Change your definition to:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的定义改为：
- en: '[PRE54]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Should now behave like this
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在应该表现如下
- en: '[PRE55]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Hoogle
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hoogle
- en: Let's find the source code for GHC's `length` function?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们找到 GHC 的`length`函数的源代码？
- en: '[Hoogle](http://www.haskell.org/hoogle/) is a search engine just for Haskell
    functions'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Hoogle](http://www.haskell.org/hoogle/)是专门为Haskell函数设计的搜索引擎'
- en: Go to [http://www.haskell.org/hoogle/](http://www.haskell.org/hoogle/)
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前往[http://www.haskell.org/hoogle/](http://www.haskell.org/hoogle/)
- en: Click on *search plugin*
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击*search plugin*
- en: Keyword "`haskell.org`" is too long for me--I change to "`ho`"
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字"`haskell.org`"对我来说太长了--我改成"`ho`"
- en: Let's search for length... click on source
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们搜索长度...点击源代码
- en: All those `#` marks are for "unboxed types", which are faster but not asymptotically
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有那些`#`标记都是用于"未装箱类型"，它们更快但不是渐近的
- en: The important point is that `len` is tail recursive
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的一点是`len`是尾递归的
- en: I use Hoogle all the time, all the time when coding
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我在编码时一直使用Hoogle，一直使用
- en: Most of the source code is not hard to understand
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数源代码并不难理解
- en: Length may be a bad starter example just because of unboxed types
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Length可能是一个不好的起始示例，仅仅因为未装箱类型
- en: Try examining the code of the functions you are using to understand them better
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试检查你正在使用的函数的代码，以更好地理解它们
- en: 'Example: counting letters'
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子：计算字母
- en: Here's a function to count lower-case letters in a `String`
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个计算`String`中小写字母数量的函数
- en: '[PRE56]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If we fix `length`, `countLowerCase` might run in constant space
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们修复`length`，`countLowerCase`可能会在常量空间中运行
- en: Recall Haskell evaluates expressions lazily... Means in most contexts values
    are interchangeable with function pointers (a.k.a. *thunks*)
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下Haskell懒惰地评估表达式...意味着在大多数情况下，值可以与函数指针（也称为*thunks*）互换使用
- en: A `String` is a `[Char]`, which is a type with two values, a *head* and *tail*
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`是`[Char]`，这是一个具有两个值的类型，一个*头*和*尾*'
- en: But until each of the *head* or *tail* is needed, it can be stored as a function
    pointer
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但直到*头*或*尾*中的每一个被需要，它都可以被存储为函数指针
- en: So `length` will causes `filter` to produce `Char`s one at a time
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此`length`将导致`filter`逐个生成`Char`
- en: '`length` does not hold on to characters once counted; can be garbage-collected
    at will'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`在计数后不会保留字符；可以随意进行垃圾回收'
- en: Function composition
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组合
- en: Here's an even more concise definition
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一个更简洁的定义
- en: '[PRE57]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The "`.`" operator provides function composition
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`.`"运算符提供函数组合'
- en: '[PRE58]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '"`f . g`" is an ASCII approximation of mathematical "*f* ∘ *g*"'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`f . g`"是数学"*f* ∘ *g*"的ASCII近似'
- en: On previous slide, `countLowerCase`'s argument had name `str`
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上一张幻灯片上，`countLowerCase`的参数名为`str`
- en: The new version doesn't name the argument, a style called *point-free*
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新版本不命名参数，这种风格称为*point-free*
- en: Function composition can be used almost like Unix pipelines
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合几乎可以像Unix管道一样使用
- en: '[PRE59]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Exercise: Write the type of "`.`" without typing `:t (.)` into ghci'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习：不要在ghci中键入`:t (.)`，写出"`.`"的类型
- en: Lambda abstraction
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda抽象
- en: Sometimes you want to name the arguments but not the function
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时你想为参数命名但不想为函数命名
- en: Haskell allows anonymous functions through *lambda abstraction*
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell允许通过*lambda抽象*使用匿名函数
- en: The notation is `\`*variable(s)* `->` *body*
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示法是`\`*变量* `->` *主体*
- en: '"`\`" is an ASCII approximation of "*λ*", so pronounced "lambda"'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`\`"是"*λ*"的ASCII近似，因此发音为"lambda"'
- en: 'Example:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE60]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Lambda abstractions can deconstruct values with patterns, e.g.:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda抽象可以使用模式解构值，例如：
- en: '[PRE61]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: But note that guards or multiple bindings are not allowed
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但请注意，不允许使用守卫或多个绑定
- en: Patterns must have the right constructor or will get run-time error
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式必须具有正确的构造函数，否则将出现运行时错误
- en: Infix vs. Prefix notation
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中缀与前缀表示法
- en: 'We''ve seen some infix functions & constructors: `+`, `*`, `/`, `.`, `||`,
    `:`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经看到一些中缀函数和构造函数：`+`, `*`, `/`, `.`, `||`, `:`
- en: In fact, any binary function or constructor can be used infix or prefix
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，任何二元函数或构造函数都可以用作中缀或前缀
- en: For functions and constructors composed of letters, digits, `_`, and `'`
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于由字母、数字、`_`和`'`组成的函数和构造函数
- en: 'Prefix is the default: `add 1 2`'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prefix是默认的：`add 1 2`
- en: 'Putting function in backticks makes it infix: `1 `add` 2`'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数放在反引号中使其中缀：`1 `add` 2`
- en: For functions starting with one of `!#$%&*+./<=>?@\^|-~` or constructors starting
    "`:`"
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于以`!#$%&*+./<=>?@\^|-~`中的一个开头的函数
- en: Infix is default, Putting functions in parens makes them prefix, e.g., `(+)
    1 2`
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中缀是默认的，将函数放在括号中使它们成为前缀，例如，`(+) 1 2`
- en: For tuples, prefix constructors are `(,)`, `(,,)`, `(,,,)`, `(,,,,)`, etc.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于元组，前缀构造函数是`(,)`、`(,,)`、`(,,,)`、`(,,,,)`等
- en: Infix functions can be partially applied in a parenthesized *section*
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中缀函数可以在括号中部分应用
- en: '[PRE62]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Fixity
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级
- en: Most operators are just library functions in Haskell
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数操作符在Haskell中只是库函数
- en: Very few operators reserved by language syntax
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言语法中保留了很少的操作符
- en: (`..`, `:`, `::`, `=`, `\`, `|`, `<-`, `->`, `@`, `~`, `=>`, `--`)
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (`..`, `:`, `::`, `=`, `\`, `|`, `<-`, `->`, `@`, `~`, `=>`, `--`)
- en: You can go crazy and define your own operators
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以疯狂地定义自己的运算符
- en: Or even use your own definitions instead of system ones
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者甚至使用您自己的定义而不是系统的定义
- en: Define precedence of infix operators with fixity declarations
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fixity声明定义中缀运算符的优先级
- en: 'Keywords: `infixl`/`infixr`/`infix` for left/right/no associativity'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字：`infixl`/`infixr`/`infix`用于左/右/无结合性
- en: 'Syntax: *infix-keyword* [0-9] *function* [, *function* ...]'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法：*infix-keyword* [0-9] *function* [, *function* ...]
- en: Allowed wherever a type declaration is allowed
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在任何类型声明允许的地方使用
- en: 0 is lowest allowed fixity precedence, 9 is highest
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0是允许的最低优先级，9是最高优先级
- en: Prefix function application has fixity 10--higher than any infix call
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀函数应用的优先级为10--高于任何中缀调用
- en: Lambda abstractions, `else` clauses, and `let`...`in` clauses extend as far
    to the right as possible (meaning they never stop at any infix operator, no matter
    how low precedence)
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda抽象、`else`子句和`let`...`in`子句尽可能向右延伸（意味着它们永远不会停在任何中缀运算符，无论优先级多低）
- en: Fixity of specific operators
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定运算符的优先级
- en: 'Here is the fixity of the [standard operators](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820061):'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是[标准运算符](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820061)的优先级：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you can''t remember, use `:i` in [GHCI](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html):'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你记不住，可以在[GHCI](http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html)中使用`:i`：
- en: '[PRE64]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If GHCI doesn''t specify, means default: `infixl 9`'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果GHCI没有指定，表示默认为：`infixl 9`
- en: The "`infixr 0`" operators
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"`infixr 0`"运算符'
- en: '`$` is function application, but with lowest precedence'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`是函数应用，但优先级最低'
- en: '[PRE65]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Turns out to be quite useful for avoiding parentheses, E.g.:'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果证明对于避免括号非常有用，例如：
- en: '[PRE66]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`seq :: a -> b -> b` just returns value of second argument...'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seq :: a -> b -> b`只是返回第二个参数的值...'
- en: but forces evaluation of the first argument before evaluating the second
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但在评估第二个参数之前强制评估第一个参数
- en: So when you are done, the first argument is a value, not a thunk
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以当你完成时，第一个参数是一个值，而不是一个thunk
- en: '[PRE67]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`seq` has to be built into the compiler'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seq`必须内置到编译器中'
- en: '`$!` combines `$` and `seq`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$!`结合了`$`和`seq`'
- en: '[PRE68]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Accumulators revisited
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视累加器
- en: 'We used an accumulator to avoid `n0` stack frames in `factorial`:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一个累加器来避免在`factorial`中积累`n0`个栈帧：
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Unfortunately, `acc` can contain a chain of thunks `n` long
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，`acc`可能包含一个长度为`n`的thunk链
- en: '`(((1 * n) * (n - 1)) * (n - 2) ...)` -- Laziness means only evaluated when
    needed'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(((1 * n) * (n - 1)) * (n - 2) ...)` -- 惰性意味着只有在需要时才会被评估'
- en: GHC is smart enough not to build up thunks, but only if optimizing
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GHC足够聪明，不会积累thunk，但只有在优化时才会这样
- en: Can fix such problems using `$!` or `seq`
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`$!`或`seq`来解决这类问题
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Hackage and cabal
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hackage和cabal
- en: '[Hackage](http://hackage.haskell.org/packages/) is a large collection of Haskell
    packages'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Hackage](http://hackage.haskell.org/packages/)是一个大型的Haskell包集合'
- en: '[Cabal](http://www.haskell.org/cabal/users-guide/) is a tool for browsing hackage
    and installing packages'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cabal](http://www.haskell.org/cabal/users-guide/)是一个用于浏览hackage和安装包的工具'
- en: Cabal comes with the [haskell platform](http://hackage.haskell.org/platform/)
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cabal随[haskell平台](http://hackage.haskell.org/platform/)一起提供
- en: Run `cabal update` to create `$HOME/.cabal`, download package database
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`cabal update`以创建`$HOME/.cabal`，下载包数据库
- en: I highly recommend unconmenting and editing these two lines in `$HOME/.cabal/config`
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我强烈建议取消注释并编辑`$HOME/.cabal/config`中的这两行
- en: '[PRE72]'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: May want to add `$HOME/.cabal/bin` to your path
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能需要将`$HOME/.cabal/bin`添加到您的路径中
- en: I use the following shell alias
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用以下shell别名
- en: '[PRE73]'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'E.g., run: `cbi network`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，运行：`cbi network`
- en: Installs packages in `$HOME/.cabal`, and records them in `$HOME/.ghc`
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`$HOME/.cabal`中安装包，并在`$HOME/.ghc`中记录它们
- en: To start fresh, must delete both `$HOME/.cabal` and `$HOME/.ghc`
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要重新开始，必须同时删除`$HOME/.cabal`和`$HOME/.ghc`
- en: Modules and `import` syntax
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块和`import`语法
- en: Haskell groups top-level bindings into *modules*
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell将顶层绑定分组为*modules*
- en: Default module name is `Main`, as programs start at function `main` in `Main`
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认模块名为`Main`，因为程序从`Main`中的函数`main`开始
- en: Except for `Main`, a module named *M* must reside in a file named *M*`.hs`
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`Main`，命名为*M*的模块必须位于名为*M*`.hs`的文件中
- en: Module names are capitalized; I use lower-case file names for `Main` modules
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名首字母大写；我使用小写文件名来命名`Main`模块
- en: Let's add this to the top of our source file
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们将这些添加到我们源文件的顶部
- en: '[PRE74]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Start module with "`module` *name* `where`" or "`module` *name* `(`*exported-symbol*[`,`
    ...]`) where`" (non-exported symbols provide modularity)
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以"`module` *name* `where`"或"`module` *name* `(`*exported-symbol*[`,` ...]`)
    where`"（非导出符号提供模块化）开始模块
- en: '`import` *module* - imports all symbols in *module*'
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import` *module* - 导入*module*中的所有符号'
- en: '`import qualified` *module* `as` *ID* - prefixes imported symbols with *ID*`.`'
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import qualified` *module* `as` *ID* - 使用 *ID*`. ` 前缀导入的符号'
- en: '`import` *module* `(`*function1*[`,` *function2* ...]`)` - imports just the
    named functions'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import` *module* `(`*function1*[`,` *function2* ...]`)` - 只导入命名函数'
- en: '`import` *module* `hiding (`*function1*[`,` *function2* ...]`)` - imports all
    but the named functions'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import` *module* `hiding (`*function1*[`,` *function2* ...]`)` - 导入除了命名函数之外的所有函数'
- en: '`do` notation'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`do` 符号'
- en: Let's write a function to greet someone
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们写一个向某人打招呼的函数
- en: 'Type the following into a file `greet.hs`:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下内容键入到文件 `greet.hs` 中：
- en: 'Or shortcut, type: `wget` [`cs240h.stanford.edu/greet1.hs`](http://cs240h.stanford.edu/greet1.hs)'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，快捷方式，输入：`wget` [`cs240h.stanford.edu/greet1.hs`](http://cs240h.stanford.edu/greet1.hs)
- en: '[PRE75]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now try running `main` in GHCI
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在尝试在 GHCI 中运行 `main`
- en: '`do` notation'
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`do` 符号'
- en: '[PRE76]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Greeting task requires some impure (non-functional) actions
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问候任务需要一些不纯（非函数式）的操作
- en: Reading and writing a file handle
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入文件句柄
- en: 'A `do` block lets you sequence IO actions. In a `do` block:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do` 块允许您对 IO 操作进行排序。在 `do` 块中：'
- en: '*pat* `<-` *action* - binds *pat* (variable or constructor pattern) to result
    of executing *action*'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pat* `<-` *action* - 将 *pat*（变量或构造模式）绑定到执行 *action* 的结果'
- en: '`let` *pat* `=` *pure-value* - binds *pat* to *pure-value* (no "`in` ..." required)'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` *pat* `=` *pure-value* - 将 *pat* 绑定到 *pure-value*（不需要 "`in` ..."）'
- en: '*action* - executes *action* and discards the result, or returns it if at end
    of block'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*action* - 执行 *action* 并丢弃结果，或者在块末返回结果'
- en: GHCI input is like `do` block (i.e., can use `<-`, need `let` for bindings)
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GHCI 输入就像 `do` 块（即，可以使用 `<-`，需要 `let` 进行绑定）
- en: '`do`/`let`/`case` won''t parse after prefix function'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前缀函数后不会解析 `do`/`let`/`case`
- en: Usually say "`func $ do` ..."
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常说 "`func $ do` ..."
- en: Can also say "`func (do` ...`)`"
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以说 "`func (do` ...`)`"
- en: What are the types of IO actions?
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IO 操作的类型是什么？
- en: '[PRE77]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`IO` is a parameterized type (just as `Maybe` is parameterized)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO` 是一个带参数的类型（就像 `Maybe` 是带参数的一样）'
- en: '"`IO String`" means IO action that produces a `String` if executed'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`IO String`" 意味着如果执行的话会产生一个 `String` 的 IO 操作'
- en: Unlike `Maybe`, we won't use a constructor for `IO`, which is somewhat magic
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `Maybe` 不同，我们不会使用 `IO` 的构造函数，这有点神奇
- en: What if we try to copy a line of input as follows?
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们尝试按如下方式复制一行输入会怎样？
- en: '[PRE78]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Oops, `hPutStrLn` expects type `String`, while `hGetLine` returns an `IO String`
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糟糕，`hPutStrLn` 期望类型为 `String`，而 `hGetLine` 返回 `IO String`
- en: How to de-construct an `IO [String]` to get a `[String]`
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解构 `IO [String]` 以获得 `[String]`
- en: We can't use `case`, because we don't have a constructor for `IO`... Besides,
    the order and number of deconstructions of something like `hPutStr` matters
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能使用 `case`，因为我们没有 `IO` 的构造函数...此外，类似 `hPutStr` 的解构的顺序和数量很重要
- en: That's the point of the `<-` operator in `do` blocks!
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是在`do`块中使用`<-`操作符的关键！
- en: Another way to see IO [[Peyton Jones]](http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf)
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IO 的另一种看法 [[Peyton Jones]](http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf)
- en: '[PRE79]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![](../Images/edea79b58977581b0611854652353d92.svg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/edea79b58977581b0611854652353d92.svg)'
- en: '`hGetLine` and `hPutStrLn` return `IO` *actions* that can change the world'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hGetLine` 和 `hPutStrLn` 返回可以改变世界的 `IO` *actions*'
- en: Pure code can manipulate such actions, but can't actually execute them
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯代码可以操纵这种操作，但实际上不能执行它们
- en: Only the special `main` action is ever executed
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有特殊的 `main` 操作会被执行
- en: Another way to see IO [[Peyton Jones]](http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf)
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IO 的另一种看法 [[Peyton Jones]](http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf)
- en: '[PRE80]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '![](../Images/af3f3977085f7e6927e9d1eb35a502ed.svg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/af3f3977085f7e6927e9d1eb35a502ed.svg)'
- en: The `do` block builds a compound action from other actions
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do` 块从其他操作构建一个复合操作'
- en: It sequences how actions will be applied to the real world
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它按照操作将如何应用于真实世界进行了排序
- en: When executed, applies `IO a` actions to the world, extracting values of type
    `a`
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当执行时，将 `IO a` 操作应用于世界，提取类型 `a` 的值
- en: What action to execute next can depend on the value of the extracted `a`
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行的下一个动作可以取决于提取的 `a` 的值
- en: Running `greet`
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 `greet`
- en: '[PRE81]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: What if you want to run it in GHCI?
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果想在 GHCI 中运行它会怎样？
- en: '[PRE82]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'No `*` before `Main` means no access to internal symbols (because compiled),
    need to say:'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Main` 之前没有 `*` 表示没有访问内部符号的权限（因为编译了），需要这样说：
- en: '[PRE83]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `return` function
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`return` 函数'
- en: What if we want `greet` to return the name of the person?
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要 `greet` 返回人名会怎样？
- en: 'Last action is `hPutStrLn :: IO ()`; want to end with action returning `name`'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最后一个操作是 `hPutStrLn :: IO ()`；希望以返回 `name` 的操作结束'
- en: 'This does not work:'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不起作用：
- en: '[PRE84]'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Problem: every action in an `IO` do block must have type `IO a` for some `a`'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题：`IO` do 块中的每个操作都必须具有某种 `a` 类型的 `IO a`
- en: 'Solution: `return` function gives trivial `IO` action returning a particular
    value'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案：`return`函数提供返回特定值的平凡`IO`操作
- en: '[PRE85]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Note: **`return` is not control flow statement**, just a function'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意：**`return`不是控制流语句**，只是一个函数
- en: '[PRE86]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Point-free IO composition
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无点IO组合
- en: Recall point-free function composition with "`.`" (fixity `infixr 9`)
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回忆无点函数组合与"`.`"（优先级 `infixr 9`）
- en: Function `>>=` (pronounced "bind") allows point-free IO composition
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`>>=`（发音为"bind"）允许无点IO组合
- en: '[PRE87]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Let's re-write `greet` with point-free style to avoid variable `name`
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们用无点风格重新编写`greet`以避免变量`name`
- en: '[PRE88]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note `>>=` composes left-to-right, while `.` goes right-to-left
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意`>>=`从左到右组合，而`.`从右到左
- en: '`do` blocks are just [syntactic sugar](http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14)
    for calling `>>=`'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do`块只是调用`>>=`的[语法糖](http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14)'
- en: '[PRE89]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Exercise: Rock, Paper, Scissors against the computer'
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：与计算机玩剪刀石头布
- en: Write a function to play a particular move against a user
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数来对抗用户的特定移动
- en: First argument is computer's move
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是计算机的移动
- en: Read user's move from `Handle`, tell user whether s/he won/lost/tied
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Handle`读取用户的移动，告诉用户他/她赢了/输了/平局
- en: '[PRE90]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Starter code: `wget` [`cs240h.stanford.edu/rock1.hs`](http://cs240h.stanford.edu/rock1.hs)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始代码：`wget` [`cs240h.stanford.edu/rock1.hs`](http://cs240h.stanford.edu/rock1.hs)
- en: 'Example:'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例：
- en: '[PRE91]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: A possible solution
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个可能的解决方案
- en: '[PRE92]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: More on polymorphism
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于多态性
- en: We've seen a bunch of polymorphic functions
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经看到了一堆多态函数
- en: Here are some more handy ones from Prelude
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一些更方便的来自Prelude的函数
- en: '[PRE93]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Parametric vs. ad hoc polymorphism
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化与特定多态性
- en: There are actually *two* kinds of polymorphism at work here
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里实际上有*两种*多态性在起作用
- en: '*parametric polymorphism* -- does the same thing for every type'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数化多态性* -- 对每种类型都执行相同的操作'
- en: 'E.g., `id :: a -> a` just passes the value through'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '例如，`id :: a -> a`只是将值传递'
- en: Works for every possible type
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每种可能的类型都适用
- en: '*ad hoc polymorphism* -- does different things on different types'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*特定多态性* -- 在不同类型上执行不同的操作'
- en: E.g., `1 + 1` and `1.0 + 1.0` compute very different functions
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`1 + 1`和`1.0 + 1.0`计算非常不同的函数
- en: E.g., `show` converts value to `String`, depends entirely on input type
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`show`将值转换为`String`，完全取决于输入类型
- en: Only works on types that support it (hence "`deriving Show`" in declarations)
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于支持它的类型（因此在声明中 "`deriving Show`"）
- en: E.g., no way to `show` a function (type `Int -> Int`)
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，无法`show`一个函数（类型 `Int -> Int`）
- en: Classes and Instances
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和实例
- en: Ad-hoc polymorphic functions are called *methods* and declared with *classes*
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定多态函数称为*方法*，并用*类*声明
- en: '[PRE99]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The actual method for each type is defined in an *instance* declaration
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种类型的实际方法在*实例*声明中定义
- en: '[PRE100]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: A class declaration can also include default definitions for methods
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类声明也可以包括方法的默认定义
- en: 'What''s the type of a function that calls `myShow`? Ask GHCI:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`myShow`的函数的类型是什么？在GHCI中询问：
- en: '[PRE101]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The Context of a type declaration
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型声明的上下文
- en: Type declarations can contain restrictions on type variables
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型声明可以包含对类型变量的限制
- en: 'Restrictions expressed with "`(`*class* *type-var*, ...`) =>`" at start of
    type, E.g.:'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制用"`(`*class* *type-var*, ...`) =>`"在类型开始处表示，例如：
- en: '[PRE103]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Can think of context as representing hidden *dictionary* arguments
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将上下文视为表示隐藏*字典*参数
- en: When you call `myPrint`, you explicitly give it a value of type `a`
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你调用`myPrint`时，你明确给它一个类型为`a`的值
- en: But also implicitly give it a function pointer for type `a`'s `MyShow` instance
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但也隐含地为类型`a`的`MyShow`实例给出一个函数指针
- en: The [Dreaded](http://www.haskell.org/haskellwiki/Monomorphism_restriction) [Monomorphism
    Restriction](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5)
    (DMR)
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[可怕的](http://www.haskell.org/haskellwiki/Monomorphism_restriction) [单态性限制](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5)（DMR）'
- en: Let's say you want to cache result of super-expensive function
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你想要缓存超级昂贵函数的结果
- en: '[PRE107]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`cachedResult` will start as thunk, be executed once, then contain value'
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cachedResult`将作为惰性求值开始，执行一次，然后包含值'
- en: Let's think about the types
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们思考一下类型
- en: '[PRE108]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: + and 0 are overloaded, so `superExpensive` can return any `Num` you want
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`和`0`是重载的，所以`superExpensive`可以返回任何你想要的`Num`'
- en: 'Why don''t we have `cachedResult :: (Num a) => a`?'
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为什么我们没有`cachedResult :: (Num a) => a`？'
- en: Recall context restrictions are like hidden arguments... so would make `cachedResult`
    into a function, undermining our caching goal!
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回忆上下文限制就像隐藏的参数...所以会将`cachedResult`变成一个函数，破坏我们的缓存目标！
- en: But how is compiler smart enough to save us here?
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但编译器如何足够聪明地在这里为我们节省？
- en: The DMR continued
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续讨论DMR
- en: 'Answer: in this case, compiler is not actually that smart'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案：在这种情况下，编译器实际上并不那么聪明
- en: 'Heuristic: If it looks like a function, can infer *ad hoc* polymorphic types'
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启发式：如果看起来像一个函数，可以推断*特设*多态类型
- en: If it looks like anything else, no *ad hoc* polymorphism unless explicitly declared
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果看起来像其他任何东西，除非明确声明，否则不会有*特设*多态性
- en: '*parametric* polymorphic types can always be inferred (no hidden arguments)'
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数化*多态类型总是可以推断的（没有隐藏参数）'
- en: What looks like a function?
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看起来像一个函数的是什么？
- en: Has to bind a single symbol (`f`), rather than a pattern (`(x, y) =` ..., `(Just
    x) =` ...)
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须绑定一个单一符号（`f`），而不是一个模式（`(x, y) =` ...，`(Just x) =` ...）
- en: Has to have at least one explicit argument (`f x =` ... ok, `f =` ... not)
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须至少有一个显式参数（`f x =` ... 可以，`f =` ... 不行）
- en: How are monomorphic types inferred?
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单态类型是如何推断的？
- en: If bound symbol used elsewhere in module, infer type from use
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果绑定的符号在模块的其他地方使用，从使用中推断类型
- en: If still ambiguous and type is of class `Num`, try `Integer` then `Double` (this
    sequence can be changed with a [`default` declaration](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4))
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果仍然存在歧义，并且类型属于`Num`类，请尝试`Integer`然后`Double`（这个顺序可以通过[`default`声明](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4)进行更改）
- en: If still ambiguous, compilation fails
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果仍然存在歧义，编译将失败
- en: The DMR take-away message
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DMR 的主要信息
- en: Think of type restrictions as implicit dictionary arguments
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型限制视为隐式字典参数
- en: Compiler won't saddle non-function with implicit arguments
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器不会给非函数加上隐式参数
- en: This code will compile
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码将编译
- en: '[PRE109]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'But neither of these will:'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但这两者都不会：
- en: '[PRE110]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: I'd rather you heard it from me than from GHC...
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我宁愿你从我这里听到，而不是从 GHC 那里...
- en: Relatively easy to work around DMR
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对容易解决 DMR
- en: Add type signatures to functions--a good idea anyway for top-level bindings,
    and sometimes necessary for `let` bindings
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数添加类型签名--对于顶层绑定来说总是个好主意，有时对于`let`绑定是必要的
- en: '[PRE111]'
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Superclasses and instance contexts
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超类和实例上下文
- en: One class may require all instances to be members of another
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可能要求所有实例都是另一个类的成员
- en: Class `Eq` contains '==' and '/=' methods, while `Ord` contains `<`, `>=`, `>`,
    `<=`, etc.
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类`Eq`包含'=='和'/='方法，而`Ord`包含`<`，`>=`，`>`，`<=`等
- en: It doesn't make sense to have an `Ord` instance not also be an `Eq` instance
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有理由有一个`Ord`实例而不是一个`Eq`实例
- en: '`Ord` declares `Eq` as a superclass, using a context'
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ord`将`Eq`声明为一个超类，使用一个上下文'
- en: '[PRE112]'
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Don't need to write superclass restrictions in contexts--any function with an
    `Ord` dictionary can lookup the `Eq` dictionary
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要在上下文中写出超类限制--任何具有`Ord`字典的函数都可以查找`Eq`字典
- en: Similarly, an instance may require a context
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，一个实例可能需要一个上下文
- en: E.g., define `myShow` for a list of items whose type is of class `MyShow`
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，为一个类为`MyShow`的项目列表定义`myShow`
- en: '[PRE113]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Classes of parameterized types
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化类型的类
- en: Can also have classes of parameterized types
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以有参数化类型的类
- en: '`Functor` is a class for parameterized types onto which you can map functions:'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Functor`是一个类，用于将函数映射到参数化类型：'
- en: '[PRE114]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Notice there are no arguments/results of type `f`, rather types `f a` and `f
    b`
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意没有类型 `f` 的参数/结果，而是类型 `f a` 和 `f b`
- en: 'An example of a `Functor` is `Maybe`:'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Functor`的一个例子是`Maybe`：'
- en: '[PRE115]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: More `Functor`s
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多`Functor`
- en: Lists are a `Functor`
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表是一个`Functor`
- en: '`[]` can be used as a prefix type constructor ("`[] Int`" means "`[Int]`")
    and can be used to declare instances'
  id: totrans-543
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]`可以用作前缀类型构造函数（"`[] Int`"表示"`[Int]`"），并且可以用于声明实例'
- en: '[PRE117]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '`IO` is a `Functor`'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO`是一个`Functor`'
- en: '[PRE118]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'So we could have said:'
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以我们可以说：
- en: '[PRE119]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Kinds
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 种类
- en: What happens if you try to make an instance of `Functor` for `Int`?
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尝试为`Int`创建`Functor`实例会发生什么？
- en: '[PRE120]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Get `fmap :: (a -> b) -> Int a -> Int b`, but `Int` not parameterized'
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '获得`fmap :: (a -> b) -> Int a -> Int b`，但`Int`没有参数化'
- en: The compiler must keep track of all the different kinds of types
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器必须跟踪所有不同种类的类型
- en: One kind of type (e.g., `Int`, `Double`, `()`) directly describes values
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种类型（例如，`Int`，`Double`，`()`）直接描述值
- en: Another kind of type requires a type parameter (`Maybe`, `[]`, `IO`)
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种类型需要一个类型参数（`Maybe`，`[]`，`IO`）
- en: Yet another kind of type requires *two* type parameters (`Either`, `(,)`)
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种类型需要*两个*类型参数（`Either`，`(,)`）
- en: Parameterized types are sometimes called *type constructors*
  id: totrans-557
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时参数化类型被称为*类型构造函数*
- en: Kinds named using symbols ∗ and →, much like curried functions
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号 ∗ 和 → 命名种类，类似于柯里化函数
- en: ∗ is the kind of type that represents values (`Int`, `Double`, `()`, etc.)
  id: totrans-559
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∗ 是代表值的类型的种类（`Int`，`Double`，`()`等）
- en: ∗ → ∗ is the kind of type with one parameter of type ∗ (`Maybe`, `IO`, etc.)
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∗ → ∗ 是具有一个类型参数 ∗ 的类型的种类（`Maybe`，`IO`等）
- en: ∗ → ∗ → ∗ is a type constructor with two arguments of kind ∗ (`Either`)
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∗ → ∗ → ∗ 是一个带有两个参数（`Either`）的类型构造器
- en: In general, *a* → *b* means a type constructor that, applied to kind *a*, yields
    kind *b*
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，*a* → *b* 意味着一个类型构造器，应用于 *a* 类型，产生 *b* 类型
- en: The `Monad` class
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Monad` 类'
- en: '**The entire first two lectures have been working up to this slide**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前两节课都在为这张幻灯片做准备**'
- en: '`return` and `>>=` are actually methods of a class called `Monad`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return` 和 `>>=` 实际上是一个叫做 `Monad` 的类的方法'
- en: '[PRE121]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This has far-reaching consequences
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这具有深远的影响
- en: You can use the syntactic sugar of `do` blocks for non-IO purposes
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `do` 块的语法糖进行非 IO 目的
- en: Many monadic functions are polymorphic in the `Monad`--invent a new monad, and
    you can still use much existing code
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多单子函数在 `Monad` 中是多态的 - 发明一个新的单子，你仍然可以使用大部分现有的代码
- en: The `Maybe` monad
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Maybe` 单子'
- en: System libraries define a `Monad` instance for `Maybe`
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统库为 `Maybe` 定义了一个 `Monad` 实例
- en: '[PRE122]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You can use `Nothing` to indicate failure
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `Nothing` 表示失败
- en: Might have a bunch of functions to extract fields from data
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能有一堆函数从数据中提取字段
- en: '[PRE123]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Threads success/failure state through system as `IO` threaded World
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `IO` 线程化的世界将线程成功/失败状态
- en: Since Haskell is lazy, stops computing at first `Nothing`
  id: totrans-577
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Haskell 是惰性的，在第一个 `Nothing` 处停止计算
- en: Algebraic data types
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代数数据类型
- en: Some data types have a large number of fields
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些数据类型有大量字段
- en: '[PRE124]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Quickly gets rather unwieldy
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很快就会变得相当笨重
- en: Algebraic data types let you label fields (like C `struct`s)
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数数据类型允许您标记字段（类似于 C 的 `struct`）
- en: '[PRE125]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Let's make an algebraic version of our `Point` class
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们制作一个我们的 `Point` 类的代数版本
- en: '[PRE126]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Algebraic types - initialization and matching
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代数类型 - 初始化和匹配
- en: '[PRE127]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Can initialize an Algebraic type by naming fields
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过命名字段来初始化代数类型
- en: '[PRE128]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Uninitialized fields get value `undefined` - a thunk that throws an exception
  id: totrans-590
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化的字段得到值 `undefined` - 一个抛出异常的惰性计算
- en: Can also pattern-match on any subset of fields
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以在任何字段子集上模式匹配
- en: '[PRE129]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[*As-patterns*](http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-590003.17.1)
    are handy to bind a variable and pattern simultaneously (with `@`):'
  id: totrans-593
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*As-patterns*](http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-590003.17.1)
    可以方便地同时绑定变量和模式（使用 `@`）：'
- en: '[PRE130]'
  id: totrans-594
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-595
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Algebraic types - access and update
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代数类型 - 访问和更新
- en: Can use field labels as access functions
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将字段标签用作访问函数
- en: '[PRE132]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '`xCoord` works anywhere you can use a function of type `Point -> Double`'
  id: totrans-599
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xCoord` 在任何您可以使用 `Point -> Double` 类型的函数中都有效'
- en: 'One consequence: field labels share the same namespace as top-level bindings,
    and must be unique'
  id: totrans-600
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个后果：字段标签与顶层绑定共享相同的命名空间，并且必须是唯一的
- en: There is a special syntax for updating one or more fields
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一种特殊的语法来更新一个或多个字段
- en: '[PRE133]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Obviously doesn't update destructively, but returns new, modified `Point`
  id: totrans-603
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然不是破坏性地更新，而是返回新的、修改过的 `Point`
- en: Very handy to maintain state in tail recursive functions and `Monads`
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尾递归函数和 `Monads` 中维护状态非常方便
- en: A few Miscellaneous points
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些杂项要点
- en: A `!` before a data field type makes it *strict* - i.e., can't be thunk
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据字段类型之前加上 `!` 使其 *严格* - 即，不能是 thunk
- en: '[PRE134]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In both cases above, the first `Int` cannot hold a thunk, but only a value
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上述两种情况下，第一个 `Int` 不能保存一个 thunk，而只能保存一个值
- en: When initializing an algebraic datatype, it is mandatory to initialize all strict
    fields (since they cannot hold the `undefined` thunk).
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当初始化一个代数数据类型时，必须初始化所有严格字段（因为它们不能保存 `undefined` 的惰性计算）。
- en: Networking
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: High-level Stream (TCP & Unix-domain) socket support in [`Network`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network.html)
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [`Network`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network.html)
    中支持高级流（TCP 和 Unix 域）套接字
- en: '[PRE135]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Low-level BSD socket functions in [`Network.Socket`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html)
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [`Network.Socket`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html)
    中的低级 BSD 套接字函数
- en: '[PRE136]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[`getAddrInfo`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#v:getAddrInfo)
    looks up hostnames just like [[RFC3493]](http://tools.ietf.org/html/rfc3493) (returns
    `[`[`AddrInfo`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#t:AddrInfo)`]`)'
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`getAddrInfo`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#v:getAddrInfo)
    就像 [[RFC3493]](http://tools.ietf.org/html/rfc3493) 一样查找主机名（返回 `[`[`AddrInfo`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#t:AddrInfo)`]`）'
- en: We'll stick to the higher-level functions today
  id: totrans-616
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天我们将坚持使用更高级的功能
- en: Networking example
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络示例
- en: 'Instead of `withTty`, let''s define `withClient` that uses TCP:'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `withTty` 不同，让我们定义一个使用 TCP 的 `withClient`：
- en: 'To get code: `wget` [`cs240h.stanford.edu/rock2.hs`](http://cs240h.stanford.edu/rock2.hs)'
  id: totrans-619
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取代码：`wget` [cs240h.stanford.edu/rock2.hs](http://cs240h.stanford.edu/rock2.hs)
- en: '[PRE137]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Try it like this:'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试这样做：
- en: '[PRE138]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
