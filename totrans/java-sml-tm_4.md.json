["```\n@Test\npublic void testPush() {\n   Stack<String> testee = new Stack<String>();\n   testee.push(\"foo\");\n   assertThat(testee.pop()).isEqualTo(\"foo\");\n}; \n```", "```\n@Test\npublic void testPop() {\n   Stack<String> testee = new Stack<String>();\n   testee.push(\"foo\");\n   assertThat(testee.pop()).isEqualTo(\"foo\");\n}; \n```", "```\n@Test\npublic void shouldRetrieveValuesInOrderTheyAreAdded() {\n  Stack<String> testee = new Stack<String>();\n  testee.push(\"a\");\n  testee.push(\"b\");\n  assertThat(testee.pop()).isEqualTo(\"b\");\n  assertThat(testee.pop()).isEqualTo(\"a\");\n} \n```", "```\npublic class ThingaMeBob {\n\n  private final Iterable<MatchingBinaryOperator> actions;\n\n  ThingaMeBob() {\n    actions = Arrays.asList(new Addition(), new Subtraction());\n  }\n\n  public int process(String s, int a, int b) {\n    for (MatchingBinaryOperator each : actions) {\n      if (each.match(s)) {\n        return each.apply(a,b);\n      }\n    }\n\n    throw new RuntimeException();\n  }\n\n}\n\nclass Addition implements MatchingBinaryOperator {\n  public boolean match(String s) {\n    return \"add\".equals(s);\n  }\n  public int apply(int a, int b) {\n    return a + b;\n  }\n}\n\nclass Subtraction implements MatchingBinaryOperator {\n  public boolean match(String s) {\n    return \"minus\".equals(s);\n  }\n  public int apply(int a, int b) {\n    return a - b;\n  }\n} \n```", "```\npublic class AdditionTest {\n\n  Addition testee = new Addition();\n\n  @Test\n  public void shouldMatchWhenStringIsAdd() {\n  }\n\n  @Test\n  public void shouldNotMatchWhenStringIsNotAdd() {\n  }\n\n  @Test\n  public void shouldAddTwoNumbers() {\n  }\n\n  // etc\n\n} \n```", "```\npublic class ThingaMeBobTest {\n\n  ThingaMeBob testee = new ThingaMeBob();\n\n  @Test\n  public void shouldAddTwoNumbers() {\n  }\n\n  @Test\n  public void shouldSubtractTwoNumbers() {\n  }\n\n  // etc\n\n} \n```", "```\npublic class ThingaMeBob {\n\n  public int process(String s, int a, int b) {\n    if (\"add\".equals(s)) {\n      return a + b;\n    }\n\n    if (\"minus\".equals(s)) {\n      return a - b;\n    }\n\n    throw new RuntimeException();\n  }\n\n} \n```", "```\n @Test\n  public void shouldReturnItemsInOrderTheyWereAdded() {\n     ArrayDeque<String> testee = new ArrayDeque<String>();\n\n     testee.add(\"foo\");\n     testee.add(\"bar\");\n\n     assertEquals(\"foo\",testee.pop());\n     assertEquals(\"bar\",testee.pop());\n  } \n```", "```\n @Test\n  public void shouldRetrieveValuesInOrderTheyAreAdded() {\n\n    // given\n    Stack<String> testee = new Stack<String>();\n    String expectedFirstValue = \"a\";\n    String expectedSecondValue = \"b\";\n\n    // when\n    testee.push(expectedFirstValue);\n    testee.push(expectedSecondValue);\n    String actualFirstValue = testee.pop();\n    String actualSecondValue = testee.pop();\n\n    // then\n    assertThat(actualFirstValue).isEqualTo(secondValue);\n    assertThat(actualSecondValue).isEqualTo(firstValue);\n  } \n```", "```\n @Test\n  public void shouldRetrieveValuesInOrderTheyAreAdded() {\n    Stack<String> testee = new Stack<String>();\n    testee.push(\"a\");\n    testee.push(\"b\");\n    assertThat(testee.pop()).isEqualTo(\"b\");\n    assertThat(testee.pop()).isEqualTo(\"a\");\n  } \n```", "```\n @Test\n  public void shouldXXX() {\n    MyClass testee = new MyClass();\n    assertThat(testee.process(0, \"\", 3))\n      .isEqualTo(Status.FAIL);\n  } \n```", "```\n @Test\n  public void shouldXXX() {\n    int invalidValue = 3;\n    MyClass testee = new MyClass();\n    assertThat(testee.process(anInt(), aString(), invalidValue))\n      .isEqualTo(Status.FAIL);\n  } \n```", "```\n @Test\n  public void shouldXXX() {\n    assertThat(testee.process()).isEqualTo(CONTINUE);\n  } \n```", "```\n @Before\n  public void setup() {\n     MyClass testee = new MyClass();\n     testee.setDefaultProcessState(CONTINUE);\n  } \n```", "```\n @Test\n  public void shouldXXX() {\n    testee.setDefaultProcessState(CONTINUE);\n    assertThat(testee.process()).isEqualTo(CONTINUE);\n  } \n```", "```\n Foo testee = new Foo(PERFORM_VALIDATION); \n```", "```\n Foo testee = new Foo(true); \n```", "```\nassertTrue(\"Expected 2 but got \" + actual, actual == 2); \n```", "```\nassertEquals(2, actual); \n```", "```\n Mockery context = new Mockery();\n\n  // given / arrange\n  Subscriber subscriber = context.mock(Subscriber.class);\n  Publisher publisher = new Publisher();\n  publisher.add(subscriber);\n\n  final String message = \"message\";\n\n  // then / assert . . . but we haven't had a when yet\n  context.checking(new Expectations() {{\n    oneOf (subscriber).receive(message);\n  }});\n\n  // when / act\n  publisher.publish(message);\n\n  // then / assert\n  context.assertIsSatisfied(); \n```", "```\n // given\n  Subscriber subscriber = Mockito.mock(Subscriber.class);\n  Publisher publisher = new Publisher();\n  publisher.add(subscriber);\n  String message = \"message\";\n\n  // when\n  publisher.publish(message);\n\n  // then\n  Mockito.verify(subscriber).receive(message); \n```", "```\npublic interface Subscriber {\n  int receive(String message);\n} \n```", "```\n String message = \"amessage\";\n  Subscriber subscriber = Mockito.mock(Subscriber.class);\n  // inject indirect value\n  Mockito.when(subscriber.receive(message)).thenReturn(1);\n\n  Publisher publisher = new Publisher();\n  publisher.add(subscriber);\n\n  publisher.publish(message);\n\n  Mockito.verify(subscriber).receive(message); \n```", "```\n Mockito.when(subscriber.receive(message)).thenReturn(1); \n```", "```\n Mockito.verify(subscriber).receive(message); \n```", "```\n Mockito.when(subscriber.receive(anyString())).thenReturn(1); \n```", "```\n@Test\npublic void shouldIncreaseInSizeWhenItemsAdded() {\n    Collection testee = new ArrayList();\n    assertEquals(0, testee.size());\n    testee.add(\"itemA\");\n    assertEquals(1, testee.size());\n    testee.add(\"itemB\");\n    assertEquals(2, testee.size());\n} \n```", "```\n@Test(expected = FooException.class)\npublic void shouldThrowFooExceptionWhenFeelsLikeIt \n```", "```\n@Test\npublic void shouldThrowFooExceptionWhenFeelsLikeIt() {\n  try {\n    testee.doStuff();\n    fail(\"Expected an exception\");\n  } catch (FooException expectedException) {\n    assertThat(expectedException.getMessage(), is(\"felt like it\"));\n  }\n} \n```", "```\n@Rule\npublic ExpectedException thrown= ExpectedException.none();\n\n@Test\npublic void foo() throws IOException {\n  thrown.expect(FooException.class);\n  thrown.expectMessage(\"felt like it\");\n\n  testee.doStuff();\n} \n```", "```\n@Test\npublic void testException() {\n  assertThatThrownBy(() -> { testee.doStuff(); })\n   .isInstanceOf(Exception.class)\n   .hasMessageContaining(\"felt like it\");\n} \n```", "```\n @Test\n  public void shouldObeyHashCodeEqualsContract() {\n    EqualsVerifier.forClass(MyValue.class).verify();\n  } \n```", "```\n @Test\n  public void shouldObeyHashCodeEqualsContract() {\n    EqualsVerifier.forClass(MyValue.class).allFieldsShouldBeUsed().verify();\n  } \n```"]