["```\n/** An EditBuffer represents a threadsafe mutable\n *  string of characters in a text editor. */\npublic interface EditBuffer {\n    /**\n     * Modifies this by inserting a string.\n     * @param pos position to insert at\n                      (requires 0 <= pos <= current buffer length)\n     * @param ins string to insert\n     */\n    public void insert(int pos, String ins);\n\n    /**\n     * Modifies this by deleting a substring\n     * @param pos starting position of substring to delete \n     *                (requires 0 <= pos <= current buffer length)\n     * @param len length of substring to delete \n     *                (requires 0 <= len <= current buffer length - pos)\n     */\n    public void delete(int pos, int len);\n\n    /**\n     * @return length of text sequence in this edit buffer\n     */\n    public int length();\n\n    /**\n     * @return content of this edit buffer\n     */\n    public String toString();\n}\n```", "```\npublic class SimpleBuffer implements EditBuffer {\n    private String text;\n    // Rep invariant: \n    //   text != null\n    // Abstraction function: \n    //   represents the sequence text[0],...,text[text.length()-1]\n```", "```\n/** GapBuffer is a non-threadsafe EditBuffer that is optimized\n *  for editing with a cursor, which tends to make a sequence of\n *  inserts and deletes at the same place in the buffer. */\npublic class GapBuffer implements EditBuffer {\n    private char[] a;\n    private int gapStart;\n    private int gapLength;\n    // Rep invariant: \n    //   a != null\n    //   0 <= gapStart <= a.length\n    //   0 <= gapLength <= a.length - gapStart\n    // Abstraction function: \n    //   represents the sequence a[0],...,a[gapStart-1],\n    //                           a[gapStart+gapLength],...,a[length-1]\n```", "```\nObject lock = new Object();\n```", "```\nsynchronized (lock) { // thread blocks here until lock is free\n    // now this thread has the lock\n    balance = balance + 1;\n    // exiting the block releases the lock\n}\n```", "```\nsynchronized (obj) { ... }\n```", "```\n/** SimpleBuffer is a threadsafe EditBuffer with a simple rep. */\npublic class SimpleBuffer implements EditBuffer {\n    private String text;\n    ...\n    public SimpleBuffer() {\n        **synchronized (this) {**\n            text = \"\";\n            checkRep();\n        **}**\n    }\n    public void insert(int pos, String ins) {\n        **synchronized (this) {**\n            text = text.substring(0, pos) + ins + text.substring(pos);\n            checkRep();\n        **}**\n    }\n    public void delete(int pos, int len) {\n        **synchronized (this) {**\n            text = text.substring(0, pos) + text.substring(pos+len);\n            checkRep();\n        **}**\n    }\n    public int length() {\n        **synchronized (this) {**\n            return text.length();\n        **}**\n    }\n    public String toString() {\n        **synchronized (this) {**\n            return text;\n        **}**\n    }\n} \n```", "```\n/** SimpleBuffer is a threadsafe EditBuffer with a simple rep. */\npublic class SimpleBuffer implements EditBuffer {\n    private String text;\n    ...\n    public SimpleBuffer() {\n        text = \"\";\n        checkRep();\n    }\n    public **synchronized** void insert(int pos, String ins) {\n        text = text.substring(0, pos) + ins + text.substring(pos);\n        checkRep();\n    }\n    public **synchronized** void delete(int pos, int len) {\n        text = text.substring(0, pos) + text.substring(pos+len);\n        checkRep();\n    }\n    public **synchronized** int length() {\n        return text.length();\n    }\n    public **synchronized** String toString() {\n        return text;\n    }\n} \n```", "```\nsynchronized (obj) {\n    // ...\n    synchronized (obj) { // <-- uh oh, deadlock?\n        // ...\n    }\n    // <-- do we own the lock on obj?\n}\n```", "```\n/** SimpleBuffer is a threadsafe EditBuffer with a simple rep. */\npublic class SimpleBuffer implements EditBuffer {\n    private String text;\n    // Rep invariant: \n    //   text != null\n    // Abstraction function: \n    //   represents the sequence text[0],...,text[text.length()-1]\n    // Thread safety argument:\n    //   all accesses to text happen within SimpleBuffer methods,\n    //   which are all guarded by SimpleBuffer's lock\n```", "```\n public String text;\n```", "```\n/** Modifies buf by replacing the first occurrence of s with t.\n *  If s not found in buf, then has no effect.\n *  @returns true if and only if a replacement was made\n */\npublic static boolean findReplace(EditBuffer buf, String s, String t) {\n    int i = buf.toString().indexOf(s);\n    if (i == -1) {\n        return false;\n    }\n    buf.delete(i, s.length());\n    buf.insert(i, t);\n    return true;\n}\n```", "```\n/** An EditBuffer represents a threadsafe mutable string of characters\n *  in a text editor. **Clients may synchronize with each other using the\n *  EditBuffer object itself.** */\npublic interface EditBuffer {\n   ...\n} \n```", "```\npublic static boolean findReplace(EditBuffer buf, String s, String t) {\n    **synchronized (buf) {**\n        int i = buf.toString().indexOf(s);\n        if (i == -1) {\n            return false;\n        }\n        buf.delete(i, s.length());\n        buf.insert(i, t);\n        return true;\n    **}**\n} \n```", "```\npublic static synchronized boolean findReplace(EditBuffer buf, ...) {\n```", "```\npublic class Wizard {\n    private final String name;\n    private final Set<Wizard> friends;\n    // Rep invariant:\n    //    name, friends != null\n    //    friend links are bidirectional: \n    //        for all f in friends, f.friends contains this\n    // Concurrency argument:\n    //    threadsafe by monitor pattern: all accesses to rep \n    //    are guarded by this object's lock\n\n    public Wizard(String name) {\n        this.name = name;\n        this.friends = new HashSet<Wizard>();\n    }\n\n    public synchronized boolean isFriendsWith(Wizard that) {\n        return this.friends.contains(that);\n    }\n\n    public synchronized void friend(Wizard that) {\n        if (friends.add(that)) {\n            that.friend(this);\n        } \n    }\n\n    public synchronized void defriend(Wizard that) {\n        if (friends.remove(that)) {\n            that.defriend(this);\n        } \n    }\n}\n```", "```\n Wizard harry = new Wizard(\"Harry Potter\");\n    Wizard snape = new Wizard(\"Severus Snape\");\n```", "```\n // thread A                   // thread B\n    harry.friend(snape);          snape.friend(harry);\n    harry.defriend(snape);        snape.defriend(harry);\n```", "```\n public void friend(Wizard that) {\n        Wizard first, second;\n        if (this.name.compareTo(that.name) < 0) {\n            first = this; second = that;\n        } else {\n            first = that; second = this;\n        }\n        synchronized (first) {\n            synchronized (second) {\n                if (friends.add(that)) {\n                    that.friend(this);\n                } \n            }\n        }\n    }\n```", "```\npublic class Wizard {\n    private final Castle castle;\n    private final String name;\n    private final Set<Wizard> friends;\n    ...\n    public void friend(Wizard that) {\n        synchronized (castle) {\n            if (this.friends.add(that)) {\n                that.friend(this);\n            }\n        }\n    }\n}\n```", "```\nsynchronized (alpha) {\n    // using alpha\n    // ...\n}\n\nsynchronized (gamma) {\n    synchronized (beta) {\n        // using beta & gamma\n        // ...\n    }\n}\n// finished\n```", "```\nsynchronized (gamma) {\n    synchronized (alpha) {\n        synchronized (beta) {\n            // using alpha, beta, & gamma\n            // ...\n        }\n    }\n}\n// finished\n```", "```\nsynchronized (gamma) {\n    synchronized (alpha) {\n        // using alpha & gamma\n        // ...\n    }\n}\n\nsynchronized (beta) {\n    synchronized (gamma) {\n        // using beta & gamma\n        // ...\n    }\n}\n// finished\n```"]