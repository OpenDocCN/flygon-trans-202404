- en: 配列
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配列
- en: 原文：[https://jsprimer.net/basic/array/](https://jsprimer.net/basic/array/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://jsprimer.net/basic/array/](https://jsprimer.net/basic/array/)
- en: 配列はJavaScriptの中でもよく使われるオブジェクトです。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 配列はJavaScriptの中でもよく使われるオブジェクトです。
- en: 配列とは値に順序をつけて格納できるオブジェクトです。 配列に格納したそれぞれの値のことを**要素**、それぞれの要素の位置のことを**インデックス**（`index`）と呼びます。
    インデックスは先頭の要素から`0`、`1`、`2`のように`0`からはじまる連番となります。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 配列とは値に順序をつけて格納できるオブジェクトです。 配列に格納したそれぞれの値のことを**要素**、それぞれの要素の位置のことを**インデックス**（`index`）と呼びます。
    インデックスは先頭の要素から`0`、`1`、`2`のように`0`からはじまる連番となります。
- en: またJavaScriptにおける配列は可変長です。 そのため配列を作成後に配列へ要素を追加したり、配列から要素を削除できます。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: またJavaScriptにおける配列は可変長です。 そのため配列を作成後に配列へ要素を追加したり、配列から要素を削除できます。
- en: この章では、配列の基本的な操作と配列を扱う場合においてのパターンについて学びます。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: この章では、配列の基本的な操作と配列を扱う場合においてのパターンについて学びます。
- en: '[](#create-and-access)*配列の作成とアクセス*'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#create-and-access)*配列の作成とアクセス*'
- en: '*配列の作成と要素へのアクセス方法は「[データ型とリテラル](../data-type#array)」の章ですでに紹介していますが、 もう一度振り返ってみましょう。'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*配列の作成と要素へのアクセス方法は「[データ型とリテラル](../data-type#array)」の章ですでに紹介していますが、 もう一度振り返ってみましょう。'
- en: 配列の作成には配列リテラルを使います。 配列リテラル（`[`と`]`）の中に要素をカンマ（`,`）区切りで記述するだけです。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 配列の作成には配列リテラルを使います。 配列リテラル（`[`と`]`）の中に要素をカンマ（`,`）区切りで記述するだけです。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 作成した配列の要素のインデックスとなる数値を、`配列[インデックス]`と記述することで、 そのインデックスの要素を配列から読み取れます。 配列の先頭要素のインデックスは`0`となります。配列のインデックスは、`0`以上`2^32
    - 1`未満の整数となります。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作成した配列の要素のインデックスとなる数値を、`配列[インデックス]`と記述することで、 そのインデックスの要素を配列から読み取れます。 配列の先頭要素のインデックスは`0`となります。配列のインデックスは、`0`以上`2^32
    - 1`未満の整数となります。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 2次元配列（配列の配列）からの値の読み取りも同様に`配列[インデックス]`でアクセスできます。 `配列[0][0]`は、配列の`0`番目の要素である配列（`["a",
    "b"]`）の`0`番目の要素を読み取ります。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2次元配列（配列の配列）からの値の読み取りも同様に`配列[インデックス]`でアクセスできます。 `配列[0][0]`は、配列の`0`番目の要素である配列（`["a",
    "b"]`）の`0`番目の要素を読み取ります。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 配列の`length`プロパティは配列の要素の数を返します。 そのため、配列の最後の要素へアクセスするには `array.length - 1` をインデックスとして利用できます。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 配列の`length`プロパティは配列の要素の数を返します。 そのため、配列の最後の要素へアクセスするには `array.length - 1` をインデックスとして利用できます。
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 一方、存在しないインデックスにアクセスした場合はどうなるでしょうか？ JavaScriptでは、存在しないインデックスに対してアクセスした場合に、例外ではなく`undefined`を返します。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一方、存在しないインデックスにアクセスした場合はどうなるでしょうか？ JavaScriptでは、存在しないインデックスに対してアクセスした場合に、例外ではなく`undefined`を返します。
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: これは、配列がオブジェクトであることを考えると、次のように存在しないプロパティへアクセスしているのと原理は同じです。 オブジェクトでも、存在しないプロパティへアクセスした場合には`undefined`が返ってきます。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: これは、配列がオブジェクトであることを考えると、次のように存在しないプロパティへアクセスしているのと原理は同じです。 オブジェクトでも、存在しないプロパティへアクセスした場合には`undefined`が返ってきます。
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: また、配列は常に`length`の数だけ要素を持っているとは限りません。 次のように、配列リテラルでは値を省略することで、未定義の要素を含めることができます。
    このような、配列の中に隙間があるものを**疎な配列**と呼びます。 一方、隙間がなくすべてのインデックスに要素がある配列を**密な配列**と呼びます。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: また、配列は常に`length`の数だけ要素を持っているとは限りません。 次のように、配列リテラルでは値を省略することで、未定義の要素を含めることができます。
    このような、配列の中に隙間があるものを**疎な配列**と呼びます。 一方、隙間がなくすべてのインデックスに要素がある配列を**密な配列**と呼びます。
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[](#array-at)*[ES2022] `Array.prototype.at`*'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#array-at)*[ES2022] `Array.prototype.at`*'
- en: '*配列の要素にアクセスするには`配列[インデックス]`という構文を使うことを紹介しました。 その際に、配列の末尾の要素へアクセスするには、`array[array.length
    - 1]`という`length`プロパティを使う必要があります。 `array`を2回書く必要があるなど、末尾の要素へのアクセスは少し手間が必要になっていました。'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*配列の要素にアクセスするには`配列[インデックス]`という構文を使うことを紹介しました。 その際に、配列の末尾の要素へアクセスするには、`array[array.length
    - 1]`という`length`プロパティを使う必要があります。 `array`を2回書く必要があるなど、末尾の要素へのアクセスは少し手間が必要になっていました。'
- en: この問題を解決するためES2022では、相対的なインデックスの値を指定して配列の要素へアクセスできる`Array.prototype.at`メソッドが追加されました。
    Arrayの`at`メソッドは、`配列[インデックス]`とよく似ていますが、引数には相対的なインデックスの値を引数として渡せます。 `.at(0)`や`.at(1)`などのように0以上のインデックスを渡した場合は、`配列[インデックス]`と同じく指定した位置の要素へアクセスできます。
    一方で、`.at(-1)`のようにマイナスのインデックスを渡した場合は、末尾から数えた位置の要素へアクセスできます。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: この問題を解決するためES2022では、相対的なインデックスの値を指定して配列の要素へアクセスできる`Array.prototype.at`メソッドが追加されました。
    Arrayの`at`メソッドは、`配列[インデックス]`とよく似ていますが、引数には相対的なインデックスの値を引数として渡せます。 `.at(0)`や`.at(1)`などのように0以上のインデックスを渡した場合は、`配列[インデックス]`と同じく指定した位置の要素へアクセスできます。
    一方で、`.at(-1)`のようにマイナスのインデックスを渡した場合は、末尾から数えた位置の要素へアクセスできます。
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`配列[インデックス]`のインデックスに`-1`を指定すると、配列オブジェクトの`"-1"`というプロパティ名へのアクセスとなります。 そのため`配列[-1]`と書くと、大抵の場合は`undefined`が返されます。'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`配列[インデックス]`のインデックスに`-1`を指定すると、配列オブジェクトの`"-1"`というプロパティ名へのアクセスとなります。 そのため`配列[-1]`と書くと、大抵の場合は`undefined`が返されます。'
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[](#detect-array)*オブジェクトが配列かどうかを判定する*'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#detect-array)*オブジェクトが配列かどうかを判定する*'
- en: '*あるオブジェクトが配列かどうかを判定するには`Array.isArray`メソッドを利用します。 `Array.isArray`メソッドは引数が配列ならば`true`を返します。'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*あるオブジェクトが配列かどうかを判定するには`Array.isArray`メソッドを利用します。 `Array.isArray`メソッドは引数が配列ならば`true`を返します。'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: また、`typeof`演算子では配列かどうかを判定することはできません。 配列もオブジェクトの一種であるため、`typeof`演算子の結果が`"object"`となるためです。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: また、`typeof`演算子では配列かどうかを判定することはできません。 配列もオブジェクトの一種であるため、`typeof`演算子の結果が`"object"`となるためです。
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[](#typed-array)*[コラム] [ES2015] TypedArray*'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#typed-array)*[コラム] [ES2015] TypedArray*'
- en: '*JavaScriptの配列は可変長のみですが、`TypedArray`という固定長でかつ型つきの配列を扱う別のオブジェクトが存在します。 `TypedArray`はバイナリデータのバッファを示すために使われるデータ型で、WebGLやバイナリを扱う場面で利用されます。
    文字列や数値などのプリミティブ型の値を直接は利用できないため、通常の配列とは用途や使い勝手が異なります。'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScriptの配列は可変長のみですが、`TypedArray`という固定長でかつ型つきの配列を扱う別のオブジェクトが存在します。 `TypedArray`はバイナリデータのバッファを示すために使われるデータ型で、WebGLやバイナリを扱う場面で利用されます。
    文字列や数値などのプリミティブ型の値を直接は利用できないため、通常の配列とは用途や使い勝手が異なります。'
- en: また、TypedArrayは`Array.isArray`のメソッドの結果が`false`となることからも別物と考えてよいでしょう。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: また、TypedArrayは`Array.isArray`のメソッドの結果が`false`となることからも別物と考えてよいでしょう。
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: そのため、JavaScriptで配列といった場合には`Array`を示します。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: そのため、JavaScriptで配列といった場合には`Array`を示します。
- en: '[](#array-destructuring)*[ES2015] 配列と分割代入*'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#array-destructuring)*[ES2015] 配列と分割代入*'
- en: '*配列の指定したインデックスの値を変数として定義し直す場合には、分割代入（Destructuring assignment）が利用できます。'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*配列の指定したインデックスの値を変数として定義し直す場合には、分割代入（Destructuring assignment）が利用できます。'
- en: 配列の分割代入では、左辺に配列リテラルのような構文で定義したい変数名を書きます。 右辺の配列から対応するインデックスの要素が、左辺で定義した変数に代入されます。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 配列の分割代入では、左辺に配列リテラルのような構文で定義したい変数名を書きます。 右辺の配列から対応するインデックスの要素が、左辺で定義した変数に代入されます。
- en: 次のコードでは、左辺に定義した変数に対して、右辺の配列から対応するインデックスの要素が代入されます。 `first`にはインデックスが`0`の要素、`second`にはインデックスが`1`の要素、`third`にはインデックスが`2`の要素が代入されます。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、左辺に定義した変数に対して、右辺の配列から対応するインデックスの要素が代入されます。 `first`にはインデックスが`0`の要素、`second`にはインデックスが`1`の要素、`third`にはインデックスが`2`の要素が代入されます。
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[](#diff-undefined-and-no-element)*[コラム] undefinedの要素と未定義の要素の違い*'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#diff-undefined-and-no-element)*[コラム] undefinedの要素と未定義の要素の違い*'
- en: '*疎な配列で該当するインデックスに要素がない場合は`undefined`を返します。 しかし、`undefined`という値も存在するため、配列に`undefined`という値がある場合に区別できません。'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*疎な配列で該当するインデックスに要素がない場合は`undefined`を返します。 しかし、`undefined`という値も存在するため、配列に`undefined`という値がある場合に区別できません。'
- en: 次のコードでは、`undefined`という値を要素として定義した密な配列と、要素そのものがない疎な配列を定義しています。 どちらも要素にアクセスした結果は`undefined`となり、区別できていないことがわかります。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`undefined`という値を要素として定義した密な配列と、要素そのものがない疎な配列を定義しています。 どちらも要素にアクセスした結果は`undefined`となり、区別できていないことがわかります。
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: この違いを見つける方法として利用できるのが、`Object.hasOwn`静的メソッドです。 `Object.hasOwn`静的メソッドを使うことで、配列オブジェクトに対して指定したインデックスに要素自体が存在するかを判定できます。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的区别方法是`Object.hasOwn`静态方法。 使用`Object.hasOwn`静态方法，可以确定数组对象在指定索引处是否存在元素。
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[](#search-element)*配列から要素を検索*'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#search-element)*从数组中搜索元素*'
- en: '*配列から指定した要素を検索する目的には、 主に次の3つがあります。'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*主要有以下三种目的来搜索数组中的元素。'
- en: その要素のインデックスが欲しい場合
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要该元素的索引
- en: その要素自体が欲しい場合
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要元素本身
- en: その要素が含まれているかという真偽値が欲しい場合
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要该元素是否包含在数组中的布尔值
- en: 配列にはそれぞれに対応したメソッドが用意されているため、目的別に見ていきます。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组提供了相应的方法，因此可以按目的查看。
- en: '[](#indexof)*インデックスを取得*'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#indexof)*获取索引*'
- en: '*指定した要素が配列のどの位置にあるかを知りたい場合、Arrayの`indexOf`メソッドや`findIndex`メソッド^([ES2015])を利用します。
    要素の位置のことを**インデックス**（`index`）と呼ぶため、メソッド名にも`index`という名前が入っています。'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果想知道指定元素在数组中的位置，可以使用Array的`indexOf`方法或`findIndex`方法^([ES2015])。 位置的概念称为**索引**（`index`），因此方法名称中也包含`index`。'
- en: 次のコードでは、Arrayの`indexOf`メソッドを利用して、配列の中から`"JavaScript"`という文字列のインデックスを取得しています。
    `indexOf`メソッドは引数と厳密等価演算子（`===`）で一致する要素を先頭から検索して該当する要素のインデックスを返し、該当する要素がない場合は`-1`を返します。
    `indexOf`メソッドには対となる`lastIndexOf`メソッドがあり、`lastIndexOf`メソッドでは末尾から検索した結果が得られます。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码使用Array的`indexOf`方法，从数组中检索字符串`"JavaScript"`的索引。 `indexOf`方法从头开始搜索与参数和严格等式操作符（`===`）匹配的元素，并返回匹配元素的索引；如果没有匹配的元素，则返回`-1`。
    与`indexOf`方法相对应的是`lastIndexOf`方法，它从末尾开始搜索匹配结果。
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`indexOf`メソッドは配列からプリミティブな要素を発見できますが、オブジェクトは持っているプロパティが同じでも別オブジェクトだと異なるものとして扱われます。
    次のコードを見ると、同じプロパティを持つ異なるオブジェクトは、`indexOf`メソッドでは見つけることができません。 これは、異なる参照を持つオブジェクト同士は`===`で比較しても一致しないためです。'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`方法可以发现数组中的原始元素，但如果对象具有相同的属性，则会被视为不同的对象。 看下面的代码，具有相同属性的不同对象无法使用`indexOf`方法找到。
    这是因为具有不同引用的对象之间即使使用`===`比较也不会相等。'
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: このように、異なるオブジェクトだが値は同じものを見つけたい場合には、Arrayの`findIndex`メソッドが利用できます。 `findIndex`メソッドの引数には配列の各要素をテストする関数をコールバック関数として渡します。
    `indexOf`メソッドとは異なり、テストする処理を自由に書けます。 これにより、プロパティの値が同じ要素を配列から見つけて、その要素のインデックスを得ることができます。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果想要找到不同对象但值相同的对象，则可以使用Array的`findIndex`方法。 将数组的每个元素作为回调函数传递给`findIndex`方法，与`indexOf`方法不同，可以自由编写测试代码。
    这样，就可以从数组中找到具有相同属性值的元素，并获取其索引。
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Arrayの`findIndex`メソッドにも対となる`findLastIndex`メソッド^([ES2023])があり、`findLastIndex`メソッドは末尾から検索した結果が得られます。
    次のように、`findIndex`は条件に一致する最初の要素のインデックスを返しますが、`findLastIndex`は最後の要素のインデックスを返します。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Array的`findIndex`方法也有对应的`findLastIndex`方法^([ES2023])，`findLastIndex`方法返回从末尾搜索的结果。
    如下，`findIndex`返回匹配条件的第一个元素的索引，而`findLastIndex`返回最后一个元素的索引。
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[](#find)*条件に一致する要素を取得*'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#find)*获取匹配条件的元素*'
- en: '*配列から要素を取得する方法としてインデックスを使うこともできます。 先ほどのように`findIndex`メソッドでインデックスを取得し、そのインデックスで配列へアクセスすればよいだけです。'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为从数组中获取元素的方法，也可以使用索引。 只需使用`findIndex`方法获取索引，然后使用该索引访问数组即可。'
- en: しかし、`findIndex`メソッドを使って要素を取得するケースでは、 そのインデックスが欲しいのか、またはその要素自体が欲しいのかがコードとして明確ではありません。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在使用`findIndex`方法获取元素的情况下，不清楚是要获取索引还是要获取元素本身。
- en: より明確に要素自体が欲しいということを表現するには、Arrayの`find`メソッド^([ES2015])が使えます。 `find`メソッドには、`findIndex`メソッドと同様にテストする関数をコールバック関数として渡します。
    `find`メソッドの返り値は、要素そのものとなり、要素が存在しない場合は`undefined`を返します。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要更明确地表示需要元素本身，可以使用Array的`find`方法^([ES2015])。 将测试函数作为回调函数传递给`find`方法，`find`方法的返回值将是该元素本身，如果元素不存在，则返回`undefined`。
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`find`メソッドにも対となる`findLast`メソッド^([ES2023])があり、`findLast`メソッドは末尾から検索した結果が得られます。
    次のように、`find`は条件に一致した最初の要素を返しますが、`findLast`は最後の要素を返します。'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 也有与`find`方法对应的`findLast`方法^([ES2023])，`findLast`方法返回从末尾搜索的结果。 如下，`find`返回第一个匹配条件的元素，而`findLast`返回最后一个元素。
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[](#slice)*指定範囲の要素を取得*'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#slice)*获取指定范围的元素*'
- en: '*配列から指定範囲の要素を取り出す方法としてArrayの`slice`メソッドが利用できます。 `slice`メソッドは、第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい配列を返します。
    第二引数は省略でき、省略した場合は配列の末尾の要素まで含んだ新しい配列を返します。'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为从数组中获取指定范围元素的方法，可以使用Array的`slice`方法。 `slice`方法从第一个参数的起始位置到第二个参数的结束位置（不包括结束位置的元素）提取一个新数组。
    第二个参数是可选的，如果省略，则返回包含从数组末尾到末尾的元素的新数组。'
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`slice`メソッドと引数の関係を図にすると次のようになります。'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将`slice`方法与参数关联的关系如下图所示。
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[](#get-boolean)*真偽値を取得*'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#get-boolean)*获取布尔值*'
- en: '*最後に、指定した要素が配列に含まれているかを知る方法について見ていきます。 インデックスや要素が取得できれば、その要素は配列に含まれているということはわかります。'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后，让我们看看如何知道指定的元素是否包含在数组中。 如果可以获取索引或元素，则可以知道该元素是否包含在数组中。'
- en: しかし、指定した要素が含まれているか**だけ**を知りたい場合に、 Arrayの`findIndex`メソッドや`find`メソッドは過剰な機能を持っています。
    そのコードを読んだ人には、取得したインデックスや要素を何に使うのかが明確ではありません。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果只想知道指定元素是否**仅仅**包含在其中，Array的`findIndex`方法或`find`方法就具有过多的功能。 这使得阅读代码的人无法明确获取的索引或元素的用途。
- en: 次のコードは、Arrayの`indexOf`メソッドを利用し、該当する要素が含まれているかを判定しています。 `indexOf`メソッドの結果を`indexOfJS`に代入していますが、含まれているかを判定する以外には利用していません。
    コードを隅々まで読まないといけないため、意図が明確ではなくコードの読みづらさにつながります。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码使用Array的`indexOf`方法来检查数组中是否包含指定的元素。 将`indexOf`方法的结果分配给`indexOfJS`，但除了检查是否包含外，没有其他用途。
    必须完全阅读代码，才能明确意图，这导致代码的可读性不佳。
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: そこで、ES2016で導入されたArrayの`includes`メソッド^([ES2016])を利用します。 Arrayの`includes`メソッドは配列に指定要素が含まれているかを判定します。
    `includes`メソッドは真偽値を返すので、`indexOf`メソッドを使った場合に比べて意図が明確になります。 前述のコードでは次のように`includes`メソッドを使うべきでしょう。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以使用ES2016引入的Array的`includes`方法^([ES2016])。 Array的`includes`方法判断数组是否包含指定元素。
    由于`includes`方法返回布尔值，因此与使用`indexOf`方法相比，意图更明确。 在前述代码中，应该使用`includes`方法，如下所示。
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`includes`メソッドは、`indexOf`メソッドと同様、異なるオブジェクトだが値が同じものを見つけたい場合には利用できません。 Arrayの`find`メソッドのようにテストするコールバック関数を利用して真偽値を得るには、Arrayの`some`メソッドを利用できます。'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes`方法与`indexOf`方法类似，不能找到具有相同值但不同对象的对象。 要使用类似于Array的`find`方法的测试回调函数来获取布尔值，可以使用Array的`some`方法。'
- en: Arrayの`some`メソッドはテストするコールバック関数にマッチする要素があるなら`true`を返し、存在しない場合は`false`を返します （「[ループと反復処理](../loop/#array-some)」の章を参照）。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Array的`some`方法会检查回调函数是否有匹配的元素，如果有则返回`true`，否则返回`false`（参见“[循环和迭代](../loop/#array-some)”章节）。
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[](#add-and-delete)*追加と削除*'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#add-and-delete)*添加和删除*'
- en: '*配列は可変長であるため、作成後の配列に対して要素を追加、削除できます。'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于数组是可变长度的，因此可以添加或删除元素到创建后的数组。'
- en: 要素を配列の末尾へ追加するにはArrayの`push`が利用できます。 一方、末尾から要素を削除するにはArrayの`pop`が利用できます。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将元素添加到数组末尾，可以使用Array的`push`。 反之，要从末尾删除元素，可以使用Array的`pop`。
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 要素を配列の先頭へ追加するにはArrayの`unshift`が利用できます。 一方、配列の先頭から要素を削除するにはArrayの`shift`が利用できます。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要素を配列の先頭へ追加するにはArrayの`unshift`が利用できます。 一方、配列の先頭から要素を削除するにはArrayの`shift`が利用できます。
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[](#concat)*配列同士を結合*'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#concat)*配列同士を結合*'
- en: '*Arrayの`concat`メソッドを使うことで配列と配列を結合した新しい配列を作成できます。'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arrayの`concat`メソッドを使うことで配列と配列を結合した新しい配列を作成できます。'
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: また、`concat`メソッドは配列だけではなく任意の値を要素として結合できます。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: また、`concat`メソッドは配列だけではなく任意の値を要素として結合できます。
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[](#spread)*[ES2015] 配列の展開*'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#spread)*[ES2015] 配列の展開*'
- en: '*`...`（Spread構文）を使うことで、配列リテラル中に既存の配列を展開できます。'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*`...`（Spread構文）を使うことで、配列リテラル中に既存の配列を展開できます。'
- en: 次のコードでは、配列リテラルの末尾に配列を展開しています。 これは、Arrayの`concat`メソッドで配列同士を結合するのと同じ結果になります。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、配列リテラルの末尾に配列を展開しています。 これは、Arrayの`concat`メソッドで配列同士を結合するのと同じ結果になります。
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Spread構文は、`concat`メソッドとは異なり、配列リテラル中の任意の位置に配列を展開できます。 そのため、次のように要素の途中に配列を展開できます。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Spread構文は、`concat`メソッドとは異なり、配列リテラル中の任意の位置に配列を展開できます。 そのため、次のように要素の途中に配列を展開できます。
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[](#flat)*[ES2019] 配列をフラット化*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#flat)*[ES2019] 配列をフラット化*'
- en: '*Arrayの`flat`メソッド^([ES2019])を使うことで、多次元配列をフラットな配列に変換できます。 引数を指定しなかった場合は1段階のみのフラット化ですが、引数に渡す数値でフラット化する深さを指定できます。
    配列をすべてフラット化する場合には、無限を意味する`Infinity`を値として渡すことで実現できます。'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arrayの`flat`メソッド^([ES2019])を使うことで、多次元配列をフラットな配列に変換できます。 引数を指定しなかった場合は1段階のみのフラット化ですが、引数に渡す数値でフラット化する深さを指定できます。
    配列をすべてフラット化する場合には、無限を意味する`Infinity`を値として渡すことで実現できます。'
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: また、Arrayの`flat`メソッドは必ず新しい配列を作成して返すメソッドです。 そのため、これ以上フラット化できない配列をフラット化しても、同じ要素を持つ新しい配列を返します。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: また、Arrayの`flat`メソッドは必ず新しい配列を作成して返すメソッドです。 そのため、これ以上フラット化できない配列をフラット化しても、同じ要素を持つ新しい配列を返します。
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[](#delete-element)*配列から要素を削除*'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#delete-element)*配列から要素を削除*'
- en: '*### [](#splice)*`Array.prototype.splice`*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*### [](#splice)*`Array.prototype.splice`*'
- en: '*配列の先頭や末尾の要素を削除する場合はArrayの`shift`メソッドや`pop`メソッドで行えます。 しかし、配列の任意のインデックスの要素を削除できません。
    配列の任意のインデックスの要素を削除するにはArrayの`splice`メソッドを利用できます。'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*配列の先頭や末尾の要素を削除する場合はArrayの`shift`メソッドや`pop`メソッドで行えます。 しかし、配列の任意のインデックスの要素を削除できません。
    配列の任意のインデックスの要素を削除するにはArrayの`splice`メソッドを利用できます。'
- en: '`splice`メソッドを利用すると、削除した要素を自動で詰めることができます。 `splice`メソッドは指定したインデックスから、指定した数だけ要素を取り除き、必要ならば要素を同時に追加できます。'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice`メソッドを利用すると、削除した要素を自動で詰めることができます。 `splice`メソッドは指定したインデックスから、指定した数だけ要素を取り除き、必要ならば要素を同時に追加できます。'
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: たとえば、配列のインデックスが`1`の要素を削除するには、インデックス`1`から`1`つの要素を削除するという指定をする必要があります。 このとき、削除した要素は自動で詰められるため、疎な配列にはなりません。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: たとえば、配列のインデックスが`1`の要素を削除するには、インデックス`1`から`1`つの要素を削除するという指定をする必要があります。 このとき、削除した要素は自動で詰められるため、疎な配列にはなりません。
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[](#assign-to-length)*`length`プロパティへの代入*'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#assign-to-length)*`length`プロパティへの代入*'
- en: '*配列のすべての要素を削除することはArrayの`splice`で行えますが、 配列の`length`プロパティへの代入を利用した方法もあります。'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*配列のすべての要素を削除することはArrayの`splice`で行えますが、 配列の`length`プロパティへの代入を利用した方法もあります。'
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 配列の`length`プロパティへ`要素数`を代入すると、その要素数に配列が切り詰められます。 つまり、`length`プロパティへ`0`を代入すると、インデックスが`0`以降の要素がすべて削除されます。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 配列の`length`プロパティへ`要素数`を代入すると、その要素数に配列が切り詰められます。 つまり、`length`プロパティへ`0`を代入すると、インデックスが`0`以降の要素がすべて削除されます。
- en: '[](#assign-empty-array)*空の配列を代入*'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#assign-empty-array)*空の配列を代入*'
- en: '*最後に、その配列の要素を削除するのではなく、新しい空の配列を変数へ代入する方法です。 次のコードでは、`array`変数に空の配列を代入することで、`array`に空の配列を参照させられます。'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*最後に、その配列の要素を削除するのではなく、新しい空の配列を変数へ代入する方法です。 次のコードでは、`array`変数に空の配列を代入することで、`array`に空の配列を参照させられます。'
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 元々、`array`変数が参照していた`[1, 2, 3]`はどこからも参照されなくなり、ガベージコレクションによりメモリから解放されます。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 元々、`array`変数が参照していた`[1, 2, 3]`はどこからも参照されなくなり、ガベージコレクションによりメモリから解放されます。
- en: また、`const`で宣言した配列の場合は変数に対して再代入できないため、この手法は使えません。 そのため、再代入をしたい場合は`let`または`var`で変数宣言をする必要があります。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ���た、`const`で宣言した配列の場合は変数に対して再代入できないため、この手法は使えません。 そのため、再代入をしたい場合は`let`または`var`で変数宣言をする必要があります。
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[](#mutable-immutable)*破壊的なメソッドと非破壊的なメソッド*'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#mutable-immutable)*破壊的なメソッドと非破壊的なメソッド*'
- en: '*これまで紹介してきた配列を変更するメソッドには、破壊的なメソッドと非破壊的メソッドがあります。 この破壊的なメソッドと非破壊的メソッドの違いを知ることは、意図しない結果を避けるために重要です。'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*これまで紹介してきた配列を変更するメソッドには、破壊的なメソッドと非破壊的メソッドがあります。 この破壊的なメソッドと非破壊的メソッドの違いを知ることは、意図しない結果を避けるために重要です。'
- en: 破壊的なメソッド（Mutable Method）とは、配列オブジェクトそのものを変更し、変更した配列または変更箇所を返すメソッドです。 非破壊的メソッド（Immutable
    Method）とは、配列オブジェクトのコピーを作成してから変更し、そのコピーした配列を返すメソッドです。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 破壊的なメソッド（Mutable Method）とは、配列オブジェクトそのものを変更し、変更した配列または変更箇所を返すメソッドです。 非破壊的メソッド（Immutable
    Method）とは、配列オブジェクトのコピーを作成してから変更し、そのコピーした配列を返すメソッドです。
- en: 破壊的なメソッドの例として、配列に要素を追加するArrayの`push`メソッドがあります。 `push`メソッドは、`myArray`の配列そのものへ要素を追加しています。
    その結果`myArray`変数の参照する配列が変更されるため破壊的なメソッドです。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 破壊的なメソッドの例として、配列に要素を追加するArrayの`push`メソッドがあります。 `push`メソッドは、`myArray`の配列そのものへ要素を追加しています。
    その結果`myArray`変数の参照する配列が変更されるため破壊的なメソッドです。
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 非破壊的なメソッドの例として、配列に要素を結合するArrayの`concat`メソッドがあります。 `concat`メソッドは、`myArray`をコピーした配列に対して要素を結合し、その配列を返します。
    `myArray`変数の参照する配列は変更されないため非破壊的なメソッドです。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 非破壊的なメソッドの例として、配列に要素を結合するArrayの`concat`メソッドがあります。 `concat`メソッドは、`myArray`をコピーした配列に対して要素を結合し、その配列を返します。
    `myArray`変数の参照する配列は変更されないため非破壊的なメソッドです。
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: JavaScriptにおいて破壊的なメソッドと非破壊的メソッドを名前から見分けるのは難しいという問題があります。 また、配列を返す破壊的なメソッドもあるため、返り値からも判別できません。
    たとえば、Arrayの`sort`メソッドは返り値がソート済みの配列ですが破壊的メソッドです。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScriptにおいて破壊的なメソッドと非破壊的メソッドを名前から見分けるのは難しいという問題があります。 また、配列を返す破壊的なメソッドもあるため、返り値からも判別できません。
    たとえば、Arrayの`sort`メソッドは返り値がソート済みの配列ですが破壊的メソッドです。
- en: 次の表で紹介するメソッドは破壊的なメソッドです。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 次の表で紹介するメソッドは破壊的なメソッドです。
- en: '| メソッド名 | 返り値 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| メソッド名 | 返り値 |'
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | 配列の末尾の値 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | 配列の末尾の値 |'
- en: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | 変更後の配列のlength |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | 変更後の配列のlength |'
- en: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | 取り除かれた要素を含む配列 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | 取り除かれた要素を含む配列 |'
- en: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | 反転した配列 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | 反転した配列 |'
- en: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | 配列の先頭の値 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | 数组的第一个值 |'
- en: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | ソートした配列 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | 排序后的数组 |'
- en: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | 変更後の配列のlength |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | 修改后的数组的长度 |'
- en: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | 変更後の配列 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | 修改后的数组 |'
- en: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | 変更後の配列 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | 修改后的数组 |'
- en: 破壊的メソッドは意図せぬ副作用を与えてしまうことがあるため、そのことを意識して利用する必要があります。 たとえば、配列から特定のインデックスの要素を削除する`removeAtIndex`という関数を提供したいとします。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于破坏性方法可能会产生意外的副作用，因此使用时需要注意。 例如，如果想要提供一种从数组中删除特定索引处元素的函数`removeAtIndex`，就需要注意这一点。
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 次のように、破壊的なメソッドであるArrayの`splice`メソッドで要素を削除すると、引数として受け取った配列にも影響を与えます。 この場合`removeAtIndex`関数には副作用があるため、破壊的であることについてのコメントがあると親切です。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用破坏性方法删除数组中的元素时，如使用`splice`方法，将会影响作为参数传递的数组。 在这种情况下，因`removeAtIndex`函数具有副作用，因此对其具有破坏性的特性进行注释是有益的。
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 一方、非破壊的メソッドは配列のコピーを作成するため、元々の配列に対して影響はありません。 この`removeAtIndex`関数を非破壊的なものにするには、受け取った配列をコピーしてから変更を加える必要があります。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，非破坏性方法会创建数组的副本，因此对原始数组没有影响。 要将此`removeAtIndex`函数变为非破坏性函数，需要将接收到的数组复制一份，然后进行更改。
- en: JavaScriptには`copy`メソッドそのものは存在しませんが、配列をコピーする方法としてArrayの`slice`メソッドと`concat`メソッドが利用されています。
    `slice`メソッドと`concat`メソッドは引数なしで呼び出すと、その配列のコピーを返します。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中没有`copy`方法本身，但常用的数组复制方法是使用Array的`slice`方法和`concat`方法。 当不带参数调用`slice`方法和`concat`方法时，它们会返回该数组的副本。
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: コピーした配列に変更を加えることで、`removeAtIndex`関数を非破壊的な関数として実装できます。 非破壊的であれば引数の配列への副作用がないので、注意させるようなコメントは不要です。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对复制的数组进行更改，可以将`removeAtIndex`函数实现为非破坏性函数。 由于非破坏性函数不会对参数数组产生副作用，因此不需要提醒注释。
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: このようにJavaScriptの配列には破壊的なメソッドと非破壊的メソッドが混在しています。 名前からも区別することが難しく、副作用を避けるためにコピーを作ってから破壊的メソッドを使うというパターンが利用されていました。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，JavaScript数组中存在破坏性和非破坏性方法。 由于名称上的区分困难，并且为了避免副作用，人们通常会创建副本然后使用破坏性方法。
- en: しかし、ES2023でこの状況を改善する変更が追加されています。 今まで、破壊的なメソッドしかなかった、`splice`、`reverse`、`sort`に対して、
    非破壊的なバージョンである`toSpliced`、`toReversed`、`toSorted`が追加されました。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ES2023添加了一些变化以改进这种情况。 目前，仅有破坏性方法的`splice`、`reverse`和`sort`，现在也有了非破坏性版本，分别为`toSpliced`、`toReversed`和`toSorted`。
- en: これらの`to`から始まる非破壊的メソッドが受け取る引数は破壊的なメソッドと同じですが、非破壊的に変更した配列を返す点が異なります。 次のコードの`toSpliced`メソッドは、配列を複製してから変更するため、元々の配列である`array`には影響を与えていないことがわかります。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以`to`开头的这些非破坏性方法接收与破坏性方法相同的参数，但它们返回的是经过非破坏性更改的数组。 下面的`toSpliced`方法示例表明，由于它复制了数组然后进行了更改，所以原始数组`array`没有受到影响。
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 先ほど`removeAtIndex`関数の実装では、`slice`メソッドで配列をコピーしてから`splice`メソッドを呼び出していました。 次のコードでは、`toSpliced`メソッドを使うことで、より簡潔に非破壊的な`removeAtIndex`関数を実装しています。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`removeAtIndex`函数实现中，我们使用`slice`方法复制数组，然后调用`splice`方法。 下面的代码使用`toSpliced`方法更简洁地实现了非破坏性的`removeAtIndex`函数。
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: また、ES2023では配列の指定したインデックスの要素を非破壊的に変更する`with`メソッドも追加されました。 `array[index] = value`の代入処理は、元々の配列を変更する破壊的な処理です。
    これに対して`with`メソッドは、配列を複製してから指定したインデックスの要素を変更した配列を返す非破壊的なメソッドです。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ES2023还引入了用于非破坏性地更改数组中指定索引元素的`with`方法。 `array[index] = value`的赋值操作本身是一种破坏性操作，而`with`方法是一种非破坏性方法，它复制数组然后更改指定索引的元素并返回该数组。
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 次の表では、破壊的な方法に対応する非破壊的な方法をまとめています。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了破坏性方法对应的非破坏性方法。
- en: '| 破壊的な方法 | 非破壊な方法 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 破坏性方法 | 非破坏性方法 |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `array[index] = item` | [`Array.prototype.with`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/with)^([ES2023])
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `array[index] = item` | [`Array.prototype.with`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/with)^([ES2023])
    |'
- en: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | [`array.slice(0, -1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)と[`array.at(-1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | [`array.slice(0, -1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)和[`array.at(-1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
- en: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | `[...array, item]`^([ES2015]) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | `[...array, item]`^([ES2015]) |'
- en: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | [`Array.prototype.toSpliced`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced)^([ES2023])
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | [`Array.prototype.toSpliced`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced)^([ES2023])
    |'
- en: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | [`Array.prototype.toReversed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed)^([ES2023])
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | [`Array.prototype.toReversed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed)^([ES2023])
    |'
- en: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | [`Array.prototype.toSorted`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted)^([ES2023])
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | [`Array.prototype.toSorted`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted)^([ES2023])
    |'
- en: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | [`array.slice(1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)と[`array.at(0)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | [`array.slice(1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)和[`array.at(0)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
- en: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | `[item, ...array]`^([ES2015]) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | `[item, ...array]`^([ES2015]) |'
- en: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | なし |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | 无 |'
- en: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | なし |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | 无 |'
- en: 破壊的なメソッドは、シンプルですが元の配列も変更してしまうため、意図しない副作用が発生しバグの原因となる可能性があります。 非破壊的なメソッドは、使い分けが必要ですが元の配列を変更せずに新しい配列を返すため、副作用が発生することはありません。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏性方法虽然简单，但会改变原始数组，可能会导致意外的副作用和错误。 非破坏性方法需要谨慎使用，但不会改变原始数组，因此不会产生副作用。
- en: そのため、まず非破壊的な方法で書けるかを検討し、そうではない場合に破壊的な方法を利用するとよいでしょう。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先考虑使用非破坏性方法，如果不行的话，可以考虑使用破坏性方法。
- en: '[](#array-iterate)*配列を反復処理するメソッド*'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#array-iterate)*数组迭代方法*'
- en: '*「[ループと反復処理](../loop/)」の章において配列を反復処理する方法を一部解説しましたが、改めて関連するArrayメソッドを見ていきます。
    反復処理の中でもよく利用されるのがArrayの`forEach`、`map`、`filter`、`reduce`メソッドです。 どのメソッドも共通して引数にコールバック関数を受け取るため高階関数と呼ばれます。'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*在“[Loop and Iteration](../loop/)”章节中，我们部分介绍了对数组进行迭代处理的方法，现在让我们重新看一下相关的Array方法。
    `forEach`、`map`、`filter`、`reduce`方法是迭代处理中经常使用的。 这些方法都需要一个回调函数作为参数，因此被称为高阶函数。'
- en: '[](#array-foreach)*`Array.prototype.forEach`*'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#array-foreach)*`Array.prototype.forEach`*'
- en: '*Arrayの`forEach`メソッドは配列の要素を先頭から順番にコールバック関数へ渡し、反復処理を行うメソッドです。'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array的`forEach`方法会按顺序将数组元素传递给回调函数，进行迭代处理的方法。*'
- en: 次のようにコールバック関数には`要素, インデックス, 配列`が引数として渡され、配列要素の先頭から順番に反復処理します。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[](#array-map)*`Array.prototype.map`*'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#array-map)*`Array.prototype.map`*'
- en: '*Arrayの`map`メソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が返した値から新しい配列を返す非破壊的なメソッドです。 配列の各要素を加工したい場合に利用します。'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array的`map`方法会按顺序将数组元素传递给回调函数，并返回一个新数组，其中包含回调函数返回的值。 这是一个非破坏性方法，用于处理数组的每个元素。'
- en: 次のようにコールバック関数には`要素, インデックス, 配列`が引数として渡され、配列要素の先頭から順番に反復処理します。 `map`メソッドの返り値は、それぞれのコールバック関数が返した値を集めた新しい配列です。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。 `map`方法的返回值是一个包含每个回调函数返回值的新数组。
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[](#array-filter)*`Array.prototype.filter`*'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#array-filter)*`Array.prototype.filter`*'
- en: '*Arrayの`filter`メソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が`true`を返した要素だけを集めた新しい配列を返す非破壊的なメソッドです。
    配列から不要な要素を取り除いた配列を作成したい場合に利用します。'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array的`filter`方法会按顺序将数组元素传递给回调函数，返回回调函数返回`true`的元素组成的新数组。 这是一个非破坏性方法，用于创建一个新数组，其中包含从数组中删除不需要的元素。'
- en: 次のようにコールバック関数には`要素, インデックス, 配列`が引数として渡され、配列要素の先頭から順番に反復処理します。 `filter`メソッドの返り値は、コールバック関数が`true`を返した要素だけを集めた新しい配列です。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。 `filter`方法的返回值是回调函数返回`true`的元素组成的新数组。
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[](#array-reduce)*`Array.prototype.reduce`*'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#array-reduce)*`Array.prototype.reduce`*'
- en: '*Arrayの`reduce`メソッドは累積値（アキュムレータ）と配列の要素を順番にコールバック関数へ渡し、1つの累積値を返します。 配列から配列以外を含む任意の値を作成したい場合に利用します。'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array的`reduce`方法会累加器和数组元素依次传递给回调函数，并返回一个累加器。 当你想要从数组中创建一个不包含数组的任意值时，可以使用它。'
- en: ここまでで紹介した反復処理のメソッドとは異なり、コールバック関数には`累積値, 要素, インデックス, 配列`を引数として渡します。 `reduce`メソッドの第二引数には`累積値`の初期値となる値を渡せます。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前介绍的迭代处理方法不同，回调函数的参数是`accumulator, element, index, array`。 你可以在`reduce`方法的第二个参数中传递一个初始值给`accumulator`。
- en: 次のコードでは、`reduce`メソッドは初期値を0として配列の各要素を加算した1つの数値を返します。 つまり配列から配列要素の合計値というNumber型の値を返しています。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`reduce`方法将数组的每个元素相加并返回一个数字作为累加器的初始值。也就是说，它返回了数组元素的总和作为一个Number类型的值。
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`reduce`メソッドに渡したコールバック関数は配列の要素数である3回呼び出され、それぞれ次のような結果になります。'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`reduce`方法的回调函数会被调用3次，每次都会传递以下参数，并产生以下结果。
- en: '|  | accumulator | currentValue | returnした値 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  | accumulator | currentValue | 返回的值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1回目の呼び出し | 0 | 1 | 0 + 1 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 第一次调用 | 0 | 1 | 0 + 1 |'
- en: '| 2回目の呼び出し | 1 | 2 | 1 + 2 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 第二次调用 | 1 | 2 | 1 + 2 |'
- en: '| 3回目の呼び出し | 3 | 3 | 3 + 3 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 第三次调用 | 3 | 3 | 3 + 3 |'
- en: Arrayの`reduce`メソッドはやや複雜ですが、配列から配列以外のデータ型の値を作成できる特徴があります。 また、`reduce`メソッドでは、配列から直接Number型の値を返せるため、`totalValue`という変数を再代入できない`const`で宣言していました。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Array的`reduce`方法稍微复杂一些，但它具有从数组创建非数组数据类型值的功能。 此外，由于`reduce`方法可以直接从数组返回Number类型的值，因此在声明了无法重新赋值的`const`变量`totalValue`。
- en: 配列の数値の合計を`forEach`メソッドなど反復処理で計算すると、次のコードのように`totalValue`という変数は再代入ができる`let`で宣言する必要があります。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`forEach`方法等迭代处理计算数组数字总和时，需要使用`let`声明的变量`totalValue`以便重新赋值。
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`let`で宣言した変数は再代入が可能なため、意図しない箇所で変数の値が変更され、バグの原因となることがあります。 そのため、できる限り変数を`const`で宣言したい場合には`reduce`メソッドは有用です。
    一方で、`reduce`メソッドは可読性があまりよくないため、コードの意図が伝わりにくいというデメリットもあります。'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用`let`声明的变量可以重新赋值，所以变量的值可能会在意外的地方更改，从而导致错误。 因此，在可能的情况下，最好使用`const`声明变量。 在这种情况下，`reduce`方法非常有用。
    另一方面，`reduce`方法的可读性不太好，这可能会导致代码意图不明确。
- en: '`reduce`メソッドには利点と可読性のトレードオフがありますが、利用する場合は`reduce`メソッドを扱う処理を関数で囲むなど処理の意図がわかるように工夫をする必要があります。'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`reduce`方法具有优点和可读性的折衷，但在使用时需要注意确保代码清晰易懂。 尤其是在处理`reduce`方法时，应该通过函数封装来明确处理意图。
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[](#array-like)*[コラム] Array-likeオブジェクト*'
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#array-like)*[专栏] 类似数组对象*'
- en: '*配列のように扱えるが配列ではないオブジェクトのことを、**Array-likeオブジェクト**と呼びます。 Array-likeオブジェクトとは配列のようにインデックスにアクセスでき、配列のように`length`プロパティも持っています。しかし、配列のインスタンスではないため、Arrayのプロトタイプメソッドを持っていないオブジェクトのことです。'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*类似数组的对象称为**Array-like对象**。Array-like对象可以像数组一样通过索引进行访问，并且像数组一样具有`length`属性。但是，它不是数组的实例，因此指的是不具有数组原型方法的对象。'
- en: '| 機能 | Array-likeオブジェクト | 配列 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 类似数组对象 | 数组 |'
- en: '| --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| インデックスアクセス（`array[0]`） | できる | できる |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 索引访问（`array[0]`） | 可以 | 可以 |'
- en: '| 長さ（`array.length`） | 持っている | 持っている |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 长度（`array.length`） | 拥有 | 拥有 |'
- en: '| Arrayのプロトタイプメソッド(`forEach`メソッドなど) | 持っていない場合もある | 持っている |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| Array原型方法（如`forEach`方法等） | 有时没有 | 有 |'
- en: Array-likeオブジェクトの例として`arguments`があります。 `arguments`オブジェクトは、`function`で宣言した関数の中から参照できる変数です。
    `arguments`オブジェクトには関数の引数に渡された値が順番に格納されていて、配列のように引数へアクセスできます。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 类似数组对象的例子包括`arguments`。 `arguments`对象是可以从`function`声明的函数中引用的变量。 `arguments`对象按顺序存储传递给函数的参数值，并且可以像数组一样访问参数。
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Array-likeオブジェクトか配列なのかを判別するには`Array.isArray`メソッドを利用できます。 `Array-like`オブジェクトは配列ではないので結果は常に`false`となります。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Array-like对象还是数组可以通过使用`Array.isArray`方法来判断。 `Array-like`对象不是数组，所以结果始终为`false`。
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Array-likeオブジェクトは配列のようで配列ではないというもどかしさを持つオブジェクトです。`Array.from`メソッド^([ES2015])を使うことでArray-likeオブジェクトを配列に変換して扱うことができます。一度配列に変換してしまえばArrayメソッドも利用できます。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Array-like对象是一种看起来像数组但不是数组的对象。 使用`Array.from`方法^([ES2015])可以将Array-like对象转换为数组以进行处理。
    一旦转换为数组，就可以使用Array方法。
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[](#method-chain-and-high-order-function)*メソッドチェーンと高階関数*'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#method-chain-and-high-order-function)*方法链与高阶函数*'
- en: '*配列で頻出するパターンとしてメソッドチェーンがあります。 メソッドチェーンとは、メソッドを呼び出した返り値に対してさらにメソッド呼び出しをするパターンのことを言います。'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组经常使用方法链的模式。 方法链是指对调用方法的返回值进行进一步的方法调用的模式。'
- en: 次のコードでは、Arrayの`concat`メソッドの返り値、つまり配列に対してさらに`concat`メソッドを呼び出すというメソッドチェーンが行われています。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，对Array的`concat`方法的返回值，也就是对数组进一步调用`concat`方法的方法链进行了处理。
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: このコードの`concat`メソッドの呼び出しを分解してみると何が行われているのかわかりやすいです。 `concat`メソッドの返り値は結合した新しい配列です。先ほどのメソッドチェーンでは、その新しい配列に対してさらに`concat`メソッドで値を結合しているということがわかります。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码中的`concat`方法调用拆分开来可以更容易理解正在发生的事情。 `concat`方法的返回值是合并的新数组。在之前的方法链中，可以看到正在对该新数组进行进一步的值合并，使用`concat`方法。
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: メソッドチェーンを利用することで処理の見た目を簡潔にできます。メソッドチェーンを利用した場合も最終的な処理結果は同じですが、途中の一時的な変数を省略できます。先ほどの例では`abArray`という一時的な変数をメソッドチェーンでは省略できています。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法链可以使处理过程更简洁。 尽管使用方法链的最终处理结果与其他方式相同，但可以省略中间的临时变量。 在上面的示例中，方法链中省略了名为`abArray`的临时变量。
- en: メソッドチェーンは配列に限ったものではありませんが、配列では頻出するパターンです。なぜなら、配列に含まれるデータを表示する際には、最終的に文字列や数値など別のデータへ加工することがほとんどであるためです。配列には配列を返す高階関数が多く実装されているため、配列を柔軟に加工できます。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链不仅限于数组，但在数组中常见。 这是因为在显示数组数据时，通常需要将其处理为其他数据类型，如字符串或数字。 由于数组实现了许多返回数组的高阶函数，因此可以灵活处理数组。
- en: 次のコードでは、ECMAScriptのバージョン名と発行年数が定義された`ECMAScriptVersions`という配列が定義されています。この配列から`2000`年以前に発行されたECMAScriptのバージョン名の一覧を取り出すことを考えてみます。目的の一覧を取り出すには「2000年以前のデータに絞り込む」と「データから`name`を取り出す」という2つの加工処理を組み合わせる必要があります。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码定义了一个名为`ECMAScriptVersions`的数组，其中包含了ECMAScript的版本名称和发布年份。 假设我们要从该数组中提取`2000`年以前发行的ECMAScript版本名称列表。
    为了实现这个目标，需要将“筛选出2000年以前的数据”和“从数据中提取`name`”这两个处理结合起来。
- en: この2つの加工処理はArrayの`filter`メソッドと`map`メソッドで実現できます。 `filter`メソッドで配列から`2000`年以前というルールで絞り込み、`map`メソッドでそれぞれの要素から`name`プロパティを取り出せます。
    どちらのメソッドも配列を返すのでメソッドチェーンで処理をつなげられます。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个处理可以通过Array的`filter`方法和`map`方法来实现。 使用`filter`方法从数组中筛选出在`2000`年之前的数据，然后使用`map`方法从每个元素中提取`name`属性。
    由于这两种方法都返回数组，因此可以在方法链中连接它们。
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: メソッドチェーンを使うことで複数の処理からなるものをひとつのまとまった処理のように見せることができます。長過ぎるメソッドチェーンは長過ぎる関数と同じように読みにくくなりますが、適度な単位のメソッドチェーンは処理をスッキリ見せるパターンとして利用されています。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法链可以将由多个处理组成的处理看作一个整体处理。 过长的方法链会导致函数过长，难以阅读，但适度的方法链可以使处理过程更清晰。
- en: '[](#conclusion)*まとめ*'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#conclusion)*总结*'
- en: '*この章では配列について学びました。'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章介绍了数组相关内容。'
- en: 配列は順序を持った要素を格納できるオブジェクトの一種
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是一种可以存储有序元素的对象。
- en: 配列には破壊的なメソッドと非破壊的なメソッドがある
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组有破坏性方法和非破坏性方法。
- en: 配列には反復処理を行う高階関数となるメソッドがある
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组具有用于执行迭代处理的高阶函数方法。
- en: メソッドチェーンは配列のメソッドが配列を返すことを利用している
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法链利用数组方法返回数组的特性。
- en: 配列はJavaScriptの中でもよく使われるオブジェクトで、メソッドの種類も多いです。 この書籍でもすべてのメソッドは紹介していないため、詳しくは[Arrayについてのドキュメント](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array)も参照してみてください。****************************
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是JavaScript中经常使用的对象之一，有许多不同类型的方法。 由于本书未介绍所有方法，请参阅[有关数组的文档](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array)以获取更多详细信息。
