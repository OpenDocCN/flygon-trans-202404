- en: 配列
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/array/](https://jsprimer.net/basic/array/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 配列はJavaScriptの中でもよく使われるオブジェクトです。
  prefs: []
  type: TYPE_NORMAL
- en: 配列とは値に順序をつけて格納できるオブジェクトです。 配列に格納したそれぞれの値のことを**要素**、それぞれの要素の位置のことを**インデックス**（`index`）と呼びます。
    インデックスは先頭の要素から`0`、`1`、`2`のように`0`からはじまる連番となります。
  prefs: []
  type: TYPE_NORMAL
- en: またJavaScriptにおける配列は可変長です。 そのため配列を作成後に配列へ要素を追加したり、配列から要素を削除できます。
  prefs: []
  type: TYPE_NORMAL
- en: この章では、配列の基本的な操作と配列を扱う場合においてのパターンについて学びます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#create-and-access)*配列の作成とアクセス*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*配列の作成と要素へのアクセス方法は「[データ型とリテラル](../data-type#array)」の章ですでに紹介していますが、 もう一度振り返ってみましょう。'
  prefs: []
  type: TYPE_NORMAL
- en: 配列の作成には配列リテラルを使います。 配列リテラル（`[`と`]`）の中に要素をカンマ（`,`）区切りで記述するだけです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 作成した配列の要素のインデックスとなる数値を、`配列[インデックス]`と記述することで、 そのインデックスの要素を配列から読み取れます。 配列の先頭要素のインデックスは`0`となります。配列のインデックスは、`0`以上`2^32
    - 1`未満の整数となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 2次元配列（配列の配列）からの値の読み取りも同様に`配列[インデックス]`でアクセスできます。 `配列[0][0]`は、配列の`0`番目の要素である配列（`["a",
    "b"]`）の`0`番目の要素を読み取ります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 配列の`length`プロパティは配列の要素の数を返します。 そのため、配列の最後の要素へアクセスするには `array.length - 1` をインデックスとして利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 一方、存在しないインデックスにアクセスした場合はどうなるでしょうか？ JavaScriptでは、存在しないインデックスに対してアクセスした場合に、例外ではなく`undefined`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: これは、配列がオブジェクトであることを考えると、次のように存在しないプロパティへアクセスしているのと原理は同じです。 オブジェクトでも、存在しないプロパティへアクセスした場合には`undefined`が返ってきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: また、配列は常に`length`の数だけ要素を持っているとは限りません。 次のように、配列リテラルでは値を省略することで、未定義の要素を含めることができます。
    このような、配列の中に隙間があるものを**疎な配列**と呼びます。 一方、隙間がなくすべてのインデックスに要素がある配列を**密な配列**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[](#array-at)*[ES2022] `Array.prototype.at`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*配列の要素にアクセスするには`配列[インデックス]`という構文を使うことを紹介しました。 その際に、配列の末尾の要素へアクセスするには、`array[array.length
    - 1]`という`length`プロパティを使う必要があります。 `array`を2回書く必要があるなど、末尾の要素へのアクセスは少し手間が必要になっていました。'
  prefs: []
  type: TYPE_NORMAL
- en: この問題を解決するためES2022では、相対的なインデックスの値を指定して配列の要素へアクセスできる`Array.prototype.at`メソッドが追加されました。
    Arrayの`at`メソッドは、`配列[インデックス]`とよく似ていますが、引数には相対的なインデックスの値を引数として渡せます。 `.at(0)`や`.at(1)`などのように0以上のインデックスを渡した場合は、`配列[インデックス]`と同じく指定した位置の要素へアクセスできます。
    一方で、`.at(-1)`のようにマイナスのインデックスを渡した場合は、末尾から数えた位置の要素へアクセスできます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`配列[インデックス]`のインデックスに`-1`を指定すると、配列オブジェクトの`"-1"`というプロパティ名へのアクセスとなります。 そのため`配列[-1]`と書くと、大抵の場合は`undefined`が返されます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[](#detect-array)*オブジェクトが配列かどうかを判定する*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*あるオブジェクトが配列かどうかを判定するには`Array.isArray`メソッドを利用します。 `Array.isArray`メソッドは引数が配列ならば`true`を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: また、`typeof`演算子では配列かどうかを判定することはできません。 配列もオブジェクトの一種であるため、`typeof`演算子の結果が`"object"`となるためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[](#typed-array)*[コラム] [ES2015] TypedArray*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptの配列は可変長のみですが、`TypedArray`という固定長でかつ型つきの配列を扱う別のオブジェクトが存在します。 `TypedArray`はバイナリデータのバッファを示すために使われるデータ型で、WebGLやバイナリを扱う場面で利用されます。
    文字列や数値などのプリミティブ型の値を直接は利用できないため、通常の配列とは用途や使い勝手が異なります。'
  prefs: []
  type: TYPE_NORMAL
- en: また、TypedArrayは`Array.isArray`のメソッドの結果が`false`となることからも別物と考えてよいでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: そのため、JavaScriptで配列といった場合には`Array`を示します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#array-destructuring)*[ES2015] 配列と分割代入*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*配列の指定したインデックスの値を変数として定義し直す場合には、分割代入（Destructuring assignment）が利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 配列の分割代入では、左辺に配列リテラルのような構文で定義したい変数名を書きます。 右辺の配列から対応するインデックスの要素が、左辺で定義した変数に代入されます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、左辺に定義した変数に対して、右辺の配列から対応するインデックスの要素が代入されます。 `first`にはインデックスが`0`の要素、`second`にはインデックスが`1`の要素、`third`にはインデックスが`2`の要素が代入されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[](#diff-undefined-and-no-element)*[コラム] undefinedの要素と未定義の要素の違い*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*疎な配列で該当するインデックスに要素がない場合は`undefined`を返します。 しかし、`undefined`という値も存在するため、配列に`undefined`という値がある場合に区別できません。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`undefined`という値を要素として定義した密な配列と、要素そのものがない疎な配列を定義しています。 どちらも要素にアクセスした結果は`undefined`となり、区別できていないことがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: この違いを見つける方法として利用できるのが、`Object.hasOwn`静的メソッドです。 `Object.hasOwn`静的メソッドを使うことで、配列オブジェクトに対して指定したインデックスに要素自体が存在するかを判定できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[](#search-element)*配列から要素を検索*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*配列から指定した要素を検索する目的には、 主に次の3つがあります。'
  prefs: []
  type: TYPE_NORMAL
- en: その要素のインデックスが欲しい場合
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: その要素自体が欲しい場合
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: その要素が含まれているかという真偽値が欲しい場合
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 配列にはそれぞれに対応したメソッドが用意されているため、目的別に見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#indexof)*インデックスを取得*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*指定した要素が配列のどの位置にあるかを知りたい場合、Arrayの`indexOf`メソッドや`findIndex`メソッド^([ES2015])を利用します。
    要素の位置のことを**インデックス**（`index`）と呼ぶため、メソッド名にも`index`という名前が入っています。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、Arrayの`indexOf`メソッドを利用して、配列の中から`"JavaScript"`という文字列のインデックスを取得しています。
    `indexOf`メソッドは引数と厳密等価演算子（`===`）で一致する要素を先頭から検索して該当する要素のインデックスを返し、該当する要素がない場合は`-1`を返します。
    `indexOf`メソッドには対となる`lastIndexOf`メソッドがあり、`lastIndexOf`メソッドでは末尾から検索した結果が得られます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`indexOf`メソッドは配列からプリミティブな要素を発見できますが、オブジェクトは持っているプロパティが同じでも別オブジェクトだと異なるものとして扱われます。
    次のコードを見ると、同じプロパティを持つ異なるオブジェクトは、`indexOf`メソッドでは見つけることができません。 これは、異なる参照を持つオブジェクト同士は`===`で比較しても一致しないためです。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: このように、異なるオブジェクトだが値は同じものを見つけたい場合には、Arrayの`findIndex`メソッドが利用できます。 `findIndex`メソッドの引数には配列の各要素をテストする関数をコールバック関数として渡します。
    `indexOf`メソッドとは異なり、テストする処理を自由に書けます。 これにより、プロパティの値が同じ要素を配列から見つけて、その要素のインデックスを得ることができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Arrayの`findIndex`メソッドにも対となる`findLastIndex`メソッド^([ES2023])があり、`findLastIndex`メソッドは末尾から検索した結果が得られます。
    次のように、`findIndex`は条件に一致する最初の要素のインデックスを返しますが、`findLastIndex`は最後の要素のインデックスを返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[](#find)*条件に一致する要素を取得*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*配列から要素を取得する方法としてインデックスを使うこともできます。 先ほどのように`findIndex`メソッドでインデックスを取得し、そのインデックスで配列へアクセスすればよいだけです。'
  prefs: []
  type: TYPE_NORMAL
- en: しかし、`findIndex`メソッドを使って要素を取得するケースでは、 そのインデックスが欲しいのか、またはその要素自体が欲しいのかがコードとして明確ではありません。
  prefs: []
  type: TYPE_NORMAL
- en: より明確に要素自体が欲しいということを表現するには、Arrayの`find`メソッド^([ES2015])が使えます。 `find`メソッドには、`findIndex`メソッドと同様にテストする関数をコールバック関数として渡します。
    `find`メソッドの返り値は、要素そのものとなり、要素が存在しない場合は`undefined`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`find`メソッドにも対となる`findLast`メソッド^([ES2023])があり、`findLast`メソッドは末尾から検索した結果が得られます。
    次のように、`find`は条件に一致した最初の要素を返しますが、`findLast`は最後の要素を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[](#slice)*指定範囲の要素を取得*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*配列から指定範囲の要素を取り出す方法としてArrayの`slice`メソッドが利用できます。 `slice`メソッドは、第一引数の開始位置から第二引数の終了位置（終了位置の要素は含まない）までの範囲を取り出した新しい配列を返します。
    第二引数は省略でき、省略した場合は配列の末尾の要素まで含んだ新しい配列を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`slice`メソッドと引数の関係を図にすると次のようになります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[](#get-boolean)*真偽値を取得*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*最後に、指定した要素が配列に含まれているかを知る方法について見ていきます。 インデックスや要素が取得できれば、その要素は配列に含まれているということはわかります。'
  prefs: []
  type: TYPE_NORMAL
- en: しかし、指定した要素が含まれているか**だけ**を知りたい場合に、 Arrayの`findIndex`メソッドや`find`メソッドは過剰な機能を持っています。
    そのコードを読んだ人には、取得したインデックスや要素を何に使うのかが明確ではありません。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードは、Arrayの`indexOf`メソッドを利用し、該当する要素が含まれているかを判定しています。 `indexOf`メソッドの結果を`indexOfJS`に代入していますが、含まれているかを判定する以外には利用していません。
    コードを隅々まで読まないといけないため、意図が明確ではなくコードの読みづらさにつながります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: そこで、ES2016で導入されたArrayの`includes`メソッド^([ES2016])を利用します。 Arrayの`includes`メソッドは配列に指定要素が含まれているかを判定します。
    `includes`メソッドは真偽値を返すので、`indexOf`メソッドを使った場合に比べて意図が明確になります。 前述のコードでは次のように`includes`メソッドを使うべきでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`includes`メソッドは、`indexOf`メソッドと同様、異なるオブジェクトだが値が同じものを見つけたい場合には利用できません。 Arrayの`find`メソッドのようにテストするコールバック関数を利用して真偽値を得るには、Arrayの`some`メソッドを利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: Arrayの`some`メソッドはテストするコールバック関数にマッチする要素があるなら`true`を返し、存在しない場合は`false`を返します （「[ループと反復処理](../loop/#array-some)」の章を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[](#add-and-delete)*追加と削除*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*配列は可変長であるため、作成後の配列に対して要素を追加、削除できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 要素を配列の末尾へ追加するにはArrayの`push`が利用できます。 一方、末尾から要素を削除するにはArrayの`pop`が利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 要素を配列の先頭へ追加するにはArrayの`unshift`が利用できます。 一方、配列の先頭から要素を削除するにはArrayの`shift`が利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[](#concat)*配列同士を結合*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Arrayの`concat`メソッドを使うことで配列と配列を結合した新しい配列を作成できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: また、`concat`メソッドは配列だけではなく任意の値を要素として結合できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[](#spread)*[ES2015] 配列の展開*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`...`（Spread構文）を使うことで、配列リテラル中に既存の配列を展開できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、配列リテラルの末尾に配列を展開しています。 これは、Arrayの`concat`メソッドで配列同士を結合するのと同じ結果になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Spread構文は、`concat`メソッドとは異なり、配列リテラル中の任意の位置に配列を展開できます。 そのため、次のように要素の途中に配列を展開できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[](#flat)*[ES2019] 配列をフラット化*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Arrayの`flat`メソッド^([ES2019])を使うことで、多次元配列をフラットな配列に変換できます。 引数を指定しなかった場合は1段階のみのフラット化ですが、引数に渡す数値でフラット化する深さを指定できます。
    配列をすべてフラット化する場合には、無限を意味する`Infinity`を値として渡すことで実現できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: また、Arrayの`flat`メソッドは必ず新しい配列を作成して返すメソッドです。 そのため、これ以上フラット化できない配列をフラット化しても、同じ要素を持つ新しい配列を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[](#delete-element)*配列から要素を削除*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*### [](#splice)*`Array.prototype.splice`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*配列の先頭や末尾の要素を削除する場合はArrayの`shift`メソッドや`pop`メソッドで行えます。 しかし、配列の任意のインデックスの要素を削除できません。
    配列の任意のインデックスの要素を削除するにはArrayの`splice`メソッドを利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`splice`メソッドを利用すると、削除した要素を自動で詰めることができます。 `splice`メソッドは指定したインデックスから、指定した数だけ要素を取り除き、必要ならば要素を同時に追加できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: たとえば、配列のインデックスが`1`の要素を削除するには、インデックス`1`から`1`つの要素を削除するという指定をする必要があります。 このとき、削除した要素は自動で詰められるため、疎な配列にはなりません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[](#assign-to-length)*`length`プロパティへの代入*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*配列のすべての要素を削除することはArrayの`splice`で行えますが、 配列の`length`プロパティへの代入を利用した方法もあります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 配列の`length`プロパティへ`要素数`を代入すると、その要素数に配列が切り詰められます。 つまり、`length`プロパティへ`0`を代入すると、インデックスが`0`以降の要素がすべて削除されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#assign-empty-array)*空の配列を代入*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*最後に、その配列の要素を削除するのではなく、新しい空の配列を変数へ代入する方法です。 次のコードでは、`array`変数に空の配列を代入することで、`array`に空の配列を参照させられます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 元々、`array`変数が参照していた`[1, 2, 3]`はどこからも参照されなくなり、ガベージコレクションによりメモリから解放されます。
  prefs: []
  type: TYPE_NORMAL
- en: また、`const`で宣言した配列の場合は変数に対して再代入できないため、この手法は使えません。 そのため、再代入をしたい場合は`let`または`var`で変数宣言をする必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[](#mutable-immutable)*破壊的なメソッドと非破壊的なメソッド*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*これまで紹介してきた配列を変更するメソッドには、破壊的なメソッドと非破壊的メソッドがあります。 この破壊的なメソッドと非破壊的メソッドの違いを知ることは、意図しない結果を避けるために重要です。'
  prefs: []
  type: TYPE_NORMAL
- en: 破壊的なメソッド（Mutable Method）とは、配列オブジェクトそのものを変更し、変更した配列または変更箇所を返すメソッドです。 非破壊的メソッド（Immutable
    Method）とは、配列オブジェクトのコピーを作成してから変更し、そのコピーした配列を返すメソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: 破壊的なメソッドの例として、配列に要素を追加するArrayの`push`メソッドがあります。 `push`メソッドは、`myArray`の配列そのものへ要素を追加しています。
    その結果`myArray`変数の参照する配列が変更されるため破壊的なメソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 非破壊的なメソッドの例として、配列に要素を結合するArrayの`concat`メソッドがあります。 `concat`メソッドは、`myArray`をコピーした配列に対して要素を結合し、その配列を返します。
    `myArray`変数の参照する配列は変更されないため非破壊的なメソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: JavaScriptにおいて破壊的なメソッドと非破壊的メソッドを名前から見分けるのは難しいという問題があります。 また、配列を返す破壊的なメソッドもあるため、返り値からも判別できません。
    たとえば、Arrayの`sort`メソッドは返り値がソート済みの配列ですが破壊的メソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: 次の表で紹介するメソッドは破壊的なメソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: '| メソッド名 | 返り値 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | 配列の末尾の値 |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | 変更後の配列のlength |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | 取り除かれた要素を含む配列 |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | 反転した配列 |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | 配列の先頭の値 |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | ソートした配列 |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | 変更後の配列のlength |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | 変更後の配列 |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | 変更後の配列 |'
  prefs: []
  type: TYPE_TB
- en: 破壊的メソッドは意図せぬ副作用を与えてしまうことがあるため、そのことを意識して利用する必要があります。 たとえば、配列から特定のインデックスの要素を削除する`removeAtIndex`という関数を提供したいとします。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 次のように、破壊的なメソッドであるArrayの`splice`メソッドで要素を削除すると、引数として受け取った配列にも影響を与えます。 この場合`removeAtIndex`関数には副作用があるため、破壊的であることについてのコメントがあると親切です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 一方、非破壊的メソッドは配列のコピーを作成するため、元々の配列に対して影響はありません。 この`removeAtIndex`関数を非破壊的なものにするには、受け取った配列をコピーしてから変更を加える必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptには`copy`メソッドそのものは存在しませんが、配列をコピーする方法としてArrayの`slice`メソッドと`concat`メソッドが利用されています。
    `slice`メソッドと`concat`メソッドは引数なしで呼び出すと、その配列のコピーを返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: コピーした配列に変更を加えることで、`removeAtIndex`関数を非破壊的な関数として実装できます。 非破壊的であれば引数の配列への副作用がないので、注意させるようなコメントは不要です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: このようにJavaScriptの配列には破壊的なメソッドと非破壊的メソッドが混在しています。 名前からも区別することが難しく、副作用を避けるためにコピーを作ってから破壊的メソッドを使うというパターンが利用されていました。
  prefs: []
  type: TYPE_NORMAL
- en: しかし、ES2023でこの状況を改善する変更が追加されています。 今まで、破壊的なメソッドしかなかった、`splice`、`reverse`、`sort`に対して、
    非破壊的なバージョンである`toSpliced`、`toReversed`、`toSorted`が追加されました。
  prefs: []
  type: TYPE_NORMAL
- en: これらの`to`から始まる非破壊的メソッドが受け取る引数は破壊的なメソッドと同じですが、非破壊的に変更した配列を返す点が異なります。 次のコードの`toSpliced`メソッドは、配列を複製してから変更するため、元々の配列である`array`には影響を与えていないことがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 先ほど`removeAtIndex`関数の実装では、`slice`メソッドで配列をコピーしてから`splice`メソッドを呼び出していました。 次のコードでは、`toSpliced`メソッドを使うことで、より簡潔に非破壊的な`removeAtIndex`関数を実装しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: また、ES2023では配列の指定したインデックスの要素を非破壊的に変更する`with`メソッドも追加されました。 `array[index] = value`の代入処理は、元々の配列を変更する破壊的な処理です。
    これに対して`with`メソッドは、配列を複製してから指定したインデックスの要素を変更した配列を返す非破壊的なメソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 次の表では、破壊的な方法に対応する非破壊的な方法をまとめています。
  prefs: []
  type: TYPE_NORMAL
- en: '| 破壊的な方法 | 非破壊な方法 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `array[index] = item` | [`Array.prototype.with`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/with)^([ES2023])
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | [`array.slice(0, -1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)と[`array.at(-1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | `[...array, item]`^([ES2015]) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | [`Array.prototype.toSpliced`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced)^([ES2023])
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | [`Array.prototype.toReversed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed)^([ES2023])
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | [`Array.prototype.toSorted`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted)^([ES2023])
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | [`array.slice(1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)と[`array.at(0)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | `[item, ...array]`^([ES2015]) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | なし |'
  prefs: []
  type: TYPE_TB
- en: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | なし |'
  prefs: []
  type: TYPE_TB
- en: 破壊的なメソッドは、シンプルですが元の配列も変更してしまうため、意図しない副作用が発生しバグの原因となる可能性があります。 非破壊的なメソッドは、使い分けが必要ですが元の配列を変更せずに新しい配列を返すため、副作用が発生することはありません。
  prefs: []
  type: TYPE_NORMAL
- en: そのため、まず非破壊的な方法で書けるかを検討し、そうではない場合に破壊的な方法を利用するとよいでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#array-iterate)*配列を反復処理するメソッド*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*「[ループと反復処理](../loop/)」の章において配列を反復処理する方法を一部解説しましたが、改めて関連するArrayメソッドを見ていきます。
    反復処理の中でもよく利用されるのがArrayの`forEach`、`map`、`filter`、`reduce`メソッドです。 どのメソッドも共通して引数にコールバック関数を受け取るため高階関数と呼ばれます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#array-foreach)*`Array.prototype.forEach`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Arrayの`forEach`メソッドは配列の要素を先頭から順番にコールバック関数へ渡し、反復処理を行うメソッドです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のようにコールバック関数には`要素, インデックス, 配列`が引数として渡され、配列要素の先頭から順番に反復処理します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[](#array-map)*`Array.prototype.map`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Arrayの`map`メソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が返した値から新しい配列を返す非破壊的なメソッドです。 配列の各要素を加工したい場合に利用します。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のようにコールバック関数には`要素, インデックス, 配列`が引数として渡され、配列要素の先頭から順番に反復処理します。 `map`メソッドの返り値は、それぞれのコールバック関数が返した値を集めた新しい配列です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[](#array-filter)*`Array.prototype.filter`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Arrayの`filter`メソッドは配列の要素を順番にコールバック関数へ渡し、コールバック関数が`true`を返した要素だけを集めた新しい配列を返す非破壊的なメソッドです。
    配列から不要な要素を取り除いた配列を作成したい場合に利用します。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のようにコールバック関数には`要素, インデックス, 配列`が引数として渡され、配列要素の先頭から順番に反復処理します。 `filter`メソッドの返り値は、コールバック関数が`true`を返した要素だけを集めた新しい配列です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[](#array-reduce)*`Array.prototype.reduce`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Arrayの`reduce`メソッドは累積値（アキュムレータ）と配列の要素を順番にコールバック関数へ渡し、1つの累積値を返します。 配列から配列以外を含む任意の値を作成したい場合に利用します。'
  prefs: []
  type: TYPE_NORMAL
- en: ここまでで紹介した反復処理のメソッドとは異なり、コールバック関数には`累積値, 要素, インデックス, 配列`を引数として渡します。 `reduce`メソッドの第二引数には`累積値`の初期値となる値を渡せます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`reduce`メソッドは初期値を0として配列の各要素を加算した1つの数値を返します。 つまり配列から配列要素の合計値というNumber型の値を返しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`reduce`メソッドに渡したコールバック関数は配列の要素数である3回呼び出され、それぞれ次のような結果になります。'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | accumulator | currentValue | returnした値 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1回目の呼び出し | 0 | 1 | 0 + 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2回目の呼び出し | 1 | 2 | 1 + 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3回目の呼び出し | 3 | 3 | 3 + 3 |'
  prefs: []
  type: TYPE_TB
- en: Arrayの`reduce`メソッドはやや複雜ですが、配列から配列以外のデータ型の値を作成できる特徴があります。 また、`reduce`メソッドでは、配列から直接Number型の値を返せるため、`totalValue`という変数を再代入できない`const`で宣言していました。
  prefs: []
  type: TYPE_NORMAL
- en: 配列の数値の合計を`forEach`メソッドなど反復処理で計算すると、次のコードのように`totalValue`という変数は再代入ができる`let`で宣言する必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`let`で宣言した変数は再代入が可能なため、意図しない箇所で変数の値が変更され、バグの原因となることがあります。 そのため、できる限り変数を`const`で宣言したい場合には`reduce`メソッドは有用です。
    一方で、`reduce`メソッドは可読性があまりよくないため、コードの意図が伝わりにくいというデメリットもあります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce`メソッドには利点と可読性のトレードオフがありますが、利用する場合は`reduce`メソッドを扱う処理を関数で囲むなど処理の意図がわかるように工夫をする必要があります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[](#array-like)*[コラム] Array-likeオブジェクト*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*配列のように扱えるが配列ではないオブジェクトのことを、**Array-likeオブジェクト**と呼びます。 Array-likeオブジェクトとは配列のようにインデックスにアクセスでき、配列のように`length`プロパティも持っています。しかし、配列のインスタンスではないため、Arrayのプロトタイプメソッドを持っていないオブジェクトのことです。'
  prefs: []
  type: TYPE_NORMAL
- en: '| 機能 | Array-likeオブジェクト | 配列 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| インデックスアクセス（`array[0]`） | できる | できる |'
  prefs: []
  type: TYPE_TB
- en: '| 長さ（`array.length`） | 持っている | 持っている |'
  prefs: []
  type: TYPE_TB
- en: '| Arrayのプロトタイプメソッド(`forEach`メソッドなど) | 持っていない場合もある | 持っている |'
  prefs: []
  type: TYPE_TB
- en: Array-likeオブジェクトの例として`arguments`があります。 `arguments`オブジェクトは、`function`で宣言した関数の中から参照できる変数です。
    `arguments`オブジェクトには関数の引数に渡された値が順番に格納されていて、配列のように引数へアクセスできます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Array-likeオブジェクトか配列なのかを判別するには`Array.isArray`メソッドを利用できます。 `Array-like`オブジェクトは配列ではないので結果は常に`false`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Array-likeオブジェクトは配列のようで配列ではないというもどかしさを持つオブジェクトです。`Array.from`メソッド^([ES2015])を使うことでArray-likeオブジェクトを配列に変換して扱うことができます。一度配列に変換してしまえばArrayメソッドも利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[](#method-chain-and-high-order-function)*メソッドチェーンと高階関数*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*配列で頻出するパターンとしてメソッドチェーンがあります。 メソッドチェーンとは、メソッドを呼び出した返り値に対してさらにメソッド呼び出しをするパターンのことを言います。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、Arrayの`concat`メソッドの返り値、つまり配列に対してさらに`concat`メソッドを呼び出すというメソッドチェーンが行われています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: このコードの`concat`メソッドの呼び出しを分解してみると何が行われているのかわかりやすいです。 `concat`メソッドの返り値は結合した新しい配列です。先ほどのメソッドチェーンでは、その新しい配列に対してさらに`concat`メソッドで値を結合しているということがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: メソッドチェーンを利用することで処理の見た目を簡潔にできます。メソッドチェーンを利用した場合も最終的な処理結果は同じですが、途中の一時的な変数を省略できます。先ほどの例では`abArray`という一時的な変数をメソッドチェーンでは省略できています。
  prefs: []
  type: TYPE_NORMAL
- en: メソッドチェーンは配列に限ったものではありませんが、配列では頻出するパターンです。なぜなら、配列に含まれるデータを表示する際には、最終的に文字列や数値など別のデータへ加工することがほとんどであるためです。配列には配列を返す高階関数が多く実装されているため、配列を柔軟に加工できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、ECMAScriptのバージョン名と発行年数が定義された`ECMAScriptVersions`という配列が定義されています。この配列から`2000`年以前に発行されたECMAScriptのバージョン名の一覧を取り出すことを考えてみます。目的の一覧を取り出すには「2000年以前のデータに絞り込む」と「データから`name`を取り出す」という2つの加工処理を組み合わせる必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: この2つの加工処理はArrayの`filter`メソッドと`map`メソッドで実現できます。 `filter`メソッドで配列から`2000`年以前というルールで絞り込み、`map`メソッドでそれぞれの要素から`name`プロパティを取り出せます。
    どちらのメソッドも配列を返すのでメソッドチェーンで処理をつなげられます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: メソッドチェーンを使うことで複数の処理からなるものをひとつのまとまった処理のように見せることができます。長過ぎるメソッドチェーンは長過ぎる関数と同じように読みにくくなりますが、適度な単位のメソッドチェーンは処理をスッキリ見せるパターンとして利用されています。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#conclusion)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では配列について学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: 配列は順序を持った要素を格納できるオブジェクトの一種
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 配列には破壊的なメソッドと非破壊的なメソッドがある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 配列には反復処理を行う高階関数となるメソッドがある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: メソッドチェーンは配列のメソッドが配列を返すことを利用している
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 配列はJavaScriptの中でもよく使われるオブジェクトで、メソッドの種類も多いです。 この書籍でもすべてのメソッドは紹介していないため、詳しくは[Arrayについてのドキュメント](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array)も参照してみてください。****************************
  prefs: []
  type: TYPE_NORMAL
