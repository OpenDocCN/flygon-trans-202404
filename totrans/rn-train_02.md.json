["```\n//define component\nclass MyComponent extends React.Component {\n  render() {\n    return <Text>My component!</Text>;\n  }\n}\n//export component\nexport default MyComponent; \n```", "```\n//import component\nimport MyComponent from './MyComponent';\nclass Main extends React.Component {\n  render() {\n    //use component\n    return <MyComponent>;\n  }\n} \n```", "```\nAppRegistry.registerComponent('MyApp', () => Main); \n```", "```\n..\n...\nrender() {\n  const txt = 'Hello';\n  function say(name){\n    return 'I am '+name;\n  }\n  return (\n    <View>\n      <Text>This is a title!</Text>\n      <Text>{txt}</Text>\n      <View>\n        <Text>{say('React')}</Text>\n      </View>\n    </View>\n  );\n}\n..\n... \n```", "```\n..\n...\nimport {\n  StyleSheet,\n  Text,\n  View,\n  Image\n} from 'react-native';\n\nclass Main extends Component {\n  render() {\n    return (\n      <View>\n        <Image source={require('./img/bg.png')}>\n          <Image source={require('./img/icon.png')}/>\n          <Text>\n            some text!\n          </Text>\n        </Image>\n      </View>\n    );\n  }\n} \n```", "```\n        shouldComponentUpdate(nextProps, nextState) {\n        return nextProps.id !== this.props.id;\n        } \n        ```", "```\nclass User extends Component {\n  render(){\n    const user = this.props.data;\n    this.props.onReady('I am ready!');\n    return(\n      <View>\n        <Text>\n          score: {this.props.score}\n          type: {this.props.type}\n          Name: {user.name}\n          Age: {user.age}\n        </Text>\n      </View>\n    );\n  }\n}\n//dufaultProps\nUser.propTypes = { score: React.PropTypes.number };\nUser.defaultProps = { score: 0 };\n\nvar user = {name: 'foo', age: 21};\nclass Main extends Component {\n  handleReady(str){\n    console.log(str);\n  }\n  render(){\n    return(\n      <View>\n        <User type=\"Dev\" data={user} onReady={this.handleReady}/>\n      </View>\n    );\n  }\n} \n```", "```\nclass Timer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: 0};\n  }\n\n  componentDidMount() {\n    let that = this;\n    setInterval(function () {\n      that.increase();\n    }, 1000);\n  }\n\n  increase() {\n    this.setState({count: this.state.count + 1});\n  }\n\n  render() {\n    return (\n      <View>\n        <Text>count: {this.state.count}</Text>\n      </View>\n    );\n  }\n}\n\nclass Main extends Component {\n  render(){\n    return(\n      <View>\n        <Timer/>\n      </View>\n    );\n  }\n} \n```", "```\nconst Heading = ({title}) => <Text>{title}</Text>;\n\n..\n...\n<Heading title=\"test title\"/>\n...\n.. \n```", "```\nclass Touch extends Component {\n  handlePress(){\n    console.log('press');\n  }\n  handleLongPress(){\n    console.log('longPress');\n  }\n  render() {\n    return (\n      <TouchableHighlight\n        onPress={this.handlePress}\n        onLongPress={this.handleLongPress}>\n        <View>\n          <Text>Press me!</Text>\n        </View>\n      </TouchableHighlight>\n    );\n  }\n} \n```", "```\nclass Test extends Component {\n  //...\n  //handle events\n  //...\n  render() {\n    return (\n      <TextInput \n        onBlur={...}\n        onChange={...}\n        onEndEditing={...}\n        onSelectionChange={...}\n        onSubmitEditing={...}\n      </TextInput>\n    );\n  }\n} \n```", "```\n//keyboardWillShow, keyboardDidShow, keyboardWillHide, keyboardDidHide\n//keyboardWillChangeFrame, keyboardDidChangeFrame\n//add the listener\n var listener = DeviceEventEmitter.addListener('keyboardWillShow', (e) =>{\n   console.log('Event is fired!');\n });\n //remove the listener\n listener.remove(); \n```", "```\nclass Test extends Component {\n  /* Capture handles */\n  //the responder system bubbles up from the deepest component, \n  //a parent View wants to prevent the child from becoming responder on a touch start\n  handleStartShouldSetResponderCapture(evt){\n    return true;\n  }\n  //the responder system bubbles up from the deepest component, \n  //a parent View wants to prevent the child from becoming responder on a touch move\n  handleMoveShouldSetResponderCapture(evt){\n    return true;\n  }\n\n  /* Lifecycle handles */\n  //Does this view want to become responder on the start of a touch?\n  handleStartShouldSetResponder(evt){\n    return true;\n  }\n  //Called for every touch move on the View when it is not the responder: \n  //does this view want to \"claim\" touch responsiveness?\n  handleMoveShouldSetResponder(evt){\n    return true;\n  }\n  //The View is now responding for touch events. \n  handleResponderGrant(evt){\n    console.log('you are touching me');\n  }\n  //Something else is the responder right now and will not release it\n  handleResponderReject(evt){\n    console.log('please wait in line');\n  }\n\n  /* event handles */\n  //touch move\n  handleResponderMove(evt){\n    console.log('touch move at:', 'X='+evt.pageX, 'Y='+evt.pageY);\n  }\n  //touch end/up\n  handleResponderRelease(evt){\n    console.log('touch end');\n  }\n  //Something else wants to become responder. Should this view release the responder?\n  handleResponderTerminationRequest(evt){\n    return true;\n  }\n  //touch cancel\n  handleResponderTerminate(evt){\n    console.log('touch canceled');\n  }\n  render() {\n    return (\n      <View \n        onStartShouldSetResponderCapture={this.handleStartShouldSetResponderCapture}\n        onMoveShouldSetResponderCapture={this.handleMoveShouldSetResponderCapture}\n        onStartShouldSetResponder={this.handleStartShouldSetResponder}\n        onMoveShouldSetResponder={this.handleMoveShouldSetResponder}\n        onResponderGrant={this.handleResponderGrant} \n        onResponderReject={this.handleResponderReject}\n        onResponderMove={this.handleResponderMove}\n        onResponderRelease={this.handleResponderRelease}\n        onResponderTerminationRequest={this.handleResponderTerminationRequest}\n        onResponderTerminate={this.handleResponderTerminate}>\n          <Text>Press me!</Text>\n      </View>\n    );\n  }\n} \n```", "```\nthis._panResponder = PanResponder.create({\n  // Ask to be the responder:\n  onStartShouldSetPanResponder: (evt, gestureState) => true,\n  onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\n  onMoveShouldSetPanResponder: (evt, gestureState) => true,\n  onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\n  //touch start\n  onPanResponderGrant: (evt, gestureState) => {},\n  //touch move\n  onPanResponderMove: (evt, gestureState) => {},\n  onPanResponderTerminationRequest: (evt, gestureState) => true,\n  //touch end/up\n  onPanResponderRelease: (evt, gestureState) => {},\n  //touch cancel\n  onPanResponderTerminate: (evt, gestureState) => {},\n  onShouldBlockNativeResponder: (evt, gestureState) => true,\n}); \n```"]