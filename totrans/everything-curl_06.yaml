- en: Command line basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command line basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: curl started out as a command-line tool and it has been invoked from shell prompts
    and from within scripts by thousands of users over the years. curl has established
    itself as one of those trusty tools that is there for you to help you get your
    work done.
  prefs: []
  type: TYPE_NORMAL
- en: Binaries and different platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command-line tool "curl" is a binary executable file. The curl project does
    not by itself distribute or provide binaries. Binary files are highly system specific
    and oftentimes also bound to specific system versions.
  prefs: []
  type: TYPE_NORMAL
- en: To get a curl for your platform and your system, you need to get a curl executable
    from somewhere. Many people build their own from the source code provided by the
    curl project, lots of people install it using a package tool for their operating
    system and yet another portion of users download binary install packages from
    sources they trust.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how you do it, make sure you are getting your version from a trusted
    source and that you verify digital signatures or the authenticity of the packages
    in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember that curl is often built to use third-party libraries to perform
    and unless curl is built to use them statically you must also have those third-party
    libraries installed; the exact set of libraries will vary depending on the particular
    build you get.
  prefs: []
  type: TYPE_NORMAL
- en: Command lines, quotes and aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different command lines, shells and prompts in which curl can
    be used. They all come with their own sets of limitations, rules and guidelines
    to follow. The curl tool is designed to work with any of them without causing
    troubles but there may be times when your specific command line system doesn't
    match what others use or what is otherwise documented.
  prefs: []
  type: TYPE_NORMAL
- en: One way that command-line systems differ, for example, is how you can put quotes
    around arguments such as to embed spaces or special symbols. In most Unix-like
    shells you use double quotes (") and single quotes (') depending if you want to
    allow variable expansions or not within the quoted string, but on Windows there's
    no support for the single quote version.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some environments, like PowerShell on Windows, the authors of the command
    line system decided they know better and "help" the user to use another tool instead
    of curl when `curl` is typed, by providing an alias that takes precedence when
    a command line is executed. In order to use curl properly with PowerShell, you
    need to type in its full name including the extension: "curl.exe".'
  prefs: []
  type: TYPE_NORMAL
- en: Different command-line environments will also have different maximum command
    line lengths and force the users to limit how large amount of data that can be
    put into a single line. curl adapts to this by offering a way to provide command-line
    options through a file—or from stdin—using the -K option.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage in, garbage out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl has very little will of its own. It tries to please you and your wishes
    to a very large extent. It also means that it will try to play with what you give
    it. If you misspell an option, it might do something unintended. If you pass in
    a slightly illegal URL, chances are curl will still deal with it and proceed.
    It means that you can pass in crazy data in some options and you can have curl
    pass on that crazy data in its transfer operation.
  prefs: []
  type: TYPE_NORMAL
- en: This is a design choice, as it allows you to really tweak how curl does its
    protocol communications and you can have curl massage your server implementations
    in the most creative ways.
  prefs: []
  type: TYPE_NORMAL
- en: Command line options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command line options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When telling curl to do something, you invoke curl with zero, one or several
    command-line options to accompany the URL or set of URLs you want the transfer
    to be about. curl supports over two hundred different options.
  prefs: []
  type: TYPE_NORMAL
- en: Short options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Command line options pass on information to curl about how you want it to behave.
    Like you can ask curl to switch on verbose mode with the -v option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '-v is here used as a "short option". You write those with the minus symbol
    and a single letter immediately following it. Many options are just switches that
    switches something on or changes something between two known states. They can
    be used with just that option name. You can then also combine several single-letter
    options after the minus. To ask for both verbose mode and that curl follows HTTP
    redirects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The command-line parser in curl always parses the entire line and you can put
    the options anywhere you like; they can also appear after the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Long options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single-letter options are convenient since they are quick to write and use,
    but as there are only a limited number of letters in the alphabet and there are
    many things to control, not all options are available like that. Long option names
    are therefore provided for those. Also, as a convenience and to allow scripts
    to become more readable, most short options have longer name aliases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Long options are always written with *two* minuses (or *dashes*, whichever
    you prefer to call them) and then the name and you can only write one option name
    per double-minus. Asking for verbose mode using the long option format looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'and asking for HTTP redirects as well using the long format looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Arguments to options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all options are just simple boolean flags that enable or disable features.
    For some of them you need to pass on data, like perhaps a user name or a path
    to a file. You do this by writing first the option and then the argument, separated
    with a space. Like, for example, if you want to send an arbitrary string of data
    in an HTTP POST to a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and it works the same way even if you use the long form of the option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use the short options with arguments, you can, in fact, also write
    the data without the space separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Arguments with spaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At times you want to pass on an argument to an option, and that argument contains
    one or more spaces. For example you want to set the user-agent field curl uses
    to be exactly `I am your father`, including those three spaces. Then you need
    to put quotes around the string when you pass it to curl on the command line.
    The exact quotes to use varies depending on your shell/command prompt, but generally
    it will work with double quotes in most places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Failing to use quotes, like if you would write the command line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: … will make curl only use 'I' as a user-agent string, and the following strings,
    'am', your, etc will instead all be treated as separate URLs since they don't
    start with `-` to indicate that they're options and curl only ever handles options
    and URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the string itself contain double quotes, which is common when you for
    example want to send a string of JSON to the server, you may need to use single
    quotes (except on Windows, where single quotes doesn''t work the same way). Send
    the JSON string `{ "name": "Darth" }`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if you want to avoid the single quote thing, you may prefer to send the
    data to curl via a file, which then doesn''t need the extra quoting. Assuming
    we call the file ''json'' that contains the above mentioned data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Negative options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For options that switch on something, there is also a way to switch it off.
    You then use the long form of the option with an initial "no-" prefix before the
    name. As an example, to switch off verbose mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Options depend on version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Options depend on version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`curl` was first typed on a command line back in the glorious year of 1998\.
    It already then worked on the specified URL and none, one or more command-line
    options given to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Since then we have added more options. We add options as we go along and almost
    every new release of curl has one or a few new options that allow users to modify
    certain aspects of its operation.
  prefs: []
  type: TYPE_NORMAL
- en: With the curl project's rather speedy release chain with a new release shipping
    every eight weeks, it is almost inevitable that you are at least not always using
    the very latest released version of curl. Sometimes you may even use a curl version
    that is a few years old.
  prefs: []
  type: TYPE_NORMAL
- en: All command-line options described in this book were, of course, added to curl
    at some point in time, and only a very small portion of them were available that
    fine spring day in 1998 when curl first shipped. You may have reason to check
    your version of curl and crosscheck with the curl man page for when certain options
    were added. This is especially important if you want to take a curl command line
    using a modern curl version back to an older system that might be running an older
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: The developers of curl are working hard to not change existing behavior though.
    Command lines written to use curl in 1998, 2003 or 2010 should all be possible
    to run unmodified even today.
  prefs: []
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl is called curl because a substring in its name is URL (Uniform Resource
    Locator). It operates on URLs. URL is the name we casually use for the web address
    strings, like the ones we usually see prefixed with http:// or starting with www.
  prefs: []
  type: TYPE_NORMAL
- en: URL is, strictly speaking, the former name for these. URI (Uniform Resource
    Identifier) is the more modern and correct name for them. Their syntax is defined
    in [RFC 3986](https://www.ietf.org/rfc/rfc3986.txt).
  prefs: []
  type: TYPE_NORMAL
- en: Where curl accepts a "URL" as input, it is then really a "URI". Most of the
    protocols curl understands also have a corresponding URI syntax document that
    describes how that particular URI format works.
  prefs: []
  type: TYPE_NORMAL
- en: curl assumes that you give it a valid URL and it only does limited checks of
    the format in order to extract the information it deems necessary to perform its
    operation. You can, for example, most probably pass in illegal characters in the
    URL without curl noticing or caring and it will just pass them on.
  prefs: []
  type: TYPE_NORMAL
- en: Scheme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: URLs start with the "scheme", which is the official name for the "http://" part.
    That tells which protocol the URL uses. The scheme must be a known one that this
    version of curl supports or it will show an error message and stop. Additionally,
    the scheme must neither start with nor contain any whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: The scheme separator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scheme identifier is separated from the rest of the URL by the "://" sequence.
    That is a colon and two forward slashes. There exists URL formats with only one
    slash, but curl doesn''t support any of them. There are two additional notes to
    be aware of, about the number of slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: curl allow some illegal syntax and try to correct it internally; so it will
    also understand and accept URLs with one or three slashes, even though they are
    in fact not properly formed URLs. curl does this because the browsers started
    this practice so it has lead to such URLs being used in the wild every now and
    then.
  prefs: []
  type: TYPE_NORMAL
- en: '`file://` URLs are written as `file://<hostname>/<path>` but the only hostnames
    that are okay to use are `localhost`, `127.0.0.1` or a blank (nothing at all):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Inserting any other host name in there will make recent versions of curl to
    return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay special attention to the third example above (`file:///path/to/file`).
    That is *three* slashes before the path. That is again an area with common mistakes
    and where browsers allow users to use the wrong syntax so as a special exception,
    curl on Windows also allows this incorrect format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: … where X is a windows-style drive letter.
  prefs: []
  type: TYPE_NORMAL
- en: Without scheme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a convenience, curl also allows users to leave out the scheme part from URLs.
    Then it guesses which protocol to use based on the first part of the host name.
    That guessing is very basic as it just checks if the first part of the host name
    matches one of a set of protocols, and assumes you meant to use that protocol.
    This heuristic is based on the fact that servers traditionally used to be named
    like that. The protocols that are detected this way are FTP, DICT, LDAP, IMAP,
    SMTP and POP3\. Any other host name in a scheme-less URL will make curl default
    to HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: You can modify the default protocol to something other than HTTP with the `--proto-default`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Name and password
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the scheme, there can be a possible user name and password embedded.
    The use of this syntax is usually frowned upon these days since you easily leak
    this information in scripts or otherwise. For example, listing the directory of
    an FTP server using a given name and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The presence of user name and password in the URL is completely optional. curl
    also allows that information to be provide with normal command-line options, outside
    of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Host name or address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The host name part of the URL is, of course, simply a name that can be resolved
    to an numerical IP address, or the numerical address itself. When specifying a
    numerical address, use the dotted version for IPv4 addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '…and for IPv6 addresses the numerical version needs to be within square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When a host name is used, the converting of the name to an IP address is typically
    done using the system's resolver functions. That normally lets a sysadmin provide
    local name lookups in the `/etc/hosts` file (or equivalent).
  prefs: []
  type: TYPE_NORMAL
- en: Port number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each protocol has a "default port" that curl will use for it, unless a specified
    port number is given. The optional port number can be provided within the URL
    after the host name part, as a colon and the port number written in decimal. For
    example, asking for an HTTP document on port 8080:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the name specified as an IPv4 address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With the name given as an IPv6 address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every URL contains a path. If there's none given, "/" is implied. The path is
    sent to the specified server to identify exactly which resource that is requested
    or that will be provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact use of the path is protocol dependent. For example, getting a file
    README from the default anonymous user from an FTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For the protocols that have a directory concept, ending the URL with a trailing
    slash means that it is a directory and not a file. Thus asking for a directory
    list from an FTP server is implied with such a slash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: FTP type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is not a feature that is widely used.
  prefs: []
  type: TYPE_NORMAL
- en: URLs that identify files on FTP servers have a special feature that allows you
    to also tell the client (curl in this case) which file type the resource is. This
    is because FTP is a little special and can change mode for a transfer and thus
    handle the file differently than if it would use another mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'You tell curl that the FTP resource is an ASCII type by appending ";type=A"
    to the URL. Getting the ''foo'' file from example.com''s root directory using
    ASCII could then be made with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And while curl defaults to binary transfers for FTP, the URL format allows
    you to also specify the binary type with type=I:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can tell curl that the identified resource is a directory if the
    type you pass is D:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: …this can then work as an alternative format, instead of ending the path with
    a trailing slash as mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: URLs offer a "fragment part". That's usually seen as a hash symbol (#) and a
    name for a specific name within a web page in browsers. curl supports fragments
    fine when a URL is passed to it, but the fragment part is never actually sent
    over the wire so it doesn't make a difference to curl's operations whether it
    is present or not.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers' "address bar"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to realize that when you use a modern web browser, the "address
    bar" they tend to feature at the top of their main windows are not using "URLs"
    or even "URIs". They are in fact mostly using IRIs, which is a superset of URIs
    to allow internationalization like non-Latin symbols and more, but it usually
    goes beyond that, too, as they tend to, for example, handle spaces and do magic
    things on percent encoding in ways none of these mentioned specifications say
    a client should do.
  prefs: []
  type: TYPE_NORMAL
- en: The address bar is quite simply an interface for humans to enter and see URI-like
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the differences between what you see in a browser's address bar and
    what you can pass in to curl is significant.
  prefs: []
  type: TYPE_NORMAL
- en: Many options and URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned above, curl supports hundreds of command-line options and it also
    supports an unlimited number of URLs. If your shell or command-line system supports
    it, there's really no limit to how long a command line you can pass to curl.
  prefs: []
  type: TYPE_NORMAL
- en: curl will parse the entire command line first, apply the wishes from the command-line
    options used, and then go over the URLs one by one (in a left to right order)
    to perform the operations.
  prefs: []
  type: TYPE_NORMAL
- en: For some options (for example `-o` or `-O` that tell curl where to store the
    transfer), you may want to specify one option for each URL on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: curl will return an exit code for its operation on the last URL used. If you
    instead rather want curl to exit with an error on the first URL in the set that
    fails, use the `--fail-early` option.
  prefs: []
  type: TYPE_NORMAL
- en: Separate options per URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous sections we described how curl always parses all options in the
    whole command line and applies those to all the URLs that it transfers.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was a simplification: curl also offers an option (-;, --next) that inserts
    a sort of boundary between a set of options and URLs for which it will apply the
    options. When the command-line parser finds a --next option, it applies the following
    options to the next set of URLs. The --next option thus works as a *divider* between
    a set of options and URLs. You can use as many --next options as you please.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we do an HTTP GET to a URL and follow redirects, we then make
    a second HTTP POST to a different URL and we round it up with a HEAD request to
    a third URL. All in a single command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying something like that *without* the --next options on the command line
    would generate an illegal command line since curl would attempt to combine both
    a POST and a HEAD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Connection reuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up a TCP connection and especially a TLS connection can be a slow process,
    even on high bandwidth networks.
  prefs: []
  type: TYPE_NORMAL
- en: It can be useful to remember that curl has a connection pool internally which
    keeps previously used connections alive and around for a while after they were
    used so that subsequent requests to the same hosts can reuse an already established
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, they can only be kept alive for as long as the curl tool is running,
    but it is a very good reason for trying to get several transfers done within the
    same command line instead of running several independent curl command line invocations.
  prefs: []
  type: TYPE_NORMAL
- en: URL globbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URL globbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At times you want to get a range of URLs that are mostly the same, with only
    a small portion of it changing between the requests. Maybe it is a numeric range
    or maybe a set of names. curl offers "globbing" as a way to specify many URLs
    like that easily.
  prefs: []
  type: TYPE_NORMAL
- en: The globbing uses the reserved symbols [] and {} for this, symbols that normally
    cannot be part of a legal URL (except for numerical IPv6 addresses but curl handles
    them fine anyway). If the globbing gets in your way, disable it with `-g, --globoff`.
  prefs: []
  type: TYPE_NORMAL
- en: While most transfer related functionality in curl is provided by the libcurl
    library, the URL globbing feature is not!
  prefs: []
  type: TYPE_NORMAL
- en: Numerical ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can ask for a numerical range with [N-M] syntax, where N is the start index
    and it goes up to and including M. For example, you can ask for 100 images one
    by one that are named numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'and it can even do the ranges with zero prefixes, like if the number is three
    digits all the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or maybe you only want even numbered images so you tell curl a step counter
    too. This example range goes from 0 to 100 with an increment of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Alphabetical ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'curl can also do alphabetical ranges, like when a site has sections named a
    to z:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the parts don''t follow such an easy pattern, and then you can instead
    give the full list yourself but then within the curly braces instead of the brackets
    used for the ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Combinations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use several globs in the same URL which then will make curl iterate
    over those, too. To download the images of Ben, Alice and Frank, in both the resolutions
    100x100 and 1000x1000, a command line could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or download all the images of a chess board, indexed by two coordinates ranged
    0 to 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can, of course, mix ranges and series. Get a week''s worth of logs
    for both the web server and the mail server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Output variables for globbing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all the globbing examples previously in this chapter we have selected to
    use the `-O / --remote-name` option, which makes curl save the target file using
    the file name part of the used URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes that is not enough. You are downloading multiple files and maybe
    you want to save them in a different subdirectory or create the saved file names
    differently. curl, of course, has a solution for these situations as well: output
    file name variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Each "glob" used in a URL gets a separate variable. They are referenced as '#[num]'
    - that means the single letter '#' followed by the glob number which starts with
    1 for the first glob and ends with the last glob.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the main pages of two different sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Save the outputs from a command line with two globs in a subdirectory;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: List options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List all command-line options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl has more than two hundred command-line options and the number of options
    keep increasing over time. Chances are the number of options will reach 250 within
    a few years.
  prefs: []
  type: TYPE_NORMAL
- en: In order to find out which options you need to perform as certain action, you
    can, of course, list all options, scan through the list and pick the one you are
    looking for. `curl --help` or simply `curl -h` will get you a list of all existing
    options with a brief explanation. If you don't really know what you are looking
    for, you probably won't be entirely satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Then you can instead opt to use `curl --manual` which will output the entire
    man page for curl plus an appended tutorial for the most common use cases. That
    is a very thorough and complete document on how each option works amassing several
    thousand lines of documentation. To wade through that is also a tedious work and
    we encourage use of a search function through those text masses. Some people will
    appreciate the man page in its [web version](https://curl.haxx.se/docs/manpage.html).
  prefs: []
  type: TYPE_NORMAL
- en: Config file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Config file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can easily end up with curl command lines that use a very large number of
    command-line options, making them rather hard to work with. Sometimes the length
    of the command line you want to enter even hits the maximum length your command-line
    system allows. The Microsoft Windows command prompt being an example of something
    that has a fairly small maximum line length.
  prefs: []
  type: TYPE_NORMAL
- en: To aid such situations, curl offers a feature we call "config file". It basically
    allows you to write command-line options in a text file instead and then tell
    curl to read options from that file in addition to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You tell curl to read more command-line options from a specific file with the
    -K/--config option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '…and in the `cmdline.txt` file (which, of course, can use any file name you
    please) you enter each command line per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The config file accepts both short and long options, exactly as you would write
    them on a command line. As a special extra feature, it also allows you to write
    the long format of the options without the leading two dashes to make it easier
    to read. Using that style, the config file shown above can alternatively be written
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Command line options that take an argument must have its argument provided on
    the same line as the option. For example changing the User-Agent HTTP header can
    be done with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow the config files to look even more like a true config file, it also
    allows you to use ''='' or '':'' between the option and its argument. As you see
    above it isn''t necessary, but some like the clarity it offers. Setting the user-agent
    option again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The argument to an option can be specified without double quotes and then curl
    will treat the next space or newline as the end of the argument. So if you want
    to provide an argument with embedded spaces you must use double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user agent string example we have used above has no white spaces and therefore
    it can also be provided without the quotes like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you want to provide a URL in a config file, you must do that the
    `--url` way, or just with `url`, and not like on the command line where basically
    everything that isn''t an option is assumed to be a URL. So you provide a URL
    for curl like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Default config file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When curl is invoked, it always (unless `-q` is used) checks for a default config
    file and uses it if found. The file name it checks for is `.curlrc` on Unix-like
    systems and `_curlrc` on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default config file is checked for in the following places in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'curl tries to find the "home directory": It first checks for the CURL_HOME
    and then the HOME environment variables. Failing that, it uses `getpwuid()` on
    Unix-like systems (which returns the home directory given the current user in
    your system). On Windows, it then checks for the APPDATA variable, or as a last
    resort the ''%USERPROFILE%\Application Data''.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Windows, if there is no _curlrc file in the home directory, it checks for
    one in the same directory the curl executable is placed. On Unix-like systems,
    it will simply try to load .curlrc from the determined home directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passwords and snooping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passwords are tricky and sensitive. Leaking a password can make someone else
    than you access the resources and the data otherwise protected.
  prefs: []
  type: TYPE_NORMAL
- en: curl offers several ways to receive passwords from the user and then subsequently
    pass them on or use them to something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic curl authentication option is `-u / --user`. It accepts an argument
    that is the user name and password, colon separated. Like when alice wants to
    request a page requiring HTTP authentication and her password is ''12345'':'
  prefs: []
  type: TYPE_NORMAL
- en: $ curl -u alice:12345 [http://example.com/](http://example.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Command line leakage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several potentially bad things are going on here. First, we are entering a password
    on the command line and the command line might be readable for other users on
    the same system (assuming you have a multi-user system). curl will help minimize
    that risk by trying to blank out passwords from process listings.
  prefs: []
  type: TYPE_NORMAL
- en: One way to avoid passing the user name and password on the command line is to
    instead use a [.netrc file](usingcurl-netrc.html) or a [config file](cmdline-configfile.html).
    You can also use the `-u` option without specifying the password, and then curl
    will instead prompt the user for it when it runs.
  prefs: []
  type: TYPE_NORMAL
- en: Network leakage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Secondly, this command line sends the user credentials to an HTTP server, which
    is a clear-text protocol that is open for man-in-the-middle or other snoopers
    to spy on the connection and see what is sent. In this command line example, it
    makes curl use HTTP Basic authentication and that is completely insecure.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to avoid this, and the key is, of course, then to avoid
    protocols or authentication schemes that sends credentials in the plain over the
    network. Easiest is perhaps to make sure you use encrypted versions of protocols.
    Use HTTPS instead of HTTP, use FTPS instead of FTP and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to stick to a plain text and insecure protocol, then see if you
    can switch to using an authentication method that avoids sending the credentials
    in the clear. If you want HTTP, such methods would include Digest (`--digest`),
    Negotiate (`--negotiate.`) and NTLM (`--ntlm`).
  prefs: []
  type: TYPE_NORMAL
- en: Progress meter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The progress meter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl has a built-in progress meter. When curl is invoked to transfer data (either
    uploading or downloading) it can show that meter in the terminal screen to show
    how the transfer is progressing, namely the current transfer speed, how long it
    has been going on and how long it thinks it might be left until completion.
  prefs: []
  type: TYPE_NORMAL
- en: The progress meter is inhibited if curl deems that there is output going to
    the terminal, as then would the progress meter interfere with that output and
    just mess up what gets displayed. A user can also forcibly switch off the progress
    meter with the `-s / --silent` option, which tells curl to hush.
  prefs: []
  type: TYPE_NORMAL
- en: If you invoke curl and don't get the progress meter, make sure your output is
    directed somewhere other than the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: curl also features an alternative and simpler progress meter that you enable
    with `-# / --progress-bar`. As the long name implies, it instead shows the transfer
    as progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: At times when curl is asked to transfer data, it can't figure out the total
    size of the requested operation and that then subsequently makes the progress
    meter contain fewer details and it cannot, for example, make forecasts for transfer
    times, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The progress meter displays bytes and bytes per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will also use suffixes for larger amounts of bytes, using the 1024 base
    system so 1024 is one kilobyte (1K), 2048 is 2K, etc. curl supports these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Suffix | Amount | Name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| K | 2^10 | kilobyte |'
  prefs: []
  type: TYPE_TB
- en: '| M | 2^20 | megabyte |'
  prefs: []
  type: TYPE_TB
- en: '| G | 2^30 | gigabyte |'
  prefs: []
  type: TYPE_TB
- en: '| T | 2^40 | terabyte |'
  prefs: []
  type: TYPE_TB
- en: '| P | 2^50 | petabyte |'
  prefs: []
  type: TYPE_TB
- en: The times are displayed using H:MM:SS for hours, minutes and seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Progress meter legend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The progress meter exists to show a user that something actually is happening.
    The different fields in the output have the following meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'From left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Title | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| % | Percentage completed of the whole transfer |'
  prefs: []
  type: TYPE_TB
- en: '| Total | Total size of the whole expected transfer (if known) |'
  prefs: []
  type: TYPE_TB
- en: '| % | Percentage completed of the download |'
  prefs: []
  type: TYPE_TB
- en: '| Received | Currently downloaded number of bytes |'
  prefs: []
  type: TYPE_TB
- en: '| % | Percentage completed of the upload |'
  prefs: []
  type: TYPE_TB
- en: '| Xferd | Currently uploaded number of bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Average Speed Dload | Average transfer speed of the entire download so far,
    in number of bytes per second |'
  prefs: []
  type: TYPE_TB
- en: '| Average Speed Upload | Average transfer speed of the entire upload so far,
    in number of bytes per second |'
  prefs: []
  type: TYPE_TB
- en: '| Time Total | Expected time to complete the operation, in HH:MM:SS notation
    for hours, minutes and seconds |'
  prefs: []
  type: TYPE_TB
- en: '| Time Current | Time passed since the start of the transfer, in HH:MM:SS notation
    for hours, minutes and seconds |'
  prefs: []
  type: TYPE_TB
- en: '| Time Left | Expected time left to completion, in HH:MM:SS notation for hours,
    minutes and seconds |'
  prefs: []
  type: TYPE_TB
- en: '| Curr.Speed | Average transfer speed over the last 5 seconds (the first 5
    seconds of a transfer is based on less time, of course) in number of bytes per
    second |'
  prefs: []
  type: TYPE_TB
