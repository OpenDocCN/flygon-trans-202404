- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are like me, you have seen many times how your programs terminate with
    an error or exception message. Here are some examples of exception messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Errors and exceptions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Errors such as OutOfMemoryError indicate a serious failure, where continuing
    the program makes no sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other exceptions, however, merely indicate an unexpected or abnormal condition
    in a program. For instance, a mistake in the input data of a program could cause
    an exception. Such mistakes can be handled: We say that the exception is handled
    or caught.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a NumberFormatException might indicate that the user entered an
    incorrect number, and the correct response would be to print an error message
    and ask for new input.
  prefs: []
  type: TYPE_NORMAL
- en: A FileNotFoundException means that the file we tried to open does not exist.
    Depending on the situation, the correct response could be to try a different file
    name, to ask the user for a different file name, or simply to skip reading the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code asks the user for a number. The function readString returns
    a string, so we have to convert that to an integer using the toInt() method. If
    the string is not a number, such as "abc" or "123ab", then the toInt() method
    throws an exception. We can catch the exception by enclosing the critical part
    in a try block, and adding a catch block to handle the exceptions we are interested
    in ([catch1.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/16-exceptions/catch1.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the try block executes normally, then the catch clauses are skipped. But
    if somewhere inside the try block (including in any method called, directly or
    indirectly) an exception is thrown, then execution of the try block stops immediately,
    and continues in the first case of the catch clause that matches the exception.
    Here, "matches" means that the exception is the same type as the exception type
    listed in the case.
  prefs: []
  type: TYPE_NORMAL
- en: The code within a catch case is called an exception handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example above, if the string str does not represent an integer (for
    instance, if it is "abc"), then str.toInt throws the exception NumberFormatException.
    The try block is terminated (and in particular, no value is assigned to x), and
    execution continues in the catch clause for NumberFormatException. Here are some
    example runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions versus error codes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Old programming languages like C do not have exceptions, and so all errors or
    unusual conditions need to be handled by error codes. In C++, error codes are
    also still widely used, for instance for compatibility with C.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple and elegant method like str.toInt() is impossible without exceptions.
    We would have to return two results: one Boolean value to indicate whether the
    conversion was successful, and the Int value itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So exceptions allow us to concentrate on the essential meaning of str.toInt():
    it takes a string, and returns a number. But the real power of exceptions only
    appears in the next section…'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions deep deep down
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The nice thing about exceptions is that you can also catch exceptions that were
    thrown inside functions called in the try block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our number conversion example, here is version where we convert
    the string in a separate function ([catch2.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/16-exceptions/catch2.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function test(s) converts the string to a double, but then rounds it off
    to two decimal places and returns an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a conversion error occurs, this happens inside test(s), but we can still
    catch this in the show(s) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When an exception occurs (we say that an exception is thrown), then the normal
    flow of execution is then interrupted, and continues at the nearest (innermost,
    most recent) catch block where this type of exception is caught (that is, there
    is an exception handler of the right type).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this in more detail and consider the following program ([except1.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/16-exceptions/except1.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For input value "25", we see beginning and end of try block and the functions
    f and g. For input value "abc", the toInt method throws an exception, so f is
    not called. For input value "0", the division inside function g throws an ArithmeticError.
    As you see, execution continues immediately in the exception handler, without
    finishing functions g, f, or the try-block.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing exceptions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far we have only caught exceptions thrown inside some library function.
    But you can just as well throw exceptions yourself. For instance, let''s assume
    that our function g(n) above should only handle non-negative numbers. We can ensure
    this by throwing an IllegalArgumentException if the argument is negative. The
    whole script now looks like this ([except2.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/16-exceptions/except2.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that exceptions are objects, and are created like any other object, by
    calling their constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we run it with different inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions are often used to detect errors in the input data.
  prefs: []
  type: TYPE_NORMAL
- en: We can catch the exception at a suitable place in the program and print an error
    message, or handle the problem in some other way.
  prefs: []
  type: TYPE_NORMAL
- en: When you are debugging a program, you may be confused where certain exceptions
    come from. In such a case it can be useful to use the method printStackTrace()
    of the exception object. It prints out the chain of methods that lead to the exception
    being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change our main function as follows ([except3.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/16-exceptions/except3.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'then we can see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that the IllegalArgumentException was thrown in function g (in
    line 16 of the script), which was called by function f, which was called from
    the main function.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Assertions are conditions in the program that are tested during the execution.
    If the condition is true, nothing particular happens. If the condition is false,
    however, an AssertionError exception is thrown. The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: throws an AssertionError if condition is false.
  prefs: []
  type: TYPE_NORMAL
- en: You can also include a message with the assertion.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of an assertion is to detect errors in your program. (Compare this
    with the exceptions use above, whose purpose is to detect errors in the input
    data.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the code A is correct, then the string s computed by A cannot be empty. We
    verify that this is indeed true, that is that s is not empty, using an assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this assertion is to protect code B. Without the assertion,
    the following could happen: There is a mistake in code A, and therefore s is empty.
    This causes some strange crash in code B, and so we start debugging code B. With
    the assertion, it is immediately clear that the problem is in code A.'
  prefs: []
  type: TYPE_NORMAL
- en: So the purpose of assertions is to protect pieces of code from each other, and
    to isolate problems.
  prefs: []
  type: TYPE_NORMAL
- en: Require
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The require(condition) statement is a special form of assertion. It works exactly
    like assert, but throws an IllegalArgumentException if the condition is false.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is useful when you need an assertion to test if the arguments of a method
    are correct: in this situtation you should use require(condition) instead of assert(condition).'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of require is to protect your function from being called with illegal
    arguments. Without it, you might spend a long time trying to debug your function,
    when in reality a problem is caused by incorrect argument values given to the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When reading or writing files, many things can go wrong. The file might not
    exist, we might not be allowed to write to it, the hard disk may be full, or someone
    might eject the CD-ROM we are reading from. This means that any serious code the
    does file input/output needs to worry about catching exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simple script prints all lines in a text file together with the
    length of each line. If the file doesn''t exist or if you are not allowed to read
    the file, an exception will be thrown. You can catch the exception, print an error
    message, and continue, instead of letting the program crash ([read1.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/16-exceptions/read1.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the forEachLine method fails to open the file, it will throw a FileNotFoundException.
    The loop is not executed; execution jumps directly to the exception handler that
    prints a message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: FileNotFoundException is a special case of IOException, so the exception matches
    both catch clauses. However, only one catch clause is executed–the first one that
    matches. The second catch clause would execute if the first were not present.
  prefs: []
  type: TYPE_NORMAL
- en: It could happen that we can open the file, but the forAllLines method still
    throws an exception (for instance, because the disk is faulty). This typically
    generates some sort of IOException. This causes the second catch clause to execute.
    Exception handlers are often used to recover from errors and clean up loose ends
    like open files.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don't need a catch clause for every exception that can occur.
    You can catch some exceptions and let others propagate.
  prefs: []
  type: TYPE_NORMAL
