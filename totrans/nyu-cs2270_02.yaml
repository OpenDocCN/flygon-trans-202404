- en: Notes for September 16 class -- Introduction to Ray Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WebGL Cheat Sheet**'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned last week, there is a convenient [compact guide to WebGL.](https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The last page in particular is useful for writing shaders in OpenGL ES.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that OpenGL ES fragment shaders do not allow recursion.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Gamma correction**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays are adjusted for human perception using a "gamma curve", since people
    can perceive a vary large range of brightness.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, the image to the right shows the values 0...255 on the horizontal
    axis, the resulting actual displayed brightness on the virtual axis.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Various displays differ, but this adjustment is generally approximately x²
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since all of our calculations are really summing actual photons of light, we
    need to do all our math in linear brightness, and then do a gamma correction when
    we are all finished:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Roughly: c → sqrt(c)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output brightness*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/faf0a062f9799cc734a4d7f0f6cf0ca4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Input values 0 ... 255*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ray tracing: *Forming a ray***'
  prefs: []
  type: TYPE_NORMAL
- en: At each pixel, a ray from the origin V = (0,0,0) shoots into the scene, hitting
    a virtual screen which is on the z = -f plane.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We refer to f as the "focal length" of this virtual camera.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The ray toward any pixel aims at: (x, y, -f), where -1 ≤ x ≤ +1 and -1 ≤ y
    ≤ +1.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So the ray direction W = normalize( vec3(x, y, -f) ).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In order to render an image of a scene at any pixel, we need to follow the ray
    at that pixel and see what object (if any) the ray encounters first.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, the nearest object at a point V + Wt, where t > 0.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/fc61dfbaf236b39341e952d35fe8e63b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ray tracing: *Defining a sphere***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe a sphere in a GLSL vector of length 4:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`vec4 sphere = vec4(x,y,z,r);`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where (x,y,z) is the center of the sphere, and r is the sphere radius.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As we discussed in class, the components of a vec4 in GLSL can be accessed
    in one of two ways:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So to access the value of your sphere's radius in a fragment shader `vec4`,
    you will want to refer to it as sphere.w (not sphere.r).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/f16b1ccbeb5d4d24076a1a259dffadaa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ray tracing: *Finding where a ray hits a sphere***'
  prefs: []
  type: TYPE_NORMAL
- en: D = V - sph.xyz // vector from center of sphere to ray origin.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The point of doing this subtraction is that we are then effectively solving
    the much easier problem of ray tracing to a sphere at the origin (0,0,0).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So instead of solving the more complex problem of tracing a ray V+Wt to a sphere
    centered at sph.xyz, we are instead solving the equivalent, but much simpler,
    problem of tracing the ray D+Wt to a sphere centered at (0,0,0).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (D + Wt)² = sph.r² // find a point along ray that is distance r from sphere
    center.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (D + Wt)² - sph.r² = 0 // need to solve for t.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Generally, if a and b are vectors, then a • b = ( a[x] * b[x] + a[y] * b[y]
    + a[z] * b[z] )
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This "inner product" also equals: |a| * |b| * cos(θ)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Multiplying the terms out, we need to solve the following quadratic equation:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (W • W) t² +
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 2 (W • D) t +
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: (D • D) - r² = 0
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since ray direction W is unit length, the first term in this equation (W • W)
    is just 1.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/8c485daddd6e051fd3d3758f6e0cd3b9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ray tracing: *Finding the nearest intersection***'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the intersection to all spheres in the scene.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The visible sphere at this pixel, if any, is the one with smallest positive
    t.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Ray tracing: *Computing the surface point***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know the value of t, we can just plug it into the ray equation to get
    the location of the surface point on the sphere that is visible at this ray, as
    shown in the equation below and in the figure to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: S = V + W t
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/9ca84eac450457168de6e9ab79a945c6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ray tracing: *Computing the surface normal***'
  prefs: []
  type: TYPE_NORMAL
- en: We now need to compute the surface normal in order to compute how the sphere
    interacts with light to produce a final color at this pixel.
  prefs: []
  type: TYPE_NORMAL
- en: The "surface normal" is the unit length vector that is perpendicular to the
    surface of the sphere -- the "up" direction if you are standing on the surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a sphere, we can get this by subtracting the center of the sphere from
    the surface point S, and then dividing by the radius of the sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: N = (S - sph.xyz) / sph.r
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/70f96f090203c87c8f10d499bd8e66b0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ray tracing: *A simple shader***'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple light source at infinity can be defined as an rgb color, together
    with an xyz light direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A diffuse simple surface material can be defined by an rgb "ambient" component,
    which is independent of any particular light source, and an rgb "diffuse" component,
    which is added for each light source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The figure to the right shows a diffuse sphere, where the point at each pixel
    is computed as:'
  prefs: []
  type: TYPE_NORMAL
- en: ambient + lightColor * diffuse * max(0, normal • lightDirection)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/38f40f1008aa1becae861e45f38d6838.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ray tracing: *Multiple light sources***'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the scene contains more than one light source, then pixel color for points
    on the sphere can be computed by:'
  prefs: []
  type: TYPE_NORMAL
- en: ambient + ∑[n] ( lightColor[n] * diffuse * max(0, normal • lightDirection[n])
    )
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where n iterates over the lights in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**At the end of the class we saw a video:**'
  prefs: []
  type: TYPE_NORMAL
- en: The Academy Award winning short [**Ryan**](http://videosift.com/video/Chris-Landreth-Ryan-Oscar-winning-animated-short)
    by Chris Landreth.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Homework**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement simple ray tracing for spheres in a fragment shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we said in class, you can start with [this code base](code2.zip).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement simple diffuse shading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extra credit: multiple spheres'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Hint:*** You can create and use an array of spheres as:'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you try this extra credit, make sure that at each pixel you choose the sphere
    with the smallest value of t.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Extra credit: multiple light sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extra credit: procedural textures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make something cool and fun, try to create something interactive (using uCursor)
    and/or animated (using uTime).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
