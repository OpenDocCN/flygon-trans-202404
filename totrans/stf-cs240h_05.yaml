- en: GHC Language extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GHC implements many extensions to Haskell, enabled by
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing `{-# LANGUAGE` *ExtensionName* `#-}` at top of file (recommended)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling with `-X`*ExtensionName* (less recommended, except for `-XSafe`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Typing `:set -X`*ExtensionName* at `ghci` prompt (or running `ghci` with `-X`...)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete list at [Language options](http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#idp14594128)
    section of GHC's option summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some extensions are very safe to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., core libraries depend on extension in a deep way
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension very superficial, easily de-sugars into Haskell2010
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other extensions less widely accepted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., makes type inference/checking undecidable or non-deterministic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Undermines type safety
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A work in progress that could never be incorporated into standard
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many extensions in a middle/gray area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Background: Monad transformers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type constructors building monads parameterized by other monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method [`lift`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Class.html#t:MonadTrans)
    executes actions from underlying transformed monad:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note monads have kind ∗ → ∗, so transformers have kind (∗ → ∗) → ∗ → ∗
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: State transformer monad, [`StateT`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#v:StateT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `StateT`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`get` and `put` allow you to modify state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: Haskell equivalent of `x++` in C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise: Implement `get` and `put`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall `StateT` implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to implement the following?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Implement `get` and `put`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall `StateT` implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to implement the following?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `MonadIO` class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes want to execute IO regardless of current monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's make `liftIO` work for `StateT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now can write functions that use IO and work in many monads:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All standard Monad transformers implement class `MonadIO`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContT`, `ErrorT`, `ListT`, `RWST`, `ReaderT`, `StateT`, `WriterT`, ...'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Background: recursive bindings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Top-level, `let`, and `where` bindings are all recursive in Haskell, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Recursion can be implemented using a fixed-point combinator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function [`fix`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Function.html#v:fix)
    calls a function with its own result, use to re-implement above:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Recursion and monadic bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By contrast, monadic bindings are *not* recursive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But monads in the [`MonadFix`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-Fix.html#t:MonadFix)
    class have a fixed-point combinator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`mfix` can be used to implement recursive monadic bindings [[Erkök00]](http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=13851C3A2D4F33918B9D662C20F30762?doi=10.1.1.43.5313&rep=rep1&type=pdf),
    e.g.:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why? E.g., might want to simulate circuits with monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need recursion if there is a loop in your circuit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Might want recursion anyway to avoid worrying about order of statements
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`RecursiveDo`](http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation)
    extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New `rec` keyword introduces recursive bindings in a `do` block [[Erkök02]](https://sites.google.com/site/leventerkok/recdo.pdf?attredirects=0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monad must be an instance of `MonadFix` (`rec` desugars to `mfix` calls)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Desugars to:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In practice `RecursiveDo` helps structure thinking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then can manually desugar rather than require a language extension
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But `mfix` on its own is quite useful
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Example uses of `mfix` and `rec`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create recursive data structures in one shot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Call non-strict methods of classes (easy access to return-type dictionary)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing `mfix`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Warm-up: The [`Identity`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Data-Functor-Identity.html#v:Identity)
    monad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`newtype` compiles to nothing, so basically same as `fix`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`fixIO` -- `IO` Monad fixed point'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, lazy IO is implemented by magic [`unsafeInterleaveIO`](http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Looks like an `IO` identify function, but defers IO until the thunk forced
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Danger--don't try this at home! No longer a functional language
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'For `IO`, `mfix = fixIO`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is quite similar to what the compiler does for pure `fix`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A generic `mfix` is not possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we tried to define an `mfix`-like function for all monads?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is equivalent to
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But `>>=` is strict in its first argument for many monads, so
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So `mfix` needs to take fixed point over value, not over monadic action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do this is monad-specific
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't work for all monads (`ContT`, `ListT`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonadFix` instance for `StateT`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about the [`StateT`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#t:StateT)
    monad?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Possibly easiest to see using `rec` notation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But easily implemented with no language extensions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Review: Type classes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A [Haskell 2010 type class declaration](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-760004.3.1)
    can take the form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `var` need not have kind ∗
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the type of each method must mention `var` and an implicit `(Classname
    var)` is added to the context of each method, e.g.:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'A [Haskell 2010 instance declaration](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-770004.3.2)
    has the form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note `v1` ... `vk` are all variables and all distinct, ruling out, e.g., `instance
    C (a,a)` or `instance C (Int a)` or `instance [[a]]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`MultiParamTypeClasses`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#id559142)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enables type classes with multiple parameters, E.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Extension itself is relatively safe, but encourages other extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., each method's type must use every type parameter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: All types (argument and return) must be fully determined
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: And the usual instance restrictions still apply
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`[Char]`--i.e., `([] Char)`--is not a valid instance parameter, would have
    to be `([] a)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`FlexibleInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allows more specific type paremeters (relatively safe extension)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.g., now we can say:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And we can make all types convert to themselves:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Oops, two instances apply; GHC doesn't know which to choose
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`OverlappingInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This extension is used, but also widely frowned upon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only need this extension if overlapping instances actually used
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable extension where instances defined, not where used
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler picks the most specific matching instance. *I*[1] is more specific
    than *I*[2] when *I*[1] can be created by substituting for the variables of *I*[2]
    and not vice versa
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Contexts (part before `=>`) not considered when selecting instances
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Do something like `Show` for `String` vs. `[a]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So does enabling `OverlappingInstances` fix `Convert`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most specific instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the most specific instance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Neither instance is most specific!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to add a *third* instance to break the tie--one that can be created
    by substituting for variables in either of the other two overlapping instances
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A case against `OverlappingInstances`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside: How `Show` actually works'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add an extra helper method, `showList`, with a default definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`Show` instance for `Char` overrides default `showList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But had to plan all this out from the start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want an easy way to special-case trees or other data structures besides lists?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then you are stuck using overlapping instances
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`FlexibleContexts`](http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#flexible-contexts)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MultiParamTypeClasses` leads to inexpressible types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What is the type of function `toInt`? Would like to write:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But `(Convert a Int) =>` is an illegal context, as `Int` not a type variable
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlexibleContexts` extension makes the above type legal to write'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is a relatively safe extension to use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Still a couple of restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each type variable in context must be "reachable" from a type variable in type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (Reachable = explicitly used, or in another constraint with a reachable variable.)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Every constraint must have a type variable
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Monad classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's neat that `liftIO` works from so many monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not do something similar for `StateT`? Make `get`/`set` methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now for each other `MonadTrans`, pass requests down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is just like `liftIO`. E.g., for `ReaderT`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Problem: we''ve defeated type inference'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember `xplusplus`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The compiler knows we are in `StateT Int IO` monad
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So can infer that the type of `get` is `Num s => StateT Int IO s`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But need to know `s` in order to select an instance of `MonadState`!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For all compiler knows, might be other matching instances, e.g.,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Since compiler can''t infer return type of `get`, must type it manually:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Yuck! Lack of type inference gets old fast!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`FunctionalDependencies`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Widely used & frowned upon (not as bad as `OverlappingInstances`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also referred to as "fundeps"
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lets a class declare some parameters to be functions of others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The best way to think of this is in terms of *instance selection*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"`| m -> s`" says can select an instance based on `m` without considering `s`,
    because **`s` is a function of `m`**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've selected the instance, you can use `s` for type inference
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Disallows conflicting instances (even w. `OverlappingInstances`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also allows arbitrary computation at the type level [[Hallgren]](http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=D19C7E3BD1B5C1FC24035542B1494ED9?doi=10.1.1.22.7806&rep=rep1&type=pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But language committee wants compilation to be decidable and deterministic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So need to add some restrictions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sufficient conditions of decidable instances](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anatomy of an instance: `instance` [*context* `=>`] *head* [`where` *body*]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*context* consists of zero or more comma-separated *assertions*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Paterson Conditions: for each assertion in the context'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No type variable has more occurrences in the assertion than in the head
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The assertion has fewer constructors and variables than the head
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The Coverage Condition: For each fundep *left* `->` *right*, the types in *right*
    cannot have type variables not mentioned in *left*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Undecidable vs. exponential -- who cares?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Editorial: maybe decidability of language is overrated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computers aren't Turing machines with infinite tapes, after all
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This legal, decidable program will crash your Haskell compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While plenty of not provably decidable programs happily compile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditions of the last slide are *sufficient*, not *necessary*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Might have other ways of knowing your program can compile
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Or maybe figure it out from trial and error?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`UndecidableInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lifts the Paterson and Coverage conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also enables `FlexibleContexts` when enabled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead, imposes a maximum recursion depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default maximum depth is 20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can increase with `-fcontext-stack=`*n* option, e.g.:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: A bit reminiscent of C++ templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gcc has a `-ftemplate-depth=` option
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note C++11 raises minimum depth from 17 to 1024
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, people have talked of increasing GHC's default context-stack
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonadIO` revisited'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall definition of `MonadIO`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Currently must define an instance for every transformer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `UndecidableInstances`, one instance can cover all transformers!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary of extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen 6 typeclass-related extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Not all of these are looked upon kindly by the community
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But if you enable all six, can be very powerful
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remainder of lecture looks at what you can do with all 6 enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Much inspired by [[Hlist]](http://homepages.cwi.nl/~ralf/HList/paper.pdf) and
    [[OOHaskell]](http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Warm-up: Type-level booleans'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note how fundep in `HNot b nb` computes negation of `b` **at the type level**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Haven't used `OverlappingInstances` yet, let's start...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing over types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Can we compute whether two types are equal? First attempt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Problem: `TypeEq a a HTrue` not more specific than `TypeEq a b HFalse`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '... but `TypeEq a a HTrue` *is* more specific than `TypeEq a b c`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that context is never consulted for instance selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only afterwards to reject failed assertions or infer types from fundeps
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: compute `c` after instance selection using another fundep'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The utility of `TypeEq`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Editorial: `TypeEq` is kind of the holy grail of fundeps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can implement `TypeEq`, you can program recursively at type level by
    distinguishing base and recursive cases!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But relies deeply on `OverlappingInstances`...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Let''s do for `MonadState` what we did for `MonadIO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MonadIO` was easier because type `IO` can''t match parameter `(t m)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, `StateT s m` matches *both* of above instance heads
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So need `OverlappingInstances` to select first instance for `StateT s m`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Heterogeneous lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Last extension: [`TypeOperators`](http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons)
    allows infix types starting with "`:`"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's use an infix constructor to define a heterogeneous list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Operations on heterogeneous lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice our list consisted of pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: View first element as a key or tag, second as a value--How to look up value?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again, note the importance of `OverlappingInstances`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needed to break recursion when type of lookup tag matches head of list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can use to implement all sorts of other features (concatenation, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heterogeneous can implement object-oriented programming!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But why `mfix`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Tying the recursive knot"'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mfix` allows you to override methods with inheritance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example, create a "const val" that ignores `SetVal` messages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`mkVal`''s call to `SetVal` was properly overridden by `mkConstVal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
