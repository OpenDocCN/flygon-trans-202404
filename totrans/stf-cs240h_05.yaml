- en: GHC Language extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GHC语言扩展
- en: GHC implements many extensions to Haskell, enabled by
  id: totrans-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GHC实现了许多Haskell扩展，通过启用
- en: Placing `{-# LANGUAGE` *ExtensionName* `#-}` at top of file (recommended)
  id: totrans-2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件顶部放置`{-# LANGUAGE` *ExtensionName* `#-}`（推荐）
- en: Compiling with `-X`*ExtensionName* (less recommended, except for `-XSafe`)
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-X`*ExtensionName*编译（不推荐，除了`-XSafe`）
- en: Typing `:set -X`*ExtensionName* at `ghci` prompt (or running `ghci` with `-X`...)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ghci`提示符处键入`:set -X`*ExtensionName*（或使用`-X`运行`ghci`...）
- en: Complete list at [Language options](http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#idp14594128)
    section of GHC's option summary
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GHC选项摘要的[语言选项](http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#idp14594128)部分列出完整列表
- en: Some extensions are very safe to use
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些扩展非常安全可靠
- en: E.g., core libraries depend on extension in a deep way
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，核心库深度依赖扩展
- en: Extension very superficial, easily de-sugars into Haskell2010
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展非常表面，很容易转换为Haskell2010
- en: Other extensions less widely accepted
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他扩展被较少接受
- en: E.g., makes type inference/checking undecidable or non-deterministic
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，使类型推断/检查变得不可判定或非确定性
- en: Undermines type safety
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏类型安全
- en: A work in progress that could never be incorporated into standard
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无法并入标准的正在进行中的工作
- en: Many extensions in a middle/gray area
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多扩展处于中间/灰色地带
- en: 'Background: Monad transformers'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景：Monad变换器
- en: Type constructors building monads parameterized by other monads
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类构造器构建由其他单子参数化的单子
- en: 'Method [`lift`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Class.html#t:MonadTrans)
    executes actions from underlying transformed monad:'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法[`lift`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Class.html#t:MonadTrans)执行来自底层转换单子的操作：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note monads have kind ∗ → ∗, so transformers have kind (∗ → ∗) → ∗ → ∗
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意单子的种类∗ → ∗，因此变换器的种类为(∗ → ∗) → ∗ → ∗
- en: 'Example: State transformer monad, [`StateT`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#v:StateT)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例子：状态变换器单子，[`StateT`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#v:StateT)
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using `StateT`
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`StateT`
- en: '`get` and `put` allow you to modify state'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`和`put`允许您修改状态'
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Example: Haskell equivalent of `x++` in C'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例子：在C中的`x++`的Haskell等价物
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Exercise: Implement `get` and `put`'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：实现`get`和`put`
- en: Recall `StateT` implementation
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾`StateT`的实现
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to implement the following?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现以下内容？
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Exercise: Implement `get` and `put`'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：实现`get`和`put`
- en: Recall `StateT` implementation
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾`StateT`的实现
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to implement the following?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现以下内容？
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `MonadIO` class
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`MonadIO`类'
- en: Sometimes want to execute IO regardless of current monad
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时希望执行IO而不考虑当前单子
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's make `liftIO` work for `StateT`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让`liftIO`在`StateT`中起作用
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now can write functions that use IO and work in many monads:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在可以编写使用IO并在许多单子中工作的函数：
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All standard Monad transformers implement class `MonadIO`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有标准Monad变换器都实现了`MonadIO`类
- en: '`ContT`, `ErrorT`, `ListT`, `RWST`, `ReaderT`, `StateT`, `WriterT`, ...'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContT`、`ErrorT`、`ListT`、`RWST`、`ReaderT`、`StateT`、`WriterT`等'
- en: 'Background: recursive bindings'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景：递归绑定
- en: 'Top-level, `let`, and `where` bindings are all recursive in Haskell, e.g.:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层、`let`和`where`绑定在Haskell中都是递归的，例如：
- en: '[PRE12]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Recursion can be implemented using a fixed-point combinator
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用固定点组合子实现递归
- en: 'Function [`fix`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Function.html#v:fix)
    calls a function with its own result, use to re-implement above:'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`fix`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Function.html#v:fix)调用具有其自身结果的函数，用于重新实现上述内容：
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Recursion and monadic bindings
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归和单子绑定
- en: By contrast, monadic bindings are *not* recursive
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比之下，单子绑定*不*是递归的
- en: '[PRE15]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But monads in the [`MonadFix`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-Fix.html#t:MonadFix)
    class have a fixed-point combinator
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但[`MonadFix`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-Fix.html#t:MonadFix)类中的单子具有固定点组合子
- en: '[PRE16]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`mfix` can be used to implement recursive monadic bindings [[Erkök00]](http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=13851C3A2D4F33918B9D662C20F30762?doi=10.1.1.43.5313&rep=rep1&type=pdf),
    e.g.:'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mfix`可用于实现递归单子绑定[[Erkök00]](http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=13851C3A2D4F33918B9D662C20F30762?doi=10.1.1.43.5313&rep=rep1&type=pdf)，例如：'
- en: '[PRE17]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Why? E.g., might want to simulate circuits with monads
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么？例如，可能想要用单子模拟电路
- en: Need recursion if there is a loop in your circuit
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果电路中存在循环，则需要递归
- en: Might want recursion anyway to avoid worrying about order of statements
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能仍然希望递归以避免担心语句的顺序
- en: The [`RecursiveDo`](http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation)
    extension
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`RecursiveDo`](http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation)
    扩展'
- en: New `rec` keyword introduces recursive bindings in a `do` block [[Erkök02]](https://sites.google.com/site/leventerkok/recdo.pdf?attredirects=0)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `rec` 关键字在 `do` 块中引入递归绑定 [[Erkök02]](https://sites.google.com/site/leventerkok/recdo.pdf?attredirects=0)
- en: Monad must be an instance of `MonadFix` (`rec` desugars to `mfix` calls)
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子必须是 `MonadFix` 的一个实例（`rec` 展开为 `mfix` 调用）
- en: '[PRE18]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Desugars to:'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开为：
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In practice `RecursiveDo` helps structure thinking
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实践中，`RecursiveDo` 有助于构建思维结构
- en: Then can manually desugar rather than require a language extension
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后可以手动展开，而不需要语言扩展
- en: But `mfix` on its own is quite useful
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但单独使用 `mfix` 是非常有用的
- en: Example uses of `mfix` and `rec`
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`mfix` 和 `rec` 的示例用法'
- en: Create recursive data structures in one shot
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性创建递归数据结构
- en: '[PRE20]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Call non-strict methods of classes (easy access to return-type dictionary)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用类的非严格方法（轻松访问返回类型字典）
- en: '[PRE21]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implementing `mfix`
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 `mfix`
- en: 'Warm-up: The [`Identity`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Data-Functor-Identity.html#v:Identity)
    monad'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热身：[`Identity`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Data-Functor-Identity.html#v:Identity)
    单子
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`newtype` compiles to nothing, so basically same as `fix`:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newtype` 编译成空，所以基本上与 `fix` 相同：'
- en: '[PRE23]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`fixIO` -- `IO` Monad fixed point'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`fixIO` -- `IO` 单子的不动点'
- en: Internally, lazy IO is implemented by magic [`unsafeInterleaveIO`](http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，惰性 IO 是通过神奇的 [`unsafeInterleaveIO`](http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO)
    实现的
- en: '[PRE24]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Looks like an `IO` identify function, but defers IO until the thunk forced
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看起来像是一个 `IO` 标识函数，但推迟 IO 直到强制 thunk
- en: Danger--don't try this at home! No longer a functional language
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 危险--不要在家里尝试！不再是一个函数式语言
- en: '[PRE25]'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For `IO`, `mfix = fixIO`:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `IO`，`mfix = fixIO`：
- en: '[PRE26]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is quite similar to what the compiler does for pure `fix`
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这与编译器为纯 `fix` 所做的事情非常相似
- en: A generic `mfix` is not possible
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用的 `mfix` 是不可能的
- en: What if we tried to define an `mfix`-like function for all monads?
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们尝试为所有单子定义一个类似 `mfix` 的函数会怎样？
- en: '[PRE27]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is equivalent to
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这等同于
- en: '[PRE28]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: But `>>=` is strict in its first argument for many monads, so
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但对于许多单子，`>>=` 在其第一个参数上是严格的
- en: '[PRE29]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So `mfix` needs to take fixed point over value, not over monadic action
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此 `mfix` 需要对值进行不动点，而不是对单子动作进行不动点
- en: How to do this is monad-specific
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何做到这一点是特定于单子的
- en: Doesn't work for all monads (`ContT`, `ListT`)
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不适用于所有单子（`ContT`，`ListT`）
- en: '`MonadFix` instance for `StateT`'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`StateT` 的 `MonadFix` 实例'
- en: What about the [`StateT`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#t:StateT)
    monad?
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`StateT`](http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#t:StateT)
    单子怎么样？'
- en: '[PRE30]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Possibly easiest to see using `rec` notation
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能最容易使用 `rec` 符号来看
- en: '[PRE31]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: But easily implemented with no language extensions
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但可以轻松实现，无需语言扩展
- en: '[PRE32]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Review: Type classes'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习：类型类
- en: 'A [Haskell 2010 type class declaration](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-760004.3.1)
    can take the form:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 [Haskell 2010 类型类声明](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-760004.3.1)
    可以采用以下形式：
- en: '[PRE33]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that `var` need not have kind ∗
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意 `var` 不必具有 ∗ 类型
- en: 'However, the type of each method must mention `var` and an implicit `(Classname
    var)` is added to the context of each method, e.g.:'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，每个方法的类型必须提及 `var`，并且每个方法的上下文中添加了一个隐式的 `(Classname var)`，例如：
- en: '[PRE35]'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A [Haskell 2010 instance declaration](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-770004.3.2)
    has the form:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 [Haskell 2010 实例声明](http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-770004.3.2)
    的形式为：
- en: '[PRE36]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note `v1` ... `vk` are all variables and all distinct, ruling out, e.g., `instance
    C (a,a)` or `instance C (Int a)` or `instance [[a]]`
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意 `v1` ... `vk` 都是变量且都不同，排除了，例如，`instance C (a,a)` 或 `instance C (Int a)` 或
    `instance [[a]]`
- en: '[`MultiParamTypeClasses`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#id559142)
    extension'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`MultiParamTypeClasses`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#id559142)
    扩展'
- en: 'Enables type classes with multiple parameters, E.g.:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用具有多个参数的类型类，例如：
- en: '[PRE37]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Extension itself is relatively safe, but encourages other extensions
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展本身相对安全，但鼓励其他扩展
- en: E.g., each method's type must use every type parameter
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，每个方法的类型必须使用每个类型参数
- en: '[PRE38]'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All types (argument and return) must be fully determined
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型（参数和返回）必须完全确定
- en: '[PRE39]'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And the usual instance restrictions still apply
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且通常的实例限制仍然适用
- en: '[PRE40]'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`[Char]`--i.e., `([] Char)`--is not a valid instance parameter, would have
    to be `([] a)`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Char]`--即 `([] Char)`--不是一个有效的实例参数，必须是 `([] a)`'
- en: '[`FlexibleInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls)
    extension'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`FlexibleInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls)
    扩展'
- en: Allows more specific type paremeters (relatively safe extension)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许更具体的类型参数（相对安全的扩展）。
- en: 'E.g., now we can say:'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，现在我们可以说：
- en: '[PRE41]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And we can make all types convert to themselves:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使所有类型转换为它们自己：
- en: '[PRE42]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Oops, two instances apply; GHC doesn't know which to choose
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糟糕，两个实例都适用； GHC 不知道选择哪个
- en: '[`OverlappingInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap)
    extension'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`OverlappingInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap)
    扩展'
- en: This extension is used, but also widely frowned upon
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个扩展被使用，但也被广泛抨击
- en: Only need this extension if overlapping instances actually used
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在实际使用重叠实例时才需要此扩展。
- en: Enable extension where instances defined, not where used
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义实例的地方启用扩展，而不是在使用的地方启用
- en: Compiler picks the most specific matching instance. *I*[1] is more specific
    than *I*[2] when *I*[1] can be created by substituting for the variables of *I*[2]
    and not vice versa
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 *I*[1] 可以通过替换 *I*[2] 的变量而创建，并且反之则不成立时，编译器会选择最具体的匹配实例。 *I*[1] 比 *I*[2] 更具体。
- en: Contexts (part before `=>`) not considered when selecting instances
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文（在 `=>` 前面的部分）在选择实例时不予考虑。
- en: 'Example: Do something like `Show` for `String` vs. `[a]`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：像 `String` vs. `[a]` 的 `Show` 一样做些什么
- en: '[PRE44]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So does enabling `OverlappingInstances` fix `Convert`?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，启用 `OverlappingInstances` 是否修复了 `Convert`？
- en: Most specific instances
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最具体的实例
- en: What is the most specific instance?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最具体的实例是什么？
- en: '[PRE45]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Neither instance is most specific!
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有实例是最具体的！
- en: We have to add a *third* instance to break the tie--one that can be created
    by substituting for variables in either of the other two overlapping instances
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须添加一个 *第三* 实例来打破这种关系--一个可以通过替换其他两个重叠实例中的变量而创建的实例
- en: '[PRE47]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A case against `OverlappingInstances`
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反对 `OverlappingInstances` 的一个案例
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Aside: How `Show` actually works'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旁注：`Show` 实际上是如何工作的
- en: 'Add an extra helper method, `showList`, with a default definition:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个额外的帮助方法，`showList`，并附带一个默认定义：
- en: '[PRE51]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Show` instance for `Char` overrides default `showList`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Char` 的 `Show` 实例覆盖了默认的 `showList`。'
- en: But had to plan all this out from the start
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是必须从一开始就计划好所有这些
- en: Want an easy way to special-case trees or other data structures besides lists?
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要一种简单的方式来为树或其他数据结构特别处理，而不仅仅是列表？
- en: Then you are stuck using overlapping instances
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后您将被迫使用重叠实例。
- en: '[`FlexibleContexts`](http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#flexible-contexts)
    extension'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`FlexibleContexts`](http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#flexible-contexts)
    扩展'
- en: '`MultiParamTypeClasses` leads to inexpressible types'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiParamTypeClasses` 导致无法表达的类型。'
- en: '[PRE52]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'What is the type of function `toInt`? Would like to write:'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数 `toInt` 的类型是什么？想要写：
- en: '[PRE53]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: But `(Convert a Int) =>` is an illegal context, as `Int` not a type variable
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是`(Convert a Int) =>`是一个非法的上下文，因为`Int`不是一个类型变量
- en: '`FlexibleContexts` extension makes the above type legal to write'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlexibleContexts` 扩展使上述类型合法可写。'
- en: Is a relatively safe extension to use
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是一个相对安全的扩展来使用
- en: Still a couple of restrictions
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然有一些限制。
- en: Each type variable in context must be "reachable" from a type variable in type
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文中的每个类型变量必须从类型中的一个类型变量可达。
- en: (Reachable = explicitly used, or in another constraint with a reachable variable.)
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (可达 = 明确使用，或者在另一个具有可达变量的约束中。)
- en: '[PRE54]'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Every constraint must have a type variable
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个约束必须有一个类型变量。
- en: '[PRE55]'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Monad classes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子类
- en: It's neat that `liftIO` works from so many monads
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`liftIO` 从如此多的单子中工作真是太棒了'
- en: Why not do something similar for `StateT`? Make `get`/`set` methods
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么不为 `StateT` 做类似的事情？让 `get`/`set` 方法
- en: '[PRE56]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now for each other `MonadTrans`, pass requests down
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在对于每个其他的 `MonadTrans`，将请求传递下去
- en: 'This is just like `liftIO`. E.g., for `ReaderT`:'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就像 `liftIO` 一样。例如，对于 `ReaderT`：
- en: '[PRE57]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Problem: we''ve defeated type inference'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题：我们破坏了类型推断。
- en: Remember `xplusplus`?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还记得 `xplusplus` 吗？
- en: '[PRE58]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The compiler knows we are in `StateT Int IO` monad
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器知道我们处于`StateT Int IO`单子中。
- en: So can infer that the type of `get` is `Num s => StateT Int IO s`
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此可以推断`get`的类型为`Num s => StateT Int IO s`。
- en: But need to know `s` in order to select an instance of `MonadState`!
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是需要知道`s`才能选择`MonadState`的一个实例！
- en: For all compiler knows, might be other matching instances, e.g.,
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于编译器来说，可能有其他匹配的实例，例如，
- en: '[PRE59]'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since compiler can''t infer return type of `get`, must type it manually:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于编译器无法推断`get`的返回类型，必须手动输入类型：
- en: '[PRE60]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Yuck! Lack of type inference gets old fast!
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呸！缺乏类型推断真的很烦人！
- en: '[`FunctionalDependencies`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies)
    extension'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`FunctionalDependencies`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies)
    扩展'
- en: Widely used & frowned upon (not as bad as `OverlappingInstances`)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被广泛使用并且被 frowned upon（没有 `OverlappingInstances` 那么糟糕）
- en: Also referred to as "fundeps"
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也被称为“fundeps”
- en: Lets a class declare some parameters to be functions of others
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许类声明某些参数是其他参数的函数
- en: '[PRE61]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The best way to think of this is in terms of *instance selection*
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好的理解方式是以*实例选择*的方式来思考
- en: '"`| m -> s`" says can select an instance based on `m` without considering `s`,
    because **`s` is a function of `m`**'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"`| m -> s`" 表示可以根据 `m` 而不考虑 `s` 来选择一个实例，因为 **`s` 是 `m` 的函数**'
- en: Once you've selected the instance, you can use `s` for type inference
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你选择了实例，你就可以使用 `s` 进行类型推断
- en: Disallows conflicting instances (even w. `OverlappingInstances`)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止冲突的实例（即使使用了 `OverlappingInstances`）
- en: Also allows arbitrary computation at the type level [[Hallgren]](http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=D19C7E3BD1B5C1FC24035542B1494ED9?doi=10.1.1.22.7806&rep=rep1&type=pdf)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还允许在类型层面进行任意计算[[Hallgren]](http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=D19C7E3BD1B5C1FC24035542B1494ED9?doi=10.1.1.22.7806&rep=rep1&type=pdf)
- en: But language committee wants compilation to be decidable and deterministic
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但语言委员会希望编译是可决定的和确定的
- en: So need to add some restrictions
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以需要添加一些限制
- en: '[Sufficient conditions of decidable instances](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules)'
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[可决定实例的充分条件](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules)'
- en: 'Anatomy of an instance: `instance` [*context* `=>`] *head* [`where` *body*]'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例的解剖：`instance` [*context* `=>`] *head* [`where` *body*]
- en: '*context* consists of zero or more comma-separated *assertions*'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*context* 包括零个或多个逗号分隔的*断言*'
- en: 'The Paterson Conditions: for each assertion in the context'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Paterson 条件：对于上下文中的每个断言
- en: No type variable has more occurrences in the assertion than in the head
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有类型变量在断言中出现的次数超过头部中出现的次数
- en: '[PRE62]'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The assertion has fewer constructors and variables than the head
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言的构造和变量比头部少
- en: '[PRE63]'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The Coverage Condition: For each fundep *left* `->` *right*, the types in *right*
    cannot have type variables not mentioned in *left*'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖条件：对于每个 fundep *left* `->` *right*，*right* 中的类型不能有 *left* 中未提及的类型变量
- en: '[PRE64]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Undecidable vs. exponential -- who cares?
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可决定 vs. 指数级 -- 谁在乎？
- en: 'Editorial: maybe decidability of language is overrated'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编者注：语言的可决定性可能被高估了
- en: Computers aren't Turing machines with infinite tapes, after all
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毕竟计算机并不是具有无限带子的图灵机
- en: This legal, decidable program will crash your Haskell compiler
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个合法的、可决定的程序会使你的 Haskell 编译器崩溃
- en: '[PRE65]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: While plenty of not provably decidable programs happily compile
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然有很多不能被证明可决定的程序可以编译成功
- en: The conditions of the last slide are *sufficient*, not *necessary*
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一张幻灯片的条件是*充分的*，而不是*必要的*
- en: Might have other ways of knowing your program can compile
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能还有其他知道你的程序可以编译的方法
- en: Or maybe figure it out from trial and error?
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者也许通过试错来弄清楚？
- en: '[`UndecidableInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances)
    extension'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`UndecidableInstances`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances)
    扩展'
- en: Lifts the Paterson and Coverage conditions
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了 Paterson 和 Coverage 条件
- en: Also enables `FlexibleContexts` when enabled
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用时还可以启用`FlexibleContexts`
- en: Instead, imposes a maximum recursion depth
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，施加了最大递归深度
- en: Default maximum depth is 20
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的最大深度是 20
- en: 'Can increase with `-fcontext-stack=`*n* option, e.g.:'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `-fcontext-stack=`*n* 选项来增加，例如：
- en: '[PRE66]'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: A bit reminiscent of C++ templates
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有点类似于 C++ 模板
- en: gcc has a `-ftemplate-depth=` option
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcc 有一个 `-ftemplate-depth=` 选项
- en: Note C++11 raises minimum depth from 17 to 1024
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意 C++11 将最小深度从 17 提高到 1024
- en: Similarly, people have talked of increasing GHC's default context-stack
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样地，人们已经谈论过增加 GHC 的默认上下文堆栈
- en: '`MonadIO` revisited'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`MonadIO` 重新审视'
- en: Recall definition of `MonadIO`
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下 `MonadIO` 的定义
- en: '[PRE67]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Currently must define an instance for every transformer
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前必须为每个转换器定义一个实例
- en: '[PRE68]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: With `UndecidableInstances`, one instance can cover all transformers!
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UndecidableInstances`，一个实例可以覆盖所有的转换器！
- en: '[PRE69]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Summary of extensions
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展的摘要
- en: We've seen 6 typeclass-related extensions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经看到了 6 个与类型类相关的扩展
- en: '[PRE70]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Not all of these are looked upon kindly by the community
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并不是所有这些都受到社区的好评
- en: But if you enable all six, can be very powerful
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但如果你启用了所有六个，它可以非常强大
- en: Remainder of lecture looks at what you can do with all 6 enabled
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的讲座将探讨启用所有 6 个扩展可以做什么
- en: Much inspired by [[Hlist]](http://homepages.cwi.nl/~ralf/HList/paper.pdf) and
    [[OOHaskell]](http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf)
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受[Hlist](http://homepages.cwi.nl/~ralf/HList/paper.pdf)和[OOHaskell](http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf)的启发
- en: 'Warm-up: Type-level booleans'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热身：类型级别的布尔值
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note how fundep in `HNot b nb` computes negation of `b` **at the type level**
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意`HNot b nb`中的功能依赖如何计算`b`的否定**在类型级别**
- en: Haven't used `OverlappingInstances` yet, let's start...
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还没有使用`OverlappingInstances`，让我们开始吧...
- en: Computing over types
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对类型进行计算
- en: 'Can we compute whether two types are equal? First attempt:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能计算两个类型是否相等吗？第一次尝试：
- en: '[PRE73]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Problem: `TypeEq a a HTrue` not more specific than `TypeEq a b HFalse`'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题：`TypeEq a a HTrue`不比`TypeEq a b HFalse`更具体
- en: '... but `TypeEq a a HTrue` *is* more specific than `TypeEq a b c`'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '... 但`TypeEq a a HTrue`比`TypeEq a b c`更具体'
- en: Recall that context is never consulted for instance selection
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，实例选择从不考虑上下文
- en: Only afterwards to reject failed assertions or infer types from fundeps
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在拒绝失败断言或从功能依赖中推断类型之后
- en: 'Solution: compute `c` after instance selection using another fundep'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案：在实例选择后使用另一个功能依赖计算`c`
- en: '[PRE74]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The utility of `TypeEq`
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TypeEq`的实用性'
- en: 'Editorial: `TypeEq` is kind of the holy grail of fundeps'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论：`TypeEq`有点像功能依赖的圣杯
- en: If you can implement `TypeEq`, you can program recursively at type level by
    distinguishing base and recursive cases!
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以实现`TypeEq`，你可以通过区分基本情况和递归情况在类型级别进行递归编程！
- en: But relies deeply on `OverlappingInstances`...
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但深度依赖于`OverlappingInstances`...
- en: 'Example: Let''s do for `MonadState` what we did for `MonadIO`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：让我们为`MonadState`做与`MonadIO`相同的事情
- en: '[PRE75]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`MonadIO` was easier because type `IO` can''t match parameter `(t m)`'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonadIO`更容易，因为类型`IO`不能匹配参数`(t m)`'
- en: Unfortunately, `StateT s m` matches *both* of above instance heads
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，`StateT s m`匹配*上述两个*实例头
- en: So need `OverlappingInstances` to select first instance for `StateT s m`
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此需要`OverlappingInstances`来选择`StateT s m`的第一个实例
- en: Heterogeneous lists
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异构列表
- en: 'Last extension: [`TypeOperators`](http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons)
    allows infix types starting with "`:`"'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个扩展：[`TypeOperators`](http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons)允许以“`:`”开头的中缀类型
- en: '[PRE76]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Let's use an infix constructor to define a heterogeneous list
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中缀构造函数来定义异构列表
- en: '[PRE77]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Operations on heterogeneous lists
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异构列表上的操作
- en: Notice our list consisted of pairs
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意我们的列表由成对组成
- en: '[PRE79]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: View first element as a key or tag, second as a value--How to look up value?
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第一个元素视为键或标签，第二个元素视为值--如何查找值？
- en: '[PRE80]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Once again, note the importance of `OverlappingInstances`
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次注意`OverlappingInstances`的重要性
- en: Needed to break recursion when type of lookup tag matches head of list
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当查找标签的类型与列表头匹配时需要打破递归
- en: Can use to implement all sorts of other features (concatenation, etc.)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用来实现各种其他功能（连接等）
- en: Object-oriented programming
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Heterogeneous can implement object-oriented programming!
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异构可以实现面向对象编程！
- en: '[PRE82]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: But why `mfix`?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但为什么要用`mfix`？
- en: '"Tying the recursive knot"'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"打结递归"'
- en: '`mfix` allows you to override methods with inheritance'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mfix`允许你通过继承覆盖方法'
- en: Example, create a "const val" that ignores `SetVal` messages
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，创建一个忽略`SetVal`消息的“const val”
- en: '[PRE83]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`mkVal`''s call to `SetVal` was properly overridden by `mkConstVal`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkVal`对`SetVal`的调用被`mkConstVal`正确地覆盖了'
