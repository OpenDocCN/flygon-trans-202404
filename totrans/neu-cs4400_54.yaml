- en: Recursive EnvironmentsTuesday, February 21st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PLAI §11.5](plai.pdf#section.11.5 "Procedural Representation of Recursive
    Environments")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What we really need for recursion, is a special kind of an environment, one
    that can refer to itself. So instead of doing (note: `call`s removed for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: which does not work for the usual reasons, we want to use some
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: that will do the necessary magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to achieve this is using the Y combinator as we have seen — a kind
    of a “constructor” for recursive functions. We can do that in a similar way to
    the `rewrite` rule that we have seen in Schlac — translate the above expression
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'or even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will see how it can be used in *our* code to implement a recursive environment.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at what `with` does in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'then we can say that to evaluate this expression, we evaluate the body expression
    in an extended environment that contains `fact`, even if a bogus one that is good
    for `0` only — the new environment is created with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: so we can take this whole thing as an operation over `env`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the first-level fact. But `fact` itself is still undefined in
    `env`, so it cannot call itself. We can try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'but that still doesn’t work, and it will never work no matter how far we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What we really want is infinity: a place where add-fact works and the result
    is the same as what we’ve started with — we want to create a “magical” environment
    that makes this possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'which basically gives us the illusion of being at the infinity point. This
    magic-env thing is exactly the *fixed-point* of the `add-fact` operation. We can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'and following the main property of the Y combinator, we know that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What does all this mean? It means that if we have a fixed-point operator at
    the level of the implementation of our environments, then we can use it to implement
    a recursive binder. In our case, this means that a fixpoint in Racket can be used
    to implement a recursive language. But we have that — Racket does have recursive
    functions, so we should be able to use that to implement our recursive binder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways that make it possible to write recursive functions in Racket.
    One is to define a function, and use its name to do a recursive call — using the
    Racket formal rules, we can see that we said that we mark that we now *know* that
    a variable is bound to a value. This is essentially a side-effect — we modify
    what we know, which corresponds to modifying the global environment. The second
    way is a new form: `letrec`. This form is similar to `let`, except that the scope
    that is established includes the named expressions — it is exactly what we want
    `rec` to do. A third way is using recursive local definitions, but that is equivalent
    to using `letrec`, more on this soon.'
  prefs: []
  type: TYPE_NORMAL
