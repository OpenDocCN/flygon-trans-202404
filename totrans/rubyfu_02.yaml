- en: Module 0x2 | System Kung Fu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块0x2 | 系统功夫
- en: Module 0x2 | System Kung Fu
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块0x2 | 系统功夫
- en: Packaging
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包
- en: Many questions about building a standalone application that doesn't require
    Ruby to be pre-installed on the system. Of-course, due attacking machine you cant
    grantee that ruby is installed on the target system. So here we will demonstrate
    some ways to do that.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 很多关于构建一个独立应用程序的问题，不需要在系统上预先安装Ruby。当然，由于攻击机器，你无法保证目标系统上是否安装了Ruby。因此，在这里我们将演示一些方法。
- en: One-Click Ruby Application(OCRA) Builder
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一键Ruby应用程序(OCRA)构建器
- en: OCRA (One-Click Ruby Application) builds Windows executables from Ruby source
    code. The executable is a self-extracting, self-running executable that contains
    the Ruby interpreter, your source code and any additionally needed ruby libraries
    or DLL.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: OCRA（一键Ruby应用程序）从Ruby源代���构建Windows可执行文件。该可执行文件是一个自解压、自运行的可执行文件，包含了Ruby解释器、你的源代码以及任何额外需要的Ruby库或DLL。
- en: '**It''s Windows support only**, not really ;)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅支持Windows**，当然不是 ;)'
- en: Features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Features
- en: LZMA Compression (optional, default on)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: LZMA压缩（可选，默认开启）
- en: Ruby 1.8.7, 1.9.3, 2.0.0 and 2.1.5 support
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 1.8.7, 1.9.3, 2.0.0和2.1.5支持
- en: Both windowed/console mode supported
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持窗口/控制台模式
- en: Includes gems based on usage, or from a Bundler Gemfile
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据使用情况或从Bundler Gemfile中包含gems
- en: To install OCRA
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装OCRA
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So all what to need is to have your application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有你需要的就是你的应用程序。
- en: Suppose we have the following script, a reverse shell of course ;)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下脚本，当然是一个反向shell ;)
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: from our Windows Attacker machine cmd.exe
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的Windows攻击机器cmd.exe
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Results
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the same directory, you'll find an exe file `rshell.exe`. Send it on the
    windows victim machine which doesn't have ruby installed and run it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录中，你会找到一个名为`rshell.exe`的可执行文件。将其发送到没有安装Ruby的Windows受害机器上并运行。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: from our attacking machine we already listening on 9911
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的攻击机器已经在9911端口监听
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](packaging__ocra1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](packaging__ocra1.png)'
- en: Traveling-ruby
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Traveling-ruby
- en: 'From official site^([1](#fn_1)) "*Traveling Ruby is a project which supplies
    self-contained, "portable" Ruby binaries: Ruby binaries that can run on any Linux
    distribution and any OS X machine. It also has Windows support (with some caveats).
    This allows Ruby app developers to bundle these binaries with their Ruby app,
    so that they can distribute a single package to end users, without needing end
    users to first install Ruby or gems.*"'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方网站^([1](#fn_1)) "*Traveling Ruby是一个项目，提供自包含的“便携”Ruby二进制文件：可以在任何Linux发行版和任何OS
    X机器上运行的Ruby二进制文件。它还支持Windows（有一些注意事项）。这使得Ruby应用程序开发人员可以将这些二进制文件与他们的Ruby应用程序捆绑在一起，这样他们可以向最终用户分发一个单一的软件包，而无需让最终用户首先安装Ruby或gems。*"
- en: 'Note: The following script has been taken from the official docs.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：以下脚本摘自官方文档。
- en: Preparation
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 准备工作
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create your application -in our case, reverse shell- in "rshell" folder
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的应用程序 -在我们的情况下，反向shell- 在“rshell”文件夹中
- en: '**rshell.rb**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**rshell.rb**'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Test it
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试它
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating package directories
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建打包目录
- en: The next step is to prepare packages for all the target platforms, by creating
    a directory each platform, and by copying your app into each directory. (Assuming
    that your application could differ from OS to another)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为所有目标平台准备软件包，通过为每个平台创建一个目录，并将你的应用程序复制到每个目录中。 （假设你的应用程序在不同的操作系统上可能有所不同）
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, create a `packaging` directory and download Traveling Ruby binaries for
    each platform into that directory. Then extract these binaries into each packaging
    directory. You can find a list of binaries at the Traveling Ruby Amazon S3 bucket.
    For faster download times, use the CloudFront domain "[http://d6r77u77i8pq3.cloudfront.net](http://d6r77u77i8pq3.cloudfront.net)".
    In this tutorial we're extracting version 20141215-2.1.5.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`packaging`目录，并将Traveling Ruby二进制文件下载到该目录中。然后将这些二进制文件解压缩到每个打包目录中。你可以在Traveling
    Ruby的Amazon S3存储桶中找到二进制文件列表。为了更快的下载速度，请使用CloudFront域名"[http://d6r77u77i8pq3.cloudfront.net](http://d6r77u77i8pq3.cloudfront.net)"。在本教程中，我们提取的是版本20141215-2.1.5。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, each package directory will have Ruby binaries included. It looks like
    this: Your directory structure will now look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个打包目录将包含Ruby二进制文件。看起来像这样：你的目录结构现在看起来像这样：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Quick sanity testing
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速健全性测试
- en: 'Let''s do a basic sanity test by running your app with a bundled Ruby interpreter.
    Suppose that you are developing on OS X. Run this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用捆绑的Ruby解释器运行你的应用程序进行基本的健全性测试。假设你在OS X上开发。运行以下命令：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating a wrapper script
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个包装脚本
- en: Now that you've verified that the bundled Ruby interpreter works, you'll want
    create a *wrapper script*. After all, you don't want your users to run `/path-to-your-app/lib/ruby/bin/ruby
    /path-to-your-app/lib/app/rshell.rb`. You want them to run /path-to-your-app/rshell.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经验证了捆绑的 Ruby 解释器的工作，您将想要创建一个 *包装脚本*。毕竟，您不希望用户运行 `/path-to-your-app/lib/ruby/bin/ruby
    /path-to-your-app/lib/app/rshell.rb`。您希望他们运行 /path-to-your-app/rshell。
- en: 'Here''s what a wrapper script could look like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是包装脚本的示例：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save this file as `packaging/wrapper.sh` in your project''s root directory.
    Then you can copy it to each of your package directories and name it `rshell`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `packaging/wrapper.sh` 在您项目的根目录中。然后您可以将其复制到每个软件包目录并命名为 `rshell`：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finalizing packages
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完成软件包
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Congratulations, you have created packages using Traveling Ruby!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经使用 Traveling Ruby 创建了软件包！
- en: 'An x86 Linux user could now use your app like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 x86 Linux 用户现在可以这样使用您的应用程序：
- en: The user downloads rshell-1.0.0-linux-x86.tar.gz.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户下载了 rshell-1.0.0-linux-x86.tar.gz。
- en: The user extracts this file.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户提取此文件。
- en: 'The user runs your app:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户运行您的应用程序：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Automating the process
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自动化流程
- en: 'Going through all of the above steps on every release is a hassle, so you should
    automate the packaging process, for example by using Rake. Here''s how the Rakefile
    could look like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次发布时执行上述所有步骤都很麻烦，因此您应该自动化打包过程，例如使用 Rake。以下是 Rakefile 的示例：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can then create all 3 packages by running:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来创建所有 3 个软件包：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also create a package for a specific platform by running one of:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过运行以下命令之一为特定平台创建软件包：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also just create package directories, without creating the .tar.gz
    files, by passing DIR_ONLY=1:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过传递 DIR_ONLY=1 来仅创建软件包目录，而不创建 .tar.gz 文件：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On Victim Machine
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在受害者机器上
- en: You now have three files which you can distribute to end users.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有三个文件，可以分发给最终用户。
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Suppose the end user is on Linux x86_64\. S/he uses your app by downloading
    rshell-1.0.0-linux-x86_64.tar.gz, extracting it and running it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设最终用户使用的是 Linux x86_64。他/她通过下载 rshell-1.0.0-linux-x86_64.tar.gz，解压缩并运行它来使用您的应用程序：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: mruby
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: mruby
- en: '**mruby CLI**^([2](#fn_2)) A utility for setting up a CLI with mruby that compiles
    binaries to Linux, OS X, and Windows.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**mruby CLI**^([2](#fn_2)) 用于设置具有将二进制文件编译到 Linux、OS X 和 Windows 的 mruby 的 CLI
    的实用程序。'
- en: Prerequisites
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 先决条件
- en: mruby-cli
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mruby-cli
- en: Docker
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Developer introduction
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 开发者介绍
- en: '[https://www.youtube.com/watch?v=OvuZ8R4Y9xA](https://www.youtube.com/watch?v=OvuZ8R4Y9xA)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=OvuZ8R4Y9xA](https://www.youtube.com/watch?v=OvuZ8R4Y9xA)'
- en: Close Source code
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭源代码
- en: Sometimes we don't want to disclose our source code for whatever reason, but
    we still want to share our applications either commercially or for free. Here
    a commercial solution for that purpose, RubyEncoder.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时出于某种原因，我们不想透露我们的源代码，但我们仍然希望商业或免费分享我们的应用程序。这里有一个商业解决方案，RubyEncoder。
- en: '**RubyEncoder**^([3](#fn_3)) protects Ruby scripts by compiling Ruby source
    code into a bytecode format and this is followed by encryption. This protects
    your scripts from reverse engineering. Ruby scripts protected with RubyEncoder
    can be executed but cannot be used to extract Ruby source code as there is no
    source code remaining within the protected script in any form.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**RubyEncoder**^([3](#fn_3)) 通过将 Ruby 源代码编译成字节码格式并进行加密来保护 Ruby 脚本。这样可以防止反向工程。使用
    RubyEncoder 保护的 Ruby 脚本可以执行，但无法用于提取 Ruby 源代码，因为受保护的脚本中没有任何形式的源代码。'
- en: '* * *'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹. Traveling-ruby: [Official website](http://phusion.github.io/traveling-ruby/)
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '¹. Traveling-ruby: [官方网站](http://phusion.github.io/traveling-ruby/) [↩](#reffn_1
    "跳回文本中的脚注 [1]")'
- en: '². mruby CLI: [Official website](https://github.com/hone/mruby-cli) [↩](#reffn_2
    "Jump back to footnote [2] in the text.")'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '². mruby CLI: [官方网站](https://github.com/hone/mruby-cli) [↩](#reffn_2 "跳回文本中的脚注
    [2]")'
- en: '³. RubyEncoder: [Official website](http://rubyencoder.com) [↩](#reffn_3 "Jump
    back to footnote [3] in the text.")'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '³. RubyEncoder: [官方网站](http://rubyencoder.com) [↩](#reffn_3 "跳回文本中的脚注 [3]")'
- en: File manipulation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: File manipulation
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: Simple Steganography
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单隐写术
- en: Simple script to hide a file `file.pdf` in an image `image.png` then write it
    into `steg.png` image which is originally the `image.png`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 简单脚本，将文件 `file.pdf` 隐藏在图像 `image.png` 中，然后将其写入原始为 `image.png` 的 `steg.png` 图像中
- en: Then, it recovers the `file.pdf` from `steg.png` to `hola.pdf`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从 `steg.png` 中恢复 `file.pdf` 到 `hola.pdf`。
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Note:** This has nothing to do with bypassing AV.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 这与绕过 AV 无关。'
- en: Simple Binary file to Hex
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的二进制文件转换为十六进制
- en: '**hex-simple.rb**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**hex-simple.rb**'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Or in one command line
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在一个命令行中
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: return
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note if want to change the hex prefix from \x to anything, just change `'\x%x'`
    to whatever you want, or remove it!.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，如果想要将十六进制前缀从 \x 更改为其他内容，只需将 `'\x%x'` 更改为你想要的内容，或者将其删除！
- en: Simple Hexdump
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的十六进制转储
- en: '**hexdump.rb**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**hexdump.rb**'
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: return
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finding weak file permissions
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找弱文件权限
- en: One of the important task to do post exploitation is find weak executable file
    permissions which might be executed buy root/administrator user trying to elevate
    our privileges on the system. At the same time, our scripts must be applicable
    for all systems
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 后��透的一个重要任务是查找弱可执行文件权限，这些权限可能由 root/administrator 用户执行，试图提升我们在系统上的权限。同时，我们的脚本必须适用于所有系统
- en: '**find777.rb**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**find777.rb**'
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can search for read, write, execute permissions, so your iteration block
    will be like
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以搜索读取、写入、执行权限，因此你的迭代块将如下所示
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Parsing HTML, XML, JSON
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 HTML、XML、JSON
- en: Parsing HTML, XML, JSON
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 HTML、XML、JSON
- en: Generally speaking the best and easiest way for parsing HTML and XML is using
    **Nokogiri** library
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，解析 HTML 和 XML 的最佳且最简单的方法是使用**Nokogiri**库
- en: To install Nokogiri
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Nokogiri
- en: '[PRE33]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: HTML
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML
- en: Here we'll use nokogiri to list our contents list from `http://rubyfu.net/content/`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们将使用 nokogiri 列出我们从 `http://rubyfu.net/content/` 中的内容列表
- en: Using CSS selectors
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CSS 选择器
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Returns
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: XML
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML
- en: There are 2 ways we'd like to show here, the standard library `rexml and nokogiri
    external library`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要展示这里有 2 种方法，标准库 `rexml 和 nokogiri 外部库`
- en: We've the following XML file
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下 XML 文件
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: REXML
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REXML
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Nokogiri
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nokogiri
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Slop
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Slop
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: JSON
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: Assume you have a small vulnerability database in a json file like follows
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个小的漏洞数据库，格式如下的 json 文件
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To parse it
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解析它
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Returns a hash
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个哈希
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now you can retrieve and data as you do with hash
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以像处理哈希一样检索和数据
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you want to add to this database, just create a hash with the same struction.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要添加到此数据库，只需创建一个具有相同结构的哈希。
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can convert it to json just by using `.to_json` method
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `.to_json` 方法将其转换为 json
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Cryptography
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: Cryptography
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: Generating Hashes
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成哈希
- en: MD5 hash
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MD5 哈希
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: SHA1 hash
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SHA1 哈希
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: SHA2 hash
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SHA2 哈希
- en: In SHA2 you have 2 ways to do it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SHA2 中，你有两种方法可以做到。
- en: '**Way #1:** By creating a new SHA2 hash object with a given bit length.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 #1：** 通过创建一个具有给定位数的新 SHA2 哈希对象。'
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Way #2:** By Using the class directly'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 #2：** 通过直接使用类'
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Bonus: Generate Linux-like Shadow password**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励：生成类似 Linux 的 Shadow 密码**'
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Windows LM Password hash
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows LM 密码哈希
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[Source | RubyNTLM](https://github.com/wimm/rubyntlm/blob/master/lib/net/ntlm.rb)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[来源 | RubyNTLM](https://github.com/wimm/rubyntlm/blob/master/lib/net/ntlm.rb)'
- en: Windows NTLMv1 Password hash
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows NTLMv1 密码哈希
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Windows NTLMv2 Password hash
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows NTLMv2 密码哈希
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: MySQL Password hash
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL 密码哈希
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: PostgreSQL Password hash
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL 密码哈希
- en: PostgreSQL hashes combined password and username then adds **md5** in front
    of the hash
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 哈希将密码和用户名组合，然后在哈希前添加**md5**
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Symmetric Encryptions
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称加密
- en: To list all supported algorithms
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有支持的算法
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To unserdatand the cipher naming (eg. `AES-128-CBC`), it devided to 3 parts
    seperated by hyphen `<Name>-<Key_length>-<Mode>`
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解密码命名（例如 `AES-128-CBC`），它被分为 3 部分，由连字符分隔 `<名称>-<密钥长度>-<模式>`
- en: Symmetric encrption algorithms modes need 3 import data in order to work
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密算法模式需要 3 个重要数据才能工作
- en: Key (password)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密钥（密码）
- en: Initial Vector (iv)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始向量（iv）
- en: Data to encrypt (plain text)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要加密的数据（明文）
- en: AES encryption
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AES 加密
- en: Encrypt
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加密
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Dencrypt
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解密
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Resources**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源**'
- en: '[OpenSSL::Cipher docs](https://ruby-doc.org/stdlib-2.3.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenSSL::Cipher 文档](https://ruby-doc.org/stdlib-2.3.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html)'
- en: '[(Symmetric) Encryption With Ruby (and Rails)](http://stuff-things.net/2015/02/12/symmetric-encryption-with-ruby-and-rails/)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[(对称) 使用 Ruby（和 Rails）进行加密](http://stuff-things.net/2015/02/12/symmetric-encryption-with-ruby-and-rails/)'
- en: Caesar cipher
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凯撒密码
- en: '**Caesar cipher** is one of the oldest known encryption methods. It is very
    simple - it is just shifting an alphabet. Transformation is termed ROTN, where
    N is shift value and ROT is from "ROTATE" because this is a cyclic shift.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**凯撒密码**是已知的最古老的加密方法之一。它非常简单 - 只是移动字母表。转换被称为 ROTN，其中 N 是移位值，ROT 来自于“旋转”，因为这是一个循环移位。'
- en: In Ruby, array rotation is mutter of using rotate() method. So all what we need
    is to have array of all alphabets rotate it and map it with the original given
    string.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，数组旋转是使用 rotate() 方法的事情。所以我们所需要的就是有一个包含所有字母表的数组，将其旋转并将其与原始给定的字符串进行映射。
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: result
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Sources:**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：**'
- en: '[http://www.blackbytes.info/2015/03/caesar-cipher-in-ruby/](http://www.blackbytes.info/2015/03/caesar-cipher-in-ruby/)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.blackbytes.info/2015/03/caesar-cipher-in-ruby/](http://www.blackbytes.info/2015/03/caesar-cipher-in-ruby/)'
- en: '[https://gist.github.com/matugm/db363c7131e6af27716c](https://gist.github.com/matugm/db363c7131e6af27716c)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/matugm/db363c7131e6af27716c](https://gist.github.com/matugm/db363c7131e6af27716c)'
- en: '[https://planetcalc.com/1434/](https://planetcalc.com/1434/)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://planetcalc.com/1434/](https://planetcalc.com/1434/)'
- en: Enigma script
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恩格玛机脚本
- en: '| ![](Cryptography__wiringdiagram.png) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| ![](Cryptography__wiringdiagram.png) |'
- en: '| --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Figure 1.** Enigma machine diagram |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **图 1.** 恩格玛机器图解 |'
- en: '[PRE61]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[Source | Understanding the Enigma machine with 30 lines of Ruby](http://red-badger.com/blog/2015/02/23/understanding-the-enigma-machine-with-30-lines-of-ruby-star-of-the-2014-film-the-imitation-game)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[来源 | 用 30 行 Ruby 代码理解恩格玛机器](http://red-badger.com/blog/2015/02/23/understanding-the-enigma-machine-with-30-lines-of-ruby-star-of-the-2014-film-the-imitation-game)'
- en: '* * *'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Command Execution
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令执行
- en: Command Execution
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令执行
- en: 'Some things to think about when choosing between these ways are:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择这些方式之间需要考虑的一些事项是：
- en: Are you going to interact with none interactive shell, like `ncat` ?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否要与非交互式 shell 交互，比如`ncat`？
- en: Do you just want stdout or do you need stderr as well? or even separated out?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你只想要标准输出还是需要标准错误输出？或者分开处理？
- en: How big is your output? Do you want to hold the entire result in memory?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的输出有多大？你想要将整个结果保存在内存中吗？
- en: Do you want to read some of your output while the subprocess is still running?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想在子进程仍在运行时读取一些输出吗？
- en: Do you need result codes?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要结果代码吗？
- en: Do you need a ruby object that represents the process and lets you kill it on
    demand?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一个代表进程并允许你按需终止它的 Ruby 对象吗？
- en: The following ways are applicable on all operating systems.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法适用于所有操作系统。
- en: Kernel#exec
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kernel#exec
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Kernel#system
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kernel#system
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Dealing with `ncat` session?
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理 `ncat` 会话？
- en: If you ever wondered how to do deal with interactive command like `passwd` due
    `ncat` session in Ruby?. You must propuly was using `python -c 'import pty; pty.spawn("/bin/sh")'`
    Well, in Ruby it's really easy using `exec` or `system`. The main trick is to
    forward STDERR to STDOUT so you can see system errors.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾想过如何处理 Ruby 中交互式命令（比如 `passwd`）由于 `ncat` 会话？你可能之前使用的是 `python -c 'import
    pty; pty.spawn("/bin/sh")'`。嗯，在 Ruby 中使用 `exec` 或 `system` 真的很容易。主要的技巧是将 STDERR
    转发到 STDOUT，这样你就可以看到系统错误。
- en: '**exec**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**exec**'
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**system**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**system**'
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Kernel#` (backticks)
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kernel#` (反引号)
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: IO#popen
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IO#popen
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Open3#popen3
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Open3#popen3
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Process#spawn
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Process#spawn
- en: Kernel.spawn executes the given command in a subshell. It returns immediately
    with the process id.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Kernel.spawn 在子 shell 中执行给定的命令。它立即返回进程 ID。
- en: '[PRE69]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '%x"", %x[], %x{}, %x$''''$'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '%x"", %x[], %x{}, %x$''''$'
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Rake#sh
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rake#sh
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Extra
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外
- en: To check the status of the backtick operation you can execute $?.success?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查反引号操作的状态，你可以执行 $?.success?
- en: $?
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: $?
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How to chose?
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何选择？
- en: a great flow chart has been made on [stackoverflow](http://stackoverflow.com/a/37329716/967283)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [stackoverflow](http://stackoverflow.com/a/37329716/967283) 上制作了一个很棒的流程图
- en: '![](cmd_exec_chart.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](cmd_exec_chart.png)'
- en: '* * *'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Ruby | Execute system commands](http://king-sabri.net/?p=2553)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby | 执行系统命令](http://king-sabri.net/?p=2553)'
- en: '[5 ways to run commands from Ruby](http://mentalized.net/journal/2010/03/08/5-ways-to-run-commands-from-ruby/)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从 Ruby 运行命令的 5 种方式](http://mentalized.net/journal/2010/03/08/5-ways-to-run-commands-from-ruby/)'
- en: '[6 ways to run Shell commands in Ruby](http://tech.natemurray.com/2007/03/ruby-shell-commands.html)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 Ruby 中运行 Shell 命令的 6 种方法](http://tech.natemurray.com/2007/03/ruby-shell-commands.html)'
- en: '[How to choose the correct way](http://stackoverflow.com/a/4413/967283)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何选择正确的方式](http://stackoverflow.com/a/4413/967283)'
- en: '[Executing commands in ruby](http://blog.bigbinary.com/2012/10/18/backtick-system-exec-in-ruby.html)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 ruby 中执行命令](http://blog.bigbinary.com/2012/10/18/backtick-system-exec-in-ruby.html)'
- en: Remote Shell
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程 Shell
- en: Remote Shell
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程 Shell
- en: Remote shell means s forward or reverse connection to the target system command-line(shell).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 远程 shell 意味着与目标系统命令行(shell)的正向或反向连接。
- en: '**Note:** For windows systems, replace the "/bin/sh" to "cmd.exe"'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 对于 Windows 系统，请将 "/bin/sh" 替换为 "cmd.exe"'
- en: Connect to Bind shell
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到绑定 shell
- en: from terminal
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端
- en: '[PRE73]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: since `192.168.0.15` is the victim IP
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`192.168.0.15`是受害者 IP
- en: Reverse shell
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向 shell
- en: Attacker is listening on port 4444 `nc -lvp 4444`. Now on victim machine run
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者正在端口 4444 上监听 `nc -lvp 4444`。现在在受害机器上运行
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: if you don't want to rely on `/bin/sh`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想依赖于 `/bin/sh`
- en: '[PRE75]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: if you don't want to rely on `cmd.exe`
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想依赖于 `cmd.exe`
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: since `192.168.0.13` is the attacker IP
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`192.168.0.13`是攻击者 IP
- en: If you want it more flexible script file
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更灵活的脚本文件
- en: '[PRE77]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Bind and Reverse shell
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定和反向 shell
- en: This is an awesome implementation for a standalone [bind](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells/blob/master/bind.rb)
    and [reverse](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells/blob/master/rubyrev.rb)
    shells scripts written by [Hood3dRob1n](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells)
    on GitHub . The bind shell requires authentication while reverse is not.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个出色的独立实现，由GitHub上的[Hood3dRob1n](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells)编写的一个[bind](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells/blob/master/bind.rb)和[reverse](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells/blob/master/rubyrev.rb)
    shells脚本。绑定shell需要身份验证，而反向shell则不需要。
- en: Ncat.rb
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ncat.rb
- en: Pure Ruby Netcat
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯Ruby Netcat
- en: Simple Ncat.rb
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的Ncat.rb
- en: I found [this](http://4thmouse.com/index.php/2008/02/20/netcat-clone-in-three-languages-part-i-ruby/)
    simple ncat so I did some enhancements on it and add some comments in it as well.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我找到了[这个](http://4thmouse.com/index.php/2008/02/20/netcat-clone-in-three-languages-part-i-ruby/)简单的ncat，所以我对它进行了一些增强，并在其中添加了一些注释。
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: To listen
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听
- en: '[PRE79]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To connect
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接
- en: '[PRE80]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Another Implementation of Ncat.rb
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个Ncat.rb的实现
- en: Again from [Hood3dRob1n](https://github.com/Hood3dRob1n/) a standalone [RubyCat](https://github.com/Hood3dRob1n/RubyCat)
    which supports password protection for bind shell.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 再次来自[Hood3dRob1n](https://github.com/Hood3dRob1n/)一个独立的[RubyCat](https://github.com/Hood3dRob1n/RubyCat)，支持绑定shell的密码保护。
- en: '* * *'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: RCE as a Service
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RCE作为服务
- en: RCE as a Service
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RCE作为服务
- en: DRb allows Ruby programs to communicate with each other on the same machine
    or over a network. DRb uses remote method invocation (RMI) to pass commands and
    data between processes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: DRb允许Ruby程序在同一台机器上或通过网络进行通信。DRb使用远程方法调用（RMI）在进程之间传递命令和数据。
- en: RCE Service
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RCE服务
- en: '[PRE81]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Note: It works on all OS platforms'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：它适用于所有操作系统平台
- en: The `drb` lib supports ACL to prevent/allow particular IP addresses. ex.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`drb`库支持ACL以防止/允许特定IP地址。例如。'
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Client
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端
- en: '[PRE83]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Or you can use a Metasploit module to get an elegant shell!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用Metasploit模块来获得一个优雅的shell！
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As you can see, even you loose the session you can connect again and again;
    it's a service, remember?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，即使你失去了会话，你也可以一次又一次地连接；这是一个服务，记住了吗？
- en: 'Note: For using a Metasploit module *only*, you don''t need even the RShell
    class. You just need the following on the target side.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：仅仅为了使用Metasploit模块，你甚至不需要RShell类。你只需要目标端的以下内容。
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: I recommend to use the first code in case Metasploit is not available.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在Metasploit不可用的情况下使用第一个代码。
- en: '**References**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考资料**'
- en: '[Metasploit technical details](http://blog.recurity-labs.com/archives/2011/05/12/druby_for_penetration_testers/)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Metasploit技术细节](http://blog.recurity-labs.com/archives/2011/05/12/druby_for_penetration_testers/)'
- en: '[dRuby book](https://pragprog.com/book/sidruby/the-druby-book)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[dRuby书籍](https://pragprog.com/book/sidruby/the-druby-book)'
- en: VirusTotal
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VirusTotal
- en: VirusTotal
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VirusTotal
- en: VirusTotal is one of the most known online service that analyzes files and URLs
    enabling the identification of viruses, worms, trojans and other kinds of malicious
    content detected by antivirus engines and website scanners. At the same time,
    it may be used as a means to detect false positives, i.e. innocuous resources
    detected as malicious by one or more scanners.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: VirusTotal是最知名的在线服务之一，用于分析文件和URL，从而识别病毒、蠕虫、特洛伊木马和其他种类的恶意内容，这些内容被杀毒引擎和网站扫描器检测到。同时，它也可以用作检测误报的手段，即被一个或多个扫描器检测为恶意的无害资源。
- en: Getting VirusTotal
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取VirusTotal
- en: Register/Sign-in to VirusTotal
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册/登录到VirusTotal
- en: Go to **My API key**
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**我的API密钥**
- en: Request a private APT key
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求一个私有的APT密钥
- en: Do not disclose your private key to anyone that you do not trust.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要向你不信任的任何人透露你的私钥。
- en: Do not embed your private in scripts or software from which it can be easily
    retrieved
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将你的私钥嵌入到可以轻松检索的脚本或软件中
- en: VirusTotal gem
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VirusTotal gem
- en: ruby-virustotal is VirusTotal automation and convenience tool for hash, file
    and URL submission.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ruby-virustotal是VirusTotal的自动化和便利工具，用于哈希、文件和URL提交。
- en: Install virustotal gem
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装virustotal gem
- en: '[PRE86]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Command line usage
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行使用
- en: You can use ruby-virustotal gem as command line tool
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用ruby-virustotal gem作为命令行工具
- en: '**- Create virustotal local profile** To interact with virustotal as command
    line tool, you have to create a profile contains you API key. The profile will
    get created in `~/.virustotal`.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**- 创建virustotal本地配置文件** 要作为命令行工具与virustotal交互，你必须创建一个包含你API密钥的配置文件。该配置文件将被创建在`~/.virustotal`中。'
- en: '[PRE87]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: edit the file and add your API key
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑文件并添加你的API密钥
- en: '**Searching a file of hashes**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索哈希文件**'
- en: '[PRE89]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**Searching a single hash**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索单个哈希**'
- en: '[PRE90]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Searching a file of hashes and outputting to XML**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索哈希文件并输出为XML**'
- en: '[PRE91]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '**Upload a file to VirusTotal and wait for analysis**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上传文件到VirusTotal并等待分析**'
- en: '[PRE92]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**Search for a single URL**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索单个网址**'
- en: '[PRE93]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: uirusu gem
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: uirusu gem
- en: uirusu is an VirusTotal automation and convenience tool for hash, file and URL
    submission.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: uirusu 是一个 VirusTotal 的自动化和便利工具，用于哈希、文件和网址的提交。
- en: Install uirusu gem
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 uirusu gem
- en: '[PRE94]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Usage is identical to virustotal gem
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式与 virustotal gem 相同
- en: '* * *'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
