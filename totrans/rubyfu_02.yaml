- en: Module 0x2 | System Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module 0x2 | System Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many questions about building a standalone application that doesn't require
    Ruby to be pre-installed on the system. Of-course, due attacking machine you cant
    grantee that ruby is installed on the target system. So here we will demonstrate
    some ways to do that.
  prefs: []
  type: TYPE_NORMAL
- en: One-Click Ruby Application(OCRA) Builder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OCRA (One-Click Ruby Application) builds Windows executables from Ruby source
    code. The executable is a self-extracting, self-running executable that contains
    the Ruby interpreter, your source code and any additionally needed ruby libraries
    or DLL.
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s Windows support only**, not really ;)'
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LZMA Compression (optional, default on)
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby 1.8.7, 1.9.3, 2.0.0 and 2.1.5 support
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Both windowed/console mode supported
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes gems based on usage, or from a Bundler Gemfile
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: To install OCRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So all what to need is to have your application.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have the following script, a reverse shell of course ;)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: from our Windows Attacker machine cmd.exe
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the same directory, you'll find an exe file `rshell.exe`. Send it on the
    windows victim machine which doesn't have ruby installed and run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: from our attacking machine we already listening on 9911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](packaging__ocra1.png)'
  prefs: []
  type: TYPE_IMG
- en: Traveling-ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From official site^([1](#fn_1)) "*Traveling Ruby is a project which supplies
    self-contained, "portable" Ruby binaries: Ruby binaries that can run on any Linux
    distribution and any OS X machine. It also has Windows support (with some caveats).
    This allows Ruby app developers to bundle these binaries with their Ruby app,
    so that they can distribute a single package to end users, without needing end
    users to first install Ruby or gems.*"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The following script has been taken from the official docs.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Create your application -in our case, reverse shell- in "rshell" folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rshell.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Test it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating package directories
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next step is to prepare packages for all the target platforms, by creating
    a directory each platform, and by copying your app into each directory. (Assuming
    that your application could differ from OS to another)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, create a `packaging` directory and download Traveling Ruby binaries for
    each platform into that directory. Then extract these binaries into each packaging
    directory. You can find a list of binaries at the Traveling Ruby Amazon S3 bucket.
    For faster download times, use the CloudFront domain "[http://d6r77u77i8pq3.cloudfront.net](http://d6r77u77i8pq3.cloudfront.net)".
    In this tutorial we're extracting version 20141215-2.1.5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, each package directory will have Ruby binaries included. It looks like
    this: Your directory structure will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Quick sanity testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let''s do a basic sanity test by running your app with a bundled Ruby interpreter.
    Suppose that you are developing on OS X. Run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating a wrapper script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you've verified that the bundled Ruby interpreter works, you'll want
    create a *wrapper script*. After all, you don't want your users to run `/path-to-your-app/lib/ruby/bin/ruby
    /path-to-your-app/lib/app/rshell.rb`. You want them to run /path-to-your-app/rshell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what a wrapper script could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `packaging/wrapper.sh` in your project''s root directory.
    Then you can copy it to each of your package directories and name it `rshell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finalizing packages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you have created packages using Traveling Ruby!
  prefs: []
  type: TYPE_NORMAL
- en: 'An x86 Linux user could now use your app like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The user downloads rshell-1.0.0-linux-x86.tar.gz.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user extracts this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The user runs your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Automating the process
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Going through all of the above steps on every release is a hassle, so you should
    automate the packaging process, for example by using Rake. Here''s how the Rakefile
    could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then create all 3 packages by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a package for a specific platform by running one of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also just create package directories, without creating the .tar.gz
    files, by passing DIR_ONLY=1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: On Victim Machine
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You now have three files which you can distribute to end users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose the end user is on Linux x86_64\. S/he uses your app by downloading
    rshell-1.0.0-linux-x86_64.tar.gz, extracting it and running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: mruby
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**mruby CLI**^([2](#fn_2)) A utility for setting up a CLI with mruby that compiles
    binaries to Linux, OS X, and Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: mruby-cli
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer introduction
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=OvuZ8R4Y9xA](https://www.youtube.com/watch?v=OvuZ8R4Y9xA)'
  prefs: []
  type: TYPE_NORMAL
- en: Close Source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we don't want to disclose our source code for whatever reason, but
    we still want to share our applications either commercially or for free. Here
    a commercial solution for that purpose, RubyEncoder.
  prefs: []
  type: TYPE_NORMAL
- en: '**RubyEncoder**^([3](#fn_3)) protects Ruby scripts by compiling Ruby source
    code into a bytecode format and this is followed by encryption. This protects
    your scripts from reverse engineering. Ruby scripts protected with RubyEncoder
    can be executed but cannot be used to extract Ruby source code as there is no
    source code remaining within the protected script in any form.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '¹. Traveling-ruby: [Official website](http://phusion.github.io/traveling-ruby/)
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '². mruby CLI: [Official website](https://github.com/hone/mruby-cli) [↩](#reffn_2
    "Jump back to footnote [2] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '³. RubyEncoder: [Official website](http://rubyencoder.com) [↩](#reffn_3 "Jump
    back to footnote [3] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: File manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple Steganography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple script to hide a file `file.pdf` in an image `image.png` then write it
    into `steg.png` image which is originally the `image.png`
  prefs: []
  type: TYPE_NORMAL
- en: Then, it recovers the `file.pdf` from `steg.png` to `hola.pdf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:** This has nothing to do with bypassing AV.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Binary file to Hex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**hex-simple.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Or in one command line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note if want to change the hex prefix from \x to anything, just change `'\x%x'`
    to whatever you want, or remove it!.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simple Hexdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**hexdump.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finding weak file permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the important task to do post exploitation is find weak executable file
    permissions which might be executed buy root/administrator user trying to elevate
    our privileges on the system. At the same time, our scripts must be applicable
    for all systems
  prefs: []
  type: TYPE_NORMAL
- en: '**find777.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can search for read, write, execute permissions, so your iteration block
    will be like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Parsing HTML, XML, JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parsing HTML, XML, JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking the best and easiest way for parsing HTML and XML is using
    **Nokogiri** library
  prefs: []
  type: TYPE_NORMAL
- en: To install Nokogiri
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we'll use nokogiri to list our contents list from `http://rubyfu.net/content/`
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are 2 ways we'd like to show here, the standard library `rexml and nokogiri
    external library`
  prefs: []
  type: TYPE_NORMAL
- en: We've the following XML file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: REXML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Nokogiri
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Slop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume you have a small vulnerability database in a json file like follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To parse it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Returns a hash
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now you can retrieve and data as you do with hash
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you want to add to this database, just create a hash with the same struction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can convert it to json just by using `.to_json` method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating Hashes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MD5 hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: SHA1 hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: SHA2 hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In SHA2 you have 2 ways to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Way #1:** By creating a new SHA2 hash object with a given bit length.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**Way #2:** By Using the class directly'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**Bonus: Generate Linux-like Shadow password**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Windows LM Password hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[Source | RubyNTLM](https://github.com/wimm/rubyntlm/blob/master/lib/net/ntlm.rb)'
  prefs: []
  type: TYPE_NORMAL
- en: Windows NTLMv1 Password hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Windows NTLMv2 Password hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: MySQL Password hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL Password hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PostgreSQL hashes combined password and username then adds **md5** in front
    of the hash
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Symmetric Encryptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To list all supported algorithms
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: To unserdatand the cipher naming (eg. `AES-128-CBC`), it devided to 3 parts
    seperated by hyphen `<Name>-<Key_length>-<Mode>`
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encrption algorithms modes need 3 import data in order to work
  prefs: []
  type: TYPE_NORMAL
- en: Key (password)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initial Vector (iv)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data to encrypt (plain text)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AES encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Encrypt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Dencrypt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Resources**'
  prefs: []
  type: TYPE_NORMAL
- en: '[OpenSSL::Cipher docs](https://ruby-doc.org/stdlib-2.3.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[(Symmetric) Encryption With Ruby (and Rails)](http://stuff-things.net/2015/02/12/symmetric-encryption-with-ruby-and-rails/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caesar cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Caesar cipher** is one of the oldest known encryption methods. It is very
    simple - it is just shifting an alphabet. Transformation is termed ROTN, where
    N is shift value and ROT is from "ROTATE" because this is a cyclic shift.'
  prefs: []
  type: TYPE_NORMAL
- en: In Ruby, array rotation is mutter of using rotate() method. So all what we need
    is to have array of all alphabets rotate it and map it with the original given
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: result
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Sources:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.blackbytes.info/2015/03/caesar-cipher-in-ruby/](http://www.blackbytes.info/2015/03/caesar-cipher-in-ruby/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gist.github.com/matugm/db363c7131e6af27716c](https://gist.github.com/matugm/db363c7131e6af27716c)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://planetcalc.com/1434/](https://planetcalc.com/1434/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enigma script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| ![](Cryptography__wiringdiagram.png) |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Figure 1.** Enigma machine diagram |'
  prefs: []
  type: TYPE_TB
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[Source | Understanding the Enigma machine with 30 lines of Ruby](http://red-badger.com/blog/2015/02/23/understanding-the-enigma-machine-with-30-lines-of-ruby-star-of-the-2014-film-the-imitation-game)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Command Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some things to think about when choosing between these ways are:'
  prefs: []
  type: TYPE_NORMAL
- en: Are you going to interact with none interactive shell, like `ncat` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you just want stdout or do you need stderr as well? or even separated out?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How big is your output? Do you want to hold the entire result in memory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you want to read some of your output while the subprocess is still running?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you need result codes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you need a ruby object that represents the process and lets you kill it on
    demand?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following ways are applicable on all operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel#exec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Kernel#system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with `ncat` session?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you ever wondered how to do deal with interactive command like `passwd` due
    `ncat` session in Ruby?. You must propuly was using `python -c 'import pty; pty.spawn("/bin/sh")'`
    Well, in Ruby it's really easy using `exec` or `system`. The main trick is to
    forward STDERR to STDOUT so you can see system errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**exec**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**system**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Kernel#` (backticks)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: IO#popen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Open3#popen3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Process#spawn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kernel.spawn executes the given command in a subshell. It returns immediately
    with the process id.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '%x"", %x[], %x{}, %x$''''$'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Rake#sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Extra
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check the status of the backtick operation you can execute $?.success?
  prefs: []
  type: TYPE_NORMAL
- en: $?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How to chose?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: a great flow chart has been made on [stackoverflow](http://stackoverflow.com/a/37329716/967283)
  prefs: []
  type: TYPE_NORMAL
- en: '![](cmd_exec_chart.png)'
  prefs: []
  type: TYPE_IMG
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ruby | Execute system commands](http://king-sabri.net/?p=2553)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 ways to run commands from Ruby](http://mentalized.net/journal/2010/03/08/5-ways-to-run-commands-from-ruby/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6 ways to run Shell commands in Ruby](http://tech.natemurray.com/2007/03/ruby-shell-commands.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to choose the correct way](http://stackoverflow.com/a/4413/967283)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Executing commands in ruby](http://blog.bigbinary.com/2012/10/18/backtick-system-exec-in-ruby.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remote Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remote shell means s forward or reverse connection to the target system command-line(shell).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** For windows systems, replace the "/bin/sh" to "cmd.exe"'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to Bind shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: from terminal
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: since `192.168.0.15` is the victim IP
  prefs: []
  type: TYPE_NORMAL
- en: Reverse shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attacker is listening on port 4444 `nc -lvp 4444`. Now on victim machine run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: if you don't want to rely on `/bin/sh`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: if you don't want to rely on `cmd.exe`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: since `192.168.0.13` is the attacker IP
  prefs: []
  type: TYPE_NORMAL
- en: If you want it more flexible script file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Bind and Reverse shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an awesome implementation for a standalone [bind](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells/blob/master/bind.rb)
    and [reverse](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells/blob/master/rubyrev.rb)
    shells scripts written by [Hood3dRob1n](https://github.com/Hood3dRob1n/Ruby-Bind-and-Reverse-Shells)
    on GitHub . The bind shell requires authentication while reverse is not.
  prefs: []
  type: TYPE_NORMAL
- en: Ncat.rb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure Ruby Netcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple Ncat.rb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I found [this](http://4thmouse.com/index.php/2008/02/20/netcat-clone-in-three-languages-part-i-ruby/)
    simple ncat so I did some enhancements on it and add some comments in it as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: To listen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another Implementation of Ncat.rb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again from [Hood3dRob1n](https://github.com/Hood3dRob1n/) a standalone [RubyCat](https://github.com/Hood3dRob1n/RubyCat)
    which supports password protection for bind shell.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: RCE as a Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RCE as a Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DRb allows Ruby programs to communicate with each other on the same machine
    or over a network. DRb uses remote method invocation (RMI) to pass commands and
    data between processes.
  prefs: []
  type: TYPE_NORMAL
- en: RCE Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: It works on all OS platforms'
  prefs: []
  type: TYPE_NORMAL
- en: The `drb` lib supports ACL to prevent/allow particular IP addresses. ex.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Or you can use a Metasploit module to get an elegant shell!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even you loose the session you can connect again and again;
    it's a service, remember?
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: For using a Metasploit module *only*, you don''t need even the RShell
    class. You just need the following on the target side.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: I recommend to use the first code in case Metasploit is not available.
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Metasploit technical details](http://blog.recurity-labs.com/archives/2011/05/12/druby_for_penetration_testers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[dRuby book](https://pragprog.com/book/sidruby/the-druby-book)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirusTotal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VirusTotal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VirusTotal is one of the most known online service that analyzes files and URLs
    enabling the identification of viruses, worms, trojans and other kinds of malicious
    content detected by antivirus engines and website scanners. At the same time,
    it may be used as a means to detect false positives, i.e. innocuous resources
    detected as malicious by one or more scanners.
  prefs: []
  type: TYPE_NORMAL
- en: Getting VirusTotal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Register/Sign-in to VirusTotal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **My API key**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request a private APT key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not disclose your private key to anyone that you do not trust.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not embed your private in scripts or software from which it can be easily
    retrieved
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: VirusTotal gem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ruby-virustotal is VirusTotal automation and convenience tool for hash, file
    and URL submission.
  prefs: []
  type: TYPE_NORMAL
- en: Install virustotal gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Command line usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use ruby-virustotal gem as command line tool
  prefs: []
  type: TYPE_NORMAL
- en: '**- Create virustotal local profile** To interact with virustotal as command
    line tool, you have to create a profile contains you API key. The profile will
    get created in `~/.virustotal`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: edit the file and add your API key
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching a file of hashes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Searching a single hash**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Searching a file of hashes and outputting to XML**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Upload a file to VirusTotal and wait for analysis**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Search for a single URL**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: uirusu gem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: uirusu is an VirusTotal automation and convenience tool for hash, file and URL
    submission.
  prefs: []
  type: TYPE_NORMAL
- en: Install uirusu gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Usage is identical to virustotal gem
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
