- en: 'Lecture 4: Scope, Currying, and Lists'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scope and binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curried functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OCaml lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variable declarations in OCaml **bind** variables within a **scope**, the part
    of the program where the variable stands for the value it is bound to. For example,
    when we write `let` *x* = *e*[1] `in` *e*[2], the scope of the identifier *x*
    is the expression *e*[2]. Within that scope, the identifier *x* stands for whatever
    value *v* the expression *e*[1] evaluated to. Since *x* = *v*, OCaml evaluates
    the `let` expression by rewriting it to *e*[2], but with the value *v* substituted
    for the occurrences of *x*. For example, the expression `let x = 2 in x + 3` is
    evaluated to `2 + 3`, and then arithmetic is used to obtain the result value `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions also bind variables. When we write a function definition in OCaml,
    we introduce new variables for the function name and for function arguments. For
    example, in this expression two variables are bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The scope of the formal parameter x is exactly the expression e[1]. The scope
    of the variable f (which is bound to a function value) is the body of the let,
    e[2].
  prefs: []
  type: TYPE_NORMAL
- en: 'A `let` expression can introduce multiple variables at once, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here both `x` and `y` have the body of the `let` as their scope. Even though
    `y` is declared after `x`, the definition of `y` cannot refer to the variable
    `x`—it isn't in scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a recursive function, the function must be in scope within its own
    body. In OCaml, this requires using a `let rec` instead of a `let`. With `let
    rec`, every variable it declares is in scope within its own definition and within
    the definitions of all the other variables. To make this work, all the definitions
    that use these variables must be functions. For example, here is how we could
    define **mutually** recursive functions `even` and `odd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are two variables named `x` in this example, both of which are in scope
    only within the respective functions that bind them. However, the variables `even`
    and `odd` are in scope in each other's definitions and within the body of the
    `let`.
  prefs: []
  type: TYPE_NORMAL
- en: Qualified identifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to name things defined in a module without using a qualified
    identifier, using the `open` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of pre-defined library modules provided by OCaml that are
    extremely useful.  For instance, the `String` module provides a number of useful
    operations on strings, and the `List` module provides operations on lists. Many
    useful operations are in the `Pervasives` module, which is already open by default.
    To find out more about the OCaml libraries and the operations they provide, see
    [the Objective Caml Reference Manual, part IV](http://caml.inria.fr/pub/docs/manual-ocaml/).
  prefs: []
  type: TYPE_NORMAL
- en: For example, there is a built-in operation for calculating the absolute value
    of an integer called `Pervasives.abs`, which can be called simply as `abs`.
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to browse through the libraries and find out what they provide. 
    You shouldn't recode something that's available in the library (unless we ask
    you to do so explicitly.)
  prefs: []
  type: TYPE_NORMAL
- en: Curried functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw that a function with multiple parameters is really just syntactic sugar
    for a function that is passed a tuple as an argument. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: is sugar for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: which in turn is sugar for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply this function, say to the tuple `(2, 3)`, evaluation proceeds
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that OCaml has another way to declare functions with multiple
    formal arguments, and in fact it is the usual way. The above declaration can be
    given in **curried** form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'or with all the types written explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there is no comma between the parameters. Similarly, when applying
    a curried function, we write no comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is more going on here than it might seem. Recall we said that functions
    really only have one argument. When we write `plus 2 3`, the function `plus` is
    only being passed one argument, the number 2\. We can parenthesize the term as
    `(plus 2) (3)`, because application is left-associative. In other words, `plus
    2` must return a function that can be applied to 3 to obtain the result 5\. In
    fact, `plus 2` returns a function that adds 2 to its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this work? The curried declaration above is syntactic sugar for the
    creation of a **higher-order function**. It stands for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluation of `plus 2 3` proceeds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So `plus` is really a function that takes in an `int` as an argument, and returns
    a new function of type `int -> int`. Therefore, the type of `plus` is `int ->
    (int -> int)`. We can write this simply as `int -> int -> int` because the type
    operator `->` is right-associative.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that we can view binary operators like `+` as functions, and they
    are curried just like `plus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far the only real data structures we can build are made of tuples. But tuples
    don't let us make data structures whose size is not known at compile time. For
    that we need a new language feature.
  prefs: []
  type: TYPE_NORMAL
- en: One simple data structure that we're used to is singly linked lists. It turns
    out that OCaml has lists built in. For example, in OCaml the expression `[]` is
    an empty list. The expression `[1;2;3]` is a list containing three integers.
  prefs: []
  type: TYPE_NORMAL
- en: In OCaml, all the elements of a list have to have the same type. For example,
    a list of integers has the type `int list`. Similarly, the list `["hi"; "there";
    "3110"]` would have the type `string list`. But `[1; "hi"]` is not a legal list.
    Lists in OCaml are **homogeneous lists**, as opposed to **heterogeneous lists**
    in which each element can have a different type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are **immutable**: you cannot change the elements of a list, unlike an
    array in Java. Once a list is constructed, it never changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often we want to make a list out of smaller lists. We can concatenate two lists
    with the `@` operator. For example, `[1;2;3] @ [4;5]` = `[1;2;3;4;5]`. However,
    this operator isn't very fast because it needs to build a copy of the entire first
    list. (It doesn't make a copy of the second list because the storage of the second
    list is shared with the storage of the concatenated list.)
  prefs: []
  type: TYPE_NORMAL
- en: 'More often when building up lists we use the `::` operator, which prepends
    an element to the front of an existing list (“prepend” means “append onto the
    front”). The expression `1::[2;3]` is `1` prepended onto the list `[2;3]`. This
    is just the list `[1;2;3]`. If we use `::` on the empty list, it makes a one-element
    list: `1::[]` = `[1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: For historical reasons going back to the language Lisp, we usually call the
    `::` operator “cons”.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that lists are immutable is in keeping with OCaml being a functional
    language. It is also actually useful for making OCaml more efficient, because
    it means that different list data structures can share parts of their representation
    in the computer's memory. For example, evaluating `h::t` only requires allocating
    space for a single extra list node in the computer's memory. It shares the rest
    of the list with the existing list `t`.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching on lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way to extract elements from a list is to use pattern matching. The
    operator `::` and the bracket constructor can be used as patterns in a `match`
    expression. For example, if we had a list `lst` and wanted to get the value 0
    if `lst` was empty, 1 if `lst` had one element, and 2 if `lst` had 2 or more elements,
    we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x` would be bound to the single element of the list if the second match
    arm were evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, functions that manipulate lists are recursive, because they need to
    do something to every element. For example, suppose that we wanted to compute
    the length of a list of strings. We could write a recursive function that accomplishes
    this (in fact, the library function `List.length` does just this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The logic here is that if a list is empty (`[]`), its length is clearly zero.
    Otherwise, if it is the appending of an element h onto another list t, its length
    must be one greater than the length of t.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to write patterns using the bracket syntax. This is exactly
    the same as writing a similar pattern using the `::` operator. For example, the
    following patterns are all equivalent: `[x;2]`, `x::2::[]`, `x::[2]`. These expressions
    are also all equivalent when used as terms.'
  prefs: []
  type: TYPE_NORMAL
- en: Library functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OCaml structure [`List`](http://www.standardml.org/Basis/list.html) contains
    many useful functions for manipulating lists. Before using lists, it's worth taking
    a look. Some of them we'll talk about later in more detail. Two functions that
    should be used with caution are `hd` and `tl`. These functions get the head and
    tail of a list, respectively. However, they raise an exception if applied to an
    empty list. They make it easy to forget about the possibility that the list might
    be empty, creating expected exceptions that crash your program. So it's usually
    best to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: List examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use pattern matching to implement other useful functions on lists. Suppose
    we wanted a function that would extract a list element by its index within the
    list, with the first element at index zero. We can implement this neatly by doing
    a pattern match on the list and the integer n at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A `Not_found` exception is raised if `n` is less than 0 or greater than or equal
    to the length of `lst`.
  prefs: []
  type: TYPE_NORMAL
