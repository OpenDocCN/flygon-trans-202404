["```\ntype 'a tree = TNode of 'a * 'a tree * 'a tree | TLeaf\n\n```", "```\nlet rec contains x = function\n    TLeaf -> false\n  | TNode (y, l, r) ->\n      x = y || (x < y && contains x l) || contains x r\n\n```", "```\nlet rec contains x t =\n  match t with\n      TLeaf -> false\n    | TNode (y, l, r) ->\n        x = y || (x < y && contains x l) || contains x r\n\n```", "```\nlet rec add x = function\n    TLeaf -> TNode (x, TLeaf, TLeaf) (* If at a leaf, put new node there *)\n  | TNode (y, l, r) as t -> (* Recursively search for value *)\n      if x = y then t\n      else if x > y then TNode (y, l, add x r)\n      else (* x < y *) TNode (y, add x l, r)\n\n```", "```\n          ^                   50\n          |               /        \\\n          |           25              75\n height=3 |         /    \\          /    \\\n  n=15    |       10     30        60     90\n          |      /  \\   /  \\      /  \\   /  \\\n          V     4   12 27  40    55  65 80  99\n\n```", "```\ntype color = Red | Black\ntype 'a rbtree =\n  Node of color * 'a * 'a rbtree * 'a rbtree | Leaf\n\n```", "```\nlet rec mem x = function\n    Leaf -> false\n  | Node (_, y, left, right) ->\n      x = y || (x < y && mem x left) || (x > y && mem x right)\n\n```", "```\n       1 2 3 4\n\n       Bz            Bz            Bx            Bx\n      / \\           / \\           / \\           / \\\n     R[y]  d         R[x]  d         a   R[z]        a   R[y]\n    /  \\          / \\               /  \\          /  \\\n  R[x]   c         a   R[y] R[y]   d        b    R[z]\n /  \\               /  \\          / \\                /  \\\na    b             b    c        b   c              c    d\n\n```", "```\n     R[y]\n    /  \\\n  Bx    Bz\n / \\   / \\\na   b c   d\n\n```", "```\nlet balance = function\n    Black, z, Node (Red, y, Node (Red, x, a, b), c), d\n  | Black, z, Node (Red, x, a, Node (Red, y, b, c)), d\n  | Black, x, a, Node (Red, z, Node (Red, y, b, c), d)\n  | Black, x, a, Node (Red, y, b, Node (Red, z, c, d)) ->\n      Node (Red, y, Node (Black, x, a, b), Node (Black, z, c, d))\n  | a, b, c, d -> Node (a, b, c, d)\n\n```", "```\nlet insert x s =\n  let rec ins = function\n    Leaf -> Node (Red, x, Leaf, Leaf)\n  | Node (color, y, a, b) as s ->\n      if x < y then balance (color, y, ins a, b)\n      else if x > y then balance (color, y, a, ins b)\n      else s in\n  match ins s with\n    Node (_, y, a, b) ->\n      Node (Black, y, a, b)\n    | Leaf -> (* guaranteed to be nonempty *)\n        failwith \"RBT insert failed with ins returning leaf\"\n\n```"]