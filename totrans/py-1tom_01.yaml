- en: 如何写出优美的代码
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 好的结构是关键
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 如何测试 Python 应用
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 测试
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 对于一个开源项目来说，文档和测试都是必不可少的组成部分，没有足够测试和文档覆盖率的 “开源项目”就是一坨垃圾！当然，对于某些能够做到自文档的大神来说，
    文档可以是不必要的，但测试依旧是代码质量的保证。
  prefs: []
  type: TYPE_NORMAL
- en: 优秀的测试通常遵循一下基本规章：
  prefs: []
  type: TYPE_NORMAL
- en: 每个测试单元应该关注于一个功能，并保证其正确性。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 测试单元之间应该尽可能独立，也就是说可以独立运行，与顺序无关。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 测试的速度应该尽可能快，过慢的测试速度会成为开发的瓶颈。对于耗费时间很长的重型测试，应该将其独立出来。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 在集中编程前后都应该完整地运行一遍测试，以保证不会造成意外的破坏。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 在编程过程中，如果需要中断工作，那么编写一个不能运行的测试对于恢复工作非常有帮助。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: debug 的第一步就是写一个针对性的单元测试，虽然这做起来并不一定容易，但却非常有价值。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 虽然 PEP8 提倡简短的命名，但在测试函数名称应该长而有意义。比如，编程中你可能使用 `square()` 甚至 `sqr()` 这样的函数名称，但是在测试中你应该写成：`test_square_of_number_2()`,
    `test_square_negative_number()`。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 对于新成员来说，阅读测试代码可能是他们了解系统的最快途径之一，热点、难点、边界情况都会一目了然。 因此，加入新功能的第一步应该是编写一个对应的单元测试。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 基本概念
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 单元测试
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[单元测试](https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)是针对程序最小模块单位
    进行正确性检验的测试工作。最小单位通常是函数或者方法。理想情况下，每一个单元测试应该独立于其它用例。 单元测试通常由软件开发人员编写，用于确保他们所写的代码符合软件需求和遵循开发目标。'
  prefs: []
  type: TYPE_NORMAL
- en: 在自动化测试时，为了实现隔离的效果，测试将脱离待测程序单元（或代码主体）本身固有的运行环境之外， 即脱离产品环境或其本身被创建和调用的上下文环境，而在测试框架中运行。
    以隔离方式运行有利于充分显露待测试代码与其它程序单元或者产品数据空间的依赖关系。 这些依赖关系在单元测试中可以被消除。隔离模块经常会使用 stubs、mock
    或 fake 等测试马甲程序。
  prefs: []
  type: TYPE_NORMAL
- en: 集成测试
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 整合测试又称组装测试，即对程序模块采用一次性或增殖方式组装起来，对系统的接口进行正确性检验的测试工作。 整合测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，
    但是并不能保证组装起来也可以同时工作。
  prefs: []
  type: TYPE_NORMAL
- en: 系统测试
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 系统测试是将需测试的软件，作为整个基于计算机系统的一个元素， 与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素及环境结合在一起测试。 在实际运行(使用)环境下，对计算机系统进行一系列的组装测试和确认测试。
    系统测试的目的在于通过与系统的需求定义作比较，发现软件与系统定义不符合或与之矛盾的地方。
  prefs: []
  type: TYPE_NORMAL
- en: 基本工具
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: doctest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python 还提供了一个叫做 [doctest](https://docs.python.org/2/library/doctest.html) 的工具，写法如下：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 如果不在代码中显式 `import doctest` 也可以在运行文件的时候输入这样的命令： `python -m doctest -v filename.py`。
  prefs: []
  type: TYPE_NORMAL
- en: 从上面的示例代码中也可以看出，doctest 并便于不提供完整的边界数据测试的支持，因此并不能完全替代单元测试。
  prefs: []
  type: TYPE_NORMAL
- en: unittest 和 unittest2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python 自带了 [unittest](https://docs.python.org/2/library/unittest.html) 库， 是
    Java JUnit 库的 Python 实现，虽然很好用，但我还是想在这里吐槽一下驼峰式命名的方法。 在 Python 2.7 版本以后，unittest.TestCase
    类自带了 `assertListEquel()` 等方法， 非常便利，也是我不愿意兼容 Python 2.6 的重要原因。
  prefs: []
  type: TYPE_NORMAL
- en: 附即将弃用的方法对照表：
  prefs: []
  type: TYPE_NORMAL
- en: '| 方法名 | 即将弃用的方法名 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| assertEqual() | failUnlessEqual, assertEquals |'
  prefs: []
  type: TYPE_TB
- en: '| assertNotEqual() | failIfEqual |'
  prefs: []
  type: TYPE_TB
- en: '| assertTrue() | failUnless, assert_ |'
  prefs: []
  type: TYPE_TB
- en: '| assertFalse() | failIf |'
  prefs: []
  type: TYPE_TB
- en: '| assertRaises() | failUnlessRaises |'
  prefs: []
  type: TYPE_TB
- en: '| assertAlmostEqual() | failUnlessAlmostEqual |'
  prefs: []
  type: TYPE_TB
- en: '| assertNotAlmostEqual() | failIfAlmostEqual |'
  prefs: []
  type: TYPE_TB
- en: '[unittest2](http://www.voidspace.org.uk/python/articles/unittest2.shtml) 是
    unittest 的增强版本，几乎完全兼容 unittest 的接口，升级时只需要将 `import unittest` 替换为 `import unittest2`
    即可，提供的新方法更强大也更严谨。'
  prefs: []
  type: TYPE_NORMAL
- en: py.test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[pytest](http://pytest.org/latest/) 是一个成熟的全功能测试框架。'
  prefs: []
  type: TYPE_NORMAL
- en: web 相关
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 对于 web 功能的测试，最简单的可以使用 `urllib2.get(url)`，然后测试输出的 HTML 结果是否符合预期。 当然针对每一个功能都这样写未免太过低效，因此知名
    web 框架大多有专门的测试库提供测试：
  prefs: []
  type: TYPE_NORMAL
- en: Django 内置了 [django.test](https://docs.djangoproject.com/en/1.8/topics/testing/overview/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tornado 内置了 [tornado.testing](http://tornado.readthedocs.org/en/latest/testing.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask 可以使用 [werkzeug.test](http://werkzeug.pocoo.org/docs/0.10/test/#werkzeug.test.Client)
    和第三方的 [Flask-Testing](https://pythonhosted.org/Flask-Testing/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Django 的启动互相之间的依赖严重，大部分文件都不能单独执行，测试时建议使用封装后的工具， 如： `django.test`、`django_nose`
    等等。
  prefs: []
  type: TYPE_NORMAL
- en: Flask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flask 在写测试的时候需要主要 `app_context` 和 `request_context` 中的[陷阱](http://flask.pocoo.org/docs/0.10/appcontext/)。
  prefs: []
  type: TYPE_NORMAL
- en: Tornado
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tornado 的 testing 库很简陋，主要是针对自身异步特性封装了一些工具。
  prefs: []
  type: TYPE_NORMAL
- en: 浏览器
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 浏览器端的测试自动化最常用的还是 [Selenium](http://www.seleniumhq.org/)，Python 版本的 [文档](https://selenium-python.readthedocs.org/)并不复杂。示例代码：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 上面的代码会启动浏览器（这里设置的是 Firefox），并触发浏览器事件模拟用户输入。对于没有浏览器的机器， 比如服务器或，可以配置远程 Selenium
    server 或者使用 Headless 的 PhantomJS 代替。使用 Headless 浏览器 因为减少了打开和关闭浏览器的时间，因此在测试效率上也更高一些。
  prefs: []
  type: TYPE_NORMAL
- en: 使用之后感触最深的是错误提示不够丰富，基本上只能断定页面结果并不符合预期，结果反馈跟 `unittest.TestCase` 简直天壤之别。
  prefs: []
  type: TYPE_NORMAL
- en: 其它工具
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: nose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: tox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 发布独立库的时候通常要考虑不同版本间兼容性的问题，虽然可以通过 virtualenv 实现环境的模拟， 但毕竟很不方便，[tox](http://tox.readthedocs.org/)
    正是解决这一问题的工具。
  prefs: []
  type: TYPE_NORMAL
- en: tox 简化了 virtualenv 的管理，提供了简便的配置。我常用的配置是这样的：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: mock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[mock](http://www.voidspace.org.uk/python/mock/) 是一个测试库，提供模拟对象供测试用例使用。 [Python
    3 以后](https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock)，
    已将 mock 已经加入标准库，调用方法是 `from unittest import mock`。'
  prefs: []
  type: TYPE_NORMAL
- en: Code Coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 对于任何充分覆盖测试的代码，其 Code Coverage 程度肯定是 100%，任何覆盖率没能达到 100% 的代码都有隐藏 bug 的可能。在 Python
    社区，代码覆盖计算工具的标准是 `coverage.py` ， 当然，在计算覆盖率时要记得配合 tox ，以保证你针对不同环境的代码都被运行过。
  prefs: []
  type: TYPE_NORMAL
- en: coverage.py 的工作流程请参阅：[How coverage.py works](http://coverage.readthedocs.org/en/latest/howitworks.html)；
    详细文档请参阅：[Documentation](http://coverage.readthedocs.org/)。
  prefs: []
  type: TYPE_NORMAL
- en: coverage.py 也有 nose 插件，可以配合使用。
  prefs: []
  type: TYPE_NORMAL
- en: CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[travis CI](https://travis-ci.org/) 对于开源项目免费'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitLab CI](https://ci.gitlab.com) 免费，提供本地部署支持'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 如何提高测试速度
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 如果测试很耗费时间，很容易引起开发人员的不满，因而怠于编写测试，所以说提高测试速度对于落实测试来说十分重要。 总结了一些提升测试效率的方法：
  prefs: []
  type: TYPE_NORMAL
- en: 合理使用 `setUpClass` 和 `tearDownClass` 方法。作为类方法，在拥有多个测试方法时也只会在一个测试用例中执行一次。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 数据库很慢，避免使用数据库。一定需要的话，请使用内存数据库（比如 SQLite）。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 使用 [mock](http://mock.readthedocs.org/en/latest/getting-started.html)，避免使用 model。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 如果测试写起来很困难，说明需要重构了。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Celery 可以使用如下配置:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: django.test.utils.override_settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 关闭调试和日志
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 删除不必要的中间件和app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 这部分建议对于 Python 项目基本上也适用。
  prefs: []
  type: TYPE_NORMAL
- en: 参考链接
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Introduction to Python/Django tests](http://django-testing-docs.readthedocs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DjangoCon 2013 - How to Write Fast and Efficient Unit Tests in Django](http://www.slideshare.net/cordiskinsey/djangocon-2013-how-to-write-fast-and-efficient-unit-tests-in-django)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing and Django](http://carljm.github.io/django-testing-slides)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 如何测试 Django 应用
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 如何测试 Django 应用？
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django 的启动互相之间的依赖严重，很多参数和依赖都需要在运行的时候导入，导致大部分文件都不能单独执行。 不过 Django 的社区非常活跃，对于知名的测试框架都有进行封装，如：
    `django.test`、`django_nose` 等等， 以配合自身的测试命令使用。
  prefs: []
  type: TYPE_NORMAL
- en: doctest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 在 Flask 中测试一个文件的 doctest 只需要运行：`python filename.py`，然而这在 Django 中行不通。 在 Django
    中依赖自身的 test 命令：`python manage.py test[ app_name]`，其中 `app_name` 若为空 默认测试所有应用。[在
    1.6 及以后版本中](https://docs.djangoproject.com/en/1.6/releases/1.6/#new-test-runner)，
    需要首先在 `settings.py` 中指定 `TEST_RUNNER`：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: TestCase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django 的 `TestCase` 类是 `unittest.TestCase` 的子类，使用起来非常相似。
  prefs: []
  type: TYPE_NORMAL
- en: Fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fixture 是 unittest 提供读取测试数据的一种方式，在 Django 的 TestCase 中也可以直接使用，使用前需要导出数据：
  prefs: []
  type: TYPE_NORMAL
- en: '`python manage.py dumpdata --format=yaml --indent=4 > fixtures_dir/filename.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: 支持的数据格式包括 YAML、JSON 等等，YAML 可读性较高，不过需要安装额外的依赖。
  prefs: []
  type: TYPE_NORMAL
- en: 配合 testserver 命令启动：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 在测试用例中指定：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Client 提供了用户代理的模拟，其使用类似于 requests 库，不过使用前需要先初始化：`client = Client()`， Client
    默认会提供 CSRF 认证，如果需要手动验证 CSRF，需要这样初始化： `csrf_enabled_client = Client(enforce_csrf_checks=True)`。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: testserver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: testserver 是 Django 提供的启动测试服务器的方法，会创建一个测试数据库来替代默认数据库， 通常会在启动时导入相应 fixture。命令如下：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Selenium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 因为 Selenium 是控制浏览器测试 web 服务，因此并不会受到 Django 的干扰，这里有一段示例代码：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 面向接口测试——Python mock 库
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mock 测试就是在测试过程中，对于某些不容易构建或获取的对象，用虚拟的对象来代替 以便于测试的测试方法。
  prefs: []
  type: TYPE_NORMAL
- en: 一些基本概念
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: double 可以理解为置换，它是所有模拟测试对象的统称，我们也可以称它为替身。 一般来说，当你创建任意一种测试置换对象时，它将被用来替代某个指定类的对象。
  prefs: []
  type: TYPE_NORMAL
- en: stub 可以理解为测试桩，它能实现当特定的方法被调用时，返回一个指定的模拟值。 如果你的测试用例需要一个伴生对象来提供一些数据，可以使用 stub 来取代数据源，
    在测试设置时可以指定返回每次一致的模拟数据。
  prefs: []
  type: TYPE_NORMAL
- en: spy 可以理解为侦查，它负责汇报情况，持续追踪什么方法被调用了，以及调用过程中传递了哪些参数。 你能用它来实现测试断言，比如一个特定的方法是否被调用或者是否使用正确的参数调用。
    当你需要测试两个对象间的某些协议或者关系时会非常有用。
  prefs: []
  type: TYPE_NORMAL
- en: mock 与 spy 类似，但在使用上有些许不同。spy 追踪所有的方法调用，并在事后让你写断言， 而 mock 通常需要你事先设定期望。你告诉它你期望发生什么，然后执行测试代码并验证最后的结果与事先定义的
    期望是否一致。
  prefs: []
  type: TYPE_NORMAL
- en: fake 是一个具备完整功能实现和行为的对象，行为上来说它和这个类型的真实对象上一样， 但不同于它所模拟的类，它使测试变得更加容易。一个典型的例子是使用内存中的数据库来生成一个
    数据持久化对象，而不是去访问一个真正的生产环境的数据库。
  prefs: []
  type: TYPE_NORMAL
- en: 实践中，这些术语常常用起来不同于它们的定义，甚至可以互换，因此不必太过于陷入这些词汇的细节。 这些定义更多的是为了在高层次上区分这些概念， 它也对考虑不同类型测试对象的行为会有帮助。
  prefs: []
  type: TYPE_NORMAL
- en: 为什么需要 mock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 对于为什么需要 mock，或者什么时候需要使用 mock，Tim Mackinnon 提出了一些建议：
  prefs: []
  type: TYPE_NORMAL
- en: 真实对象具有不可确定的行为（产生不可预测的结果，如股票行情）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 真实对象很难被创建
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 真实对象的某些行为很难触发（比如网络错误）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 真实情况令程序的运行速度很慢
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 真实对象有用户界面
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 测试需要询问真实对象它是如何被调用的（比如测试可能需要验证某个回调函数是否被调用了）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 真实对象实际上并不存在（当需要和其他开发小组，或者新的硬件系统打交道时）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Mock` 类是 `ClallableMinxin` 和 `NonCallableMock` 的子类，实际上 `Mock` 中并没有其它定义： `class
    Mock(CallableMixin, NonCallableMock):pass`。'
  prefs: []
  type: TYPE_NORMAL
- en: 参数
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`spec`：这个参数是用来指定 Mock 实例的行为，那些方法是存在的，那些不存在。 其值可以是一个类或实例，也可以是一个字符串列表。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec_set`：比起 `spec` 更加严格。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`side_effect`：在 Mock 实例被调用时被调用的方法，对应 `side_effect`属性，可以用来返回动态值或者 异常。其参数和 mock
    相同，如果返回值不为 `DEFAULT` 则用作 Mock 实例的返回值。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 如果 `side_effect` 是一个迭代器，则每次调用的时候返回其中下一个元素。如果迭代器中的元素是异常 则将其抛出而非返回。
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`return_value`: mock 对象被调用时的返回值，默认是一个新的 `Mock` 实例。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wraps`: Item for the mock object to wrap. If `wraps` is not None then calling
    the Mock will pass the call through to the wrapped object (returning the real
    result). Attribute access on the mock will return a Mock object that wraps the
    corresponding attribute of the wrapped object (so attempting to access an attribute
    that doesn''t exist will raise an `AttributeError`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the mock has an explicity `return_value` set then calls are not passed to
    the wrapped object and the `return_value` is returned instead. 如果 Mock 实例存在 `return_value`
    ，不会调用被封装的对象。
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name`：Mock 对象在 repr 时的名字，调试时会很有帮助。该参数会传递给子 mock。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks can also be called with arbitrary keyword arguments. These will be used
    to set attributes on the mock after it is created.
  prefs: []
  type: TYPE_NORMAL
- en: 属性
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`call_args`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_args_list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_count`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`called`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return_value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`side_effect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 方法
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`attach_mock` Attach a mock as an attribute of this one, replacing its name
    and parent. Calls to the attached mock will be recorded in the `method_calls`
    and `mock_calls` attributes of this one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set attributes on the mock through keyword arguments. Attributes plus return
    values and side effects can be set on child mocks using standard dot notation
    and unpacking a dictionary in the method call:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`mock_add_spec` Add a spec to a mock. `spec` can either be an object or a list
    of strings. Only attributes on the `spec` can be fetched as attributes from the
    mock. If `spec_set` is True then only attributes on the spec can be set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset_mock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MogicMock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MagicMock 是 Mock 的子类，和 Mock 的不同之处在于 MagicMock 默认已经 mock 了对象的魔术方法（magic method）。
    推荐使用 MagicMock。
  prefs: []
  type: TYPE_NORMAL
- en: patch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`patch( target, new=DEFAULT, spec=None, create=False, spec_set=None, autospec=None,
    new_callable=None, **kwargs)` 有两种主要用法：'
  prefs: []
  type: TYPE_NORMAL
- en: 装饰器：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 和上下文管理器：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 两种情况下都保证仅仅在函数体内或者 with 表达式中，`target` 被 `new` 所替代。 当函数执行完或者离开 with 环境时，`target`
    恢复回去。
  prefs: []
  type: TYPE_NORMAL
- en: '`new` 默认是一个 `MagicMock` 对象 If `patch` is used as a decorator and `new` is omitted,
    the created mock is passed in as an extra argument to the decorated function.
    If `patch` is used as a context manager the created mock is returned by the context
    manager.'
  prefs: []
  type: TYPE_NORMAL
- en: '`target` should be a string in the form `''package.module.ClassName''`. The
    `target` is imported and the specified object replaced with the `new` object,
    so the `target` must be importable from the environment you are calling `patch`
    from. The target is imported when the decorated function is executed, not at decoration
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: The `spec` and `spec_set` keyword arguments are passed to the `MagicMock` if
    patch is creating one for you.
  prefs: []
  type: TYPE_NORMAL
- en: In addition you can pass `spec=True` or `spec_set=True`, which causes patch
    to pass in the object being mocked as the spec/spec_set object.
  prefs: []
  type: TYPE_NORMAL
- en: '`new_callable` allows you to specify a different class, or callable object,
    that will be called to create the `new` object. By default `MagicMock` is used.'
  prefs: []
  type: TYPE_NORMAL
- en: A more powerful form of `spec` is `autospec`. If you set `autospec=True` then
    the mock with be created with a spec from the object being replaced. All attributes
    of the mock will also have the spec of the corresponding attribute of the object
    being replaced. Methods and functions being mocked will have their arguments checked
    and will raise a `TypeError` if they are called with the wrong signature. For
    mocks replacing a class, their return value (the 'instance') will have the same
    spec as the class.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `autospec=True` you can pass `autospec=some_object` to use an arbitrary
    object as the spec instead of the one being replaced.
  prefs: []
  type: TYPE_NORMAL
- en: By default `patch` will fail to replace attributes that don't exist. If you
    pass in `create=True`, and the attribute doesn't exist, patch will create the
    attribute for you when the patched function is called, and delete it again afterwards.
    This is useful for writing tests against attributes that your production code
    creates at runtime. It is off by by default because it can be dangerous. With
    it switched on you can write passing tests against APIs that don't actually exist!
  prefs: []
  type: TYPE_NORMAL
- en: Patch can be used as a `TestCase` class decorator. It works by decorating each
    test method in the class. This reduces the boilerplate code when your test methods
    share a common patchings set. `patch` finds tests by looking for method names
    that start with `patch.TEST_PREFIX`. By default this is `test`, which matches
    the way `unittest` finds tests. You can specify an alternative prefix by setting
    `patch.TEST_PREFIX`.
  prefs: []
  type: TYPE_NORMAL
- en: Patch can be used as a context manager, with the with statement. Here the patching
    applies to the indented block after the with statement. If you use "as" then the
    patched object will be bound to the name after the "as"; very useful if `patch`
    is creating a mock object for you.
  prefs: []
  type: TYPE_NORMAL
- en: '`patch` takes arbitrary keyword arguments. These will be passed to the `Mock`
    (or `new_callable`) on construction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are available
    for alternate use-cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 猴子补丁（monkey patch）
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`patch` 本质上是一个函数，但是在实现的时候通过 MP 添加了很多属性：'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 例子
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[IPython notebook 在线示例](https://github.com/kxxoling/Python-One-to-Million/blob/ipynb/testing/mock.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: 参考文章
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[使用模拟对象（Mock Object）技术进行测试驱动开发](https://www.ibm.com/developerworks/cn/java/j-lo-mockobject/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[置换测试: Mock, Stub 和其他](http://objccn.io/issue-15-5/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyPI - mock](https://pypi.python.org/pypi/mock)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[mock - getting started](http://www.voidspace.org.uk/python/mock/getting-started.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Terminology for Mocks/Doubles/Fake/Dummy/Stub](http://martinfowler.com/articles/mocksArentStubs.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
