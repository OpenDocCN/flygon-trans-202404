["```\nWhile true\uff1a\n    for i in stream:\n        if i has data:\n            Do something with i \n```", "```\nWhile true\uff1a\n    select\uff08stream\uff09\n    for i in stream\uff1a\n        if i has data\uff1a\n            Do something \n```", "```\nwhile true \n    active_stream[] = epoll_wait(epollfd)\n    for i in active_stream[]\uff1a\n        read or write till unavailable \n```", "```\ndef handle_stream(self, stream, address):\n\n    \"\"\"Override to handle a new `.IOStream` from an incoming connection.\"\"\"\n\n    raise NotImplementedError() \n```", "```\nwhile True:\n    poll_timeout = 3600.0\n\n    # Prevent IO event starvation by delaying new callbacks\n    # to the next iteration of the event loop.\n    with self._callback_lock:\n        \uff03\u4e0a\u6b21\u5faa\u73af\u7684\u56de\u8c03\u5217\u8868\n        callbacks = self._callbacks\n        self._callbacks = []\n    for callback in callbacks:\n        \uff03\u6267\u884c\u9057\u7559\u56de\u8c03\n        self._run_callback(callback)\n\n    if self._timeouts:\n        now = self.time()\n        while self._timeouts:\n            \uff03\u8d85\u65f6\u56de\u8c03\n            if self._timeouts[0].callback is None:\n                # \u6700\u5c0f\u5806\u7ef4\u62a4\u8d85\u65f6\u4e8b\u4ef6\n                heapq.heappop(self._timeouts)\n            elif self._timeouts[0].deadline <= now:\n                timeout = heapq.heappop(self._timeouts)\n                self._run_callback(timeout.callback)\n            else:\n                seconds = self._timeouts[0].deadline - now\n                poll_timeout = min(seconds, poll_timeout)\n                break\n\n    if self._callbacks:\n        # If any callbacks or timeouts called add_callback,\n        # we don't want to wait in poll() before we run them.\n        poll_timeout = 0.0\n\n    if not self._running:\n        break\n\n    if self._blocking_signal_threshold is not None:\n        # clear alarm so it doesn't fire while poll is waiting for\n        # events.\n        signal.setitimer(signal.ITIMER_REAL, 0, 0)\n\n    try:\n        \uff03\u8fd9\u91cc\u7684poll\u5c31\u662fepoll\uff0c\u5f53\u6709\u4e8b\u4ef6\u53d1\u751f\uff0c\u5c31\u4f1a\u8fd4\u56de\uff0c\u8be6\u60c5\u53c2\u7167tornado\u91cce\uff03poll\u7684\u4ee3\u7801\n        event_pairs = self._impl.poll(poll_timeout)\n    except Exception as e:\n        if (getattr(e, 'errno', None) == errno.EINTR or\n            (isinstance(getattr(e, 'args', None), tuple) and\n             len(e.args) == 2 and e.args[0] == errno.EINTR)):\n            continue\n        else:\n            raise\n\n    if self._blocking_signal_threshold is not None:\n        signal.setitimer(signal.ITIMER_REAL,\n                         self._blocking_signal_threshold, 0)\n\n    \uff03\u5982\u679c\u6709\u4e8b\u4ef6\u53d1\u751f\uff0c\u6dfb\u52a0\u4e8b\u4ef6\uff0c\n    self._events.update(event_pairs)\n    while self._events:\n        fd, events = self._events.popitem()\n        try:\n            \uff03\u6839\u636efd\u627e\u5230\u5bf9\u5e94\u7684\u56de\u8c03\u51fd\u6570\uff0c\n            self._handlers[fd](fd, events)\n        except (OSError, IOError) as e:\n            if e.args[0] == errno.EPIPE:\n                # Happens when the client closes the connection\n                pass\n            else:\n                app_log.error(\"Exception in I/O handler for fd %s\",\n                              fd, exc_info=True)\n        except Exception:\n            app_log.error(\"Exception in I/O handler for fd %s\",\n                          fd, exc_info=True) \n```"]