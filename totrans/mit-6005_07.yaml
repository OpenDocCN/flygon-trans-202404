- en: 'Reading 7: Designing Specifications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Understand underdetermined specs, and be able to identify and assess nondeterminism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand declarative vs. operational specs, and be able to write declarative
    specs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand strength of preconditions, postconditions, and specs; and be able
    to compare spec strength
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to write coherent, useful specifications of appropriate strength
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,introduction/qtzCnF3-GJw)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this reading we’ll look at different specs for similar behaviors, and talk
    about the tradeoffs between them. We’ll look at three dimensions for comparing
    specs:'
  prefs: []
  type: TYPE_NORMAL
- en: How **deterministic** it is. Does the spec define only a single possible output
    for a given input, or allow the implementor to choose from a set of legal outputs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How **declarative** it is. Does the spec just characterize *what* the output
    should be, or does it explicitly say *how* to compute the output?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How **strong** it is. Does the spec have a small set of legal implementations,
    or a large set?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all specifications we might choose for a module are equally useful, and
    we’ll explore what makes some specifications better than others.
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic vs. underdetermined specs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall the two example implementations of `find` we began with in the [previous
    reading](../06-specifications/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The subscripts `[First]` and `[Last]` are not actual Java syntax. We’re using
    them here to distinguish the two implementations for the sake of discussion. In
    the actual code, both implementations should be Java methods called `find`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one possible specification of `find`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This specification is **deterministic**: when presented with a state satisfying
    the precondition, the outcome is completely determined. Only one return value
    and one final state is possible. There are no valid inputs for which there is
    more than one valid output.'
  prefs: []
  type: TYPE_NORMAL
- en: Both `find[First]` and `find[Last]` satisfy the specification, so if this is
    the specification on which the clients relied, the two implementations are equivalent
    and substitutable for one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a slightly different specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This specification is not deterministic. It doesn’t say which index is returned
    if `val` occurs more than once. It simply says that if you look up the entry at
    the index given by the returned value, you’ll find `val`. This specification allows
    multiple valid outputs for the same input.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is different from *nondeterministic* in the usual sense of that
    word. Nondeterministic code sometimes behaves one way and sometimes another, even
    if called in the same program with the same inputs. This can happen, for example,
    when the code’s behavior depends on a random number, or when it depends on the
    timing of concurrent processes. But a specification which is not deterministic
    doesn’t have to have a nondeterministic implementation. It can be satisfied by
    a fully deterministic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the confusion, we’ll refer to specifications that are not deterministic
    as **underdetermined**.
  prefs: []
  type: TYPE_NORMAL
- en: This underdetermined `find` spec is again satisfied by both `find[First]` and
    `find[Last]`, each resolving the underdeterminedness in its own (fully deterministic)
    way. A client of `find[OneOrMore,AnyIndex]` spec can’t rely on which index will
    be returned if `val` appears more than once. The spec would be satisfied by a
    nondeterministic implementation, too — for example, one that tosses a coin to
    decide whether to start searching from the beginning or the end of the array.
    But in almost all cases we’ll encounter, underdeterminism in specifications offers
    a choice that is made by the implementor at implementation time. An underdetermined
    spec is typically implemented by a fully-deterministic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Distinguished
  prefs: []
  type: TYPE_NORMAL
- en: 'With the same two implementations from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Over/under
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously we saw this underdetermined version of the `find` specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This spec allows multiple possible return values for arrays with duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: For each spec below, say whether it is *less* fully-determined than `find[OneOrMore,AnyIndex]`,
    *more* fully-determined, or deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Declarative vs. operational specs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,declarative_vs_operational_specs/nFmrlOPBbE0)'
  prefs: []
  type: TYPE_NORMAL
- en: Roughly speaking, there are two kinds of specifications. *Operational* specifications
    give a series of steps that the method performs; pseudocode descriptions are operational.
    *Declarative* specifications don’t give details of intermediate steps. Instead,
    they just give properties of the final outcome, and how it’s related to the initial
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Almost always, declarative specifications are preferable. They’re usually shorter,
    easier to understand, and most importantly, they don’t inadvertently expose implementation
    details that a client may rely on (and then find no longer hold when the implementation
    is changed). For example, if we want to allow either implementation of `find`,
    we would *not* want to say in the spec that the method “goes down the array until
    it finds `val`,” since aside from being rather vague, this spec suggests that
    the search proceeds from lower to higher indices and that the lowest will be returned,
    which perhaps the specifier did not intend.
  prefs: []
  type: TYPE_NORMAL
- en: One reason programmers sometimes lapse into operational specifications is because
    they’re using the spec comment to explain the implementation for a maintainer.
    Don’t do that. When it’s necessary, use comments within the body of the method,
    not in the spec comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a given specification, there may be many ways to express it declaratively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It’s up to us to choose the clearest specification for clients and maintainers
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Joint declaration
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Stronger vs. weaker specs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,stronger_vs_weaker_specs/Du57bZsp3gE)'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to change a method – either how its implementation behaves,
    or the specification itself. There are already clients that depend on the method’s
    current specification. How do you compare the behaviors of two specifications
    to decide whether it’s safe to replace the old spec with the new spec?
  prefs: []
  type: TYPE_NORMAL
- en: A specification S2 is stronger than or equal to a specification S1 if
  prefs: []
  type: TYPE_NORMAL
- en: S2’s precondition is weaker than or equal to S1’s,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: S2’s postcondition is stronger than or equal to S1’s, for the states that satisfy
    S1’s precondition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this is the case, then an implementation that satisfies S2 can be used to
    satisfy S1 as well, and it’s safe to replace S1 with S2 in your program.
  prefs: []
  type: TYPE_NORMAL
- en: These two rules embody several ideas. They tell you that you can always weaken
    the precondition; placing fewer demands on a client will never upset them. And
    you can always strengthen the post-condition, which means making more promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this spec for `find`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'can be replaced with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'which has a weaker precondition. This in turn can be replaced with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: which has a stronger postcondition.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about this specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We’ll come back to `find[CanBeMissing]` in the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '## Diagramming specifications'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine (very abstractly) the space of all possible Java methods.
  prefs: []
  type: TYPE_NORMAL
- en: Each point in this space represents a method implementation.
  prefs: []
  type: TYPE_NORMAL
- en: First we’ll diagram `find[First]` and `find[Last]` defined [above](#deterministic_vs_underdetermined_specs).
    Look back at the code and see that `find[First]` and `find[Last]` are *not specs*.
    They are implementations, with method bodies that implement their actual behavior.
    So we denote them as points in the space.
  prefs: []
  type: TYPE_NORMAL
- en: A specification defines a *region* in the space of all possible implementations.
    A given implementation either behaves according to the spec, satisfying the precondition-implies-postcondition
    contract (it is inside the region), or it does not (outside the region).
  prefs: []
  type: TYPE_NORMAL
- en: Both `find[First]` and `find[Last]` satisfy `find[OneOrMore,AnyIndex]`, so they
    are inside the region defined by that spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can imagine clients looking in on this space: the specification acts as
    a firewall.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementors have the freedom to move around inside the spec, changing their
    code without fear of upsetting a client. This is crucial in order for the implementor
    to be able to improve the performance of their algorithm, the clarity of their
    code, or to change their approach when they discover a bug, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients don’t know which implementation they will get. They must respect the
    spec, but also have the freedom to change how they’re using the implementation
    without fear that it will suddenly break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will similar specifications relate to one another? Suppose we start with
    specification S1 and use it to create a new specification S2.
  prefs: []
  type: TYPE_NORMAL
- en: If S2 is stronger than S1, how will these specs appear in our diagram?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by **strengthening the postcondition**. If S2’s postcondition is
    now stronger than S1’s postcondition, then S2 is the stronger specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Think about what strengthening the postcondition means for implementors: it
    means they have less freedom, the requirements on their output are stronger. Perhaps
    they previously satisfied `find[OneOrMore,AnyIndex]` by returning any index `i`,
    but now the spec demands the *lowest* index `i`. So there are now implementations
    *inside* `find[OneOrMore,AnyIndex]` but *outside* `find[OneOrMore,FirstIndex]`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Could there be implementations *inside* `find[OneOrMore,FirstIndex]` but *outside*
    `find[OneOrMore,AnyIndex]`? No. All of those implementations satisfy a stronger
    postcondition than what `find[OneOrMore,AnyIndex]` demands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Think through what happens if we **weaken the precondition**, which will again
    make S2 a stronger specification. Implementations will have to handle new inputs
    that were previously excluded by the spec. If they behaved badly on those inputs
    before, we wouldn’t have noticed, but now their bad behavior is exposed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We see that when S2 is stronger than S1, it defines a *smaller* region in this
    diagram; a weaker specification defines a larger region.
  prefs: []
  type: TYPE_NORMAL
- en: In our figure, since `find[Last]` iterates from the end of the array `arr`,
    it does not satisfy `find[OneOrMore,FirstIndex]` and is outside that region.
  prefs: []
  type: TYPE_NORMAL
- en: Another specification S3 that is neither stronger nor weaker than S1 might overlap
    (such that there exist implementations that satisfy only S1, only S3, and both
    S1 and S3) or might be disjoint. In both cases, S1 and S3 are incomparable.
  prefs: []
  type: TYPE_NORMAL
- en: '#### reading exercises'
  prefs: []
  type: TYPE_NORMAL
- en: Bulking up(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Strength is truth(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Finding findExactlyOne
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the `find` specifications again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We already know that `find[OneOrMore,FirstIndex]` is stronger than `find[OneOrMore,AnyIndex]`,
    which is stronger than `find[ExactlyOne]`.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Finding findCanBeMissing
  prefs: []
  type: TYPE_NORMAL
- en: Let’s determine where `find[CanBeMissing]` is on the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Found(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Designing good specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_7_designing_specifications,designing_good_specifications/aQDLg2_nU9s)'
  prefs: []
  type: TYPE_NORMAL
- en: What makes a good method? Designing a method means primarily writing a specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'About the form of the specification: it should obviously be succinct, clear,
    and well-structured, so that it’s easy to read.'
  prefs: []
  type: TYPE_NORMAL
- en: The content of the specification, however, is harder to prescribe. There are
    no infallible rules, but there are some useful guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: The specification should be coherent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The spec shouldn’t have lots of different cases. Long argument lists, deeply
    nested if-statements, and boolean flags are all signs of trouble. Consider this
    specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Is this a well-designed procedure? Probably not: it’s incoherent, since it
    does several things (finding in two arrays and summing the indexes) that are not
    really related. It would be better to use two separate procedures, one that finds
    the indexes, and the other that sums them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example, [the `countLongWords` method from *Code Review*](../04-code-review/#countLongWords):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In addition to [terrible use of global variables](../04-code-review/#dont_use_global_variables)
    and [printing instead of returning](../04-code-review/#methods_should_return_results_not_print_them),
    the specification is not coherent — it does two different things, counting words
    and finding the longest word.
  prefs: []
  type: TYPE_NORMAL
- en: Separating those two responsibilities into two different methods will make them
    simpler (easy to understand) and more useful in other contexts (ready for change).
  prefs: []
  type: TYPE_NORMAL
- en: The results of a call should be informative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the specification of a method that puts a value in a map, where keys
    are of some type `K` and values are of some type `V`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that the precondition does not rule out `null` values so the map can store
    `null`s. But the postcondition uses `null` as a special return value for a missing
    key. This means that if `null` is returned, you can’t tell whether the key was
    not bound previously, or whether it was in fact bound to `null`. This is not a
    very good design, because the return value is useless unless you know for sure
    that you didn’t insert `null`s.
  prefs: []
  type: TYPE_NORMAL
- en: The specification should be strong enough
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course the spec should give clients a strong enough guarantee in the general
    case — it needs to satisfy their basic requirements. We must use extra care when
    specifying the special cases, to make sure they don’t undermine what would otherwise
    be a useful method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there’s no point throwing an exception for a bad argument but
    allowing arbitrary mutations, because a client won’t be able to determine what
    mutations have actually been made. Here’s a specification illustrating this flaw
    (and also written in an inappropriately operational style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If a `NullPointerException` is thrown, the client is left to figure out on their
    own which elements of `list2` actually made it to `list1`.
  prefs: []
  type: TYPE_NORMAL
- en: The specification should also be weak enough
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this specification for a method that opens a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bad specification. It lacks important details: is the file opened
    for reading or writing? Does it already exist or is it created? And it’s too strong,
    since there’s no way it can guarantee to open a file. The process in which it
    runs may lack permission to open a file, or there might be some problem with the
    file system beyond the control of the program. Instead, the specification should
    say something much weaker: that it attempts to open a file, and if it succeeds,
    the file has certain properties.'
  prefs: []
  type: TYPE_NORMAL
- en: The specification should use *abstract types* where possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw early on in the [Java Collections section of *Basic Java*](../02-basic-java/#arraylists_and_linkedlists_creating_lists)
    that we can distinguish between more abstract notions like a `List` or `Set` and
    particular implementations like `ArrayList` or `HashSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing our specification with *abstract types* gives more freedom to both
    the client and the implementor. In Java, this often means using an interface type,
    like `Map` or `Reader`, instead of specific implementation types like `HashMap`
    or `FileReader`. Consider this specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This forces the client to pass in an `ArrayList`, and forces the implementor
    to return an `ArrayList`, even if there might be alternative `List` implementations
    that they would rather use. Since the behavior of the specification doesn’t depend
    on anything specific about `ArrayList`, it would be better to write this spec
    in terms of the more abstract `List`.
  prefs: []
  type: TYPE_NORMAL
- en: Precondition or postcondition?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another design issue is whether to use a precondition, and if so, whether the
    method code should attempt to make sure the precondition has been met before proceeding.
    In fact, the most common use of preconditions is to demand a property precisely
    because it would be hard or expensive for the method to check it.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, a non-trivial precondition inconveniences clients, because
    they have to ensure that they don’t call the method in a bad state (that violates
    the precondition); if they do, there is no predictable way to recover from the
    error. So users of methods don’t like preconditions. That’s why the Java API classes,
    for example, tend to specify (as a postcondition) that they throw unchecked exceptions
    when arguments are inappropriate. This approach makes it easier to find the bug
    or incorrect assumption in the caller code that led to passing bad arguments.
    In general, it’s better to **fail fast**, as close as possible to the site of
    the bug, rather than let bad values propagate through a program far from their
    original cause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it’s not feasible to check a condition without making a method unacceptably
    slow, and a precondition is often necessary in this case. If we wanted to implement
    the `find` method using binary search, we would have to require that the array
    be sorted. Forcing the method to actually *check* that the array is sorted would
    defeat the entire purpose of the binary search: to obtain a result in logarithmic
    and not linear time.'
  prefs: []
  type: TYPE_NORMAL
- en: The decision of whether to use a precondition is an engineering judgment. The
    key factors are the cost of the check (in writing and executing code), and the
    scope of the method. If it’s only called locally in a class, the precondition
    can be discharged by carefully checking all the sites that call the method. But
    if the method is public, and used by other developers, it would be less wise to
    use a precondition. Instead, like the Java API classes, you should throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: About access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Read: **[Packages](http://docs.oracle.com/javase/tutorial/java/package/index.html)**
    (7 short pages) in the Java Tutorials.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read: **[Controlling Access](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)**
    (1 page) in the Java Tutorials.'
  prefs: []
  type: TYPE_NORMAL
- en: We have been using *public* for almost all of our methods, without really thinking
    about it. The decision to make a method public or private is actually a decision
    about the contract of the class. Public methods are freely accessible to other
    parts of the program. Making a method public advertises it as a service that your
    class is willing to provide. If you make all your methods public — including helper
    methods that are really meant only for local use within the class — then other
    parts of the program may come to depend on them, which will make it harder for
    you to change the internal implementation of the class in the future. Your code
    won’t be as **ready for change**.
  prefs: []
  type: TYPE_NORMAL
- en: Making internal helper methods public will also add clutter to the visible interface
    your class offers. Keeping internal things *private* makes your class’s public
    interface smaller and more coherent (meaning that it does one thing and does it
    well). Your code will be **easier to understand**.
  prefs: []
  type: TYPE_NORMAL
- en: We will see even stronger reasons to use *private* in the next few classes,
    when we start to write classes with persistent internal state. Protecting this
    state will help keep the program **safe from bugs**.
  prefs: []
  type: TYPE_NORMAL
- en: About static vs. instance methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Read: **[the `static` keyword](http://www.codeguru.com/java/tij/tij0037.shtml#Heading79)**
    on CodeGuru.'
  prefs: []
  type: TYPE_NORMAL
- en: We have also been using *static* for almost all of our methods, again without
    much discussion. Static methods are not associated with any particular instance
    of a class, while *instance* methods (declared without the `static` keyword) must
    be called on a particular object.
  prefs: []
  type: TYPE_NORMAL
- en: Specifications for instance methods are written just the same way as specifications
    for static methods, but they will often refer to properties of the instance on
    which they were called.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, by now we’re very familiar with this specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using an `int[]`, what if we had a class `IntArray` designed for
    storing arrays of integers? The `IntArray` class might provide an instance method
    with the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’ll have much more to say about specifications for instance methods in future
    classes!
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show me a sign(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: That’s an odd way of looking at it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral oddities
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following test cases for `secondToLastIndexOf`:'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Odd doc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A specification acts as a crucial firewall between implementor and client —
    both between people (or the same person at different times) and between code.
    [As we saw last time](../06-specifications/#summary), it makes separate development
    possible: the client is free to write code that uses a module without seeing its
    source code, and the implementor is free to write the implementation code without
    knowing how it will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative specifications are the most useful in practice. Preconditions (which
    weaken the specification) make life harder for the client, but applied judiciously
    they are a vital tool in the software designer’s repertoire, allowing the implementor
    to make necessary assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, our goal is to design specifications that make our software:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs**. Without specifications, even the tiniest change to any
    part of our program could be the tipped domino that knocks the whole thing over.
    Well-structured, coherent specifications minimize misunderstandings and maximize
    our ability to write correct code with the help of static checking, careful reasoning,
    testing, and code review.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand**. A well-written declarative specification means the
    client doesn’t have to read or understand the code. You’ve probably never read
    the code for, say, [Python `dict.update`](https://hg.python.org/cpython/file/7ae156f07a90/Objects/dictobject.c#l1990),
    and doing so isn’t nearly as useful to the Python programmer as [reading the declarative
    spec](https://docs.python.org/3/library/stdtypes.html#dict.update).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change**. An appropriately weak specification gives freedom to
    the implementor, and an appropriately strong specification gives freedom to the
    client. We can even change the specs themselves, without having to revisit every
    place they’re used, as long as we’re only strengthening them: weakening preconditions
    and strengthening postconditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
