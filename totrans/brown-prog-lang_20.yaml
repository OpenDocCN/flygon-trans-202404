- en: 20State, Change, and More Equality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20状态、变化和更多的等式
- en: '|     [20.1 A Canonical Mutable Structure](#%28part._mutable-structures%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [20.1 一个标准的可变结构](#%28part._mutable-structures%29) |'
- en: '|     [20.2 What it Means to be Identical](#%28part._sem-identical%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [20.2 什么是相同的含义](#%28part._sem-identical%29) |'
- en: '|     [20.3 Recursion and Cycles from Mutation](#%28part._rec-from-mut%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [20.3 递归和突变的循环](#%28part._rec-from-mut%29) |'
- en: '|       [20.3.1 Partial Definitions](#%28part._.Partial_.Definitions%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [20.3.1 部分定义](#%28part._.Partial_.Definitions%29) |'
- en: '|       [20.3.2 Recursive Functions](#%28part._rec-for-recursive%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [20.3.2 递归函数](#%28part._rec-for-recursive%29) |'
- en: '|       [20.3.3 Premature Evaluation](#%28part._premature-eval%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [20.3.3 过早评估](#%28part._premature-eval%29) |'
- en: '|       [20.3.4 Cyclic Lists Versus Streams](#%28part._.Cyclic_.Lists_.Versus_.Streams%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|       [20.3.4 循环列表与流](#%28part._.Cyclic_.Lists_.Versus_.Streams%29) |'
- en: '|     [20.4 From Identifiers to Variables](#%28part._mutable-variables%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|     [20.4 从标识符到变量](#%28part._mutable-variables%29) |'
- en: '|     [20.5 Interaction of Mutation with Closures: Counters](#%28part._state-closures-counter%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|     [20.5 突变与闭包的交互：计数器](#%28part._state-closures-counter%29) |'
- en: '|       [20.5.1 Implementation Using Boxes](#%28part._.Implementation_.Using_.Boxes%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|       [20.5.1 使用盒子的实现](#%28part._.Implementation_.Using_.Boxes%29) |'
- en: '|       [20.5.2 Implementation Using Variables](#%28part._.Implementation_.Using_.Variables%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [20.5.2 使用变量的实现](#%28part._.Implementation_.Using_.Variables%29) |'
- en: '|     [20.6 A Family of Equality Predicates](#%28part._equality-operations%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|     [20.6 一个等价断言的家族](#%28part._equality-operations%29) |'
- en: '|       [20.6.1 A Hierarchy of Equality](#%28part._equality-hierarchy%29) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|       [20.6.1 一个等级制度的等价](#%28part._equality-hierarchy%29) |'
- en: '|       [20.6.2 Space and Time Complexity](#%28part._.Space_and_.Time_.Complexity%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|       [20.6.2 空间和时间复杂度](#%28part._.Space_and_.Time_.Complexity%29) |'
- en: '|       [20.6.3 Comparing Functions](#%28part._.Comparing_.Functions%29) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|       [20.6.3 比较函数](#%28part._.Comparing_.Functions%29) |'
- en: 20.1A Canonical Mutable Structure
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.1一个标准的可变结构
- en: As we have motivated ([Checking Component Connectedness](graphs.html#%28part._union-find-functional%29)),
    sometimes it’s nice to be able to change the value of a datum rather than merely
    construct a new one with an updated value. The main advantage to changing it is
    that every value that refers to it can now see this change. The main disadvantage
    to changing it is that every value that refers to it can now see this change.
    Using this power responsibly is therefore an important programming challenge.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所激发的（[检查组件连通性](graphs.html#%28part._union-find-functional%29)），有时更改数据值而不仅仅是构造具有更新值的新数据是很好的。更改它的主要优势是每个引用它的值现在都可以看到这个更改。更改它的主要缺点是每个引用它的值现在都可以看到这个更改。因此，负责地使用这种能力是一项重要的编程挑战。
- en: 'To put this idea in the simplest light, let us consider the simplest kind of
    mutable datum: one that has only one field. We call this a box, and treat it as
    a fresh container type. Boxes will support just three operations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个想法简单化，让我们考虑最简单的可变数据的最简单的情况：只有一个字段的数据。我们称之为一个盒子，并将其视为一个新的容器类型。盒子将支持三个操作：
- en: box consumes a value and creates a mutable box containing that value.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 盒子消耗一个值并创建一个包含该值的可变盒子。
- en: unbox consumes a box and returns the value contained in the box.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: unbox消耗一个盒子并返回盒子中包含的值。
- en: set-box consumes a box, a new value, and changes the box to contain the value.
    All subsequent unboxes of that box will now return the new value.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'set-box消耗一个盒子、一个新值，并将盒子更改为包含该值。该盒子的所有后续unbox将返回新值。 '
- en: 'In a typed language, we would require that the new value put in the box by
    set-box be type-consistent with what was there before. (Even in a language that
    isn’t statically typed, we would presumably expect the same to keep the programming
    process sane.) You can thus think of a box as equivalent to a Java container class
    with parameterized type, which has a single member field with a getter and setter:
    box is the constructor, unbox is the getter, and set-box is the setter. (Because
    there is only one field, its name is irrelevant.)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类型化的语言中，我们要求通过set-box放入盒子中的新值与之前放入的值在类型上一致。（即使在一个不是静态类型的语言中，我们可能也期望保持编程过程的理智。）因此，您可以将一个盒子看作是一个等价于具有参数化类型的Java容器类，它具有一个带有getter和setter的单个成员字段：盒子是构造函数，unbox是getter，set-box是setter。（因为只有一个字段，所以它的名称是无关紧要的。）
- en: '| class Box<T> { |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| class Box<T> { |'
- en: '|     private T the_value; |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|     private T the_value; |'
- en: '|     Box(T v) { |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|     Box(T v) { |'
- en: '|         this.the_value = v; |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|         this.the_value = v; |'
- en: '|     } |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|     } |'
- en: '|     T get() { |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|     T get() { |'
- en: '|         return this.the_value; |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|         return this.the_value; |'
- en: '|     } |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|     } |'
- en: '|     void set(T v) { |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|     void set(T v) { |'
- en: '|         this.the_value = v; |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|         this.the_value = v; |'
- en: '|     } |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|     } |'
- en: '| } |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: 'Correspondingly, here is a definition of a box in Pyret:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，这是Pyret中盒子的定义：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that in Pyret, because values are immutable by default, we have to explicitly
    declare the v field to be mutable using ref; mutable fields must be accessed using
    ! rather than ., the dot operator.The reason for using a different syntax is to
    warn the programmer that the value obtained from this field may change over time,
    so they should not make assumptions about its longevity. Because Pyret is single-threaded,
    however, they can assume the value will stay unchanged until either the next mutation
    in the same procedure, or until the next call to another procedure or return from
    this procedure—<wbr>whichever comes soonest.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Pyret中，因为默认情况下值是不可变的，我们必须使用ref显式声明v字段为可变；可变字段必须使用!而不是.来访问，即点运算符。使用不同语法的原因是警告程序员，从该字段获取的值可能会随时间变化，因此他们不应该对其寿命做出假设。然而，由于Pyret是单线程的，他们可以假设该值在同一过程中的下一次变异之前，或者在另一个过程的下一次调用或从该过程返回之前保持不变，以最快到来的那个时间点。
- en: Do Now!
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在！
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we say “type-consistent” above, rather than “the same type”?
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么我们在上面说“类型一致”而不是“相同类型”？
- en: The values could be related by subtyping ([Subtyping](objects.html#%28part._subtyping%29)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可能通过子类型关联（[子类型](objects.html#%28part._subtyping%29)）。
- en: Exercise
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the comment about longevity mean? How does this apply to reusing values
    extracted from fields?
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于寿命的评论是什么意思？这如何适用于重用从字段中提取的值？
- en: 20.2What it Means to be Identical
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.2什么是相同的含义
- en: Now that we have seen mutation, we’re in a position to understand the meaning
    of Pyret’s identical operation ([Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)).
    Consider a check of these two boxes and three references to them:<three-boxes>
    ::=
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了变异，我们现在能够理解Pyret的相同操作的含义（[重新审视相等性](Sharing_and_Equality.html#%28part._identical-eq%29)）。考虑对这两个盒子和对它们的三个引用的检查：<three-boxes>
    ::=
- en: '|   b0 = box("a value") |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|   b0 = box("a value") |'
- en: '|   b1 = box("a value") |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|   b1 = box("a value") |'
- en: '|   b2 = b1 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|   b2 = b1 |'
- en: 'Observe that b1 and b2 are referring to the same box, while b0 is referring
    to a different one. We can see this because the following tests pass:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到b1和b2引用的是同一个盒子，而b0引用的是另一个盒子。我们可以看到这一点，因为以下测试通过：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In other words, b1 and b2 are aliases for each other: they are two different
    names for one and the same value. In contrast, neither name is an alias for the
    value referred to by b0.Since identical is transitive, it follows from the above
    two checks that b0 is not identical to b2.Until now, this distinction had limited
    relevance. However, mutation introduces a wrinkle: if we change one value, all
    aliases to that value detect the change. We will perform this mutation in a slightly
    elaborate way, which we’ll explain in a moment:<modify-b1> ::='
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，b1和b2是彼此的别名：它们是同一个值的两个不同名称。相反，没有一个名称是b0引用的值的别名。由于相同是传递的，根据上述两个检查，可以得出b0不等同于b2。到目前为止，这种区别具有有限的相关性。然而，变异引入了一个问题：如果我们改变一个值，所有指向该值的别名都会检测到变化。我们将以稍微复杂的方式执行此变异，稍后我们将解释：<modify-b1>
    ::=
- en: '|   hold-b1-value = b1!v |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|   hold-b1-value = b1!v |'
- en: '|   b1!{v: "a different value"} |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|   b1!{v: "a different value"} |'
- en: 'Observe that if you just copy these definitions and tests one after the other
    in your editor, tests that should succeed will fail. This is because Pyret moves
    all test blocks to the end of the program, so the checks are not running in the
    source location where they are written. Until now, this made not a whit of difference.
    Now that we have mutation, it makes a world of difference. Therefore, you will
    need to erase old tests as you add new code that modifies state. Because that
    is the point of state: statements that were previously true no longer are. With
    this, we now have:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您只是在编辑器中依次复制这些定义和测试，应该成功的测试将失败。这是因为Pyret将所有测试块移动到程序的末尾，因此检查不是在编写它们的源位置运行的。到目前为止，这没有任何区别。现在我们有了变异，这就有了很大的不同。因此，您需要在添加修改状态的新代码时擦除旧���试。因为这就是状态的目的：以前为真的陈述现在不再是真的。有了这个，我们现在有了：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'after which we can restore the value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之后我们可以恢复值：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Continuing in this vein, symmetrically, we can also modify the value bound
    to b2 and make sure the change is visible via b1:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这样做，对称地，我们也可以修改绑定到b2的值，并确保通过b1可见更改：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In contrast, if we modify the content of the box referred to by b0, the only
    fact that held previously that no longer holds is this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们修改了由b0引用的盒子的内容，那么以前持有的唯一事实不再持有的是这个：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Thus, whereas previously the two boxes were structurally the same but not identical,
    now the are not even the former (while still not being the latter).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管以前这两个盒子在结构上是相同的，但现在它们甚至都不是前者（但仍然不是后者）。
- en: Now, why did we bother holding on to and restoring the value? It’s because at
    the end of each of these sequences, the values have all been restored, but by
    making the change, we have been able to observe which other names detect the change
    and which ones do not—<wbr>in other words, which names are aliases and which are
    not—<wbr>in still other words, we have implemented the essence of identical.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为什么要保留并恢复值呢？这是因为在每个序列的末尾，所有值都已恢复，但是通过进行更改，我们已经能够观察到哪些其他名称检测到更改，哪些名称没有—<wbr>换句话说，哪些名称是别名，哪些不是—<wbr>换句话说，我们已经实现了identical的本质。
- en: 'In practice, identical does not behave this way: it would be too disruptive—<wbr>e.g.,
    if this fake value was saved to persistent storage and then the system crashed—<wbr>and
    it would anyway be observable if the system had multiple threads. It is also not
    the most efficient implementation possible. Nevertheless, it does demonstrate
    the basic idea behind identical: two values are identical precisely when, when
    you make changes to one, you see the changes manifest on the “other” (i.e., there
    is really only one value).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，identical并不是这样行为：这将是太破坏性的—<wbr>例如，如果这个假值被保存到持久存储，然后系统崩溃—<wbr>而且如果系统有多个线程，它也是可观察到的。它也不是可能的最有效的实现。尽管如此，它确实展示了identical背后的基本思想：当你对一个值进行更改时，当你在“另一个”上看到更改时，两个值是相同的（即，实际上只有一个值）。
- en: 20.3Recursion and Cycles from Mutation
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.3递归和变异循环
- en: 'Mutation can also help us make sense of recursion. Let us return to the example
    we tried to write earlier ([From Acyclicity to Cycles](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 变异也可以帮助我们理解递归。让我们返回到我们之前尝试编写的例子（从非循环到循环）：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'which, as we noted, does not pass muster because web-colors is not bound on
    the right of the =. (Why not? Because otherwise, if we try to substitute web-colors
    on the right, we would end up in an infinite regress.)Something about this should
    make you a little suspicious: we have been able to write recursive functions all
    the time, without difficulty. Why are they different? For two reasons:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所注意到的那样，这并不合规，因为web-colors没有绑定在=的右边。（为什么不呢？因为如果我们尝试在右边替换web-colors，我们会陷入无限循环。）这件事情应该让你有点怀疑：我们一直能够毫无困难地编写递归函数。它们为什么不同？有两个原因：
- en: The first reason is the fact that we’re defining a function. A function’s body
    is not evaluated right away—<wbr>only when we apply it—<wbr>so the language can
    wait for the body to finish being defined. (We’ll see what this might mean in
    a moment.)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个原因是我们正在定义一个函数。函数的主体不会立即评估—<wbr>只有当我们应用它时—<wbr>所以语言可以等待主体完成定义。（我们马上会看到这可能意味着什么。）
- en: 'The second reason isn’t actually a reason: function definitions actually are
    special. But we are about to expose what’s so special about them—<wbr>it’s the
    use of a box!—<wbr>so that any definition can avail of it.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因实际上并不是原因：函数定义实际上是特殊的。但我们即将揭示它们的特殊之处—<wbr>它是使用了一个盒子！—<wbr>以便任何定义都可以利用它。
- en: Returning to our example above, recall that we can’t make up our list using
    links, because we want the list to never terminate. Therefore, let us first define
    a new datatype to hold an cyclig list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们上面的例子，回想一下我们不能使用链接来制作我们的列表，因为我们希望列表永远不会终止。因此，让我们首先定义一个新的数据类型来保存循环列表。
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Observe that we have carefully avoided writing type definitions for the fields;
    we will instead try to figure them out as we go along. Also, however, this definition
    as written cannot work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已经小心避免编写字段的类型定义；相反，我们会试着一边进行，一边弄清楚它们。但是，如此书写的定义却不能起作用。
- en: Do Now!
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why not?
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你看明白了吗？
- en: 'Let’s decompose the intended infinite list into two pieces: lists that begin
    with white and ones that begin with grey. What follows white? A grey list. What
    follows grey? A white list. It is clear we can’t write down these two definitions
    because one of them must precede the other, but each one depends on the other.
    (This is the same problem as trying to write a single definition above.)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 20.3.1Partial Definitions
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we need to instead do is to partially define each list, and then complete
    the definition using the other one. However, that is impossible using the above
    definition, because we cannot change anything once it is constructed. Instead,
    therefore, we need:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that this datatype lacks a base case, which should remind you of definitions
    we saw in [Streams From Functions](func-as-data.html#%28part._streams-from-funs%29).Using
    this, we can define:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Each of these definitions is quite useless by itself, but they each represent
    what we want, and they have a mutable field for the rest, currently holding a
    dummy value. Therefore, it’s clear what we must do next: update the mutable field.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because we have ordained that our colors must alternate beginning with white,
    this rounds up our definition:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we ask Pyret to inspect the value of web-colors, we notice that it employs
    an algorithm to prevent traversing infinite objects. We can define a helper function,
    take, a variation of which we saw earlier ([Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)),
    to inspect a finite prefix of an infinite list:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'such that:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 20.3.2Recursive Functions
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on this, we can now understand recursive functions. Consider a very simple
    example, such as this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We might like to think this is equivalent to:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: but if you enter this, Pyret will complain that sum is not bound. We must instead
    write
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What do you think rec does? It binds sum to a box initially containing a dummy
    value; it then defines the function in an environment where the name is bound,
    unboxing the use of the name; and finally, it replaces the box’s content with
    the defined function, following the same pattern we saw earlier for web-colors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 20.3.3Premature Evaluation
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Observe that the above description reveals that there is a time between the
    creation of the name and the assignment of a value to it. Can this intermediate
    state be observed? It sure can!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'There are generally three solutions to this problem:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the value is sufficiently obscure so that it can never be used in
    a meaningful context. This means values like 0 are especially bad, and indeed
    most common datatypes should be shunned. Indeed, there is no value already in
    use that can be used here that might not be confusing in some context.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The language might create a new type of value just for use here. For instance,
    imagine this definition of CList:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'undef appears to be a “base case”, thus making CList very similar to List.
    In truth, however, the undef is present only until the first mutation happens,
    after which it will never again be present: the intent is that r only contain
    a reference to other clinks.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 似乎 undef 是一个“基本情况”，因此使 CList 非常类似于 List。然而，事实上，undef 仅存在于第一次发生突变之前，之后将永远不会再次出现：意图是
    r 仅包含对其他 clink 的引用。
- en: The undef value can now be used by the language to check for premature uses
    of a cyclic list. However, while this is technically feasible, it imposes a run-time
    penalty. Therefore, this check is usually only performed by languages focused
    on teaching; professional programmers are assumed to be able to manage the consequences
    of such premature use by themselves.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，语言可以使用未定义的值来检查循环列表的过早使用。然而，尽管从技术上讲这是可行的，但它会带来运行时的惩罚。因此，这种检查通常只由专注于教学的语言执行；假定专业程序员能够自行处理此类过早使用的后果。
- en: Allow the recursion constructor to be used only in the case of binding functions,
    and then make sure that the right-hand side of the binding is syntactically a
    function. This solution precludes some reasonable programs, but is certainly safe.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只允许在绑定函数的情况下使用递归构造函数，然后确保绑定的右侧在语法上是一个函数。这种解决方案排除了一些合理的程序，但肯定是安全的。
- en: 20.3.4Cyclic Lists Versus Streams
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3.4 循环列表与流
- en: The color list example above is, as we have noted, very reminiscent of stream
    examples. What is the relationship between the two ways of defining infinite data?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，上述颜色列表示例非常类似于流示例。两种定义无限数据的方式之间有什么关系？
- en: 'Cyclic lists have on their side simplicity. The pattern of definition used
    above can actually be encapsulated into a language construct using desugaring
    ([Desugaring: Growing the Language Without Enlarging It](first-interp.html#%28part._first-desugar%29)),
    so programmers do not need to wrestle with mutable fields (as above) or thunks
    (as streams demand). This simplicity, however, comes at a price: cyclic lists
    can only represent strictly repeating data, i.e., you cannot define nats or fibs
    as cyclic lists. In contrast, the function abstraction in a stream makes it generative:
    each invocation can create a truly novel datum (such as the next natural or Fibonacci
    number). Therefore, it is straightforward to implement cyclic lists as streams,
    but not vice versa.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 循环列表的简单性很有优势。上面使用的定义模式实际上可以通过解糖（[解糖：扩展语言而不增大它](first-interp.html#%28part._first-desugar%29））封装到语言结构中，因此程序员不需要处理可变字段（如上所述）或懒惰计算（如流所需）。然而，这种简单性是有代价的：循环列表只能表示严格重复的数据，即，你不能将
    nats 或 fibs 定义为循环列表。相比之下，流中的函数抽象是生成性的：每次调用都可以创建一个真正新颖的数据（例如下一个自然数或斐波那契数）。因此，将循环列表实现为流是直接的，但反之则不然。
- en: 20.4From Identifiers to Variables
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.4 从标识符到变量
- en: As we have seen, mutable values can be aliased, which means references can inadvertently
    have their values changed. Because these values can be passed around, it can be
    difficult to track all the aliases that might exist (because it would be infeasible
    for a value to retain “backward references”).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，可变值可以被别名，这意味着引用可能会无意中更改其值。由于这些值可以传递，因此很难跟踪可能存在的所有别名（因为值保留“后向引用”是不可行的）。
- en: 'Therefore, in Pyret as in most languages, there is another form of mutable,
    called a variable. A variable is an identifier whose binding can be changed (as
    opposed to re-bound in a new scope); in Pyret, the syntax for changing the value
    of a variable is :=. Furthermore, variables must be declared explicitly by preceding
    their declaration with var:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Pyret 中和大多数语言一样，还有另一种可变形式，称为变量。变量是一个标识符，其绑定可以更改（与在新范围中重新绑定相反）；在 Pyret 中，更改变量值的语法是：=。此外，必须通过在其声明之前加上
    var 来明确声明变量：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The var keyword forces you to understand that the = is not a true equality:
    it’s equal for now, but may not be in the future.We’ve insisted on using the word
    “identifier” before because we wanted to reserve “variable” for what we’re about
    to study. In Java, when we say (assuming x is locally bound, e.g., as a method
    parameter)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: var 关键字迫使你理解 = 不是真正的相等：现在相等，但将来可能不等。我们之前一直坚持使用“标识符”一词，因为我们想保留“变量”来研究我们即将学习的内容。在
    Java 中，当我们说（假设 x 是局部绑定的，例如，作为方法参数）
- en: '| x = 1; |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| x = 1; |'
- en: '| x = 3; |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| x = 3; |'
- en: we’re asking to change the value of x. After the first assignment, the value
    of x is 1; after the second one, it’s 3. Thus, the value of x varies over the
    course of the execution of the method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求改变x的值。第一次赋值后，x的值为1；第二次赋值后，它是3。因此，x的值在方法执行过程中变化。
- en: Now, we also use the term “variable” in mathematics to refer to function parameters.
    For instance, in f(y) = y+3 we say that y is a “variable”. That is called a variable
    because it varies across invocations; however, within each invocation, it has
    the same value in its scope. Our identifiers until now have corresponded to this
    mathematical notion of a variable.If the identifier was bound to a box, then it
    remained bound to the same box value. It’s the content of the box that changed,
    not which box the identifier was bound to. In contrast, programming variables
    can vary even within each invocation, like the Java x above.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在数学中也使用术语“变量”来指代函数参数。例如，在f(y) = y+3中，我们说y是一个“变量”。之所以称其为变量，是因为它在调用之间变化；然而，在每次调用中，它在其范围内具有相同的值。到目前为止，我们的标识符对应于这种数学上的变量概念。如果标识符绑定到一个盒子，则它仍然绑定到相同的盒子值。变化的是盒子的内容，而不是标识符绑定到的盒子。相比之下，编程变量甚至在每次调用中也可以变化，就像上面的Java中的x一样。
- en: 'Henceforth, we will use variable when we mean an identifier whose value can
    change within its scope, and identifier when this cannot happen. If in doubt,
    we might play it safe and use “variable”; if the difference doesn’t really matter,
    we might use either one. It is less important to get caught up in these specific
    terms than to understand that they represent a distinction that matters ([Mutation:
    Structures and Variables](implementing-mutation.html)).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，当我们指的是其值可以在其范围内变化的标识符时，我们将使用“变量”，而当无法发生这种情况时，我们将使用“标识符”。如果有疑问，我们可能会保守地使用“变量”；如果差异并不真正重要，我们可能会同时使用两者。比起纠缠于这些具体术语，更重要的是理解它们代表了一个重要的区别（[变异：结构和变量](implementing-mutation.html)）。
- en: '20.5Interaction of Mutation with Closures: Counters'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.5变异与闭包的相互作用：计数器
- en: 'Suppose we want to create a function that counts how many times it has been
    invoked. Further, let us assume we can create new counters on need. Thus, mk-counter
    creates a fresh counter each time, each of which maintains its own count history.
    A sample use might look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个计算自身被调用次数的函数。此外，让我们假设我们可以根据需要创建新的计数器。因此，`mk-counter`每次都会创建一个新的计数器，每个计数器都会保持其自己的计数历史记录。一个示例用法可能如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that each invocation of mk-counter makes a fresh counter, so the counters
    created by two separate invocations do not interfere with one another.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次调用`mk-counter`都会创建一个新的计数器，因此两个单独调用所创建的计数器不会相互干扰。
- en: We now see how we can implement this using both mutable structures (specifically,
    boxes) and variables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了如何使用可变结构（具体来说是盒子）和变量来实现这一点。
- en: 20.5.1Implementation Using Boxes
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.5.1使用盒子实现
- en: 'Here is the implementation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Why does this work? It’s because each invocation of mk-counter creates a box
    only once, which it binds to ctr. The closure closes over this one box. All subsequent
    mutations affect the same box. In contrast, swapping two lines makes a big difference:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么有效？因为每次调用`mk-counter`都只创建一个盒子，并将其绑定到`ctr`上。闭包闭合在这个盒子上。所有后续的变异都影响同一个盒子。相比之下，交换两行会有很大的区别：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, a new box is allocated on every invocation, not of mk-broken-counter
    but of the function that it returns, so the answer each time is the same (despite
    the mutation inside the procedure). Our implementation of boxes should be certain
    to preserve this distinction.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每次调用时都会分配一个新的盒子，不是`mk-broken-counter`的调用，而是它返回的函数，因此每次的答案都是相同的（尽管过程内有变异）。我们的盒子实现应确保保留这种区别。
- en: 'The examples above hint at an implementation necessity. Clearly, whatever the
    environment closes over in the procedure returned by mk-counter must refer to
    the same box each time. Yet something also needs to make sure that the value in
    that box is different each time! Look at it more carefully: it must be lexically
    the same, but dynamically different. This distinction will be at the heart of
    a strategy for implementing state ([Mutation: Structures and Variables](implementing-mutation.html)).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例暗示了一个实现的必要性。显然，由`mk-counter`返回的过程中环境闭合的内容必须每次都引用同一个盒子。但是还需要确保该盒子中的值每次都不同！仔细看看：它在词法上必须相同，但在动态上不同。这种区别将成为实现状态的策略的核心（[变异：结构和变量](implementing-mutation.html)）。
- en: 20.5.2Implementation Using Variables
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.5.2使用变量实现
- en: 'The implementation using variables is virtually identical:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量的实现几乎是相同的：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And sure enough, if we swap the same critical two lines, we get the wrong behavior:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，如果我们交换同样关键的两行，我们会得到错误的行为：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 20.6A Family of Equality Predicates
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.6A 一系列相等的谓词
- en: 'Until now we have seen two notions of equality:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种相等的概念：
- en: The binary operator ==, which is also used as the equality comparison by in
    when testing.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元运算符==，它也被用作等号比较在测试时。
- en: identical, also written as <=>.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: identical，也写作<=>。
- en: 'However, we haven’t discussed exactly what == means, and it turns out there
    are two things it could mean, leaving us with three different notions of equality.
    To see this, refresh your memory with our [three boxes](#%28elem._three-boxes%29).We
    have already covered the meaning of identical. However, there is an intuitive
    level where it is unsatisfying: when our notion of equality is, “When printed
    (as output) or written (as input), would these two values look the same?”, where
    box("a value") and box("a value") are the “same”. That is, it would be nice to
    have an equality operator—<wbr>call it E1—<wbr>such that'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有讨论==的确切含义，事实证明它有两种可能的含义，这使我们得到了三种不同的相等概念。要了解这一点，请刷新您对我们的[三个盒子](#%28elem._three-boxes%29)的记忆。我们已经涵盖了identical的含义。然而，还有一个直观层面，在那里它是不令人满意的：当我们的相等概念是，“在打印（作为输出）或写入（作为输入）时，这两个值看起来一样吗？”，其中box("一个值")和box("一个值")是“相同的”。也就是说，很好有一个等号运算符——叫它E1——使得
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'because all three look the same when written out as values.However, as we just
    saw ([What it Means to be Identical](#%28part._sem-identical%29)), these equivalences
    can be ephemeral. When we modify b1 ([see above](#%28elem._modify-b1%29)), clearly
    these no longer print identically:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当作为值写出时，所有三个看起来都是一样的。然而，正如我们刚才看到的（[相等的含义](#%28part._sem-identical%29)），这些等价关系可能是暂时的。当我们修改b1时（[见上文](#%28elem._modify-b1%29)），显然这些不再打印相同：
- en: '| > b0 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| > b0 |'
- en: '| box("a value") |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| box("一个值") |'
- en: '| > b1 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| > b1 |'
- en: '| box("a different value") |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| box("不同的值") |'
- en: '| > b2 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| > b2 |'
- en: '| box("a different value") |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| box("不同的值") |'
- en: so we would expect
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们会期望
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There is in fact such an operator in Pyret: it is called equal-now, and written
    as a binary operator as =~ (the ~ is meant to be suggestive of hand-waving, because
    the value is equal now, but you shouldn’t assume it will be in the future). As
    the name and visual suggest, this is a fragile operator: you should not write
    programs that assume anything about the long-term equality of values that are
    equal at this moment, in case the values are mutable. However, it can still be
    useful to know whether, at this instant, two values will, in effect, “print the
    same”.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，Pyret中有这样一个运算符，它被称为equal-now，并且以=~（~的意思是手指挥，因为值现在是相等的，但你不应该假设它将来也是这样）作为二元运算符编写。正如名称和视觉所暗示的，这是一个脆弱的运算符：如果值是可变的，你不应该写一些假设长期相等的值的程序。然而，知道是否在此时两个值实际上“打印相同”仍然是有用的。  '
- en: Exercise
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Confirm that equal-now does indeed have the properties ascribed to E1 above.
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确认equal-now确实具有上面E1所赋予的属性。
- en: 'However, this still does not enable us to distinguish between == and identical:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然不能让我们区分==和identical：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For that, it helps to have a slightly richer structure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，有一个稍微丰富的结构会有所帮助：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that we are allocating three different lists, though two of them share
    the same mutable box. Now we find something interesting. Unsurprisingly, the following
    is true:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管其中两个共享相同的可变盒子，但我们正在分配三个不同的列表。现在我们发现了一些有趣的东西。毫不奇怪，以下内容是真实的：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: while
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 而
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What might == represent that is interestingly different from both identical
    and equal-now? When it returns true, it is that the two values will “print the
    same” now and forever. How is this possible? It is because == recursively checks
    that the two arguments are structural until it gets to a mutable field; at that
    point, it checks that they are identical. If they are identical, then any change
    made to one will be reflected in the other (because they are in fact the same
    mutable field). That means their content, too, will always “print the same”. Therefore,
    we can now reveal the name given to ==: it is equal-always.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ==可能代表什么与identical和equal-now有趣地不同？ 当它返回true时，是两个值“现在和将来都会“打印相同”。这是怎么可能的？这是因为==递归地检查两个参数是否结构相同，直到它到达一个可变字段为止；在那一点上，它检查它们是否是相同的。如果它们是相同的，那么对其中一个进行的任何更改都将反映在另一个上（因为它们实际上是同一个可变字段）。这意味着它们的内容也将始终“打印相同”。因此，我们现在可以揭示==的名称：它是equal-always。
- en: 20.6.1A Hierarchy of Equality
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.6.1A 相等的等级结构
- en: Observe that if two values v1 and v2 are equal-now, they are not necessarily
    equal-always; if they are equal-always, they are not necessarily identical. We
    have seen examples of both these cases above.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果两个值 v1 和 v2 现在相等，则它们不一定总是相等；如果它们总是相等，则它们不一定相同。我们已经在上面看到了这两种情况的例子。
- en: In contrast, if two values are identical, then they are certainly going to be
    equal-always. That is because their mutable fields reduce to identical, while
    the immutable parts—<wbr>which will be traversed structurally—<wbr>are guaranteed
    to yield equality, being in fact the same value. In turn, if they satisfy equal-always
    they are guaranteed to be equal-now, because the only difference is that equal-now
    structurally traverses the content of mutable fields, but if these are identical
    (as they must be, to be equal-always), they are certain to be structurally equal.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果两个值是相同的，那么它们肯定是总是相等的。这是因为它们的可变字段缩减为相同，而不可变部分——<wbr>将被结构性地遍历——<wbr>保证产生相等性，实际上是相同的值。反过来，如果它们满足总是相等，它们肯定是现在相等的，因为唯一的区别是现在相等结构性地遍历可变字段的内容，但如果这些字段是相同的（因为它们必须是总是相等的），它们肯定是结构上相等的。
- en: 'In most languages, it is common to have two equality operators, corresponding
    to identical (known as reference equality) and equal-now (known as structural
    equality). Pyret is rare in having a third operator, equal-always. For most programs,
    this is in fact the most useful equality operator: it is not overly bothered with
    details of aliasing, which can be difficult to predict; at the same time it makes
    decisions that stand the test of time, thereby forming a useful basis for various
    optimizations (which may not even be conscious of their temporal assumptions).
    This is why is in testing uses equal-always by default, and forces users to explicitly
    pick a different primitive if they want it.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数语言中，通常会有两个相等运算符，对应于相同（称为引用相等）和现在相等（称为结构相等）。Pyret 是罕见的，它有第三个运算符，总是相等。对于大多数程序来说，这实际上是最有用的相等运算符：它不过分关注可能难以预测的别名细节；同时，它做出的决定经得起时间的考验，因此形成了各种优化的有用基础（甚至可能不意识到它们的时间假设）。这就是为什么在测试中默认使用总是相等，并迫使用户明确选择不同的原始操作符。
- en: 20.6.2Space and Time Complexity
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.6.2 空间和时间复杂度
- en: identical always takes constant time. Indeed, some programs use identical precisely
    because they want constant-time equality, carefully structuring their program
    so that values that should be considered equal are aliases to the same value.
    Of course, maintaining this programming discipline is tricky.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总是相同的时间始终为常数。实际上，一些程序正是因为它们想要常数时间的相等性，才使用相同的。它们精心构造程序，使应该被视为相等的值是对同一值的别名。当然，保持这种编程纪律是棘手的。
- en: equal-always and equal-now both must traverse at least the immutable part of
    data. Therefore, they take time proportional to the smaller datum (because if
    the two data are of different size, they must not be equal anyway, so there is
    no need to visit the extra data). The difference is that equal-always reduces
    to identical at references, thereby performing less computation than equal-now
    would.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相等和总是相等都必须至少遍历数据的不可变部分。因此，它们的时间与较小的数据成正比（因为如果两个数据大小不同，则它们肯定不相等，因此没有必要访问额外的数据）。区别在于，总是相等将缩减到引用上的相同，因此执行的计算量比现在相等要少。
- en: 'For some programs, the cost of checking equality may be considerable. There
    are two common strategies such a program can employ:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些程序，检查相等性的成本可能相当大。这样的程序可以采用两种常见策略：
- en: 'Use a quick check followed by a slower check only if necessary. For instance,
    suppose we want to speed up equal-always, and have reason to believe we will often
    compare identical elements and/or that the values being compared are very large.
    Then we might define:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用快速检查，只在必要时使用较慢的检查。例如，假设我们想加速相等性检查，并且有理由相信我们经常比较相同的元素和/或被比较的值非常大。然后我们可以定义：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'which has the following behavior:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其行为如下：
- en: '[PRE32]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is exactly the same as the behavior of equal-always, but faster when it
    can discharge the equality using identical without having to traverse the data.
    (Observe that this is a safe optimization because identical implies equal-always.)
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当可以使用相同的而不必遍历数据时，其行为与总是相等的行为完全相同，但速度更快。 （注意，这是一种安全的优化，因为相同意味着总是相等。）
- en: 'Use a different equality strategy entirely, if possible: see [Set Membership
    by Hashing Redux](Algorithms_That_Exploit_State.html#%28part._hash-tables%29).'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能的话，完全使用不同的等价策略：参见[哈希表重复利用的集合成员资格](Algorithms_That_Exploit_State.html#%28part._hash-tables%29)。
- en: 20.6.3Comparing Functions
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.6.3比较函数
- en: We haven’t actually provided the full truth about equality because we haven’t
    discussed functions. Defining equality for functions—<wbr>especially extensional
    equality, namely whether two functions have the same graph, i.e., for each input
    produce the same output—<wbr>is complicated (a euphemism for impossible) due to
    the Halting Problem [REF].
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并没有提供关于等价性的全部真相，因为我们还没有讨论函数。定义函数的等价性——尤其是外延等价，即两个函数是否具有相同的图，即对于每个输入产生相同的输出——是复杂的（一种委婉说法是不可能的）由于停机问题[REF]。
- en: 'Because of this, most languages have tended to use approximations for function
    equality, most commonly reference equality. This is, however, a very weak approximation:
    even if the exact same function text in the same environment is allocated as two
    different closures, these would not be reference-equal. At least when this is
    done as part of the definition of identical, it makes sense; if other operators
    do this, however, they are actively lying, which is something the equality operators
    do not usually do.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数语言都倾向于使用函数等价的近似值，最常见的是引用等价。然而，这是一个非常弱的近似值：即使在相同的环境中分配了完全相同的函数文本作为两个不同的闭包，它们也不会引用相等。至少当这是作为相同的定义的一部分时，这是有意义的；然而，如果其他运算符这样做，它们实际上是在撒谎，而这是等价运算符通常不会做的事情。
- en: 'There is one other approach we can take: simply disallow function comparison.
    This is what Pyret does: all three equality operators above will result in an
    error if you try to compare two functions. (You can compare against just one function,
    however, and you will get the answer false.) This ensures that the language’s
    comparison operators are never trusted falsely.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取另一种方法：简单地禁止函数比较。这就是 Pyret 所做的：如果您尝试比较两个函数，所有三个等价性运算符将导致错误。 （但是，您可以与一个函数进行比较，并且您将得到错误答案。）这确保了语言的比较运算符永远不会被错误地信任。
- en: Pyret did have the choice of allowing reference equality for functions inside
    identical and erroring only in the other two cases. Had it done so, however, it
    would have violated the chain of implication above ([A Hierarchy of Equality](#%28part._equality-hierarchy%29)).
    The present design is arguably more elegant. Programmers who do want to use reference
    equality on functions can simply embed the functions inside a mutable structure
    like boxes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret 的选择是允许在相同情况下的函数引用相等，并且只在另外两种情况下出错。然而，如果这样做，它将违反上述链式推论（[等价性的层次结构](#%28part._equality-hierarchy%29)）。目前的设计可以说更加优雅。希望使用函数引用相等的程序员可以简单地将函数嵌入可变结构，如盒子。
- en: 'There is one problem with erroring when comparing two functions: a completely
    generic procedure that compares two arbitrary values has to be written defensively.
    Because this is annoying, Pyret offers a three-valued version of each of the above
    three operators (identical3, equal-always3 and equal-now3), all of which return
    EqualityResult values that correspond to truth, falsity, and ignorance (returned
    in the case when both arguments are functions). Programmers can use this in place
    of the Boolean-valued comparison operators if they are uncertain about the types
    of the parameters.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较两个函数时出现一个问题：一个完全通用的比较两个任意值的程序必须要进行防御性编写。因为这很烦人，Pyret 提供了上述三个运算符的三值版本（identical3，equal-always3
    和 equal-now3），它们都返回对应于真、假和无知（当两个参数都是函数时返回）的 EqualityResult 值。如果程序员对参数的类型不确定，可以使用这个版本替换布尔值比较运算符。
