- en: 'Chapter 1: Introduction'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：引言
- en: '*Computer science is to the information revolution what mechanical engineering
    was to the industrial revolution.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*计算机科学对信息革命的意义，就像机械工程对工业革命的意义一样。*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Robert Keller
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——罗伯特·凯勒
- en: 1.1 What is Computer Science?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 什么是计算机科学？
- en: You might be uncertain about what computer science (CS) is, but you use it every
    day. When you use Google or your smartphone, or watch a movie with special effects,
    there’s lots of CS in there. When you order a product over the Internet, there
    is CS in the web site, in the cryptography used to keep your credit card number
    secure, and in the way that FedEx routes their delivery vehicle to get your order
    to you as quickly as possible. Nonetheless, even computer scientists can struggle
    to answer the question “What *exactly* is CS?”
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不确定计算机科学（CS）是什么，但你每天都在使用它。当你使用谷歌或智能手机时，或者观看带有特效的电影时，其中都包含大量的CS。当你通过互联网订购产品时，网站中有CS，在用于保护你的信用卡号安全的加密中有CS，以及联邦快递（FedEx）为了尽快将您的订单送达给您而安排其交付车辆的方式中也有CS。尽管如此，即使是计算机科学家也可能难以回答“CS究竟是什么？”这个问题。
- en: 'Many other sciences try to understand how things work: physics tries to understand
    the physical world, chemistry tries to understand the composition of matter, and
    biology tries to understand life. So what is computer science trying to understand?
    Computers? Probably not: computers are designed and built by humans, so their
    inner workings are known (at least to some people!).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他科学试图理解事物的工作原理：物理学试图理解物理世界，化学试图理解物质的组成，生物学试图理解生命。那么计算机科学试图理解什么呢？计算机？可能不是：计算机是由人类设计和建造的，因此它们的内部工作原理是已知的（至少对一些人来说是！）。
- en: Perhaps it’s all about programming. Programming is indeed important to a computer
    scientist, just as grammar is important to a writer or a telescope is important
    to an astronomer. But nobody would argue that writing is about grammar or that
    astronomy is about telescopes. Similarly, programming is an important piece of
    computer science but it’s not what CS is all about.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这一切都关乎编程。编程确实对计算机科学家来说很重要，就像语法对作家或望远镜对天文学家来说很重要一样。但没有人会认为写作就是语法，或者天文学就是望远镜。同样，编程是计算机科学的一个重要组成部分，但这并不是CS的全部。
- en: If we turn to origins, computer science has roots in disparate fields that include
    engineering, mathematics, and cognitive science, among others. Some computer scientists
    design things, much like engineers. Others seek new ways to solve computational
    problems, analyze their solutions, and prove that they are correct, much like
    mathematicians. Still others think about how humans interact with computers and
    software, which is closely related to cognitive science and psychology. All of
    these pieces are a part of computer science.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾起源，计算机科学在不同领域都有根基，包括工程学、数学和认知科学等。一些计算机科学家设计事物，就像工程师一样。其他人寻求解决计算问题的新方法，分析他们的解决方案，并证明它们是正确的，就像数学家一样。还有一些人思考人类与计算机和软件的交互方式，这与认知科学和心理学密切相关。所有这些部分都是计算机科学的一部分。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Zoogenesis refers to the origin of a particular animals species. Computational
    biology is a field that uses CS to help solve zoogenetic questions, among many
    others.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*动物发生学是指特定动物物种的起源。计算生物学是一门利用CS来帮助解决动物起源问题等诸多问题的领域。*'
- en: One theme that unifies (nearly) all computer scientists is that they are interested
    in the *automation of tasks* ranging from **a**rtificial intelligence to **z**oogenesis.
    Put another way, computer scientists are interested in finding solutions for a
    wide variety of computational problems. They analyze those solutions to determine
    their “goodness,” and they implement the good solutions to create useful software
    for people to work with. This diversity of endeavors is, in part, what makes CS
    so much fun.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有计算机科学家都有一个共同点，那就是他们对从**人工智能**到**动物发生学**等各种任务的*自动化*感兴趣。换句话说，计算机科学家感兴趣的是寻找各种计算问题的解决方案。他们分析这些解决方案以确定它们的“好处”，然后实施好的解决方案以创建人们可以使用的有用软件。这种多样化的努力部分地造就了CS的乐趣所在。
- en: 'There are several important concepts at the heart of computer science; we have
    chosen to emphasize six of them: data, problem solving, algorithms, programming,
    abstraction, and creativity.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的核心有几个重要概念；我们选择强调其中的六个：数据，问题解决，算法，编程，抽象和创造力。
- en: 1.1.1 Data
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 数据
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*That’s Astronomical!*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*天文数字！*'
- en: 'When you Google the words “pie recipe,” Google reports that it finds approximately
    38 million pages, ranked in order of estimated relevance and usefulness. Facebook
    has approximately 1 billion active users who generate over 3 billion comments
    and “Likes” each day. GenBank, a national database of DNA sequences used by biologists
    and medical researchers studying genetic diseases, has over 100 million genetic
    sequences with over 100 billion DNA base pairs. According to the International
    Data Corporation, in 2010 the size of our “Digital Universe” reached 1.2 zettabytes.
    How much is that? Jeffrey Heer, a computer scientist who specializes in managing
    and visualizing large amounts of data, puts it this way: A stack of DVDs that
    reached to the moon and back would store approximately 1.2 zettabytes of data.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在谷歌搜索“派食谱”这几个词时，谷歌报告说它发现了大约3800万个网页，按估计的相关性和有用性排序。Facebook有大约10亿活跃用户，他们每天产生超过30亿的评论和“赞”。GenBank是一个由生物学家和研究遗传疾病的医学研究人员使用的DNA序列的国家数据库，拥有超过1亿个基因序列，超过1000亿个DNA碱基对。根据国际数据公司的说法，2010年，我们的“数字宇宙”的大小达到了1.2泽字节。这是多少？专门从事管理和可视化大量数据的计算机科学家杰弗里·希尔这样说：一堆到月球并返回的DVD大约可以存储1.2泽字节的数据。
- en: Without computer science, all of this data would be junk. Searching for a recipe
    on Google, a friend on Facebook, or genes in GenBank would all be impossible without
    ideas and tools from computer science.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 没有计算机科学，所有这些数据都将是垃圾。在谷歌上搜索食谱、在Facebook上寻找朋友或在GenBank中寻找基因都是不可能的，没有计算机科学的思想和工具。
- en: Doing meaningful things with data is challenging, even if we’re not dealing
    with millions or billions of things. In this book, we’ll do interesting things
    with smaller sets of data. But much of what we’ll do will be applicable to very
    large amounts of data too.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不处理数百万或数十亿的事物，利用数据做有意义的事情也是具有挑战性的。在这本书中，我们将对小数据集进行有趣的处理。但我们所做的很多事情也适用于非常大量的数据。
- en: 1.1.2 Algorithms
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 算法
- en: '**Making Pie and Making** \(\pi\)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**制作派和制作** \(\pi\)'
- en: When presented with a computational problem, our first objective is to find
    a computational solution, or “algorithm,” to solve it. An *algorithm* is a precise
    sequence of steps for carrying out a task, such as ranking web pages in Google,
    searching for a friend on Facebook, or finding closely related genes in Genbank.
    In some cases, a single good algorithm is enough to launch a successful company
    (e.g., Google’s initial success was due to its Page Rank algorithm).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 面对计算问题时，我们的首要目标是找到一个计算解决方案，或者说是“算法”，来解决它。*算法*是一系列精确的步骤，用于执行任务，例如在谷歌中排名网页、在Facebook上搜索朋友或在Genbank中找到相关基因。在某些情况下，一个良好的算法足以推动一家成功的公司（例如，谷歌最初的成功归功于其Page
    Rank算法）。
- en: 'Algorithms are commonly compared to recipes that act on their ingredients (the
    data). For example, imagine that an alien has come to Earth from a distant planet
    and has a hankering for some pumpkin pie. The alien does a Google search for pumpkin
    pie and finds the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 算法通常被比作对其成分（数据）进行操作的食谱。例如，想象一下，一个外星人从遥远的星球来到地球，渴望吃一些南瓜派。外星人在谷歌上搜索南瓜派，并找到了以下内容：
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*I’ve come to Earth for pumpkin pie!*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*我为了南瓜派来到地球！*'
- en: Mix 3/4 cup sugar, 1 tsp cinnamon, 1/2 tsp salt, 1/2 tsp ginger and 1/4 tsp
    cloves in a small bowl.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个小碗中混合3/4杯糖、1茶匙肉桂、1/2茶匙盐、1/2茶匙姜和1/4茶匙丁香。
- en: Beat two eggs in a large bowl.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个大碗中打两个鸡蛋。
- en: Stir 1 15-oz. can pumpkin and the mixture from step 1 into the eggs.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将1 15盎司的南瓜罐头和步骤1中的混合物搅拌进鸡蛋中。
- en: Gradually stir in 1 12 fl. oz. can evaporated milk into the mixture.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐渐地将1 12液体盎司的淡奶油搅拌进混合物中。
- en: Pour mixture into unbaked, pre-prepared 9-inch pie shell.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将混合物倒入未烤的、预先准备好的9英寸派皮中。
- en: Bake at 425°F for 15 minutes.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在425°F下烘烤15分钟。
- en: Reduce oven temperature to 350°F.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将烤箱温度降至350°F。
- en: Bake for 30-40 minutes more, or until set.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再烤30-40分钟，或者直到凝固。
- en: Cool for 2 hours on wire rack.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在铁丝架上冷却2小时。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*No! Don’t lick the spoon - there are raw eggs in there!*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*不！不要舔勺子 - 里面有生鸡蛋！*'
- en: Assuming we know how to perform basic cooking steps (measuring ingredients,
    cracking eggs, stirring, licking the spoon, etc.), we could make a tasty pie by
    following these steps precisely.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道如何执行基本的烹饪步骤（称量配料，打蛋，搅拌，舔勺子等），我们可以通过准确地遵循这些步骤制作出美味的馅饼。
- en: 'Out of respect for our gastronomical well-being, computer scientists rarely
    write recipes (algorithms) that have anything to do with food. As a computer scientist,
    we would be more likely to write an algorithm to calculate \(\pi\) very precisely
    than we would be to write an algorithm to make a pie. Let’s consider just such
    an algorithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 出于对我们的胃口健康的尊重，计算机科学家很少编写与食物有关的食谱（算法）。作为计算机科学家，我们更有可能编写一个非常精确地计算\(\pi\)的算法，而不是编写一个制作馅饼的算法。让我们考虑一下这样的算法：
- en: Draw a square that is 2 by 2 feet.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一个边长为2英尺的正方形。
- en: Inscribe a circle of radius 1 foot (diameter 2 feet) inside this square.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个正方形内刻一个半径为1英尺（直径为2英尺）的圆。
- en: Grab a bucket of n darts, move away from the dartboard, and put on a blindfold.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿一桶n个飞镖，远离飞镖板，戴上眼罩。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Please don’t try this at home!*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*请不要在家里尝试这个！*'
- en: 'Take each dart one at a time and for each dart:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个处理每个飞镖，对于每个飞镖：
- en: With your eyes still covered, throw the dart randomly (but assume that your
    throwing skills ensure that it will land somewhere on the square dartboard).
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依然闭着眼睛，随机投掷飞镖（但假设你的投掷技巧能确保它会落在方形飞镖板的某个地方）。
- en: Record whether or not the dart landed inside the circle.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录飞镖是否落在圆内。
- en: When you have thrown all the darts, divide the number that landed inside the
    circle by the total number, n, of darts you threw and multiply by 4\. This will
    give you your estimate for \(\pi\).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你扔完所有的飞镖后，将落在圆内的数量除以你投掷的飞镖的总数n，并乘以4。这将为你提供\(\pi\)的估计值。
- en: Figure 1.1 shows the scenario.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1展示了这种情况。
- en: '![../Images/dart.PNG](../Images/dart.PNG)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/dart.PNG](../Images/dart.PNG)'
- en: 'Figure 1.1: Using a dartboard to approximate \(\pi\)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：使用飞镖板来近似\(\pi\)
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*Hey, watch it! That dart almost hit me!*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*嘿，小心！那飞镖差点打到我了！*'
- en: 'That’s the description of the algorithm, but why does it work? Here’s why:
    The area of the circle is \(\pi r^2\) which is π in this case because we made
    the radius of the board to be 1\. The area of the square is 4\. Since we’re assuming
    that darts are equally likely to end up anywhere in the square, we expect the
    proportion of them that land in the circle to be the ratio of the area of the
    circle to the area of the square: \(\frac{\pi}{4}\). Therefore, if we throw n
    darts and determine that some number k land inside the circle, then \(\frac{k}{n}\)
    should be approximately \(\frac{\pi}{4}\). So multiplying the ratio by 4 gives
    us an approximation of \(\pi\).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是算法的描述，但它为什么有效呢？原因在于：圆的面积是\(\pi r^2\)，在这种情况下是π，因为我们将板的半径设为1。正方形的面积是4。由于我们假设飞镖在正方形的任何地方落下的可能性都相等，我们期望落在圆内的飞镖的比例是圆的面积与正方形面积的比值：\(\frac{\pi}{4}\)。因此，如果我们扔了n个飞镖，并确定其中有一些数目k落在圆内，那么\(\frac{k}{n}\)应该大约是\(\frac{\pi}{4}\)。因此，将比例乘以4给我们提供了\(\pi\)的近似值。
- en: Happily, the computer does not have to robotically throw physical darts; instead
    we can simulate this dart throwing process on a computer by generating random
    coordinates that describe where the darts land. The computer can throw millions
    of virtual darts in a fraction of a second and will never miss the square–making
    things considerably safer for your roommate!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，计算机不必机械地投掷物理飞镖；相反，我们可以在计算机上模拟这个投掷飞镖的过程，通过生成描述飞镖落点的随机坐标。计算机可以在几秒钟内抛出数百万个虚拟飞镖，永远不会偏离正方形——这使得对你的室友来说更安全！
- en: 1.1.3 Programming
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 编程
- en: Although we noted earlier that computer science is not exclusively about programming,
    ultimately we usually want to have a program–that is, software–that implements
    the algorithm that will operate on our data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前指出计算机科学不仅仅涉及编程，但最终我们通常希望有一个程序——也就是说，软件——来实现我们的数据上运行的算法。
- en: Learning to program is a bit like learning to speak or write in a new language.
    The good news is that the *syntax* of a programming language–the vocabulary and
    grammar–is not nearly as complicated as for a spoken language. In this book, we’ll
    program in a language called Python, whose syntax is particularly easy to learn.
    But don’t be fooled into thinking it’s not a real programming language–Python
    is a very real language used by real programmers to write real software. Moreover,
    the ideas that you’ll learn here will be transferable to learning other languages
    later.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 学习编程有点像学习一门新语言的口语或书面语言。好消息是，编程语言的*语法*——词汇和语法——远不及口语语言复杂。在这本书中，我们将使用一种名为Python的语言进行编程，其语法特别容易学习。但不要被误导以为它不是一种真正的编程语言——Python是一种非常真实的语言，由真正的程序员用来编写真实的软件。此外，您在这里学到的想法将可转移到以后学习其他语言。
- en: 1.1.4 Abstraction
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.4 抽象
- en: While data, algorithms, and programming might seem like the whole story, the
    truth is that there are other important ideas behind the scenes. Software is often
    immensely complex and it can be difficult or even impossible for any single person
    to keep all of the interacting pieces in mind. To deal with such complex systems,
    computer scientists use the the notion of *abstraction*–the idea that when designing
    one part of a program, we can ignore the inessential details of other parts of
    the program as long as we have a high level understanding of what they do.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据、算法和编程可能看起来像是整个故事，但事实是，背后还有其他重要的思想。软件通常非常复杂，对于任何单个人来说，保持所有相互作用的部分在脑海中可能是困难的，甚至是不可能的。为了处理这样的复杂系统，计算机科学家使用*抽象*的概念——即在设计程序的一个部分时，我们可以忽略其他部分的不重要细节，只要我们对它们的工作原理有高层次的理解。
- en: For example, a car has an engine, a drivetrain, an electrical system, and other
    components. These components can be designed individually and then assembled to
    work together. The designer of the drivetrain doesn’t need to understand every
    aspect of how the engine works, but just enough to know how the drivetrain and
    the engine will be connected. To the drivetrain designer, the engine is an “abstraction.”
    In fact, the engine itself is divided into components such as the engine block,
    distributor, and others. These parts too can be viewed as abstract entities that
    interact with one another. When designing the engine block, we don’t need to think
    about every detail of how the distributor works.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，汽车有发动机、传动系统、电气系统和其他组件。这些组件可以分别设计，然后组装在一起工作。传动系统设计者不需要了解发动机的每个方面，而只需了解传动系统和发动机将如何连接。对于传动系统设计者来说，发动机是一种“抽象”。实际上，发动机本身被划分为发动机块、分配器等组件。这些部件也可以被视为相互作用的抽象实体。在设计发动机块时，我们不需要考虑分配器的每个细节。
- en: Software systems can be even more complicated than a car. Designing software
    requires that we think about abstractions in order to ensure that many people
    can contribute to the project without everyone needing to understand everything,
    in order to test the software methodically, and in order to be able to update
    it in the future by simply replacing one “component” by a new and improved component.
    Abstraction, therefore, is a key idea in the design of any large system, and software
    in particular.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统甚至可能比汽车更复杂。设计软件要求我们考虑抽象，以确保许多人可以为项目做出贡献，而不是每个人都需要理解一切，以系统地测试软件，并且能够在将来通过简单地用新的和改进的组件替换一个“组件”来更新它。因此，抽象是任何大型系统设计以及特别是软件设计中的关键思想。
- en: 1.1.5 Problem Solving and Creativity
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.5 问题解决和创造力
- en: This book strives to prepare you to write well-designed programs that do interesting
    things with data. In the process, we hope to convey to you that computer science
    is an enormously creative endeavor that requires innovative problem-solving, exploration,
    and even experimentation. Often times, there’s more than one way to solve a problem.
    In some cases there’s not even a clear “best” way to solve a problem. Different
    solutions will have different merits. While Google, Facebook, GenBank are wonderfully
    easy to use, many challenges arose–and continue to arise–in the design and continual
    updating of such systems. These challenges often lead to groups of computer scientists
    working together to find different solutions and evaluate their relative merits.
    While the challenges that we’ll confront in this book are of a more modest scope,
    we hope to share with you the sense of problem solving and creativity that are
    at the heart of computer science.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本书致力于培养你编写设计良好、处理数据的有趣程序的能力。在此过程中，我们希望向你传达计算机科学是一项极具创造性的工作，需要创新的问题解决、探索，甚至实验。解决问题有时不止一种方法。在某些情况下，甚至没有明确的“最佳”解决方案。不同的解决方案将具有不同的优点。虽然谷歌、Facebook、GenBank
    等等易于使用，但在设计和不断更新这些系统方面出现了许多挑战——并且仍然在出现——这些挑战通常导致计算机科学家团队合作，寻找不同的解决方案并评估它们的相对优点。虽然本书中我们将面临的挑战规模较小，但我们希望与您分享计算机科学核心的问题解决和创造力。
- en: '**Takeaway message:** *In a nutshell, the objective of this book is to demonstrate
    the breadth of activities that comprise computer science, show you some fundamental
    and beautiful ideas, and provide you with the skills to design, implement, and
    analyze your own programs.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点：** *简而言之，本书的目标是展示构成计算机科学的广泛活动，向你展示一些基本且美妙的想法，并为你提供设计、实现和分析自己程序的技能。*'
- en: 1.2 PicoBot
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 PicoBot
- en: '*Leap before you look.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*先跳后看*。'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —W.H. Auden
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——W.H. 奥登
- en: 'The best way for you to get a feel for computer science is to jump right in
    and start solving a computer science problem. So let’s do just that. In this section,
    we’ll examine solutions to an important problem: How to make sure you’ll never
    have to clean–or at least vacuum–your room again. To solve this problem we’ll
    use a simple programming language named Picobot that controls a robot loosely
    based on the Roomba vacuum cleaner robot.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 感受计算机科学最好的方法就是立即着手解决一个计算机科学问题。所以我们就这么做吧。在这一部分，我们将研究如何解决一个重要问题的解决方案：如何确保你永远不必再清理房间——至少不必再吸尘。为了解决这个问题，我们将使用一个名为
    Picobot 的简单编程语言，它控制着一个松散基于 Roomba 吸尘器机器人的机器人。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*This web site offers a simulation environment for exploring Picobot’s capabilities*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个网站提供了一个模拟环境，用于探索 Picobot 的功能*'
- en: You’re probably wondering what happened to Python, the programming language
    we said we would be using throughout this book. Why are we sweeping Python under
    the carpet and brushing aside the language that we plan to use for the remainder
    of the book? The answer is that although Python is a simple (but powerful!) programming
    language that’s easy to learn, Picobot is an *even simpler* language that’s *even
    easier* to learn. The entire language takes only a few minutes to learn and yet
    it allows you to do some very powerful and interesting computation. So, we’ll
    be able to start some serious computer science before we get sucked into a discussion
    of a full-blown programming language. This will be new and fun–and whether you
    have programmed before, it should offer a “Eureka!” experience. So, dust off your
    browser and join us at [http://www.cs.hmc.edu/picobot](http://www.cs.hmc.edu/picobot).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 Python 发生了什么，我们说过我们将在本书中使用它。为什么我们将 Python 掩藏起来，搁置我们计划在本书剩余部分中使用的语言？答案是，虽然
    Python 是一种简单（但强大！）的编程语言，易于学习，但 Picobot 是一种*更简单*的语言，学习起来*更容易*。整个语言只需几分钟即可学会，但它可以让你进行一些非常强大且有趣的计算。因此，我们将能够在陷入对完整编程语言的讨论之前开始进行一些严肃的计算机科学。这将是新鲜有趣的——无论你以前是否曾经编程，它都应该给你带来一次“啊哈！”的体验。所以，打开你的浏览器，加入我们：[http://www.cs.hmc.edu/picobot](http://www.cs.hmc.edu/picobot)。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Or, at least, the “breakout” app that enable the industry’s first large-scale
    profits.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*或者，至少是使行业首次获得大规模利润的“突破”应用程序。*'
- en: '![../Images/roomba.jpg](../Images/roomba.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/roomba.jpg](../Images/roomba.jpg)'
- en: '*An iRobot Roomba. You’ll notice that we use the word “Picobot” to refer to
    both the Roomba robot and the language that we will use to program it.* *Actually,
    Picobot might not be able to actually “see” at all. Instead, it might sense its
    environment though one of many possible sensors including bump sensors, infrared,
    camera, lasers, etc.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个 iRobot Roomba。你会注意到我们用“Picobot”这个词来指代 Roomba 机器人以及我们将用来编程它的语言。* *实际上，Picobot
    可能根本无法“看见”。相反，它可能通过许多可能的传感器之一感知其环境，包括触碰传感器、红外线、摄像头、激光等。*'
- en: 1.2.1 The Roomba Problem
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 Roomba 问题
- en: 'It is the humblest of tasks–cleaning up–that has turned out to be the “killer
    app” for household robots. Imagine yourself as a Roomba vacuum named Picobot:
    your goal is to suck up the debris from the free space around you- ideally without
    missing any nooks or crannies. The robotics community calls this *the coverage
    problem*: it is the task of ensuring that all the grass is mown, all the surface
    receives paint, or all the Martian soil is surveyed.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 清理工作——最平凡的任务——竟然成为家用机器人的“杀手级应用”。想象一下自己是一台名为 Picobot 的 Roomba 吸尘器：你的目标是清理周围空闲空间的杂物——理想情况下不会漏掉任何角落。机器人界称之为
    *覆盖问题*：确保所有草坪都被修剪、所有表面都被涂漆，或所有火星土壤都被测量。
- en: At first this problem might seem pretty easy. After all, if your parents gave
    you a vacuum cleaner and told you to vacuum your room without missing a spot,
    you’d probably do a pretty great job without even thinking too much about it.
    Shouldn’t it be straightforward to convey your strategy to a robot?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这个问题可能看起来很容易。毕竟，如果你的父母给了你一台吸尘器，并告诉你要吸干净房间而不要漏掉任何地方，你可能会做得相当出色，甚至都不需要太多思考。把你的策略传达给一个机器人应该很简单，对吧？
- en: Unfortunately, there are a couple of obstacles that make the Picobot’s job considerably
    more difficult than yours. First, Picobot has very limited “sight”; it can only
    sense what’s directly around it. Second, Picobot is totally unfamiliar with the
    environment it is supposed to clean. While you could probably walk around your
    room blindfolded without crashing into things, Picobot is not so lucky. Third,
    Picobot has a very limited memory. In fact, it can’t even remember which part
    of the room it has seen and which part it has not.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有几个障碍使得 Picobot 的工作比你的工作要困难得多。首先，Picobot 的“视力”非常有限；它只能感知到其周围的东西。其次，Picobot
    完全不熟悉它应该清理的环境。虽然你可能能够闭着眼睛在房间里走动而不撞到东西，但 Picobot 就没那么幸运了。第三，Picobot 的记忆能力非常有限。事实上，它甚至无法记住房间的哪一部分是它见过的，哪一部分是它没见过的。
- en: While these challenges make Picobot’s job (and our job of programming Picobot)
    more difficult, they also make the coverage problem an interesting and non-trivial
    computer science problem worth serious study.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些挑战使得 Picobot 的工作（以及我们编程 Picobot 的工作）变得更加困难，但它们也使得覆盖问题成为一个有趣且非平凡的计算机科学问题，值得认真研究。
- en: 1.2.2 The Environment
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 环境
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*“Discretize” is CS-speak for “break up into individual pieces”.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*“离散化”是计算机术语，意思是“将其分解为单独的部分”。*'
- en: Our first task in solving this problem is to represent it in a way that the
    computer can handle. In other words, we need to define the data we will be working
    with to solve this problem. For example, how will we represent where the obstacles
    in the room are? Where Picobot is? We could represent the room as a plane, and
    then list the coordinates of the object’s corners and the coordinates of Picobot’s
    location. While this representation is reasonable, we will actually use a slightly
    simpler approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一个任务是以计算机可处理的方式表示它。换句话说，我们需要定义我们将用来解决这个问题的数据。例如，我们将如何表示房间中的障碍物？Picobot
    的位置在哪里？我们可以将房间表示为一个平面，然后列出对象的角落坐标和 Picobot 位置的坐标。虽然这种表示是合理的，但我们实际上会使用稍微简单的方法。
- en: 'Whether lawn or sand, an environment is simpler to cover if it is discretized
    into cells as shown in Figure 1.2\. This is our first example of an abstraction:
    we are ignoring the details of the environment and simplifying it into something
    we can easily work with. You, as Picobot, are similarly simplified: you occupy
    one grid square (the green one), and you can travel one step at a time in one
    of the four compass directions: north, east, west, or south.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是草地还是沙子，如果将环境离散化为如图 1.2 所示的单元格，覆盖起来就更简单了。这是我们抽象的第一个示例：我们忽略了环境的细节，并将其简化为我们可以轻松处理的东西。你作为
    Picobot，同样也被简化了：你占据一个网格方块（绿色的方块），可以沿着四个罗盘方向之一一次移动一步：北、东、西或南。
- en: 'Picobot cannot travel onto obstacles (the blue cells–which we will also call–”walls”);
    as we mentioned above, it does not know the positions of those obstacles ahead
    of time. What Picobot can sense is its immediate surroundings: the four cells
    directly to its north, east, west, or south. The surroundings are always reported
    as a string of four letters in **“NEWS”** order, meaning that we first see what
    is in our neighboring cell to the **N**orth, next what’s to the **E**ast, then
    **W**est, and finally **S**outh. If the cell to the north is empty, the letter
    in the first position is an `x`. If the cell to the north is occupied, the letter
    in that first position is an N. The second letter, an `x` or an `E`, indicates
    whether the eastern neighbor is empty or occupied; the third, `x` or `W`, is the
    west; the fourth, `x` or `S`, is the south. At its position in the lower-left-hand
    corner of Figure 1.2, for example, Picobot’s sensors would report its four-letter
    surroundings as `xxWS`. There are sixteen possible surroundings for Picobot, shown
    in Figure 1.3 with their textual representations.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Picobot不能穿过障碍物（蓝色单元格-我们也将其称为“墙壁”）；正如我们上面提到的，它不知道障碍物的位置。Picobot能感知的是它的周围环境：北、东、西或南的四个单元格。环境总是按照**“NEWS”**顺序报告，这意味着我们首先看到北边的邻居单元格，接下来是东边的情况，然后是西边，最后是南边。如果北边的单元格为空，第一个位置的字母是`x`。如果北边的单元格被占据，该位置的第一个字母是N。第二个字母，`x`或`E`，表示东边的邻居是空的还是被占据；第三个，`x`或`W`，是西边；第四个，`x`或`S`，是南边。例如，在图1.2左下角的位置，Picobot的传感器会报告它的四个字母周围环境为`xxWS`。Picobot有十六种可能的周围环境，用它们的文本表示在图1.3中展示。
- en: '[![../Images/picoRules.jpg](../Images/picoRules.jpg)](../Images/picoRules.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/picoRules.jpg](../Images/picoRules.jpg)](../Images/picoRules.jpg)'
- en: 'Figure 1.2: There are four types of cells in a Picobot environment, or map:
    green is Picobot itself, blue cells are walls, and gray cells are free space.
    Picobot can’t sense whether a empty cell has been visited or not (dark or light
    gray), but it can sense whether each of its four immediate neighbors is free space
    or an obstacle.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：Picobot环境或地图中有四种类型的单元格：绿色是Picobot本身，蓝色单元格是墙壁，灰色单元格是自由空间。Picobot无法感知空单元格是否已被访问（深灰色或浅灰色），但它可以感知其四个直接邻居中的每一个是自由空间还是障碍物。
- en: '[![../Images/picoPossibilities.jpg](../Images/picoPossibilities.jpg)](../Images/picoPossibilities.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/picoPossibilities.jpg](../Images/picoPossibilities.jpg)](../Images/picoPossibilities.jpg)'
- en: 'Figure 1.3: There are sixteen possible surroundings strings for Picobot. The
    one in which Picobot is completely enclosed will not occur in our simulator!'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：Picobot有十六种可能的周围字符串。在我们的模拟器中，Picobot完全被包围的情况不会发生！
- en: 1.2.3 State
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 状态
- en: As we’ve seen, Picobot can sense its immediate surroundings. This will be important
    in its decision-making process. For example, if Picobot is in the process of moving
    north and it senses that the cell to its north is a wall, it should not try to
    continue moving north! In fact, the simulator will not allow it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Picobot可以感知其周围环境。这将对其决策过程至关重要。例如，如果Picobot正在向北移动，并且感知到北边的单元格是墙壁，它就不应该继续向北移动！事实上，模拟器也不会允许这样做。
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*I’m currently in an inquisitive state.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*我目前处于一个好奇的状态。*'
- en: 'But how does Picobot “know” whether it is moving north or some other direction?
    Picobot doesn’t have an innate sense of direction. Instead, we make use of a powerful
    concept called *state*. The state of a computer (or a person or almost any other
    thing) is simply its current condition: on or off, happy or sad, underwater or
    in outer space, etc. In computer science, we often use “state” to refer to the
    internal information that describes what a computer is doing.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Picobot如何“知道”自己是在向北移动还是其他方向呢？Picobot没有固有的方向感。相反，我们利用了一个强大的概念，称为*状态*。计算机（或人或几乎任何其他事物）的状态简单地是它的当前状态：开或关，快乐或悲伤，水下或外太空等。在计算机科学中，我们经常使用“状态”来指代描述计算机正在做什么的内部信息。
- en: 'Picobot’s state is extremely simple: it is a single number in the range 0-99\.
    Somewhat surprisingly, that’s enough to give Picobot some pretty complex behaviors.
    **Picobot always starts in state 0.**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Picobot的状态非常简单：它是一个在0-99范围内的单个数字。有点令人惊讶的是，这已经足以赋予Picobot一些相当复杂的行为。**Picobot总是从状态0开始。**
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*The state of anything can be described with a set of numbers.. but describing
    human states would take at least trillions of values*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*The state of anything can be described with a set of numbers.. but describing
    human states would take at least trillions of values*'
- en: Although Picobot’s state is numeric, it’s helpful to think of it in English
    terms. For example, we might think of state 0 as meaning “I’m heading north until
    I can’t go any further.” However, it’s important to note that none of the state
    numbers has any special built-in meaning; it is up to us to make those decisions.
    Moreover, Picobot doesn’t actually have a sense of which directions it is pointing.
    But we can define our own conception of which direction Picobot is “pointing”
    by defining an appropriate set of states.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Although Picobot’s state is numeric, it’s helpful to think of it in English
    terms. For example, we might think of state 0 as meaning “I’m heading north until
    I can’t go any further.” However, it’s important to note that none of the state
    numbers has any special built-in meaning; it is up to us to make those decisions.
    Moreover, Picobot doesn’t actually have a sense of which directions it is pointing.
    But we can define our own conception of which direction Picobot is “pointing”
    by defining an appropriate set of states.
- en: For example, imagine that Picobot wants to perform the task of continually moving
    north until it gets to a wall. We might decide that state 3 means “I’m heading
    north until I can’t go any further (and when I get to a wall to my north, then
    I’ll consider what to do next!).” When Picobot gets to a wall, it might want to
    enter a new state such as “I’m heading west until I can’t go any further (and
    when I get to a wall to my west, I’ll have to think about what to do then!).”
    We might choose to call that state 42 (or state 4; it’s entirely up to us).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: For example, imagine that Picobot wants to perform the task of continually moving
    north until it gets to a wall. We might decide that state 3 means “I’m heading
    north until I can’t go any further (and when I get to a wall to my north, then
    I’ll consider what to do next!).” When Picobot gets to a wall, it might want to
    enter a new state such as “I’m heading west until I can’t go any further (and
    when I get to a wall to my west, I’ll have to think about what to do then!).”
    We might choose to call that state 42 (or state 4; it’s entirely up to us).
- en: '![../Images/states.PNG](../Images/states.PNG)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/states.PNG](../Images/states.PNG)'
- en: 'Figure 1.4: The five parts of two Picobot rules. One useful way to interpret
    the idea of state is to attribute a distinct intention to each state. With these
    two rules, Picobot’s initial state (state 0) represents “go west as far as possible.”'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 1.4: The five parts of two Picobot rules. One useful way to interpret
    the idea of state is to attribute a distinct intention to each state. With these
    two rules, Picobot’s initial state (state 0) represents “go west as far as possible.”'
- en: As we’ll see next, your job as the Picobot programmer is to define the states
    and their meanings; this is what controls Picobot and makes it do interesting
    things!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: As we’ll see next, your job as the Picobot programmer is to define the states
    and their meanings; this is what controls Picobot and makes it do interesting
    things!
- en: '**Takeaway message:** *The state is simply a number representing a task that
    you would like Picobot to undertake.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Takeaway message:** *The state is simply a number representing a task that
    you would like Picobot to undertake.*'
- en: 1.2.4 Think locally, act globally
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 Think locally, act globally
- en: Now we know how to represent Picobot’s surroundings, and how to represent its
    state. But how do we make Picobot *do* anything?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Now we know how to represent Picobot’s surroundings, and how to represent its
    state. But how do we make Picobot *do* anything?
- en: 'Picobot moves by following a set of rules that specify actions and possibly
    state changes. Which rule Picobot chooses to follow depends on its current state
    and its current surroundings. Thus, Picobot’s complete “thought process” is as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'Picobot moves by following a set of rules that specify actions and possibly
    state changes. Which rule Picobot chooses to follow depends on its current state
    and its current surroundings. Thus, Picobot’s complete “thought process” is as
    follows:'
- en: I take stock of my current state and immediate surroundings.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: I take stock of my current state and immediate surroundings.
- en: Based on that information, I find a rule that tells me (1) a direction to move
    and (2) the state I want to be in next.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Based on that information, I find a rule that tells me (1) a direction to move
    and (2) the state I want to be in next.
- en: Picobot uses a five-part rule to express this thought process. Figure 1.4 shows
    two examples of such rules.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Picobot uses a five-part rule to express this thought process. Figure 1.4 shows
    two examples of such rules.
- en: The first rule,
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: The first rule,
- en: '`0 xxWx -> E 1`'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 xxWx -> E 1`'
- en: re-expressed in English, says “If I’m in state 0 and only my western neighbor
    contains an obstacle, take one step east and change into state 1.” The second
    rule,
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: re-expressed in English, says “If I’m in state 0 and only my western neighbor
    contains an obstacle, take one step east and change into state 1.” The second
    rule,
- en: '`0 xxxx -> W 0`'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 xxxx -> W 0`'
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Go west, young Picobot!*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*Go west, young Picobot!*'
- en: says “If I’m in state 0 with no obstacles around me, move one step west and
    stay in state 0.” Taken together, these two rules use local information to direct
    Picobot across an open area westward to a boundary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: says “If I’m in state 0 with no obstacles around me, move one step west and
    stay in state 0.” Taken together, these two rules use local information to direct
    Picobot across an open area westward to a boundary.
- en: '[![../Images/movingPico.jpg](../Images/movingPico.jpg)](../Images/movingPico.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/movingPico.jpg](../Images/movingPico.jpg)](../Images/movingPico.jpg)'
- en: 'Figure 1.5: The result of running Picobot with this section’s four rules.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：运行 Picobot 后得到的结果，使用了本节的四条规则。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Remember that Picobot always begins its mission in state 0*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住，Picobot 总是从状态 0 开始执行任务。*'
- en: 'At each step, Picobot examines the list of rules that you’ve written looking
    for the *one* rule that applies. A rule applies if the state part of the rule
    matches Picobot’s current state and the surroundings part of the rule matches
    the current surroundings. What happens if there are NO rules that match Picobot’s
    current state and surroundings? The Picobot simulator will let you know about
    this in its *Messages* box and the robot will stop running. Similarly, if more
    than one rule applies, Picobot will also complain. Figure 1.5 shows how Picobot
    follows the first rule that matches its current state and surroundings at each
    time step. But what about state 1? No rules specify Picobot’s actions in state
    1-yet! Just as state 0 represents the “go west” task, we can specify two rules
    that will make state 1 be the “go east” task:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，Picobot 都会检查你编写的规则列表，寻找适用的*一条*规则。如果规则的状态部分与 Picobot 的当前状态匹配，并且规则的环境部分与当前环境匹配，则该规则适用。如果没有规则与
    Picobot 的当前状态和环境匹配会发生什么呢？Picobot 模拟器会在其*消息*框中告诉你，并且机器人会停止运行。同样地，如果有多条规则适用，Picobot
    也会抱怨。图 1.5 显示了 Picobot 如何遵循每个时间步骤中与其当前状态和环境匹配的第一条规则。但是状态 1 呢？还没有规则指定 Picobot 在状态
    1 中的动作！就像状态 0 代表“向西走”的任务一样，我们可以指定两条规则，让状态 1 成为“向东走”的任务：
- en: '`1 xxxx -> E 1`'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 xxxx -> E 1`'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`1 xExx -> W 0`'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 xExx -> W 0`'
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Picobot cannot sense whether or not a cell has been visited. This limitation
    is quite realistic: the Roomba, for example, does not know whether a region has
    already been cleaned.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Picobot 无法感知单元格是否被访问过。这种限制非常现实：例如，Roomba 并不知道一个区域是否已经被清扫过。*'
- en: These rules transition back to state 0, creating an infinite loop back and forth
    across an open row. Try it out! Note that the Picobot website starts Picobot at
    a randomly selected empty cell. Note also that if Picobot starts along a top or
    bottom wall, no rules match and it does not move! We will remedy this defect in
    the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则会将状态回退到 0，创建一个来回穿越开放行的无限循环。试一试吧！注意，Picobot 网站会在随机选择的空单元格处启动 Picobot。还要注意，如果
    Picobot 从顶部或底部墙壁开始，没有规则匹配，它就不会移动！我们将在下一节解决这个缺陷。
- en: '![../Images/picoTable.PNG](../Images/picoTable.PNG)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/picoTable.PNG](../Images/picoTable.PNG)'
- en: 'Table 1.1: Two equivalent formulations of a more general “go-west-go-east”
    behavior for Picobot. Both sets of rules use only two states, but the wildcard
    character * allows for a much more succinct representation on the left than on
    the right!'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1：Picobot 更通用的“向西走-向东走”行为的两种等效表述。两套规则只使用了两个状态，但左侧的通配符字符 * 允许更简洁地表示，而右侧则不然！
- en: By the way, sometimes you might not want Picobot to move as the result of applying
    a rule. Rather than specifying a move direction (“E”, ‘W”, “N”, or “S”), you may
    use the upper-case letter “X” to indicate “stay where you are”. For example, the
    rule
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，有时你可能不希望 Picobot 根据应用规则而移动。与其指定一个移动方向（“E”、“W”、“N”或“S”），你可以使用大写字母“X”来表示“原地不动”。例如，规则
- en: '`0 Nxxx -> X 1`'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 Nxxx -> X 1`'
- en: is saying “if I’m in state 0 and there is a wall to the north, don’t move but
    enter state 1.”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 是说“如果我处于状态 0 并且北面有墙，不要移动但进入状态 1。”
- en: 1.2.5 Whatever
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.5 无论什么
- en: The problem with the previous “go-west-go-east” example is that the rules are
    too specific. When going west, we really don’t care whether or not walls are present
    to the north, south, or east. Similarly, when going east, we don’t care about
    neighboring cells to the north, south, or west. The wildcard character * indicates
    that we don’t care about the surroundings in the given position (N, E, W, or S).
    Table 1.1’s rules use the wildcard to direct Picobot to forever visit (vacuum)
    the east-west row in which it starts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前述“向西走-向东走”示例的问题在于规则过于具体。在向西走时，我们实际上不关心北、南或东是否存在墙壁。同样地，向东走时，我们不关心北、南或西的相邻单元格。通配符字符
    * 表示我们不关心给定位置（N、E、W 或 S）的环境。表 1.1 的规则使用通配符指导 Picobot 永远访问（清扫）其起始的东西向行。
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*Picobot needs to get over its “don’t care” attitude!*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Picobot 需要克服它的“不在乎”态度！*'
- en: 1.2.6 Algorithms and Rules
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.6 算法和规则
- en: 'So far we’ve looked at how to write rules that make Picobot move. But in trying
    to solve problems with Picobot, it’s usually helpful to take a more global view
    of how Picobot is accomplishing its task, and then to translate that approach
    into rules. In other words, we want to develop an algorithm that allows Picobot
    to accomplish the desired task, where that task is usually to cover the entire
    room. In the previous section, Picobot had the more modest goal of simply moving
    back and forth in an empty room. The algorithm for accomplishing this task was
    the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过如何编写让 Picobot 移动的规则。但是在尝试用 Picobot 解决问题时，通常有助于更全面地看待 Picobot 是如何完成任务的，然后将这种方法转化为规则。换句话说，我们希望制定一种算法，使
    Picobot 能够完成所需的任务，而这个任务通常是覆盖整个房间。在前一节中，Picobot 的目标是在一个空房间中简单地来回移动。完成这个任务的算法如下：
- en: Move west until Picobot hits a wall to the west
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向西移动，直到 Picobot 碰到西边的墙
- en: Then move east until Picobot hits a wall to the east
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后向东移动，直到 Picobot 碰到东边的墙
- en: Then go back to step 1
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后回到步骤 1
- en: 'Now the question becomes: how do we translate this algorithm into the rules
    from the previous section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题变成了：如何将这个算法转化为前一节中的规则：
- en: '`0 **x* -> W 0`'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 **x* -> W 0`'
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0 **W* -> E 1`'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 **W* -> E 1`'
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`1 *x** -> E 1`'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 *x** -> E 1`'
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`1 *E** -> W 0`'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 *E** -> W 0`'
- en: 'As written, it is difficult to see the connection between the steps of the
    algorithm and the Picobot rules. We can see that Picobot will need two states
    to keep track of which direction it is moving (i.e., is it in step 1 or step 2),
    but it’s still not exactly clear how the algorithm translates into precise rules.
    Essentially, each of Picobot’s rules applies in an “if-then” fashion. In other
    words, if Picobot is in a particular state and sees a particular environment,
    then it takes a certain action and potentially enters a new state. With some minor
    modifications, we can rewrite the algorithm above to follow Picobot’s “if-then”
    rule structure more directly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如此写作，很难看出算法步骤与 Picobot 规则之间的联系。我们可以看到 Picobot 需要两个状态来跟踪它的移动方向（即它是在步骤 1 还是步骤
    2），但仍然不清楚算法如何精确转化为规则。基本上，Picobot 的每条规则都是以“如果-那么”的方式应用的。换句话说，如果 Picobot 处于特定状态并看到特定环境，那么它会采取某种行动并可能进入新状态。通过一些小的修改，我们可以重写上面的算法，更直接地遵循
    Picobot 的“如果-那么”规则结构：
- en: 'Repeat the following steps forever:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永远重复以下步骤：
- en: If Picobot is moving west and there is no wall to the west, then keep moving
    west.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Picobot 正在向西移动，并且西边没有墙壁，那么继续向西移动。
- en: If Picobot is moving west and there is a wall to the west, then start moving
    east.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Picobot 正在向西移动，并且西边有一堵墙，那么开始向东移动。
- en: If Picobot is moving east and there is no wall to the east, then keep moving
    east.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Picobot 正在向东移动，并且东边没有墙壁，那么继续向东移动。
- en: If Picobot is moving east and there is a wall to the east, then start moving
    west.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Picobot 正在向东移动，并且东边有墙壁，那么开始向西移动。
- en: 'Now we can see more clearly the direct translation between the steps of this
    algorithm and the Picobot rules: each step in the algorithm translates directly
    into a rule in Picobot, where state 0 represents “Picobot is movingWest” and state
    1 represents “Picobot is moving East”. Formulating algorithms in this way is the
    key to writing successful programs in Picobot.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更清楚地看到这个算法步骤与 Picobot 规则之间的直接对应关系：算法中的每一步直接转化为 Picobot 中的一条规则，其中状态 0 代表“Picobot
    正在向西移动”，状态 1 代表“Picobot 正在向东移动”。以这种方式制定算法是编写 Picobot 成功程序的关键。
- en: 1.2.7 The Picobot challenge
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.7 Picobot 挑战
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*This back-and-forth nwonk saw euqinhcet to ancient Greek ox- ti dellac ohw
    srevird “boustrophedon.” Text in some classical nwonk si stpircsunam to show the
    same .nrettap*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种来回走的方式被认为是古希腊的一种古老的方式，被称为“boustrophedon”。一些古典文本中的文字是倒着排列的以显示相同的内容。*'
- en: Table 1.1’s rules direct Picobot to visit the entirety of its starting row.
    This section’s challenge is to develop a set of rules that direct Picobot to cover
    the entirety of an empty rectangular room, such as the rooms in Figure 1.2 and
    1.5\. The set of rules–that is, your program–should work regardless of how big
    the room is and regardless of where Picobot initially begins.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 的规则指导 Picobot 访问其起始行的全部内容。本节的挑战是制定一组规则，指导 Picobot 覆盖一个空的矩形房间的全部内容，例如图
    1.2 和 1.5 中的房间。这组规则——也就是你的程序——应该能够在房间有多大以及 Picobot 最初在哪里开始的情况下都能正常工作。
- en: Because Picobot does not distinguish already-visited from unvisited cells, it
    may not know when it has visited every cell. The online simulator, however, will
    detect and report a successful, complete traversal of an environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Picobot 不能区分已访问的单元格和未访问的单元格，因此它可能不知道它何时已经访问了每个单元格。然而，在线模拟器将检测并报告对环境的成功完整遍历。
- en: Try it out. You might find it helpful to simply play around with modifying the
    rules we’ve given you here. For example, you might start by altering the rules
    in Figure 1.1 so that they side-step into a neighboring row after clearing the
    current one. However, once you have an idea for how you might solve the problem,
    we encourage you to plan your algorithm, and then express that algorithm in a
    way that is easily translatable into Picobot rules.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看。您可能会发现简单地玩弄我们在这里给出的规则有所帮助。例如，您可以从修改图 1.1 中的规则开始，以便在清除当前行后侧向相邻行。但是，一旦您对如何解决问题有了想法，我们鼓励您计划您的算法，然后以一种易于转换为
    Picobot 规则的方式表达该算法。
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*Thank you for sparing us from any corny maize jokes.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*感谢您没有说任何无聊的玉米笑话。*'
- en: 1.2.8 A-Maze Your Friends!
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.8 迷住您的朋友们！
- en: Once you’ve developed a Picobot program that completely traverses the empty
    room, try to write other programs for more complex environments. You’ll see a
    “MAP” option on the Picobot Web page where you can scroll forward or backward
    through a collection of maps that we’ve created. You can also edit these maps
    by clicking on a cell with your mouse; clicking on an empty cell turns it into
    a wall and clicking on a wall turns it into an empty cell. *Remember that your
    program should work no matter where Picobot begins.*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个完全遍历空房间的 Picobot 程序后，尝试编写其他更复杂环境的程序。您会在 Picobot 网页上看到一个“MAP”选项，您可以通过它向前或向后滚动我们创建的地图集合。您也可以通过鼠标单击单元格来编辑这些地图；单击空单元格将其变为墙壁，单击墙壁将其变为空单元格。*请记住，您的程序应该在
    Picobot 开始的任何位置都能正常工作*。
- en: '![../Images/maze.jpg](../Images/maze.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/maze.jpg](../Images/maze.jpg)'
- en: 'Figure 1.6: Picobot’s maze.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1.6: Picobot 的迷宫。'
- en: One environment that is particularly interesting is the maze shown in Figure
    1.6\. Notice that in this maze, all the walls are connected to the outer boundary
    and all empty cells are adjacent to a wall. A smaller maze with this property
    is shown in Figure 1.7(a). Any maze with this property can be completely explored
    with a simple algorithm called the *right-hand rule* (or the *left-hand rule*
    if you prefer).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有趣的环境是图 1.6 中显示的迷宫。请注意，在这个迷宫中，所有的墙都连接到外部边界，而所有的空单元格都相邻于墙壁。具有这种属性的较小迷宫如图
    1.7(a) 所示。任何具有这种属性的迷宫都可以用一个简单的算法完全探索，称为*右手法则*（或者如果您喜欢的话，是*左手法则*）。
- en: Imagine for a moment that you are in the maze rather than Picobot. In contrast
    to Picobot, you have a clear sense of the direction you’re pointing and you have
    two hands. You start facing north with your right hand touching the wall. Now,
    you can visit every empty cell by simply walking through the maze, making sure
    that your right hand is always touching the wall. Pause here for a moment to convince
    yourself that this is true. Notice also that this algorithm will not visit every
    cell if some walls are not connected to the outer boundary, as shown in the maze
    in Figure 1.7(b) or if some empty cells are not adjacent to a wall, as shown in
    Figure 1.7(c).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您是迷宫中的人，而不是 Picobot。与 Picobot 相比，您有一个明确的指向和两只手。您从北方开始，右手碰到墙壁。现在，您可以通过简单地沿着迷宫行走，并确保您的右手始终触摸墙壁来访问每个空单元格。暂停片刻，说服自己这是真的。还要注意，如果一些墙壁未连接到外部边界，如图
    1.7(b) 中所示的迷宫，或者如果一些空单元格不相邻于墙壁，如图 1.7(c) 所示，这种算法将不会访问每个单元格。
- en: '![../Images/threemazes.jpg](../Images/threemazes.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/threemazes.jpg](../Images/threemazes.jpg)'
- en: 'Figure 1.7: (a) A maze in which all walls are connected to the outer boundary
    and all empty cells are adjacent to a wall. (b) A maze in which some walls are
    not connected to the outer boundary. (c) A maze in which some empty cells are
    not adjacent to walls.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1.7: (a) 所有墙壁都连接到外部边界，所有空单元格都相邻于墙壁的迷宫。 (b) 一些墙壁未连接到外部边界的迷宫。 (c) 一些空单元格不相邻于墙壁的迷宫。'
- en: Converting the right-hand rule into a set of Picobot rules is an interesting
    computational challenge. After all, you have a sense of direction and you have
    a right hand that was guiding you around the walls, whereas Picobot has neither
    hands nor a sense of orientation. To “teach” Picobot the right-hand rule, we’ll
    again need to use states to represent the direction that Picobot is pointing.
    It may seem that an impossibly large number of situations must be considered,
    but in fact, the number of situations is finite and actually quite small, which
    makes it possible to program Picobot for this task.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将右手法则转化为一组 Picobot 规则是一个有趣的计算挑战。毕竟，你有方向感，有一只右手在墙边引导着你，而 Picobot 既没有手，也没有方向感。为了“教导”
    Picobot 右手法则，我们需要再次使用状态来表示 Picobot 所指的方向。可能会觉得需要考虑的情况数量非常多，但实际上情况是有限的，而且数量相当少，这使得为
    Picobot 设计这个任务成为可能。
- en: To get started, it seems pretty natural to use the four states 0, 1, 2, and
    3 to represent Picobot pointing north, south, east, or west. Now, we’ll need to
    introduce rules that allow Picobot to behave as if it had a right hand to touch
    against the wall.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，使用四个状态 0、1、2 和 3 来表示 Picobot 指向北、南、东或西似乎是相当自然的。现在，我们需要引入规则，让 Picobot 能够表现得好像它有一只右手可以触摸墙壁。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Of course, all empty cells must be reachable. If some cells are isolated from
    others, the problem is just physically impossible.*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*当然，所有空单元格必须是可达的。如果有些单元格与其他单元格隔离开来，那么问题就是物理上不可能的。*'
- en: Assume we are in state 0, which we (arbitrarily) choose to correspond to representing
    Picobot pointing north. Picobot’s imaginary right hand is then pointing east.
    If there is a wall to the east and none to the north, the right-hand rule would
    tell us to take a step to the north and keep pointing north. Taking a step to
    the north is no problem. “Keep pointing north” means “stay in state 0.” On the
    other hand, if we are in state 0 and there is no wall to the east, Picobot should
    take a step to the east and think of itself as pointing to the east. “Pointing
    east” will mean changing to another state that is intended to encode that information.
    This is a fun challenge and we encourage you to stop here and try it. (Remember,
    your program should work regardless of where Picobot starts and for any maze with
    the property that all walls are connected to the outer boundary and all empty
    cells are adjacent to a wall.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们处于状态 0，我们（任意地）选择它表示 Picobot 指向北。Picobot 的想象中右手指向东。如果东边有墙而北边没有，右手法则会告诉我们向北迈一步并继续指向北。向北迈一步不是问题。“继续指向北”意味着“保持在状态
    0”。另一方面，如果我们处于状态 0 而东边没有墙，Picobot 应该向东迈一步，并将自己想象成指向东。所谓的“指向东”意味着改变到另一个打算编码该信息的状态。这是一个有趣的挑战，我们鼓励你停下来尝试一下。（请记住，你的程序应该能够在
    Picobot 的起始位置和具有以下特性的任何迷宫中工作：所有墙都与外部边界相连，所有空单元格都与墙相邻。）
- en: 1.2.9 Uncomputable environments
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.9 无法计算的环境
- en: Is it possible to write a Picobot program that will fully explore any room that
    we give it? Surprisingly, the answer is “no,” and it’s possible to prove that
    fact mathematically. Picobot’s computational capabilities aren’t enough to guarantee
    coverage of all environments. However, by adding one simple feature to Picobot,
    it can be programmed to fully explore any room. That feature is the ability to
    drop, sense, and pick up “markers” along the way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可能编写一个 Picobot 程序，使其完全探索我们给出的任何房间？令人惊讶的是，答案是“不”，并且可以通过数学证明这一事实。Picobot 的计算能力不足以保证覆盖所有环境。但是，通过向
    Picobot 添加一个简单的功能，它可以被编程以完全探索任何房间。该功能是沿途放置、感知和拾取“标记”。
- en: The fact that computational challenges as elementary as Picobot lead us to *provably
    unsolvable problems* suggests that computation and computers are far from omnipotent.
    And by the time you’re done reading this book, you’ll have learned how to prove
    that certain problems are beyond the limits of what computers can solve.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 计算挑战的基本性质之一是，像 Picobot 这样的问题会导致 *可以证明无法解决的问题*，这表明计算和计算机远非万能。当你读完这本书时，你将学会如何证明某些问题超出了计算机可以解决的范围。
