- en: 'Chapter 4: Computer Organization'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '-   第四章：计算机组织'
- en: '*Computers are useless. They can only give you answers.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '-   *计算机是无用的。它们只能给你答案。*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Pablo Picasso
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '-   ——巴勃罗·毕加索'
- en: 4.1 Introduction to Computer Organization
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '-   4.1 计算机组织简介'
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '-   ![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*Hey!*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '-   *嘿！*'
- en: When we run a Python program, what’s actually going on inside the computer?
    While we hope that recursion is feeling less like magic to you now, the fact that
    an electronic device can actually interpret and execute something as complicated
    as a recursive program may seem - what’s the right word here? - *alien.* The goal
    of this chapter is to metaphorically pry the lid off a computer and peer inside
    to understand what’s really going on there.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '-   当我们运行一个Python程序时，计算机内部到底发生了什么？虽然我们希望递归对你来说不再像魔术一样神秘，但一个电子设备实际上能够解释和执行像递归程序这样复杂的东西，可能看起来
    - 这里应该用什么词呢？ - *陌生*。本章的目标是像隐喻一样打开计算机的盖子，向内部窥视，了解那里到底发生了什么。'
- en: As you can imagine, a computer is a complicated thing. A modern computer has
    on the order of billions of transistors. It would be impossible to keep track
    of how all of those components interact. Consequently, computer scientists and
    engineers design and think about computers using what are called *multiple levels
    of abstraction* . At the lowest level are components like transistors - the fundamental
    building blocks of modern electronic devices. Using transistors, we can build
    higher level devices called *logic gates* - they are the next level of abstraction.
    From logic gates we can build electronic devices that add, multiply, and do other
    basic operations - that’s yet another level of abstraction. We keep moving up
    levels of abstraction, building more complex devices from more basic ones.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '-   正如你所想象的，计算机是一件复杂的东西。一台现代计算机拥有数十亿个晶体管。要跟踪所有这些组件如何互动是不可能的。因此，计算机科学家和工程师使用所谓的*多个抽象级别*来设计和思考计算机。在最低级别是像晶体管这样的组件
    - 现代电子设备的基本构建块。使用晶体管，我们可以构建更高级别的设备，称为*逻辑门* - 这是下一个抽象级别。从逻辑门我们可以构建执行加法、乘法和其他基本操作的电子设备
    - 这又是另一个抽象级别。我们不断向上移动抽象级别，从更基本的设备构建更复杂的设备。'
- en: As a result, a computer can be designed by multiple people, each thinking about
    their specific level of abstraction. One type of expert might work on designing
    smaller, faster, and more efficient transistors. Another might work on using those
    transistors - never mind precisely how they work - to design better components
    that are based on transistors. Yet another expert will work on deciding how to
    organize these components into even more complex units that perform key computational
    functions. Each expert is grateful to be standing (metaphorically) on the shoulders
    of another person’s work at the next lower level of abstraction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '-   因此，一个计算机可以由多人设计，每个人都考虑着他们特定的抽象级别。一种专家可能致力于设计更小、更快、更高效的晶体管。另一种可能致力于使用这些晶体管
    - 不要太在意它们的工作原理 - 来设计基于晶体管的更好的组件。另一位专家将致力于决定如何将这些组件组织成更复杂的单元，执行关键的计算功能。每位专家都感激地站在（隐喻上）另一个人在下一个更低抽象级别的工作成果上。'
- en: By analogy, a builder thinks about building walls out of wood, nails, and sheet
    rock. An architect designs houses using walls without worrying too much about
    how they are built. A city planner thinks about designing cities out of houses,
    without thinking too much how they are built, and so forth. This idea is called
    “abstraction” because it allows us to think about a particular level of design
    using the lower level ideas abstractly; that is, without having to keep in mind
    all of the specific details of what happens at that lower level.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '-   类比地，一个建筑师考虑用木头、钉子和石膏板建造墙壁。一位建筑师设计房屋时，使用墙壁而不太担心它们是如何建造的。一位城市规划师考虑用房屋设计城市，而不太考虑它们是如何建造的，依此类推。这个想法被称为“抽象”，因为它允许我们使用更低级别的抽象思考特定设计级别；也就是说，不必记住在较低级别发生的所有具体细节。'
- en: '![../Images/threelight.PNG](../Images/threelight.PNG)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '-   ![../Images/threelight.PNG](../Images/threelight.PNG)'
- en: 'Figure 4.1: A three-way light bulb.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '-   图4.1：一个三路灯泡。'
- en: This seemingly simple idea of abstraction is one of the most important ideas
    in computer science. Not only are computers designed this way, but software is
    as well. Once we have basic workhorse functions like `map`, `reduce`, and others,
    we can use those to build more complex functions. We can use those more complex
    functions in many places to build even more complex software. In essence, we modularize
    so we that we can reuse good things to build bigger good things.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似简单的抽象概念是计算机科学中最重要的概念之一。计算机不仅是按照这种方式设计的，软件也是如此。一旦我们有了像`map`、`reduce`等基本的工作函数，我们就可以使用它们来构建更复杂的函数。我们可以在许多地方使用这些更复杂的函数来构建更复杂的软件。本质上，我们模块化，这样我们就可以重复使用好的东西来构建更大的好东西。
- en: In this spirit, we’ll start by looking at how data is represented in a computer.
    Next, we’ll move up the levels of abstraction from transistors all the way up
    to a full-blown computer. We’ll program that computer in its own “native language”
    and talk about how your Python program ultimately gets translated to that language.
    By the end of this chapter, we’ll have a view of what happens when we run a program
    on our computer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本着这种精神，我们将首先看看计算机中数据是如何表示的。接下来，我们将从晶体管的抽象层级一直上升到一个完整的计算机。我们将用其自己的“本地语言”对该计算机进行编程，并讨论你的Python程序最终如何被翻译成该语言。在本章结束时，我们将了解在计算机上运行程序时发生了什么。
- en: 4.2 Representing Information
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 信息表示
- en: At the most fundamental level, a computer doesn’t really know math or have any
    notion of what it means to compute. Even when a machine adds 1+1 to get 2, it
    isn’t *really* dealing with numbers. Instead, it’s manipulating electricity according
    to specific rules.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，计算机实际上并不了解数学，也不知道计算的含义。即使一台机器将1+1相加得到2，它也*并非*在处理数字。相反，它是根据特定规则操纵电力。
- en: To make those rules produce something that is useful to us, we need to associate
    the electrical signals inside the machine with the numbers and symbols that we,
    as humans, like to use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些规则产生对我们有用的东西，我们需要将机器内部的电信号与我们作为人类喜欢使用的数字和符号相关联。
- en: 4.2.1 Integers
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 整数
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*That’s a shocking idea!*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个惊人的想法！*'
- en: The obvious way to relate electricity to numbers would be to assign a direct
    correspondence between voltage (or current) and numbers. For example, we could
    let zero volts represent the number 0, 1 volt be 1, 10 volts be 10, and so forth.
    There was a time when things were done this way, in so-called analog computers.
    But there are several problems with this approach, not the least of which would
    be the need to have a million-volt computer!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将电力与数字相关联的明显方法是在电压（或电流）和数字之间建立直接对应关系。例如，我们可以让零伏特代表数字0，1伏特代表1，10伏特代表10，依此类推。曾经有一段时间是这样做的，即所谓的模拟计算机。但是这种方法存在几个问题，其中最大的问题之一是需要拥有一台百万伏特的计算机！
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*Whose bright idea was this?*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是谁的绝妙主意？*'
- en: Here’s another approach. Imagine that we use a light bulb to represent numbers.
    If the bulb is off, the number is 0\. If the bulb is on, the number is 1\. That’s
    fine, but it only allows us to represent two numbers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一种方法。想象一下，我们使用一个灯泡来代表数字。如果灯泡熄灭，数字就是0。如果灯泡亮起，数字就是1。这很好，但只允许我们表示两个数字。
- en: 'All right then, let’s upgrade to a “three-way” lamp. A three-way lamp really
    has four switch positions: off, and three increasing brightness levels. Internally,
    a three-way bulb has two filaments (Figure 4.1), one dim and one bright. For example,
    one might be 50 watts, and the other 100\. By choosing neither of them, one, the
    other, or both, we can get 0, 50, 100, or 150 watts worth of light. We could use
    that bulb to represent the numbers 0, 50, 100, and 150 or we could decide that
    the four levels represent the numbers 0, 1, 2, and 3.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么让我们升级到一个“三档”灯泡。一个三档灯泡实际上有四个开关位置：关闭和三个逐渐增亮的亮度级别。在内部，一个三档灯泡有两根灯丝（图4.1），一根暗淡，一根明亮。例如，一根可能是50瓦，另一根是100瓦。通过选择两者中的任何一个，我们可以得到0、50、100或150瓦的光。我们可以使用该灯泡表示数字0、50、100和150，或者我们可以决定这四个级别代表数字0、1、2和3。
- en: Internally, a computer uses this same idea to represent integers. Instead of
    using 50, 100, and 200, as in our illuminating example above, computers use combinations
    of numbers that are powers of 2\. Let’s imagine that we have a bulb with a 20-watt
    filament, a 21-watt filament, and a 22-watt filament. Then we could make the number
    0 by turning none of the filaments on, we could make 1 by turning on only the
    20-watt filament, we could make 2 by turning on the 21-watt filament, and so forth,
    up to \(2^0 +2^1 +2^2 = 7\) using all three filaments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，计算机使用相同的思想来表示整数。 与我们上面的启示性示例中使用的50、100和200不同，计算机使用的是2的幂的组合。 假设我们有一个灯泡，有一个20瓦的灯丝，一个21瓦的灯丝和一个22瓦的灯丝。
    然后，我们可以通过打开灯丝来制造数字0，只打开20瓦的灯丝可以制造数字1，打开21瓦的灯丝可以制造数字2，依此类推，直到使用所有三个灯丝制造\(2^0 +
    2^1 + 2^2 = 7\)。
- en: 'Imagine now that we had the following four consecutive powers of 2 available
    to us: \(2^0 , 2^1 , 2^2 , 2^3\). Take a moment to try to write the numbers 0,
    1, 2, and so forth as high as you can go by using zero or one of each of these
    powers of 2\. Stop reading. We’ll wait while you try this.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们可以使用以下四个连续的2的幂：\(2^0 , 2^1 , 2^2 , 2^3\)。 想一会儿，尝试使用这些2的幂的每一个零或一个来编写数字0、1、2等，直到你能编写到尽可能高的数字。
    停止阅读。 当你尝试时我们会等待。
- en: 'If all went well, you discovered that you could make all of the integers from
    0 to 15 using 0 or 1 of each of these four powers of 2\. For example, 13 can be
    represented as \(2^0 +2^2 +2^3\) . Written another way, this is:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您会发现您可以使用这四个2的幂的每一个的0或1来制作从0到15的所有整数。 例如，13可以表示为\(2^0 + 2^2 + 2^3\) 。
    用另一种方式写，这是：
- en: \[13 = 1·2^3 + 1·2^2 + 0·2^1 + 1·2^0\]![../Images/Alien.PNG](../Images/Alien.PNG)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: \[13 = 1·2^3 + 1·2^2 + 0·2^1 + 1·2^0\]![../Images/Alien.PNG](../Images/Alien.PNG)
- en: '*There are 10 kinds of people in this world: Those who understand binary and
    those who don’t.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个世界上有10种人：懂二进制和不懂的人。*'
- en: Notice that we’ve written the larger powers of 2 on the left and the smaller
    powers of two on the right. This convention is useful, as we’ll see shortly. The
    0’s and 1’s in the equation above - the *coefficients* on the powers of 2 - indicate
    whether or not the particular power of 2 is being used. These 0 and 1 coefficients
    are called *bits*, which stands for *bi*nary digi*ts*. *Binary* means “using two
    values”- here, the 0 and the 1 are the two values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将更大的2的幂写在左边，较小的2的幂写在右边。 正如我们马上会看到的，这种约定很有用。 方程中的0和1 - 2的幂上的*系数* - 指示特定的2的幂是否被使用。
    这些0和1系数称为*比特*，代表*二*进制数*位*。 *二进制*意味着“使用两个值”-这里，0和1是两个值。
- en: It’s convenient to use the sequence of bits to represent a number, without explicitly
    showing the powers of two. For example, we would use the bit sequence 1101 to
    represent the number 13 since that is the order in which the bits appear in the
    equation above. Similarly 0011 represents the number 3\. We often leave off the
    leading (that is, the leftmost) 0’s, so we might just write this as 11 instead.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比特序列来表示数字是方便的，而不是显式显示2的幂。 例如，我们使用比特序列1101来表示数字13，因为这是比特出现在上述方程中的顺序。 同样，0011表示数字3。
    我们经常省略前导（也就是最左边的）0，因此我们可能只写成11。
- en: The representation that we’ve been using here is called base 2 because it is
    built on powers of 2\. Are other bases possible? Sure! You use base 10 every day.
    In base 10, numbers are made out of powers of 10 and rather than just using 0
    and 1 as the coefficients, we use 0 through 9\. For example, the sequence 603
    really means
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的表示法称为2进制，因为它是建立在2的幂上的。 其他基数可能吗？ 当然可以！ 每天都在使用10进制。 在10进制中，数字由10的幂组成，而不仅仅是使用0和1作为系数，我们使用0到9。
    例如，序列603实际上意味着
- en: \[6·10^2 + 0·10^1 + 3·10^0\]
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: \[6·10^2 + 0·10^1 + 3·10^0\]
- en: Other bases are also useful. For example, the Yuki Native American tribe, who
    lived in Northern California, used base 8\. In base 8 we use powers of 8 and the
    coefficients that we use are 0 through 7\. So, for example, the sequence 207 in
    base 8 means
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其他进制也很有用。 例如，居住在加利福尼亚北部的尤基土著美国部落使用8进制。 在8进制中，我们使用8的幂和系数，我们使用的系数是0到7。 因此，例如，8进制中的序列207意味着
- en: \[2·8^2 + 0·8^1 + 7·8^0\]
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: \[2·8^2 + 0·8^1 + 7·8^0\]
- en: which is 135 (in base 10). It is believed that the Yukis used base 8 because
    they counted using the eight slots *between* their fingers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以10进制表示的135。 据信尤基人使用8进制是因为他们计数时使用了手指之间的八个空隙。
- en: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
- en: '*In Star Wars, the Hutts have 8 fingers and therefore also count in base 8.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*在星球大战中，赫特族有8根手指，因此也是以8为基数计数。*'
- en: Notice that when we choose some base \(b\) (where \(b\) is some integer greater
    than or equal to 2), the digits that we use as coefficients are 0 through \(b
    - 1\). Why? It’s not hard to prove mathematically that when we use this convention,
    every positive integer between 0 and \(bd -1\) can be represented using \(d\)
    digits. Moreover, every integer in this range has a *unique* representation, which
    is handy since it avoids the headache of having multiple representations of the
    same number. For example, just as 42 has no other representation in base 10, the
    number 1101 in base 2 (which we saw a moment ago is 13 in base 10) has no other
    representation in base 2.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们选择某个基数\(b\)（其中\(b\)是大于或等于2的整数）时，我们用作系数的数字是0到\(b - 1\)。为什么？从数学上证明使用这种约定时，我们可以用\(d\)个数字表示0到\(bd
    -1\)之间的每个正整数。此外，在这个范围内的每个整数都有一个*唯一*的表示，这很方便，因为它避免了同一个数字有多个表示的头痛。例如，就像42在十进制中没有其他表示一��，我们在二进制中看到的数字1101（刚才我们看到是十进制中的13）在二进制中也没有其他表示。
- en: Many older or smaller computers use 32 bits to represent a number in base 2;
    sensibly enough, we call them “32-bit computers.” Therefore, we can uniquely represent
    all of the positive integers between 0 and 2^32 - 1 , or 4, 294, 967, 295\. A
    powerful modern computer that uses 64 bits to represent each number can represent
    integers up to 2^64 - 1, which is roughly 18 *quadrillion*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多较老或较小的计算机使用32位来表示二进制中的一个数字；因此，我们称它们为“32位计算机”。因此，我们可以唯一地表示0到2^32 - 1之间的所有正整数，即4,294,967,295。一个现代强大的计算机使用64位来表示每个数字，可以表示高达2^64
    - 1的整数，大约为18 *quadrillion*。
- en: 4.2.2 Arithmetic
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 算术
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*We’ll have sum fun with addition.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将通过加法获得一些乐趣。*'
- en: Arithmetic in base 2, base 8, or base 42 is analogous to arithmetic in base
    10\. For example, let’s consider addition. In base 10, we simply start at the
    rightmost column, where we add those digits and “carry” to the next column if
    necessary. For example, when adding \(17+25\) , \(5+7 = 12\) so we write down
    a 2 in the rightmost position and carry the 1\. That 1 represents a 10 and is
    therefore propagated, or carried, to the next column, which represents the “10’s
    place.”
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制、八进制或四十二进制的算术类似于十进制的算术。例如，让我们考虑加法。在十进制中，我们简单地从最右边的列开始，将这些数字相加，如果必要的话“进位”到下一列。例如，当加法\(17+25\)时，\(5+7
    = 12\)，所以我们在最右边的位置写下2并进位1。那个1代表10，因此被传播或进位到下一列，代表“十位”。
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*Although I find coming to agreement with myself to be easier in general.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然我发现一般来说，与自己达成一致更容易。*'
- en: 'Addition in base 2 is nearly identical. Let’s add 111 (which, you’ll recall
    is 7 in base 10) and 110 (which is 6 in base 10). We start at the rightmost (or
    “least significant”) column and add 1 to 0, giving 1\. Now we move to the next
    column, which is the \(2^1\) position or “2’s place”. Each of our two numbers
    has a 1 in this position. 1 + 1 = 2 but we only use 0’s and 1’s in base 2, so
    in base 2 we would have 1 + 1 = 10\. This is analogous to adding 7 + 3 in base
    10: rather than writing 10, we write a 0 and carry the 1 to the next column. Similarly,
    in base 2, for 1 + 1 we write 0 and carry the 1 to the next column. Do you see
    why this works? Having a 2 in the “2’s place” is the same thing as having a 1
    in the “4’s place”. In general having a 2 in the column corresponding to \(2^i\)
    is the same as having a 1 in the next column, the one corresponding to \(2^{i+1}\)
    since \(2 · 2^i = 2^{i+1}\) .'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制中的加法几乎相同。让我们相加111（你会记得这在十进制中是7）和110（在十进制中是6）。我们从最右边（或“最低有效”）列开始，将1加到0，得到1。现在我们移动到下一列，即\(2^1\)位置或“2位”。我们的两个数字中每个都有一个1在这个位置。1
    + 1 = 2，但在二进制中我们只使用0和1，所以在二进制中我们会写1 + 1 = 10。这类似于在十进制中加7 + 3：而不是写10，我们写0并将1进位到下一列。同样，在二进制中，对于1
    + 1，我们写0并将1进位到下一列。你明白为什么这样做了吗？在“2位”上有一个2与在“4位”上有一个1是相同的。通常情况下，在对应于\(2^i\)的列中有一个2与在下一列，即对应于\(2^{i+1}\)的列中有一个1是相同的，因为\(2
    · 2^i = 2^{i+1}\)。
- en: '**Takeaway message:** *Addition, subtraction, multiplication, and division
    in your favorite base are all analogous to those operations in base 10!*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点：** *在你喜欢的基数中进行加法、减法、乘法和除法都类似于十进制中的这些操作！*'
- en: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
- en: '*We’ll try not to get carried away with these examples, but you should try
    adding a few numbers in base 2 to make sure that it makes sense to you.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们不会在这些例子中过度，但你应该尝试在二进制中添加一些数字，以确保你理解它是否有意义。*'
- en: 4.2.3 Letters and Strings
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 字母和字符串
- en: As you know, computers don’t only manipulate numbers; they also work with symbols,
    words, and documents. Now that we have ways to represent numbers as bits, we can
    use those numbers to represent other symbols.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，计算机不仅仅是处理数字；它们还处理符号、文字和文档。现在我们有了用比特表示数字的方法，我们可以使用这些数字来表示其他符号。
- en: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
- en: '*In ASCII, the number 42 represents the asterisk* *(* * *)*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*在ASCII中，数字 42 表示星号* *(* * *)*'
- en: It’s fairly easy to represent the alphabet numerically; we just need to come
    to an agreement, or “convention,” on the encoding. For example, we might decide
    that 1 should mean “A”, 2 should mean “B”, and so forth. Or we could represent
    “A” with 42 and “B” with 97; as long as we are working entirely within our own
    computer system it doesn’t really matter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数字化字母相当容易；我们只需要就编码达成一致，或者“约定”。例如，我们可以决定 1 表示“A”，2 表示“B”，以此类推。或者我们可以用 42 表示“A”，用
    97 表示“B”；只要我们完全在自己的计算机系统内工作，这就不重要。
- en: But if we want to send a document to a friend, it helps to have an agreement
    with more than just ourselves. Long ago, the American National Standards Institute
    (ANSI) published such an agreement, called ASCII (pronounced “as key” and standing
    for the American Standard Code for Information Interchange). It defined encodings
    for the upper- and lower-case letters, the numbers, and a selected set of special
    characters - which, not coincidentally, happen to be precisely the symbols printed
    on the keys of a standard U.S. keyboard.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想把一份文档发送给朋友，与仅仅自己达成协议是有帮助的。很久以前，美国国家标准协会（ANSI）发布了这样的协议，称为ASCII（读作“as
    key”，代表美国信息交换标准代码）。它定义了大写和小写字母、数字以及一组特殊字符的编码 - 这些字符恰好是标准美国键盘上的键上打印的符号。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Negative Thinking**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**消极思维**'
- en: We’ve successfully represented numbers in base 2 and done arithmetic with them.
    But all of our numbers were positive. How about representing negative numbers?
    And what about fractions?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地用二进制表示了数字并对其进行了算术运算。但我们所有的数字都是正数。那么如何表示负数？还有分数呢？
- en: 'Let’s start with negative numbers. One fairly obvious approach is to reserve
    one bit to indicate whether the number is positive or negative; for example, in
    a 32-bit computer we might use the leftmost bit for this purpose: Setting that
    bit to 0 could mean that the number represented by the remaining 31 bits is positive.
    If that leftmost bit is a 1 then the remaining number would be considered to be
    negative. This is called a *sign-magnitude* representation. The price we pay is
    that we lose half of our range (since we now have only 31 bits, in our example,
    to represent the magnitude of the number). While we don’t mean to be too negative
    here, a bigger problem is that it’s tricky to build computer circuits to manipulate
    sign-magnitude numbers. Instead, we use a system called two’s complement.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从负数开始。一个相当明显的方法是保留一个位来指示数字是正数还是负数；例如，在一个 32 位的计算机中，我们可以使用最左边的位来做这个目的：将该位设置为
    0 可以表示由剩下的 31 位表示的数字是正数。如果最左边的位是 1，则认为剩余的数字是负数。这称为 *符号-幅度* 表示。我们付出的代价是失去了一半的范围（因为我们现在只有
    31 位，在我们的例子中，来表示数字的幅度）。虽然我们并不是要太消极，但更大的问题是，构建用于操作符号-幅度数字的计算机电路是棘手的。相反，我们使用一种称为二进制补码的系统。
- en: 'The idea behind two’s complement is this: It would be very convenient if the
    representation of a number plus the representation of its negation added up to
    0\. For example, since 3 added to -3 is 0, it would be nice if the binary representation
    of 3 plus the binary representation of -3 added up to 0\. We already know what
    the binary representation of 3 is 11\. Let’s imagine that we have an 8-bit computer
    (rather than 32- or 64-bit), just to make this example easier. Then, including
    the leading 0’s, 3 would be represented as 00000011\. Now, how could we represent
    -3 so that its representation added to 00000011 would be 0, that is 00000000?'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制补码背后的理念是：如果一个数的表示加上它的负数的表示加起来等于0会非常方便。例如，由于3加上-3等于0，如果3的二进制表示加上-3的二进制表示等于0会很好。我们已经知道3的二进制表示是11。让我们假设我们有一台8位的计算机（而不是32位或64位），为了让这个例子更容易些。那么，包括前导的0，3将被表示为00000011。现在，我们如何表示-3，使得它的表示加上00000011等于0，也就是00000000？
- en: Notice that if we “flip” all of the bits in the representation of 3, we get
    11111100\. Moreover, 00000011 + 11111100 = 11111111\. If we add one more to this
    we get 11111111 + 00000001 and when we do the addition with carries we get 100000000;
    a 1 followed by eight 0’s. If the computer is only using eight bits to represent
    each number then that leftmost ninth bit will not be recorded! So, what will be
    saved is just the lower eight bits, 00000000, which is 0\. So, to represent -3,
    we can simply take the representation of 3, flip the bits, and then add 1 to that.
    (Try it out to make sure that you see how this works.) In general, the representation
    of a negative number in the two’s complement system involves flipping the bits
    of the positive number and then adding 1.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们“翻转”3的表示中的所有位，我们会得到11111100。此外，00000011 + 11111100 = 11111111。如果我们再加1，我们得到11111111
    + 00000001，当我们进行带进位的加法时，我们得到100000000；一个1后面跟着八个0。如果计算机只使用八位来表示每个数字，那么最左边的第九位将不会被记录！所以，将保存的只是较低的八位，00000000，即0。因此，要表示-3，我们可以简单地取3的表示，翻转位，然后再加1。（试一下，确保你知道这是如何工作的。）一般来说，二进制补码系统中负数的表示涉及翻转正数的位，然后加1。
- en: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
- en: '*“ord” stands for “ordinal”. You can think of this as asking for the “ordering
    number” of the symbol*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*“ord”代表“ordinal”。你可以把它看作是在询问符号的“序号”。*'
- en: 'You can look up the ASCII encoding on the web. Alternatively, you can use the
    Python function ord to find the numerical representation of any symbol. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在网上查找ASCII编码。或者，你可以使用Python函数ord来找到任何符号的数值表示。例如：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*4 bits are sometimes called a “nybble”; we take no responsibility for this
    pathetically nerdy pun.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*4位有时被称为“nybble”；我们对这个可怜的书呆子双关语不负责任。*'
- en: Why is the ordinal value of ‘9’ reported as 57? Keep in mind that the 9, in
    quotes, is just a character like the asterisk, a letter, or a punctuation symbol.
    It appears as character 57 in the ASCII convention. Incidentally, the inverse
    of ord is chr. Typing chr(42) will return an asterisk symbol and chr(57) will
    return the symbol ‘9’.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么‘9’的序数值被报告为57？请记住，带引号的9只是一个字符，就像星号、字母或标点符号一样。它在ASCII约定中显示为字符57。顺便说一句，ord的反函数是chr。输入chr(42)将返回一个星号符号，输入chr(57)将返回符号‘9’。
- en: Each character in ASCII can be represented by 8 bits, a chunk commonly referred
    to as a “*byte*.” Unfortunately, with only 8 bits ASCII can only represent 256
    different symbols. (You might find it entertaining to pause here and write a short
    program that counts from 0 to 255 and, for each of these numbers, prints out the
    ASCII symbol corresponding to that number. You’ll find that some of the symbols
    printed are “weird” or even invisible. Snoop on the Web to learn more about why
    this is so.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII中的每个字符都可以用8位表示，通常称为“*byte*”。不幸的是，只有8位的ASCII只能表示256个不同的符号。（你可能会觉得有趣，停下来写一个简短的程序，从0数到255，并为每个数字打印出对应于该数字的ASCII符号。你会发现其中一些打印出的符号是“奇怪的”，甚至是看不见的。在网上调查一下，了解为什么会这样。）
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Piecing It Together**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**将其拼凑起来**'
- en: How about representing fractions? One approach (often used in video and music
    players) is to establish a convention that everything is measured in units of
    some convenient fraction (just as our three-way bulb works in units of 50 watts).
    For example, we might decide that everything is in units of 0.01, so that the
    number 100111010 doesn’t represent 314 but rather represents 3.14.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如何表示分数？一种方法（在视频和音乐播放器中经常使用）是建立一个约定，即所有内容都以某个方便的分数单位来衡量（就像我们的三向灯泡以50瓦为单位工作一样）。例如，我们可以决定一切都是以0.01单位为单位，这样数字100111010就不表示314，而是表示3.14。
- en: However, scientific computation often requires both more precision and a wider
    range of numbers than this strategy affords. For example, chemists often work
    with values as on the order of \(10^{23}\) or more (Avogadro’s number is approximately
    \(6.02 \times 10^{23}\) ), while a nuclear physicist might use values as small
    as \(10^{-12}\) or even smaller.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，科学计算通常需要比这种策略提供的更高的精度和更广泛的数字范围。例如，化学家通常使用大约\(10^{23}\)或更多的值（阿伏伽德罗常数约为\(6.02
    \times 10^{23}\)），而核物理学家可能使用小至\(10^{-12}\)甚至更小的值。
- en: Imagine that we are operating in base 10 and we have only eight digits to represent
    our numbers. We might use the first six digits to represent a number, with the
    convention that there is an implicit 0 followed by a decimal point, just before
    the first digit. For example, the six digits 123456 would represent the number
    0.123456\. Then, the last two digits could be used to represent the exponent on
    the power of 10\. So, 12345678 would represent \(0.123456 \times 10^{78}\) . Computers
    use a similar idea to represent fractional numbers, except that base 2 is used
    instead of base 10.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们是在十进制中运作，并且我们只有八个数字来表示我们的数字。我们可以使用前六个数字来表示一个数字，约定是在第一个数字之前有一个隐含的0，紧跟着一个小数点。例如，六个数字123456将表示数字0.123456。然后，最后两个数字可以用来表示10的幂上的指数。因此，12345678将表示\(0.123456
    \times 10^{78}\)。计算机使用类似的思想来表示分数，只是使用的是基数2而不是基数10。
- en: It may seem that 256 symbols is a lot, but it doesn’t provide for accented characters
    used in languages like French (Français), let alone the Cyrillic or Sanskrit alphabets
    or the many thousands of symbols used in Chinese and Japanese.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 256个符号似乎很多，但它并不能提供像法语（Français）等语言中使用的重音字符，更不用说西里尔字母或梵文字母，或者中国和日本使用的成千上万的符号。
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*There are even unofficial Unicode symbols for Klingon!*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*甚至有非官方的 Unicode 符号用于克林贡语！*'
- en: To address that oversight, the International Standards Organization (ISO) eventually
    devised a system called Unicode, which can represent every character in every
    known language, with room for future growth. Because Unicode is somewhat wasteful
    of space for English documents, ISO also defined several “Unicode Transformation
    Formats” (UTF), the most popular of which is *UTF-8*. You may already be using
    UTF-8 on your computer, but we won’t go into the gory details here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，国际标准化组织（ISO）最终设计出了一种称为 Unicode 的系统，它可以表示每种已知语言中的每个字符，并为未来的增长留出空间。由于
    Unicode 对于英文文档来说有点浪费空间，ISO 还定义了几种“Unicode 转换格式”（UTF），其中最流行的是 *UTF-8*。您可能已经在您的计算机上使用了
    UTF-8，但我们不会在这里深入讨论细节。
- en: Of course, individual letters aren’t very interesting. Humans normally like
    to string letters together, and we’ve seen that Python uses a data type called
    “strings” to do this. It’s easy to do that with a sequence of numbers; for example,
    in ASCII the sequence 99, 104, 111, 99, 111, 108, 97, 116, 101 translates to “chocolate”.
    The only detail missing is that when you are given a long string of numbers, you
    have to know when to stop; a common convention is to include a “length field”
    at the very beginning of the sequence. This number tells us how many characters
    are in the string. (Python uses a length field, but hides it from us to keep the
    string from appearing cluttered.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，单个字母并不是很有趣。人们通常喜欢把字母串在一起，我们已经看到 Python 使用了一种称为“字符串”的数据类型来做到这一点。用一串数字做到这一点很容易；例如，在
    ASCII 中，序列99、104、111、99、111、108、97、116、101 翻译成“chocolate”。唯一缺少的细节是当你得到一长串数字时，你必须知道何时停止；一个常见的约定是在序列的开头包含一个“长度字段”。这个数字告诉我们字符串中有多少个字符。（Python
    使用长度字段，但隐藏了它，以避免字符串看起来凌乱。）
- en: 4.2.4 Structured Information
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 结构化信息
- en: Using the same concepts, we can represent almost any information as a sequence
    of numbers. For example, a picture can be represented as a sequence of colored
    dots, arranged in rows. Each colored dot (also known as a “picture element” or
    pixel ) can be represented as three numbers giving the amount of red, green, and
    blue at that pixel. Similarly, a sound is a time sequence of “sound pressure levels”
    in the air. A movie is a more complex time sequence of single pictures, usually
    24 or 30 per second, along with a matching sound sequence.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的概念，我们可以将几乎任何信息表示为一系列数字。例如，一幅图片可以表示为一系列排列在行中的彩色点。每个彩色点（也称为“像素”或像素）可以用三个数字表示，分别给出该像素的红色、绿色和蓝色的数量。同样，声音是空气中“声压级”的时间序列。电影是一系列单个图片的更复杂的时间序列，通常每秒24或30帧，以及相匹配的声音序列。
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*That would be more than a bit annoying!*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*那将会非常烦人！*'
- en: That’s the level of abstraction thing again! Bits make up numbers, numbers make
    up pixels, pixels make up pictures, pictures make up movies. A two-hour movie
    can require several billion bits, but nobody who is making or watching a movie
    wants to think about all of those bits!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是抽象层次的事情！位构成数字，数字构成像素，像素构成图片，图片构成电影。一部两小时的电影可能需要数十亿位，但制作或观看电影的人都不想考虑所有这些位！
- en: 4.3 Logic Circuitry
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 逻辑电路
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*My favorite food chain sells donuts.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*我最喜欢的食品连锁店卖甜甜圈。*'
- en: Now that we have adopted some conventions on the representation of data it’s
    time to build devices that manipulate data. We’ll start at a low level of abstraction
    of transistors and move up the metaphorical “food chain” to more complex devices,
    then units that can perform addition and other basic operations, and finally to
    a full-blown computer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经采用了一些关于数据表示的约定，是时候构建处理数据的设备了。我们将从晶体管的低抽象级别开始，然后向更复杂的设备的隐喻“食物链”上升，然后是可以执行加法和其他基本操作的单元，最后是一个完整的计算机。
- en: 4.3.1 Boolean Algebra
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 布尔代数
- en: In Chapter 2 we talked about Boolean variables - variables that take the value
    `True` or `False`. It turns out that Booleans are at the very heart of how a computer
    works.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们谈到了布尔变量 - 变量取值为`True`或`False`。事实证明，布尔变量是计算机工作的核心。
- en: 'As we noted in the last section, it’s convenient to represent our data in base
    2, also known as binary. The binary system has two digits, 0 and 1 just as Boolean
    variables have two values, `False` and `True`. In fact, we can think of 0 as corresponding
    to `False` and 1 as `True` as corresponding to `True`. The truth is, that Python
    thinks about it this way too. One funny way to see this is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，用二进制表示数据是方便的，也称为二进制。二进制系统有两个数字，0和1，就像布尔变量有两个值，`False`和`True`一样。事实上，我们可以认为0对应于`False`，1对应于`True`。事实上，Python也是这样考虑的。一个有趣的看待方式如下：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
- en: '*We are writing these in upper-case letters to indicate that we are talking
    about operations on bits-0’s and 1’s - rather than Python’s build in* `and`, `or`,
    *and* `not`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用大写字母来表示我们讨论的是位-0和1的操作，而不是Python内置的* `and`, `or`, *和* `not`。'
- en: 'Weird - but there it is: in Python `False` is really 0 and `True` is really
    1\. By the way, in many programming languages this is not the case. In fact, programming
    language designers have interesting debates about whether it’s a good idea or
    not to have `False` and `True` be so directly associated with the numbers 0 and
    1\. On the one hand, that’s how we often think about `False` and `True`. On the
    other hand, it can result in confusing expressions like `False + 42` which are
    hard to read and prone to introducing programmer errors.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪 - 但事实就是这样：在Python中，`False`实际上是0，`True`实际上是1。顺便说一句，在许多编程语言中，情况并非如此。事实上，编程语言设计者就是否将`False`和`True`直接与数字0和1关联起来进行了有趣的辩论。一方面，这是我们经常思考`False`和`True`的方式。另一方面，这可能导致令人困惑的表达式，如`False
    + 42`，这些表达式很难阅读并容易引入程序员错误。
- en: With the Booleans `True` and `False` we saw that we could use the operations
    and, or, and not to build up more interesting Boolean expressions. For example,
    `True` and `True` is the same as `True` while `True` or `False` is `True` and
    not `True` is `False`. Of course, we can now emulate these three operations for
    0 and 1\. 1 `AND` 1 = 1, 1 `OR` 0 = 1, and `NOT` 1 = 0.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过布尔值`True`和`False`，我们看到我们可以使用操作and、or和not来构建更有趣的布尔表达式。例如，`True`和`True`等同于`True`，而`True`或`False`是`True`，而`not
    True`是`False`。当然，我们现在可以为0和1模拟这三个操作。1 `AND` 1 = 1，1 `OR` 0 = 1，`NOT` 1 = 0。
- en: 'Although your intuition of `AND`, `OR`, and `NOT` is probably fine, we can
    be very precise about these three operations by defining them with a *truth table*
    : a listing of all possible combinations of values of the input variables, together
    with the result produced by the function. For example, the truth table for `AND`
    is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您对`AND`、`OR`和`NOT`的直觉可能很好，但我们可以通过用*真值表*定义它们来非常精确地描述这三个操作：输入变量的所有可能值组合的列表，以及函数产生的结果。例如，`AND`的真值表如下：
- en: '![../Images/and.PNG](../Images/and.PNG)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/and.PNG](../Images/and.PNG)'
- en: In Boolean notation, `AND` is normally represented as multiplication; an examination
    of the above table shows that as long as *x* and *y* are either 0 or 1, *x* `AND`
    *y* is in fact identical to multiplication. Therefore, we will often write *xy*
    to represent *x* `AND` *y*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔符号中，`AND`通常表示为乘法；对上表的检查表明只要*x*和*y*为0或1，*x* `AND` *y*实际上与乘法相同。因此，我们经常写*xy*来表示*x*
    `AND` *y*。
- en: '**Takeaway message:** `AND` *is 1 if and only if both of its arguments are
    1.*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点：** `AND` *当且仅当其两个参数都为1时为1*。'
- en: '`OR` is a two-argument function that is 1 if either of its arguments are 1\.
    The truth table for `OR` is:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`OR`是一个两个参数的函数，如果其任一参数为1，则结果为1。`OR`的真值表如下：'
- en: '![../Images/or.PNG](../Images/or.PNG)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/or.PNG](../Images/or.PNG)'
- en: '`OR` is normally written using the plus sign: \(x + y\). The first three lines
    of the above table are indeed identical to addition, but note that the fourth
    is different.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`OR`通常用加号表示：\(x + y\)。上表的前三行确实与加法相同，但请注意第四行不同。'
- en: '**Takeaway message:** `OR` *is 1 if either of its arguments is 1.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点：** `OR` *如果其任一参数为1，则结果为1*。'
- en: 'Finally, `NOT` is a one-argument function that produces the opposite of its
    argument. The truth table is:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`NOT`是一个一元函数，产生其参数的相反值。真值表如下：
- en: '![../Images/not.PNG](../Images/not.PNG)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/not.PNG](../Images/not.PNG)'
- en: '`NOT` is normally written using an overbar, e.g. \(\bar{x}\)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOT`通常用上横线表示，例如\(\bar{x}\)'
- en: 4.3.2 Making Other Boolean Functions
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 构建其他布尔函数
- en: Amazingly, any function of Boolean variables, no matter how complex, can be
    expressed in terms of `AND`, `OR`, and `NOT`. No other operations are required
    because, as we’ll see, any other operation could be made out of `AND`, `OR`, and
    `NOT` s. In this section we’ll show how to do that. This fundamental result will
    allow us to build circuits to do things like arithmetic and, ultimately, a computer.
    For example, consider a function described by the truth table below. This function
    is known as “implication” and is written \(x \Rightarrow y\) .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，任何布尔变量的函数，无论多么复杂，都可以用`AND`、`OR`和`NOT`来表示。因为，正如我们将看到的，任何其他操作都可以由`AND`、`OR`和`NOT`组成。在本节中，我们将展示如何做到这一点。这一基本结果将使我们能够构建电路来执行诸如算术和最终计算机等任务。例如，考虑下面的真值表描述的函数。这个函数被称为“蕴含”并写作\(x
    \Rightarrow y\)。
- en: '![../Images/arrow.PNG](../Images/arrow.PNG)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/arrow.PNG](../Images/arrow.PNG)'
- en: This function can be expressed as \(\bar{x} + xy\). To see why, try building
    the truth table for \(\bar{x} + xy\). That is, for each of the four possible combinations
    of *x* and *y*, evaluate \(\bar{x} + xy\). For example, when \(x = 0\) and \(y
    = 0\) , notice that \(\bar{x}\) is 1\. Since the `OR` of 1 and anything else is
    always 1, we see that \(\bar{x} + xy\) evaluates to 1 in this case. Aha! This
    is exactly the value that we got in the truth table above for \(x = 0\) and \(y
    = 0\). If you continue doing this for the next three rows, you’ll see that values
    of \(x \Rightarrow y\) and \(\bar{x} + xy\) always match. In other words, they
    are identical. This method of enumerating the output for each possible input is
    a fool-proof way of proving that two functions are identical, even if it is a
    bit laborious.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以表示为\(\bar{x} + xy\)。为了理解为什么，尝试构建\(\bar{x} + xy\)的真值表。也就是说，对于*x*和*y*的四种可能组合中的每一种，评估\(\bar{x}
    + xy\)。例如，当\(x = 0\)且\(y = 0\)时，注意到\(\bar{x}\)为1。由于1和任何其他值的`OR`始终为1，我们看到在这种情况下\(\bar{x}
    + xy\)的值为1。啊哈！这正是我们在上面的真值表中得到的\(x = 0\)和\(y = 0\)的值。如果你继续对下面的三行进行操作，你会发现\(x \Rightarrow
    y\)和\(\bar{x} + xy\)的值总是匹配的。换句话说，它们是相同的。这种枚举每个可能输入的输出的方法是证明两个函数相同的一种确凿方法，即使有点费力。
- en: For simple Boolean functions, it’s often possible to invent an expression for
    the function by just inspecting the truth table. However, it’s not always so easy
    to do this, particularly when we have Boolean functions with more than two inputs.
    So, it would be nice to have a systematic approach for building expressions from
    truth tables. The *minterm expansion principle* provides us with just such an
    approach.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的布尔函数，通常可以通过检查真值表来发明函数的表达式。然而，当我们有超过两个输入的布尔函数时，这样做并不总是那么容易。因此，希望能有一种系统的方法来从真值表中构建表达式。*最小项展开原理*为我们提供了这样一种方法。
- en: '![../Images/Alien.PNG](../Images/Alien.PNG)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien.PNG](../Images/Alien.PNG)'
- en: '*Perhaps “minterms” should be called “happyterms”.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*也许“最小项”应该被称为“幸福项”*。'
- en: We’ll see how the minterm expansion principle works through an example. Specifically,
    let’s try it out for the truth table for the implication function above. Notice
    that when the inputs are \(x = 1\) and \(y = 0\), the truth table tells us that
    the output is 0\. However, for all three of the other rows (that is pairs of inputs),
    the output is more “interesting” - it’s 1\. We’ll build a custom-made logical
    expression for each of these rows with a 1 as the output. First, consider the
    row \(x = 0\) ; \(y = 0\) . Note that the expression \(\bar{x} \bar{y}\) evaluates
    to 1 for this particular pair of inputs because the `NOT` of 0 is 1 and the `AND`
    of 1 and 1 is 1\. Moreover, notice that for every other possible pair of values
    for x and y this term \(\bar{x} \bar{y}\) evaluates to 0\. Do you see why? The
    only way that \(\bar{x} \bar{y}\) can evaluate to 1 is for \(\bar{x}\) to be 1
    (and thus for x to be 0) and for \(\bar{y}\) to be 1 (since we are computing the
    `AND` here and `AND` outputs 1 only if both of its inputs are 1). The term \(\bar{x}
    \bar{y}\) is called a minterm. You can think of it as being custom-made to make
    the inputs \(x = 0\) ; \(y = 0\) “happy” (evaluate to 1) and does nothing for
    every other pair of inputs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个示例看看最小项展开原理是如何工作的。具体来说，让我们尝试对上面蕴含函数的真值表进行操作。注意当输入为\(x = 1\)和\(y = 0\)时，真值表告诉我们输出为0。然而，对于其他三行（也就是输入对）中的所有情况，输出更“有趣”
    - 它是1。我们将为每个输出为1的行构建一个定制的逻辑表达式。首先，考虑行\(x = 0\)；\(y = 0\)。注意到表达式\(\bar{x} \bar{y}\)对于这对特定的输入来说评估为1，因为0的`NOT`是1，而1和1的`AND`是1。此外，注意对于x和y的每一对可能值，这个项\(\bar{x}
    \bar{y}\)的值为0。你明白为什么吗？\(\bar{x} \bar{y}\)能够评估为1的唯一方式是\(\bar{x}\)为1（因此x为0）且\(\bar{y}\)为1（因为我们在这里计算`AND`，而`AND`仅在其两个输入都为1时输出1）。术语\(\bar{x}
    \bar{y}\)被称为最小项。你可以将其视为定制的，使得输入\(x = 0\)；\(y = 0\)“幸福”（评估为1），并对每一对其他输入不起作用。
- en: We’re not done yet! We now want a minterm that is custom-made to evaluate to
    1 for the input \(x = 0\); \(y = 1\) and evaluates to 0 for every other pair of
    input values. Take a moment to try to write such a minterm. It’s \(\bar{x} y\).
    This term evaluates to 1 if and only if \(x = 0\) and \(y = 1\). Similarly, a
    minterm for \(x = 1\); \(y = 1\) is math:xy. Now that we have these minterms,
    one for each row in the truth table that contains a 1 as output, what do we do
    next? Notice that in our example, our function should output a 1 if the first
    minterm evaluates to 1 or the second minterm evaluates to 1 or the third minterm
    evaluates to 1\. Also notice the words “or” in that sentence. We want to `OR`
    the values of these three minterms together. This gives us the expression \(\bar{x}\bar{y}
    + \bar{x}y + xy\). This expression evaluates to 1 for the first, second, and fourth
    rows of the truth table as it should. How about the third row, the “uninteresting”
    case where \(x = 1\); \(y = 1\) should output 0\. Recall that each of the minterms
    in our expression was custom-made to make exactly one pattern “happy”. So, none
    of these terms will make the \(x = 1\); \(y = 1\) “happy” and thus, for that pair
    of inputs, our newly minted expression outputs a 0 as it should!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！现在，我们想要一个特制的最小项，对于输入\(x = 0\)；\(y = 1\)时计算结果为1，并且对于其他输入值对都计算结果为0。花点时间尝试写出这样的最小项。它是\(\bar{x}
    y\)。这个术语仅当\(x = 0\)且\(y = 1\)时计算结果为1。同样地，\(x = 1\)；\(y = 1\)的最小项是 math:xy。现在我们有了这些最小项，每个真值表中包含输出为1的行都有一个最小项，接下来我们该怎么办？注意，在我们的示例中，如果第一个最小项计算结果为1，或者第二个最小项计算结果为1，或者第三个最小项计算结果为1，我们的函数应该输出1。也请注意那句话中的“或”字。我们想要将这三个最小项的值进行`OR`运算。这给出了表达式\(\bar{x}\bar{y}
    + \bar{x}y + xy\)。该表达式对真值表的第一、第二和第四行计算结果为1，正如应该的那样。那么第三行呢，即“无趣”的情况，其中\(x = 1\)；\(y
    = 1\)应该输出0。回想一下，我们表达式中的每个最小项都是定制的，以使得正好一个模式“满意”。因此，对于这对输入，我们新铸造的表达式输出0，正如应该的那样！
- en: 'It’s not hard to see that this minterm expansion principle works for every
    truth table. Here is the precise description of the process:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不难看出，这种最小项展开原理适用于每个真值表。以下是该过程的精确描述：
- en: Write down the truth table for the Boolean function that you are considering.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下您正在考虑的布尔函数的真值表。
- en: Delete all rows from the truth table where the value of the function is 0.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除函数值为0的真值表中的所有行。
- en: 'For each remaining row we will create something called a “minterm” as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个剩余的行，我们将创建一个称为“最小项”的东西，如下所示：
- en: For each variable that has a 1 in that row, write the name of the variable.
    If the input variable is 0 in that row, write the variable with a negation symbol
    to `NOT` it.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个在该行中为1的变量，写下变量的名称。如果该行中的输入变量为0，则写下带有否定符号的变量以进行`NOT`操作。
- en: Now `AND` all of these variables together.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将所有这些变量都`AND`在一起。
- en: Combine all of the minterms for the rows using `OR` .
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有行的最小项使用 `OR` 组合起来。
- en: You might have noticed that this general algorithm for converting truth tables
    to logic expressions only uses `AND`, `OR`, and `NOT` operations. It uses `NOT`
    and `AND` to construct each minterm and then it uses `OR` to “glue” these minterms
    together. This effectively proves that `AND`, `OR`, and `NOT` suffice to represent
    any Boolean function!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，将真值表转换为逻辑表达式的这个通用算法只使用了`AND`、`OR`和`NOT`操作。它使用`NOT`和`AND`构建每个最小项，然后使用`OR`将这些最小项“粘合”在一起。这有效地证明了`AND`、`OR`和`NOT`足以表示任何布尔函数！
- en: The minterm expansion principle is a recipe - it’s an *algorithm*. In fact,
    it can be implemented on a computer to automatically construct a logical expression
    for any truth table. In practice, this process is generally done by computers.
    Notice, however that this algorithm doesn’t necessarily give us the simplest expression
    possible. For example, for the implication function, we saw that the expression
    \(\bar{x}+xy\) is correct. However, the minterm expansion principle produced the
    expression \(\bar{x}\bar{y} + \bar{x}y + xy\). These expressions are logically
    equivalent, but the first one is undeniably shorter. Regrettably, the so-called
    “minimum equivalent expressions” problem of finding the shortest expression for
    a Boolean function is very hard. In fact, a Harvey Mudd College graduate, David
    Buchfuhrer, recently showed that the minimum equivalent expressions problem is
    provably as hard as some of the hardest (unsolved) problems in mathematics and
    computer science. Amazing but true!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最小项展开原理是一个配方 - 它是一个*算法*。实际上，它可以在计算机上实现，自动为任何真值表构建逻辑表达式。在实践中，这个过程通常由计算机完成。然而请注意，这个算法并不一定给出我们可能的最简表达式。例如，对于蕴含函数，我们看到表达式\(\bar{x}+xy\)是正确的。然而，最小项展开原理产生了表达式\(\bar{x}\bar{y}
    + \bar{x}y + xy\)。这些表达式在逻辑上是等价的，但第一个表达式无疑更短。遗憾的是，寻找布尔函数最短表达式的所谓“最小等价表达式”问题非常困难。事实上，哈维穆德学院的毕业生大卫·布赫弗最近表明，寻找布尔函数最小等价表达式的问题在数学和计算机科学中是可以证明的最困难（未解决）问题之一。令人惊讶但却是真实的！
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*That means that computers are helping design other computers! That seems profoundly
    amazing to me.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*这意味着计算机正在帮助设计其他计算机！这对我来说似乎是非常惊人的。*'
- en: 4.3.3 Logic Using Electrical Circuits
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 电路逻辑
- en: Next, we’d like to be able to perform Boolean functions in hardware. Let’s imagine
    that our basic “building block” is an electromagnetic switch as shown in Figure
    4.2\. There is *always* power supplied to the switch (as shown in the upper left)
    and there is a spring that holds a movable “arm” in the up position. So, normally,
    there is no power going to the wire labeled “output”. The “user’s” input is indicated
    by the wire labeled “input.” When the input power is off (or “low”), the electromagnet
    is not activated and the movable arm remains up, and output is 0\. When the input
    is on (or “high”), the electromagnet is activated, causing the movable arm to
    swing downwards and power to flow to the output wire. Let’s agree that a “low”
    electrical signal corresponds to the number 0 and a “high” electrical signal corresponds
    to the number 1\. Now, let’s build a device for computing the `AND` function using
    switches. We can do this as shown in Figure 4.3 where there are two switches in
    series. In this figure, we use a simple representation of the switch without the
    power or the ground. The inputs are \(x\) and \(y\), so when \(x\) is 1, the arm
    of the first switch swings down and closes the switch, allowing power to flow
    from the left to the right. Similarly, when \(y\) is 1, that arm of the second
    switch swings down, allowing power to flow from left to right. Notice that when
    either or both of the input \(x, y\) are 0, at least one switch remains open and
    there is no electrical signal flowing from the power source to the output. However,
    when both \(x\) *and* \(y\) are 1 both switches close and there is a signal, that
    is a 1, flowing to the output. This is a device for computing \(x\) `AND` \(y\)
    . We call this an `AND` gate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望能够在硬件中执行布尔函数。让我们想象我们的基本“构建块”是一个电磁开关，如图4.2所示。开关始终供电（如左上角所示），并有一个弹簧将可移动的“臂”保持在上升位置。因此，通常情况下，没有电源供应到标记为“输出”的导线。用户的输入由标记为“输入”的导线表示。当输入电源关闭（或“低”）时，电磁铁不被激活，可移动的臂保持上升状态，输出为0。当输入打开（或“高”）时，电磁铁被激活，导致可移动的臂向下摆动，电源流向输出导线。让我们约定，“低”电信号对应数字0，“高”电信号对应数字1。现在，让我们使用开关构建一个计算`AND`函数的设备。我们可以如图4.3所示进行操作，其中有两个串联的开关。在这个图中，我们使用了一个简单的开关表示，没有电源或地线。输入是\(x\)和\(y\)，所以当\(x\)为1时，第一个开关的臂向下摆动并关闭开关，允许电源从左侧流向右侧。同样，当\(y\)为1时，第二个开关的臂向下摆动，允许电源从左侧流向右侧。请注意，当输入\(x,
    y\)中的任一个或两个都为0时，至少有一个开关保持打开状态，电源源源不断地从电源源流向输出。然而，当\(x\) *和* \(y\)都为1时，两个开关都关闭，有一个信号，即1，流向输出。这是一个计算\(x\)
    `AND` \(y\)的设备。我们称之为`AND`门。
- en: Similarly, the circuit in Figure 4.4 computes \(x\) `OR` \(y\) and is called
    an `OR` gate. The function `NOT` \(x\) can be implemented by constructing a switch
    that conducts if and only \(x\) is 0.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，图4.4中的电路计算\(x\) `OR` \(y\)，被称为一个`OR`门。函数`NOT` \(x\)可以通过构建一个仅在\(x\)为0时导通的开关来实现。
- en: '![../Images/emswitch.PNG](../Images/emswitch.PNG)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/emswitch.PNG](../Images/emswitch.PNG)'
- en: 'Figure 4.2: An electromagnetic switch.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：一个电磁开关。
- en: '![../Images/andswitch.PNG](../Images/andswitch.PNG)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/andswitch.PNG](../Images/andswitch.PNG)'
- en: 'Figure 4.3: An `AND` gate constructed with switches.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：使用开关构建的`AND`门。
- en: '![../Images/orswitch.PNG](../Images/orswitch.PNG)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/orswitch.PNG](../Images/orswitch.PNG)'
- en: 'Figure 4.4: An `OR` gate constructed with switches.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：使用开关构建的`OR`门。
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*Those gate shapes are weird. I’m on the fence about whether I like them or
    not.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*那些门的形状很奇怪。我对它们是否喜欢还没决定呢。*'
- en: While computers based on electromechanical switches were state-of-the-art in
    the 1930’s, computers today are built with transistorized switches that use the
    same principles but are much smaller, much faster, more reliable, and more efficient.
    Since the details of the switches aren’t terribly important at this level of abstraction,
    we represent, or “abstract”, the gates using symbols as shown in Figure 4.5
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于电机开关的计算机在20世纪30年代是最先进的，但是今天的计算机是由晶体管开关构建的，它们使用相同的原理，但体积更小、速度更快、更可靠、更高效。由于在这个抽象级别上开关的细节并不是非常重要，我们使用图4.5中显示的符号来表示或“抽象”门。
- en: '![../Images/gates.PNG](../Images/gates.PNG)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/gates.PNG](../Images/gates.PNG)'
- en: 'Figure 4.5: Symbols used for `AND`, `OR`, and `NOT` gates.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：用于`AND`、`OR`和`NOT`门的符号。
- en: We can now build circuits for any Boolean function! Starting with the truth
    table, we use the minterm expansion principle to find an expression for the function.
    For example, we used the minterm expansion principle to construct the expression
    \(\bar{x}\bar{y} + \bar{x}y + xy\) for the implication function. We can convert
    this into a circuit using `AND`, `OR`, and `NOT` gates as shown in Figure 4.6.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建任何布尔函数的电路了！从真值表开始，我们使用最小项展开原理找到函数的表达式。例如，我们使用最小项展开原理构建了蕴含函数的表达式\(\bar{x}\bar{y}
    + \bar{x}y + xy\)。我们可以将其转换为使用`AND`、`OR`和`NOT`门的电路，如图4.6所示。
- en: '![../Images/circuit.PNG](../Images/circuit.PNG)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/circuit.PNG](../Images/circuit.PNG)'
- en: 'Figure 4.6: A circuit for the implication function.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：蕴含函数的电路。
- en: 4.3.4 Computing With Logic
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 逻辑计算
- en: 'Now that we know how to implement functions of Boolean variables, let’s move
    up one more level of abstraction and try to build some units that do arithmetic.
    In binary, the numbers from 0 to 3 are represented as 00, 01, 10, and 11\. We
    can use a simple truth table to describe how to add two two-bit numbers to get
    a three-bit result:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何实现布尔变量的函数了，让我们再上升一个抽象级别，尝试构建一些进行算术运算的单元。在二进制中，从0到3的数字分别表示为00、01、10和11。我们可以使用一个简单的真值表来描述如何将两个两位数相加得到一个三位数的结果：
- en: '![../Images/table.PNG](../Images/table.PNG)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/table.PNG](../Images/table.PNG)'
- en: In all, this truth table contains sixteen rows. But how can we apply the minterm
    expansion principle to it? The trick is to view it as three tables, one for each
    bit of the output. We can write down the table for the rightmost output bit separately,
    and then create a circuit to compute that output bit. Next, we can repeat this
    process for the middle output bit. Finally, we can do this one more time for the
    leftmost output bit. While this works, it is much more complicated than we would
    like! If we use this technique to add two 16-bit numbers, there will be \(2^{32}\)
    rows in our truth table resulting in several *billion* gates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这个真值表包含了十六行。但是我们如何应用最小项展开原理呢？诀窍是将其视为三个表，每个输出位一个表。我们可以分别写出最右侧输出位的表，然后创建一个电路来计算该输出位。接下来，我们可以为中间输出位重复这个过程。最后，我们可以再为最左侧输出位做一次。虽然这样可以实现，但比我们想象的要复杂得多！如果我们使用这种技术来添加两个16位的数字，那么我们的真值表将会有\(2^{32}\)行，导致数十亿个门。
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*Ouch!*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*哎呀！*'
- en: Fortunately, there is a much better way of doing business. Remember that two
    numbers are added (in any base) by first adding the digits in the rightmost column.
    Then, we add the digits in the next column and so forth, proceeding from one column
    to the next, until we’re done. Of course, we may also need to carry a digit from
    one column to the next as we add.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种更好的做法。记住，两个数字（在任何进制下）是通过首先将最右边列的数字相加来相加的。然后，我们将在下一列中的数字相加，依此类推，从一列到下一列，直到完成。当然，当我们相加时，我们可能还需要将一个数字从一列带到下一列。
- en: We can exploit this addition algorithm by building a relatively simple circuit
    that does just one column of addition. Such a device is called a *full adder*,
    (admittedly a funny name given that it’s only doing one column of addition!).
    Then we can “chain” 16 full adders together to add two 16-bit numbers or chain
    64 copies of this device together if we want to add two 64-bit numbers. The resulting
    circuit, called a *ripple-carry adder*, will be much simpler and smaller than
    the first approach that we suggested above. This modular approach allows us to
    first design a component of intermediate complexity (e.g. the full adder) and
    use that design to design a more complex device (e.g. a 16-bit adder). Aha! Abstraction
    again!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构建一个相对简单的电路来利用这种加法算法，这个电路只做一列加法。这样的设备被称为*全加器*（尽管这个名字有点滑稽，因为它只做一列加法！）。然后我们可以将16个全加器链接在一起，以便加两个16位数，或者如果我们想要加两个64位数，我们可以将64个这样的设备链接在一起。得到的电路被称为*串行进位加法器*，比我们上面建议的第一种方法要简单得多，也更小。这种模块化的方法允许我们首先设计一个中等复杂度的组件（例如全加器），然后使用该设计来设计一个更复杂的设备（例如16位加法器）。啊哈！又是抽象！
- en: 'The full adder takes three inputs: The two digits being added in this column
    (we’ll call them \(x\) and \(y\)) and the “carry in” value that was propagated
    from the previous column (we’ll call that \(c_{\mbox{in}}\)). There will be two
    outputs: The sum (we’ll call that \(z\)) and the “carry out” to be propagated
    to the next column (we’ll call that \(c_{\mbox{out}}\)). We suggest that you pause
    here and build the truth table for this function. Since there are three inputs,
    there will be \(2^3 = 8\) rows in the truth table. There will be two columns of
    output. Now, treat each of these two output columns as a separate function. Starting
    with the first column of output, the sum \(z\), use the minterm expansion principle
    to write a logic expression for \(z\). Then, convert this expression into a circuit
    using `AND`, `OR`, and `NOT` gates. Then, repeat this process for the second column
    of output, \(c_{\mbox{out}}\). Now you have a full adder! Count the gates in this
    adder - it’s not a very big number.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 全加器有三个输入：这一列中要相加的两个数字（我们称它们为\(x\)和\(y\)）以及从上一列传播过来的“进位”值（我们称它为\(c_{\mbox{in}}\)）。会有两个输出：和（我们称它为\(z\)）以及要传播到下一列的“进位”（我们称它为\(c_{\mbox{out}}\)）。我们建议您在这里停下来，为这个函数建立真值表。由于有三个输入，真值表中会有\(2^3
    = 8\)行。会有两列输出。现在，将这两列输出分别视为单独的函数。从第一列输出开始，和\(z\)，使用最小项展开原理为\(z\)编写逻辑表达式。然后，使用`AND`、`OR`和`NOT`门将此表达式转换为电路。然后，为第二列输出\(c_{\mbox{out}}\)重复此过程。现在你有了一个全加器！数一下这个加法器中的门数
    - 这不是一个很大的数字。
- en: Finally, we can represent this full adder abstractly with a box that has the
    three inputs on top and the two outputs on the bottom. We now chain these together
    to build our ripple-carry adder. A 2-bit ripple-carry adder is shown in Figure
    4.7\. How many gates would be used in total for a 16-bit ripple-carry adder? It’s
    in the hundreds rather than the billions required in our first approach!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以用一个方框来抽象地表示这个全加器，顶部有三个输入，底部有两个输出。现在我们将它们链接在一起，构建我们的串行进位加法器。一个2位的串行进位加法器如图4.7所示。对于一个16位的串行进位加法器，总共需要多少门？相比我们第一种方法需要的数十亿门，这里只需要数百门！
- en: '![../Images/adder.PNG](../Images/adder.PNG)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/adder.PNG](../Images/adder.PNG)'
- en: 'Figure 4.7: A 2-bit ripple-carry adder. Each box labeled “FA” is a full adder
    that accepts two input bits plus a carry, and produces a single output bit along
    with a carry into the next FA.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：一个2位的串行进位加法器。每个标有“FA”的方框都是一个全加器，接受两个输入位和一个进位，并产生一个输出位以及一个进位传递到下一个FA。
- en: Now that we’ve built a ripple-carry adder, it’s not a big stretch to build up
    many of the other kinds of basic features of a computer. For example, consider
    building a multiplication circuit. We can observe that multiplication involves
    a number of addition steps. Now that we have an addition module, that is an abstraction
    that we can use to build a multiplier!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个串行进位加法器，构建许多其他类型的计算机基本功能并不困难。例如，考虑构建一个乘法电路。我们可以观察到乘法涉及多个加法步骤。现在我们有了一个加法模块，这是一个我们可以用来构建乘法器的抽象！
- en: '**Take Away** *Using the minterm expansion principle and modular design, we
    can now build virtually all of the major parts of a computer.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点** *利用最小项展开原理和模块化设计，我们现在可以构建计算机的几乎所有主要部件。*'
- en: 4.3.5 Memory
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.5 内存
- en: '![../Images/Alien2.PNG](../Images/Alien2.PNG)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien2.PNG](../Images/Alien2.PNG)'
- en: '*I’m glad that you didn’t forget this part!*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*我很高兴你没有忘记这部分！*'
- en: 'There is one important aspect of a computer that we haven’t seen how to design:
    memory! A computer can store data and then fetch those data for later use.(“Data”
    is the plural of “datum”. Therefore, we say “those data” rather than “that data”.)
    In this section we’ll see how to build a circuit that stores a single bit (a 0
    or 1). This device is called a *latch* because it allows us to “lock” a bit and
    retrieve it later. Once we’ve built a latch, we can abstract that into a “black
    box” and use the principle of modular design to assemble many latches into a device
    that stores a lot of data.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中有一个重要的方面我们还没有看到如何设计：内存！计算机可以存储数据，然后在以后使用时检索这些数据。（“数据”是“数据”的复数形式。因此，我们说“those
    data”而不是“that data”。）在本节中，我们将看到如何构建一个存储单个位（0或1）的电路。这个设备被称为*锁存器*，因为它允许我们“锁定”一个位并稍后检索它。一旦我们建立了一个锁存器，我们可以将其抽象为一个“黑匣子”，并使用模块化设计原则将许多锁存器组装成一个存储大量数据的设备。
- en: 'A latch can be created from two interconnected `NOR` gates: `NOR` is just `OR`
    followed by `NOT`. That is, its truth table is exactly the opposite of the truth
    table for `OR` as shown below.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个锁存器可以由两个相互连接的`NOR`门创建：`NOR`就是`OR`后跟`NOT`。也就是说，它的真值表与`OR`的真值表完全相反，如下所示。
- en: '![../Images/nor.PNG](../Images/nor.PNG)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/nor.PNG](../Images/nor.PNG)'
- en: A `NOR` gate is represented symbolically as an `OR` gate with a little circle
    at its output (representing negation).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`NOR`门在符号上表示为一个`OR`门，其输出端带有一个小圆圈（表示否定）。
- en: Now, a latch can be constructed from two `NOR` gates as shown in Figure 4.8\.
    The input \(S\) is known as “set” while the input \(R\) is known as “reset”. The
    appropriateness of these names will become evident in a moment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如图4.8所示，一个锁存器可以由两个`NOR`门构建。输入\(S\)被称为“设置”，而输入\(R\)被称为“复位”。这些名称的适当性将很快变得明显。
- en: '![../Images/latching.PNG](../Images/latching.PNG)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/latching.PNG](../Images/latching.PNG)'
- en: 'Figure 4.8: A latch built from two `NOR` gates.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：由两个`NOR`门构建的锁存器。
- en: 'What in the world is going on in this circuit!? To begin with, suppose that
    all of \(R\), \(S\), and \(Q\) are 0\. Since both \(Q\) and \(S\) are 0, the output
    of the bottom `NOR` gate, \(\bar{Q}\), is 1\. But since \(\bar{Q}\) is 1, the
    top `NOR` gate is forced to produce a 0\. Thus, the latch is in a stable state:
    the fact that \(\bar{Q}\) is 1 holds \(Q\) at 0.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电路中到底发生了什么事情！？首先，假设所有的\(R\)，\(S\)和\(Q\)都是0。由于\(Q\)和\(S\)都是0，底部`NOR`门的输出\(\bar{Q}\)为1。但由于\(\bar{Q}\)为1，顶部`NOR`门被迫产生一个0。因此，锁存器处于稳定状态：\(\bar{Q}\)为1保持\(Q\)为0。
- en: Now, consider what happens if we change \(S\) (remember, it’s called “set”)
    to 1, while holding R at 0\. This change forces \(\bar{Q}\) to 0; for a moment,
    both \(Q\) and \(\bar{Q}\) are zero. But the fact that \(\bar{Q}\) is zero means
    that both inputs to the top `NOR` gate are zero, so its output, \(Q\), must become
    1\. After that happens, we can return S to 0, and the latch will remain stable.
    We can think of the effect of changing \(S\) to 1 for a moment as “setting” the
    latch to store the value 1\. The value is stored at \(Q\). (\(\bar{Q}\) is just
    used to make this circuit do its job, but it’s the value of \(Q\) that we will
    be interested in.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑如果我们将\(S\)（记住，它被称为“设置”）更改为1，同时保持R为0。这个改变会强制\(\bar{Q}\)变为0；一瞬间，\(Q\)和\(\bar{Q}\)都是零。但\(\bar{Q}\)为零意味着顶部`NOR`门的两个输入都是零，因此它的输出，\(Q\)，必须变为1。发生这种情况后，我们可以将S返回为0，锁存器将保持稳定。我们可以将将\(S\)更改为1的效果暂时视为“设置”锁存器以存储值1。这个值存储在\(Q\)中。(\(\bar{Q}\)只是用来使这个电路完成其工作，但我们感兴趣的是\(Q\)的值。)
- en: An identical argument will show that \(R\) (remember, it’s called “reset”) will
    cause \(Q\) to return to zero, and thus \(\bar{Q}\) will become 1 again. That
    is, the value of \(Q\) is reset to 0! This circuit is commonly called the *S-R
    latch*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相同的论点将表明 \(R\)（记住，它被称为“重置”）会导致 \(Q\) 返回到零，因此 \(\bar{Q}\) 将再次变为 1。也就是说，\(Q\)
    的值被重置为 0！这个电路通常被称为 *S-R 锁存器*。
- en: What happens if both \(S\) and \(R\) become 1 at the same time? Try this out
    through a thought experiment. We’ll pause here and wait for you.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(S\) 和 \(R\) 同时变为 1 会发生什么？通过一个思维实验来尝试一下。我们会在这里暂停等待你。
- en: Did you notice how this latch will misbehave? When \(S\) and \(R\) are both
    set to 1 (this is trying to set and reset the circuit simultaneously—very naughty)
    both \(Q\) and \(\bar{Q}\) will become 0\. Now, if we let \(S\) and \(R\) return
    back to 0, the inputs to both `NOR` gates are 0 and their outputs both become
    1\. Now each `NOR` gate gets a 1 back as input and its output becomes 0\. In other
    words, the `NOR` gates are rapidly “flickering” between 0 and 1 and not storing
    anything! In fact, other weird and unpredictable things can happen if the two
    `NOR` gates compute their outputs at slightly different speeds. Circuit designers
    have found ways to avoid this problem by building some “protective” circuitry
    that ensures that \(S\) and \(R\) can never be simultaneously set to 1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到这个锁存器会出现问题？当 \(S\) 和 \(R\) 都设置为 1 时（这试图同时设置和重置电路——非常淘气），\(Q\) 和 \(\bar{Q}\)
    都会变为 0。现在，如果我们让 \(S\) 和 \(R\) 返回到 0，那么两个 `NOR` 门的输入都是 0，它们的输出都变为 1。现在每个 `NOR`
    门都得到一个 1 作为输入，其输出变为 0。换句话说，`NOR` 门在 0 和 1 之间迅速“闪烁”，而不存储任何东西！事实上，如果两个 `NOR` 门以稍微不同的速度计算输出，可能会发生其他奇怪和不可预测的事情。电路设计师已经找到了一些方法来避免这个问题，通过构建一些“保护性”电路确保
    \(S\) 和 \(R\) 永远不会同时设置为 1。
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*I’m sheepish about sharing my RAM puns because you’ve probably herd them already.*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*我对分享我的内存双关语感到有些羞愧，因为你可能已经听过了。*'
- en: So, a latch is a one-bit memory. If you want to remember a 1, turn \(S\) to
    1 for a moment; if you want to remember a 0, turn \(R\) to 1 for a moment. If
    you aggregate 8 latches together, you can remember an 8-bit byte. If you aggregate
    millions of bits, organized in groups of 8, you have the *Random Access Memory
    (RAM)* that forms the memory of a computer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，锁存器是一个一位内存。如果你想记住一个 1，将 \(S\) 转为 1 一会儿；如果你想记住一个 0，将 \(R\) 转为 1 一会儿。如果你将 8
    个锁存器聚合在一起，你可以记住一个 8 位字节。如果你聚合数百万位，以 8 位一组组织，你就有了构成计算机内存的 *随机存取存储器（RAM）*。
- en: 4.4 Building a Complete Computer
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 构建一个完整的计算机
- en: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
- en: '*“Balancing” the club’s budget?! We promise that wheel have no more unicycle
    jokes!*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*“平衡”俱乐部的预算？！我们承诺不再开一些独轮车的笑话！*'
- en: Imagine that you’ve been elected treasurer of your school’s unicycling club
    and its time to do the books and balance the budget. You have a large notebook
    with all of the club’s finances. As you work, you copy a few numbers from the
    binder onto a scratch sheet, do some computations using a calculator, and jot
    those results down on your scratch sheet. Occasionally, you might copy some of
    those results back into the big notebook to save for the future and then jot some
    more numbers from the notebook onto your scratch sheet.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你被选为学校独轮车俱乐部的财务主管，现在是时候做账和平衡预算了。你有一个大笔记本记录着俱乐部的财务情况。在工作时，你从大本子上抄下一些数字到草稿纸上，使��计算器进行一些计算，并将结果记在草稿纸上。偶尔，你可能会将其中一些结果复制回大本子以备将来使用，然后再从大本子上抄一些数字到草稿纸上。
- en: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
- en: '*We spoke too soon about no more unicycle jokes.*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们说得太早了，关于不再开一些独轮车的笑话。*'
- en: A modern computer operates on the same principle. Your calculator and the scratch
    sheet correspond to the *CPU* of the computer. The CPU is where computation is
    performed but there’s not enough memory there to store all of the data that you
    will need. The big notebook corresponds to the computer’s memory. These two parts
    of the computer are physically separate components that are connected by wires
    on your computer’s circuit board.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一台现代计算机也是按照相同的原理运行的。你的计算器和草稿纸对应于计算机的 *CPU*。CPU 是进行计算的地方，但那里没有足够的内存来存储你将需要的所有数据。大笔记本对应于计算机的内存。计算机的这两个部分是物理上分开的组件，通过计算机电路板上的电线连接在一起。
- en: What’s in the CPU? There are devices like ripple-carry adders, multipliers,
    and their ilk for doing arithmetic. These devices can all be built using the concepts
    that we saw earlier in this chapter, namely the minterm expansion principle and
    modular design. The CPU also has a small amount of memory, corresponding to the
    scratch sheet. This memory comprises a small number of *registers* where we can
    store data. These registers could be built out of latches or other related devices.
    Computers typically have on the order of 16 to 32 of these registers, each of
    which can store 32 or 64 bits. All of the CPU’s arithmetic is done using values
    in the registers. That is, the adders, multipliers, and so forth expect to get
    their inputs from registers and to save the results to a register, just as you
    would expect to use your scratch pad for the input and output of your computations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 里面有什么？有一些用于执行算术运算的设备，例如连锁进位加法器、乘法器等。这些设备都可以使用本章前面介绍的概念构建，即最小项展开原理和模块化设计。CPU
    还有一小部分内存，对应于临时存储器。这种内存包括一小部分 *寄存器*，我们可以在其中存储数据。这些寄存器可以由锁存器或其他相关设备构建。计算机通常具有大约
    16 至 32 个这些寄存器，每个寄存器可以存储 32 或 64 位。CPU 的所有算术运算都是使用寄存器中的值完成的。也就是说，加法器、乘法器等设备希望从寄存器获取它们的输入，并将结果保存到寄存器中，就像您期望使用您的临时存储器来输入和输出计算的结果一样。
- en: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien.PNG](../Images/Alien.PNG)](../Images/Alien.PNG)'
- en: '*See! We didn’t tire you with any more unicycle puns.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*看！我们没有再用更多的独轮车双关语来烦你了。*'
- en: The memory, corresponding to the big notebook, can store a lot of data - probably
    billions of bits! When the CPU needs data that is not currently stored in a register
    (scratch pad), it requests that data from memory. Similarly, when the CPU needs
    to store the contents of a register (perhaps because it needs to use that register
    to store some other values), it can ship it off to be stored in memory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 内存，对应于大笔记本，可以存储大量数据 - 可能是数十亿位！当 CPU 需要的数据当前未存储在寄存器（临时存储器）中时，它会从内存请求数据。同样，当 CPU
    需要存储寄存器的内容（可能是因为它需要使用该寄存器存储其他值），它可以将其发送以存储在内存中。
- en: 'What’s the point of having separate registers and memory? Why not just have
    all the memory in the CPU? The answer is multifaceted, but here is part of it:
    The CPU needs to be small in order to be fast. Transmitting a bit of data along
    a millimeter of wire slows the computer down considerably! On the other hand,
    the memory needs to be large in order to store lots of data. Putting a large memory
    in the CPU would make the CPU slow. In addition, there are other considerations
    that necessitate separating the CPU from the memory. For example, CPUs are built
    using different (and generally much more expensive) manufacturing processes than
    memories.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要有单独的寄存器和内存？为什么不直接将所有内存放在 CPU 中？答案是多方面的，但其中一部分是：CPU 需要小才能快。在一毫米的导线上传输一位数据会显著减慢计算机的速度！另一方面，内存需要大才能存储大量数据。将大内存放在
    CPU 中会使 CPU 变慢。此外，还有其他考虑因素需要将 CPU 与内存分开。例如，CPU 使用不同（通常更昂贵）的制造工艺来制造。
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*Memory is slow. If the CPU can read from or write to a register in one unit
    of time, it will take approximately 100 units of time to read from or write to
    memory!*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存速度慢。如果 CPU 可以在一个时间单位内从寄存器读取或写入，那么从内存读取或写入大约需要 100 个时间单位！*'
- en: Now, let’s complicate the picture slightly. Imagine that the process of balancing
    the unicycle club’s budget is complicated. The steps required to do the finances
    involve making decisions along the way (e.g. “If we spent more than $500 on unicycle
    seats this year, we are eligible for a rebate.”) and other complications. So,
    there is a long sequence of instructions that is written in the first few pages
    of our club notebook. This set of instructions is a program! Since the program
    is too long and complicated for you to remember, you copy the instructions one-by-one
    from the notebook onto your scratch sheet. You follow that instruction, which
    might tell you, for example, to add some numbers and store them some place. Then,
    you fetch the next instruction from the notebook.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微复杂化这个情景。想象一下，平衡独轮车俱乐部预算的过程是复杂的。进行财务的步骤涉及沿途做出决策（例如，“如果今年我们在独轮车座椅上花费超过500美元，我们有资格获得退款。”）和其他复杂情况。因此，在我们俱乐部笔记本的前几页上写有一长串指令。这组指令就是一个程序！由于程序太长且复杂，你无法记住，所以你从笔记本上一一复制指令到你的草稿纸上。然后，你按照指令执行，比如，可能会告诉你添加一些数字并将它们存储在某个地方。然后，你从笔记本中获取下一个指令。
- en: How do you remember which instruction to fetch next and how do you remember
    the instruction itself? The CPU of a computer has two special registers just for
    this purpose. A register called the *program counter* keeps track of the location
    in memory where it will find the next instruction. That instruction is then fetched
    from memory and stored in a special register called the *instruction register*.
    The computer examines the contents of the instruction register, executes that
    instruction, and then increments the program counter so that it will now fetch
    the next instruction.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何记住下一个要获取的指令以及如何记住指令本身？计算机的中央处理器有两个专门的寄存器用于此目的。一个名为*程序计数器*的寄存器跟踪它将找到下一个指令的内存位置。然后，该指令从内存中获取并存储在一个名为*指令寄存器*的特殊寄存器中。计算机检查指令寄存器的内容，执行该指令，然后增加程序计数器，以便现在获取下一个指令。
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: '**John von Neumann (1903-1957)**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**约翰·冯·诺伊曼（1903-1957）**'
- en: One of the great pioneers of computing was John von Neumann(pronounced “NOY-mahn”),
    a Hungarian-born mathematician who contributed to fields as diverse as set theory
    and nuclear physics. He invented the Monte Carlo method (which we used to calculate
    \(\pi\) in Section 1.1.2), cellular automata, the *merge sort* method for sorting,
    and of course the von Neumann architecture for computers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机领域的伟大先驱之一是约翰·冯·诺伊曼（发音为“NOY-mahn”），一位出生于匈牙利的数学家，他对集合论和核物理等领域做出了贡献。他发明了蒙特卡洛方法（我们在第1.1.2节中用来计算\(\pi\)），细胞自动机，*归并排序*方法用于排序，当然还有冯·诺伊曼计算机体系结构。
- en: Although von Neumann was famous for wearing a three-piece suit everywhere—including
    on a mule trip in the Grand Canyon and even on the tennis court—he was not a boring
    person. His parties were always popular (although he sometimes sneaked away from
    his guests to work) and he loved to quote from his voluminous memory of off-color
    limericks. Despite his brilliance, he was a notoriously bad driver, which might
    explain why he bought a new car every year.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管冯·诺伊曼以到处穿着三件套而闻名——甚至在大峡谷的骡子之旅和甚至在网球场上也是如此——他并不是一个无聊的人。他的聚会总是受欢迎的（尽管他有时会偷偷离开客人去工作），他喜欢引用他丰富的下流打油诗记忆。尽管他很聪明，但他是一个臭名昭著的糟糕司机，这也许可以解释为什么他每年都会买一辆新车。
- en: Von Neumann died of cancer, perhaps caused by radiation from atomic-bomb tests.
    But his legacy lives on in every computer built today.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 冯·诺伊曼死于癌症，可能是由于原子弹试验的辐射造成的。但他的遗产在今天建造的每台计算机中延续着。
- en: This way of organizing computation was invented by the famous mathematician
    and physicist, Dr. John von Neumann, and is known as the *von Neumann architecture*.
    While computers differ in all kinds of ways, they all use this fundamental principle.
    In the next subsection we’ll look more closely at how this principle is used in
    a real computer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织计算的方式是由著名数学家和物理学家约翰·冯·诺伊曼博士发明的，被称为*冯·诺伊曼体系结构*。尽管计算机在各种方面有所不同，但它们都使用这一基本原则。在下一小节中，我们将更仔细地看看这个原则是如何在实际计算机中使用的。
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*One of von Neumann’s colleagues was Dr. Claude Shannon—inventor of the minterm
    expansion principle. Shannon, it turns out, was also a very good unicyclist.*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*冯·诺伊曼的一位同事是克劳德·香农博士——发明了最小项展开原理。事实证明，香农也是一个非常优秀的独轮车手。*'
- en: 4.4.1 The von Neumann Architecture
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 冯·诺伊曼体系结构
- en: We mentioned that the computer’s memory stores both instructions and data. We
    know that data can be encoded as numbers, and numbers can be encoded in binary.
    But what about the instructions? Good news! Instructions too can be stored as
    numbers by simply adopting some convention that maps instructions to numbers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到计算机的内存存储着指令和数据。我们知道数据可以编码为数字，而数字可以以二进制形式编码。那么指令呢？好消息！指令也可以简单地被存储为数字，只需采用一些将指令映射到数字的惯例。
- en: 'For example, let’s assume that our computer is based on 8-bit numbers and let’s
    assume that our computer only has four instructions: add, subtract, multiply,
    and divide. (That’s very few instructions, but let’s start there for now and then
    expand later). Each of these instructions will need a number, called an *operation
    code* (or *opcode*), to represent it. Since there are four opcodes, we’ll need
    four numbers, which means two bits per number. For example, we might choose the
    following opcodes for our instructions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的计算机是基于8位数字的，并且假设我们的计算机只有四个指令：add、subtract、multiply和divide。（这些指令很少，但让我们从这里开始，然后再扩展）。每个指令都需要一个称为*操作码*（或*opcode*）的数字来表示它。由于有四个操作码，我们将需要四个数字，即每个数字两位。例如，我们可以为我们的指令选择以下操作码：
- en: '![../Images/ops.PNG](../Images/ops.PNG)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/ops.PNG](../Images/ops.PNG)'
- en: Next, let’s assume that our computer has four registers number 0 through 3\.
    Imagine that we want to add two numbers. We must specify the two registers whose
    values we wish to add and the register where we wish to store the result. If we
    want to add the contents of register 2 with the contents of register 0 and store
    the result in register 3, we could adopt the convention that we’ll write “add
    3, 0, 2”. The last two numbers are the registers where we’ll get our inputs and
    the first number is the register where we’ll store our result. In binary, “add
    3, 0, 2” would be represented as “00 11 00 10”. We’ve added the spaces to help
    you see the numbers 00 (indicating “add”), 11 (indicating the register where the
    result will be stored), 00 (indicating register 0 as the first register that we
    will add), and 10 (indicating register 2 as the second register that we will add).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们假设我们的计算机有四个寄存器，编号从0到3。想象一下，我们要将两个数字相加。我们必须指定我们想要相加的两个寄存器的值以及我们希望存储结果的寄存器。如果我们想要将寄存器2的内容与寄存器0的内容相加，并将结果存储在寄存器3中，我们可以采用这样的惯例：我们将写“add
    3, 0, 2”。最后两个数字是我们将获得输入的寄存器，第一个数字是我们将存储结果的寄存器。以二进制表示，“add 3, 0, 2”将表示为“00 11 00
    10”。我们已经添加了空格，以帮助您看到数字00（表示“add”），11（表示将存储结果的寄存器），00（表示我们将添加的第一个寄存器），以及10（表示我们将添加的第二个寄存器）。
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*Computer scientists often start counting from 0.*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机科学家通常从0开始计数。*'
- en: 'In general, we can establish the convention that an instruction will be encoded
    using 8 bits as follows: The first two bits (which we’ll call I0 and I1) represent
    the instruction, the next two bits (D0 and D1) encode the “destination register”
    where our result will be stored, the next two bits (S0 and S1) encode the first
    register that we will add, and the last two bits (T0 and T1) encode the second
    register that we will add. This representation is shown below.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，我们可以建立以下惯例：一条指令将使用8位来编码，具体如下：前两位（我们称为I0和I1）表示指令，接下来的两位（D0和D1）编码“目标寄存器”，我们的结果将存储在其中，接下来的两位（S0和S1）编码我们将添加的第一个寄存器，最后两位（T0和T1）编码我们将添加的第二个寄存器。下图显示了这种表示方法。
- en: '![../Images/rep.PNG](../Images/rep.PNG)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/rep.PNG](../Images/rep.PNG)'
- en: Recall that we assume that our computer is based on 8-bit numbers. That is,
    each register stores 8 bits and each number in memory is 8 bits long. Figure 4.9
    shows what our computer might look like. Notice the program counter at the top
    of the CPU. Recall that this register contains a number that tells us where in
    memory to fetch the next instruction. At the moment, this program counter is 00000000,
    indicating address 0 in memory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们假设我们的计算机是基于8位数字的。也就是说，每个寄存器存储8位，内存中的每个数字都是8位长。图4.9显示了我们的计算机可能的外观。注意CPU顶部的程序计数器。回想一下，这个寄存器包含一个数字，告诉我们从内存中的哪个位置获取下一条指令。目前，这个程序计数器是00000000，表示内存中的地址0。
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*So a computer is kind of like a dog?*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*所以计算机有点像狗？*'
- en: The computer begins by going to this memory location and fetching the data that
    resides there. Now look at the memory, shown on the right side of the figure.
    The memory addresses are given both in binary (base 2) and in base 10\. Memory
    location 0 contains the data 00100010\. This 8-bit sequence is now brought into
    the CPU and stored in the instruction register. The CPU’s logic gates decode this
    instruction. The leading 00 indicates it’s an addition instruction. The following
    10 indicates that the result of the addition that we’re about to perform will
    be stored in register 2\. The next 00 and 10 mean that we’ll get the data to add
    from registers 0 and 2, respectively. These values are then sent to the CPU’s
    ripple-carry adder where they are added. Since registers 0 and 2 contain 00000101
    and 00001010, respectively, before the operation, after the operation register
    2 will contain the value 00001111.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机首先会转到这个存储位置，并获取那里的数据。现在看一下图中右侧的存储器。存储器地址既以二进制（2进制）给出，也以十进制给出。存储位置0包含数据00100010。这个8位序列现在被带入CPU并存储在指令寄存器中。CPU的逻辑门解码这条指令。前导的00表示这是一条加法指令。接下来的10表示我们即将执行的加法的结果将存储在寄存器2中。接下来的00和10表示我们将从寄存器0和2中分别获取要添加的数据。这些值然后被发送到CPU的逐位进位加法器中，它们被相加。由于操作之前，寄存器0和2分别包含00000101和00001010，所以操作后寄存器2将包含值00001111。
- en: 'In general, our computer operates by repeatedly performing the following procedure:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们的计算机通过反复执行以下过程来运行：
- en: Send the address in the program counter (commonly called the *PC* ) to the memory,
    asking it to read that location.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将程序计数器（通常称为*PC*）中的地址发送到存储器，要求它读取该位置。
- en: Load the value from memory into the instruction register.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储器中的值加载到指令寄存器中。
- en: '*Decode* the instruction register to determine what instruction to execute
    and which registers to use.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*解码*指令寄存器以确定要执行的指令和要使用的寄存器。'
- en: '*Execute* the requested instruction. This step often involves reading operands
    from registers, performing arithmetic, and sending the results back to the destination
    register. Doing so usually involves several sub-steps.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*执行*请求的指令。这一步通常涉及从寄存器中读取操作数，执行算术运算，并将结果发送回目标寄存器。这通常涉及几个子步骤。'
- en: Increment the PC (Program Counter) so that it contains the address of the next
    instruction in memory. (It is this step that gives the PC its name, because it
    *counts* its way through the addresses in the program.)
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PC（程序计数器）递增，使其包含内存中下一条指令的地址。（正是这一步赋予PC它的名称，因为它通过程序中的地址进行*计数*。）
- en: '![../Images/cpumem.PNG](../Images/cpumem.PNG)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/cpumem.PNG](../Images/cpumem.PNG)'
- en: 'Figure 4.9: A computer with instructions stored in memory. The program counter
    tells the computer where to get the next instruction.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：存储指令的计算机。程序计数器告诉计算机从哪里获取下一条指令。
- en: “Wait!” we hear you scream. “The memory is storing *both* instructions *and*
    data! How can it tell which is which?!” That’s a great question and we’re glad
    you asked. The truth is that the computer *can’t tell* which is which. If we’re
    not careful, the computer might fetch something from memory into its instruction
    register and try to execute it when, in fact, that 8-bit number represents the
    number of pizzas that the unicycle club purchased and not an instruction! One
    way to deal with this is to have an additional special instruction called “halt”
    that tells the computer to stop fetching instructions. In the next subsections
    we’ll expand our computer to have more instructions (including “halt”) and more
    registers and we’ll write some real programs in the language of the computer.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: “等等！”我们听到你喊道。“存储器同时存储*指令*和*数据*！它怎么知道哪个是哪个？！”这是一个很好的问题，我们很高兴你问。事实上，计算机*无法*区分哪个是哪个。如果我们不小心，计算机可能会从存储器中获取一些东西到它的指令寄存器中并尝试执行它，而实际上，这个8位数代表自行车俱乐部购买的比萨饼数量，而不是一条指令！解决这个问题的一种方法是增加一个额外的特殊指令，称为“停止”，告诉计算机停止获取指令。在接下来的小节中，我们将扩展我们的计算机，增加更多的指令（包括“停止”）和更多的寄存器，并且我们将用计算机语言编写一些真正的程序。
- en: '**Takeaway message:** *A computer uses a simple process of repeatedly fetching
    its next instruction from memory, decoding that instruction, executing that instruction,
    and incrementing the program counter. All of these steps are implemented with
    digital circuits that, ultimately, can be built using the processes that we’ve
    described earlier in this chapter.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**主要信息：** *计算机使用一个简单的过程，不断从内存中获取下一个指令，解码该指令，执行该指令，并增加程序计数器。所有这些步骤都是通过数字电路实现的，最终可以使用我们在本章前面描述的过程构建。*'
- en: 4.5 Hmmm
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 Hmmm
- en: 'The computer we discussed in Section 4.4 is simple to understand, but its simplicity
    means it’s not very useful. In particular, a real computer also needs (at a minimum)
    ways to:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第4.4节讨论的计算机很容易理解，但它的简单意味着它并不是很有用。特别是，一个真正的计算机还需要（至少）以下方式：
- en: Move information between the registers and a large memory,
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在寄存器和大内存之间移动信息，
- en: Get data from the outside world,
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从外部世界获取数据，
- en: Print results, and
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果，并且
- en: Make decisions.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做出决定。
- en: 'To illustrate how these features can be included, we have designed the Harvey
    Mudd Miniature Machine, or Hmmm. Just like our earlier 4-instruction computer,
    Hmmm has a program counter, an instruction register, a set of data registers,
    and a memory. These are organized as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何包含这些特性，我们设计了哈维莫德小型机器，或者说Hmmm。就像我们之前的4指令计算机一样，Hmmm有一个程序计数器，一个指令寄存器，一组数据寄存器和一个内存。这些组织如下：
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*Hmmm is music to my ears!*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hmmm是我耳中的音乐！*'
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*Different computers have different word sizes. Most machines sold today use
    64-bit words; older ones use 32 bits. 16-bit, 8-bit, and even 4-bit computers
    are still used for special applications. Your digital watch probably contains
    a 4-bit computer.*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*不同的计算机有不同的字长。今天出售的大多数机器使用64位字；旧的机器使用32位。16位、8位甚至4位的计算机仍然用于特殊应用。你的数码手表可能包含一个4位计算机。*'
- en: While our simple computer used 8-bit instructions, in Hmmm, both instructions
    and data are 16 bits wide. The set of bits representing an instruction is called
    a *word*. That allows us to represent a reasonable range of numbers, and lets
    the instructions be more complicated.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们的简单计算机使用8位指令，在Hmmm中，指令和数据都是16位宽。表示指令的一组位被称为*字*。这使我们能够表示一个合理范围的数字，并使指令更加复杂。
- en: 'In addition to the program counter and instruction register, Hmmm has 16 registers,
    named R0 through R15\. R0 is special: it always contains zero, and anything you
    try to store there is thrown away.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了程序计数器和指令寄存器，Hmmm有16个寄存器，命名为R0到R15。R0是特殊的：它始终包含零，任何你尝试存储在那里的东西都会被丢弃。
- en: Hmmm’s memory contains 256 locations. Although the memory can be used for either
    instructions or data, programs are prevented from reading or writing the instruction
    section of memory. (Some modern computers offer a similar feature.)
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hmmm的内存包含256个位置。尽管内存可以用于指令或数据，但程序被阻止读取或写入内存的指令部分。（一些现代计算机提供类似的功能。）
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*Hmmm’s instruction set is large, but not hmmmungous.*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hmmm的指令集很大，但不是非常庞大。*'
- en: 'It’s very inconvenient to program Hmmm by writing down the bits corresponding
    to the instructions. Instead, we will use *assembly language*, which is a programming
    language where each machine instruction receives a friendlier symbolic representation.
    For example, to compute R3 = R1 + R2, we would write:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过写下对应指令的位很不方便来编程Hmmm。相反，我们将使用*汇编语言*，这是一种编程语言，其中每个机器指令都有一个更友好的符号表示。例如，要计算R3
    = R1 + R2，我们会写：
- en: '[PRE2]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A very simple process is used to convert this assembly language into the 0’s
    and 1’s - the “machine language” - that the computer can execute.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个非常简单的过程将这种汇编语言转换为计算机可以执行的0和1 - 计算机可以执行的“机器语言”。
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: A complete list of Hmmm instructions, including their binary encoding, is given
    in Figure 4.10.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了Hmmm指令的完整列表，包括它们的二进制编码，如图4.10所示。
- en: 4.5.1 A Simple Hmmm Program
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 一个简单的Hmmm程序
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*Not the least of which is that writing even a short program in assembly language
    can be a hmmmbling experience!*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*其中之一是，用汇编语言编写一个简短的程序可能是一种令人费解的体验！*'
- en: To begin with, let’s look at a program that will calculate the approximate area
    of a triangle. It’s admittedly mundane, but it will help us move on to more interesing
    Hmmm-ing shortly. (We suggest that you follow along by downloading Hmmm from [http://www.cs.hmc.edu/~cs5grad/cs5/hmmm/documentation/documentation.html](http://www.cs.hmc.edu/~cs5grad/cs5/hmmm/documentation/documentation.html)
    and trying these examples out with us.)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个计算三角形近似面积的程序。这可能有点乏味，但它会帮助我们很快进入更有趣的 Hmmm 编程。（我们建议您从[http://www.cs.hmc.edu/~cs5grad/cs5/hmmm/documentation/documentation.html](http://www.cs.hmc.edu/~cs5grad/cs5/hmmm/documentation/documentation.html)下载
    Hmmm 并尝试这些示例。）
- en: 'Let’s begin by using our favorite editor to create a file named `triangle1.hmmm`
    with the following contents:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用我们最喜欢的编辑器创建一个名为 `triangle1.hmmm` 的文件，内容如下：
- en: '[PRE3]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How Does It Work?
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: What does all of this mean? First, anything starting with a pound sign (“#”)
    is a comment; Hmmm ignores it. Second, you’ll note that each line is numbered,
    starting with zero. This number indicates the memory location where the instruction
    will be stored.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着什么？首先，任何以井号（“#”）开头的内容都是注释；Hmmm 会忽略它。其次，您会注意到每行都有编号，从零开始。这个数字表示指令将存储的内存位置。
- en: 'You may have also noticed that this program doesn’t use any commas, unlike
    the example `add` instruction above. Hmmm is very lenient about notation; all
    of the following instructions mean exactly the same thing:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到，这个程序不使用逗号，不像上面的 `add` 指令示例。Hmmm 对符号非常宽容；以下所有指令都表示完全相同的意思：
- en: '[PRE4]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Needless to say, we don’t recommend the last two options!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，我们不推荐最后两个选项！
- en: So what do all of these lines actually do? The first two (0 and 1) read in the
    base and height of the triangle. When Hmmm executes a `read` instruction, it pauses
    and prompts the user to enter a number, converts the user’s number into binary,
    and stores it into the named register. So the first-typed number will go into
    register R1, and the second into R2.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些行实际上做什么？前两行（0 和 1）读取三角形的底和高。当 Hmmm 执行 `read` 指令时，它会暂停并提示用户输入一个数字，将用户的数字转换为二进制，并将其存储到命名寄存器中。因此，第一个输入的数字将进入寄存器
    R1，第二个进入 R2。
- en: 'The `MUL`tiply instruction then finds \(b\times h\) by calculating R1 = R1
    \(\times\) R2\. This instruction illustrates three important principles of hmmm
    programming:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`MUL`tiply 指令通过计算 R1 = R1 \(\times\) R2 来找到 \(b\times h\)。这个指令展示了 hmmm 编程的三个重要原则：'
- en: 'Most arithmetic instructions accept three registers: two *sources* and a *destination*.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数算术指令接受三个寄存器：两个 *源* 和一个 *目的地*。
- en: The destination register is always listed first, so that the instruction can
    be read somewhat like a Python assignment statement.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目的地寄存器总是首先列出，这样指令可以有点像 Python 赋值语句。
- en: A source and destination can be the same.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源和目的地可以是相同的。
- en: After multiplying, we need to divide \(b\times h\) by 2\. But where can we get
    the constant 2? One option would be to ask the user to provide it via a `read`
    instruction, but that seems clumsy. Instead, a special instruction, `setn` (*set
    to number*), lets us insert a small constant into a register. As with `mul`, the
    destination is given first; this is equivalent to the Python statement R2 = 2.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法后，我们需要将 \(b\times h\) 除以 2。但我们从哪里可以得到常数 2？一个选项是要求用户通过 `read` 指令提供它，但这似乎很笨拙。相反，一个特殊指令
    `setn`（*设置为数字*）让我们将一个小常数插入到一个寄存器中。与 `mul` 一样，目的地首先给出；这相当于 Python 语句 R2 = 2。
- en: 'The `DIV`ide instruction finishes the calculation, and `write` displays the
    result on the screen. There is one thing left to do, though: after the `write`
    is finished, the computer will happily try to execute the instruction at the following
    memory location. Since there isn’t a valid instruction there, the computer will
    fetch a collection of bits there that are likely to be invalid as an instruction,
    causing the computer to crash. So we need to tell it to `halt` after it’s done
    with its work.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`DIV`ide 指令完成计算，`write` 在屏幕上显示结果。但还有一件事要做：在 `write` 完成后，计算机将愉快地尝试执行下一个内存位置的指令。由于那里没有有效的指令，计算机将获取一组位，这些位很可能不是有效的指令，导致计算机崩溃。因此，我们需要告诉它在完成工作后`halt`。'
- en: That’s it! But will our program work
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！但我们的程序会起作用吗？
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*It would be hmmmurous if we got this wrong*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们搞错了那将会很有趣*'
- en: Trying It Out
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 试一下
- en: 'We can *assemble* the program by running `hmmmAssembler.py` from the command
    line: [[1]](#id5) User-typed input is shown in blue and the prompt is shown using
    the symbol `%`. The prompt on your computer may look different.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在命令行中运行`hmmmAssembler.py`来*组装*程序：[[1]](#id5) 用户输入以蓝色显示，并使用符号`％`显示提示符。您计算机上的提示符可能看起来不同。
- en: '[PRE5]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you have errors in the program, `hmmmAssembler.py` will tell you; otherwise
    it will produce the output file `triangle1.hb` (“hb” stands for “Hmmm binary”).
    We can then test our program by running the Hmmm simulator:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序中有错误，`hmmmAssembler.py`会告诉您；否则，它将生成输出文件`triangle1.hb`（“hb”代表“Hmmm二进制”）。然后，我们可以通过运行Hmmm模拟器来测试我们的程序：
- en: '[PRE6]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that the program produced the correct answer for the first test case,
    but not for the second. That’s because Hmmm only works with integers; division
    rounds fractional values down to the next smaller integer just as integer division
    does in Python.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该程序对第一个测试案例产生了正确的答案，但对第二个测试案例没有产生。那是因为Hmmm只能处理整数；除法会将分数值向下舍入到下一个较小的整数，就像Python中的整数除法一样。
- en: 4.5.2 Looping
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 循环
- en: 'If you want to calculate the areas of a lot of triangles, it’s a nuisance to
    have to run the program over and over. Hmmm offers a solution in the *unconditional
    jump* instruction, which says “instead of executing the next sequential instruction,
    start reading instructions beginning at address *n* .” If we simply replace the
    `halt` with a jump:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想计算许多三角形的面积，反复运行程序会很麻烦。Hmmm在*无条件跳转*指令中提供了一种解决方案，它表示“不执行下一个顺序指令，而是从地址*n*开始阅读指令”。如果我们只是用跳转替换`halt`：
- en: '[PRE7]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: then our program will calculate triangle areas forever.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们的程序将永远计算三角形的面积。
- en: What’s that `jumpn 0` instruction doing? The short explanation is that it’s
    telling the computer to jump back to location 0 and continue executing the program
    there. The better explanation is that this instruction simply puts the number
    0 in the program counter. Remember, the computer mindlessly checks its program
    counter to determine where to fetch its next instruction from memory. By placing
    a 0 in the program counter, we are ensuring that the next time the computer goes
    to fetch an instruction it will fetch it from memory location 0.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`jumpn 0`指令是做什么的？简短的解释是，它告诉计算机跳回到位置0并继续在那里执行程序。更好的解释是，这条指令只是把数字0放在程序计数器中。记住，计算机无意识地检查其程序计数器以确定从内存中的哪里获取下一条指令。通过将0放入程序计数器，我们确保计算机下次去获取指令时将从内存位置0获取。
- en: 'Since there will come a time when we want to stop, we can *force* the program
    to end by holding down the Ctrl (“Control”) key and typing C (this is commonly
    written “Ctrl-C” or just “^C”’):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于总会有一天我们想停止，我们可以通过按住Ctrl（“Control”）键并键入C来*强制*程序结束（这通常写作“Ctrl-C”或“^C”）：
- en: '[PRE8]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That works, but it produces a somewhat ugly message at the end. A nicer approach
    might be to automatically halt if the user inputs a zero for either the base or
    the height. We can do that with a *conditional jump* instruction, which works
    like `jumpn` if some *condition* is true, and otherwise does nothing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效，但在最后会产生一条相当难看的消息。一个更好的方法可能是，如果用户为底边或高度输入了零，则自动停止。我们可以使用*条件跳转*指令来做到这一点，它的工作方式类似于如果某个*条件*为真则执行`jumpn`，否则不执行任何操作。
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*I believe that I learned that when someone jeqzn’s I should say “gesundheit”*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*我相信我学到了当有人打喷嚏时我应该说“健康”*'
- en: There are several varieties of conditional jump statements and the one we’ll
    use here is called `jeqzn` which is pronounced “jump to *n* if equal to zero”
    or just “jump if equal to zero.” This conditional jump takes a register and a
    number as input. If the specified register contains the value zero then we will
    jump to the instruction specified by the number in the second argument. That is,
    if the register contains zero then we will place the number in the second argument
    in the program counter so that the computer will continue computing using that
    number as its next instruction.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种条件跳转语句的变体，我们将在这里使用的是`jeqzn`，它的发音是“如果等于零则跳转到*n*”或简称“等于零则跳转”。这个条件跳转接受一个寄存器和一个数字作为输入。如果指定的寄存器包含值零，则我们将跳转到第二个参数中指定的指令。也就是说，如果寄存器包含零，则我们将在程序计数器中放置第二个参数中的数字，以便计算机将使用该数字作为其下一条指令进行计算。
- en: '[PRE9]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, our program behaves politely:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的程序举止得很有礼貌：
- en: '[PRE10]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The nice thing about conditional jumps is that you aren’t limited to just terminating
    loops; you can also use them to make decisions. For example, you should now be
    able to write a Hmmm program that prints the absolute value of a number. The other
    conditional jump statements in Hmmm are included in the listing of all Hmmm instructions
    at the end of this chapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转的好处在于你不仅仅局限于终止循环；你还可以用它们做出决策。例如，现在你应该能够编写一个 Hmmm 程序，打印一个数的绝对值。Hmmm 中的其他条件跳转语句包含在本章末尾的所有
    Hmmm 指令列表中。
- en: 4.5.3 Functions
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 函数
- en: 'Here is a program that computes factorials:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算阶乘的程序：
- en: '[PRE11]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (If you give this program a negative number, it will crash unpleasantly; how
    could you fix that problem?) The `addn` instruction at line 4 simply adds a constant
    to a register, replacing its contents with the result. We could achieve the same
    effect by using `setn` and a normal `add`, but computer programs add constants
    so frequently that Hmmm provides a special instruction to make the job easier.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: （如果给这个程序一个负数，它会不愉快地崩溃；你怎么解决这个问题？）第 4 行的`addn`指令简单地将一个常数添加到一个寄存器中，用结果替换其内容。我们可以通过使用`setn`和普通的`add`来实现相同的效果，但是计算机程序经常添加常数，因此
    Hmmm 提供了一个特殊指令来简化工作。
- en: But suppose you need to write a program that computes \(({n\atop k}) = {n!\over{k!(n-k)!}}\).
    (If you haven’t seen this formula before, it counts the number of different ways
    to choose \(k\) items from a set of \(n\) distinct items and it’s pronounced ”
    \(n\) choose \(k\) ”.)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但是假设你需要编写一个计算 \(({n\atop k}) = {n!\over{k!(n-k)!}}\) 的程序。（如果你以前没有见过这个公式，它计算从一个包含
    \(n\) 个不同项的集合中选择 \(k\) 个项的不同方式的数量，发音为“ \(n\) 选择 \(k\) ”。）
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*I wouldn’t choose to write that program.*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不会选择写那个程序。*'
- en: Since we need to compute three different factorials, we would like to avoid
    having to copy the above loop three different times. Instead, we’d prefer to have
    a *function* that computes factorials, just like Python has.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要计算三个不同的阶乘，我们希望避免三次复制上面的循环。相反，我们更希望有一个*函数*来计算阶乘，就像 Python 一样。
- en: Creating a function is just a bit tricky. It can’t read its input from the user,
    and it must return the value that it computed to whatever code called that function.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个函数有点棘手。它不能从用户那里读取输入，并且必须将计算得到的值返回给调用该函数的任何代码。
- en: It’s convenient to adopt a few simple conventions to make this all work smoothly.
    One such convention is to decide on special registers to be used for *parameter
    passing*, i.e., getting information into and out of a function. For example, we
    could decide that r1 will contain \(n\) when the factorial function starts, and
    r2 will contain the result. (As we’ll see later, this approach is problematic
    in the general case, but it’s adequate for now.)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 采用一些简单的约定使这一切顺利运行非常方便。其中一个约定是决定用于*参数传递*的特殊寄存器，即将信息传递到函数中和从函数中获取信息。例如，我们可以决定当阶乘函数开始时，r1
    将包含 \(n\)，r2 将包含结果。（正如我们将在后面看到的，这种方法在一般情况下存在问题，但现在是足够的。）
- en: 'Our new program, with the factorial function built in, is:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新程序，内置了阶乘函数，是：
- en: '[PRE12]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the program introduces a number of new instructions. The simplest
    is `nop`, the *no-operation* instruction, at lines 13 and 14\. When executed,
    it does absolutely nothing.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该程序引入了许多新指令。最简单的是`nop`，在第 13 和 14 行的*无操作*指令。当执行时，它什么也不做。
- en: Why would we want such an instruction? If you’ve already written some small
    Hmmm programs, you’ve probably discovered the inconvenience of renumbering lines.
    By including a few `nop`s as *padding*, we make it easy to insert a new instruction
    in the sequence from 0-15 without having to change where the factorial function
    begins.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要这样的指令？如果你已经编写过一些小的 Hmmm 程序，你可能已经发现了重新编号行的不便之处。通过包含一些`nop`作为*填充*，我们可以轻松地在
    0-15 的序列中插入一个新指令，而无需更改阶乘函数的起始位置。
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*One of the hmmmdingers of programming in assembly language!*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*汇编语言编程的一大难点之一！*'
- en: 'Far more interesting is the `calln` instruction, which appears at lines 3,
    6, and 9\. `Calln` works similarly to `jumpn`: it causes Hmmm to start executing
    instructions at a given address, in this case 15\. But if we had just used a `jumpn`,
    after the factorial function calculated its result, it wouldn’t know whether to
    jump back to line 4, line 7, or line 10! To solve the problem, the `calln` uses
    register R14 to save the address of the instruction immediately *following* the
    call. [[2]](#id6)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是`calln`指令，出现在第3、6和9行。`Calln`与`jumpn`类似：它导致Hmmm从给定地址开始执行指令，这里是15。但如果我们只使用`jumpn`，在阶乘函数计算出结果后，它不知道是跳回第4行、第7行还是第10行！为了解决这个问题，`calln`使用寄存器R14保存调用后紧随的指令的地址。[[2]](#id6)
- en: 'We’re not done, though: the factorial function itself faces the other end of
    the same dilemma. R14 contains 4, 7, or 10, but it would be clumsy to write code
    equivalent to “If R14 is 4, jump to 4; otherwise if R14 is 7, jump to 7; ...”
    Instead, the `jumpr` (jump to address in register) instruction solves the problem
    neatly, if somewhat confusingly. Rather than jumping to a fixed address given
    in the instruction (as is done in line 19), `jumpr` goes to a *variable* address
    taken from a register. In other words, if R14 is 4, `jumpr` will jump to address
    4; if it’s 7 it will jump to 7, and so forth.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 不过我们还没有结束：阶乘函数本身面临着同样困境的另一端。R14包含4、7或10，但写出等效于“如果R14是4，则跳转到4；否则如果R14是7，则跳转到7；…”的代码会很笨拙。相反，`jumpr`（跳转到寄存器中的地址）指令巧妙地解决了这个问题，尽管有些令人困惑。与在指令中给出固定地址跳转（如第19行所做）不同，`jumpr`跳转到从寄存器中取出的*变量*地址。换句话说，如果R14是4，`jumpr`将跳转到地址4；如果是7，它将跳转到7，依此类推。
- en: 4.5.4 Recursion
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.4 递归
- en: In Chapter 2 we learned to appreciate the power and elegance of recursion. But
    how can you do recursion in Hmmm assembly language? There must be a way; after
    all, Python implements recursion as a series of machine instructions on your computer.
    To understand the secret, we need to talk about the *stack*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们学会了欣赏递归的力量和优雅。但是在Hmmm汇编语言中如何实现递归呢？肯定有办法；毕竟，Python将递归实现为计算机上的一系列机器指令。要理解这个秘密，我们需要谈论*栈*。
- en: Stacks
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: You may recall that in Chapter 2 we talked about stacks (remember those stacks
    of storage boxes)? Now we’re going to see precisely how they work.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你还记得在第2章中我们谈到了栈（记得那些存储箱的堆叠）？现在我们将看到它们是如何工作的。
- en: 'A stack is something we are all familiar with in the physical world: it’s just
    a pile where you can only get at the top thing. Make a tall stack of books; you
    can only see the cover of the top one, you can’t remove books from the middle
    (at least not without risking a collapse!), and you can’t add books anywhere except
    at the top.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 栈在物理世界中是我们都熟悉的东西：它只是一个堆叠，你只能拿到顶部的东西。堆叠高高的书；你只能看到顶部一本书的封面，你不能从中间取出书（至少不会有倒塌的风险！），你不能在除顶部以外的任何地方添加书。
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*The sheer weight of that book could crush your stack!*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*那本书的厚重可能会压垮你的栈！*'
- en: The reason a stack is useful is because it remembers things and gives them back
    to you in reverse order. Suppose you’re reading *Gone With the Wind* and you start
    wondering whether it presents the American Civil War fairly. You might put *GWTW*
    on a stack, pick up a history book, and start researching. As you’re reading the
    history book, you run into an unfamiliar word. You place the history book on the
    stack and pick up a dictionary. When you’re done with the dictionary, you return
    it to the shelf, and the top of the stack has the history book, right where you
    left off. After you finish your research, you put that book aside, and voilá!
    *GWTW* is waiting for you.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 栈之所以有用，是因为它记住事物并以相反的顺序返回给你。假设你正在阅读《飘》并开始思考它是否公平地展现了美国内战。你可能把《飘》放在栈上，拿起一本历史书开始研究。当你阅读历史书时，遇到一个陌生的词。你把历史书放在栈上，拿起一本词典。当你用完词典后，把它放回书架，栈的顶部是历史书，就在你离开的地方。研究结束后，你把那本书放在一边，嘿！《飘》等着你。
- en: This technique of putting things aside and then returning to them is precisely
    what we need for recursion. To calculate \(5!\), you need to find \(4!\) for which
    you need \(3!\) and so forth. A stack can remember where we were in the calculation
    of \(4!\) and help us to return to it later.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 将事物放在一边然后返回到它们正是我们递归所需要的。要计算\(5!\)，你需要找到\(4!\)，为此需要\(3!\)等等。栈可以记住我们在计算\(4!\)时的位置，并帮助我们稍后返回。
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*Again, this is just a convention.*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*再次强调，这只是一个约定。*'
- en: To implement a stack on a computer, we need a *stack pointer*, which is a register
    that holds the memory address of the top item on the stack. Traditionally, the
    stack pointer is kept in the highest-numbered register, so on Hmmm we use R15.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要在计算机上实现一个栈，我们需要一个*栈指针*，它是一个保存栈顶项的内存地址的寄存器。传统上，栈指针被保存在编号最高的寄存器中，所以在 Hmmm 上我们使用R15。
- en: 'Suppose R15 currently contains 102, [[3]](#id7) and the stack contains 42 (on
    top), 56, and 12\. Then we would draw the stack like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 假设R15当前包含102，[[3]](#id7)，栈包含42（在顶部），56和12。那么我们会这样画栈：
- en: '![../Images/stack.PNG](../Images/stack.PNG)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/stack.PNG](../Images/stack.PNG)'
- en: To *push* a value, say 23, onto the stack, we must increment R15 to contain
    the address of a new location (103) and then store 23 into that spot in memory.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*推送*一个数值，比如23，进栈，我们必须增加R15的值，使其包含一个新的地址（103），然后将23存储到内存中的那个位置。'
- en: Later, to *pop* the top value off, we must ask R15 where the top is [[4]](#id8)
    (103) and recover the value in that location. Then we decrement R15 so that it
    points to the new stack top, location 102\. Everything is now back where we started.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，为了从栈顶弹出顶部值，我们必须询问R15顶部在哪里[[4]](#id8)（103），并恢复该位置的值。然后，我们减少R15，使其指向新的栈顶，位置102。现在一切又回到了原点。
- en: 'The code to push something, say the contents of R4, on the stack looks like
    this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 推送某物，比如R4的内容，到栈上的代码看起来像这样：
- en: '[PRE13]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `storer` instruction stores the contents of R4 into the memory location
    *addressed* by register 15\. In other words, if R15 contains 103, the value in
    R4 will be copied into memory location 103.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`storer`指令将R4的内容存储到寄存器15寻址的内存位置。换句话说，如果R15包含103，那么R4中的值将被复制到内存位置103。'
- en: 'Just as `storer` can put things onto the stack, `loadr` will recover them:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`storer`可以将东西放入栈中，`loadr`将恢复它们：
- en: '[PRE14]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Important note:** in the first example above, the stack pointer is incremented
    *before* the `storer`; in the second, it is decremented *after* the loadr`. This
    ordering is necessary to make the stack work properly; you should be sure you
    understand it before proceeding further.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示：**在上面的第一个例子中，栈指针在`storer`之前被增加；在第二个例子中，在`loadr`之后被减少。这种顺序是使栈正常工作所必需的；在继续之前，你应该确保你理解了这一点。'
- en: Saving Precious Possessions
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存宝贵的东西
- en: When we wrote the \(({n \atop k})\) program in Section 4.5.3, we took advantage
    of our knowledge of how the factorial function on line 15 worked. In particular,
    we knew that it only modified registers R1, R2, and R14, so that we could use
    R3 and R4 for our own purposes. In more complex programs, however, it may not
    be possible to partition the registers so neatly. This is especially true in recursive
    functions, which by their nature tend to re-use the same registers that their
    callers use.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在4.5.3节中编写\(({n \atop k})\)程序时，我们利用了对第15行阶乘函数的工作原理的了解。特别地，我们知道它只修改了寄存器R1、R2和R14，所以我们可以将R3和R4用于我们自己的目的。然而，在更复杂的程序中，可能无法将寄存器如此整齐地分区。这在递归函数中尤其如此，因为它们的本质是倾向于重复使用调用者使用的相同寄存器。
- en: The only way to be sure that a called function won’t clobber your data is to
    save it somewhere, and the stack is a perfect place to use for that purpose. When
    writing a Hmmm program, the convention is that you must save all of your “precious
    possessions” before calling a function, and restore them afterwards. Because of
    how a stack works, you have to restore things in reverse order.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保一个被调用的函数不会破坏你的数据的唯一方法是将其保存在某个地方，而栈是一个完美的地方。在编写一个 Hmmm 程序时，约定是在调用函数之前必须保存所有的“宝贵的东西”，并在调用之后恢复它们。由于栈的工作原理，你必须以相反的顺序恢复这些东西。
- en: But what’s a precious possession? The quick answer is that it’s any register
    that you plan to use, *except* R0 and R15\. In particular, if you are calling
    a function from inside another function, R14 is a precious possession.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么是宝贵的东西呢？简单来说，除了R0和R15之外的任何寄存器都是。特别是，如果你在另一个函数内部调用一个函数，那么R14就是一个宝贵的东西。
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*It’s a common mistake, but to err is hmmman.*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个常见的错误，但出错是人类的。*'
- en: Many newcomers to Hmmm try to take shortcuts with stack saving and restoring.
    That is to reason, “I know that I’m calling two functions in a row, so it’s silly
    to restore my precious possessions and save them again right away.” Although you
    can get away with that trick in certain situations, it’s very difficult to get
    it right, and you are much more likely to cause yourself trouble by trying to
    save time. We strongly suggest that you follow the suggested *stack discipline*
    rigorously to avoid problems.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者尝试在堆栈保存和恢复方面采取捷径。也就是说，“我知道我连续调用两个函数，所以恢复我的宝贵财产然后立即再次保存它们是愚蠢的。”尽管在某些情况下你可以使用这个技巧，但很难做到正确，而且尝试节省时间很可能会给自己带来麻烦。我们强烈建议您严格遵循建议的*堆栈规则*，以避免问题。
- en: 'Let’s look at a Hmmm program that uses the stack. We’ll use the recursive algorithm
    to calculate factorials:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用堆栈的Hmmm程序。我们将使用递归算法来计算阶乘：
- en: '[PRE15]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The main program is quite simple (lines 0 - 4): we read a number from the user,
    call the recursive factorial function, and write the answer, and then halt.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序非常简单（第0-4行）：我们从用户那里读取一个数字，调用递归阶乘函数，然后写出答案，最后停止。
- en: The factorial function is only a bit more complex. After testing for the base
    case of \(0!\), we save our “precious possessions” in preparation for the recursive
    call (lines 6 - 9). But what is precious to us? The function uses registers R1,
    R2, R14, and R15\. We don’t need to save R15 because it’s the stack pointer, and
    R1 doesn’t yet have anything valuable in it. So we only have to save R2 and R14\.
    We follow the stack discipline, placing R2 on the stack (line 7) and then R14
    (line 9).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数稍微复杂一些。在测试\(0!\)的基本情况后，我们为递归调用（第6-9行）保存我们的“宝贵财产”。但对我们来说什么是宝贵的？该函数使用寄存器R1、R2、R14和R15。我们不需要保存R15，因为它是堆栈指针，而R1还没有任何有价值的东西。因此，我们只需要保存R2和R14。我们遵循堆栈规则，在堆栈上放置R2（第7行），然后是R14（第9行）。
- en: After saving our precious possessions, we call ourselves recursively to calculate
    \((N-1)!\) (lines 10–11) and then recover registers R14 (line 12) and R2 (line
    14) in reverse order, again following the stack discipline. Then we multiply \((N-1)!\)
    by \(N\), and we’re done.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存我们的宝贵财产后，我们递归调用自己来计算\((N-1)!\)（第10-11行），然后按相反顺序恢复寄存器R14（第12行）和R2（第14行），再次遵循堆栈规则。然后我们将\((N-1)!\)乘以\(N\)，完成。
- en: It is worth spending a bit of time studying this example to be sure that you
    understand how it operates. Draw the stack on a piece of paper, and work out how
    values get pushed onto the stack and popped back off when the program calculates
    \(3!\).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花点时间研究这个例子，确保你理解它是如何运作的。在一张纸上画出堆栈，并计算程序计算\(3!\)时值是如何被推入堆栈和弹出的。
- en: 4.5.5 The Complete Hmmm Instruction Set
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.5 完整的Hmmm指令集
- en: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien1.PNG](../Images/Alien1.PNG)](../Images/Alien1.PNG)'
- en: '*Note that* `sub` *can be combined with* `jltzn` *to evaluate expressions like*
    \(a<b\).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意* `sub` *可以与* `jltzn` *结合使用来评估类似* \(a<b\) *的表达式*。'
- en: This finishes our discussion of Hmmm. We have covered all of the instructions
    except `sub`, `mod`, `jnezn`, `jgtzn`, and `jltzn`; we trust that those don’t
    need separate explanations.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对Hmmm的讨论。我们已经涵盖了除`sub`、`mod`、`jnezn`、`jgtzn`和`jltzn`之外的所有指令；我们相信这些不需要单独解释。
- en: For convenience, Figure 4.10 at the bottom of the page summarizes the entire
    instruction set, and also gives the binary encoding of each instruction.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，页面底部的图4.10总结了整个指令集，并给出了每个指令的二进制编码。
- en: As a final note, you may find it instructive to compare the encodings of certain
    pairs of instructions. In particular, what is the difference between `add`, `mov`,
    and `nop`? How does `calln` relate to `jumpn`? We will leave you with these puzzles
    as we move on to imperative programming.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能会发现比较某些指令对的编码很有启发性。特别是，`add`、`mov`和`nop`之间有什么区别？`calln`与`jumpn`有什么关系？当我们转向命令式编程时，我们将留下这些谜题给您。
- en: 4.5.6 A Few Last Words
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.6 一些最后的话
- en: What actually happens when we run a program that we’ve written in a language
    such as Python? In some systems, the entire program is first automatically translated
    or *compiled* into machine language (the binary equivalent of assembly language)
    using another program called a *compiler*. The resulting compiled program looks
    like the Hmmm code that we’ve written and is executed on the computer. Another
    approach is to use a program called an *interpreter* that translates the instructions
    one line at a time into something that can be executed by the computer’s hardware.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行用诸如Python等语言编写的程序时，实际上发生了什么？在某些系统中，整个程序首先会被自动翻译或*编译*成机器语言（汇编语言的二进制等效物），使用另一个称为*编译器*的程序。生成的编译程序看起来像我们编写的Hmmm代码，并在计算机上执行。另一种方法是使用一个称为*解释器*的程序，将指令逐行翻译成计算机硬件可以执行的内容。
- en: It’s important to keep in mind that exactly when and how the program gets translated
    - all at once as in the case of a compiler or one line at a time in the case of
    an interpreter - is an issue separate from the language itself. In fact, some
    languages have both compilers and interpreters, so that we can use one or the
    other.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，程序何时以及如何被翻译 - 在编译器一次性翻译或解释器逐行翻译的情况下 - 是一个与语言本身无关的问题。事实上，一些语言既有编译器又有解释器，因此我们可以使用其中之一。
- en: Why would someone even care whether their program was compiled or interpreted?
    In the compiled approach, the entire program is converted into machine language
    before it is executed. The program runs very fast but if there is an error when
    the program runs, we probably won’t get very much information from the computer
    other than seeing that the program “crashed”. In the interpreted version, the
    interpreter serves as a sort of “middle-man” between our program and the computer.
    The interpreter can examine our instruction before translating it into machine
    language. Many bugs can be detected and reported by the interpreter before the
    instruction is ever actually executed by the computer. The “middle-man” slows
    down the execution of the program but provides an opportunity to detect potential
    problems. In any case, ultimately every program that we write is executed as code
    in machine language. This machine language code is decoded by digital circuits
    that execute the code on other circuits.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有人会在意他们的程序是编译还是解释？在编译的方法中，整个程序在执行之前被转换为机器语言。程序运行非常快，但如果程序运行时出现错误，除了看到程序“崩溃”外，我们可能不会从计算机那里得到太多信息。在解释版本中，解释器充当我们的程序和计算机之间的一种“中间人”。解释器可以在将指令转换为机器语言之前检查我们的指令。许多错误可以在指令被计算机实际执行之前被解释器检测并报告。这种“中间人”会减慢程序的执行速度，但提供了检测潜在问题的机会。无论如何，最终我们编写的每个程序都会作为机器语言中的代码执行。这些机器语言代码由执行代码的数字电路解码。
- en: 4.6 Conclusion
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 结论
- en: Aye caramba! That was a lot. We’ve climbed the levels of abstraction from transistors,
    to logic gates, to a ripple-carry adder, and ultimately saw the general idea of
    a how a computer works. Finally, we’ve programmed that computer in its native
    language.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 天啊！这太多了。我们从晶体管、逻辑门、到涟漪进位加法器，最终看到了计算机工作的一般概念。最后，我们用其本地语言编程了那台计算机。
- en: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien1.PNG](../Images/Alien1.PNG)'
- en: '*I think a mochaccino and a donut would be quite meaningful right about now.*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*我觉得现在喝杯摩卡奇诺和一个甜甜圈会很有意义。*'
- en: Now that we’ve seen the foundations of how a computer works, we’re going back
    to programming and problem-solving. In the next couple of chapters, some of the
    programming concepts that we’ll see will be directly tied to the issues that we
    examined in this chapter. We hope that the understanding that you have for the
    internal workings of a computer will help the concepts that we’re about to see
    be even more meaningful than they would be otherwise.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了计算机工作的基础，我们将回到编程和问题解决。在接下来的几章中，我们将看到一些编程概念与我们在本章中探讨的问题直接相关。我们希望您对计算机内部工作原理的理解将有助于使我们即将看到的概念比以往更有意义。
- en: '| Instruction     | Description | Aliases |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 指令     | 描述 | 别名 |'
- en: '| **System instructions** |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **系统指令** |'
- en: '| **halt** | Stop! | None |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **halt** | 停止！ | 无 |'
- en: '| **read** rX | Place user input in register rX | None |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **read** rX | 将用户输入放入寄存器rX | 无 |'
- en: '| **write** rX | Print contents of register rX | None |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **write** rX | 打印寄存器rX的内容 | 无 |'
- en: '| **nop** | Do nothing | None |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| **nop** | 什么也不做 | 无 |'
- en: '| **Setting register data** |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| **设置寄存器数据** |'
- en: '| **setn** rX N | Set register rX equal to the integer N (-128 to +127) | None
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| **setn** rX N | 将寄存器 rX 设置为整数 N（-128 到 +127） | 无 |'
- en: '| **addn** rX N | Add integer N (-128 to 127) to register rX | None |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **addn** rX N | 将整数 N（-128 到 127）加到寄存器 rX | 无 |'
- en: '| **copy** rX rY | Set rX = rY | **mov** |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **copy** rX rY | 设置 rX = rY | **mov** |'
- en: '| **Arithmetic** |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **算术** |'
- en: '| **add** rX rY rZ | Set rX = rY + rZ | None |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| **add** rX rY rZ | 设置 rX = rY + rZ | 无 |'
- en: '| **sub** rX rY rZ | Set rX = rY - rZ | None |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **sub** rX rY rZ | 设置 rX = rY - rZ | 无 |'
- en: '| **neg** rX rY | Set rX = -rY | None |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **neg** rX rY | 设置 rX = -rY | 无 |'
- en: '| **mul** rX rY rZ | Set rX = rY * rZ | None |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **mul** rX rY rZ | 设置 rX = rY * rZ | 无 |'
- en: '| **div** rX rY rZ | Set rX = rY / rZ (integer division; no remainder) | None
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **div** rX rY rZ | 设置 rX = rY / rZ（整数除法；没有余数） | 无 |'
- en: '| **mod** rX rY rZ | Set rX = rY % rZ (returns the remainder of integer division)
    | None |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| **mod** rX rY rZ | 设置 rX = rY % rZ（返回整数除法的余数） | 无 |'
- en: '| **Jumps!** |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **跳转！** |'
- en: '| **jumpn** N | Set program counter to address N | None |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| **jumpn** N | 将程序计数器设置为地址 N | 无 |'
- en: '| **jumpr** rX | Set program counter to address in rX | **jump** |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| **jumpr** rX | 将程序计数器设置为寄存器 rX 中的地址 | **jump** |'
- en: '| **jeqzn** rX N | If rX == 0, then jump to line N | **jeqz** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **jeqzn** rX N | 如果 rX == 0，则跳转到第 N 行 | **jeqz** |'
- en: '| **jnezn** rX N | If rX != 0, then jump to line N | **jnez** |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| **jnezn** rX N | 如果 rX != 0，则跳转到第 N 行 | **jnez** |'
- en: '| **jgtzn** rX N | If rX > 0, then jump to line N | **jgtz** |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| **jgtzn** rX N | 如果 rX > 0，则跳转到第 N 行 | **jgtz** |'
- en: '| **jltzn** rX N | If rX < 0, then jump to line N | **jltz** |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| **jltzn** rX N | 如果 rX < 0，则跳转到第 N 行 | **jltz** |'
- en: '| **calln** rX N | Copy the next address into rX and then jump to mem. addr.
    N | **call** |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| **calln** rX N | 将下一个地址复制到 rX，然后跳转到内存地址 N | **call** |'
- en: '| **Interacting with memory (RAM)** |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| **与内存（RAM）交互** |'
- en: '| **loadn** rX N | Load register rX with the contents of memory address N |
    None |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| **loadn** rX N | 使用内存地址 N 的内容加载寄存器 rX | 无 |'
- en: '| **storen** rX N | Store contents of register rX into memory address N | None
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| **storen** rX N | 将寄存器 rX 的内容存储到内存地址 N | 无 |'
- en: '| **loadr** rX rY | Load register rX with data from the address location held
    in reg. rY | **loadi, load** |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| **loadr** rX rY | 使用寄存器 rY 中保存的地址位置的数据加载寄存器 rX | **loadi, load** |'
- en: '| **storer** rX rY | Store contents of register rX into memory address held
    in reg. rY | **storei, store** |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| **storer** rX rY | 将寄存器 rX 的内容存储到寄存器 rY 中保存的内存地址 | **storei, store** |'
- en: 'Figure 4.10: The Hmmm instruction set.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：Hmmm 指令集。
- en: Footnotes
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: '| [[1]](#id1) | On Windows, you can navigate to the command line from the Start
    menu. On a Macintosh, bring up the Terminal application, which lives in Applications/Utilities.
    On Linux, most GUIs offer a similar terminal application in their main menu. The
    example above was run on Linux. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| [[1]](#id1) | 在 Windows 上，您可以从“开始”菜单导航到命令行。在 Macintosh 上，打开位于应用程序/实用程序中的终端应用程序。在
    Linux 上，大多数 GUI 提供类似的终端应用程序在其主菜单中。上面的示例在 Linux 上运行。 |'
- en: '| [[2]](#id2) | We could have chosen any register except R0 for this purpose,
    but by convention Hmmm programs use R14. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| [[2]](#id2) | 我们可以选择除 R0 外的任何寄存器来实现这个目的，但按照惯例，Hmmm 程序使用 R14。 |'
- en: '| [[3]](#id3) | We say that R15 *points to* location 102. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| [[3]](#id3) | 我们说 R15 *指向* 位置 102。 |'
- en: '| [[4]](#id4) | We say we *follow the pointer* in R15. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| [[4]](#id4) | 我们说我们*跟随指针*在 R15 中。 |'
