["```\n Client              Client\n -----------         -----------\n| App       |       | App       |\n -----------         -----------     ......\n| Thor cache|       | Thor cache|\n|           |       |           | ------\n ----------- <-  --> -----------        \\\n   \\ write x   \\/                        \\   read-set\n    |          / invalidate messages      \\  write-set\n   \\|/        /                            \\\n    .        /                             \\/\n  Server    /         Server             Validation service\n -----------         -----------         -----------\n| App       |       | App       |       |           |\n -----------         -----------         -----------\n| Data      |       | Data      |\n|   A-M     |       |   N-Z     |\n -----------         ----------- \n```", "```\nx = y = z = 0\n\n# Then, 4 tx's are run\n\nT1: Rx0 Wx1\nT2: Rz0 Wz9\nT3: Ry1 Rx1\nT4: Rx0 Wy1 \n```", "```\nx = y = 0\n\nT1: Rx0 Wx1\nT2: Rx0 Wy=1\nT3: Ry0 Rx=1 \n```", "```\nx = y = z = 0\n\nT1 Wx1\nT2 Rx1 Wy2\nT3 Ry2 Rx0\n\nT3 read x=0 => T3 comes before T1\nT3 read y=2 => T3 comes after T2\nT2 read x=1 => T2 comes after T1\n\n  /---------\\\n /          \\/\nT2 <- T3 <- T1 \n```", "```\nx on server 1\ny on server 2\n\n    sv1         sv2\n  ---------- ---------\nT1 Rx0 Wx1  |   \nT2 Rx0      |   Wy1\nT3 Rx1      |   Ry0\n\nsv1: T2 T1 T3 (yes)\nsv2: T3 T2 (yes) \n```", "```\n sv1     |   sv2\nT1@100: Rx0 Wx1       Rx0 Wx1   |\nT2@110: Rx0 Wy1       Rx0       |   Wy1\nT3@105: Ry0 Rx1       Rx1       |   Ry0\n                    T1 T3 T2       T2 T3\n                      (no)          (no) \n```", "```\nT1@100: Rx0 Wx1\nT2@ 90: Rx1 Wx2  (assigned lower timestamp due to loose sync) \n```", "```\nT1: Wx1 v105\nT2: Wx2 v106\nT3: Wx1 v107\nT4: Rx1 v105\n-> aborted becauses T4 read stale version of x (105)\n -> however, even though it read the v105 it still got the same value as\n    the freshest version v107 (the value 1) => unnecessary abort \n```", "```\nPaper: Efficient Optimistic Concurrency Control using Loosely\nSynchronized Clocks, by Adya, Gruber, Liskov and Maheshwari.\n\nWhy this paper?\n  to look at optimistic concurrency control (OCC)\n  OCC might help us get large scale, high speed, *and* good semantics\n\nThor overview\n  [clients, client caches, servers A-M N-Z]\n  data sharded over servers\n  code runs in clients (not like Argus; not an RPC system)\n  clients read/write DB records from servers\n  clients cache data locally for fast access\n    on client cache miss, fetch from server\n\nThor arrangement is fairly close to modern big web site habits\n  clients, local fast cache, slower DB servers\n  like Facebook/memcache paper\n  but Thor has much better semantics\n\nThor programs use fully general transactions\n  multi-operation\n  serializable\n  so can do bank xfers w/o losing money, &c\n\nClient caching makes transactions tricky\n  writes have to invalidatate cached copies\n  how to cope with reads of stale cached data?\n  how to cope with read-modify-write races?\n  clients could lock before using each record\n    but that's slow -- probably need to contact server\n    wrecks the whole point of fast local caching in clients\n    (though caching read locks might be OK, as in paper Eval)\n\nThor uses optimistic concurrency control (OCC)\n  an idea from the early 1980s\n  just read and write the local copy\n    don't worry about other transactions until commit\n  when transaction wants to commit:\n    send read/write info to server for \"validation\"\n    validation decides if OK to commit -- if serializable\n    if yes, send invalidates to clients with cached copies of written records\n    if no, abort, discard writes\n  optimistic b/c hopes for no conflict\n    if turns out to be true, fast!\n    if false, validation can detect, but slow\n\nWhat should validation do?\n  it looks at what the executing transactions read and wrote\n  decides if there's a serial execution order that would have gotten\n    the same results as the actual concurrent execution\n  there are many OCC validation algorithms!\n    i will outline a few, leading up to Thor's\n\nValidation scheme #1\n  a single validation server\n  clients tell validation server the read and write VALUES\n    seen by each transaction that wants to commit\n    \"read set\" and \"write set\"\n  validation must decide:\n    would the results be serializable if we let these\n      transactions commit?\n  scheme #1 shuffles the transactions, looking for a serial order\n    in which each read sees the value written by the most\n    recent write; if one exists, the execution was serializable.\n\nValidation example 1:\n  initially, x=0 y=0 z=0\n  T1: Rx0 Wx1\n  T2: Rz0 Wz9\n  T3: Ry1 Rx1\n  T4: Rx0 Wy1\n  validation needs to decide if this execution (reads, writes)\n    is equivalent to some serial order\n  yes: one such order is T4, T1, T3, T2; says yes to all\n    (really T2 can go anywhere)\n  note this scheme is far more permissive than Thor's\n    e.g. it allows transactions to see uncommitted writes\n\nOCC is neat b/c transactions didn't need to lock!\n  so they can run quickly from client caches\n  just one msg exchange w/ validator per transaction\n    not one locking exchange per record used\n  OCC excellent for T2 which didn't conflict with anything\n    we got lucky for T1 T3 T4, which do conflict\n\nValidation example 2 -- sometimes must abort:\n  initially, x=0 y=0\n  T1: Rx0 Wx1\n  T2: Rx0 Wy1\n  T3: Ry0 Rx1\n  values not consistent w/ any serial order!\n    T1 -> T3 (via x)\n    T3 -> T2 (via y)\n    T2 -> T1 (via x)\n    there's a cycle, so not the same as any serial execution\n  perhaps T3 read a stale y=0 from cache\n    or T2 read a style x=0 from cache\n  in this case validation can abort one of them\n    then others are OK to commit\n  e.g. abort T2\n    then T1, T3 is OK (but not T3, T1)\n\nHow should client handle abort?\n  roll back the program (including writes to program variables)\n  re-run from start of transaction\n  hopefully won't be conflicts the second time\n  OCC is best when conflicts are uncommon!\n\nDo we need to validate read-only transactions?\n  example:\n    initially x=0 y=0\n    T1: Wx1\n    T2: Rx1 Wy2\n    T3: Ry2 Rx0\n  i.e. T3 read a stale x=0 from its cache, hadn't yet seen invalidate.\n  need to validate in order to abort T3.\n  other OCC schemes can avoid validating read-only transactions\n    keep multiple versions -- but Thor and my schemes don't\n\nIs OCC better than locking?\n  yes, if few conflicts\n    avoids lock msgs, clients don't have to wait for locks\n  no, if many conflicts\n    OCC aborts, must re-start, perhaps many times\n    locking waits\n  example: simultaneous increment\n    locking:\n      T1: Rx0 Wx1\n      T2: -------Rx1  Wx2\n    OCC:\n      T1: Rx0 Wx1\n      T2: Rx0 Wx1\n      fast but wrong; must abort one\n\nWe really want *distributed* OCC validation\n  split storage and validation load over servers\n  each storage server sees only xactions that use its data\n  each storage server validates just its part of the xaction\n  two-phase commit (2PC) to check that they all say \"yes\"\n    only really commit if all relevant servers say \"yes\"\n\nCan we just distribute validation scheme #1?\n  imagine server S1 knows about x, server S2 knows about y\n  example 2 again\n    T1: Rx0 Wx1\n    T2: Rx0 Wy1\n    T3: Ry0 Rx1\n  S1 validates just x information:\n    T1: Rx0 Wx1\n    T2: Rx0\n    T3: Rx1\n    answer is \"yes\" (T2 T1 T3)\n  S2 validates just y information:\n    T2: Wy1\n    T3: Ry0\n    answer is \"yes\" (T3 T2)\n  but we know the real answer is \"no\"\n\nSo simple distributed validation does not work\n  the validators must choose consistent orders!\n\nValidation scheme #2\n  Idea: client (or TC) chooses timestamp for committing xaction\n    from loosely synchronized clocks, as in Thor\n  validation checks that reads and writes are consistent with TS order\n  solves distrib validation problem:\n    timestamps tell the validators the order to check\n    so \"yes\" votes will refer to the same order\n\nExample 2 again, with timestamps:\n  T1@100: Rx0 Wx1\n  T2@110: Rx0 Wy1\n  T3@105: Ry0 Rx1\n  S1 validates just x information:\n    T1@100: Rx0 Wx1\n    T2@110: Rx0\n    T3@105: Rx1\n    timestamps say order must be T1, T3, T2\n    does not validate! T2 should have seen x=1\n  S2 validates just y information:\n    T2@110: Wy1\n    T3@105: Ry0\n    timstamps say order must be T3, T2\n    validates!\n  S1 says no, S2 says yes, two-phase commit coordinator will abort\n\nWhat have we given up by requiring timestamp order?\n  example:\n    T1@100: Rx0 Wx1\n    T2@50: Rx1 Wx2\n  T2 follows T1 in real time, and sees T1's write\n  but T2 will abort, since TS says T2 comes first, so T1 should have seen x=2\n    could have committed, since T1 then T2 works\n  this will happen if client clocks are too far off\n    if T1's client clock is ahead, or T2's behind\n  so: requiring TS order can abort unnecessarily\n    b/c validation no longer *searching* for an order that works\n    instead merely *checking* that TS order consistent w/ reads, writes\n    we've given up some optimism by requiring TS order\n  maybe not a problem if clocks closely synched\n  maybe not a problem if conflicts are rare\n\nProblem with schemes so far:\n  commit messages contained *values*, which can be big\n  could instead use version numbers to check whether\n    later xaction read earlier xaction's write\n  let's use writing xaction's TS as record version number\n\nValidation scheme #4\n  tag each DB record (and cached record) with TS of xation that last wrote it\n  validation requests carry TS of each record read\n\nOur example for scheme #4:\n  all values start with timestamp 0\n  T1@100: Rx@0 Wx\n  T2@110: Rx@0 Wy\n  T3@105: Ry@0 Rx@100\n  note:\n    reads have timestamp that was in read record, not value\n    writes don't include either value or timestamp\n  S1 validates just x information:\n    orders the transactions by timestamp:\n    T1@100: Rx@0 Wx\n    T3@105: Rx@100\n    T2@110: Rx@0\n    the question: does each read see the most recent write?\n      T3 is ok, but T2 is not\n  S2 validates just y information:\n    again, sort by TS, check each read saw latest write:\n    T3@105: Ry@0\n    T2@110: Wy\n    this does validate\n  so scheme #4 abort, correctly, reasoning only about version TSs\n\nwhat have we give up by thinking about version #s rather than values?\n  maybe version numbers are different but values are the same\n  e.g.\n    T1@100: Wx1\n    T2@110: Wx2\n    T3@120: Wx1\n    T4@130: Rx1@100\n  timestamps say we should abort T4 b/c read a stale version\n    should have read T3's write\n    so scheme #4 will abort\n  but T4 read the correct value -- x=1\n    so abort wasn't necessary\n\nProblem: per-record timestamp might use too much storage space\n  Thor wants to avoid space overhead \n  maybe important, maybe not\n\nValidation scheme #5\n  Thor's invalidation scheme: no timestamps on records\n  how can validation detect that a transaction read stale data?\n  it read stale data b/c earlier xaction's invalidation hadn't yet arrived!\n  so server can track invalidation msgs that might not have arrived yet\n    \"invalid set\" -- one per client\n    delete invalid set entry when client ACKs invalidation msg\n    server aborts committing xaction if it read record in client's invalid set\n    client aborts running xaction if it read record mentioned in invalidation\n\nExample use of invalid set\n  [timeline]\n  Client C1:\n    T2@105 ... Rx ... 2PC commit point\n    imagine that client acts as 2PC coordinator\n  Server:\n    VQ: T1@100 Wx\n    T1 committed, x in C1's invalid set\n      server has sent invalidation message to C1\n\nThree cases:\n  1\\. invalidation arrives before T2 reads\n     Rx will miss in client cache, read from data from server\n     client will (probably) return ACK before T2 commits\n     server won't abort T2\n  2\\. invalidation arrives after T2 reads, before commit point\n     client will abort T2 in response to invalidation\n  3\\. invalidation arrives after 2PC commit point\n     i.e. after all servers replied to prepare\n     this means the client was still in the invalid set when\n       the server tried to validate the transaction\n     so the server aborted, so the client will abort too\n  so: Thor's validation detects stale reads w/o timestamp on each record\n\nPerformance\n\nLook at Figure 5\n  AOCC is Thor\n  comparing to ACBL: client talks to srvr to get write-locks,\n   and to commit non-r/o xactions, but can cache read locks along with data\n  why does Thor (AOCC) have higher throughput?\n    fewer msgs; commit only, no lock msgs\n  why does Thor throughput go up for a while w/ more clients?\n    apparently a single client can't keep all resources busy\n    maybe due to network RTT?\n    maybe due to client processing time? or think time?\n    more clients -> more parallel xactions -> more completed\n  why does Thor throughput level off?\n    maybe 15 clients is enough to saturate server disk or CPU\n    abt 100 xactions/second, about right for writing disk\n  why does Thor throughput *drop* with many clients?\n    more clients means more concurrent xactions at any given time\n    more concurrency means more chance of conflict\n    for OCC, more conflict means more aborts, so more wasted CPU\n\nConclusions\n  fast client caching + transactions would be excellent\n  distributed OCC very interesting, still an open research area\n  avoiding per-record version #s doesn't seem compelling\n  Thor's use of time was influential, e.g. Spanner \n```"]