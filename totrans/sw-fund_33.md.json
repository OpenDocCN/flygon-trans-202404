["```\n\n```", "```\n\n    This file contains a set of tactics that extends the set of builtin\n    tactics provided with the standard distribution of Coq. It intends\n    to overcome a number of limitations of the standard set of tactics,\n    and thereby to help user to write shorter and more robust scripts.\n\n    Hopefully, Coq tactics will be improved as time goes by, and this\n    file should ultimately be useless. In the meanwhile, serious Coq\n    users will probably find it very useful.\n\n    The present file contains the implementation and the detailed\n    documentation of those tactics. The SF reader need not read this\n    file; instead, he/she is encouraged to read the chapter named\n    UseTactics.v, which is gentle introduction to the most useful\n    tactics from the LibTactic library. \n\n    The main features offered are:\n\n*   More convenient syntax for naming hypotheses, with tactics for introduction and inversion that take as input only the name of hypotheses of type Prop, rather than the name of all variables.\n\n*   Tactics providing true support for manipulating N-ary conjunctions, disjunctions and existentials, hidding the fact that the underlying implementation is based on binary propositions.\n\n*   Convenient support for automation: tactic followed with the symbol \"~\" or \"*\" will call automation on the generated subgoals. Symbol \"~\" stands for auto and \"*\" for intuition eauto. These bindings can be customized.\n\n*   Forward-chaining tactics are provided to instantiate lemmas either with variable or hypotheses or a mix of both.\n\n*   A more powerful implementation of apply is provided (it is based on refine and thus behaves better with respect to conversion).\n\n*   An improved inversion tactic which substitutes equalities on variables generated by the standard inversion mecanism. Moreover, it supports the elimination of dependently-typed equalities (requires axiom K, which is a weak form of Proof Irrelevance).\n\n*   Tactics for saving time when writing proofs, with tactics to asserts hypotheses or sub-goals, and improved tactics for clearing, renaming, and sorting hypotheses.\n\n    External credits:\n\n*   thanks to Xavier Leroy for providing the idea of tactic forward,\n\n*   thanks to Georges Gonthier for the implementation trick in rapply,\n\n```", "```\n\n# Tools for Programming with Ltac\n\n```", "```\n\n## Identity Continuation\n\n```", "```\n\n## Untyped Arguments for Tactics\n\n    Any Coq value can be boxed into the type Boxer. This is\n    useful to use Coq computations for implementing tactics.\n\n```", "```\n\n## Optional Arguments for Tactics\n\n    ltac_no_arg is a constant that can be used to simulate\n    optional arguments in tactic definitions.\n    Use mytactic ltac_no_arg on the tactic invokation,\n    and use match arg with ltac_no_arg \u21d2 .. or\n    match type of arg with ltac_No_arg \u21d2 .. to\n    test whether an argument was provided.\n\n```", "```\n\n## Wildcard Arguments for Tactics\n\n    ltac_wild is a constant that can be used to simulate\n    wildcard arguments in tactic definitions. Notation is __.\n\n```", "```\n\n    ltac_wilds is another constant that is typically used to\n    simulate a sequence of N wildcards, with N chosen\n    appropriately depending on the context. Notation is ___.\n\n```", "```\n\n## Position Markers\n\n    ltac_Mark and ltac_mark are dummy definitions used as sentinel\n    by tactics, to mark a certain position in the context or in the goal.\n\n```", "```\n\n    gen_until_mark repeats generalize on hypotheses from the\n    context, starting from the bottom and stopping as soon as reaching\n    an hypothesis of type Mark. If fails if Mark does not\n    appear in the context.\n\n```", "```\n\n    intro_until_mark repeats intro until reaching an hypothesis of\n    type Mark. It throws away the hypothesis Mark.\n    It fails if Mark does not appear as an hypothesis in the\n    goal.\n\n```", "```\n\n## List of Arguments for Tactics\n\n    A datatype of type list Boxer is used to manipulate list of\n    Coq values in ltac. Notation is >> v[1] v[2] ... vN for building\n    a list containing the values v[1] through vN.\n\n```", "```\n\n    The tactic list_boxer_of inputs a term E and returns a term\n    of type \"list boxer\", according to the following rules:\n\n*   if E is already of type \"list Boxer\", then it returns E;\n\n*   otherwise, it returns the list (boxer E)::nil.\n\n```", "```\n\n## Databases of Lemmas\n\n    Use the hint facility to implement a database mapping\n    terms to terms. To declare a new database, use a definition:\n    Definition mydatabase := True. \n\n    Then, to map mykey to myvalue, write the hint:\n    Hint Extern 1 (Register mydatabase mykey) \u21d2 Provide myvalue. \n\n    Finally, to query the value associated with a key, run the\n    tactic ltac_database_get mydatabase mykey. This will leave\n    at the head of the goal the term myvalue. It can then be\n    named and exploited using intro.\n\n```", "```\n\n## On-the-Fly Removal of Hypotheses\n\n    In a list of arguments >> H[1] H[2] .. HN passed to a tactic\n    such as lets or applys or forwards or specializes,\n    the term rm, an identity function, can be placed in front\n    of the name of an hypothesis to be deleted.\n\n```", "```\n\n    rm_term E removes one hypothesis that admits the same\n    type as E.\n\n```", "```\n\n    rm_inside E calls rm_term Ei for any subterm\n    of the form rm Ei found in E\n\n```", "```\n\n    For faster performance, one may deactivate rm_inside by\n    replacing the body of this definition with idtac.\n\n```", "```\n\n## Numbers as Arguments\n\n    When tactic takes a natural number as argument, it may be\n    parsed either as a natural number or as a relative number.\n    In order for tactics to convert their arguments into natural numbers,\n    we provide a conversion tactic.\n\n```", "```\n\n    ltac_pattern E at K is the same as pattern E at K except that\n    K is a Coq natural rather than a Ltac integer. Syntax\n    ltac_pattern E as K in H is also available.\n\n```", "```\n\n## Testing Tactics\n\n    show tac executes a tactic tac that produces a result,\n    and then display its result.\n\n```", "```\n\n    dup N produces N copies of the current goal. It is useful\n    for building examples on which to illustrate behaviour of tactics.\n    dup is short for dup 2.\n\n```", "```\n\n## Check No Evar in Goal\n\n```", "```\n\n## Helper Function for Introducing Evars\n\n    with_evar T (fun M \u21d2 tac) creates a new evar that can\n    be used in the tactic tac under the name M.\n\n```", "```\n\n## Tagging of Hypotheses\n\n    get_last_hyp tt is a function that returns the last hypothesis\n    at the bottom of the context. It is useful to obtain the default\n    name associated with the hypothesis, e.g.\n    intro; let H := get_last_hyp tt in let H' := fresh \"P\" H in ...\n\n```", "```\n\n## More Tagging of Hypotheses\n\n    ltac_tag_subst is a specific marker for hypotheses\n    which is used to tag hypotheses that are equalities to\n    be substituted.\n\n```", "```\n\n    ltac_to_generalize is a specific marker for hypotheses\n    to be generalized.\n\n```", "```\n\n## Deconstructing Terms\n\n    get_head E is a tactic that returns the head constant of the\n    term E, ie, when applied to a term of the form P x[1] ... xN\n    it returns P. If E is not an application, it returns E.\n    Warning: the tactic seems to loop in some cases when the goal is\n    a product and one uses the result of this function.\n\n```", "```\n\n    get_fun_arg E is a tactic that decomposes an application\n  term E, ie, when applied to a term of the form X[1] ... XN\n  it returns a pair made of X[1] .. X(N-1) and XN.\n\n```", "```\n\n## Action at Occurence and Action Not at Occurence\n\n    ltac_action_at K of E do Tac isolates the K-th occurence of E in the\n    goal, setting it in the form P E for some named pattern P,\n    then calls tactic Tac, and finally unfolds P. Syntax\n    ltac_action_at K of E in H do Tac is also available.\n\n```", "```\n\n    protects E do Tac temporarily assigns a name to the expression E\n    so that the execution of tactic Tac will not modify E. This is\n    useful for instance to restrict the action of simpl.\n\n```", "```\n\n## An Alias for eq\n\n    eq' is an alias for eq to be used for equalities in\n    inductive definitions, so that they don't get mixed with\n    equalities generated by inversion.\n\n```", "```\n\n# Common Tactics for Simplifying Goals Like intuition\n\n```", "```\n\n# Backward and Forward Chaining\n\n```", "```\n\n## Application\n\n```", "```\n\n    rapply is a tactic similar to eapply except that it is\n    based on the refine tactics, and thus is strictly more\n    powerful (at least in theory :). In short, it is able to perform\n    on-the-fly conversions when required for arguments to match,\n    and it is able to instantiate existentials when required.\n\n```", "```\n\n    The tactics applys_N T, where N is a natural number,\n    provides a more efficient way of using applys T. It avoids\n    trying out all possible arities, by specifying explicitely\n    the arity of function T.\n\n```", "```\n\n    lets_base H E adds an hypothesis H : T to the context, where T is\n    the type of term E. If H is an introduction pattern, it will\n    destruct H according to the pattern.\n\n```", "```\n\n    applys_to H E transform the type of hypothesis H by\n    replacing it by the result of the application of the term\n    E to H. Intuitively, it is equivalent to lets H: (E H).\n\n```", "```\n\n    applys_to H[1],...,HN E applys E to several hypotheses\n\n```", "```\n\n    constructors calls constructor or econstructor.\n\n```", "```\n\n## Assertions\n\n    asserts H: T is another syntax for assert (H : T), which\n    also works with introduction patterns. For instance, one can write:\n    asserts \\[x P\\] (\u2203 n, n = 3), or\n    asserts \\[H|H\\] (n = 0 \u2228 n = 1).  \n\n```", "```\n\n    asserts H[1] .. HN: T is a shorthand for\n    asserts \\[H[1] \\[H[2] \\[.. HN\\]\\]\\]\\: T].\n\n```", "```\n\n    asserts: T is asserts H: T with H being chosen automatically.\n\n```", "```\n\n    cuts H: T is the same as asserts H: T except that the two subgoals\n    generated are swapped: the subgoal T comes second. Note that contrary\n    to cut, it introduces the hypothesis.\n\n```", "```\n\n    cuts: T is cuts H: T with H being chosen automatically.\n\n```", "```\n\n    cuts H[1] .. HN: T is a shorthand for\n    cuts \\[H[1] \\[H[2] \\[.. HN\\]\\]\\]\\: T].\n\n```", "```\n\n## Instantiation and Forward-Chaining\n\n    The instantiation tactics are used to instantiate a lemma E\n    (whose type is a product) on some arguments. The type of E is\n    made of implications and universal quantifications, e.g.\n    \u2200 x, P x \u2192 \u2200 y z, Q x y z \u2192 R z.\n\n    The first possibility is to provide arguments in order: first x,\n    then a proof of P x, then y etc... In this mode, called \"Args\",\n    all the arguments are to be provided. If a wildcard is provided\n    (written __), then an existential variable will be introduced in\n    place of the argument.\n\n    It is very convenient to give some arguments the lemma should be\n    instantiated on, and let the tactic find out automatically where\n    underscores should be insterted. Underscore arguments __ are\n    interpret as follows: an underscore means that we want to skip the\n    argument that has the same type as the next real argument provided\n    (real means not an underscore). If there is no real argument after\n    underscore, then the underscore is used for the first possible argument.\n\n    The general syntax is tactic (>> E[1] .. EN) where tactic is\n    the name of the tactic (possibly with some arguments) and Ei\n    are the arguments. Moreover, some tactics accept the syntax\n    tactic E[1] .. EN as short for tactic (>> E[1] .. EN) for\n    values of N up to 5.\n\n    Finally, if the argument EN given is a triple-underscore ___,\n    then it is equivalent to providing a list of wildcards, with\n    the appropriate number of wildcards. This means that all\n    the remaining arguments of the lemma will be instantiated. \n    Definitions in the conclusion are not unfolded in this case.\n\n```", "```\n\n    newer version : support for typeclasses\n\n```", "```\n\n    lets H: (>> E[0] E[1] .. EN) will instantiate lemma E[0]\n    on the arguments Ei (which may be wildcards __),\n    and name H the resulting term. H may be an introduction\n    pattern, or a sequence of introduction patterns I[1] I[2] IN,\n    or empty.\n    Syntax lets H: E[0] E[1] .. EN is also available. If the last\n    argument EN is ___ (triple-underscore), then all\n    arguments of H will be instantiated.\n\n```", "```\n\n    forwards H: (>> E[0] E[1] .. EN) is short for\n    forwards H: (>> E[0] E[1] .. EN ___).\n    The arguments Ei can be wildcards __ (except E[0]).\n    H may be an introduction pattern, or a sequence of\n    introduction pattern, or empty.\n    Syntax forwards H: E[0] E[1] .. EN is also available.\n\n```", "```\n\n    applys (>> E[0] E[1] .. EN) instantiates lemma E[0]\n    on the arguments Ei (which may be wildcards __),\n    and apply the resulting term to the current goal,\n    using the tactic applys defined earlier on.\n    applys E[0] E[1] E[2] .. EN is also available.\n\n```", "```\n\n    fapplys (>> E[0] E[1] .. EN) instantiates lemma E[0]\n    on the arguments Ei and on the argument ___ meaning\n    that all evars should be explicitly instantiated,\n    and apply the resulting term to the current goal.\n    fapplys E[0] E[1] E[2] .. EN is also available.\n\n```", "```\n\n    specializes H (>> E[1] E[2] .. EN) will instantiate hypothesis H\n    on the arguments Ei (which may be wildcards __). If the last\n    argument EN is ___ (triple-underscore), then all arguments of\n    H get instantiated.\n\n```", "```\n\n    specializes_vars H is equivalent to specializes H __ .. __ \n    with as many double underscore as the number of dependent arguments\n    visible from the type of H. Note that no unfolding is currently\n    being performed (this behavior might change in the future).\n    The current implementation is restricted to the case where\n    H is an existing hypothesis \u2014 TODO: generalize.\n\n```", "```\n\n## Experimental Tactics for Application\n\n    fapply is a version of apply based on forwards.\n\n```", "```\n\n    sapply stands for \"super apply\". It tries\n    apply, eapply, applys and fapply,\n    and also tries to head-normalize the goal first.\n\n```", "```\n\n## Adding Assumptions\n\n    lets_simpl H: E is the same as lets H: E excepts that it\n    calls simpl on the hypothesis H.\n    lets_simpl: E is also provided.\n\n```", "```\n\n    lets_hnf H: E is the same as lets H: E excepts that it\n    calls hnf to set the definition in head normal form. \n    lets_hnf: E is also provided.\n\n```", "```\n\n    puts X: E is a synonymous for pose (X := E).\n    Alternative syntax is puts: E.\n\n```", "```\n\n## Application of Tautologies\n\n    logic E, where E is a fact, is equivalent to\n    assert H:E; [tauto | eapply H; clear H]. It is useful for instance to prove a conjunction [A \u2227 B] by showing first [A] and then [A \u2192 B], through the command [logic (foral A B, A \u2192 (A \u2192 B) \u2192 A \u2227 B)]  \n\n```", "```\n\n## Application Modulo Equalities\n\n    The tactic equates replaces a goal of the form\n    P x y z with a goal of the form P x ?a z and a\n    subgoal ?a = y. The introduction of the evar ?a makes\n    it possible to apply lemmas that would not apply to the\n    original goal, for example a lemma of the form\n    \u2200 n m, P n n m, because x and y might be equal\n    but not convertible.\n\n    Usage is equates i[1] ... ik, where the indices are the\n    positions of the arguments to be replaced by evars,\n    counting from the right-hand side. If 0 is given as\n    argument, then the entire goal is replaced by an evar.\n\n```", "```\n\n    applys_eq H i[1] .. iK is the same as\n    equates i[1] .. iK followed by apply H\n    on the first subgoal.\n\n```", "```\n\n## Absurd Goals\n\n    false_goal replaces any goal by the goal False. \n    Contrary to the tactic false (below), it does not try to do\n    anything else\n\n```", "```\n\n    false_post is the underlying tactic used to prove goals\n    of the form False. In the default implementation, it proves\n    the goal if the context contains False or an hypothesis of the\n    form C x[1] .. xN = D y[1] .. yM, or if the congruence tactic\n    finds a proof of x \u2260 x for some x.\n\n```", "```\n\n    false replaces any goal by the goal False, and calls false_post\n\n```", "```\n\n    tryfalse tries to solve a goal by contradiction, and leaves\n    the goal unchanged if it cannot solve it.\n    It is equivalent to try solve \\[ false \\].\n\n```", "```\n\n    false E tries to exploit lemma E to prove the goal false.\n    false E[1] .. EN is equivalent to false (>> E[1] .. EN),\n    which tries to apply applys (>> E[1] .. EN) and if it\n    does not work then tries forwards H: (>> E[1] .. EN)\n    followed with false\n\n```", "```\n\n    false_invert H proves a goal if it absurd after\n    calling inversion H and false\n\n```", "```\n\n    false_invert proves any goal provided there is at least \n    one hypothesis H in the context (or as a universally quantified\n    hypothesis visible at the head of the goal) that can be proved absurd by calling \n    inversion H.\n\n```", "```\n\n    tryfalse_invert H and tryfalse_invert are like the \n    above but leave the goal unchanged if they don't solve it.\n\n```", "```\n\n    false_neq_self_hyp proves any goal if the context\n    contains an hypothesis of the form E \u2260 E. It is \n    a restricted and optimized version of false. It is \n    intended to be used by other tactics only.\n\n```", "```\n\n# Introduction and Generalization\n\n```", "```\n\n## Introduction\n\n    introv is used to name only non-dependent hypothesis.\n\n*   If introv is called on a goal of the form \u2200 x, H, it should introduce all the variables quantified with a \u2200 at the head of the goal, but it does not introduce hypotheses that preceed an arrow constructor, like in P \u2192 Q.\n\n*   If introv is called on a goal that is not of the form \u2200 x, H nor P \u2192 Q, the tactic unfolds definitions until the goal takes the form \u2200 x, H or P \u2192 Q. If unfolding definitions does not produces a goal of this form, then the tactic introv does nothing at all.\n\n```", "```\n\n    intros_all repeats intro as long as possible. Contrary to intros,\n    it unfolds any definition on the way. Remark that it also unfolds the\n    definition of negation, so applying introz to a goal of the form\n    \u2200 x, P x \u2192 \u00acQ will introduce x and P x and Q, and will\n    leave False in the goal.\n\n```", "```\n\n    intros_hnf introduces an hypothesis and sets in head normal form\n\n```", "```\n\n## Generalization\n\n    gen X[1] .. XN is a shorthand for calling generalize dependent\n    successively on variables XN...X[1]. Note that the variables\n    are generalized in reverse order, following the convention of\n    the generalize tactic: it means that X[1] will be the first\n    quantified variable in the resulting goal.\n\n```", "```\n\n    generalizes X is a shorthand for calling generalize X; clear X.\n    It is weaker than tactic gen X since it does not support\n    dependencies. It is mainly intended for writing tactics.\n\n```", "```\n\n## Naming\n\n    sets X: E is the same as set (X := E) in *, that is,\n    it replaces all occurences of E by a fresh meta-variable X\n    whose definition is E.\n\n```", "```\n\n    def_to_eq E X H applies when X := E is a local\n    definition. It adds an assumption H: X = E\n    and then clears the definition of X.\n    def_to_eq_sym is similar except that it generates\n    the equality H: E = X.\n\n```", "```\n\n    set_eq X H: E generates the equality H: X = E,\n    for a fresh name X, and replaces E by X in the\n    current goal. Syntaxes set_eq X: E and\n    set_eq: E are also available. Similarly,\n    set_eq \u2190 X H: E generates the equality H: E = X.\n\n    sets_eq X HX: E does the same but replaces E by X\n    everywhere in the goal. sets_eq X HX: E in H replaces in H.\n    set_eq X HX: E in \u22a2 performs no substitution at all.\n\n```", "```\n\n    gen_eq X: E is a tactic whose purpose is to introduce\n    equalities so as to work around the limitation of the induction\n    tactic which typically loses information. gen_eq E as X replaces\n    all occurences of term E with a fresh variable X and the equality\n    X = E as extra hypothesis to the current conclusion. In other words\n    a conclusion C will be turned into (X = E) \u2192 C.\n    gen_eq: E and gen_eq: E as X are also accepted.\n\n```", "```\n\n    sets_let X finds the first let-expression in the goal\n    and names its body X. sets_eq_let X is similar,\n    except that it generates an explicit equality.\n    Tactics sets_let X in H and sets_eq_let X in H\n    allow specifying a particular hypothesis (by default,\n    the first one that contains a let is considered).\n\n    Known limitation: it does not seem possible to support\n    naming of multiple let-in constructs inside a term, from ltac.\n\n```", "```\n\n# Rewriting\n\n    rewrites E is similar to rewrite except that\n    it supports the rm directives to clear hypotheses\n    on the fly, and that it supports a list of arguments in the form\n    rewrites (>> E[1] E[2] E[3]) to indicate that forwards should be \n    invoked first before rewrites is called.\n\n```", "```\n\n    rewrite_all E iterates version of rewrite E as long as possible.\n    Warning: this tactic can easily get into an infinite loop.\n    Syntax for rewriting from right to left and/or into an hypothese\n    is similar to the one of rewrite.\n\n```", "```\n\n    asserts_rewrite E asserts that an equality E holds (generating a\n    corresponding subgoal) and rewrite it straight away in the current\n    goal. It avoids giving a name to the equality and later clearing it.\n    Syntax for rewriting from right to left and/or into an hypothese\n    is similar to the one of rewrite. Note: the tactic replaces\n    plays a similar role.\n\n```", "```\n\n    cuts_rewrite E is the same as asserts_rewrite E except\n    that subgoals are permuted.\n\n```", "```\n\n    rewrite_except H EQ rewrites equality EQ everywhere\n    but in hypothesis H. Mainly useful for other tactics.\n\n```", "```\n\n    rewrites E at K applies when E is of the form T[1] = T[2]\n    rewrites the equality E at the K-th occurence of T[1]\n    in the current goal.\n    Syntaxes rewrites \u2190 E at K and rewrites E at K in H\n    are also available.\n\n```", "```\n\n## Replace\n\n    replaces E with F is the same as replace E with F except that\n    the equality E = F is generated as first subgoal. Syntax\n    replaces E with F in H is also available. Note that contrary to\n    replace, replaces does not try to solve the equality\n    by assumption. Note: replaces E with F is similar to\n    asserts_rewrite (E = F).\n\n```", "```\n\n    replaces E at K with F replaces the K-th occurence of E\n    with F in the current goal. Syntax replaces E at K with F in H\n    is also available.\n\n```", "```\n\n## Change\n\n    changes is like change except that it does not silently\n   fail to perform its task. (Note that, changes is implemented\n   using rewrite, meaning that it might perform additional \n   beta-reductions compared with the original change tactic.\n\n```", "```\n\n## Renaming\n\n    renames X[1] to Y[1], ..., XN to YN is a shorthand for a sequence of\n    renaming operations rename Xi into Yi.\n\n```", "```\n\n## Unfolding\n\n    unfolds unfolds the head definition in the goal, i.e., if the\n    goal has form P x[1] ... xN then it calls unfold P.\n    If the goal is an equality, it tries to unfold the head constant\n    on the left-hand side, and otherwise tries on the right-hand side.\n    If the goal is a product, it calls intros first.\n warning: this tactic is overriden in LibReflect.\n\n```", "```\n\n    unfolds in H unfolds the head definition of hypothesis H, i.e., if\n    H has type P x[1] ... xN then it calls unfold P in H.\n\n```", "```\n\n    unfolds in H[1],H[2],..,HN allows unfolding the head constant\n    in several hypotheses at once.\n\n```", "```\n\n    unfolds P[1],..,PN is a shortcut for unfold P[1],..,PN in *.\n\n```", "```\n\n    folds P[1],..,PN is a shortcut for fold P[1] in *; ..; fold PN in *.\n\n```", "```\n\n## Simplification\n\n    simpls is a shortcut for simpl in *.\n\n```", "```\n\n    simpls P[1],..,PN is a shortcut for\n    simpl P[1] in *; ..; simpl PN in *.\n\n```", "```\n\n    unsimpl E replaces all occurence of X by E, where X is\n   the result which the tactic simpl would give when applied to E.\n   It is useful to undo what simpl has simplified too far.\n\n```", "```\n\n    unsimpl E in H is similar to unsimpl E but it applies\n    inside a particular hypothesis H.\n\n```", "```\n\n    unsimpl E in * applies unsimpl E everywhere possible.\n    unsimpls E is a synonymous.\n\n```", "```\n\n    nosimpl t protects the Coq termt against some forms of\n    simplification. See Gonthier's work for details on this trick.\n\n```", "```\n\n## Reduction\n\n```", "```\n\n## Substitution\n\n    substs does the same as subst, except that it does not fail\n    when there are circular equalities in the context.\n\n```", "```\n\n    Implementation of substs below, which allows to call\n    subst on all the hypotheses that lie beyond a given\n    position in the proof context.\n\n```", "```\n\n    substs below body E applies subst on all equalities that appear\n    in the context below the first hypothesis whose body is E.\n    If there is no such hypothesis in the context, it is equivalent\n    to subst. For instance, if H is an hypothesis, then\n    substs below H will substitute equalities below hypothesis H.\n\n```", "```\n\n    substs below H applies subst on all equalities that appear\n    in the context below the hypothesis named H. Note that\n    the current implementation is technically incorrect since it\n    will confuse different hypotheses with the same body.\n\n```", "```\n\n    subst_hyp H substitutes the equality contained in the\n    first hypothesis from the context.\n\n```", "```\n\n    subst_hyp H substitutes the equality contained in H.\n\n```", "```\n\n    intro_subst is a shorthand for intro H; subst_hyp H:\n    it introduces and substitutes the equality at the head\n    of the current goal.\n\n```", "```\n\n    subst_local substitutes all local definition from the context\n\n```", "```\n\n    subst_eq E takes an equality x = t and replace x\n    with t everywhere in the goal\n\n```", "```\n\n## Tactics to Work with Proof Irrelevance\n\n```", "```\n\n    pi_rewrite E replaces E of type Prop with a fresh\n    unification variable, and is thus a practical way to\n    exploit proof irrelevance, without writing explicitly\n    rewrite (proof_irrelevance E E'). Particularly useful\n    when E' is a big expression.\n\n```", "```\n\n## Proving Equalities\n\n    Note: current implementation only supports up to arity 5 \n\n    fequal is a variation on f_equal which has a better behaviour\n    on equalities between n-ary tuples.\n\n```", "```\n\n    fequals is the same as fequal except that it tries and solve\n    all trivial subgoals, using reflexivity and congruence\n    (as well as the proof-irrelevance principle).\n    fequals applies to goals of the form f x[1] .. xN = f y[1] .. yN\n    and produces some subgoals of the form xi = yi).\n\n```", "```\n\n    fequals_rec calls fequals recursively.\n    It is equivalent to repeat (progress fequals).\n\n```", "```\n\n# Inversion\n\n```", "```\n\n## Basic Inversion\n\n    invert keep H is same to inversion H except that it puts all the\n    facts obtained in the goal. The keyword keep means that the\n    hypothesis H should not be removed.\n\n```", "```\n\n    invert keep H as X[1] .. XN is the same as inversion H as ... except\n    that only hypotheses which are not variable need to be named\n    explicitely, in a similar fashion as introv is used to name\n    only hypotheses.\n\n```", "```\n\n    invert H is same to inversion H except that it puts all the\n    facts obtained in the goal and clears hypothesis H.\n    In other words, it is equivalent to invert keep H; clear H.\n\n```", "```\n\n    invert H as X[1] .. XN is the same as invert keep H as X[1] .. XN\n    but it also clears hypothesis H.\n\n```", "```\n\n## Inversion with Substitution\n\n    Our inversion tactics is able to get rid of dependent equalities\n    generated by inversion, using proof irrelevance.\n\n```", "```\n\n    inverts keep H is same to invert keep H except that it\n    applies subst to all the equalities generated by the inversion.\n\n```", "```\n\n    inverts keep H as X[1] .. XN is the same as\n    invert keep H as X[1] .. XN except that it applies subst to all the\n    equalities generated by the inversion\n\n```", "```\n\n    inverts H is same to inverts keep H except that it\n    clears hypothesis H.\n\n```", "```\n\n    inverts H as X[1] .. XN is the same as inverts keep H as X[1] .. XN\n    but it also clears the hypothesis H.\n\n```", "```\n\n    inverts H as performs an inversion on hypothesis H, substitutes\n    generated equalities, and put in the goal the other freshly-created\n    hypotheses, for the user to name explicitly.\n    inverts keep H as is the same except that it does not clear H.\nTODO: reimplement inverts above using this one\n\n```", "```\n\n    lets_inverts E as I[1] .. IN is intuitively equivalent to\n    inverts E, with the difference that it applies to any \n    expression and not just to the name of an hypothesis.\n\n```", "```\n\n## Injection with Substitution\n\n    Underlying implementation of injects\n\n```", "```\n\n    injects keep H takes an hypothesis H of the form\n    C a[1] .. aN = C b[1] .. bN and substitute all equalities\n    ai = bi that have been generated.\n\n```", "```\n\n    injects H is similar to injects keep H but clears\n    the hypothesis H.\n\n```", "```\n\n    inject H as X[1] .. XN is the same as injection\n    followed by intros X[1] .. XN\n\n```", "```\n\n## Inversion and Injection with Substitution \u2014rough implementation\n\n    The tactics inversions and injections provided in this section\n    are similar to inverts and injects except that they perform\n    substitution on all equalities from the context and not only\n    the ones freshly generated. The counterpart is that they have\n    simpler implementations. \n\n    inversions keep H is the same as inversions H but it does\n    not clear hypothesis H.\n\n```", "```\n\n    inversions H is a shortcut for inversion H followed by subst\n    and clear H.\n    It is a rough implementation of inverts keep H which behave\n    badly when the proof context already contains equalities.\n    It is provided in case the better implementation turns out to be\n    too slow.\n\n```", "```\n\n    injections keep H is the same as injection H followed\n    by intros and subst. It is a rough implementation of\n    injects keep H which behave\n    badly when the proof context already contains equalities,\n    or when the goal starts with a forall or an implication.\n\n```", "```\n\n    injections H is the same as injection H followed\n    by intros and clear H and subst. It is a rough\n    implementation of injects keep H which behave\n    badly when the proof context already contains equalities,\n    or when the goal starts with a forall or an implication.\n\n```", "```\n\n## Case Analysis\n\n    cases is similar to case_eq E except that it generates the\n    equality in the context and not in the goal, and generates the\n    equality the other way round. The syntax cases E as H\n    allows specifying the name H of that hypothesis.\n\n```", "```\n\n    case_if_post is to be defined later as a tactic to clean\n    up goals. By defaults, it looks for obvious contradictions. \n    Currently, this tactic is extended in LibReflect to clean up\n    boolean propositions.\n\n```", "```\n\n    case_if looks for a pattern of the form if ?B then ?E[1] else ?E[2]\n    in the goal, and perform a case analysis on B by calling\n    destruct B. Subgoals containing a contradiction are discarded.\n    case_if looks in the goal first, and otherwise in the\n    first hypothesis that contains and if statement.\n    case_if in H can be used to specify which hypothesis to consider.\n    Syntaxes case_if as Eq and case_if in H as Eq allows to name\n    the hypothesis coming from the case analysis.\n\n```", "```\n\n    cases_if is similar to case_if with two main differences:\n    if it creates an equality of the form x = y and then \n    substitutes it in the goal\n\n```", "```\n\n    case_ifs is like repeat case_if\n\n```", "```\n\n    destruct_if looks for a pattern of the form if ?B then ?E[1] else ?E[2]\n    in the goal, and perform a case analysis on B by calling\n    destruct B. It looks in the goal first, and otherwise in the\n    first hypothesis that contains and if statement.\n\n```", "```\n\n    BROKEN since v[8].5beta2.\n\n    destruct_head_match performs a case analysis on the argument\n    of the head pattern matching when the goal has the form\n    match ?E with ... or match ?E with ... = _ or\n    _ = match ?E with .... Due to the limits of Ltac, this tactic\n    will not fail if a match does not occur. Instead, it might\n    perform a case analysis on an unspecified subterm from the goal.\n    Warning: experimental.\n\n```", "```\n\n    cases' E is similar to case_eq E except that it generates the\n    equality in the context and not in the goal. The syntax cases E as H\n    allows specifying the name H of that hypothesis.\n\n```", "```\n\n    cases_if' is similar to cases_if except that it generates\n    the symmetric equality.\n\n```", "```\n\n# Induction\n\n    inductions E is a shorthand for dependent induction E.\n    inductions E gen X[1] .. XN is a shorthand for\n    dependent induction E generalizing X[1] .. XN.\n\n```", "```\n\n    induction_wf IH: E X is used to apply the well-founded induction\n    principle, for a given well-founded relation. It applies to a goal\n    PX where PX is a proposition on X. First, it sets up the\n    goal in the form (fun a \u21d2 P a) X, using pattern X, and then\n    it applies the well-founded induction principle instantiated on E,\n    where E is a term of type well_founded R, and R is a binary\n    relation.\n    Syntaxes induction_wf: E X and induction_wf E X.\n\n```", "```\n\n    Induction on the height of a derivation: the helper tactic\n    induct_height helps proving the equivalence of the auxiliary \n    judgment that includes a counter for the maximal height\n    (see LibTacticsDemos for an example)\n\n```", "```\n\n# Coinduction\n\n    Tactic cofixs IH is like cofix IH except that the\n    coinduction hypothesis is tagged in the form IH: COIND P\n    instead of being just IH: P. This helps other tactics\n    clearing the coinduction hypothesis using clear_coind\n\n```", "```\n\n    Tactic clear_coind clears all the coinduction hypotheses,\n    assuming that they have been tagged\n\n```", "```\n\n    Tactic abstracts tac is like abstract tac except that\n    it clears the coinduction hypotheses so that the productivity\n    check will be happy. For example, one can use abstracts omega\n    to obtain the same behavior as omega but with an auxiliary\n    lemma being generated.\n\n```", "```\n\n# Decidable Equality\n\n    decides_equality is the same as decide equality excepts that it\n    is able to unfold definitions at head of the current goal.\n\n```", "```\n\n# Equivalence\n\n    iff H can be used to prove an equivalence P \u2194 Q and name H\n    the hypothesis obtained in each case. The syntaxes iff and iff H[1] H[2]\n    are also available to specify zero or two names. The tactic iff \u2190 H\n    swaps the two subgoals, i.e., produces (Q -> P) as first subgoal.\n\n```", "```\n\n# N-ary Conjunctions and Disjunctions\n\n```", "```\n\n    N-ary Conjunctions Splitting in Goals \n\n    Underlying implementation of splits.\n\n```", "```\n\n    splits applies to a goal of the form (T[1] \u2227 .. \u2227 TN) and\n    destruct it into N subgoals T[1] .. TN. If the goal is not a\n    conjunction, then it unfolds the head definition.\n\n```", "```\n\n    splits N is similar to splits, except that it will unfold as many\n    definitions as necessary to obtain an N-ary conjunction.\n\n```", "```\n\n    splits_all will recursively split any conjunction, unfolding\n    definitions when necessary. Warning: this tactic will loop\n    on goals of the form well_founded R. Todo: fix this\n\n```", "```\n\n    N-ary Conjunctions Deconstruction \n\n    Underlying implementation of destructs.\n\n```", "```\n\n    destructs T allows destructing a term T which is a N-ary\n    conjunction. It is equivalent to destruct T as (H[1] .. HN),\n    except that it does not require to manually specify N different\n    names.\n\n```", "```\n\n    destructs N T is equivalent to destruct T as (H[1] .. HN),\n    except that it does not require to manually specify N different\n    names. Remark that it is not restricted to N-ary conjunctions.\n\n```", "```\n\n    Proving goals which are N-ary disjunctions \n\n    Underlying implementation of branch.\n\n```", "```\n\n    branch N applies to a goal of the form\n    P[1] \u2228 ... \u2228 PK \u2228 ... \u2228 PN and leaves the goal PK.\n    It only able to unfold the head definition (if there is one),\n    but for more complex unfolding one should use the tactic\n    branch K of N.\n\n```", "```\n\n    branch K of N is similar to branch K except that the\n    arity of the disjunction N is given manually, and so this\n    version of the tactic is able to unfold definitions.\n    In other words, applies to a goal of the form\n    P[1] \u2228 ... \u2228 PK \u2228 ... \u2228 PN and leaves the goal PK.\n\n```", "```\n\n    N-ary Disjunction Deconstruction \n\n    Underlying implementation of branches.\n\n```", "```\n\n    branches T allows destructing a term T which is a N-ary\n    disjunction. It is equivalent to destruct T as [ H[1] | .. | HN ] ,\n    and produces N subgoals corresponding to the N possible cases. \n\n```", "```\n\n    branches N T is the same as branches T except that the arity is\n    forced to N. This version is useful to unfold definitions\n    on the fly.\n\n```", "```\n\n    N-ary Existentials\n\n```", "```\n\n    \u2203 T[1] ... TN is a shorthand for \u2203 T[1]; ...; \u2203 TN.\n    It is intended to prove goals of the form exist X[1] .. XN, P.\n    If an argument provided is __ (double underscore), then an\n    evar is introduced. \u2203 T[1] .. TN ___ is equivalent to\n    \u2203 T[1] .. TN __ __ __ with as many __ as possible.\n\n```", "```\n\n    Existentials and conjunctions in hypotheses \n\n    unpack or unpack H destructs conjunctions and existentials in\n    all or one hypothesis.\n\n```", "```\n\n# Tactics to Prove Typeclass Instances\n\n    typeclass is an automation tactic specialized for finding\n    typeclass instances.\n\n```", "```\n\n    solve_typeclass is a simpler version of typeclass, to use\n    in hint tactics for resolving instances\n\n```", "```\n\n# Tactics to Invoke Automation\n\n```", "```\n\n## Definitions for Parsing Compatibility\n\n```", "```\n\n## hint to Add Hints Local to a Lemma\n\n    hint E adds E as an hypothesis so that automation can use it.\n    Syntax hint E[1],..,EN is available\n\n```", "```\n\n## jauto, a New Automation Tactic\n\n    jauto is better at intuition eauto because it can open existentials\n    from the context. In the same time, jauto can be faster than\n    intuition eauto because it does not destruct disjunctions from the\n    context. The strategy of jauto can be summarized as follows:\n\n*   open all the existentials and conjunctions from the context\n\n*   call esplit and split on the existentials and conjunctions in the goal\n\n*   call eauto.\n\n```", "```\n\n    iauto is a shorthand for intuition eauto\n\n```", "```\n\n## Definitions of Automation Tactics\n\n    The two following tactics defined the default behaviour of\n    \"light automation\" and \"strong automation\". These tactics\n    may be redefined at any time using the syntax Ltac .. ::= ... \n\n    auto_tilde is the tactic which will be called each time a symbol\n    \u00ac is used after a tactic.\n\n```", "```\n\n    auto_star is the tactic which will be called each time a symbol\n    * is used after a tactic.\n\n```", "```\n\n    autos\u00ac is a notation for tactic auto_tilde. It may be followed\n    by lemmas (or proofs terms) which auto will be able to use\n    for solving the goal.  autos is an alias for autos\u00ac\n\n```", "```\n\n    autos* is a notation for tactic auto_star. It may be followed\n    by lemmas (or proofs terms) which auto will be able to use\n    for solving the goal.\n\n```", "```\n\n    auto_false is a version of auto able to spot some contradictions.\n    There is an ad-hoc support for goals in \u2194: split is called first.\n    auto_false\u00ac and auto_false* are also available.\n\n```", "```\n\n## Parsing for Light Automation\n\n    Any tactic followed by the symbol \u00ac will have auto_tilde called\n    on all of its subgoals. Three exceptions:\n\n*   cuts and asserts only call auto on their first subgoal,\n\n*   apply\u00ac relies on sapply rather than apply,\n\n*   tryfalse\u00ac is defined as tryfalse by auto_tilde.\n\n    Some builtin tactics are not defined using tactic notations\n   and thus cannot be extended, e.g., simpl and unfold.\n   For these, notation such as simpl\u00ac will not be available.\n\n```", "```\n\n## Parsing for Strong Automation\n\n    Any tactic followed by the symbol * will have auto* called\n    on all of its subgoals. The exceptions to these rules are the\n    same as for light automation.\n\n    Exception: use subs* instead of subst* if you\n    import the library Coq.Classes.Equivalence.\n\n```", "```\n\n# Tactics to Sort Out the Proof Context\n\n```", "```\n\n## Hiding Hypotheses\n\n```", "```\n\n    hide_def x and show_def x can be used to hide/show\n    the body of the definition x.\n\n```", "```\n\n    show_def unfolds Something in the goal\n\n```", "```\n\n    hide_defs and show_defs applies to all definitions\n\n```", "```\n\n    hide_hyp H replaces the type of H with the notation Something\n    and show_hyp H reveals the type of the hypothesis. Note that the\n    hidden type of H remains convertible the real type of H.\n\n```", "```\n\n    hide_hyps and show_hyps can be used to hide/show all hypotheses\n    of type Prop.\n\n```", "```\n\n    hide H and show H automatically select between\n    hide_hyp or hide_def, and show_hyp or show_def.\n    Similarly hide_all and show_all apply to all.\n\n```", "```\n\n    hide_term E can be used to hide a term from the goal.\n    show_term or show_term E can be used to reveal it.\n    hide_term E in H can be used to specify an hypothesis.\n\n```", "```\n\n    show_unfold R unfolds the definition of R and\n    reveals the hidden definition of R. \u2014todo:test, \n    and implement using unfold simply\n\n```", "```\n\n## Sorting Hypotheses\n\n    sort sorts out hypotheses from the context by moving all the\n    propositions (hypotheses of type Prop) to the bottom of the context.\n\n```", "```\n\n## Clearing Hypotheses\n\n    clears X[1] ... XN is a variation on clear which clears\n    the variables X[1]..XN as well as all the hypotheses which\n    depend on them. Contrary to clear, it never fails.\n\n```", "```\n\n    clears (without any argument) clears all the unused variables\n    from the context. In other words, it removes any variable\n    which is not a proposition (i.e., not of type Prop) and which\n    does not appear in another hypothesis nor in the goal.\n\n```", "```\n\n    clears_all clears all the hypotheses from the context\n    that can be cleared. It leaves only the hypotheses that\n    are mentioned in the goal.\n\n```", "```\n\n    clears_but H[1] H[2] .. HN clears all hypotheses except the\n    one that are mentioned and those that cannot be cleared.\n\n```", "```\n\n    clears_last clears the last hypothesis in the context.\n    clears_last N clears the last N hypotheses in the context.\n\n```", "```\n\n# Tactics for Development Purposes\n\n```", "```\n\n## Skipping Subgoals\n\n    DEPRECATED: the new \"admit\" tactics now works fine.\n\n    The skip tactic can be used at any time to admit the current\n    goal. Using skip is much more efficient than using the Focus\n    top-level command to reach a particular subgoal.\n\n    There are two possible implementations of skip. The first one\n    relies on the use of an existential variable. The second one\n    relies on an axiom of type False. Remark that the builtin tactic\n    admit is not applicable if the current goal contains uninstantiated\n    variables.\n\n    The advantage of the first technique is that a proof using skip\n    must end with Admitted, since Qed will be rejected with the message\n    \"uninstantiated existential variables\". It is thereafter clear\n    that the development is incomplete.\n\n    The advantage of the second technique is exactly the converse: one\n    may conclude the proof using Qed, and thus one saves the pain from\n    renaming Qed into Admitted and vice-versa all the time.\n    Note however, that it is still necessary to instantiate all the existential\n    variables introduced by other tactics in order for Qed to be accepted.\n\n    The two implementation are provided, so that you can select the one that\n    suits you best. By default skip' uses the first implementation, and\n    skip uses the second implementation.\n\n```", "```\n\n    demo is like admit but it documents the fact that admit is intended\n\n```", "```\n\n    skip H: T adds an assumption named H of type T to the\n    current context, blindly assuming that it is true.\n    skip: T and skip H_asserts: T and skip_asserts: T\n    are other possible syntax.\n    Note that H may be an intro pattern.\n    The syntax skip H[1] .. HN: T can be used when T is a\n    conjunction of N items.\n\n```", "```\n\n    skip_cuts T simply replaces the current goal with T.\n\n```", "```\n\n    skip_goal H applies to any goal. It simply assumes\n    the current goal to be true. The assumption is named \"H\".\n    It is useful to set up proof by induction or coinduction.\n    Syntax skip_goal is also accepted.\n\n```", "```\n\n    skip_rewrite T can be applied when T is an equality.\n    It blindly assumes this equality to be true, and rewrite it in\n    the goal.\n\n```", "```\n\n    skip_rewrite T in H is similar as rewrite_skip, except that\n    it rewrites in hypothesis H.\n\n```", "```\n\n    skip_rewrites_all T is similar as rewrite_skip, except that\n    it rewrites everywhere (goal and all hypotheses).\n\n```", "```\n\n    skip_induction E applies to any goal. It simply assumes\n    the current goal to be true (the assumption is named \"IH\" by\n    default), and call destruct E instead of induction E.\n    It is useful to try and set up a proof by induction\n    first, and fix the applications of the induction hypotheses\n    during a second pass on the Proof using.\n\n```", "```\n\n# Compatibility with Standard Library\n\n    The module Program contains definitions that conflict with the\n    current module. If you import Program, either directly or indirectly\n    (e.g., through Setoid or ZArith), you will need to import the\n    compability definitions through the top-level command:\n    Import LibTacticsCompatibility.\n\n```", "```\n\n```"]