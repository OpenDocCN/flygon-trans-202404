["```\n    (define add (make-untyped-list-function +))(add (list 1 2 3 4))\n    ```", "```\n[\u25b6](toy.rkt \"toy.rkt\")#lang pl;;; ----------------------------------------------------------------;;; Syntax#| The BNF:\u00a0  <TOY> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | <id>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { bind {{ <id> <TOY> } ... } <TOY> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { fun { <id> ... } <TOY> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { if <TOY> <TOY> <TOY> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { <TOY> <TOY> ... }|#;; A matching abstract syntax tree datatype:(define-type TOY\u00a0 [Num\u00a0 Number]\u00a0 [Id\u00a0  Symbol]\u00a0 [Bind (Listof Symbol) (Listof TOY) TOY]\u00a0 [Fun\u00a0 (Listof Symbol) TOY]\u00a0 [Call TOY (Listof TOY)]\u00a0 [If\u00a0  TOY TOY TOY])(: unique-list? : (Listof Any) -> Boolean);; Tests whether a list is unique, guards Bind and Fun values.(define (unique-list? xs)\u00a0 (or (null? xs)\u00a0 \u00a0 \u00a0 (and (not (member (first xs) (rest xs)))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (unique-list? (rest xs)))))(: parse-sexpr : Sexpr -> TOY);; parses s-expressions into TOYs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'bind more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'bind (list (list (symbol: names) (sexpr: nameds))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ...)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 body)\u00a0 \u00a0 \u00a0 \u00a0 (if (unique-list? names)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Bind names (map parse-sexpr nameds) (parse-sexpr body))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (error 'parse-sexpr \"duplicate `bind' names: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  names))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `bind' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'fun more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'fun (list (symbol: names) ...) body)\u00a0 \u00a0 \u00a0 \u00a0 (if (unique-list? names)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Fun names (parse-sexpr body))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (error 'parse-sexpr \"duplicate `fun' names: ~s\" names))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `fun' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'if more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'if cond then else)\u00a0 \u00a0 \u00a0 \u00a0 (If (parse-sexpr cond)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (parse-sexpr then)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (parse-sexpr else))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `if' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list fun args ...) ; other lists are applications\u00a0 \u00a0  (Call (parse-sexpr fun)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (map parse-sexpr args))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> TOY);; Parses a string containing an TOY expression to a TOY AST.(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)));;; ----------------------------------------------------------------;;; Values and environments(define-type ENV\u00a0 [EmptyEnv]\u00a0 [FrameEnv FRAME ENV]);; a frame is an association list of names and values.(define-type FRAME = (Listof (List Symbol VAL)))(define-type VAL\u00a0 [RktV\u00a0 Any]\u00a0 [FunV\u00a0 (Listof Symbol) TOY ENV]\u00a0 [PrimV ((Listof VAL) -> VAL)])(: extend : (Listof Symbol) (Listof VAL) ENV -> ENV);; extends an environment with a new frame.(define (extend names values env)\u00a0 (if (= (length names) (length values))\u00a0 \u00a0 (FrameEnv (map (lambda ([name : Symbol] [val : VAL])\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (list name val))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  names values)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 env)\u00a0 \u00a0 (error 'extend \"arity mismatch for names: ~s\" names)))(: lookup : Symbol ENV -> VAL);; lookup a symbol in an environment, frame by frame,;; return its value or throw an error if it isn't bound(define (lookup name env)\u00a0 (cases env\u00a0 \u00a0 [(EmptyEnv) (error 'lookup \"no binding for ~s\" name)]\u00a0 \u00a0 [(FrameEnv frame rest)\u00a0 \u00a0  (let ([cell (assq name frame)])\u00a0 \u00a0 \u00a0  (if cell\u00a0 \u00a0 \u00a0 \u00a0  (second cell)\u00a0 \u00a0 \u00a0 \u00a0  (lookup name rest)))]))(: unwrap-rktv : VAL -> Any);; helper for `racket-func->prim-val': unwrap a RktV wrapper in;; preparation to be sent to the primitive function(define (unwrap-rktv x)\u00a0 (cases x\u00a0 \u00a0 [(RktV v) v]\u00a0 \u00a0 [else (error 'racket-func \"bad input: ~s\" x)]))(: racket-func->prim-val : Function -> VAL);; converts a racket function to a primitive evaluator function;; which is a PrimV holding a ((Listof VAL) -> VAL) function.;; (the resulting function will use the list function as is,;; and it is the list function's responsibility to throw an error;; if it's given a bad number of arguments or bad input types.)(define (racket-func->prim-val racket-func)\u00a0 (define list-func (make-untyped-list-function racket-func))\u00a0 (PrimV (lambda (args)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (RktV (list-func (map unwrap-rktv args))))));; The global environment has a few primitives:(: global-environment : ENV)(define global-environment\u00a0 (FrameEnv (list (list '+ (racket-func->prim-val +))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (list '- (racket-func->prim-val -))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (list '* (racket-func->prim-val *))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (list '/ (racket-func->prim-val /))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (list '< (racket-func->prim-val <))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (list '> (racket-func->prim-val >))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (list '= (racket-func->prim-val =))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ;; values\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (list 'true\u00a0 (RktV #t))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (list 'false (RktV #f)))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (EmptyEnv)));;; ----------------------------------------------------------------;;; Evaluation(: eval : TOY ENV -> VAL);; evaluates TOY expressions.(define (eval expr env)\u00a0 ;; convenient helper\u00a0 (: eval* : TOY -> VAL)\u00a0 (define (eval* expr) (eval expr env))\u00a0 (cases expr\u00a0 \u00a0 [(Num n)\u00a0  (RktV n)]\u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 [(Bind names exprs bound-body)\u00a0 \u00a0  (eval bound-body (extend names (map eval* exprs) env))]\u00a0 \u00a0 [(Fun names bound-body)\u00a0 \u00a0  (FunV names bound-body env)]\u00a0 \u00a0 [(Call fun-expr arg-exprs)\u00a0 \u00a0  (let ([fval (eval* fun-expr)]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [arg-vals (map eval* arg-exprs)])\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(PrimV proc) (proc arg-vals)]\u00a0 \u00a0 \u00a0 \u00a0  [(FunV names body fun-env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval body (extend names arg-vals fun-env))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"function call with a non-function: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]\u00a0 \u00a0 [(If cond-expr then-expr else-expr)\u00a0 \u00a0  (eval* (if (cases (eval* cond-expr)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [(RktV v) v] ; Racket value => use as boolean\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [else #t])\u00a0  ; other values are always true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 then-expr\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else-expr))]))(: run : String -> Any);; evaluate a TOY program contained in a string(define (run str)\u00a0 (let ([result (eval (parse str) global-environment)])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(RktV v) v]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a bad value: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])));;; ----------------------------------------------------------------;;; Tests(test (run \"{{fun {x} {+ x 1}} 4}\")\u00a0 \u00a0 \u00a0 => 5)(test (run \"{bind {{add3 {fun {x} {+ x 3}}}} {add3 1}}\")\u00a0 \u00a0 \u00a0 => 4)(test (run \"{bind {{add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {add1 {fun {x} {+ x 1}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {bind {{x 3}} {add1 {add3 x}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{bind {{identity {fun {x} x}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {foo {fun {x} {+ x 1}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {{identity foo} 123}}\")\u00a0 \u00a0 \u00a0 => 124)(test (run \"{bind {{x 3}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {bind {{f {fun {y} {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {bind {{x 5}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {f 4}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{{{fun {x} {x 1}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {x} {fun {y} {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  123}\")\u00a0 \u00a0 \u00a0 => 124);; More tests for complete coverage(test (run \"{bind x 5 x}\")\u00a0 \u00a0 \u00a0 =error> \"bad `bind' syntax\")(test (run \"{fun x x}\")\u00a0 \u00a0 \u00a0 \u00a0  =error> \"bad `fun' syntax\")(test (run \"{if x}\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 =error> \"bad `if' syntax\")(test (run \"{}\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 =error> \"bad syntax\")(test (run \"{bind {{x 5} {x 5}} x}\") =error> \"duplicate*bind*names\")(test (run \"{fun {x x} x}\")\u00a0 \u00a0  =error> \"duplicate*fun*names\")(test (run \"{+ x 1}\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  =error> \"no binding for\")(test (run \"{+ 1 {fun {x} x}}\") =error> \"bad input\")(test (run \"{+ 1 {fun {x} x}}\") =error> \"bad input\")(test (run \"{1 2}\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  =error> \"with a non-function\")(test (run \"{{fun {x} x}}\")\u00a0 \u00a0  =error> \"arity mismatch\")(test (run \"{if {< 4 5} 6 7}\")\u00a0 => 6)(test (run \"{if {< 5 4} 6 7}\")\u00a0 => 7)(test (run \"{if + 6 7}\")\u00a0 \u00a0 \u00a0 \u00a0 => 6)(test (run \"{fun {x} x}\")\u00a0 \u00a0 \u00a0  =error> \"returned a bad value\");;; ----------------------------------------------------------------\n```"]