- en: Troubleshooting F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the saying goes, "if it compiles, it's correct", but it can be extremely
    frustrating just trying to get the code to compile at all! So this page is devoted
    to helping you troubleshoot your F# code.
  prefs: []
  type: TYPE_NORMAL
- en: I will first present some general advice on troubleshooting and some of the
    most common errors that beginners make. After that, I will describe each of the
    common error messages in detail, and give examples of how they can occur and how
    to correct them.
  prefs: []
  type: TYPE_NORMAL
- en: '[(Jump to the error numbers)](#NumericErrors)'
  prefs: []
  type: TYPE_NORMAL
- en: General guidelines for troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By far the most important thing you can do is to take the time and effort to
    understand exactly how F# works, especially the core concepts involving functions
    and the type system. So please read and reread the series ["thinking functionally"](thinking-functionally.html)
    and ["understanding F# types"](understanding-fsharp-types.html), play with the
    examples, and get comfortable with the ideas before you try to start doing serious
    coding. If you don't understand how functions and types work, then the compiler
    errors will not make any sense.
  prefs: []
  type: TYPE_NORMAL
- en: If you are coming from an imperative language such as C#, you may have developed
    some bad habits by relying on the debugger to find and fix incorrect code. In
    F#, you will probably not get that far, because the compiler is so much stricter
    in many ways. And of course, there is no tool to "debug" the compiler and step
    through its processing. The best tool for debugging compiler errors is your brain,
    and F# forces you to use it!
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, there are a number of extremely common errors that beginners make,
    and I will quickly go through them.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use parentheses when calling a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In F#, whitespace is the standard separator for function parameters. You will
    rarely need to use parentheses, and in particular, do not use parentheses when
    calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Don't mix up tuples with multiple parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If it has a comma, it is a tuple. And a tuple is one object not two. So you
    will get errors about passing the wrong type of parameter, or too few parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The compiler treats `(1,2)` as a generic tuple, which it attempts to pass to
    "`addTwoParams`". Then it complains that the first parameter of `addTwoParams`
    is an int, and we're trying to pass a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to pass *two* arguments to a function expecting *one* tuple,
    you will get another obscure error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Watch out for too few or too many arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The F# compiler will not complain if you pass too few arguments to a function
    (in fact "partial application" is an important feature), but if you don't understand
    what is going on, you will often get strange "type mismatch" errors later.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly the error for having too many arguments is typically "This value is
    not a function" rather than a more straightforward error.
  prefs: []
  type: TYPE_NORMAL
- en: The "printf" family of functions is very strict in this respect. The argument
    count must be exact.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important topic ? it is critical that you understand how partial
    application works. See the series ["thinking functionally"](thinking-functionally.html)
    for a more detailed discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Use semicolons for list separators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the few places where F# needs an explicit separator character, such as lists
    and records, the semicolon is used. Commas are never used. (Like a broken record,
    I will remind you that commas are for tuples).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Don't use ! for not or != for not-equal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The exclamation point symbol is not the "NOT" operator. It is the deferencing
    operator for mutable references. If you use it by mistake, you will get the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The correct construction is to use the "not" keyword. Think SQL or VB syntax
    rather than C syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And for "not equal", use "<>", again like SQL or VB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Don't use = for assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using mutable values, the assignment operation is written "`<-`".
    If you use the equals symbol you might not even get an error, just an unexpected
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Watch out for hidden tab characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The indenting rules are very straightforward, and it is easy to get the hang
    of them. But you are not allowed to use tabs, only spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to set your editor to convert tabs to spaces. And watch out if you are
    pasting code in from elsewhere. If you do run into persistent problems with a
    bit of code, try removing the whitespace and re-adding it.
  prefs: []
  type: TYPE_NORMAL
- en: Don't mistake simple values for function values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are trying to create a function pointer or delegate, watch out that you
    don't accidentally create a simple value that has already been evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a parameterless function that you can reuse, you will need to explicitly
    pass a unit parameter, or define it as a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See the series ["thinking functionally"](thinking-functionally.html) for more
    discussion of parameterless functions.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for troubleshooting "not enough information" errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The F# compiler is currently a one-pass left-to-right compiler, and so type
    information later in the program is unavailable to the compiler if it hasn't been
    parsed yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of errors can be caused by this, such as ["FS0072: Lookup on object
    of indeterminate type"](#FS0072) and ["FS0041: A unique overload for could not
    be determined"](#FS0041). The suggested fixes for each of these specific cases
    are described below, but there are some general principles that can help if the
    compiler is complaining about missing types or not enough information. These guidelines
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Define things before they are used (this includes making sure the files are
    compiled in the right order)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the things that have "known types" earlier than things that have "unknown
    types". In particular, you might be able reorder pipes and similar chained functions
    so that the typed objects come first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate as needed. One common trick is to add annotations until everything
    works, and then take them away one by one until you have the minimum needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do try to avoid annotating if possible. Not only is it not aesthetically pleasing,
    but it makes the code more brittle. It is a lot easier to change types if there
    are no explicit dependencies on them.
  prefs: []
  type: TYPE_NORMAL
- en: F# compiler errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A listing of common errors, ordered by error number
  prefs: []
  type: TYPE_NORMAL
- en: Here is a list of the major errors that seem to me worth documenting. I have
    not documented any errors that are self explanatory, only those that seem obscure
    to beginners.
  prefs: []
  type: TYPE_NORMAL
- en: I will continue to add to the list in the future, and I welcome any suggestions
    for additions.
  prefs: []
  type: TYPE_NORMAL
- en: '[FS0001: The type ''X'' does not match the type ''Y''](#FS0001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0003: This value is not a function and cannot be applied](#FS0003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0008: This runtime coercion or type test involves an indeterminate type](#FS0008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0010: Unexpected identifier in binding](#FS0010a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0010: Incomplete structured construct](#FS0010b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0013: The static coercion from type X to Y involves an indeterminate type](#FS0013)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0020: This expression should have type ''unit''](#FS0020)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0030: Value restriction](#FS0030)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0035: This construct is deprecated](#FS0035)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0039: The field, constructor or member X is not defined](#FS0039)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0041: A unique overload for could not be determined](#FS0041)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0049: Uppercase variable identifiers should not generally be used in patterns](#FS0049)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0072: Lookup on object of indeterminate type](#FS0072)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FS0588: Block following this ''let'' is unfinished](#FS0588)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FS0001: The type ''X'' does not match the type ''Y'''
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably the most common error you will run into. It can manifest itself
    in a wide variety of contexts, so I have grouped the most common problems together
    with examples and fixes. Do pay attention to the error message, as it is normally
    quite explicit about what the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: '| Error message | Possible causes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| The type ''float'' does not match the type ''int'' | [A. Can''t mix floats
    and ints](#FS0001A) |'
  prefs: []
  type: TYPE_TB
- en: '| The type ''int'' does not support any operators named ''DivideByInt'' | [A.
    Can''t mix floats and ints.](#FS0001A) |'
  prefs: []
  type: TYPE_TB
- en: '| The type ''X'' is not compatible with any of the types | [B. Using the wrong
    numeric type.](#FS0001B) |'
  prefs: []
  type: TYPE_TB
- en: '| This type (function type) does not match the type (simple type). Note: function
    types have a arrow in them, like `''a -> ''b`. | [C. Passing too many arguments
    to a function.](#FS0001C) |'
  prefs: []
  type: TYPE_TB
- en: '| This expression was expected to have (function type) but here has (simple
    type) | [C. Passing too many arguments to a function.](#FS0001C) |'
  prefs: []
  type: TYPE_TB
- en: '| This expression was expected to have (N part function) but here has (N-1
    part function) | [C. Passing too many arguments to a function.](#FS0001C) |'
  prefs: []
  type: TYPE_TB
- en: '| This expression was expected to have (simple type) but here has (function
    type) | [D. Passing too few arguments to a function.](#FS0001D) |'
  prefs: []
  type: TYPE_TB
- en: '| This expression was expected to have (type) but here has (other type) | [E.
    Straightforward type mismatch.](#FS0001E) [F. Inconsistent returns in branches
    or matches.](#FS0001F)'
  prefs: []
  type: TYPE_NORMAL
- en: '[G. Watch out for type inference effects buried in a function.](#FS0001G)'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type mismatch. Expecting a (simple type) but given a (tuple type). Note:
    tuple types have a star in them, like `''a * ''b`. | [H. Have you used a comma
    instead of space or semicolon?](#FS0001H) |'
  prefs: []
  type: TYPE_TB
- en: '| Type mismatch. Expecting a (tuple type) but given a (different tuple type).
    | [I. Tuples must be the same type to be compared.](#FS0001I) |'
  prefs: []
  type: TYPE_TB
- en: '| This expression was expected to have type ''a ref but here has type X | [J.
    Don''t use ! as the "not" operator.](#FS0001J) |'
  prefs: []
  type: TYPE_TB
- en: '| The type (type) does not match the type (other type) | [K. Operator precedence
    (especially functions and pipes).](#FS0001K) |'
  prefs: []
  type: TYPE_TB
- en: '| This expression was expected to have type (monadic type) but here has type
    ''b * ''c | [L. let! error in computation expressions.](#FS0001L) |'
  prefs: []
  type: TYPE_TB
- en: A. Can't mix ints and floats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike C# and most imperative languages, ints and floats cannot be mixed in
    expressions. You will get a type error if you attempt this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is to cast the int into a `float` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This issue can also manifest itself in library functions and other places. For
    example, you cannot do "`average`" on a list of ints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You must cast each int to a float first, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: B. Using the wrong numeric type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will get a "not compatible" error when a numeric cast failed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: One possible fix is to cast it if appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: C. Passing too many arguments to a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The clue is in the error.
  prefs: []
  type: TYPE_NORMAL
- en: The fix is to remove one of the arguments!
  prefs: []
  type: TYPE_NORMAL
- en: Similar errors are caused by passing too many arguments to `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: D. Passing too few arguments to a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not pass enough arguments to a function, you will get a partial application.
    When you later use it, you get an error because it is not a simple type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly common for some .NET library functions that expect a unit
    parameter, such as `ReadLine` above.
  prefs: []
  type: TYPE_NORMAL
- en: The fix is to pass the correct number of parameters. Check the type of the result
    value to make sure that it is indeed a simple type. In the `ReadLine` case, the
    fix is to pass a `()` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: E. Straightforward type mismatch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest case is that you have the wrong type, or you are using the wrong
    type in a print format string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: F. Inconsistent return types in branches or matches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common mistake is that if you have a branch or match expression, then every
    branch MUST return the same type. If not, you will get a type error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the straightforward fix is to make each branch return the same type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Remember that if an "else" branch is missing, it is assumed to return unit,
    so the "true" branch must also return unit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If both branches cannot return the same type, you may need to create a new union
    type that can contain both types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: G. Watch out for type inference effects buried in a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function may cause an unexpected type inference that ripples around your code.
    For example, in the following, the innocent print format string accidentally causes
    `doSomething` to expect a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The fix is to check the function signatures and drill down until you find the
    guilty party. Also, use the most generic types possible, and avoid type annotations
    if possible.
  prefs: []
  type: TYPE_NORMAL
- en: H. Have you used a comma instead of space or semicolon?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are new to F#, you might accidentally use a comma instead of spaces
    to separate function arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is: don''t use a comma!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'One area where commas *are* used is when calling .NET library functions. These
    all take tuples as arguments, so the comma form is correct. In fact, these calls
    look just the same as they would from C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I. Tuples must be the same type to be compared or pattern matched
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tuples with different types cannot be compared. Trying to compare a tuple of
    type `int * int`, with a tuple of type `int * string` results in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And the length must be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get the same issue when pattern matching tuples during binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: J. Don't use ! as the "not" operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use `!` as a "not" operator, you will get a type error mentioning the
    word "ref".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The fix is to use the "not" keyword instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: K. Operator precedence (especially functions and pipes)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you mix up operator precedence, you may get type errors. Generally, function
    application is highest precedence compared to other operators, so you get an error
    in the case below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The fix is to use parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, the pipe operator is low precedence compared to other operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Again, the fix is to use parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: L. let! error in computation expressions (monads)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a simple computation expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: However, if you try to use it, you get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that "`Bind`" expects a tuple `(wrapper,func)`, not two parameters.
    (Check the signature for bind in the F# documentation).
  prefs: []
  type: TYPE_NORMAL
- en: The fix is to change the bind function to accept a tuple as its (single) parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0003: This value is not a function and cannot be applied'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This error typically occurs when passing too many arguments to a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It can also occur when you do operator overloading, but the operators cannot
    be used as prefix or infix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0008: This runtime coercion or type test involves an indeterminate type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will often see this when attempting to use "`:?`" operator to match on a
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The message tells you the problem: "runtime type tests are not allowed on some
    types".'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to "box" the value which forces it into a reference type, and
    then you can type check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0010: Unexpected identifier in binding'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically caused by breaking the "offside" rule for aligning expressions in
    a block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The fix is to align the code correctly!
  prefs: []
  type: TYPE_NORMAL
- en: 'See also [FS0588: Block following this ''let'' is unfinished](#FS0588) for
    another issue caused by alignment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'FS0010: Incomplete structured construct'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often occurs if you are missing parentheses from a class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Can also occur if you forgot to put parentheses around an operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Can also occur if you are missing one side of an infix operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Can also occur if you attempt to send a namespace definition to F# interactive.
    The interactive console does not allow namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0013: The static coercion from type X to Y involves an indeterminate type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is generally caused by implic
  prefs: []
  type: TYPE_NORMAL
- en: 'FS0020: This expression should have type ''unit'''
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This error is commonly found in two situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Expressions that are not the last expression in the block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using wrong assignment operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FS0020 with expressions that are not the last expression in the block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only the last expression in a block can return a value. All others must return
    unit. So this typically occurs when you have a function in a place that is not
    the last function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The easy fix is use `ignore`. But ask yourself why you are using a function
    and then throwing away the answer ? it might be a bug.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This also occurs if you think you writing C# and you accidentally use semicolons
    to separate expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: FS0020 with assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another variant of this error occurs when assigning to a property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: With this error, chances are you have confused the assignment operator "`<-`"
    for mutable values, with the equality comparison operator "`=`".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The fix is to use the proper assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0030: Value restriction'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is related to F#'s automatic generalization to generic types whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: F#'s type inference will cleverly figure out the generic types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'However in some cases, the F# compiler feels that the code is ambiguous, and,
    even though it looks like it is guessing the type correctly, it needs you to be
    more specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost always this will be caused by trying to define a partially applied function,
    and almost always, the easiest fix is to explicitly add the missing parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For more details see the MSDN article on ["automatic generalization"](http://msdn.microsoft.com/en-us/library/dd233183%28v=VS.100%29.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'FS0035: This construct is deprecated'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# syntax has been cleaned up over the last few years, so if you are using examples
    from an older F# book or webpage, you may run into this. See the MSDN documentation
    for the correct syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0039: The field, constructor or member X is not defined'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This error is commonly found in four situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The obvious case where something really isn't defined! And make sure that you
    don't have a typo or case mismatch either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FS0039 with interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In F# all interfaces are "explicit" implementations rather than "implicit".
    (Read the C# documentation on ["explicit interface implementation"](http://msdn.microsoft.com/en-us/library/aa288461%28v=vs.71%29.aspx)
    for an explanation of the difference).
  prefs: []
  type: TYPE_NORMAL
- en: The key point is that when a interface member is explicitly implemented, it
    cannot be accessed through a normal class instance, but only through an instance
    of the interface, so you have to cast to the interface type by using the `:>`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a class that implements an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is to cast the object to the interface, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: FS0039 with recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s a standard Fibonacci implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that when the compiler sees 'fib' in the body, it doesn't know
    about the function because it hasn't finished compiling it yet!
  prefs: []
  type: TYPE_NORMAL
- en: The fix is to use the "`rec`" keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note that this only applies to "`let`" functions. Member functions do not need
    this, because the scope rules are slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: FS0039 with extension methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have defined an extension method, you won't be able to use it unless
    the module is in scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple extension to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to use it the extension, you get the FS0039 error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The fix is just to open the `IntExtensions` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0041: A unique overload for could not be determined'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This can be caused when calling a .NET library function that has multiple overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'There a number of ways to fix this. One way is to use an explicit type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You can sometimes use a named parameter to avoid the type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can try to create intermediate objects that help the type inference,
    again without needing type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0049: Uppercase variable identifiers should not generally be used in patterns'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When pattern matching, be aware of a subtle difference between the pure F# union
    types which consist of a tag only, and a .NET Enum type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pure F# union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'But with .NET enums you must fully qualify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The fixed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'FS0072: Lookup on object of indeterminate type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This occurs when "dotting into" an object whose type is unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The compiler does not know what type "x" is, and therefore does not know if
    "`Length`" is a valid method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There a number of ways to fix this. The crudest way is to provide an explicit
    type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In some cases though, judicious rearrangement of the code can help. For example,
    the example below looks like it should work. It's obvious to a human that the
    `List.map` function is being applied to a list of strings, so why does `x.Length`
    cause an error?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that the F# compiler is currently a one-pass compiler, and so
    type information present later in the program cannot be used if it hasn't been
    parsed yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, you can always explicitly annotate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: But another, more elegant way that will often fix the problem is to rearrange
    things so the known types come first, and the compiler can digest them before
    it moves to the next clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: It's good practice to avoid explicit type annotations, so this approach is best,
    if it is feasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'FS0588: Block following this ''let'' is unfinished'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caused by outdenting an expression in a block, and thus breaking the "offside
    rule".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The fix is to align the code correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'See also [FS0010: Unexpected identifier in binding](#FS0010a) for another issue
    caused by alignment.'
  prefs: []
  type: TYPE_NORMAL
