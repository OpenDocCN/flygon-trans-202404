["```\nrandomInts n =\n  let seed = Random.initialSeed 0 in\n  fst (Random.generate (Random.list n (Random.int 0 10000)) seed)\n\n> randomInts 1000\n[ ... ] : List Int\n\n> randomInts 10000\nRangeError: Maximum call stack size exceeded \n```", "```\n> [1..10000]\n[ ... ] : List number\n\n> [1..100000]\n[ ... ] : List number\n\n> [1..1000000]\n[ ... ] : List number\n\n> [1..10000000]\n[ ... ] : List number\n\n> [1..100000000]\nFATAL ERROR: JS Allocation failed - process out of memory \n```", "```\nsum n =\n  if | n <= 0    -> 0\n     | otherwise -> n + sum (n-1) \n```", "```\n> sum 100\n5050 : number\n\n> sum 1000\n500500 : number\n\n> sum 10000\n50005000 : number\n\n> sum 100000\nRangeError: Maximum call stack size exceeded \n```", "```\nsum_tr_ : Int -> Int -> Int\nsum_tr_ acc n =\n  if | n <= 0    -> acc\n     | otherwise -> sum_tr_ (n+acc) (n-1) \n```", "```\nsum_tr = sum_tr_ 0 \n```", "```\nsum_tr_ acc n =\n  var i   := n;\n  var res := acc;\n  while (not (!i <= 0)) {\n    res := !i + !res;\n    i   := !i - 1;\n  }\n  !res \n```", "```\n> sum_tr 100\n5050 : Int\n\n> sum_tr 1000\n500500 : Int\n\n> sum_tr 10000\nRangeError: Maximum call stack size exceeded\n\n> sum_tr 100000\nRangeError: Maximum call stack size exceeded \n```", "```\nsum_tr_ : Int -> Int -> Int \n```", "```\nsum_tramp_ : Int -> Int -> Trampoline Int \n```", "```\nsum_tramp_ : Int -> Int -> Trampoline Int\nsum_tramp_ acc n =\n  if | n <= 0    -> Done acc\n     | otherwise -> Continue (\\_ -> sum_tramp_ (n+acc) (n-1)) \n```", "```\ntrampoline : Trampoline a -> a \n```", "```\nsum_tramp = trampoline << sum_tramp_ 0 \n```", "```\n> sum_tr 100000\nRangeError: Maximum call stack size exceeded\n\n> sum_tramp 100000\n5000050000 : Int\n\n> sum_tramp 1000000\n500000500000 : Int\n\n> sum_tramp 10000000\n50000005000000 : Int\n\n> sum_tramp 100000000\n5000000050000000 : Int \n```", "```\nsum_tramp_ acc n =\n  if | n <= 0    -> Done acc\n     | otherwise -> Continue (always (sum_tramp_ (n+acc) (n-1))) \n```", "```\nsum_tramp_ acc n =\n  if | n <= 0    -> Done acc\n     | otherwise -> continue (sum_tramp_ (n+acc) (n-1))\n\ncontinue = Continue << always \n```", "```\nfoldl : (a -> b -> b) -> b -> List a -> b\nfoldl f acc xs = case xs of\n  []     -> acc\n  x::xs' -> foldl f (f x acc) xs' \n```", "```\nfoldl f acc xs =\n  var ys  := xs;\n  var res := acc;\n  while (not (!ys = [])) {\n    let (x::xs') = !ys in\n      res := f x !res;\n      ys  := xs';\n  }\n  !res \n```", "```\n> foldl (+) 0 [1..1000]\n500500 : number\n\n> foldl (+) 0 [1..10000]\nRangeError: Maximum call stack size exceeded \n```", "```\nfoldl_tramp_ : (a -> b -> b) -> b -> List a -> Trampoline b\nfoldl_tramp_ f acc xs = case xs of\n  []     -> Done acc\n  x::xs' -> Continue (\\_ -> foldl_tramp_ f (f x acc) xs')\n\nfoldl_tramp : (a -> b -> b) -> b -> List a -> b\nfoldl_tramp f init xs = trampoline <| foldl_tramp_ f init xs \n```", "```\n> foldl_tramp (+) 0 [1..10000]\n50005000 : number\n> foldl_tramp (+) 0 [1..100000]\n5000050000 : number\n> foldl_tramp (+) 0 [1..1000000]\n500000500000 : number \n```", "```\n> List.foldl (+) 0 [1..1000000]\n500000500000 : number \n```", "```\nfoldr : (a -> b -> b) -> b -> List a -> b\nfoldr f acc xs = case xs of\n  []     -> acc\n  x::xs' -> f x (foldr f acc xs') \n```", "```\nlist : Int -> Generator a -> Generator (List a) \n```", "```\nmodule TestRandomList where\n\nimport Random     as R\nimport RandomList as R'\n\nrandomInts n =\n  let seed = R.initialSeed 0 in\n  fst (R.generate (R.list n (R.int 0 10000)) seed)\n\nrandomInts' n =\n  let seed = R'.initialSeed 0 in\n  fst (R'.generate (R'.list n (R'.int 0 10000)) seed) \n```", "```\n> import TestRandomList (..)\n\n> randomInts 10\n[6992,4473,9857,1963,20,8490,708,8552,7773,6495] : List Int\n\n> randomInts' 10\n[6992,4473,9857,1963,20,8490,708,8552,7773,6495] : List Int\n\n> randomInts 10000\nRangeError: Maximum call stack size exceeded\n\n> randomInts' 10000\n[ ... ] : List Int \n```"]