- en: The "Thinking Functionally" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This series of posts will introduce you to the fundamentals of functional programming
    -- what does it really mean to "program functionally", and how this approach differs
    from object oriented or imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[Thinking Functionally: Introduction](thinking-functionally-intro.html). A
    look at the basics of functional programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mathematical functions](mathematical-functions.html). The impetus behind functional
    programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function Values and Simple Values](function-values-and-simple-values.html).
    Binding not assignment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How types work with functions](how-types-work-with-functions.html). Understanding
    the type notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Currying](currying.html). Breaking multi-parameter functions into smaller
    one-parameter functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partial application](partial-application.html). Baking-in some of the parameters
    of a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function associativity and composition](function-composition.html). Building
    new functions from existing ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining functions](defining-functions.html). Lambdas and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function signatures](function-signatures.html). A function signature can give
    you some idea of what it does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Organizing functions](organizing-functions.html). Nested functions and modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Attaching functions to types](type-extensions.html). Creating methods the
    F# way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Worked example: A stack based calculator](stack-based-calculator.html). Using
    combinators to build functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thinking Functionally: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thinking Functionally: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen some of the power of F# in the ["why use F#"](why-use-fsharp.html)
    series, we're going to step back and look at the fundamentals of functional programming
    -- what does it really mean to "program functionally", and how this approach is
    different from object oriented or imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the way you think
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to understand that functional programming is not just a stylistic
    difference; it is a completely different way of thinking about programming, in
    the way that truly object-oriented programming (in Smalltalk say) is also a different
    way of thinking from a traditional imperative language such as C.
  prefs: []
  type: TYPE_NORMAL
- en: 'F# does allow non-functional styles, and it is tempting to retain the habits
    you already are familiar with. You could just use F# in a non-functional way without
    really changing your mindset, and not realize what you are missing. To get the
    most out of F#, and to be fluent and comfortable with functional programming in
    general, it is critical that you think functionally, not imperatively. And that
    is the goal of this series: to help you understand functional programming in a
    deep way, and help to change the way you think.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be a quite abstract series, although I will use lots of short code
    examples to demonstrate the points. We will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mathematical functions**. The first post introduces the mathematical ideas
    behind functional languages, and the benefits that come from this approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions and values**. The next post introduces functions and values, showing
    how "values" are different from variables, and why there are similarities between
    function and simple values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Types**. Then we move on to the basic types that work with functions: primitive
    types such as string and int; the unit type, function types, and generic types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions with multiple parameters**. Next, I explain the concepts of "currying"
    and "partial application". This is where your brain can start to hurt, if you
    are coming from an imperative background!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining functions**. Then some posts devoted to the many different ways
    to define and combine functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function signatures**. Then a important post on the critical topic of function
    signatures: what they mean and how to use them as an aid to understanding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organizing functions**. Once you know how to create functions, how can you
    organize them to make them available to the rest of your code?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematical functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The impetus behind functional programming comes from mathematics. Mathematical
    functions have a number of very nice features that functional languages try to
    emulate in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: So first, let's start with a mathematical function that adds 1 to a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What does this really mean? Well it seems pretty straightforward. It means that
    there is an operation that starts with a number, and adds one to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce some terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: The set of values that can be used as input to the function is called the *domain*.
    In this case, it could be the set of real numbers, but to make life simpler for
    now, let's restrict it to integers only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of possible output values from the function is called the *range* (technically,
    the image on the codomain). In this case, it is also the set of integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function is said to *map* the domain to the range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Functions_Add1.png)'
  prefs: []
  type: TYPE_IMG
- en: Here's how the definition would look in F#
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you type that into the F# interactive window (don''t forget the double semicolons)
    you will see the result (the "signature" of the function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at that output in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The overall meaning is "the function `add1` maps integers (the domain) onto
    integers (the range)".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"`add1`" is defined as a "val", short for "value". Hmmm? what does that mean?
    We''ll discuss values shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrow notation "`->`" is used to show the domain and range. In this case,
    the domain is the `int` type, and the range is also the `int` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also note that the type was not specified, yet the F# compiler guessed that
    the function was working with ints. (Can this be tweaked? Yes, as we'll see shortly).
  prefs: []
  type: TYPE_NORMAL
- en: Key properties of mathematical functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematical functions have some properties that are very different from the
    kinds of functions you are used to in procedural programming.
  prefs: []
  type: TYPE_NORMAL
- en: A function always gives the same output value for a given input value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function has no side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties provide some very powerful benefits, and so functional programming
    languages try to enforce these properties in their design as well. Let's look
    at each of them in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical functions always give the same output for a given input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In imperative programming, we think that functions "do" something or "calculate"
    something. A mathematical function does not do any calculation -- it is purely
    a mapping from input to output. In fact, another way to think of defining a function
    is simply as the set of all the mappings. For example, in a very crude way we
    could define the "`add1`" function (in C#) as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we can't have a case for every possible integer, but the principle
    is the same. You can see that absolutely no calculation is being done at all,
    just a lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical functions are free from side effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a mathematical function, the input and the output are logically two different
    things, both of which are predefined. The function does not change the input or
    the output -- it just maps a pre-existing input value from the domain to a pre-existing
    output value in the range.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, evaluating the function *cannot possibly have any effect on
    the input, or anything else for that matter*. Remember, evaluating the function
    is not actually calculating or manipulating anything; it is just a glorified lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 'This "immutability" of the values is subtle but very important. If I am doing
    mathematics, I do not expect the numbers to change underneath me when I add them!
    For example, if I have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I would not expect x to be changed by the adding of one to it. I would expect
    to get back a different number (y) and x would be left untouched. In the world
    of mathematics, the integers already exist as an unchangeable set, and the "add1"
    function simply defines a relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: The power of pure functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The kinds of functions which have repeatable results and no side effects are
    called "pure functions", and you can do some interesting things with them:'
  prefs: []
  type: TYPE_NORMAL
- en: They are trivially parallelizable. I could take all the integers from 1 to 1000,
    say, and given 1000 different CPUs, I could get each CPU to execute the "`add1`"
    function for the corresponding integer at the same time, safe in the knowledge
    that there was no need for any interaction between them. No locks, mutexes, semaphores,
    etc., needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I can use a function lazily, only evaluating it when I need the output. I can
    be sure that the answer will be the same whether I evaluate it now or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I only ever need to evaluate a function once for a certain input, and I can
    then cache the result, because I know that the same input always gives the same
    output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If I have a number of pure functions, I can evaluate them in any order I like.
    Again, it can't make any difference to the final result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So you can see that if we can create pure functions in a programming language,
    we immediately gain a lot of powerful techniques. And indeed you can do all these
    things in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen an example of parallelism in the ["why use F#?"](why-use-fsharp.html)
    series.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating functions lazily will be discussed in the ["optimization"](optimization.md)
    series.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching the results of functions is called "memoization" and will also be discussed
    in the ["optimization"](optimization.md) series.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not caring about the order of evaluation makes concurrent programming much easier,
    and doesn't introduce bugs when functions are reordered or refactored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Unhelpful" properties of mathematical functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematical functions also have some properties that seem not to be very helpful
    when used in programming.
  prefs: []
  type: TYPE_NORMAL
- en: The input and output values are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function always has exactly one input and one output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties are mirrored in the design of functional programming languages
    too. Let's look at each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: '**The input and output values are immutable**'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable values seem like a nice idea in theory, but how can you actually get
    any work done if you can't assign to variables in a traditional way?
  prefs: []
  type: TYPE_NORMAL
- en: I can assure you that this is not as much as a problem as you might think. As
    you work through this series, you'll see how this works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mathematical functions always have exactly one input and one output**'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the diagrams, there is always exactly one input and one
    output for a mathematical function. This is true for functional programming languages
    as well, although it may not be obvious when you first use them.
  prefs: []
  type: TYPE_NORMAL
- en: That seems like a big annoyance. How can you do useful things without having
    functions with two (or more) parameters?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it turns there is a way to do it, and what's more, it is completely transparent
    to you in F#. It is called "currying" and it deserves its own post, which is coming
    up soon.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, as you will later discover, these two "unhelpful" properties will turn
    out to be incredibly useful and a key part of what makes functional programming
    so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Function Values and Simple Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function Values and Simple Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the simple function again
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What does the "x" mean here? It means:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept some value from the input domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the name "x" to represent that value so that we can refer to it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process of using a name to represent a value is called "binding". The name
    "x" is "bound" to the input value.
  prefs: []
  type: TYPE_NORMAL
- en: So if we evaluate the function with the input 5 say, what is happening is that
    everywhere we see "x" in the original definition, we replace it with "5", sort
    of like search and replace in a word processor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that this is not assignment. "x" is not a "slot"
    or variable that is assigned to the value and can be assigned to another value
    later on. It is a onetime association of the name "x" with the value. The value
    is one of the predefined integers, and cannot change. And so, once bound, x cannot
    change either; once associated with a value, always associated with a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept is a critical part of thinking functionally: *there are no "variables",
    only values*.'
  prefs: []
  type: TYPE_NORMAL
- en: Function values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you think about this a bit more, you will see that the name "`add1`" itself
    is just a binding to "the function that adds one to its input". The function itself
    is independent of the name it is bound to.
  prefs: []
  type: TYPE_NORMAL
- en: When you type `let add1 x = x + 1` you are telling the F# compiler "every time
    you see the name "`add1`", replace it with the function that adds 1 to its input".
    "`add1`" is called a **function value**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see that the function is independent of its name, try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that "`add1`" and "`plus1`" are two names that refer ("bound to")
    to the same function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can always identify a function value because its signature has the standard
    form `domain -> range`. Here is a generic function value signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Simple values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine an operation that always returned the integer 5 and didn't have any
    input.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Functions_Const.png)'
  prefs: []
  type: TYPE_IMG
- en: This would be a "constant" operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'How would we write this in F#? We want to tell the F# compiler "every time
    you see the name `c`, replace it with 5". Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'which when evaluated, returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is no mapping arrow this time, just a single int. What's new is an equals
    sign with the actual value printed after it. The F# compiler knows that this binding
    has a known value which it will always return, namely the value 5\.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we've just defined a constant, or in F# terms, a simple value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can always tell a simple value from a function value because all simple
    values have a signature that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Simple values vs. function values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important to understand that in F#, unlike languages such as C#, there
    is very little difference between simple values and function values. They are
    both values which can be bound to names (using the same keyword `let`) and then
    passed around. And in fact, one of the key aspects of thinking functionally is
    exactly that: *functions are values that can be passed around as inputs to other
    functions*, as we will soon see.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a subtle difference between a simple value and a function
    value. A function always has a domain and range and must be "applied" to an argument
    to get a result. A simple value does not need to be evaluated after being bound.
    Using the example above, if we wanted to define a "constant function" that returns
    five we would have to use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature for these functions is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: More on unit, function syntax and anonymous functions later.
  prefs: []
  type: TYPE_NORMAL
- en: '"Values" vs. "Objects"'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a functional programming language like F#, most things are called "values".
    In an object-oriented language like C#, most things are called "objects". So what
    is the difference between a "value" and an "object"?
  prefs: []
  type: TYPE_NORMAL
- en: A value, as we have seen above, is just a member of a domain. The domain of
    ints, the domain of strings, the domain of functions that map ints to strings,
    and so on. In principle, values are immutable. And values do not have any behavior
    attached them.
  prefs: []
  type: TYPE_NORMAL
- en: An object, in a standard definition, is an encapsulation of a data structure
    with its associated behavior (methods). In general, objects are expected to have
    state (that is, be mutable), and all operations that change the internal state
    must be provided by the object itself (via "dot" notation).
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, even the primitive values have some object-like behavior. For example,
    you can dot into a string to get its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: But, in general, we will avoid using "object" for standard values in F#, reserving
    it to refer to instances of true classes, or other values that expose member methods.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standard naming rules are used for value and function names, basically, any
    alphanumeric string, including underscores. There are a couple of extras:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can put an apostrophe anywhere in a name, except the first character. So:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The final tick is often used to signal some sort of "variant" version of a
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: or define variants of existing keywords
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also put double backticks around any string to make a valid identifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You might want to use the double backtick trick sometimes:'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to use an identifier that is the same as a keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When trying to use natural language for business rules, unit tests, or BDD style
    executable specifications a la Cucumber.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Unlike C#, the naming convention for F# is that functions and values start with
    lowercase letters rather than uppercase (`camelCase` rather than `PascalCase`)
    unless designed for exposure to other .NET languages. Types and modules use uppercase
    however.
  prefs: []
  type: TYPE_NORMAL
- en: How types work with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How types work with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some understanding of functions, we'll look at how types work
    with functions, both as domains and ranges. This is just an overview; the series
    ["understanding F# types"](understanding-fsharp-types.html) will cover types in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to understand the type notation a bit more. We''ve seen that
    the arrow notation "`->`" is used to show the domain and range. So that a function
    signature always looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some example functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you evaluate that in the F# interactive window, you will see the signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`intToString` has a domain of `int` which it maps onto the range `string`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringToInt` has a domain of `string` which it maps onto the range `int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The possible primitive types are what you would expect: string, int, float,
    bool, char, byte, etc., plus many more derived from the .NET type system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more examples of functions using primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'and their signatures are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Type annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, the F# compiler correctly determined the types of
    the parameters and results. But this is not always the case. If you try the following
    code, you will get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The compiler does not know what type "x" is, and therefore does not know if
    "Length" is a valid method. In most cases, this can be fixed by giving the F#
    compiler a "type annotation" so that it knows which type to use. In the corrected
    version below, we indicate that the type of "x" is a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The parens around the `x:string` param are important. If they are missing, the
    compiler thinks that the return value is a string! That is, an "open" colon is
    used to indicate the type of the return value, as you can see in the example below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We're indicating that the x param is a string and the return value is an int.
  prefs: []
  type: TYPE_NORMAL
- en: Function types as parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function that takes other functions as parameters, or returns a function,
    is called a **higher-order function** (sometimes abbreviated as HOF). They are
    used as a way of abstracting out common behavior. These kinds of functions are
    extremely common in F#; most of the standard libraries use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function `evalWith5ThenAdd2`, which takes a function as a parameter,
    then evaluates the function with the value 5, and adds 2 to the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature of this function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the domain is `(int->int)` and the range is `int`. What does
    that mean? It means that the input parameter is not a simple value, but a function,
    and what's more is restricted only to functions that map `ints` to `ints`. The
    output is not a function, just an int.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '"`add1`" is a function that maps ints to ints, as we can see from its signature.
    So it is a valid parameter for the `evalWith5ThenAdd2` function. And the result
    is 8\.'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the special word "`it`" is used for the last thing that was evaluated;
    in this case the result we want. It's not a keyword, just a convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '"`times3`" is also a function that maps ints to ints, as we can see from its
    signature. So it is also a valid parameter for the `evalWith5ThenAdd2` function.
    And the result is 17.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the input is sensitive to the types. If our input function uses `floats`
    rather than `ints`, it will not work. For example, if we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluating this will give an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: meaning that the input function should have been an `int->int` function.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function value can also be the output of a function. For example, the following
    function will generate an "adder" function that adds using the input value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'which means that the generator takes an `int`, and creates a function (the
    "adder") that maps `ints` to `ints`. Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This creates two adder functions. The first generated function adds 1 to its
    input, and the second adds 2\. Note that the signatures are just as we would expect
    them to be.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And we can now use these generated functions in the normal way. They are indistinguishable
    from functions defined explicitly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using type annotations to constrain function types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the first example, we had the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this case F# could deduce that "`fn`" mapped `ints` to `ints`, so its signature
    would be `int->int`
  prefs: []
  type: TYPE_NORMAL
- en: But what is the signature of "fn" in this following case?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, "`fn`" is some kind of function that takes an int, but what does
    it return? The compiler can't tell. If you do want to specify the type of the
    function, you can add a type annotation for function parameters in the same way
    as for a primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you could also specify the return type instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Because the main function returns a string, the "`fn`" function is also constrained
    to return a string, so no explicit typing is required for "fn".
  prefs: []
  type: TYPE_NORMAL
- en: The "unit" type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When programming, we sometimes want a function to do something without returning
    a value. Consider the function "`printInt`", defined below. The function doesn't
    actually return anything. It just prints a string to the console as a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: So what is the signature for this function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: What is this "`unit`"?
  prefs: []
  type: TYPE_NORMAL
- en: Well, even if a function returns no output, it still needs a range. There are
    no "void" functions in mathematics-land. Every function must have some output,
    because a function is a mapping, and a mapping has to have something to map to!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Functions_Unit.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So in F#, functions like this return a special range called "`unit`". This
    range has exactly one value in it, called "`()`". You can think of `unit` and
    `()` as somewhat like "void" (the type) and "null" (the value) in C#. But unlike
    void/null, `unit` is a real type and `()` is a real value. To see this, evaluate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'and you will see the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Which means that the value "`whatIsThis`" is of type `unit` and has been bound
    to the value `()`
  prefs: []
  type: TYPE_NORMAL
- en: 'So, going back to the signature of "`printInt`", we can now understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This signature says: `printInt` has a domain of `int` which it maps onto nothing
    that we care about.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameterless functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we understand unit, can we predict its appearance in other contexts?
    For example, let''s try to create a reusable "hello world" function. Since there
    is no input and no output, we would expect it to have a signature `unit -> unit`.
    Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Not quite what we expected. "Hello world" is printed immediately and the result
    is not a function, but a simple value of type unit. As we saw earlier, we can
    tell that this is a simple value because it has a signature of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: So in this case, we see that `printHello` is actually a *simple value* with
    the value `()`. It's not a function that we can call again.
  prefs: []
  type: TYPE_NORMAL
- en: Why the difference between `printInt` and `printHello`? In the `printInt` case,
    the value could not be determined until we knew the value of the x parameter,
    so the definition was of a function. In the `printHello` case, there were no parameters,
    so the right hand side could be determined immediately. Which it was, returning
    the `()` value, with the side effect of printing to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a true reusable function that is parameterless by forcing the
    definition to have a unit argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'and to call it, we have to pass the `()` value as a parameter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Forcing unit types with the ignore function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases the compiler requires a unit type and will complain. For example,
    both of the following will be compiler errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To help in these situations, there is a special function `ignore` that takes
    anything and returns the unit type. The correct version of this code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Generic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many cases, the type of the function parameter can be any type, so we need
    a way to indicate this. F# uses the .NET generic type system for this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following function converts the parameter to a string and
    appends some text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't matter what type the parameter is, as all objects understand `ToString()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'What is this type called `''a`? That is F#''s way of indicating a generic type
    that is not known at compile time. The apostrophe in front of the "a" means that
    the type is generic. The signature for the C# equivalent of this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note that the F# function is still strongly typed with a generic type. It does
    *not* take a parameter of type `Object`. This strong typing is desirable so that
    when functions are composed together, type safety is still maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the same function being used with an int, a float and a string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are two generic parameters, the compiler will give them different
    names: `''a` for the first generic, `''b` for the second generic, and so on. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The type signature for this has two generics: `''a` and `''b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the compiler will recognize when only one generic type is
    required. In the following example, the x and y parameters must be of the same
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'So the function signature has the same generic type for both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Generic parameters are also very important when it comes to lists and more abstract
    structures, and we will be seeing them a lot in upcoming examples.
  prefs: []
  type: TYPE_NORMAL
- en: Other types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The types discussed so far are just the basic types. These types can be combined
    in various ways to make much more complex types. A full discussion of these types
    will have to wait for [another series](understanding-fsharp-types.html), but meanwhile,
    here is a brief introduction to them so that you can recognize them in function
    signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '**The "tuple" types**. These are pairs, triples, etc., of other types. For
    example `("hello", 1)` is a tuple made from a string and an int. The comma is
    the distinguishing characteristic of a tuple -- if you see a comma in F#, it is
    almost certainly part of a tuple!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In function signatures, tuples are written as the "multiplication" of the two
    types involved. So in this case, the tuple would have type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**The collection types**. The most common of these are lists, sequences, and
    arrays. Lists and arrays are fixed size, while sequences are potentially infinite
    (behind the scenes, sequences are the same as `IEnumerable`). In function signatures,
    they have their own keywords: "`list`", "`seq`", and "`[]`" for arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**The option type**. This is a simple wrapper for objects that might be missing.
    There are two cases: `Some` and `None`. In function signatures, they have their
    own "`option`" keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '**The discriminated union type**. These are built from a set of choices of
    other types. We saw some examples of this in the ["why use F#?"](why-use-fsharp.html)
    series. In function signatures, they are referred to by the name of the type,
    so there is no special keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The record type**. These are like structures or database rows, a list of
    named slots. We saw some examples of this in the ["why use F#?"](why-use-fsharp.html)
    series as well. In function signatures, they are referred to by the name of the
    type, so again there is no special keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your understanding of types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How well do you understand the types yet? Here are some expressions for you
    -- see if you can guess their signatures. To see if you are correct, just run
    them in the interactive window!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After that little digression on basic types, we can turn back to functions
    again, and in particular the puzzle we mentioned earlier: if a mathematical function
    can only have one parameter, then how is it possible that an F# function can have
    more than one?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is quite simple: a function with multiple parameters is rewritten
    as a series of new functions, each with only one parameter. And this is done automatically
    by the compiler for you. It is called "**currying**", after Haskell Curry, a mathematician
    who was an important influence on the development of functional programming.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works in practice, let''s use a very basic example that prints
    two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, the compiler rewrites it as something more like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Construct the function called "`printTwoParameters`" but with only *one* parameter:
    "x"'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside that, construct a subfunction that has only *one* parameter: "y". Note
    that this inner function uses the "x" parameter but x is not passed to it explicitly
    as a parameter. The "x" parameter is in scope, so the inner function can see it
    and use it without needing it to be passed in.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, return the newly created subfunction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This returned function is then later used against "y". The "x" parameter is
    baked into it, so the returned function only needs the y param to finish off the
    function logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By rewriting it this way, the compiler has ensured that every function has
    only one parameter, as required. So when you use "`printTwoParameters`", you might
    think that you are using a two parameter function, but it is actually only a one
    parameter function! You can see for yourself by passing only one argument instead
    of two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If you evaluate it with one argument, you don't get an error, you get back a
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what you are really doing when you call `printTwoParameters` with two arguments
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: You call `printTwoParameters` with the first argument (x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printTwoParameters` returns a new function that has "x" baked into it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You then call the new function with the second argument (y)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an example of the step by step version, and then the normal version
    again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Again, the "two parameter function" is actually a one parameter function that
    returns an intermediate function.
  prefs: []
  type: TYPE_NORMAL
- en: But wait a minute -- what about the "`+`" operation itself? It's a binary operation
    that must take two parameters, surely? No, it is curried like every other function.
    There is a function called "`+`" that takes one parameter and returns a new intermediate
    function, exactly like `addTwoParameters` above.
  prefs: []
  type: TYPE_NORMAL
- en: When we write the statement `x+y`, the compiler reorders the code to remove
    the infix and turns it into `(+) x y`, which is the function named `+` called
    with two parameters. Note that the function named "+" needs to have parentheses
    around it to indicate that it is being used as a normal function name rather than
    as an infix operator.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the two parameter function named `+` is treated as any other two parameter
    function would be.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: And yes, this works for all other operators and built in functions like printf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Signatures of curried functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how curried functions work, what should we expect their signatures
    to look like?
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the first example, "`printTwoParameters`", we saw that it took
    one argument and returned an intermediate function. The intermediate function
    also took one argument and returned nothing (that is, unit). So the intermediate
    function has type `int->unit`. In other words, the domain of `printTwoParameters`
    is `int` and the range is `int->unit`. Putting this together we see that the final
    signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If you evaluate the explicitly curried implementation, you will see the parentheses
    in the signature, as written above, but if you evaluate the normal implementation,
    which is implicitly curried, the parentheses are left off, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses are optional. If you are trying to make sense of function signatures
    it might be helpful to add them back in mentally.
  prefs: []
  type: TYPE_NORMAL
- en: At this point you might be wondering, what is the difference between a function
    that returns an intermediate function and a regular two parameter function?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a one parameter function that returns a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a two parameter function that returns a simple value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The signatures are slightly different, but in practical terms, there *is* no
    difference*, only that the second function is automatically curried for you.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with more than two parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How does currying work for functions with more than two parameters? Exactly
    the same way: for each parameter except the last one, the function returns an
    intermediate function with the previous parameters baked in.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider this contrived example. I have explicitly specified the types of the
    parameters, but the function itself does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature of the overall function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'and the signatures of the intermediate functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'A function signature can tell you how many parameters the function takes: just
    count the number of arrows outside of parentheses. If the function takes or returns
    other function parameters, there will be other arrows in parentheses, but these
    can be ignored. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Issues with multiple parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logic behind currying can produce some unexpected results until you understand
    it. Remember that you will not get an error if you evaluate a function with fewer
    arguments than it is expecting. Instead you will get back a partially applied
    function. If you then go on to use this partially applied function in a context
    where you expect a value, you will get obscure error messages from the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an innocuous looking function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'What would you expect to happen when we call it as shown below? Will it print
    "hello" to the console? Try to guess before evaluating it, and here''s a hint:
    be sure to take a look at the function signature.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: It will *not* be called as expected. The original function expects a unit argument
    that was not supplied, so you are getting a partially applied function (in this
    case with no arguments).
  prefs: []
  type: TYPE_NORMAL
- en: How about this? Will it compile?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: If you evaluate it, you will see that the compiler complains about the printfn
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: If you didn't understand currying, this message would be very cryptic! All expressions
    that are evaluated standalone like this (i.e. not used as a return value or bound
    to something with "let") *must* evaluate to the unit value. And in this case,
    it is does *not* evaluate to the unit value, but instead evaluates to a function.
    This is a long winded way of saying that `printfn` is missing an argument.
  prefs: []
  type: TYPE_NORMAL
- en: A common case of errors like this is when interfacing with the .NET library.
    For example, the `ReadLine` method of a `TextReader` must take a unit parameter.
    It is often easy to forget this and leave off the parens, in which case you do
    not get a compiler error immediately, but only when you try to treat the result
    as a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, `line1` is just a pointer or delegate to the `Readline` method,
    not the string that we expected. The use of `()` in `reader.ReadLine()` actually
    executes the function.
  prefs: []
  type: TYPE_NORMAL
- en: Too many parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can get similar cryptic messages when you have too many parameters as well.
    Here are some examples of passing too many parameters to printf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: For example, in the last case, the compiler is saying that it expects the format
    argument to have three parameters (the signature `'a -> 'b -> 'c -> 'd` has three
    parameters) but it is given only two (the signature `'a -> 'b -> unit` has two
    parameters).
  prefs: []
  type: TYPE_NORMAL
- en: In cases not using `printf`, passing too many parameters will often mean that
    you end up with a simple value that you then try to pass a parameter to. The compiler
    will complain that the simple value is not a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: If you break the call into a series of explicit intermediate functions, as we
    did earlier, you can see exactly what is going wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous post on currying, we looked at breaking multiple parameter functions
    into smaller one parameter functions. It is the mathematically correct way of
    doing it, but that is not the only reason it is done -- it also leads to a very
    powerful technique called **partial function application**. This is a very widely
    used style in functional programming, and it is important to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of partial application is that if you fix the first N parameters of
    the function, you get a function of the remaining parameters. From the discussion
    on currying, you can probably see how this comes about naturally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some simple examples that demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: In each case, we create a partially applied function that we can then reuse
    in multiple contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partial application can just as easily involve fixing function parameters,
    of course. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The following more complex example shows how the same approach can be used to
    create "plug in" behavior that is transparent.
  prefs: []
  type: TYPE_NORMAL
- en: We create a function that adds two numbers, but in addition takes a logging
    function that will log the two numbers and the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The logging function has two parameters: (string) "name" and (generic) "value",
    so it has signature `string->''a->unit`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create various implementations of the logging function, such as a console
    logger or a popup logger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally we partially apply the main function to create new functions that
    have a particular logger baked into them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: These functions with the logger baked in can in turn be used like any other
    function. For example, we can create a partial application to add 42, and then
    pass that into a list function, just like we did for the simple "`add42`" function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: These partially applied functions are a very useful tool. We can create library
    functions which are flexible (but complicated), yet make it easy to create reusable
    defaults so that callers don't have to be exposed to the complexity all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Designing functions for partial application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see that the order of the parameters can make a big difference in the
    ease of use for partial application. For example, most of the functions in the
    `List` library such as `List.map` and `List.filter` have a similar form, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The list is always the last parameter. Here are some examples of the full form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'And the same examples using partial application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: If the library functions were written with the parameters in a different order,
    it would be much more inconvenient to use them with partial application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you write your own multi-parameter functions, you might wonder what the
    best parameter order is. As with all design questions, there is no "right" answer
    to this question, but here are some commonly accepted guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put earlier: parameters more likely to be static'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put last: the data structure or collection (or most varying argument)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For well-known operations such as "subtract", put in the expected order
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Guideline 1 is straightforward. The parameters that are most likely to be "fixed"
    with partial application should be first. We saw this with the logger example
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Guideline 2 makes it easier to pipe a structure or collection from function
    to function. We have seen this many times already with list functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, partially applied list functions are easy to compose, because the
    list parameter itself can be easily elided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping BCL functions for partial application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The .NET base class library functions are easy to access in F#, but are not
    really designed for use with a functional language like F#. For example, most
    functions have the data parameter first, while with F#, as we have seen, the data
    parameter should normally come last.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is easy enough to create wrappers for them that are more idiomatic.
    For example, in the snippet below, the .NET string functions are rewritten to
    have the string target be the last parameter rather than the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the string becomes the last parameter, we can then use them with pipes
    in the expected way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'or with function composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the "pipe" function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have seen how partial application works, you should be able to
    understand how the "pipe" function works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipe function is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: All it does is allow you to put the function argument in front of the function
    rather than after. That's all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function has multiple parameters, then it appears that the input is
    the final parameter. Actually what is happening is that the function is partially
    applied, returning a function that has a single parameter: the input'
  prefs: []
  type: TYPE_NORMAL
- en: Here's the same example rewritten to use partial application
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have already seen, the pipe operator is extremely common in F#, and
    used all the time to preserve a natural flow. Here are some more usages that you
    might see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The reverse pipe function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might occasionally see the reverse pipe function "<|" being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: It seems that this function doesn't really do anything different from normal,
    so why does it exist?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that, when used in the infix style as a binary operator, it reduces
    the need for parentheses and can make the code cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: You can also use piping in both directions at once to get a pseudo infix notation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Function associativity and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function associativity and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have a chain of functions in a row, how are they combined?
  prefs: []
  type: TYPE_NORMAL
- en: For example, what does this mean?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Does it mean apply the function y to the argument z, and then take the result
    and use it as an argument for x? In which case it is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Or does it mean apply the function x to the argument y, and then take the resulting
    function and evaluate it with the argument z? In which case it is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The answer is the latter. Function application is *left associative*. That is,
    evaluating `x y z` is the same as evaluating `(x y) z`. And evaluating `w x y
    z` is the same as evaluating `((w x) y) z`. This should not be a surprise. We
    have already seen that this is how partial application works. If you think of
    x as a two parameter function, then `(x y) z` is the result of partial application
    of the first parameter, followed by passing the z argument to the intermediate
    function.
  prefs: []
  type: TYPE_NORMAL
- en: If you do want to do right association, you can use explicit parentheses, or
    you can use a pipe. The following three forms are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, work out the signatures for these functions without actually
    evaluating them!
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've mentioned function composition a number of times in passing now, but what
    does it actually mean? It can seem quite intimidating at first, but it is actually
    quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Say that you have a function "f" that maps from type "T1" to type "T2", and
    say that you also have a function "g" that maps from type "T2" to type "T3". Then
    you can connect the output of "f" to the input of "g", creating a new function
    that maps from type "T1" to type "T3".
  prefs: []
  type: TYPE_NORMAL
- en: '![](Functions_Composition.png)'
  prefs: []
  type: TYPE_IMG
- en: Here's an example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: We can create a new function h that takes the output of "f" and uses it as the
    input for "g".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'A much more compact way is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: So far, so straightforward. What is interesting is that we can define a new
    function called "compose" that, given functions "f" and "g", combines them in
    this way without even knowing their signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'If you evaluate this, you will see that the compiler has correctly deduced
    that if "`f`" is a function from generic type `''a` to generic type `''b`, then
    "`g`" is constrained to have generic type `''b` as an input. And the overall signature
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: (Note that this generic composition operation is only possible because every
    function has one input and one output. This approach would not be possible in
    a non-functional language.)
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the actual definition of compose uses the "`>>`" symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Given this definition, we can now use composition to build new functions from
    existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: This explicit style is quite cluttered. We can do a few things to make it easier
    to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can leave off the x parameter so that the composition operator returns
    a partial application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: And now we have a binary operation, so we can put the operator in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: And there you have it. Using the composition operator allows code to be cleaner
    and more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Using the composition operator in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composition operator (like all infix operators) has lower precedence than
    normal function application. This means that the functions used in composition
    can have arguments without needing to use parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the "add" and "times" functions have an extra parameter, this
    can be passed in during the composition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as the inputs and outputs match, the functions involved can use any
    kind of value. For example, consider the following, which performs a function
    twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Note that the compiler has deduced that the function f must use the same type
    for both input and output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider a function like "`+`". As we have seen earlier, the input is an
    `int`, but the output is actually a partially applied function `(int->int)`. The
    output of "`+`" can thus be used as the input of "`twice`". So we can write something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can''t write something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: because the input to "*" must be an `int` value, not an `int->int` function
    (which is what the output of addition is).
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we tweak it so that the first function has an output of just `int` instead,
    then it does work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Composition can also be done backwards using the "`<<`" operator, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Reverse composition is mainly used to make code more English-like. For example,
    here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Composition vs. pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you might be wondering what the difference is between the composition
    operator and the pipeline operator, as they can seem quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s look again at the definition of the pipeline operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: All it does is allow you to put the function argument in front of the function
    rather than after. That's all. If the function has multiple parameters, then the
    input would be the final parameter. Here's the example used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Composition is not the same thing and cannot be a substitute for a pipe. In
    the following case the number 3 is not even a function, so its "output" cannot
    be fed into `doSomething`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The compiler is complaining that "3" should be some sort of function `'a->'b`.
  prefs: []
  type: TYPE_NORMAL
- en: Compare this with the definition of composition, which takes 3 arguments, where
    the first two must be functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Trying to use a pipe instead doesn't work. In the following example, "`add 1`"
    is a (partial) function of type `int->int`, and cannot be used as the second parameter
    of "`times 2`".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The compiler is complaining that "`times 2`" should take an `int->int` parameter,
    that is, be of type `(int->int)->'a`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how to create typical functions using the "let" syntax, below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we'll look at some other ways of creating functions, and tips
    for defining functions.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions (a.k.a. lambdas)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are familiar with lambdas in other languages, this will not be new to
    you. An anonymous function (or "lambda expression") is defined using the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are used to lambdas in C# there are a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: the lambda must have the special keyword `fun`, which is not needed in the C#
    version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the arrow symbol is a single arrow `->` rather than the double arrow (`=>`)
    in C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a lambda that defines addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same as a more conventional function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Lambdas are often used when you have a short expression and you don't want to
    define a function just for that expression. This is particularly common with list
    operations, as we have seen already.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Note that you must use parentheses around the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas are also used when you want to make it clear that you are returning
    a function from another function. For example, the "`adderGenerator`" function
    that we talked about earlier could be rewritten with a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The lambda version is slightly longer, but makes it clear that an intermediate
    function is being returned.
  prefs: []
  type: TYPE_NORMAL
- en: You can nest lambdas as well. Here is yet another definition of `adderGenerator`,
    this time using lambdas only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Can you see that all three of the following definitions are the same thing?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: If you can't see it, then do reread the [post on currying](currying.html). This
    is important stuff to understand!
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching on parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When defining a function, you can pass an explicit parameter, as we have seen,
    but you can also pattern match directly in the parameter section. In other words,
    the parameter section can contain *patterns*, not just identifiers!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to use patterns in a function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This kind of matching can only occur when the matching is always possible. For
    example, you cannot match on union types or lists this way, because some cases
    might not be matched.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: You will get a warning about incomplete pattern matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common mistake: tuples vs. multiple parameters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you come from a C-like language, a tuple used as a single function parameter
    can look awfully like multiple parameters. They are not the same thing at all!
    As I noted earlier, if you see a comma, it is probably part of a tuple. Parameters
    are separated by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The first definition, "`addTwoParams`", takes two parameters, separated with
    spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second definition, "`addTuple`", takes a single parameter. It then binds
    "x" and "y" to the inside of the tuple and does the addition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third definition, "`addConfusingTuple`", takes a single parameter just like
    "`addTuple`", but the tricky thing is that the tuple is unpacked and bound as
    part of the parameter definition using pattern matching. Behind the scenes, it
    is exactly the same as "`addTuple`".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the signatures (it is always a good idea to look at the signatures
    if you are unsure)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see an error occur in the second case above.
  prefs: []
  type: TYPE_NORMAL
- en: First, the compiler treats `(1,2)` as a generic tuple of type `('a * 'b)`, which
    it attempts to pass as the first parameter to "`addTwoParams`". Then it complains
    that the first parameter of `addTwoParams` is an `int`, and we're trying to pass
    a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a tuple, use a comma! Here''s how to do it correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, if you attempt to pass multiple arguments to a function expecting
    a tuple, you will also get an obscure error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the compiler thinks that, since you are passing two arguments,
    `addConfusingTuple` must be curryable. So then "`addConfusingTuple 1`" would be
    a partial application that returns another intermediate function. Trying to apply
    that intermediate function with "2" gives an error, because there is no intermediate
    function! We saw this exact same error in the post on currying, when we discussed
    the issues that can occur from having too many parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Why not use tuples as parameters?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The discussion of the issues with tuples above shows that there''s another
    way to define functions with more than one parameter: rather than passing them
    in separately, all the parameters can be combined into a single composite data
    structure. In the example below, the function takes a single parameter, which
    is a tuple containing three items.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Note that the function signature is different from a true three parameter function.
    There is only one arrow, so only one parameter, and the stars indicate that this
    is a tuple of `(int*int*int)`.
  prefs: []
  type: TYPE_NORMAL
- en: When would we want to use tuple parameters instead of individual ones?
  prefs: []
  type: TYPE_NORMAL
- en: When the tuples are meaningful in themselves. For example, if we are working
    with three dimensional coordinates, a three-tuple might well be more convenient
    than three separate dimensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples are occasionally used to bundle data together in a single structure that
    should be kept together. For example, the `TryParse` functions in .NET library
    return the result and a Boolean as a tuple. But if you have a lot of data that
    is kept together as a bundle, then you will probably want to define a record or
    class type to store it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A special case: tuples and .NET library functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One area where commas are seen a lot is when calling .NET library functions!
  prefs: []
  type: TYPE_NORMAL
- en: 'These all take tuple-like arguments, and so these calls look just the same
    as they would from C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that .NET library functions are not curried and cannot be partially
    applied. *All* the parameters must *always* be passed in, and using a tuple-like
    approach is the obvious way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'But do note that although these calls look like tuples, they are actually a
    special case. Real tuples cannot be used, so the following code is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do want to partially apply .NET library functions, it is normally trivial
    to write wrapper functions for them, as we have [seen earlier](partial-application.html),
    and as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Guidelines for separate vs. grouped parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The discussion on tuples leads us to a more general topic: when should function
    parameters be separate and when should they be grouped?'
  prefs: []
  type: TYPE_NORMAL
- en: Note that F# is different from C# in this respect. In C# *all* the parameters
    are *always* provided, so the question does not even arise! In F#, due to partial
    application, only some parameters might be provided, so you need to distinguish
    between those that are required to be grouped together vs. those that are independent.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some general guidelines of how to structure parameters when you are
    designing your own functions.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is always better to use separate parameters rather than passing
    them as a single structure such as a tuple or record. This allows for more flexible
    behavior such as partial application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, when a group of parameters *must* all be set at once, then *do* use some
    sort of grouping mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, when designing a function, ask yourself "could I provide this
    parameter in isolation?" If the answer is no, the parameters should be grouped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Finally, do be sure to order the parameters appropriately to assist with partial
    application (see the guidelines in the earlier [post](partial-application.html)).
    For example, in the last function above, why did I put the `myCredentials` parameter
    ahead of the `aName` parameter?
  prefs: []
  type: TYPE_NORMAL
- en: Parameter-less functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we may want functions that don't take any parameters at all. For example,
    we may want a "hello world" function that we can call repeatedly. As we saw in
    a previous section, the naive definition will not work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: The fix is to add a unit parameter to the function, or use a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'And then the function must always be called with a unit argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'This is particularly common with the .NET libraries. Some examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Do remember to call them with the unit parameter!
  prefs: []
  type: TYPE_NORMAL
- en: Defining new operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define functions named using one or more of the operator symbols (see
    the [F# documentation](http://msdn.microsoft.com/en-us/library/dd233204) for the
    exact list of symbols that you can use):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: You must use parentheses around the symbols when defining them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that for custom operators that begin with `*`, a space is required; otherwise
    the `(*` is interpreted as the start of a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Once defined, the new function can be used in the normal way, again with parens
    around the symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: If the function has exactly two parameters, you can use it as an infix operator
    without parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: You can also define prefix operators that start with `!` or `~` (with some restrictions
    -- see the [F# documentation on operator overloading](http://msdn.microsoft.com/en-us/library/dd233204#prefix))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: In F# it is quite common to create your own operators, and many libraries will
    export operators with names such as `>=>` and `<*>`.
  prefs: []
  type: TYPE_NORMAL
- en: Point-free style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen many examples of leaving off the last parameter of functions
    to reduce clutter. This style is referred to as **point-free style** or **tacit
    programming**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: There are pros and cons to this style.
  prefs: []
  type: TYPE_NORMAL
- en: On the plus side, it focuses attention on the high level function composition
    rather than the low level objects. For example "`(+) 1 >> (*) 2`" is clearly an
    addition operation followed by a multiplication. And "`List.reduce (+)`" makes
    it clear that the plus operation is key, without needing to know about the list
    it is actually applied to.
  prefs: []
  type: TYPE_NORMAL
- en: Point-free helps to clarify the underlying algorithm and reveal commonalities
    between code -- the "`reduce`" function used above is a good example of this --
    it will be discussed in a planned series on list processing.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, too much point-free style can make for confusing code. Explicit
    parameters can act as a form of documentation, and their names (such as "list")
    make it clear what the function is acting on.
  prefs: []
  type: TYPE_NORMAL
- en: As with anything in programming, the best guideline is to use the approach that
    provides the most clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word "**combinator**" is used to describe functions whose result depends
    only on their parameters. That means there is no dependency on the outside world,
    and in particular no other functions or global value can be accessed at all.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this means that a combinator function is limited to combining its
    parameters in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen some combinators already: the "pipe" operator and the
    "compose" operator. If you look at their definitions, it is clear that all they
    do is reorder the parameters in various ways'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, a function like "printf", although primitive, is not a combinator,
    because it has a dependency on the outside world (I/O).
  prefs: []
  type: TYPE_NORMAL
- en: Combinator birds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Combinators are the basis of a whole branch of logic (naturally called "combinatory
    logic") that was invented many years before computers and programming languages.
    Combinatory logic has had a very large influence on functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about combinators and combinatory logic, I recommend the book
    "To Mock a Mockingbird" by Raymond Smullyan. In it, he describes many other combinators
    and whimsically gives them names of birds. Here are some examples of some standard
    combinators and their bird names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The letter names are quite standard, so if you refer to "the K combinator",
    everyone will be familiar with that terminology.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that many common programming patterns can be represented using
    these standard combinators. For example, the Kestrel is a common pattern in fluent
    interfaces where you do something but then return the original object. The Thrush
    is the pipe operation, the Queer bird is forward composition, and the Y-combinator
    is famously used to make functions recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, there is a well-known theorem that states that any computable function
    whatsoever can be built from just two basic combinators, the Kestrel and the Starling.
  prefs: []
  type: TYPE_NORMAL
- en: Combinator libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A combinator library is a code library that exports a set of combinator functions
    that are designed to work together. The user of the library can then easily combine
    simple functions together to make bigger and more complex functions, like building
    with Lego.
  prefs: []
  type: TYPE_NORMAL
- en: A well designed combinator library allows you to focus on the high level operations,
    and push the low level "noise" to the background. We've already seen some examples
    of this power in the examples in ["why use F#"](why-use-fsharp.html) series, and
    the `List` module is full of them -- the "`fold`" and "`map`" functions are also
    combinators, if you think about it.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of combinators is that they are the safest type of function.
    As they have no dependency on the outside world they cannot change if the global
    environment changes. A function that reads a global value or uses a library function
    can break or alter between calls if the context is different. This can never happen
    with combinators.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, combinator libraries are available for parsing (the FParsec library),
    HTML construction, testing frameworks, and more. We'll discuss and use combinators
    further in later series.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, a function will need to refer to itself in its body. The classic example
    is the Fibonacci function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: You have to tell the compiler that this is a recursive function using the rec
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Recursive functions and data structures are extremely common in functional programming,
    and I hope to devote a whole later series to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Function signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It may not be obvious, but F# actually has two syntaxes - one for normal (value)
    expressions, and one for type definitions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Type expressions have a special syntax that is *different* from the syntax used
    in normal expressions. You have already seen many examples of this when you use
    the interactive session, because the type of each expression has been printed
    along with its evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, F# uses type inference to deduce types, so you don't often need
    to explicitly specify types in your code, especially for functions. But in order
    to work effectively in F#, you *do* need to understand the type syntax, so that
    you can build your own types, debug type errors, and understand function signatures.
    In this post, we'll focus on its use in function signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example function signatures using the type syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Understanding functions through their signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just by examining a function's signature, you can often get some idea of what
    it does. Let's look at some examples and analyze them in turn.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: This function takes two `int` parameters and returns another, so presumably
    it is some sort of mathematical function such as addition, subtraction, multiplication,
    or exponentiation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: This function takes an `int` and returns a `unit`, which means that the function
    is doing something important as a side-effect. Since there is no useful return
    value, the side effect is probably something to do with writing to IO, such as
    logging, writing to a file or database, or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: This function takes no input but returns a `string`, which means that the function
    is conjuring up a string out of thin air! Since there is no explicit input, the
    function probably has something to do with reading (from a file say) or generating
    (a random string, say).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: This function takes an `int` input and returns a function that when called,
    returns strings. Again, the function probably has something to do with reading
    or generating. The input probably initializes the returned function somehow. For
    example, the input could be a file handle, and the returned function something
    like `readline()`. Or the input could be a seed for a random string generator.
    We can't tell exactly, but we can make some educated guesses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a list of some type, but returns only one of that type,
    which means that the function is merging or choosing elements from the list. Examples
    of functions with this signature are `List.sum`, `List.max`, `List.head` and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two parameters: the first is a function that maps something
    to a bool (a predicate), and the second is a list. The return value is a list
    of the same type. Predicates are used to determine whether a value meets some
    sort of criteria, so it looks like the function is choosing elements from the
    list based on whether the predicate is true or not and then returning a subset
    of the original list. A typical function with this signature is `List.filter`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two parameters: the first maps type `''a` to type `''b`,
    and the second is a list of `''a`. The return value is a list of a different type
    `''b`. A reasonable guess is that the function takes each of the `''a`s in the
    list, maps them to a `''b` using the function passed in as the first parameter,
    and returns the new list of `''b`s. And indeed, the prototypical function with
    this signature is `List.map`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using function signatures to find a library method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function signatures are an important part of searching for library functions.
    The F# libraries have hundreds of functions in them and they can initially be
    overwhelming. Unlike an object oriented language, you cannot simply "dot into"
    an object to find all the appropriate methods. However, if you know the signature
    of the function you are looking for, you can often narrow down the list of candidates
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say you have two lists and you are looking for a function
    to combine them into one. What would the signature be for this function? It would
    take two list parameters and return a third, all of the same type, giving the
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go to the [MSDN documentation for the F# List module](http://msdn.microsoft.com/en-us/library/ee353738),
    and scan down the list of functions, looking for something that matches. As it
    happens, there is only one function with that signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: which is exactly the one we want!
  prefs: []
  type: TYPE_NORMAL
- en: Defining your own types for function signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you may want to create your own types to match a desired function
    signature. You can do this using the "type" keyword, and define the type in the
    same way that a signature is written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: You can then use these types to constrain function values and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the second definition below will fail because of type constraints.
    If you remove the type constraint (as in the third definition) there will not
    be any problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Test your understanding of function signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How well do you understand function signatures? See if you can create simple
    functions that have each of these signatures. Avoid using explicit type annotations!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Organizing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to define functions, how can you organize them?
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, there are three options:'
  prefs: []
  type: TYPE_NORMAL
- en: functions can be nested inside other functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: at an application level, the top level functions are grouped into "modules".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: alternatively, you can also use the object-oriented approach and attach functions
    to types as methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at the first two options in this post, and the third in the next
    post.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In F#, you can define functions inside other functions. This is a great way
    to encapsulate "helper" functions that are needed for the main function but shouldn't
    be exposed outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below `add` is nested inside `addThreeNumbers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: A nested function can access its parent function parameters directly, because
    they are in scope. So, in the example below, the `printError` nested function
    does not need to have any parameters of its own -- it can access the `n` and `max`
    values directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'A very common pattern is that the main function defines a nested recursive
    helper function, and then calls it with the appropriate initial values. The code
    below is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: When nesting functions, do try to avoid very deeply nested functions, especially
    if the nested functions directly access the variables in their parent scopes rather
    than having parameters passed to them. A badly nested function will be just as
    confusing as the worst kind of deeply nested imperative branching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how *not* to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A module is just a set of functions that are grouped together, typically because
    they work on the same data type or types.
  prefs: []
  type: TYPE_NORMAL
- en: A module definition looks very like a function definition. It starts with the
    `module` keyword, then an `=` sign, and then the contents of the module are listed.
    The contents of the module *must* be indented, just as expressions in a function
    definition must be indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a module that contains two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Now if you try this in Visual Studio, and you hover over the `add` function,
    you will see that the full name of the `add` function is actually `MathStuff.add`,
    just as if `MathStuff` was a class and `add` was a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, that''s exactly what is going on. Behind the scenes, the F# compiler
    creates a static class with static methods. So the C# equivalent would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: If you realize that modules are just static classes, and that functions are
    static methods, then you will already have a head-start on understanding how modules
    work in F#, as most of the rules that apply to static classes also apply to modules.
  prefs: []
  type: TYPE_NORMAL
- en: And, just as in C# every standalone function must be part of a class, in F#
    every standalone function *must* be part of a module.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing functions across module boundaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to access a function in another module, you can refer to it by its
    qualified name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: You can also import all the functions in another module with the `open` directive,
    after which you can use the short name, rather than having to specify the qualified
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The rules for using qualified names are exactly as you would expect. That is,
    you can always use a fully qualified name to access a function, and you can use
    relative names or unqualified names based on what other modules are in scope.
  prefs: []
  type: TYPE_NORMAL
- en: Nested modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like static classes, modules can contain child modules nested within them,
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'And other modules can reference functions in the nested modules using either
    a full name or a relative name as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Top level modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So if there can be nested child modules, that implies that, going back up the
    chain, there must always be some *top-level* parent module. This is indeed true.
  prefs: []
  type: TYPE_NORMAL
- en: Top level modules are defined slightly differently than the modules we have
    seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: The `module MyModuleName` line *must* be the first declaration in the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no `=` sign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of the module are *not* indented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, there must be a top level module declaration present in every `.FS`
    source file. There some exceptions, but it is good practice anyway. The module
    name does not have to be the same as the name of the file, but two files cannot
    share the same module name.
  prefs: []
  type: TYPE_NORMAL
- en: For `.FSX` script files, the module declaration is not needed, in which case
    the module name is automatically set to the filename of the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `MathStuff` declared as a top level module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Note the lack of indentation for the top level code (the contents of `module
    MathStuff`), but that the content of a nested module like `FloatLib` does still
    need to be indented.
  prefs: []
  type: TYPE_NORMAL
- en: Other module content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A module can contain other declarations as well as functions, including type
    declarations, simple values and initialization code (like static constructors)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: By the way, if you are playing with these examples in the interactive window,
    you might want to right-click and do "Reset Session" every so often, so that the
    code is fresh and doesn't get contaminated with previous evaluations
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's our example module again. Notice that `MathStuff` has an `add` function
    and `FloatLib` *also* has an `add` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Now what happens if I bring *both* of them into scope, and then use `add`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: What happened was that the `MathStuff.FloatLib` module has masked or overridden
    the original `MathStuff` module, which has been "shadowed" by `FloatLib`.
  prefs: []
  type: TYPE_NORMAL
- en: As a result you now get a [FS0001 compiler error](index5.html#FS0001) because
    the first parameter `1` is expected to be a float. You would have to change `1`
    to `1.0` to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is invisible and easy to overlook. Sometimes you can do
    cool tricks with this, almost like subclassing, but more often, it can be annoying
    if you have functions with the same name (such as the very common `map`).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want this to happen, there is a way to stop it by using the `RequireQualifiedAccess`
    attribute. Here's the same example where both modules are decorated with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `open` isn''t allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can still access the functions (without any ambiguity) via their qualified
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Access Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: F# supports the use of standard .NET access control keywords such as `public`,
    `private`, and `internal`. The [MSDN documentation](http://msdn.microsoft.com/en-us/library/dd233188)
    has the complete details.
  prefs: []
  type: TYPE_NORMAL
- en: These access specifiers can be put on the top-level ("let bound") functions,
    values, types and other declarations in a module. They can also be specified for
    the modules themselves (you might want a private nested module, for example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is public by default (with a few exceptions) so you will need to
    use `private` or `internal` if you want to protect them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These access specifiers are just one way of doing access control in F#. Another
    completely different way is to use module "signature" files, which are a bit like
    C header files. They describe the content of the module in an abstract way. Signatures
    are very useful for doing serious encapsulation, but that discussion will have
    to wait for the planned series on encapsulation and capability based security.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespaces in F# are similar to namespaces in C#. They can be used to organize
    modules and types to avoid name collisions.
  prefs: []
  type: TYPE_NORMAL
- en: A namespace is declared with a `namespace` keyword, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Because of this namespace, the fully qualified name of the `MathStuff` module
    now becomes `Utilities.MathStuff` and the fully qualified name of the `add` function
    now becomes `Utilities.MathStuff.add`.
  prefs: []
  type: TYPE_NORMAL
- en: With the namespace, the indentation rules apply, so that the module defined
    above must have its content indented, as it it were a nested module.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare a namespace implicitly by adding dots to the module name.
    That is, the code above could also be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The fully qualified name of the `MathStuff` module is still `Utilities.MathStuff`,
    but in this case, the module is a top-level module and the contents do not need
    to be indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional things to be aware of when using namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are optional for modules. And unlike C#, there is no default namespace
    for an F# project, so a top level module without a namespace will be at the global
    level. If you are planning to create reusable libraries, be sure to add some sort
    of namespace to avoid naming collisions with code in other libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces can directly contain type declarations, but not function declarations.
    As noted earlier, all function and value declarations must be part of a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, be aware that namespaces don't work well in scripts. For example, if
    you try to to send a namespace declaration such as `namespace Utilities` below
    to the interactive window, you will get an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace hierarchies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create a namespace hierarchy by simply separating the names with periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: And if you want to put *two* namespaces in the same file, you can. Note that
    all namespaces *must* be fully qualified -- there is no nesting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: One thing you can't do is have a naming collision between a namespace and a
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Mixing types and functions in modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that a module typically consists of a set of related functions that
    act on a data type.
  prefs: []
  type: TYPE_NORMAL
- en: In an object oriented program, the data structure and the functions that act
    on it would be combined in a class. However in functional-style F#, a data structure
    and the functions that act on it are combined in a module instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common patterns for mixing types and functions together:'
  prefs: []
  type: TYPE_NORMAL
- en: having the type declared separately from the functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: having the type declared in the same module as the functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first approach, the type is declared *outside* any module (but in a namespace)
    and then the functions that work on the type are put in a module with a similar
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'In the alternative approach, the type is declared *inside* the module and given
    a simple name such as "`T`" or the name of the module. So the functions are accessed
    with names like `MyModule.Func1` and `MyModule.Func2` while the type itself is
    accessed with a name like `MyModule.T`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Note that in both cases, you should have a constructor function that creates
    new instances of the type (a factory method, if you will), Doing this means that
    you will rarely have to explicitly name the type in your client code, and therefore,
    you not should not care whether it lives in the module or not!
  prefs: []
  type: TYPE_NORMAL
- en: So which approach should you choose?
  prefs: []
  type: TYPE_NORMAL
- en: The former approach is more .NET like, and much better if you want to share
    your libraries with other non-F# code, as the exported class names are what you
    would expect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter approach is more common for those used to other functional languages.
    The type inside a module compiles into nested classes, which is not so nice for
    interop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For yourself, you might want to experiment with both. And in a team programming
    situation, you should choose one style and be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Modules containing types only
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a set of types that you need to declare without any associated functions,
    don't bother to use a module. You can declare types directly in a namespace and
    avoid nested classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is how you might think to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: And here is a alternative way to do it. The `module` keyword has simply been
    replaced with `namespace`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, `PersonType` will have the same fully qualified name.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this only works with types. Functions must always live in a module.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching functions to types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attaching functions to types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have focused on the pure functional style so far, sometimes it is
    convenient to switch to an object oriented style. And one of the key features
    of the OO style is the ability to attach functions to a class and "dot into" the
    class to get the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, this is done using a feature called "type extensions". And any F# type,
    not just classes, can have functions attached to them.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example of attaching a function to a record type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'The key things to note are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `with` keyword indicates the start of the list of members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `member` keyword shows that this is a member function (i.e. a method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word `this` is a placeholder for the object that is being dotted into (called
    a "self-identifier"). The placeholder prefixes the function name, and then the
    function body then uses the same placeholder when it needs to refer to the current
    instance. There is no requirement to use a particular word, just as long as it
    is consistent. You could use `this` or `self` or `me` or any other word that commonly
    indicates a self reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You don''t have to add a member at the same time that you declare the type,
    you can always add it later in the same module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: These examples demonstrate what are called "intrinsic extensions". They are
    compiled into the type itself and are always available whenever the type is used.
    They also show up when you use reflection.
  prefs: []
  type: TYPE_NORMAL
- en: With intrinsic extensions, it is even possible to have a type definition that
    divided across several files, as long as all the components use the same namespace
    and are all compiled into the same assembly. Just as with partial classes in C#,
    this can be useful to separate generated code from authored code.
  prefs: []
  type: TYPE_NORMAL
- en: Optional extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another alternative is that you can add an extra member from a completely different
    module. These are called "optional extensions". They are not compiled into the
    type itself, and require some other module to be in scope for them to work (this
    behavior is just like C# extension methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we have a `Person` type defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'The example below demonstrates how to add an `UppercaseName` extension to it
    in a different module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'So now let''s test this extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Uh-oh, we have an error. What's wrong is that the `PersonExtensions` is not
    in scope. Just as for C#, any extensions have to be brought into scope in order
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we do that, everything is fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Extending system types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can extend types that are in the .NET libraries as well. But be aware that
    when extending a type, you must use the actual type name, not a type abbreviation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you try to extend `int`, you will fail, because `int` is not
    the true name of the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'You must use `System.Int32` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Static members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can make the member functions static by:'
  prefs: []
  type: TYPE_NORMAL
- en: adding the keyword `static`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dropping the `this` placeholder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can create static members for system types as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Attaching existing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very common pattern is to attach pre-existing standalone functions to a type.
    This has a couple of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: While developing, you can create standalone functions that refer to other standalone
    functions. This makes programming easier because type inference works much better
    with functional-style code than with OO-style ("dotting into") code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But for certain key functions, you can attach them to the type as well. This
    gives clients the choice of whether to use functional or object-oriented style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One example of this in the F# libraries is the function that calculates a list's
    length. It is available as a standalone function in the `List` module, but also
    as a method on a list instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: In the following example, we start with a type with no members initially, then
    define some functions, then finally attach the `fullName` function to the type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: The standalone `fullName` function has one parameter, the person. In the attached
    member, the parameter comes from the `this` self-reference.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching existing functions with multiple parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One nice thing is that when the previously defined function has multiple parameters,
    you don't have to respecify them all when doing the attachment, as long as the
    `this` parameter is first.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, the `hasSameFirstAndLastName` function has three parameters.
    Yet when we attach it, we only need to specify one!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'Why does this work? Hint: think about currying and partial application!'
  prefs: []
  type: TYPE_NORMAL
- en: Tuple-form methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we start having methods with more than one parameter, we have to make
    a decision:'
  prefs: []
  type: TYPE_NORMAL
- en: we could use the standard (curried) form, where parameters are separated with
    spaces, and partial application is supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we could pass in *all* the parameters at once, comma-separated, in a single
    tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "curried" form is more functional, and the "tuple" form is more object-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: The tuple form is also how F# interacts with the standard .NET libraries, so
    let's examine this approach in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a testbed, here is a Product type with two methods, each implemented using
    one of the approaches. The `CurriedTotal` and `TupleTotal` methods each do the
    same thing: work out the total price for a given quantity and discount.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s some test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: No difference so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that curried version can be partially applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'But the tuple approach can do a few things that that the curried one can''t,
    namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Named parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named parameters with tuple-style parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tuple-style approach supports named parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when names are used, the parameter order can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: if some parameters are named and some are not, the named ones must always
    be last.'
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters with tuple-style parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For tuple-style methods, you can specify an optional parameter by prefixing
    the parameter name with a question mark.
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter is set, it comes through as `Some value`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the parameter is not set, it comes through as `None`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: This explicit matching of the `None` and `Some` can be tedious, and there is
    a slightly more elegant solution for handling optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There is a function `defaultArg` which takes the parameter as the first argument
    and a default for the second argument. If the parameter is set, the value is returned.
    And if not, the default value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the same code rewritten to use `defaultArg`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Method overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C#, you can have multiple methods with the same name that differ only in
    their function signature (e.g. different parameter types and/or number of parameters)
  prefs: []
  type: TYPE_NORMAL
- en: In the pure functional model, that does not make sense -- a function works with
    a particular domain type and a particular range type. The same function cannot
    work with different domains and ranges.
  prefs: []
  type: TYPE_NORMAL
- en: However, F# *does* support method overloading, but only for methods (that is
    functions attached to types) and of these, only those using tuple-style parameter
    passing.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example, with yet another variant on the `TupleTotal` method!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Normally, the F# compiler would complain that there are two methods with the
    same name, but in this case, because they are tuple based and because their signatures
    are different, it is acceptable. (To make it obvious which one is being called,
    I have added a small debugging message.)
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Hey! Not so fast... The downsides of using methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are coming from an object-oriented background, you might be tempted
    to use methods everywhere, because that is what you are familiar with. But be
    aware that there some major downsides to using methods as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods don't play well with type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods don't play well with higher order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, by overusing methods you would be needlessly bypassing the most powerful
    and useful aspects of programming in F#.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what I mean.
  prefs: []
  type: TYPE_NORMAL
- en: Methods don't play well with type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back to our Person example again, the one that had the same logic
    implemented both as a standalone function and as a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see how well each one works with type inference. Say that I want to
    print the full name of a person, so I will define a function `printFullName` that
    takes a person as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the code using the module level standalone function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: This compiles without problems, and the type inference has correctly deduced
    that parameter was a person
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try the "dotted" version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: This does not compile at all, because the type inference does not have enough
    information to deduce the parameter. *Any* object might implement `.FullName`
    -- there is just not enough to go on.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we could annotate the function with the parameter type, but that defeats
    the whole purpose of type inference.
  prefs: []
  type: TYPE_NORMAL
- en: Methods don't play well with higher order functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A similar problem happens with higher order functions. For example, let's say
    that, given a list of people, we want to get all their full names.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a standalone function, this is trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'With object methods, we have to create special lambdas everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: And this is just a simple example. Object methods don't compose well, are hard
    to pipe, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: So, a plea for those of you new to functionally programming. Don't use methods
    at all if you can, especially when you are learning. They are a crutch that will
    stop you getting the full benefit from functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Worked example: A stack based calculator'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Worked example: A stack based calculator'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we'll implement a simple stack based calculator (also known as
    "reverse Polish" style). The implementation is almost entirely done with functions,
    with only one special type and no pattern matching at all, so it is a great testing
    ground for the concepts introduced in this series.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with a stack based calculator, it works as follows:
    numbers are pushed on a stack, and operations such as addition and multiplication
    pop numbers off the stack and push the result back on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram showing a simple calculation using a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack based calculator diagram](stack-based-calculator.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first steps to designing a system like this is to think about how it would
    be used. Following a Forth like syntax, we will give each action a label, so that
    the example above might want to be written something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: We might not be able to get this exact syntax, but let's see how close we can
    get.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we need to define the data structure for a stack. To keep things simple,
    we'll just use a list of floats.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'But, hold on, let''s wrap it in a [single case union type](discriminated-unions.html#single-case)
    to make it more descriptive, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: For more details on why this is nicer, read the discussion of single case union
    types in [this post](discriminated-unions.html#single-case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create a new stack, we use `StackContents` as a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'And to extract the contents of an existing Stack, we pattern match with `StackContents`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: The Push function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next we need a way to push numbers on to the stack. This will be simply be prepending
    the new value at the front of the list using the "`::`" operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our push function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: This basic function has a number of things worth discussing.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, note that the list structure is immutable, so the function must accept
    an existing stack and return a new stack. It cannot just alter the existing stack.
    In fact, all of the functions in this example will have a similar format like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Next, what should the order of the parameters be? Should the stack parameter
    come first or last? If you remember the discussion of [designing functions for
    partial application](partial-application), you will remember that the most changeable
    thing should come last. You'll see shortly that this guideline will be born out.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function can be made more concise by using pattern matching in
    the function parameter itself, rather than using a `let` in the body of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rewritten version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Much nicer!
  prefs: []
  type: TYPE_NORMAL
- en: 'And by the way, look at the nice signature it has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: As we know from a [previous post](function-signatures), the signature tells
    you a lot about the function. In this case, I could probably guess what it did
    from the signature alone, even without knowing that the name of the function was
    "push". This is one of the reasons why it is a good idea to have explicit type
    names. If the stack type had just been a list of floats, it wouldn't have been
    as self-documenting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, now let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Works great!
  prefs: []
  type: TYPE_NORMAL
- en: Building on top of "push"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this simple function in place, we can easily define an operation that pushes
    a particular number onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'But wait a minute! Can you see that the `stack` parameter is used on both sides?
    In fact, we don''t need to mention it at all. Instead we can skip the `stack`
    parameter and write the functions using partial application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Now you can see that if the parameters for `push` were in a different order,
    we wouldn't have been able to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s define a function that creates an empty stack as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test all of these now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'These intermediate stacks are annoying ? can we get rid of them? Yes! Note
    that these functions ONE, TWO, THREE all have the same signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that they can be chained together nicely! The output of one can
    be fed into the input of the next, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: Popping the stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That takes care of pushing onto the stack ? what about a `pop` function next?
  prefs: []
  type: TYPE_NORMAL
- en: When we pop the stack, we will return the top of the stack, obviously, but is
    that all?
  prefs: []
  type: TYPE_NORMAL
- en: In an object-oriented style, [the answer is yes](http://msdn.microsoft.com/en-us/library/system.collections.stack.pop.aspx).
    In an OO approach, we would *mutate* the stack itself behind the scenes, so that
    the top element was removed.
  prefs: []
  type: TYPE_NORMAL
- en: But in a functional style, the stack is immutable. The only way to remove the
    top element is to create a *new stack* with the element removed. In order for
    the caller to have access to this new diminished stack, it needs to be returned
    along with the top element itself.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the `pop` function will have to return *two* values, the top
    plus the new stack. The easiest way to do this in F# is just to use a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: This function is also very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we are extracting the `contents` directly in the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We then use a `match..with` expression to test the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we separate the top element from the rest, create a new stack from the
    remaining elements and finally return the pair as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Try the code above and see what happens. You will get a compiler error! The
    compiler has caught a case we have overlooked -- what happens if the stack is
    empty?
  prefs: []
  type: TYPE_NORMAL
- en: So now we have to decide how to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Return a special "Success" or "Error" state, as we did in a [post
    from the "why use F#?" series](correctness-exhaustive-pattern-matching.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Option 2: Throw an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, I prefer to use error cases, but in this case, we''ll use an exception.
    So here''s the `pop` code changed to handle the empty case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'and to test the underflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Writing the math functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now with both push and pop in place, we can work on the "add" and "multiply"
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Test these interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: It works!
  prefs: []
  type: TYPE_NORMAL
- en: Time to refactor...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is obvious that there is significant duplicate code between these two functions.
    How can we refactor?
  prefs: []
  type: TYPE_NORMAL
- en: 'Both functions pop two values from the stack, apply some sort of binary function,
    and then push the result back on the stack. This leads us to refactor out the
    common code into a "binary" function that takes a two parameter math function
    as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '*Note that in this implementation, I''ve switched to using ticks to represent
    changed states of the "same" object, rather than numeric suffixes. Numeric suffixes
    can easily get quite confusing.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Question: why are the parameters in the order they are, instead of `mathFn`
    being after `stack`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `binary`, we can define ADD and friends more simply:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a first attempt at ADD using the new `binary` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can eliminate the lambda, as it is *exactly* the definition of the built-in
    `+` function! Which gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, we can use partial application to hide the stack parameter. Here''s
    the final definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the definition of some other math functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Let's test interactively again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: In a similar fashion, we can create a helper function for unary functions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'And then define some unary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'Test interactively again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the original requirements, we mentioned that we wanted to be able to show
    the results, so let's define a SHOW function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this case, we pop the original stack but ignore the diminished
    version. The final result of the function is the original stack, as if it had
    never been popped.
  prefs: []
  type: TYPE_NORMAL
- en: So now finally, we can write the code example from the original requirements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Going further
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is fun -- what else can we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we can define a few more core helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'And with these additional functions in place, we can write some nice examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: Using composition instead of piping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But that's not all. In fact, there is another very interesting way to think
    about these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I pointed out earlier, they all have an identical signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: So, because the input and output types are the same, these functions can be
    composed using the composition operator `>>`, not just chained together with pipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: In each of these cases, a new function is defined by composing other functions
    together to make a new one. This is a good example of the "combinator" approach
    to building up functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes vs composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now seen two different ways that this stack based model can be used;
    by piping or by composition. So what is the difference? And why would we prefer
    one way over another?
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that piping is, in a sense, a "realtime transformation" operation.
    When you use piping you are actually doing the operations right now, passing a
    particular stack around.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, composition is a kind of "plan" for what you want to do,
    building an overall function from a set of parts, but *not* actually running it
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example, I can create a "plan" for how to square a number by combining
    smaller operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: I cannot do the equivalent with the piping approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'This causes a compilation error. I have to have some sort of concrete stack
    instance to make it work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: And even then, I only get the answer for this particular input, not a plan for
    all possible inputs, as in the COMPOSED_SQUARE example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to create a "plan" is to explicitly pass in a lambda to a more
    primitive function, as we saw near the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: This is much more explicit (and is likely to be faster) but loses all the benefits
    and clarity of the composition approach.
  prefs: []
  type: TYPE_NORMAL
- en: So, in general, go for the composition approach if you can!
  prefs: []
  type: TYPE_NORMAL
- en: The complete code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's the complete code for all the examples so far.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So there we have it, a simple stack based calculator. We've seen how we can
    start with a few primitive operations (`push`, `pop`, `binary`, `unary`) and from
    them, build up a whole domain specific language that is both easy to implement
    and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, this example is based heavily on the Forth language. I highly
    recommend the free book ["Thinking Forth"](http://thinking-forth.sourceforge.net/),
    which is not just about the Forth language, but about (*non* object-oriented!)
    problem decomposition techniques which are equally applicable to functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: I got the idea for this post from a great blog by [Ashley Feniello](http://blogs.msdn.com/b/ashleyf/archive/2011/04/21/programming-is-pointless.aspx).
    If you want to go deeper into emulating a stack based language in F#, start there.
    Have fun!
  prefs: []
  type: TYPE_NORMAL
