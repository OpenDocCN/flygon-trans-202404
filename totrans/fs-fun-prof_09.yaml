- en: The "Thinking Functionally" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “思考函数式”系列
- en: This series of posts will introduce you to the fundamentals of functional programming
    -- what does it really mean to "program functionally", and how this approach differs
    from object oriented or imperative programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列文章将介绍你函数式编程的基础知识——“函数式编程”到底意味着什么，以及这种方法与面向对象或命令式编程有何不同。
- en: '[Thinking Functionally: Introduction](thinking-functionally-intro.html). A
    look at the basics of functional programming.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[思考函数式：介绍](thinking-functionally-intro.html)。关于函数式编程基础的一瞥。'
- en: '[Mathematical functions](mathematical-functions.html). The impetus behind functional
    programming.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数学函数](mathematical-functions.html)。函数式编程的动力源。'
- en: '[Function Values and Simple Values](function-values-and-simple-values.html).
    Binding not assignment.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数值和简单值](function-values-and-simple-values.html)。绑定而非赋值。'
- en: '[How types work with functions](how-types-work-with-functions.html). Understanding
    the type notation.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型如何与函数配合工作](how-types-work-with-functions.html)。理解类型表示法。'
- en: '[Currying](currying.html). Breaking multi-parameter functions into smaller
    one-parameter functions.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[柯里化](currying.html)。将多参数函数分解为更小的单参数函数。'
- en: '[Partial application](partial-application.html). Baking-in some of the parameters
    of a function.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[部分应用](partial-application.html)。将函数的一些参数固定下来。'
- en: '[Function associativity and composition](function-composition.html). Building
    new functions from existing ones.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数的结合性和合成性](function-composition.html)。从现有函数构建新函数。'
- en: '[Defining functions](defining-functions.html). Lambdas and more.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义函数](defining-functions.html)。Lambda表达式和更多内容。'
- en: '[Function signatures](function-signatures.html). A function signature can give
    you some idea of what it does.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数签名](function-signatures.html)。函数签名可以让你对其功能有所了解。'
- en: '[Organizing functions](organizing-functions.html). Nested functions and modules.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[组织函数](organizing-functions.html)。嵌套函数和模块。'
- en: '[Attaching functions to types](type-extensions.html). Creating methods the
    F# way.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将函数附加到类型](type-extensions.html)。以F#的方式创建方法。'
- en: '[Worked example: A stack based calculator](stack-based-calculator.html). Using
    combinators to build functionality.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例演练：基于堆栈的计算器](stack-based-calculator.html)。使用组合子构建功能。'
- en: 'Thinking Functionally: Introduction'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考函数式：介绍
- en: 'Thinking Functionally: Introduction'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考函数式：介绍
- en: Now that you have seen some of the power of F# in the ["why use F#"](why-use-fsharp.html)
    series, we're going to step back and look at the fundamentals of functional programming
    -- what does it really mean to "program functionally", and how this approach is
    different from object oriented or imperative programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在["为什么使用F#"](why-use-fsharp.html)系列中看到了F#的一些威力，我们要退一步，看看函数式编程的基础知识——“函数式编程”到底意味着什么，以及这种方法与面向对象或命令式编程有何不同。
- en: Changing the way you think
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变你的思维方式
- en: It is important to understand that functional programming is not just a stylistic
    difference; it is a completely different way of thinking about programming, in
    the way that truly object-oriented programming (in Smalltalk say) is also a different
    way of thinking from a traditional imperative language such as C.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理解函数式编程的重要性不仅仅是一种风格上的差异；它是一种完全不同的编程思维方式，就像真正的面向对象编程（比如Smalltalk）也与传统的命令式语言如C有着不同的思考方式一样。
- en: 'F# does allow non-functional styles, and it is tempting to retain the habits
    you already are familiar with. You could just use F# in a non-functional way without
    really changing your mindset, and not realize what you are missing. To get the
    most out of F#, and to be fluent and comfortable with functional programming in
    general, it is critical that you think functionally, not imperatively. And that
    is the goal of this series: to help you understand functional programming in a
    deep way, and help to change the way you think.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: F#确实允许非函数式的风格，而且很容易保留你已经熟悉的习惯。你可以只是以非函数式的方式使用F#，而不真正改变你的思维方式，并且意识不到你所错过的东西。要充分利用F#，并且对函数式编程有流利和舒适的掌握，关键是你要以函数式的思维方式思考，而不是命令式的。这就是本系列的目标：帮助你深入理解函数式编程，并帮助改变你的思维方式。
- en: 'This will be a quite abstract series, although I will use lots of short code
    examples to demonstrate the points. We will cover the following points:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个相当抽象的系列，虽然我会用大量的短代码示例来演示这些观点。我们将涵盖以下几点：
- en: '**Mathematical functions**. The first post introduces the mathematical ideas
    behind functional languages, and the benefits that come from this approach.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学函数**。第一篇文章介绍了函数式语言背后的数学思想，以及从这种方法中获得的好处。'
- en: '**Functions and values**. The next post introduces functions and values, showing
    how "values" are different from variables, and why there are similarities between
    function and simple values.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数和值**。下一篇文章介绍了函数和值，展示了“值”与变量的不同之处，以及为什么函数和简单值之间存在相似之处。'
- en: '**Types**. Then we move on to the basic types that work with functions: primitive
    types such as string and int; the unit type, function types, and generic types.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**。然后我们转向与函数配合使用的基本类型：如字符串和整数等原始类型；单位类型、函数类型和泛型类型。'
- en: '**Functions with multiple parameters**. Next, I explain the concepts of "currying"
    and "partial application". This is where your brain can start to hurt, if you
    are coming from an imperative background!'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有多个参数的函数**。接下来，我将解释“柯里化”和“部分应用”的概念。如果你来自命令式编程背景，你的大脑可能会开始疼！'
- en: '**Defining functions**. Then some posts devoted to the many different ways
    to define and combine functions.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义函数**。然后是一些专门用于定义和组合函数的不同方式的帖子。'
- en: '**Function signatures**. Then a important post on the critical topic of function
    signatures: what they mean and how to use them as an aid to understanding.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数签名**。然后是一个关于函数签名的关键主题的重要帖子：它们的含义以及如何将它们用作理解的辅助工具。'
- en: '**Organizing functions**. Once you know how to create functions, how can you
    organize them to make them available to the rest of your code?'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织函数**。一旦你知道如何创建函数，你如何组织它们以使它们对你的代码的其余部分可用？'
- en: Mathematical functions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学函数
- en: Mathematical functions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学函数
- en: The impetus behind functional programming comes from mathematics. Mathematical
    functions have a number of very nice features that functional languages try to
    emulate in the real world.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的动力来自数学。数学函数具有许多非常好的特性，函数式语言试图在现实世界中模拟这些特性。
- en: So first, let's start with a mathematical function that adds 1 to a number.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先，让我们从一个数学函数开始，它将1加到一个数字。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What does this really mean? Well it seems pretty straightforward. It means that
    there is an operation that starts with a number, and adds one to it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这到底意味着什么？嗯，看起来相当直观。它意味着有一个以数字开始的操作，并将其加一。
- en: 'Let''s introduce some terminology:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一些术语：
- en: The set of values that can be used as input to the function is called the *domain*.
    In this case, it could be the set of real numbers, but to make life simpler for
    now, let's restrict it to integers only.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '可以用作函数输入的值的集合称为*定义域*。在这种情况下，它可以是实数集，但为了现在简化生活，让我们将其限制为仅整数。 '
- en: The set of possible output values from the function is called the *range* (technically,
    the image on the codomain). In this case, it is also the set of integers.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的可能输出值集合称为*值域*（技术上是定义域上的像）。在这种情况下，它也是整数的集合。
- en: The function is said to *map* the domain to the range.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数被称为*将*定义域映射到值域。
- en: '![](Functions_Add1.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Functions_Add1.png)'
- en: Here's how the definition would look in F#
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在 F# 中定义的方式：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you type that into the F# interactive window (don''t forget the double semicolons)
    you will see the result (the "signature" of the function):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它输入 F# 交互窗口（别忘了双分号），你会看到结果（函数的“签名”）：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s look at that output in detail:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下这个输出：
- en: The overall meaning is "the function `add1` maps integers (the domain) onto
    integers (the range)".
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体意义是“函数`add1`将整数（定义域）映射到整数（值域）”。
- en: '"`add1`" is defined as a "val", short for "value". Hmmm? what does that mean?
    We''ll discuss values shortly.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`add1`”被定义为“val”，缩写为“value”。嗯？那是什么意思？我们马上就会讨论值。
- en: The arrow notation "`->`" is used to show the domain and range. In this case,
    the domain is the `int` type, and the range is also the `int` type.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头符号“`->`”用于显示定义域和值域。在本例中，定义域是`int`类型，值域也是`int`类型。
- en: Also note that the type was not specified, yet the F# compiler guessed that
    the function was working with ints. (Can this be tweaked? Yes, as we'll see shortly).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，类型未指定，但 F# 编译器猜测函数正在使用整数。（这能调整吗？是的，我们马上会看到）。
- en: Key properties of mathematical functions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学函数的关键属性
- en: Mathematical functions have some properties that are very different from the
    kinds of functions you are used to in procedural programming.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数具有一些与过程式编程中您习惯的函数非常不同的特性。
- en: A function always gives the same output value for a given input value
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对于给定的输入值始终给出相同的输出值
- en: A function has no side effects.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数没有副作用。
- en: These properties provide some very powerful benefits, and so functional programming
    languages try to enforce these properties in their design as well. Let's look
    at each of them in turn.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性提供了一些非常强大的好处，因此函数式编程语言也试图在其设计中强制执行这些属性。让我们依次看看每一个。
- en: Mathematical functions always give the same output for a given input
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学函数对于给定的输入始终产生相同的输出。
- en: In imperative programming, we think that functions "do" something or "calculate"
    something. A mathematical function does not do any calculation -- it is purely
    a mapping from input to output. In fact, another way to think of defining a function
    is simply as the set of all the mappings. For example, in a very crude way we
    could define the "`add1`" function (in C#) as
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们认为函数“做”某事或“计算”某事。数学函数不做任何计算--它纯粹是从输入到输出的映射。事实上，定义函数的另一种方式是将所有映射定义为函数的集合。例如，在非常简单的情况下，我们可以将“`add1`”函数（在
    C# 中）定义为
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Obviously, we can't have a case for every possible integer, but the principle
    is the same. You can see that absolutely no calculation is being done at all,
    just a lookup.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们无法为每个可能的整数都有一个情况，但原则是相同的。您可以看到绝对没有进行任何计算，只是查找。
- en: Mathematical functions are free from side effects
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学函数没有副作用
- en: In a mathematical function, the input and the output are logically two different
    things, both of which are predefined. The function does not change the input or
    the output -- it just maps a pre-existing input value from the domain to a pre-existing
    output value in the range.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学函数中，输入和输出在逻辑上是两个不同的事物，两者都是预定义的。函数不会改变输入或输出--它只是将域中的预先存在的输入值映射到范围中的预先存在的输出值。
- en: In other words, evaluating the function *cannot possibly have any effect on
    the input, or anything else for that matter*. Remember, evaluating the function
    is not actually calculating or manipulating anything; it is just a glorified lookup.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，评估函数*绝对不可能对输入或其他任何事物产生任何影响*。请记住，评估函数实际上不是计算或操作任何内容；它只是一种华丽的查找。
- en: 'This "immutability" of the values is subtle but very important. If I am doing
    mathematics, I do not expect the numbers to change underneath me when I add them!
    For example, if I have:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值的“不可变性”微妙但非常重要。如果我在做数学运算，我不希望在我加它们时数字在我脚下改变！例如，如果我有：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I would not expect x to be changed by the adding of one to it. I would expect
    to get back a different number (y) and x would be left untouched. In the world
    of mathematics, the integers already exist as an unchangeable set, and the "add1"
    function simply defines a relationship between them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我不希望 x 被加一改变。我期望得到一个不同的数字（y），而 x 保持不变。在数学世界中，整数已经存在为一个不可改变的集合，而“add1”函数只是定义了它们之间的关系。
- en: The power of pure functions
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯函数的力量
- en: 'The kinds of functions which have repeatable results and no side effects are
    called "pure functions", and you can do some interesting things with them:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可重复结果且没有副作用的函数称为“纯函数”，您可以使用它们执行一些有趣的事情：
- en: They are trivially parallelizable. I could take all the integers from 1 to 1000,
    say, and given 1000 different CPUs, I could get each CPU to execute the "`add1`"
    function for the corresponding integer at the same time, safe in the knowledge
    that there was no need for any interaction between them. No locks, mutexes, semaphores,
    etc., needed.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以轻松并行化。我可以从 1 到 1000 中取所有整数，然后给定 1000 个不同的 CPU，我可以让每个 CPU 同时执行相应整数的“`add1`”函数，而无需担心它们之间需要任何交互。不需要锁定、互斥体、信号量等。
- en: I can use a function lazily, only evaluating it when I need the output. I can
    be sure that the answer will be the same whether I evaluate it now or later.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以懒惰地使用一个函数，只在需要输出时评估它。我可以确信，无论我现在还是以后评估它，答案都将是相同的。
- en: I only ever need to evaluate a function once for a certain input, and I can
    then cache the result, because I know that the same input always gives the same
    output.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于特定的输入，我只需要评估函数一次，然后我就可以缓存结果，因为我知道相同的输入总是产生相同的输出。
- en: If I have a number of pure functions, I can evaluate them in any order I like.
    Again, it can't make any difference to the final result.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我有一系列纯函数，我可以按任何顺序评估它们。同样，它对最终结果不会有任何影响。
- en: 'So you can see that if we can create pure functions in a programming language,
    we immediately gain a lot of powerful techniques. And indeed you can do all these
    things in F#:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到，如果我们可以在编程语言中创建纯函数，我们立即获得了许多强大的技术。事实上，您可以在 F# 中执行所有这些操作：
- en: You have already seen an example of parallelism in the ["why use F#?"](why-use-fsharp.html)
    series.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经在["为什么使用 F#？"](why-use-fsharp.html)系列中看到了并行性的一个例子。
- en: Evaluating functions lazily will be discussed in the ["optimization"](optimization.md)
    series.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性评估函数将在["优化"](optimization.md)系列中讨论。
- en: Caching the results of functions is called "memoization" and will also be discussed
    in the ["optimization"](optimization.md) series.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存函数的结果被称为“记忆化”，也将在["优化"](optimization.md)系列中讨论。
- en: Not caring about the order of evaluation makes concurrent programming much easier,
    and doesn't introduce bugs when functions are reordered or refactored.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不关心评估顺序使并发编程变得更容易，并且在函数重新排序或重构时不会引入错误。
- en: '"Unhelpful" properties of mathematical functions'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学函数的“不太有用”特性
- en: Mathematical functions also have some properties that seem not to be very helpful
    when used in programming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数在编程中使用时也有一些看起来不太有用的特性。
- en: The input and output values are immutable
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出值是不可变的
- en: A function always has exactly one input and one output
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数总是恰好有一个输入和一个输出
- en: These properties are mirrored in the design of functional programming languages
    too. Let's look at each of these in turn.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性也反映在函数式编程语言的设计中。让我们依次看看每一个。
- en: '**The input and output values are immutable**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入和输出值是不可变的**'
- en: Immutable values seem like a nice idea in theory, but how can you actually get
    any work done if you can't assign to variables in a traditional way?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，不可变值似乎是一个不错的想法，但如果你不能以传统方式分配变量，你怎么能完成任何工作呢？
- en: I can assure you that this is not as much as a problem as you might think. As
    you work through this series, you'll see how this works in practice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以向你保证，这并不像你想象的那么严重。当你逐步学习这个系列时，你会看到这在实践中是如何运作的。
- en: '**Mathematical functions always have exactly one input and one output**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学函数总是恰好有一个输入和一个输出**'
- en: As you can see from the diagrams, there is always exactly one input and one
    output for a mathematical function. This is true for functional programming languages
    as well, although it may not be obvious when you first use them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从图表中看到的，数学函数总是恰好有一个输入和一个输出。这对于函数式编程语言也是成立的，尽管当你第一次使用它们时可能并不明显。
- en: That seems like a big annoyance. How can you do useful things without having
    functions with two (or more) parameters?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个很大的烦恼。如果没有具有两个（或更多）参数的函数，你怎么能做有用的事情呢？
- en: Well, it turns there is a way to do it, and what's more, it is completely transparent
    to you in F#. It is called "currying" and it deserves its own post, which is coming
    up soon.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，事实证明有一种方法可以做到这一点，而且更重要的是，在 F# 中对你来说完全透明。这被称为“柯里化”，它值得有自己的帖子，即将推出。
- en: In fact, as you will later discover, these two "unhelpful" properties will turn
    out to be incredibly useful and a key part of what makes functional programming
    so powerful.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，正如你将来会发现的那样，这两个“不太有用”的特性将被证明是非常有用的，也是函数式编程如此强大的关键部分。
- en: Function Values and Simple Values
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数值和简单值
- en: Function Values and Simple Values
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数值和简单值
- en: Let's look at the simple function again
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看简单函数
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What does the "x" mean here? It means:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“x”是什么意思？它意味着：
- en: Accept some value from the input domain.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入域接受某个值。
- en: Use the name "x" to represent that value so that we can refer to it later.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名称“x”来表示该值，以便我们以后可以引用它。
- en: This process of using a name to represent a value is called "binding". The name
    "x" is "bound" to the input value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称代表值的过程称为“绑定”。名称“x”与输入值“绑定”在一起。
- en: So if we evaluate the function with the input 5 say, what is happening is that
    everywhere we see "x" in the original definition, we replace it with "5", sort
    of like search and replace in a word processor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们用输入 5 评估函数，那么正在发生的是，我们在原始定义中看到“x”的地方，将其替换为“5”，有点像在文字处理器中进行搜索和替换。
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is important to understand that this is not assignment. "x" is not a "slot"
    or variable that is assigned to the value and can be assigned to another value
    later on. It is a onetime association of the name "x" with the value. The value
    is one of the predefined integers, and cannot change. And so, once bound, x cannot
    change either; once associated with a value, always associated with a value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解这不是赋值。 “x”不是一个可以分配给值并且以后可以分配给另一个值的“槽”或变量。它是名称“x”与值的一次性关联。该值是预定义的整数之一，不能更改。因此，一旦绑定，x
    也不能更改；一旦与值关联，就永远与值关联。
- en: 'This concept is a critical part of thinking functionally: *there are no "variables",
    only values*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念是思考函数式编程的关键部分：*没有“变量”，只有值*。
- en: Function values
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数值
- en: If you think about this a bit more, you will see that the name "`add1`" itself
    is just a binding to "the function that adds one to its input". The function itself
    is independent of the name it is bound to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再仔细想一想，你会发现名字“`add1`”本身���是绑定到“将其输入加一的函数”。函数本身与其绑定的名字无关。
- en: When you type `let add1 x = x + 1` you are telling the F# compiler "every time
    you see the name "`add1`", replace it with the function that adds 1 to its input".
    "`add1`" is called a **function value**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入 `let add1 x = x + 1` 时，你告诉 F# 编译器“每当你看到名字“`add1`”，就用将 1 加到输入的函数替换它”。“`add1`”被称为**函数值**。
- en: 'To see that the function is independent of its name, try:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到函数与其名字无关，试试：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that "`add1`" and "`plus1`" are two names that refer ("bound to")
    to the same function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，“`add1`”和“`plus1`”是指向同一个函数的两个名字。
- en: 'You can always identify a function value because its signature has the standard
    form `domain -> range`. Here is a generic function value signature:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以通过标准形式 `domain -> range` 来识别函数值的签名。这是一个通用的函数值签名：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Simple values
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单值
- en: Imagine an operation that always returned the integer 5 and didn't have any
    input.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个总是返回整数 5 且没有任何输入的操作。
- en: '![](Functions_Const.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Functions_Const.png)'
- en: This would be a "constant" operation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个“常量”操作。
- en: 'How would we write this in F#? We want to tell the F# compiler "every time
    you see the name `c`, replace it with 5". Here''s how:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在 F# 中编写这个？我们想告诉 F# 编译器“每当你看到名字 `c`，就用 5 替换它”。这样做：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'which when evaluated, returns:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当被评估时，返回：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is no mapping arrow this time, just a single int. What's new is an equals
    sign with the actual value printed after it. The F# compiler knows that this binding
    has a known value which it will always return, namely the value 5\.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有映射箭头，只有一个单独的整数。新的是等号后面跟着实际的值。F# 编译器知道这个绑定有一个已知的值，它将始终返回，即值 5。
- en: In other words, we've just defined a constant, or in F# terms, a simple value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们刚刚定义了一个常量，或者用 F# 术语来说，是一个简单的值。
- en: 'You can always tell a simple value from a function value because all simple
    values have a signature that looks like:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以通过简单值的签名来区分它与函数值，因为所有简单值的签名看起来像：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Simple values vs. function values
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单值与函数值
- en: 'It is important to understand that in F#, unlike languages such as C#, there
    is very little difference between simple values and function values. They are
    both values which can be bound to names (using the same keyword `let`) and then
    passed around. And in fact, one of the key aspects of thinking functionally is
    exactly that: *functions are values that can be passed around as inputs to other
    functions*, as we will soon see.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，在 F# 中，与 C# 等语言不同，简单值和函数值之间几乎没有什么区别。它们都是可以绑定到名称（使用相同的关键字 `let`）然后传递的值。事实上，函数式思维的一个关键方面就是：*函数是可以作为输入传递给其他函数的值*，我们很快就会看到。
- en: Note that there is a subtle difference between a simple value and a function
    value. A function always has a domain and range and must be "applied" to an argument
    to get a result. A simple value does not need to be evaluated after being bound.
    Using the example above, if we wanted to define a "constant function" that returns
    five we would have to use
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意简单值和函数值之间有微妙的区别。函数总是有一个域和范围，并且必须“应用”到一个参数上才能得到结果。简单值在绑定后不需要被评估。使用上面的例子，如果我们想定义一个返回五的“常量函数”，我们将不得不使用
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The signature for these functions is:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的签名是：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'instead of:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More on unit, function syntax and anonymous functions later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 unit、函数语法和匿名函数的内容稍后再说。
- en: '"Values" vs. "Objects"'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “值”与“对象”
- en: In a functional programming language like F#, most things are called "values".
    In an object-oriented language like C#, most things are called "objects". So what
    is the difference between a "value" and an "object"?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 F# 这样的函数式编程语言中，大多数东西都被称为“值”。在像 C# 这样的面向对象语言中，大多数东西都被称为“对象”。那么“值”和“对象”之间有什么区别呢？
- en: A value, as we have seen above, is just a member of a domain. The domain of
    ints, the domain of strings, the domain of functions that map ints to strings,
    and so on. In principle, values are immutable. And values do not have any behavior
    attached them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 值，正如我们上面所看到的，只是域的一个成员。整数的域，字符串的域，将整数映射到字符串的函数的域，等等。原则上，值是不可变的。值没有任何附加的行为。
- en: An object, in a standard definition, is an encapsulation of a data structure
    with its associated behavior (methods). In general, objects are expected to have
    state (that is, be mutable), and all operations that change the internal state
    must be provided by the object itself (via "dot" notation).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对象，在标准定义中，是数据结构及其相关行为（方法）的封装。通常期望对象具有状态（即是可变的），并且所有改变内部状态的操作都必须由对象本身提供（通过“点”符号）。
- en: 'In F#, even the primitive values have some object-like behavior. For example,
    you can dot into a string to get its length:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，即使是原始值也具有一些类似对象的行为。例如，你可以用点号进入一个字符串以获得它的长度：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But, in general, we will avoid using "object" for standard values in F#, reserving
    it to refer to instances of true classes, or other values that expose member methods.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但总的来说，我们将避免在 F# 中对标准值使用“object”，而将其保留以指代真实类的实例，或者暴露成员方法的其他值。
- en: Naming Values
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名值
- en: 'Standard naming rules are used for value and function names, basically, any
    alphanumeric string, including underscores. There are a couple of extras:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于值和函数名称，使用标准命名规则，基本上是任何包括下划线的字母数字字符串。还有一些额外的：
- en: 'You can put an apostrophe anywhere in a name, except the first character. So:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在名称的任何地方放置一个撇号，除了第一个字符。所以：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The final tick is often used to signal some sort of "variant" version of a
    value:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的撇号通常用于表示某种值的“变体”版本：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: or define variants of existing keywords
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者定义现有关键字的变体
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also put double backticks around any string to make a valid identifier.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在任何字符串周围加上双反引号来使其成为一个有效的标识符。
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You might want to use the double backtick trick sometimes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想使用双反引号技巧：
- en: When you want to use an identifier that is the same as a keyword
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要使用与关键字相同的标识符时
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When trying to use natural language for business rules, unit tests, or BDD style
    executable specifications a la Cucumber.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当尝试使用自然语言来进行业务规则、单元测试或类似 Cucumber 的 BDD 风格的可执行规范时。
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unlike C#, the naming convention for F# is that functions and values start with
    lowercase letters rather than uppercase (`camelCase` rather than `PascalCase`)
    unless designed for exposure to other .NET languages. Types and modules use uppercase
    however.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 不同，F# 的命名约定是函数和值以小写字母开头而不是大写字母（`camelCase`而不是`PascalCase`），除非设计用于暴露给其他
    .NET 语言。类型和模块使用大写字母。
- en: How types work with functions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型如何与函数配合工作
- en: How types work with functions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型如何与函数配合工作
- en: Now that we have some understanding of functions, we'll look at how types work
    with functions, both as domains and ranges. This is just an overview; the series
    ["understanding F# types"](understanding-fsharp-types.html) will cover types in
    detail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对函数有了一些理解，我们将看一下类型如何与函数配合工作，既作为定义域又作为范围。这只是一个概述；系列文章["理解 F# 类型"](understanding-fsharp-types.html)将详细介绍类型。
- en: 'First, we need to understand the type notation a bit more. We''ve seen that
    the arrow notation "`->`" is used to show the domain and range. So that a function
    signature always looks like:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更深入地了解类型标记。我们已经看到箭头符号"`->`"用于显示定义域和值域。因此，一个函数签名总是如下所示：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here are some example functions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例函数：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you evaluate that in the F# interactive window, you will see the signatures:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 F# 交互窗口中评估这个，你会看到签名：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This means:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: '`intToString` has a domain of `int` which it maps onto the range `string`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intToString`的定义域是`int`，它将其映射到范围`string`。'
- en: '`stringToInt` has a domain of `string` which it maps onto the range `int`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringToInt`的定义域是`string`，它将其映射到范围`int`。'
- en: Primitive types
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型
- en: 'The possible primitive types are what you would expect: string, int, float,
    bool, char, byte, etc., plus many more derived from the .NET type system.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的原始类型就是你所期望的：字符串、整数、浮点数、布尔值、字符、字节等，再加上许多从 .NET 类型系统派生出的类型。
- en: 'Here are some more examples of functions using primitive types:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用原始类型的函数的更多示例：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'and their signatures are:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 并且它们的签名是：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Type annotations
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型注解
- en: 'In the previous examples, the F# compiler correctly determined the types of
    the parameters and results. But this is not always the case. If you try the following
    code, you will get a compiler error:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，F# 编译器正确地确定了参数和结果的类型。但并非总是如此。如果尝试以下代码，你将会收到编译器错误：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The compiler does not know what type "x" is, and therefore does not know if
    "Length" is a valid method. In most cases, this can be fixed by giving the F#
    compiler a "type annotation" so that it knows which type to use. In the corrected
    version below, we indicate that the type of "x" is a string.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不知道 "x" 的类型，因此不知道 "Length" 是否是一个有效的方法。在大多数情况下，这可以通过给 F# 编译器一个“类型注释”来修复，以便它知道要使用哪种类型。在下面的纠正版本中，我们指示
    "x" 的类型是一个字符串。
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The parens around the `x:string` param are important. If they are missing, the
    compiler thinks that the return value is a string! That is, an "open" colon is
    used to indicate the type of the return value, as you can see in the example below.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`x:string` 参数周围的圆括号很重要。如果缺少它们，编译器会认为返回值是一个字符串！也就是说，使用“开放”冒号来指示返回值的类型，正如你在下面的示例中所看到的。'
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We're indicating that the x param is a string and the return value is an int.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指示 x 参数是一个字符串，返回值是一个整数。
- en: Function types as parameters
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型作为参数
- en: A function that takes other functions as parameters, or returns a function,
    is called a **higher-order function** (sometimes abbreviated as HOF). They are
    used as a way of abstracting out common behavior. These kinds of functions are
    extremely common in F#; most of the standard libraries use them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接受其他函数作为参数，或者返回一个函数的函数称为**高阶函数**（有时缩写为 HOF）。它们被用作抽象出常见行为的一种方式。这类函数在 F# 中非常常见；大多数标准库都使用它们。
- en: 'Consider a function `evalWith5ThenAdd2`, which takes a function as a parameter,
    then evaluates the function with the value 5, and adds 2 to the result:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个名为 `evalWith5ThenAdd2` 的函数，它将一个函数作为参数，然后用值 5 评估该函数，并将结果加 2：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The signature of this function looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的签名看起来像这样：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see that the domain is `(int->int)` and the range is `int`. What does
    that mean? It means that the input parameter is not a simple value, but a function,
    and what's more is restricted only to functions that map `ints` to `ints`. The
    output is not a function, just an int.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到域是 `(int->int)`，范围是 `int`。这是什么意思？这意味着输入参数不是一个简单的值，而是一个函数，并且更重要的是只限于将 `ints`
    映射到 `ints` 的函数。输出不是一个函数，只是一个整数。
- en: 'Let''s try it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'gives:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 得到：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '"`add1`" is a function that maps ints to ints, as we can see from its signature.
    So it is a valid parameter for the `evalWith5ThenAdd2` function. And the result
    is 8\.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '"`add1`" 是一个将整数映射到整数的函数，从其签名中我们可以看出来。因此它是 `evalWith5ThenAdd2` 函数的有效参数。结果是 8。'
- en: By the way, the special word "`it`" is used for the last thing that was evaluated;
    in this case the result we want. It's not a keyword, just a convention.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，特殊词 "`it`" 用于表示上次评估的结果；在本例中是我们想要的结果。它不是关键字，只是一种约定。
- en: 'Here''s another one:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 再来一个例子：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'gives:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 得到：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '"`times3`" is also a function that maps ints to ints, as we can see from its
    signature. So it is also a valid parameter for the `evalWith5ThenAdd2` function.
    And the result is 17.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '"`times3`" 也是一个将整数映射到整数的函数，从其签名中我们可以看出来。因此它也是 `evalWith5ThenAdd2` 函数的有效参数。结果是
    17。'
- en: 'Note that the input is sensitive to the types. If our input function uses `floats`
    rather than `ints`, it will not work. For example, if we have:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输入对类型是敏感的。如果我们的输入函数使用 `floats` 而不是 `ints`，它将无法工作。例如，如果我们有：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Evaluating this will give an error:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 评估这个将会出错：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: meaning that the input function should have been an `int->int` function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着输入函数应该是一个 `int->int` 函数。
- en: Functions as output
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数作为输出
- en: A function value can also be the output of a function. For example, the following
    function will generate an "adder" function that adds using the input value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 函数值也可以是函数的输出。例如，下面的函数将生成一个使用输入值进行加法的“加法器”函数。
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The signature is:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 签名是：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'which means that the generator takes an `int`, and creates a function (the
    "adder") that maps `ints` to `ints`. Let''s see how it works:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着生成器接受一个 `int`，并创建一个函数（"加法器"）将 `ints` 映射到 `ints`。让我们看看它是如何工作的：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This creates two adder functions. The first generated function adds 1 to its
    input, and the second adds 2\. Note that the signatures are just as we would expect
    them to be.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了两个加法器函数。第一个生成的函数将其输入加 1，第二个加 2。请注意，签名正如我们所期望的那样。
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And we can now use these generated functions in the normal way. They are indistinguishable
    from functions defined explicitly
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以以正常方式使用这些生成的函数了。它们与明确定义的函数无异。
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using type annotations to constrain function types
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类型注释来约束函数类型
- en: 'In the first example, we had the function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们有这个函数：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case F# could deduce that "`fn`" mapped `ints` to `ints`, so its signature
    would be `int->int`
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，F# 可以推断出 "`fn`" 将 `ints` 映射到 `ints`，因此其签名将为 `int->int`
- en: But what is the signature of "fn" in this following case?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 但在以下情况下 "fn" 的签名是什么？
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Obviously, "`fn`" is some kind of function that takes an int, but what does
    it return? The compiler can't tell. If you do want to specify the type of the
    function, you can add a type annotation for function parameters in the same way
    as for a primitive type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，"`fn`" 是某种接受整数的函数，但它返回什么？ 编译器无法确定。 如果您确实想指定函数的类型，可以像对原始类型一样为函数参数添加类型注释。
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Alternatively, you could also specify the return type instead.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您还可以指定返回类型。
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Because the main function returns a string, the "`fn`" function is also constrained
    to return a string, so no explicit typing is required for "fn".
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为主函数返回一个字符串，所以 "`fn`" 函数也被限定为返回一个字符串，因此不需要为 "fn" 进行显式的类型标注。
- en: The "unit" type
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"unit" 类型'
- en: When programming, we sometimes want a function to do something without returning
    a value. Consider the function "`printInt`", defined below. The function doesn't
    actually return anything. It just prints a string to the console as a side effect.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，有时我们希望函数执行某些操作而不返回值。 考虑下面定义的函数 "`printInt`"。 该函数实际上不返回任何内容。 它只是作为副作用将一个字符串打印到控制台。
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: So what is the signature for this function?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个函数的签名是什么？
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: What is this "`unit`"?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 "`unit`" 是什么？
- en: Well, even if a function returns no output, it still needs a range. There are
    no "void" functions in mathematics-land. Every function must have some output,
    because a function is a mapping, and a mapping has to have something to map to!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，即使一个函数没有返回输出，它仍然需要一个范围。 在数学领域没有 "void" 函数。 每个函数必须有一些输出，因为函数是一个映射，而映射必须有一些东西可映射！
- en: '![](Functions_Unit.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](Functions_Unit.png)'
- en: 'So in F#, functions like this return a special range called "`unit`". This
    range has exactly one value in it, called "`()`". You can think of `unit` and
    `()` as somewhat like "void" (the type) and "null" (the value) in C#. But unlike
    void/null, `unit` is a real type and `()` is a real value. To see this, evaluate:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，像这样的函数返回一种特殊的范围，称为“`unit`”。 这个范围里面确切地只有一个值，称为“`()`”。 你可以把`unit`和`()`想象成
    C# 中的 "void"（类型）和 "null"（值）。 但与void/null不同的是，`unit`是一个真正的类型，`()`是一个真正的值。 要查看这一点，请评估：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'and you will see the signature:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到签名：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Which means that the value "`whatIsThis`" is of type `unit` and has been bound
    to the value `()`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着值 "`whatIsThis`" 的类型是 `unit`，并且已经绑定到值 `()`
- en: 'So, going back to the signature of "`printInt`", we can now understand it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到 "`printInt`" 的签名，我们现在可以理解它了：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This signature says: `printInt` has a domain of `int` which it maps onto nothing
    that we care about.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名表示：`printInt` 的定义域是 `int`，它映射到我们不关心的东西。
- en: Parameterless functions
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无参数函数
- en: 'Now that we understand unit, can we predict its appearance in other contexts?
    For example, let''s try to create a reusable "hello world" function. Since there
    is no input and no output, we would expect it to have a signature `unit -> unit`.
    Let''s see:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了 unit，我们能预测它在其他情况下的出现吗？ 例如，让我们尝试创建一个可重用的 "hello world" 函数。 由于没有输入和输出，我们期望它的签名为
    `unit -> unit`。 让我们看看：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The result is:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Not quite what we expected. "Hello world" is printed immediately and the result
    is not a function, but a simple value of type unit. As we saw earlier, we can
    tell that this is a simple value because it has a signature of the form:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全符合我们的期望。 "Hello world" 立即打印出来，结果不是一个函数，而是一个简单值，其类型为 unit。 正如我们前面看到的，我们可以通过以下形式的签名来判断这是一个简单值：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So in this case, we see that `printHello` is actually a *simple value* with
    the value `()`. It's not a function that we can call again.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，我们看到 `printHello` 实际上是一个 *简单值*，其值为 `()`。 它不是一个我们可以再次调用的函数。
- en: Why the difference between `printInt` and `printHello`? In the `printInt` case,
    the value could not be determined until we knew the value of the x parameter,
    so the definition was of a function. In the `printHello` case, there were no parameters,
    so the right hand side could be determined immediately. Which it was, returning
    the `()` value, with the side effect of printing to the console.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`printInt` 和 `printHello` 之间的差异是什么？ 在 `printInt` 的情况下，直到我们知道 x 参数的值才能确定值，因此定义是一个函数。
    在 `printHello` 的情况下，没有参数，因此右侧的值可以立即确定。 它返回了 `()` 值，并具有向控制台打印的副作用。'
- en: 'We can create a true reusable function that is parameterless by forcing the
    definition to have a unit argument, like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过强制定义具有单元参数的函数来创建真正可重用的函数，就像这样：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The signature is now:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在签名为：
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'and to call it, we have to pass the `()` value as a parameter, like so:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用它，我们必须将 `()` 值作为参数传递，就像这样：
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Forcing unit types with the ignore function
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ignore 函数强制单元类型
- en: 'In some cases the compiler requires a unit type and will complain. For example,
    both of the following will be compiler errors:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，编译器需要单元类型并将抱怨。例如，以下两者都将是编译器错误：
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To help in these situations, there is a special function `ignore` that takes
    anything and returns the unit type. The correct version of this code would be:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这些情况下提供帮助，有一个特殊函数 `ignore`，它接受任何内容并返回单元类型。这段代码的正确版本将是：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Generic types
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型
- en: In many cases, the type of the function parameter can be any type, so we need
    a way to indicate this. F# uses the .NET generic type system for this situation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，函数参数的类型可以是任何类型，因此我们需要一种方法来表示这一点。F# 使用 .NET 泛型类型系统来处理这种情况。
- en: 'For example, the following function converts the parameter to a string and
    appends some text:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数将参数转换为字符串并附加一些文本：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It doesn't matter what type the parameter is, as all objects understand `ToString()`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的类型不重要，因为所有对象都理解 `ToString()`。
- en: 'The signature is:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 签名为：
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'What is this type called `''a`? That is F#''s way of indicating a generic type
    that is not known at compile time. The apostrophe in front of the "a" means that
    the type is generic. The signature for the C# equivalent of this would be:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`''a` 这种类型叫什么？这是 F# 表示在编译时不知道的泛型类型的方式。 "a" 前面的撇号表示类型是泛型的。这的 C# 签名等效于：'
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that the F# function is still strongly typed with a generic type. It does
    *not* take a parameter of type `Object`. This strong typing is desirable so that
    when functions are composed together, type safety is still maintained.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，F# 函数仍然是具有泛型类型的强类型化的。它 *不* 接受 `Object` 类型的参数。这种强类型化是可取的，以便在将函数组合在一起时，仍然保持类型安全性。
- en: Here's the same function being used with an int, a float and a string
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用整数、浮点数和字符串调用相同函数的示例
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If there are two generic parameters, the compiler will give them different
    names: `''a` for the first generic, `''b` for the second generic, and so on. Here''s
    an example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个泛型参数，编译器将给它们不同的名称：第一个泛型为 `'a`，第二个泛型为 `'b`，以此类推。这里是一个例子：
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The type signature for this has two generics: `''a` and `''b`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此签名有两个泛型：`'a` 和 `'b`：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'On the other hand, the compiler will recognize when only one generic type is
    required. In the following example, the x and y parameters must be of the same
    type:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，编译器会识别出仅需要一个泛型类型的情况。在以下示例中，x 和 y 参数必须是相同类型：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'So the function signature has the same generic type for both of them:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数签名对于两者都具有相同的泛型类型：
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Generic parameters are also very important when it comes to lists and more abstract
    structures, and we will be seeing them a lot in upcoming examples.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到列表和更抽象的结构时，泛型参数也非常重要，我们将在接下来的示例中经常见到它们。
- en: Other types
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型
- en: The types discussed so far are just the basic types. These types can be combined
    in various ways to make much more complex types. A full discussion of these types
    will have to wait for [another series](understanding-fsharp-types.html), but meanwhile,
    here is a brief introduction to them so that you can recognize them in function
    signatures.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的类型只是基本类型。这些类型可以以各种方式组合在一起，以形成更复杂的类型。关于这些类型的完整讨论将等待 [另一个系列](understanding-fsharp-types.html)，但同时，这里是对它们的简要介绍，以便您能够在函数签名中识别它们。
- en: '**The "tuple" types**. These are pairs, triples, etc., of other types. For
    example `("hello", 1)` is a tuple made from a string and an int. The comma is
    the distinguishing characteristic of a tuple -- if you see a comma in F#, it is
    almost certainly part of a tuple!'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"元组" 类型**。这些是其他类型的对、三元组等。例如 `("hello", 1)` 是由字符串和整数组成的元组。逗号是元组的区别特征 -- 如果在
    F# 中看到逗号，几乎肯定是元组的一部分！'
- en: 'In function signatures, tuples are written as the "multiplication" of the two
    types involved. So in this case, the tuple would have type:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名中，元组被写为涉及的两种类型的 "乘法"。因此，在这种情况下，元组将具有类型：
- en: '[PRE68]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**The collection types**. The most common of these are lists, sequences, and
    arrays. Lists and arrays are fixed size, while sequences are potentially infinite
    (behind the scenes, sequences are the same as `IEnumerable`). In function signatures,
    they have their own keywords: "`list`", "`seq`", and "`[]`" for arrays.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合类型**。其中最常见的是列表、序列和数组。列表和数组是固定大小的，而序列可能是无限的（在幕后，序列与 `IEnumerable` 相同）。在函数签名中，它们有自己的关键字：“`list`”、“`seq`”和“`[]`”分别表示列表、序列和数组。'
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**The option type**. This is a simple wrapper for objects that might be missing.
    There are two cases: `Some` and `None`. In function signatures, they have their
    own "`option`" keyword:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项类型**。这是一个简单的包装器，用于可能缺失的对象。有两种情况：`Some` 和 `None`。在函数签名中，它们有自己的“`option`”关键字：'
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**The discriminated union type**. These are built from a set of choices of
    other types. We saw some examples of this in the ["why use F#?"](why-use-fsharp.html)
    series. In function signatures, they are referred to by the name of the type,
    so there is no special keyword.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鉴别联合类型**。这些类型由其他类型的一组选择构建而成。我们在["为什么使用 F#?"](why-use-fsharp.html)系列中看到了一些例子。在函数签名中，它们按类型名称引用，因此没有特殊的关键字。'
- en: '**The record type**. These are like structures or database rows, a list of
    named slots. We saw some examples of this in the ["why use F#?"](why-use-fsharp.html)
    series as well. In function signatures, they are referred to by the name of the
    type, so again there is no special keyword.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录类型**。这些类似于结构或数据库行，是一系列具有命名槽的列表。我们在["为什么使用 F#?"](why-use-fsharp.html)系列中也看到了一些例子。在函数签名中，它们按类型名称引用，因此也没有特殊的关键字。'
- en: Test your understanding of types
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你对类型的理解
- en: How well do you understand the types yet? Here are some expressions for you
    -- see if you can guess their signatures. To see if you are correct, just run
    them in the interactive window!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你对类型了解多少？以下是一些表达式--看看你能否猜到它们的签名。要查看是否正确，只需在交互窗口中运行它们！
- en: '[PRE71]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Currying
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: Currying
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'After that little digression on basic types, we can turn back to functions
    again, and in particular the puzzle we mentioned earlier: if a mathematical function
    can only have one parameter, then how is it possible that an F# function can have
    more than one?'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在对基本类型进行了一小段的插曲之后，我们可以再次转向函数，特别是我们之前提到的谜题：如果数学函数只能有一个参数，那么如何可能 F# 函数可以有多个呢？
- en: 'The answer is quite simple: a function with multiple parameters is rewritten
    as a series of new functions, each with only one parameter. And this is done automatically
    by the compiler for you. It is called "**currying**", after Haskell Curry, a mathematician
    who was an important influence on the development of functional programming.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 答案非常简单：具有多个参数的函数被重写为一系列新函数，每个函数只有一个参数。这由编译器自动完成。它被称为“**柯里化**”，以数学家 Haskell Curry
    的名字命名，他对函数式编程的发展产生了重要影响。
- en: 'To see how this works in practice, let''s use a very basic example that prints
    two numbers:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看这是如何实践的，让我们用一个非常基本的例子来打印两个数字：
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Internally, the compiler rewrites it as something more like:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，编译器将其重写为更类似于以下内容：
- en: '[PRE73]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s examine this in more detail:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地研究一下这个问题：
- en: 'Construct the function called "`printTwoParameters`" but with only *one* parameter:
    "x"'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造名为“`printTwoParameters`”的函数，但只有*一个*参数：“x”
- en: 'Inside that, construct a subfunction that has only *one* parameter: "y". Note
    that this inner function uses the "x" parameter but x is not passed to it explicitly
    as a parameter. The "x" parameter is in scope, so the inner function can see it
    and use it without needing it to be passed in.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中构造一个只有*一个*参数的子函数：“y”。请注意，这个内部函数使用“x”参数，但x并没有显式地作为参数传递给它。由于“x”参数在作用域内，所以内部函数可以看到它并使用它，而不需要显式传递它。
- en: Finally, return the newly created subfunction.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回新创建的子函数。
- en: This returned function is then later used against "y". The "x" parameter is
    baked into it, so the returned function only needs the y param to finish off the
    function logic.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，返回的函数稍后将用于“y”。 “x”参数已经嵌入其中，因此返回的函数只需要y参数来完成函数逻辑。
- en: 'By rewriting it this way, the compiler has ensured that every function has
    only one parameter, as required. So when you use "`printTwoParameters`", you might
    think that you are using a two parameter function, but it is actually only a one
    parameter function! You can see for yourself by passing only one argument instead
    of two:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式重写，编译器确保每个函数都只有一个参数，如所需。因此，当您使用“`printTwoParameters`”时，您可能认为您正在使用一个具有两个参数的函数，但实际上只是一个具有一个参数的函数！您可以自行验证，只传递一个参数而不是两个参数：
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you evaluate it with one argument, you don't get an error, you get back a
    function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用一个参数评估它，你不会得到错误，而是得到一个函数。
- en: 'So what you are really doing when you call `printTwoParameters` with two arguments
    is:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你用两个参数调用`printTwoParameters`时，你实际上在做什么：
- en: You call `printTwoParameters` with the first argument (x)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你用第一个参数（x）调用`printTwoParameters`
- en: '`printTwoParameters` returns a new function that has "x" baked into it.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printTwoParameters`返回一个将"x"嵌入其中的新函数。'
- en: You then call the new function with the second argument (y)
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后你用第二个参数（y）调用新函数
- en: Here is an example of the step by step version, and then the normal version
    again.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是逐步版本的示例，然后再次是正常版本。
- en: '[PRE75]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here is another example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Again, the "two parameter function" is actually a one parameter function that
    returns an intermediate function.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个"两个参数函数"实际上是一个返回中间函数的一个参数函数。
- en: But wait a minute -- what about the "`+`" operation itself? It's a binary operation
    that must take two parameters, surely? No, it is curried like every other function.
    There is a function called "`+`" that takes one parameter and returns a new intermediate
    function, exactly like `addTwoParameters` above.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但等一下 -- "`+`"操作本身呢？它是一个必须接受两个参数的二元操作，对吧？不，它像其他函数一样被柯里化。有一个名为"`+`"的函数，它接受一个参数并返回一个新的中间函数，就像上面的`addTwoParameters`一样。
- en: When we write the statement `x+y`, the compiler reorders the code to remove
    the infix and turns it into `(+) x y`, which is the function named `+` called
    with two parameters. Note that the function named "+" needs to have parentheses
    around it to indicate that it is being used as a normal function name rather than
    as an infix operator.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写语句`x+y`时，编译器重新排列代码以去除中缀，并将其转换为`(+) x y`，这是名为`+`的函数与两个参数一起调用。请注意，名为"+"的函数需要在其周围加上括号，以指示它被用作普通函数名而不是中缀运算符。
- en: Finally, the two parameter function named `+` is treated as any other two parameter
    function would be.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，名为`+`的两个参数函数被视为任何其他两个参数函数一样。
- en: '[PRE77]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: And yes, this works for all other operators and built in functions like printf.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这对所有其他运算符和内置函数如printf也适用。
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Signatures of curried functions
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化函数的签名
- en: Now that we know how curried functions work, what should we expect their signatures
    to look like?
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道柯里化函数是如何工作的，我们应该期望它们的签名是什么样子的呢？
- en: 'Going back to the first example, "`printTwoParameters`", we saw that it took
    one argument and returned an intermediate function. The intermediate function
    also took one argument and returned nothing (that is, unit). So the intermediate
    function has type `int->unit`. In other words, the domain of `printTwoParameters`
    is `int` and the range is `int->unit`. Putting this together we see that the final
    signature is:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第一个例子"`printTwoParameters`"，我们看到它接受一个参数并返回一个中间函数。中间函数也接受一个参数并返回空（即，unit）。因此，中间函数的类型是`int->unit`。换句话说，`printTwoParameters`的定义域是`int`，值域是`int->unit`。将这些放在一起，我们看到最终的签名是：
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you evaluate the explicitly curried implementation, you will see the parentheses
    in the signature, as written above, but if you evaluate the normal implementation,
    which is implicitly curried, the parentheses are left off, like so:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你评估显式柯里化的实现，你会看到签名中的括号，就像上面写的那样，但如果你评估隐式柯里化的正常实现，括号会被省略，就像这样：
- en: '[PRE80]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The parentheses are optional. If you are trying to make sense of function signatures
    it might be helpful to add them back in mentally.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 括号是可选的。如果你试图理解函数签名，将它们在脑海中添加回去可能会有所帮助。
- en: At this point you might be wondering, what is the difference between a function
    that returns an intermediate function and a regular two parameter function?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此时你可能会想知道，返回中间函数和常规两个参数函数之间有什么区别？
- en: 'Here''s a one parameter function that returns a function:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回函数的一个参数函数：
- en: '[PRE81]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here''s a two parameter function that returns a simple value:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回简单值的两个参数函数：
- en: '[PRE82]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The signatures are slightly different, but in practical terms, there *is* no
    difference*, only that the second function is automatically curried for you.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 签名略有不同，但在实际情况下，*没有任何区别*，只是第二个函数会自动为你柯里化。
- en: Functions with more than two parameters
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有多于两个参数的函数
- en: 'How does currying work for functions with more than two parameters? Exactly
    the same way: for each parameter except the last one, the function returns an
    intermediate function with the previous parameters baked in.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带有两个以上参数的函数，柯里化是如何工作的？完全相同：对于除最后一个参数之外的每个参数，函数都返回一个中间函数，其中包含前面的参数。
- en: Consider this contrived example. I have explicitly specified the types of the
    parameters, but the function itself does nothing.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个刻意设计的例子。我已经明确指定了参数的类型，但函数本身什么也没做。
- en: '[PRE83]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The signature of the overall function is:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 整个函数的签名是：
- en: '[PRE84]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'and the signatures of the intermediate functions are:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 中间函数的签名是：
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'A function signature can tell you how many parameters the function takes: just
    count the number of arrows outside of parentheses. If the function takes or returns
    other function parameters, there will be other arrows in parentheses, but these
    can be ignored. Here are some examples:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名可以告诉你函数需要多少个参数：只需数括号外的箭头数量。如果函数接受或返回其他函数参数，括号内还会有其他箭头，但这些可以忽略。以下是一些例子：
- en: '[PRE86]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Issues with multiple parameters
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多参数问题
- en: The logic behind currying can produce some unexpected results until you understand
    it. Remember that you will not get an error if you evaluate a function with fewer
    arguments than it is expecting. Instead you will get back a partially applied
    function. If you then go on to use this partially applied function in a context
    where you expect a value, you will get obscure error messages from the compiler.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化背后的逻辑可能会产生一些意想不到的结果，直到你理解它。记住，如果你评估一个带有少于它预期参数的函数，你不会得到错误。相反，你会得到一个部分应用的函数。如果你继续在期望一个值的上下文中使用这个部分应用的函数，你将从编译器获得晦涩的错误消息。
- en: 'Here''s an innocuous looking function:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个看起来无害的函数：
- en: '[PRE87]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'What would you expect to happen when we call it as shown below? Will it print
    "hello" to the console? Try to guess before evaluating it, and here''s a hint:
    be sure to take a look at the function signature.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按照下面所示调用它时，你期望会发生什么？它会在控制台打印“hello”吗？在评估之前尝试猜测一下，并且这里有一个提示：一定要查看函数签名。
- en: '[PRE88]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It will *not* be called as expected. The original function expects a unit argument
    that was not supplied, so you are getting a partially applied function (in this
    case with no arguments).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 它将*不会*按预期调用。原始函数期望一个未提供的单位参数，因此你得到一个部分应用的函数（在这种情况下没有参数）。
- en: How about this? Will it compile?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个呢？它会编译通过吗？
- en: '[PRE89]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If you evaluate it, you will see that the compiler complains about the printfn
    line.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你评估它，你会发现编译器抱怨printfn行。
- en: '[PRE90]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If you didn't understand currying, this message would be very cryptic! All expressions
    that are evaluated standalone like this (i.e. not used as a return value or bound
    to something with "let") *must* evaluate to the unit value. And in this case,
    it is does *not* evaluate to the unit value, but instead evaluates to a function.
    This is a long winded way of saying that `printfn` is missing an argument.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解柯里化，这条消息会非常难懂！像这样单独评估的所有表达式（即不用作返回值或绑定到带有“let”的东西）*必须*评估为单位值。而在这种情况下，它不会评估为单位值，而是评估为一个函数。这就是说`printfn`缺少一个参数的绕了一大圈的方法。
- en: A common case of errors like this is when interfacing with the .NET library.
    For example, the `ReadLine` method of a `TextReader` must take a unit parameter.
    It is often easy to forget this and leave off the parens, in which case you do
    not get a compiler error immediately, but only when you try to treat the result
    as a string.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这类错误的常见情况是与.NET库进行接口时。例如，`TextReader`的`ReadLine`方法必须接受一个单位参数。很容易忘记这一点，然后省略括号，这样你不会立即得到编译器错误，而只有在尝试将结果视为字符串时才会得到错误。
- en: '[PRE91]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the code above, `line1` is just a pointer or delegate to the `Readline` method,
    not the string that we expected. The use of `()` in `reader.ReadLine()` actually
    executes the function.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`line1`只是指向`Readline`方法的指针或委托，并不是我们预期的字符串。在`reader.ReadLine()`中使用`()`实际上执行了该函数。
- en: Too many parameters
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数过多
- en: You can get similar cryptic messages when you have too many parameters as well.
    Here are some examples of passing too many parameters to printf.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有太多参数时，你也会得到类似的隐晦消息。以下是向printf传递过多参数的一些例子。
- en: '[PRE92]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: For example, in the last case, the compiler is saying that it expects the format
    argument to have three parameters (the signature `'a -> 'b -> 'c -> 'd` has three
    parameters) but it is given only two (the signature `'a -> 'b -> unit` has two
    parameters).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在最后一种情况中，编译器正在说它期望格式参数有三个参数（签名 `'a -> 'b -> 'c -> 'd` 有三个参数），但它只给出了两个（签名
    `'a -> 'b -> unit` 有两个参数）。
- en: In cases not using `printf`, passing too many parameters will often mean that
    you end up with a simple value that you then try to pass a parameter to. The compiler
    will complain that the simple value is not a function.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用 `printf` 的情况下，传递太多参数通常意味着你最终会得到一个简单的值，然后你尝试将参数传递给它。编译器会抱怨说简单的值不是一个函数。
- en: '[PRE93]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If you break the call into a series of explicit intermediate functions, as we
    did earlier, you can see exactly what is going wrong.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将调用分解为一系列明确的中间函数，就像我们之前做的那样，你可以清楚地看到出了什么问题。
- en: '[PRE94]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Partial application
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: Partial application
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: In the previous post on currying, we looked at breaking multiple parameter functions
    into smaller one parameter functions. It is the mathematically correct way of
    doing it, but that is not the only reason it is done -- it also leads to a very
    powerful technique called **partial function application**. This is a very widely
    used style in functional programming, and it is important to understand it.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一篇关于柯里化的文章中，我们看到了将多参数函数分解为较小的一参数函数的方法。这是数学上正确的做法，但这不是唯一的原因 -- 这还导致了一种非常强大的技术，称为**部分函数应用**。这是函数式编程中非常常用的一种风格，重要的是要理解它。
- en: The idea of partial application is that if you fix the first N parameters of
    the function, you get a function of the remaining parameters. From the discussion
    on currying, you can probably see how this comes about naturally.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用的想法是，如果你固定函数的前N个参数，你将得到一个剩余参数的函数。从柯里化的讨论中，你可能能够自然地看出这是如何发生的。
- en: 'Here are some simple examples that demonstrate this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些简单的例子来演示这一点：
- en: '[PRE95]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In each case, we create a partially applied function that we can then reuse
    in multiple contexts.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们都创建了一个部分应用的函数，然后可以在多个上下文中重复使用。
- en: 'The partial application can just as easily involve fixing function parameters,
    of course. Here are some examples:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，部分应用也可以涉及固定函数参数。以下是一些例子：
- en: '[PRE96]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The following more complex example shows how the same approach can be used to
    create "plug in" behavior that is transparent.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更复杂的示例显示了相同的方法如何用于创建透明的“插件”行为。
- en: We create a function that adds two numbers, but in addition takes a logging
    function that will log the two numbers and the result.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个添加两个数字的函数，但还需要一个记录函数，该函数将记录两个数字和结果。
- en: 'The logging function has two parameters: (string) "name" and (generic) "value",
    so it has signature `string->''a->unit`.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录函数有两个参数：(字符串) "name" 和 (泛型) "value"，因此它的签名是 `string->'a->unit`。
- en: We then create various implementations of the logging function, such as a console
    logger or a popup logger.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了各种实现记录函数，例如控制台记录器或弹出记录器。
- en: And finally we partially apply the main function to create new functions that
    have a particular logger baked into them.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们部分应用主函数以创建具有特定记录器的新函数。
- en: '[PRE97]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: These functions with the logger baked in can in turn be used like any other
    function. For example, we can create a partial application to add 42, and then
    pass that into a list function, just like we did for the simple "`add42`" function.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内嵌了记录器的函数也可以像任何其他函数一样使用。例如，我们可以创建一个部分应用来添加42，然后将其传递给列表函数，就像我们为简单的 "`add42`"
    函数所做的那样。
- en: '[PRE98]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: These partially applied functions are a very useful tool. We can create library
    functions which are flexible (but complicated), yet make it easy to create reusable
    defaults so that callers don't have to be exposed to the complexity all the time.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分应用的函数是一个非常有用的工具。我们可以创建灵活的（但复杂的）库函数，但也可以轻松创建可重用的默认值，这样调用者不必一直暴露在复杂性中。
- en: Designing functions for partial application
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计部分应用的函数
- en: 'You can see that the order of the parameters can make a big difference in the
    ease of use for partial application. For example, most of the functions in the
    `List` library such as `List.map` and `List.filter` have a similar form, namely:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到参数的顺序对于部分应用的易用性有很大的影响。例如，`List` 库中的大多数函数（如 `List.map` 和 `List.filter`）都具有类似的形式，即：
- en: '[PRE99]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The list is always the last parameter. Here are some examples of the full form:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 列表始终是最后一个参数。以下是一些完整形式的示例：
- en: '[PRE100]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'And the same examples using partial application:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以及使用部分应用的相同示例：
- en: '[PRE101]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: If the library functions were written with the parameters in a different order,
    it would be much more inconvenient to use them with partial application.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库函数的参数顺序不同，那么使用部分应用将会变得更加不方便。
- en: 'As you write your own multi-parameter functions, you might wonder what the
    best parameter order is. As with all design questions, there is no "right" answer
    to this question, but here are some commonly accepted guidelines:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写自己的多参数函数时，你可能会想知道最佳的参数顺序是什么。与所有设计问题一样，这个问题没有“正确”的答案，但以下是一些常被接受的指南：
- en: 'Put earlier: parameters more likely to be static'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放在前面：参数更可能是静态的
- en: 'Put last: the data structure or collection (or most varying argument)'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放在最后：数据结构或集合（或最变化的参数）
- en: For well-known operations such as "subtract", put in the expected order
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于像“减法”这样的众所周知的操作，按预期顺序放置
- en: Guideline 1 is straightforward. The parameters that are most likely to be "fixed"
    with partial application should be first. We saw this with the logger example
    earlier.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 指南1很简单。最有可能使用部分应用固定的参数应该首先出现。我们之前在日志记录器示例中看到了这一点。
- en: Guideline 2 makes it easier to pipe a structure or collection from function
    to function. We have seen this many times already with list functions.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 指南2使得将结构或集合从函数传递到函数变得更加容易。我们已经多次在列表函数中看到这一点。
- en: '[PRE102]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Similarly, partially applied list functions are easy to compose, because the
    list parameter itself can be easily elided:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，部分应用的列表函数易于组合，因为列表参数本身可以很容易地省略：
- en: '[PRE103]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Wrapping BCL functions for partial application
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为部分应用包装BCL函数
- en: The .NET base class library functions are easy to access in F#, but are not
    really designed for use with a functional language like F#. For example, most
    functions have the data parameter first, while with F#, as we have seen, the data
    parameter should normally come last.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: .NET基类库函数在F#中很容易访问，但实际上并不是为像F#这样的函数式语言而设计的。例如，大多数函数都将数据参数放在第一位，而在F#中，正如我们所见，数据参数通常应该放在最后一位。
- en: 'However, it is easy enough to create wrappers for them that are more idiomatic.
    For example, in the snippet below, the .NET string functions are rewritten to
    have the string target be the last parameter rather than the first:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，为它们创建更符合惯用法的包装器相当容易。例如，在下面的代码片段中，将.NET字符串函数重写为字符串目标是最后一个参数而不是第一个参数：
- en: '[PRE104]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Once the string becomes the last parameter, we can then use them with pipes
    in the expected way:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦字符串成为最后一个参数，我们就可以按预期的方式使用它们与管道：例如：
- en: '[PRE105]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'or with function composition:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用函数组合：
- en: '[PRE106]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Understanding the "pipe" function
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解“管道”函数
- en: Now that you have seen how partial application works, you should be able to
    understand how the "pipe" function works.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了部分应用是如何工作的，你应该能够理解“管道”函数是如何工作的。
- en: 'The pipe function is defined as:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 管道函数被定义为：
- en: '[PRE107]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: All it does is allow you to put the function argument in front of the function
    rather than after. That's all.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的就是允许你把函数参数放在函数之前而不是之后。就是这样。
- en: '[PRE108]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If the function has multiple parameters, then it appears that the input is
    the final parameter. Actually what is happening is that the function is partially
    applied, returning a function that has a single parameter: the input'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数有多个参数，则看起来输入是最后一个参数。实际上正在发生的是函数被部分应用，返回一个具有单个参数的函数：输入
- en: Here's the same example rewritten to use partial application
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将相同示例重写为使用部分应用的示例
- en: '[PRE109]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'As you have already seen, the pipe operator is extremely common in F#, and
    used all the time to preserve a natural flow. Here are some more usages that you
    might see:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的，管道运算符在F#中非常常见，并且经常用于保持自然的流程。以下是一些你可能会看到的更多用法：
- en: '[PRE110]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The reverse pipe function
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向管道函数
- en: You might occasionally see the reverse pipe function "<|" being used.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能偶尔会看到反向管道函数“<|”被使用。
- en: '[PRE111]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: It seems that this function doesn't really do anything different from normal,
    so why does it exist?
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎这个函数并没有真正做任何不同于正常的事情，那么它为什么存在呢？
- en: The reason is that, when used in the infix style as a binary operator, it reduces
    the need for parentheses and can make the code cleaner.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，当以中缀样式作为二元运算符使用时，它减少了对括号的需求，使代码更清晰。
- en: '[PRE112]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: You can also use piping in both directions at once to get a pseudo infix notation.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以同时在两个方向上使用管道来获得伪中缀表示法。
- en: '[PRE113]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Function associativity and composition
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数结合性和组合
- en: Function associativity and composition
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数结合性和组合
- en: Function associativity
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数结合性
- en: If we have a chain of functions in a row, how are they combined?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一系列函数连续排列，它们是如何组合的？
- en: For example, what does this mean?
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是什么意思？
- en: '[PRE114]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Does it mean apply the function y to the argument z, and then take the result
    and use it as an argument for x? In which case it is the same as:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着将函数y应用于参数z，然后取结果并将其用作参数传递给x？在这种情况下，它与以下情况相同：
- en: '[PRE115]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Or does it mean apply the function x to the argument y, and then take the resulting
    function and evaluate it with the argument z? In which case it is the same as:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这是否意味着将函数x应用于参数y，然后取得结果函数并用参数z评估它���在这种情况下，它与以下情况相同：
- en: '[PRE116]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The answer is the latter. Function application is *left associative*. That is,
    evaluating `x y z` is the same as evaluating `(x y) z`. And evaluating `w x y
    z` is the same as evaluating `((w x) y) z`. This should not be a surprise. We
    have already seen that this is how partial application works. If you think of
    x as a two parameter function, then `(x y) z` is the result of partial application
    of the first parameter, followed by passing the z argument to the intermediate
    function.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是后者。函数应用是*左结合*的。也就是说，评估`x y z`与评估`(x y) z`是相同的。评估`w x y z`与评估`((w x) y) z`是相同的。这应该不会让人感到惊讶。我们已经看到这就是部分应用的工作方式。如果你将x看作一个具有两个参数的函数，那么`(x
    y) z`就是对第一个参数进行部分应用的结果，然后将z参数传递给中间函数。
- en: If you do want to do right association, you can use explicit parentheses, or
    you can use a pipe. The following three forms are equivalent.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要进行右结合，你可以使用显式括号，或者你可以使用一个管道。以下三种形式是等价的。
- en: '[PRE117]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: As an exercise, work out the signatures for these functions without actually
    evaluating them!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，计算出这些函数的签名，而不实际评估它们！
- en: Function composition
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组合
- en: We've mentioned function composition a number of times in passing now, but what
    does it actually mean? It can seem quite intimidating at first, but it is actually
    quite simple.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在路过中多次提到函数组合，但它实际上是什么意思？起初可能看起来很吓人，但实际上它非常简单。
- en: Say that you have a function "f" that maps from type "T1" to type "T2", and
    say that you also have a function "g" that maps from type "T2" to type "T3". Then
    you can connect the output of "f" to the input of "g", creating a new function
    that maps from type "T1" to type "T3".
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个从类型"T1"到类型"T2"的映射函数"f"，并且你还有一个从类型"T2"到类型"T3"的映射函数"g"。那么你可以将"f"的输出连接到"g"的输入，创建一个从类型"T1"到类型"T3"的新函数。
- en: '![](Functions_Composition.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](Functions_Composition.png)'
- en: Here's an example
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子
- en: '[PRE118]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We can create a new function h that takes the output of "f" and uses it as the
    input for "g".
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新函数h，它接受"f"的输出并将其用作"g"的输入。
- en: '[PRE119]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'A much more compact way is this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更加紧凑的方式是这样的：
- en: '[PRE120]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: So far, so straightforward. What is interesting is that we can define a new
    function called "compose" that, given functions "f" and "g", combines them in
    this way without even knowing their signatures.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很简单。有趣的是，我们可以定义一个名为"compose"的新函数，它可以在不知道它们签名的情况下，将函数"f"和"g"以这种方式组合起来。
- en: '[PRE121]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'If you evaluate this, you will see that the compiler has correctly deduced
    that if "`f`" is a function from generic type `''a` to generic type `''b`, then
    "`g`" is constrained to have generic type `''b` as an input. And the overall signature
    is:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你评估这个，你会看到编译器已经正确推断出如果"`f`"是一个从通用类型`'a`到通用类型`'b`的函数，那么"`g`"被限制为具有通用类型`'b`作为输入。整体签名是：
- en: '[PRE122]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: (Note that this generic composition operation is only possible because every
    function has one input and one output. This approach would not be possible in
    a non-functional language.)
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，这种通用的组合操作之所以可能，是因为每个函数都有一个输入和一个输出。在非函数式语言中，这种方法是不可能的。）
- en: As we have seen, the actual definition of compose uses the "`>>`" symbol.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，compose的实际定义使用"`>>`"符号。
- en: '[PRE123]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Given this definition, we can now use composition to build new functions from
    existing ones.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个定义，我们现在可以使用组合来从现有函数构建新函数。
- en: '[PRE124]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This explicit style is quite cluttered. We can do a few things to make it easier
    to use and understand.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这种显式风格相当凌乱。我们可以做一些事情使其更易于使用和理解。
- en: First, we can leave off the x parameter so that the composition operator returns
    a partial application.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以省略x参数，以便组合运算符返回一个部分应用。
- en: '[PRE125]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: And now we have a binary operation, so we can put the operator in the middle.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个二元操作，所以我们可以把操作符放在中间。
- en: '[PRE126]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: And there you have it. Using the composition operator allows code to be cleaner
    and more straightforward.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。使用组合运算符可以使代码更清晰、更简单。
- en: '[PRE127]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Using the composition operator in practice
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实践中使用组合运算符
- en: The composition operator (like all infix operators) has lower precedence than
    normal function application. This means that the functions used in composition
    can have arguments without needing to use parentheses.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 组合运算符（像所有中缀运算符一样）的优先级低于普通的函数应用。这意味着在组合中使用的函数可以具有参数，而无需使用括号。
- en: For example, if the "add" and "times" functions have an extra parameter, this
    can be passed in during the composition.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果“add”和“times”函数有额外的参数，这些参数可以在组合过程中传递。
- en: '[PRE128]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'As long as the inputs and outputs match, the functions involved can use any
    kind of value. For example, consider the following, which performs a function
    twice:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 只要输入和输出匹配，涉及的函数可以使用任何类型的值。例如，考虑下面的示例，该示例执行一个函数两次：
- en: '[PRE129]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Note that the compiler has deduced that the function f must use the same type
    for both input and output.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，编译器已经推断出函数 f 必须对输入和输出使用相同的类型。
- en: 'Now consider a function like "`+`". As we have seen earlier, the input is an
    `int`, but the output is actually a partially applied function `(int->int)`. The
    output of "`+`" can thus be used as the input of "`twice`". So we can write something
    like:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个函数“`+`”。正如我们之前所看到的，输入是一个`int`，但输出实际上是一个部分应用的函数`(int->int)`。因此，“+”的输出可以用作“twice”的输入。因此我们可以写出像这样的东西：
- en: '[PRE130]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'On the other hand, we can''t write something like:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们不能写出像这样的东西：
- en: '[PRE131]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: because the input to "*" must be an `int` value, not an `int->int` function
    (which is what the output of addition is).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 因为“*”的输入必须是`int`值，而不是`int->int`函数（这是加法的输出）。
- en: 'But if we tweak it so that the first function has an output of just `int` instead,
    then it does work:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们将第一个函数的输出调整为仅是`int`，那么就可以工作了：
- en: '[PRE132]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Composition can also be done backwards using the "`<<`" operator, if needed.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，组合也可以使用“`<<`”运算符进行反向操作。
- en: '[PRE133]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Reverse composition is mainly used to make code more English-like. For example,
    here is a simple example:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 反向组合主要用于使代码更接近英语。例如，这是一个简单的例子：
- en: '[PRE134]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Composition vs. pipeline
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合 vs. 管道
- en: At this point, you might be wondering what the difference is between the composition
    operator and the pipeline operator, as they can seem quite similar.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会想知道组合运算符和管道运算符之间的区别，因为它们看起来可能非常相似。
- en: 'First let''s look again at the definition of the pipeline operator:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们再次看一下管道运算符的定义：
- en: '[PRE135]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: All it does is allow you to put the function argument in front of the function
    rather than after. That's all. If the function has multiple parameters, then the
    input would be the final parameter. Here's the example used earlier.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是允许您将函数参数放在函数之前而不是之后。仅此而已。如果函数有多个参数，则输入将是最后一个参数。以下是之前使用的示例。
- en: '[PRE136]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Composition is not the same thing and cannot be a substitute for a pipe. In
    the following case the number 3 is not even a function, so its "output" cannot
    be fed into `doSomething`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 组合不是相同的概念，也不能替代管道。在以下情况下，数字 3 甚至不是一个函数，因此其“输出”无法被传递到`doSomething`中：
- en: '[PRE137]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The compiler is complaining that "3" should be some sort of function `'a->'b`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器抱怨说“3”应该是某种函数`'a->'b`。
- en: Compare this with the definition of composition, which takes 3 arguments, where
    the first two must be functions.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与组合的定义进行比较，组合需要 3 个参数，其中前两个必须是函数。
- en: '[PRE138]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Trying to use a pipe instead doesn't work. In the following example, "`add 1`"
    is a (partial) function of type `int->int`, and cannot be used as the second parameter
    of "`times 2`".
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用管道代替也行不通。在以下示例中，“`add 1`”是一个（部分）类型为`int->int`的函数，并且不能用作“`times 2`”的第二个参数。
- en: '[PRE139]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The compiler is complaining that "`times 2`" should take an `int->int` parameter,
    that is, be of type `(int->int)->'a`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器抱怨说“`times 2`”应该接受一个`int->int`参数，即类型应为`(int->int)->'a`。
- en: Defining functions
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数
- en: Defining functions
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'We have seen how to create typical functions using the "let" syntax, below:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用“let”语法创建典型函数，如下所示：
- en: '[PRE140]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: In this section, we'll look at some other ways of creating functions, and tips
    for defining functions.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍创建函数的其他方法以及定义函数的技巧。
- en: Anonymous functions (a.k.a. lambdas)
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数（又名 lambda）
- en: 'If you are familiar with lambdas in other languages, this will not be new to
    you. An anonymous function (or "lambda expression") is defined using the form:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他语言中的 lambda，这对你来说并不新鲜。使用形式定义匿名函数（或“lambda 表达式”）：
- en: '[PRE141]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If you are used to lambdas in C# there are a couple of differences:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于在 C# 中使用 lambda，那么有一些不同之处：
- en: the lambda must have the special keyword `fun`, which is not needed in the C#
    version
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda必须具有特殊关键字`fun`，在C#版本中不需要
- en: the arrow symbol is a single arrow `->` rather than the double arrow (`=>`)
    in C#.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头符号是单箭头`->`，而不是C#中的双箭头(`=>`)。
- en: 'Here is a lambda that defines addition:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个定义加法的lambda：
- en: '[PRE142]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'This is exactly the same as a more conventional function definition:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这与更传统的函数定义完全相同：
- en: '[PRE143]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Lambdas are often used when you have a short expression and you don't want to
    define a function just for that expression. This is particularly common with list
    operations, as we have seen already.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个简短的表达式并且不想为该表达式定义一个函数时，通常会使用lambda。这在列表操作中特别常见，正如我们已经看到的。
- en: '[PRE144]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note that you must use parentheses around the lambda.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你必须在lambda周围使用括号。
- en: Lambdas are also used when you want to make it clear that you are returning
    a function from another function. For example, the "`adderGenerator`" function
    that we talked about earlier could be rewritten with a lambda.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要明确地表明你正在从另一个函数返回一个函数时，也会使用lambda。例如，我们之前讨论过的"`adderGenerator`"函数可以用lambda重写。
- en: '[PRE145]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The lambda version is slightly longer, but makes it clear that an intermediate
    function is being returned.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: lambda版本略长，但清楚地表明正在返回一个中间函数。
- en: You can nest lambdas as well. Here is yet another definition of `adderGenerator`,
    this time using lambdas only.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以嵌套lambda。这里是`adderGenerator`的另一种定义，这次只使用lambda。
- en: '[PRE146]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Can you see that all three of the following definitions are the same thing?
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到以下三个定义都是相同的吗？
- en: '[PRE147]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: If you can't see it, then do reread the [post on currying](currying.html). This
    is important stuff to understand!
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不懂，那就重新阅读一下[有关柯里化的文章](currying.html)。这是很重要的理解内容！
- en: Pattern matching on parameters
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在参数上进行模式匹配
- en: When defining a function, you can pass an explicit parameter, as we have seen,
    but you can also pattern match directly in the parameter section. In other words,
    the parameter section can contain *patterns*, not just identifiers!
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，你可以传递一个显式参数，正如我们所见，但你也可以直接在参数部分进行模式匹配。换句话说，参数部分可以包含*模式*，而不仅仅是标识符！
- en: 'The following example demonstrates how to use patterns in a function definition:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何在函数定义中使用模式：
- en: '[PRE148]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This kind of matching can only occur when the matching is always possible. For
    example, you cannot match on union types or lists this way, because some cases
    might not be matched.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这种匹配只有在匹配总是可能时才会发生。例如，你不能以这种方式匹配联合类型或列表，因为有些情况可能无法匹配。
- en: '[PRE149]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: You will get a warning about incomplete pattern matches.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到有关不完整模式匹配的警告。
- en: 'A common mistake: tuples vs. multiple parameters'
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个常见的错误：元组与多个参数
- en: If you come from a C-like language, a tuple used as a single function parameter
    can look awfully like multiple parameters. They are not the same thing at all!
    As I noted earlier, if you see a comma, it is probably part of a tuple. Parameters
    are separated by spaces.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自类C语言，一个元组作为单个函数参数看起来可能与多个参数非常相似。它们根本不是同一回事！正如我之前指出的，如果你看到逗号，那可能是元组的一部分。参数用空格分隔。
- en: 'Here is an example of the confusion:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是混淆的一个例子：
- en: '[PRE150]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The first definition, "`addTwoParams`", takes two parameters, separated with
    spaces.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个定义，"`addTwoParams`"，接受两个用空格分隔的参数。
- en: The second definition, "`addTuple`", takes a single parameter. It then binds
    "x" and "y" to the inside of the tuple and does the addition.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个定义，"`addTuple`"，接受一个参数。然后将"x"和"y"绑定到元组的内部并进行加法运算。
- en: The third definition, "`addConfusingTuple`", takes a single parameter just like
    "`addTuple`", but the tricky thing is that the tuple is unpacked and bound as
    part of the parameter definition using pattern matching. Behind the scenes, it
    is exactly the same as "`addTuple`".
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个定义，"`addConfusingTuple`"，接受一个参数，就像"`addTuple`"一样，但棘手的地方在于元组被解包并作为参数定义的一部分使用模式匹配绑定。在幕后，它与"`addTuple`"完全相同。
- en: Let's look at the signatures (it is always a good idea to look at the signatures
    if you are unsure)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下签名（如果你不确定，查看签名总是一个好主意）
- en: '[PRE151]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now let''s use them:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用它们：
- en: '[PRE152]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Here we can see an error occur in the second case above.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第二种情况中我们可以看到一个错误发生。
- en: First, the compiler treats `(1,2)` as a generic tuple of type `('a * 'b)`, which
    it attempts to pass as the first parameter to "`addTwoParams`". Then it complains
    that the first parameter of `addTwoParams` is an `int`, and we're trying to pass
    a tuple.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器将`(1,2)`视为类型为`('a * 'b)`的通用元组，它试图将其作为第一个参数传递给"`addTwoParams`"。然后它抱怨`addTwoParams`的第一个参数是一个`int`，而我们正在尝试传递一个元组。
- en: 'To make a tuple, use a comma! Here''s how to do it correctly:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建元组，请使用逗号！以下是正确的做法：
- en: '[PRE153]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Conversely, if you attempt to pass multiple arguments to a function expecting
    a tuple, you will also get an obscure error.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果您尝试向期望元组的函数传递多个参数，您还将收到一个晦涩的错误。
- en: '[PRE154]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In this case, the compiler thinks that, since you are passing two arguments,
    `addConfusingTuple` must be curryable. So then "`addConfusingTuple 1`" would be
    a partial application that returns another intermediate function. Trying to apply
    that intermediate function with "2" gives an error, because there is no intermediate
    function! We saw this exact same error in the post on currying, when we discussed
    the issues that can occur from having too many parameters.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器认为，由于您正在传递两个参数，`addConfusingTuple`必须是可柯里化的。所以 "`addConfusingTuple
    1`" 将是一个返回另一个中间函数的部分应用。尝试使用"2"应用该中间函数会导致错误，因为没有中间函数！我们在关于柯里化的帖子中看到了完全相同的错误，当我们讨论由于具有太多参数而可能发生的问题时。
- en: Why not use tuples as parameters?
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么不使用元组作为参数？
- en: 'The discussion of the issues with tuples above shows that there''s another
    way to define functions with more than one parameter: rather than passing them
    in separately, all the parameters can be combined into a single composite data
    structure. In the example below, the function takes a single parameter, which
    is a tuple containing three items.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 上面关于元组的问题讨论表明，有另一种定义多个参数的函数的方法：而不是分别传递它们，所有参数都可以合并到单个复合数据结构中。在下面的示例中，函数接受一个单一参数，该参数是一个包含三个项目的元组。
- en: '[PRE155]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Note that the function signature is different from a true three parameter function.
    There is only one arrow, so only one parameter, and the stars indicate that this
    is a tuple of `(int*int*int)`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数签名与真正的三个参数函数不同。只有一个箭头，所以只有一个参数，并且星号表示这是一个`(int*int*int)`的元组。
- en: When would we want to use tuple parameters instead of individual ones?
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候我们会想要使用元组参数而不是单独的参数？
- en: When the tuples are meaningful in themselves. For example, if we are working
    with three dimensional coordinates, a three-tuple might well be more convenient
    than three separate dimensions.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元组本身有意义时。例如，如果我们使用三维坐标，三元组可能比三个单独的维度更方便。
- en: Tuples are occasionally used to bundle data together in a single structure that
    should be kept together. For example, the `TryParse` functions in .NET library
    return the result and a Boolean as a tuple. But if you have a lot of data that
    is kept together as a bundle, then you will probably want to define a record or
    class type to store it.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时会使用元组将数据捆绑在一起，以便保持在一起。例如，.NET库中的`TryParse`函数以元组形式返回结果和布尔值。但是，如果有大量数据作为捆绑在一起，则可能希望定义一个记录或类类型来存储它。
- en: 'A special case: tuples and .NET library functions'
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特例：元组和.NET库函数
- en: One area where commas are seen a lot is when calling .NET library functions!
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号经常出现的一个领域是调用.NET库函数！
- en: 'These all take tuple-like arguments, and so these calls look just the same
    as they would from C#:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都需要类似元组的参数，因此这些调用看起来与从C#调用的方式完全相同：
- en: '[PRE156]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The reason is that .NET library functions are not curried and cannot be partially
    applied. *All* the parameters must *always* be passed in, and using a tuple-like
    approach is the obvious way to do this.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是.NET库函数不是柯里化的，也不能部分应用。 *所有*参数必须*始终*被传递，并且使用类似元组的方法是显而易见的方法。
- en: 'But do note that although these calls look like tuples, they are actually a
    special case. Real tuples cannot be used, so the following code is invalid:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，尽管这些调用看起来像元组，但它们实际上是一个特例。真正的元组不能使用，因此以下代码是无效的：
- en: '[PRE157]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'If you do want to partially apply .NET library functions, it is normally trivial
    to write wrapper functions for them, as we have [seen earlier](partial-application.html),
    and as shown below:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实想部分应用.NET库函数，通常可以轻松为它们编写包装函数，就像我们之前所见的那样，并如下所示：
- en: '[PRE158]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Guidelines for separate vs. grouped parameters
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单独参数与分组参数的指南
- en: 'The discussion on tuples leads us to a more general topic: when should function
    parameters be separate and when should they be grouped?'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 对元组的讨论引出了一个更一般的话题：函数参数应该何时分离，何时分组？
- en: Note that F# is different from C# in this respect. In C# *all* the parameters
    are *always* provided, so the question does not even arise! In F#, due to partial
    application, only some parameters might be provided, so you need to distinguish
    between those that are required to be grouped together vs. those that are independent.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，在这方面F#与C#不同。在C#中，*所有*参数都*始终*提供，因此甚至不会提出这个问题！在F#中，由于部分应用，可能只提供了一些参数，因此您需要区分必须分组在一起的参数与独立参数。 '
- en: Here are some general guidelines of how to structure parameters when you are
    designing your own functions.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设计自己的函数时，以下是一些一般性参数结构指南。
- en: In general, it is always better to use separate parameters rather than passing
    them as a single structure such as a tuple or record. This allows for more flexible
    behavior such as partial application.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，最好始终使用单独的参数而不是将它们作为元组或记录等单个结构传递。这样可以获得更灵活的行为，例如部分应用。
- en: But, when a group of parameters *must* all be set at once, then *do* use some
    sort of grouping mechanism.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，当一组参数*必须*一次设置时，请*使用*某种分组机制。
- en: In other words, when designing a function, ask yourself "could I provide this
    parameter in isolation?" If the answer is no, the parameters should be grouped.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在设计函数时，问自己“我能单独提供这个参数吗？” 如果答案是否定的，那么这些参数应该被分组。
- en: 'Let''s look at some examples:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子：
- en: '[PRE159]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Finally, do be sure to order the parameters appropriately to assist with partial
    application (see the guidelines in the earlier [post](partial-application.html)).
    For example, in the last function above, why did I put the `myCredentials` parameter
    ahead of the `aName` parameter?
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请确保按适当顺序排列参数，以协助部分应用（请参阅前面[文章](partial-application.html)中的指南）。例如，在上面的最后一个函数中，为什么我把`myCredentials`参数放在`aName`参数前面？
- en: Parameter-less functions
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无参数函数
- en: Sometimes we may want functions that don't take any parameters at all. For example,
    we may want a "hello world" function that we can call repeatedly. As we saw in
    a previous section, the naive definition will not work.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能希望函数根本不需要任何参数。例如，我们可能想要一个可以重复调用的“hello world”函数。正如我们在前一节中看到的，朴素的定义将不起作用。
- en: '[PRE160]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The fix is to add a unit parameter to the function, or use a lambda.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是向函数添加一个单元参数，或者使用lambda。
- en: '[PRE161]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'And then the function must always be called with a unit argument:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 然后函数必须始终使用单元参数调用：
- en: '[PRE162]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'This is particularly common with the .NET libraries. Some examples are:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这在.NET库中特别常见。一些例子包括：
- en: '[PRE163]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Do remember to call them with the unit parameter!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住使用单元参数调用它们！
- en: Defining new operators
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义新操作符
- en: 'You can define functions named using one or more of the operator symbols (see
    the [F# documentation](http://msdn.microsoft.com/en-us/library/dd233204) for the
    exact list of symbols that you can use):'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义使用一个或多个操作符符号命名的函数（参见[F#文档](http://msdn.microsoft.com/en-us/library/dd233204)以获取可使用的符号的确切列表）：
- en: '[PRE164]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: You must use parentheses around the symbols when defining them.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 定义它们时必须在符号周围加括号。
- en: 'Note that for custom operators that begin with `*`, a space is required; otherwise
    the `(*` is interpreted as the start of a comment:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于以`*`开头的自定义操作符，需要空格；否则，`(*`会被解释为注释的开始：
- en: '[PRE165]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Once defined, the new function can be used in the normal way, again with parens
    around the symbols:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 定义后，新函数可以按正常方式使用，再次在符号周围加上括号：
- en: '[PRE166]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: If the function has exactly two parameters, you can use it as an infix operator
    without parentheses.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数恰好有两个参数，您可以将其用作中缀运算符，而无需括号。
- en: '[PRE167]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: You can also define prefix operators that start with `!` or `~` (with some restrictions
    -- see the [F# documentation on operator overloading](http://msdn.microsoft.com/en-us/library/dd233204#prefix))
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义以`!`或`~`开头的前缀运算符（有一些限制——请参阅[F#操作符重载文档](http://msdn.microsoft.com/en-us/library/dd233204#prefix)）
- en: '[PRE168]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: In F# it is quite common to create your own operators, and many libraries will
    export operators with names such as `>=>` and `<*>`.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，创建自己的操作符非常常见，并且许多库将导出具有诸如`>=>`和`<*>`等名称的操作符。
- en: Point-free style
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点无关风格
- en: We have already seen many examples of leaving off the last parameter of functions
    to reduce clutter. This style is referred to as **point-free style** or **tacit
    programming**.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到很多例子，省略函数的最后一个参数以减少混乱。这种风格称为**点无关风格**或**沉默编程**。
- en: 'Here are some examples:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE169]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: There are pros and cons to this style.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格有其利弊。
- en: On the plus side, it focuses attention on the high level function composition
    rather than the low level objects. For example "`(+) 1 >> (*) 2`" is clearly an
    addition operation followed by a multiplication. And "`List.reduce (+)`" makes
    it clear that the plus operation is key, without needing to know about the list
    it is actually applied to.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是，它将注意力集中在高级函数组合上，而不是低级对象上。例如 "`(+) 1 >> (*) 2`" 明显是一个加法操作，然后是一个乘法操作。而 "`List.reduce
    (+)`" 明确表明加法操作是关键，而无需了解实际应用到的列表。
- en: Point-free helps to clarify the underlying algorithm and reveal commonalities
    between code -- the "`reduce`" function used above is a good example of this --
    it will be discussed in a planned series on list processing.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 无点风格有助于澄清底层算法，并揭示代码之间的共同点——上面使用的 "`reduce`" 函数就是一个很好的例子——这将在计划中的列表处理系列中讨论。
- en: On the other hand, too much point-free style can make for confusing code. Explicit
    parameters can act as a form of documentation, and their names (such as "list")
    make it clear what the function is acting on.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，过多的无点风格可能导致混乱的代码。显式参数可以作为一种文档形式，它们的名称（如 "list"）清楚地表明函数作用的对象是什么。
- en: As with anything in programming, the best guideline is to use the approach that
    provides the most clarity.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 与编程中的任何事物一样，最佳指导原则是使用提供最大清晰度的方法。
- en: Combinators
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合子
- en: The word "**combinator**" is used to describe functions whose result depends
    only on their parameters. That means there is no dependency on the outside world,
    and in particular no other functions or global value can be accessed at all.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '"**组合子**" 这个词用来描述其结果仅取决于其参数的函数。这意味着没有对外部世界的依赖，特别是不能访问其他函数或全局值。'
- en: In practice, this means that a combinator function is limited to combining its
    parameters in various ways.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着组合子函数受限于以各种方式组合其参数。
- en: 'We have already seen some combinators already: the "pipe" operator and the
    "compose" operator. If you look at their definitions, it is clear that all they
    do is reorder the parameters in various ways'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些组合子： "pipe" 运算符和 "compose" 运算符。如果您查看它们的定义，很明显它们只是以不同方式重新排列参数。
- en: '[PRE170]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: On the other hand, a function like "printf", although primitive, is not a combinator,
    because it has a dependency on the outside world (I/O).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，像 "printf" 这样的函数虽然原始，但不是一个组合子，因为它对外部世界（I/O）有依赖。
- en: Combinator birds
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合子鸟类
- en: Combinators are the basis of a whole branch of logic (naturally called "combinatory
    logic") that was invented many years before computers and programming languages.
    Combinatory logic has had a very large influence on functional programming.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 组合子是整个逻辑分支的基础（自然地称为 "组合逻辑"），在计算机和编程语言出现很多年之前就被发明。组合逻辑对函数式编程产生了很大的影响。
- en: 'To read more about combinators and combinatory logic, I recommend the book
    "To Mock a Mockingbird" by Raymond Smullyan. In it, he describes many other combinators
    and whimsically gives them names of birds. Here are some examples of some standard
    combinators and their bird names:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多有关组合子和组合逻辑的内容，我推荐 Raymond Smullyan 的书籍《To Mock a Mockingbird》。在书中，他描述了许多其他组合子，并幽默地给它们取了鸟类的名字。以下是一些标准组合子及其鸟类名称的示例：
- en: '[PRE171]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The letter names are quite standard, so if you refer to "the K combinator",
    everyone will be familiar with that terminology.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字母名称非常标准，因此如果你提到 "K 组合子"，每个人都会熟悉这个术语。
- en: It turns out that many common programming patterns can be represented using
    these standard combinators. For example, the Kestrel is a common pattern in fluent
    interfaces where you do something but then return the original object. The Thrush
    is the pipe operation, the Queer bird is forward composition, and the Y-combinator
    is famously used to make functions recursive.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，许多常见的编程模式可以使用这些标准组合子来表示。例如，Kestrel 是流畅接口中的常见模式，您执行某些操作然后返回原始对象。Thrush 是管道操作，Queer
    bird 是前向组合，而 Y 组合子被广泛用于使函数递归。
- en: Indeed, there is a well-known theorem that states that any computable function
    whatsoever can be built from just two basic combinators, the Kestrel and the Starling.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一个著名的定理表明，任何可计算的函数都可以由两个基本组合子——Kestrel 和 Starling 构建。
- en: Combinator libraries
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合子库
- en: A combinator library is a code library that exports a set of combinator functions
    that are designed to work together. The user of the library can then easily combine
    simple functions together to make bigger and more complex functions, like building
    with Lego.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 组合子库是一个代码库，它导出一组旨在共同工作的组合子函数。库的用户可以轻松地将简单函数组合在一起，以创建更大更复杂的函数，就像用乐高积木搭建一样。
- en: A well designed combinator library allows you to focus on the high level operations,
    and push the low level "noise" to the background. We've already seen some examples
    of this power in the examples in ["why use F#"](why-use-fsharp.html) series, and
    the `List` module is full of them -- the "`fold`" and "`map`" functions are also
    combinators, if you think about it.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的组合子库可以让您专注于高层操作，并将低级“噪音”推到后台。在 ["为什么使用 F#"](why-use-fsharp.html) 系列中，我们已经看到了一些这种力量的例子，`List`
    模块中充满了它们——“`fold`”和“`map`”函数也是组合子，如果您仔细考虑的话。
- en: Another advantage of combinators is that they are the safest type of function.
    As they have no dependency on the outside world they cannot change if the global
    environment changes. A function that reads a global value or uses a library function
    can break or alter between calls if the context is different. This can never happen
    with combinators.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组合子的优势是它们是最安全的函数类型。由于它们不依赖于外部世界，因此如果全局环境发生变化，它们就不会发生变化。一个读取全局值或使用库函数的函数在不同的上下文中调用时可能会中断或改变。而组合子永远不会发生这种情况。
- en: In F#, combinator libraries are available for parsing (the FParsec library),
    HTML construction, testing frameworks, and more. We'll discuss and use combinators
    further in later series.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，组合子库可用于解析（FParsec 库）、HTML 构建、测试框架等等。我们将在后续系列中进一步讨论和使用组合子。
- en: Recursive functions
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数
- en: 'Often, a function will need to refer to itself in its body. The classic example
    is the Fibonacci function:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个函数在其主体中需要引用它自己。经典的例子是斐波那契函数：
- en: '[PRE172]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Unfortunately, this will not compile:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这将无法编译：
- en: '[PRE173]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: You have to tell the compiler that this is a recursive function using the rec
    keyword.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用rec关键字告诉编译器这是一个递归函数。
- en: '[PRE174]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Recursive functions and data structures are extremely common in functional programming,
    and I hope to devote a whole later series to this topic.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数和数据结构在函数式编程中非常常见，我希望将来能专门讨论这个主题。
- en: Function signatures
  id: totrans-639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数签名
- en: Function signatures
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数签名
- en: 'It may not be obvious, but F# actually has two syntaxes - one for normal (value)
    expressions, and one for type definitions. For example:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 或许不太明显，但 F# 实际上有两种语法——一种用于普通（值）表达式，另一种用于类型定义。例如：
- en: '[PRE175]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Type expressions have a special syntax that is *different* from the syntax used
    in normal expressions. You have already seen many examples of this when you use
    the interactive session, because the type of each expression has been printed
    along with its evaluation.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表达式具有与常规表达式不同的特殊语法。当您使用交互式会话时，已经看到了许多此类示例，因为每个表达式的类型都与其评估一起打印出来了。
- en: As you know, F# uses type inference to deduce types, so you don't often need
    to explicitly specify types in your code, especially for functions. But in order
    to work effectively in F#, you *do* need to understand the type syntax, so that
    you can build your own types, debug type errors, and understand function signatures.
    In this post, we'll focus on its use in function signatures.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，F# 使用类型推断来推导类型，因此您不经常需要在代码中明确指定类型，特别是对于函数而言。但是为了有效地在 F# 中工作，您确实需要理解类型语法，以便可以构建自己的类型、调试类型错误并理解函数签名。在本文中，我们将专注于其在函数签名中的使用。
- en: 'Here are some example function signatures using the type syntax:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些使用类型语法的示例函数签名：
- en: '[PRE176]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Understanding functions through their signatures
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过它们的签名来理解函数
- en: Just by examining a function's signature, you can often get some idea of what
    it does. Let's look at some examples and analyze them in turn.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过检查函数的签名，您通常可以大致了解其功能。让我们看一些示例并依次分析它们。
- en: '[PRE177]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: This function takes two `int` parameters and returns another, so presumably
    it is some sort of mathematical function such as addition, subtraction, multiplication,
    or exponentiation.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个`int`参数并返回另一个，所以很可能是某种数学函数，如加法、减法、乘法或指数运算。
- en: '[PRE178]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: This function takes an `int` and returns a `unit`, which means that the function
    is doing something important as a side-effect. Since there is no useful return
    value, the side effect is probably something to do with writing to IO, such as
    logging, writing to a file or database, or something similar.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个`int`并返回一个`unit`，这意味着函数作为副作用执行了一些重要的操作。由于没有有用的返回值，副作用可能与写入IO有关，比如记录日志、写入文件或数据库，或者类似的操作。
- en: '[PRE179]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: This function takes no input but returns a `string`, which means that the function
    is conjuring up a string out of thin air! Since there is no explicit input, the
    function probably has something to do with reading (from a file say) or generating
    (a random string, say).
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不接受任何输入，但返回一个`string`，这意味着函数从虚空中创造一个字符串！由于没有明确的输入，该函数可能与读取（比如从文件中）或生成（比如生成随机字符串）有关。
- en: '[PRE180]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: This function takes an `int` input and returns a function that when called,
    returns strings. Again, the function probably has something to do with reading
    or generating. The input probably initializes the returned function somehow. For
    example, the input could be a file handle, and the returned function something
    like `readline()`. Or the input could be a seed for a random string generator.
    We can't tell exactly, but we can make some educated guesses.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个`int`输入，并返回一个函数，当调用它时，返回字符串。同样，该函数可能与读取或生成有关。输入可能以某种方式初始化返回的函数。例如，输入可以是一个文件句柄，返回的函数类似于`readline()`。或者输入可以是一个随机字符串生成器的种子。我们不能确定，但我们可以做出一些有根据的猜测。
- en: '[PRE181]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: This function takes a list of some type, but returns only one of that type,
    which means that the function is merging or choosing elements from the list. Examples
    of functions with this signature are `List.sum`, `List.max`, `List.head` and so
    on.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受某种类型的列表，但仅返回其中的一个相同类型的元素，这意味着函数正在合并或选择列表中的元素。具有这种签名的函数示例包括`List.sum`、`List.max`、`List.head`等。
- en: '[PRE182]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'This function takes two parameters: the first is a function that maps something
    to a bool (a predicate), and the second is a list. The return value is a list
    of the same type. Predicates are used to determine whether a value meets some
    sort of criteria, so it looks like the function is choosing elements from the
    list based on whether the predicate is true or not and then returning a subset
    of the original list. A typical function with this signature is `List.filter`.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数：第一个是将某物映射到布尔值（谓词）的函数，第二个是一个列表。返回值是相同类型的列表。谓词用于确定值是否符合某种条件，因此看起来函数根据谓词是否为真来选择列表中的元素，然后返回原始列表的子集。具有这种签名的典型函数是`List.filter`。
- en: '[PRE183]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'This function takes two parameters: the first maps type `''a` to type `''b`,
    and the second is a list of `''a`. The return value is a list of a different type
    `''b`. A reasonable guess is that the function takes each of the `''a`s in the
    list, maps them to a `''b` using the function passed in as the first parameter,
    and returns the new list of `''b`s. And indeed, the prototypical function with
    this signature is `List.map`.'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数：第一个将类型`'a`映射到类型`'b`，第二个是`'a`的列表。返回值是不同类型`'b`的列表。一个合理的猜测是，该函数接受列表中的每个`'a`，使用作为第一个参数传递的函数将它们映射到`'b`，然后返回`'b`的新列表。的确，具有这种签名的原型函数是`List.map`。
- en: Using function signatures to find a library method
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数签名查找库方法
- en: Function signatures are an important part of searching for library functions.
    The F# libraries have hundreds of functions in them and they can initially be
    overwhelming. Unlike an object oriented language, you cannot simply "dot into"
    an object to find all the appropriate methods. However, if you know the signature
    of the function you are looking for, you can often narrow down the list of candidates
    quickly.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名是搜索库函数的重要部分。F# 库中有数百个函数，最初可能会让人感到不知所措。与面向对象的语言不同，你不能简单地“点进”一个对象来找到所有合适的方法。然而，如果你知道你要查找的函数的签名，你通常可以迅速缩小候选列表。
- en: 'For example, let''s say you have two lists and you are looking for a function
    to combine them into one. What would the signature be for this function? It would
    take two list parameters and return a third, all of the same type, giving the
    signature:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有两个列表，你正在寻找一个函数来将它们合并成一个。这个函数的签名会是什么？它将接受两个列表参数并返回第三个，所有类型相同，给出的签名为：
- en: '[PRE184]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Now go to the [MSDN documentation for the F# List module](http://msdn.microsoft.com/en-us/library/ee353738),
    and scan down the list of functions, looking for something that matches. As it
    happens, there is only one function with that signature:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 现在去[MSDN F# List 模块文档](http://msdn.microsoft.com/en-us/library/ee353738) ，并向下扫描函数列表，查找与之匹配的内容。碰巧，只有一个函数具有该签名：
- en: '[PRE185]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: which is exactly the one we want!
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的！
- en: Defining your own types for function signatures
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为函数签名定义自己的类型
- en: 'Sometimes you may want to create your own types to match a desired function
    signature. You can do this using the "type" keyword, and define the type in the
    same way that a signature is written:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望创建自己的类型以匹配所需的函数签名。您可以使用“type”关键字来实现这一点，并且像编写签名一样定义类型：
- en: '[PRE186]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: You can then use these types to constrain function values and parameters.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些类型来约束函数值和参数。
- en: For example, the second definition below will fail because of type constraints.
    If you remove the type constraint (as in the third definition) there will not
    be any problem.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的第二个定义将因为类型约束而失败。如果删除类型约束（如第三个定义中所示），将不会有任何问题。
- en: '[PRE187]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Test your understanding of function signatures
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你对函数签名的理解。
- en: How well do you understand function signatures? See if you can create simple
    functions that have each of these signatures. Avoid using explicit type annotations!
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 你对函数签名了解多少？看看你是否可以创建具有这些签名的简单函数。避免使用显式类型注释！
- en: '[PRE188]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Organizing functions
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织函数
- en: Organizing functions
  id: totrans-680
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织函数
- en: Now that you know how to define functions, how can you organize them?
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何定义函数了，你如何组织它们呢？
- en: 'In F#, there are three options:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，有三个选项：
- en: functions can be nested inside other functions.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以嵌套在其他函数中。
- en: at an application level, the top level functions are grouped into "modules".
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序级别，顶级函数被分组到“模块”中。
- en: alternatively, you can also use the object-oriented approach and attach functions
    to types as methods.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您也可以使用面向对象的方法，并将函数附加到类型作为方法。
- en: We'll look at the first two options in this post, and the third in the next
    post.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这篇文章中看看前两个选项，第三个选项将在下一篇文章中看到。
- en: Nested Functions
  id: totrans-687
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: In F#, you can define functions inside other functions. This is a great way
    to encapsulate "helper" functions that are needed for the main function but shouldn't
    be exposed outside.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，您可以在其他函数内定义函数。这是封装“辅助”函数的绝佳方式，这些函数对于主函数是必需的，但不应该在外部暴露。
- en: 'In the example below `add` is nested inside `addThreeNumbers`:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中`add`嵌套在`addThreeNumbers`内：
- en: '[PRE189]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: A nested function can access its parent function parameters directly, because
    they are in scope. So, in the example below, the `printError` nested function
    does not need to have any parameters of its own -- it can access the `n` and `max`
    values directly.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套函数可以直接访问其父函数的参数，因为它们在作用域内。所以，在下面的示例中，`printError`嵌套函数不需要有任何自己的参数 -- 它可以直接访问`n`和`max`的值。
- en: '[PRE190]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'A very common pattern is that the main function defines a nested recursive
    helper function, and then calls it with the appropriate initial values. The code
    below is an example of this:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的模式是，主函数定义一个嵌套的递归助手函数，然后用适当的初始值调用它。下面的代码是一个例子：
- en: '[PRE191]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: When nesting functions, do try to avoid very deeply nested functions, especially
    if the nested functions directly access the variables in their parent scopes rather
    than having parameters passed to them. A badly nested function will be just as
    confusing as the worst kind of deeply nested imperative branching.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套函数时，尽量避免非常深层的嵌套函数，特别是如果嵌套函数直接访问其父范围中的变量而不是将参数传递给它们。一个嵌套不良的函数将会和最糟糕的深度嵌套的命令分支一样令人困惑。
- en: 'Here''s how *not* to do it:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*不*要这样做的方法：
- en: '[PRE192]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Modules
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: A module is just a set of functions that are grouped together, typically because
    they work on the same data type or types.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 模块只是一组函数，这些函数通常因为它们作用于相同的数据类型或类型而被分组在一起。
- en: A module definition looks very like a function definition. It starts with the
    `module` keyword, then an `=` sign, and then the contents of the module are listed.
    The contents of the module *must* be indented, just as expressions in a function
    definition must be indented.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 模块定义看起来非常像函数定义。它以`module`关键字开始，然后是一个`=`号，然后列出模块的内容。模块的内容*必须*缩进，就像函数定义中的表达式必须缩进一样。
- en: 'Here''s a module that contains two functions:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含两个函数的模块：
- en: '[PRE193]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Now if you try this in Visual Studio, and you hover over the `add` function,
    you will see that the full name of the `add` function is actually `MathStuff.add`,
    just as if `MathStuff` was a class and `add` was a method.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你在Visual Studio中尝试这个，并且将鼠标悬停在`add`函数上，你会发现`add`函数的完整名称实际上是`MathStuff.add`，就像`MathStuff`是一个类而`add`是一个方法一样。
- en: 'Actually, that''s exactly what is going on. Behind the scenes, the F# compiler
    creates a static class with static methods. So the C# equivalent would be:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这正是发生的事情。在幕后，F#编译器创建了一个带有静态方法的静态类。因此，C#等价物是：
- en: '[PRE194]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: If you realize that modules are just static classes, and that functions are
    static methods, then you will already have a head-start on understanding how modules
    work in F#, as most of the rules that apply to static classes also apply to modules.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意识到模块只是静态类，并且函数是静态方法，那么你已经有了理解F#中模块如何工作的一大优势，因为大多数适用于静态类的规则也适用于模块。
- en: And, just as in C# every standalone function must be part of a class, in F#
    every standalone function *must* be part of a module.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，就像在C#中每个独立的函数必须是类的一部分一样，在F#中每个独立的函数*必须*是模块的一部分。
- en: Accessing functions across module boundaries
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨模块边界访问函数
- en: If you want to access a function in another module, you can refer to it by its
    qualified name.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要访问另一个模块中的函数，你可以通过其限定名称来引用它。
- en: '[PRE195]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: You can also import all the functions in another module with the `open` directive,
    after which you can use the short name, rather than having to specify the qualified
    name.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`open`指令导入另一个模块中的所有函数，之后你可以使用短名称，而不必指定限定名称。
- en: '[PRE196]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The rules for using qualified names are exactly as you would expect. That is,
    you can always use a fully qualified name to access a function, and you can use
    relative names or unqualified names based on what other modules are in scope.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 使用限定名称的规则正如你所期望的那样。也就是说，你总是可以使用完全限定名称来访问一个函数，并且可以根据其他模块的范围使用相对名称或不限定名称。
- en: Nested modules
  id: totrans-714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套模块
- en: 'Just like static classes, modules can contain child modules nested within them,
    as shown below:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 就像静态类一样，模块可以包含嵌套在其中的子模块，如下所示：
- en: '[PRE197]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'And other modules can reference functions in the nested modules using either
    a full name or a relative name as appropriate:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模块也可以使用全名或适当的相对名引用嵌套模块中的函数：
- en: '[PRE198]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Top level modules
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶级模块
- en: So if there can be nested child modules, that implies that, going back up the
    chain, there must always be some *top-level* parent module. This is indeed true.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果可以有嵌套的子模块，那就意味着，回溯链，必须始终存在一些*顶级*父模块。这的确是真的。
- en: Top level modules are defined slightly differently than the modules we have
    seen so far.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级模块的定义略有不同于我们到目前为止看到的模块。
- en: The `module MyModuleName` line *must* be the first declaration in the file
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module MyModuleName`行*必须*是文件中的第一个声明'
- en: There is no `=` sign
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`=`号
- en: The contents of the module are *not* indented
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的内容*不*需要缩进
- en: In general, there must be a top level module declaration present in every `.FS`
    source file. There some exceptions, but it is good practice anyway. The module
    name does not have to be the same as the name of the file, but two files cannot
    share the same module name.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，每个`.FS`源文件中必须存在一个顶级模块声明。有一些例外，但无论如何这都是一个好习惯。模块名称不必与文件名相同，但两个文件不能共享相同的模块名称。
- en: For `.FSX` script files, the module declaration is not needed, in which case
    the module name is automatically set to the filename of the script.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`.FSX`脚本文件，不需要模块声明，在这种情况下，模块名称会自动设置为脚本的文件名。
- en: 'Here is an example of `MathStuff` declared as a top level module:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将`MathStuff`声明为顶级模块的示例：
- en: '[PRE199]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Note the lack of indentation for the top level code (the contents of `module
    MathStuff`), but that the content of a nested module like `FloatLib` does still
    need to be indented.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 注意顶级代码（`module MathStuff`的内容）的缺乏缩进，但是像`FloatLib`这样的嵌套模块的内容仍然需要缩进。
- en: Other module content
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他模块内容
- en: A module can contain other declarations as well as functions, including type
    declarations, simple values and initialization code (like static constructors)
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以包含其他声明以及函数，包括类型声明、简单值和初始化代码（如静态构造函数）
- en: '[PRE200]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: By the way, if you are playing with these examples in the interactive window,
    you might want to right-click and do "Reset Session" every so often, so that the
    code is fresh and doesn't get contaminated with previous evaluations
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你在交互窗口中使用这些示例，你可能需要定期右键单击并执行“重置会话”，这样代码就是新鲜的，不会受到以前评估的影响。
- en: Shadowing
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's our example module again. Notice that `MathStuff` has an `add` function
    and `FloatLib` *also* has an `add` function.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Now what happens if I bring *both* of them into scope, and then use `add`?
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: What happened was that the `MathStuff.FloatLib` module has masked or overridden
    the original `MathStuff` module, which has been "shadowed" by `FloatLib`.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: As a result you now get a [FS0001 compiler error](index5.html#FS0001) because
    the first parameter `1` is expected to be a float. You would have to change `1`
    to `1.0` to fix this.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is invisible and easy to overlook. Sometimes you can do
    cool tricks with this, almost like subclassing, but more often, it can be annoying
    if you have functions with the same name (such as the very common `map`).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want this to happen, there is a way to stop it by using the `RequireQualifiedAccess`
    attribute. Here's the same example where both modules are decorated with it.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Now the `open` isn''t allowed:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'But we can still access the functions (without any ambiguity) via their qualified
    name:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Access Control
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: F# supports the use of standard .NET access control keywords such as `public`,
    `private`, and `internal`. The [MSDN documentation](http://msdn.microsoft.com/en-us/library/dd233188)
    has the complete details.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: These access specifiers can be put on the top-level ("let bound") functions,
    values, types and other declarations in a module. They can also be specified for
    the modules themselves (you might want a private nested module, for example).
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is public by default (with a few exceptions) so you will need to
    use `private` or `internal` if you want to protect them.
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These access specifiers are just one way of doing access control in F#. Another
    completely different way is to use module "signature" files, which are a bit like
    C header files. They describe the content of the module in an abstract way. Signatures
    are very useful for doing serious encapsulation, but that discussion will have
    to wait for the planned series on encapsulation and capability based security.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespaces in F# are similar to namespaces in C#. They can be used to organize
    modules and types to avoid name collisions.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: A namespace is declared with a `namespace` keyword, as shown below.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Because of this namespace, the fully qualified name of the `MathStuff` module
    now becomes `Utilities.MathStuff` and the fully qualified name of the `add` function
    now becomes `Utilities.MathStuff.add`.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: With the namespace, the indentation rules apply, so that the module defined
    above must have its content indented, as it it were a nested module.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare a namespace implicitly by adding dots to the module name.
    That is, the code above could also be written as:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The fully qualified name of the `MathStuff` module is still `Utilities.MathStuff`,
    but in this case, the module is a top-level module and the contents do not need
    to be indented.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional things to be aware of when using namespaces:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are optional for modules. And unlike C#, there is no default namespace
    for an F# project, so a top level module without a namespace will be at the global
    level. If you are planning to create reusable libraries, be sure to add some sort
    of namespace to avoid naming collisions with code in other libraries.
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于模块来说，命名空间是可选的。与 C# 不同的是，F# 项目没有默认的命名空间，因此顶层模块如果没有命名空间，将位于全局级别。如果你计划创建可重用的库，请确保添加一些命名空间，以避免与其他库中的代码命名冲突。
- en: Namespaces can directly contain type declarations, but not function declarations.
    As noted earlier, all function and value declarations must be part of a module.
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间可以直接包含类型声明，但不能包含函数声明。正如前面所述，所有函数和值声明都必须是模块的一部分。
- en: Finally, be aware that namespaces don't work well in scripts. For example, if
    you try to to send a namespace declaration such as `namespace Utilities` below
    to the interactive window, you will get an error.
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，请注意，命名空间在脚本中工作得不好。例如，如果你尝试将命名空间声明`namespace Utilities`发送到交互式窗口，你将会收到一个错误。
- en: Namespace hierarchies
  id: totrans-766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间层次结构
- en: 'You can create a namespace hierarchy by simply separating the names with periods:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地用句点分隔名称来创建命名空间层次结构：
- en: '[PRE208]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: And if you want to put *two* namespaces in the same file, you can. Note that
    all namespaces *must* be fully qualified -- there is no nesting.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在同一个文件中放置*两个*命名空间，你可以。请注意，所有命名空间*必须*完全限定 -- 没有嵌套。
- en: '[PRE209]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: One thing you can't do is have a naming collision between a namespace and a
    module.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在命名空间和模块之间有命名冲突。
- en: '[PRE210]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Mixing types and functions in modules
  id: totrans-773
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块中混合类型和函数
- en: We've seen that a module typically consists of a set of related functions that
    act on a data type.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，一个模块通常包含一组相关的函数，这些函数作用于一个数据类型。
- en: In an object oriented program, the data structure and the functions that act
    on it would be combined in a class. However in functional-style F#, a data structure
    and the functions that act on it are combined in a module instead.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的程序中，数据结构和作用于它的函数会被组合在一个类中。然而，在函数式的 F# 中，数据结构和作用于它的函数会被组合在一个模块中。
- en: 'There are two common patterns for mixing types and functions together:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类型和函数的两种常见模式有：
- en: having the type declared separately from the functions
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同于函数的模块中声明类型
- en: having the type declared in the same module as the functions
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相同模块中声明类型
- en: In the first approach, the type is declared *outside* any module (but in a namespace)
    and then the functions that work on the type are put in a module with a similar
    name.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种方法中，类型被声明*在*任何模块之外（但在一个命名空间中），然后作用于该类型的函数被放置在一个类似名字的模块中。
- en: '[PRE211]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'In the alternative approach, the type is declared *inside* the module and given
    a simple name such as "`T`" or the name of the module. So the functions are accessed
    with names like `MyModule.Func1` and `MyModule.Func2` while the type itself is
    accessed with a name like `MyModule.T`. Here''s an example:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种方法中，类型被声明*在*模块内，并被赋予一个简单的名字，比如“`T`”或模块的名字。所以函数可以通过像`MyModule.Func1`和`MyModule.Func2`这样的名字来访问，而类型本身可以通过像`MyModule.T`这样的名字来访问。下面是一个例子：
- en: '[PRE212]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Note that in both cases, you should have a constructor function that creates
    new instances of the type (a factory method, if you will), Doing this means that
    you will rarely have to explicitly name the type in your client code, and therefore,
    you not should not care whether it lives in the module or not!
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这两种情况下，你应该有一个构造函数来创建类型的新实例（一种工厂方法），这意味着你很少需要在客户端代码中显式命名类型，因此，你不应该关心它是否存在于模块中！
- en: So which approach should you choose?
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你应该选择哪种方法呢？
- en: The former approach is more .NET like, and much better if you want to share
    your libraries with other non-F# code, as the exported class names are what you
    would expect.
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一种方法更像是.NET，并且如果你想要将你的库与其他非 F# 代码共享，这种方法更好，因为导出的类名是你期望的。
- en: The latter approach is more common for those used to other functional languages.
    The type inside a module compiles into nested classes, which is not so nice for
    interop.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后一种方法对于那些习惯于其他函数式语言的人来说更常见。模块内的类型编译成嵌套类，这对于互操作性来说不太好看。
- en: For yourself, you might want to experiment with both. And in a team programming
    situation, you should choose one style and be consistent.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你自己，你可能想要尝试两种方法。在团队编程情况下，你应该选择一种风格并保持一致。
- en: Modules containing types only
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只包含类型的模块
- en: If you have a set of types that you need to declare without any associated functions,
    don't bother to use a module. You can declare types directly in a namespace and
    avoid nested classes.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一组需要声明但没有相关函数的类型，请不要使用模块。您可以直接在命名空间中声明类型，避免嵌套类。
- en: 'For example, here is how you might think to do it:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是您可能考虑如何做的方式：
- en: '[PRE213]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: And here is a alternative way to do it. The `module` keyword has simply been
    replaced with `namespace`.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一种替代方法。`module`关键字简单地被替换为`namespace`。
- en: '[PRE214]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: In both cases, `PersonType` will have the same fully qualified name.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`PersonType`将具有相同的完全限定名称。
- en: Note that this only works with types. Functions must always live in a module.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这仅适用于类型。函数必须始终位于模块中。
- en: Attaching functions to types
  id: totrans-796
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数附加到类型
- en: Attaching functions to types
  id: totrans-797
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数附加到类型
- en: Although we have focused on the pure functional style so far, sometimes it is
    convenient to switch to an object oriented style. And one of the key features
    of the OO style is the ability to attach functions to a class and "dot into" the
    class to get the desired behavior.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们迄今为止专注于纯函数式风格，有时切换到面向对象风格会更方便。面向对象风格的一个关键特点是能够将函数附加到类并“点进”类以获得所需的行为。
- en: In F#, this is done using a feature called "type extensions". And any F# type,
    not just classes, can have functions attached to them.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，这是通过一种称为“类型扩展”的功能来实现的。任何F#类型，不仅仅是类，都可以附加函数。
- en: Here's an example of attaching a function to a record type.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将函数附加到记录类型的示例。
- en: '[PRE215]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'The key things to note are:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的关键点是：
- en: The `with` keyword indicates the start of the list of members
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`关键字表示成员列表的开始'
- en: The `member` keyword shows that this is a member function (i.e. a method)
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`member`关键字表明这是一个成员函数（即方法）'
- en: The word `this` is a placeholder for the object that is being dotted into (called
    a "self-identifier"). The placeholder prefixes the function name, and then the
    function body then uses the same placeholder when it needs to refer to the current
    instance. There is no requirement to use a particular word, just as long as it
    is consistent. You could use `this` or `self` or `me` or any other word that commonly
    indicates a self reference.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单词`this`是一个占位符，用于指代正在点进的对象（称为“self-标识符”）。占位符前缀函数名称，然后函数体在需要引用当前实例时使用相同的占位符。没有使用特定单词的要求，只要保持一致即可。您可以使用`this`或`self`或`me`或任何其他通常表示自引用的单词。
- en: 'You don''t have to add a member at the same time that you declare the type,
    you can always add it later in the same module:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必在声明类型的同时添加成员，您始终可以稍后在同一模块中添加它：
- en: '[PRE216]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: These examples demonstrate what are called "intrinsic extensions". They are
    compiled into the type itself and are always available whenever the type is used.
    They also show up when you use reflection.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了所谓的“内在扩展”。它们被编译到类型本身中，并且在使用类型时始终可用。当您使用反射时，它们也会显示出来。
- en: With intrinsic extensions, it is even possible to have a type definition that
    divided across several files, as long as all the components use the same namespace
    and are all compiled into the same assembly. Just as with partial classes in C#,
    this can be useful to separate generated code from authored code.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内在扩展，甚至可以将类型定义分割到几个文件中，只要所有组件使用相同的命名空间并且都编译到同一个程序集中。就像C#中的部分类一样，这对于将生成的代码与编写的代码分开非常有用。
- en: Optional extensions
  id: totrans-810
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选扩展
- en: Another alternative is that you can add an extra member from a completely different
    module. These are called "optional extensions". They are not compiled into the
    type itself, and require some other module to be in scope for them to work (this
    behavior is just like C# extension methods).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是您可以从完全不同的模块中添加额外的成员。这些被称为“可选扩展”。它们不会被编译到类型本身中，并且需要一些其他模块在作用域内才能工作（这种行为就像C#的扩展方法）。
- en: 'For example, let''s say we have a `Person` type defined:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们定义了一个`Person`类型：
- en: '[PRE217]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'The example below demonstrates how to add an `UppercaseName` extension to it
    in a different module:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例演示了如何在不同模块中为其添加`UppercaseName`扩展：
- en: '[PRE218]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'So now let''s test this extension:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试这个扩展：
- en: '[PRE219]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Uh-oh, we have an error. What's wrong is that the `PersonExtensions` is not
    in scope. Just as for C#, any extensions have to be brought into scope in order
    to be used.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们出现了一个错误。问题在于`PersonExtensions`不在作用域内。就像对于C#一样，任何扩展都必须在作用域内才能使用。
- en: 'Once we do that, everything is fine:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，一切都很好：
- en: '[PRE220]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Extending system types
  id: totrans-821
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展系统类型
- en: You can extend types that are in the .NET libraries as well. But be aware that
    when extending a type, you must use the actual type name, not a type abbreviation.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以扩展在 .NET 库中的类型。但要注意，当扩展一个类型时，你必须使用实际的类型名称，而不是类型缩写。
- en: 'For example, if you try to extend `int`, you will fail, because `int` is not
    the true name of the type:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你尝试扩展 `int`，你会失败，因为 `int` 不是类型的真实名称：
- en: '[PRE221]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'You must use `System.Int32` instead:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用 `System.Int32` 代替：
- en: '[PRE222]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Static members
  id: totrans-827
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员
- en: 'You can make the member functions static by:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式使成员函数静态化：
- en: adding the keyword `static`
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加关键字 `static`
- en: dropping the `this` placeholder
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去掉 `this` 占位符
- en: '[PRE223]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'And you can create static members for system types as well:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为系统类型创建静态成员：
- en: '[PRE224]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Attaching existing functions
  id: totrans-834
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加现有函数
- en: 'A very common pattern is to attach pre-existing standalone functions to a type.
    This has a couple of benefits:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的模式是将预先存在的独立函数附加到类型上。这有几个好处：
- en: While developing, you can create standalone functions that refer to other standalone
    functions. This makes programming easier because type inference works much better
    with functional-style code than with OO-style ("dotting into") code.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中，你可以创建引用其他独立函数的独立函数。这样做使编程更加容易，因为类型推断在函数式代码中比面向对象式代码更有效。
- en: But for certain key functions, you can attach them to the type as well. This
    gives clients the choice of whether to use functional or object-oriented style.
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但对于某些关键函数，你也可以将它们附加到类型上。这使客户可以选择使���函数式还是面向对象的风格。
- en: One example of this in the F# libraries is the function that calculates a list's
    length. It is available as a standalone function in the `List` module, but also
    as a method on a list instance.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: F# 库中的一个例子是计算列表长度的函数。它作为 `List` 模块中的独立函数可用，但也作为列表实例的方法可用。
- en: '[PRE225]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: In the following example, we start with a type with no members initially, then
    define some functions, then finally attach the `fullName` function to the type.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们首先从一个没有成员的类型开始，然后定义一些函数，最后将 `fullName` 函数附加到类型上。
- en: '[PRE226]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The standalone `fullName` function has one parameter, the person. In the attached
    member, the parameter comes from the `this` self-reference.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的 `fullName` 函数有一个参数，即人。在附加成员中，参数来自 `this` 自引用。
- en: Attaching existing functions with multiple parameters
  id: totrans-843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加具有多个参数的现有函数
- en: One nice thing is that when the previously defined function has multiple parameters,
    you don't have to respecify them all when doing the attachment, as long as the
    `this` parameter is first.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好处是，当先前定义的函数有多个参数时，在进行附加时，只要 `this` 参数在第一位，你就不必重新指定它们。
- en: In the example below, the `hasSameFirstAndLastName` function has three parameters.
    Yet when we attach it, we only need to specify one!
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`hasSameFirstAndLastName` 函数有三个参数。然而当我们调用它时，只需要指定一个！
- en: '[PRE227]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Why does this work? Hint: think about currying and partial application!'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样能够工作？提示：考虑柯里化和部分应用！
- en: Tuple-form methods
  id: totrans-848
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组形式的方法
- en: 'When we start having methods with more than one parameter, we have to make
    a decision:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始有多个参数的方法时，我们必须做出决定：
- en: we could use the standard (curried) form, where parameters are separated with
    spaces, and partial application is supported.
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用标准（柯里化）形式，其中参数用空格分隔，并支持部分应用。
- en: we could pass in *all* the parameters at once, comma-separated, in a single
    tuple.
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以一次性传入*所有*参数，用逗号分隔，放在一个单独的元组中。
- en: The "curried" form is more functional, and the "tuple" form is more object-oriented.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '"柯里化"形式更加函数式，而"元组"形式更加面向对象。'
- en: The tuple form is also how F# interacts with the standard .NET libraries, so
    let's examine this approach in more detail.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 元组形式也是 F# 与标准 .NET 库交互的方式，让我们更详细地研究这种方法。
- en: 'As a testbed, here is a Product type with two methods, each implemented using
    one of the approaches. The `CurriedTotal` and `TupleTotal` methods each do the
    same thing: work out the total price for a given quantity and discount.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个测试平台，这里有一个产品类型，有两种方法，每种方法都使用其中一种方法实现。`CurriedTotal` 和 `TupleTotal` 方法都做同样的事情：计算给定数量和折扣的总价格。
- en: '[PRE228]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'And here''s some test code:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些测试代码：
- en: '[PRE229]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: No difference so far.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止没有区别。
- en: 'We know that curried version can be partially applied:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道柯里化版本可以进行部分应用：
- en: '[PRE230]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'But the tuple approach can do a few things that that the curried one can''t,
    namely:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 但元组方法可以做一些柯里化方法无法做到的事情，即：
- en: Named parameters
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名参数
- en: Optional parameters
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数
- en: Overloading
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载
- en: Named parameters with tuple-style parameters
  id: totrans-865
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有元组样式参数的命名参数
- en: 'The tuple-style approach supports named parameters:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: As you can see, when names are used, the parameter order can be changed.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: if some parameters are named and some are not, the named ones must always
    be last.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters with tuple-style parameters
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For tuple-style methods, you can specify an optional parameter by prefixing
    the parameter name with a question mark.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter is set, it comes through as `Some value`
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the parameter is not set, it comes through as `None`
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'And here''s a test:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: This explicit matching of the `None` and `Some` can be tedious, and there is
    a slightly more elegant solution for handling optional parameters.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: There is a function `defaultArg` which takes the parameter as the first argument
    and a default for the second argument. If the parameter is set, the value is returned.
    And if not, the default value is returned.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the same code rewritten to use `defaultArg`
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Method overloading
  id: totrans-882
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C#, you can have multiple methods with the same name that differ only in
    their function signature (e.g. different parameter types and/or number of parameters)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: In the pure functional model, that does not make sense -- a function works with
    a particular domain type and a particular range type. The same function cannot
    work with different domains and ranges.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: However, F# *does* support method overloading, but only for methods (that is
    functions attached to types) and of these, only those using tuple-style parameter
    passing.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example, with yet another variant on the `TupleTotal` method!
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Normally, the F# compiler would complain that there are two methods with the
    same name, but in this case, because they are tuple based and because their signatures
    are different, it is acceptable. (To make it obvious which one is being called,
    I have added a small debugging message.)
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s a test:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Hey! Not so fast... The downsides of using methods
  id: totrans-891
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are coming from an object-oriented background, you might be tempted
    to use methods everywhere, because that is what you are familiar with. But be
    aware that there some major downsides to using methods as well:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Methods don't play well with type inference
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods don't play well with higher order functions
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, by overusing methods you would be needlessly bypassing the most powerful
    and useful aspects of programming in F#.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what I mean.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: Methods don't play well with type inference
  id: totrans-897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back to our Person example again, the one that had the same logic
    implemented both as a standalone function and as a method:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Now let's see how well each one works with type inference. Say that I want to
    print the full name of a person, so I will define a function `printFullName` that
    takes a person as a parameter.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: Here's the code using the module level standalone function.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: This compiles without problems, and the type inference has correctly deduced
    that parameter was a person
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try the "dotted" version:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: This does not compile at all, because the type inference does not have enough
    information to deduce the parameter. *Any* object might implement `.FullName`
    -- there is just not enough to go on.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we could annotate the function with the parameter type, but that defeats
    the whole purpose of type inference.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: Methods don't play well with higher order functions
  id: totrans-908
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A similar problem happens with higher order functions. For example, let's say
    that, given a list of people, we want to get all their full names.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: 'With a standalone function, this is trivial:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'With object methods, we have to create special lambdas everywhere:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: And this is just a simple example. Object methods don't compose well, are hard
    to pipe, and so on.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: So, a plea for those of you new to functionally programming. Don't use methods
    at all if you can, especially when you are learning. They are a crutch that will
    stop you getting the full benefit from functional programming.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: 'Worked example: A stack based calculator'
  id: totrans-916
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Worked example: A stack based calculator'
  id: totrans-917
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we'll implement a simple stack based calculator (also known as
    "reverse Polish" style). The implementation is almost entirely done with functions,
    with only one special type and no pattern matching at all, so it is a great testing
    ground for the concepts introduced in this series.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with a stack based calculator, it works as follows:
    numbers are pushed on a stack, and operations such as addition and multiplication
    pop numbers off the stack and push the result back on.'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram showing a simple calculation using a stack:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack based calculator diagram](stack-based-calculator.png)'
  id: totrans-921
  prefs: []
  type: TYPE_IMG
- en: 'The first steps to designing a system like this is to think about how it would
    be used. Following a Forth like syntax, we will give each action a label, so that
    the example above might want to be written something like:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: We might not be able to get this exact syntax, but let's see how close we can
    get.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: The Stack data type
  id: totrans-925
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we need to define the data structure for a stack. To keep things simple,
    we'll just use a list of floats.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'But, hold on, let''s wrap it in a [single case union type](discriminated-unions.html#single-case)
    to make it more descriptive, like this:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: For more details on why this is nicer, read the discussion of single case union
    types in [this post](discriminated-unions.html#single-case).
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create a new stack, we use `StackContents` as a constructor:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'And to extract the contents of an existing Stack, we pattern match with `StackContents`:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: The Push function
  id: totrans-935
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next we need a way to push numbers on to the stack. This will be simply be prepending
    the new value at the front of the list using the "`::`" operator.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our push function:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: This basic function has a number of things worth discussing.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: 'First, note that the list structure is immutable, so the function must accept
    an existing stack and return a new stack. It cannot just alter the existing stack.
    In fact, all of the functions in this example will have a similar format like
    this:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Next, what should the order of the parameters be? Should the stack parameter
    come first or last? If you remember the discussion of [designing functions for
    partial application](partial-application), you will remember that the most changeable
    thing should come last. You'll see shortly that this guideline will be born out.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function can be made more concise by using pattern matching in
    the function parameter itself, rather than using a `let` in the body of the function.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rewritten version:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Much nicer!
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: 'And by the way, look at the nice signature it has:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: As we know from a [previous post](function-signatures), the signature tells
    you a lot about the function. In this case, I could probably guess what it did
    from the signature alone, even without knowing that the name of the function was
    "push". This is one of the reasons why it is a good idea to have explicit type
    names. If the stack type had just been a list of floats, it wouldn't have been
    as self-documenting.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, now let''s test it:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Works great!
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: Building on top of "push"
  id: totrans-953
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this simple function in place, we can easily define an operation that pushes
    a particular number onto the stack.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'But wait a minute! Can you see that the `stack` parameter is used on both sides?
    In fact, we don''t need to mention it at all. Instead we can skip the `stack`
    parameter and write the functions using partial application as follows:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Now you can see that if the parameters for `push` were in a different order,
    we wouldn't have been able to do this.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s define a function that creates an empty stack as
    well:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Let''s test all of these now:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'These intermediate stacks are annoying ? can we get rid of them? Yes! Note
    that these functions ONE, TWO, THREE all have the same signature:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'This means that they can be chained together nicely! The output of one can
    be fed into the input of the next, as shown below:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Popping the stack
  id: totrans-967
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That takes care of pushing onto the stack ? what about a `pop` function next?
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: When we pop the stack, we will return the top of the stack, obviously, but is
    that all?
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: In an object-oriented style, [the answer is yes](http://msdn.microsoft.com/en-us/library/system.collections.stack.pop.aspx).
    In an OO approach, we would *mutate* the stack itself behind the scenes, so that
    the top element was removed.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: But in a functional style, the stack is immutable. The only way to remove the
    top element is to create a *new stack* with the element removed. In order for
    the caller to have access to this new diminished stack, it needs to be returned
    along with the top element itself.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the `pop` function will have to return *two* values, the top
    plus the new stack. The easiest way to do this in F# is just to use a tuple.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the implementation:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: This function is also very straightforward.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: As before, we are extracting the `contents` directly in the parameter.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: We then use a `match..with` expression to test the contents.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: Next, we separate the top element from the rest, create a new stack from the
    remaining elements and finally return the pair as a tuple.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: Try the code above and see what happens. You will get a compiler error! The
    compiler has caught a case we have overlooked -- what happens if the stack is
    empty?
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: So now we have to decide how to handle this.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Return a special "Success" or "Error" state, as we did in a [post
    from the "why use F#?" series](correctness-exhaustive-pattern-matching.html).'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Option 2: Throw an exception.'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, I prefer to use error cases, but in this case, we''ll use an exception.
    So here''s the `pop` code changed to handle the empty case:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Now let''s test it:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'and to test the underflow:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Writing the math functions
  id: totrans-989
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now with both push and pop in place, we can work on the "add" and "multiply"
    functions:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Test these interactively:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: It works!
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: Time to refactor...
  id: totrans-995
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is obvious that there is significant duplicate code between these two functions.
    How can we refactor?
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: 'Both functions pop two values from the stack, apply some sort of binary function,
    and then push the result back on the stack. This leads us to refactor out the
    common code into a "binary" function that takes a two parameter math function
    as a parameter:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '*Note that in this implementation, I''ve switched to using ticks to represent
    changed states of the "same" object, rather than numeric suffixes. Numeric suffixes
    can easily get quite confusing.*'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: 'Question: why are the parameters in the order they are, instead of `mathFn`
    being after `stack`?'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `binary`, we can define ADD and friends more simply:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a first attempt at ADD using the new `binary` helper:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'But we can eliminate the lambda, as it is *exactly* the definition of the built-in
    `+` function! Which gives us:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'And again, we can use partial application to hide the stack parameter. Here''s
    the final definition:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'And here''s the definition of some other math functions:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: Let's test interactively again.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: In a similar fashion, we can create a helper function for unary functions
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'And then define some unary functions:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Test interactively again:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Putting it all together
  id: totrans-1018
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the original requirements, we mentioned that we wanted to be able to show
    the results, so let's define a SHOW function.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Note that in this case, we pop the original stack but ignore the diminished
    version. The final result of the function is the original stack, as if it had
    never been popped.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: So now finally, we can write the code example from the original requirements
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Going further
  id: totrans-1024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is fun -- what else can we do?
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we can define a few more core helper functions:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'And with these additional functions in place, we can write some nice examples:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Using composition instead of piping
  id: totrans-1030
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But that's not all. In fact, there is another very interesting way to think
    about these functions.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'As I pointed out earlier, they all have an identical signature:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: So, because the input and output types are the same, these functions can be
    composed using the composition operator `>>`, not just chained together with pipes.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: In each of these cases, a new function is defined by composing other functions
    together to make a new one. This is a good example of the "combinator" approach
    to building up functionality.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: Pipes vs composition
  id: totrans-1038
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now seen two different ways that this stack based model can be used;
    by piping or by composition. So what is the difference? And why would we prefer
    one way over another?
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that piping is, in a sense, a "realtime transformation" operation.
    When you use piping you are actually doing the operations right now, passing a
    particular stack around.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, composition is a kind of "plan" for what you want to do,
    building an overall function from a set of parts, but *not* actually running it
    yet.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example, I can create a "plan" for how to square a number by combining
    smaller operations:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: I cannot do the equivalent with the piping approach.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'This causes a compilation error. I have to have some sort of concrete stack
    instance to make it work:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: And even then, I only get the answer for this particular input, not a plan for
    all possible inputs, as in the COMPOSED_SQUARE example.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to create a "plan" is to explicitly pass in a lambda to a more
    primitive function, as we saw near the beginning:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: This is much more explicit (and is likely to be faster) but loses all the benefits
    and clarity of the composition approach.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: So, in general, go for the composition approach if you can!
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: The complete code
  id: totrans-1053
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's the complete code for all the examples so far.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Summary
  id: totrans-1056
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So there we have it, a simple stack based calculator. We've seen how we can
    start with a few primitive operations (`push`, `pop`, `binary`, `unary`) and from
    them, build up a whole domain specific language that is both easy to implement
    and easy to use.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, this example is based heavily on the Forth language. I highly
    recommend the free book ["Thinking Forth"](http://thinking-forth.sourceforge.net/),
    which is not just about the Forth language, but about (*non* object-oriented!)
    problem decomposition techniques which are equally applicable to functional programming.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: I got the idea for this post from a great blog by [Ashley Feniello](http://blogs.msdn.com/b/ashleyf/archive/2011/04/21/programming-is-pointless.aspx).
    If you want to go deeper into emulating a stack based language in F#, start there.
    Have fun!
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
