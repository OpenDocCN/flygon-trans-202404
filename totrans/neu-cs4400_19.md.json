["```\n{with {id WAE1} WAE2}\n```", "```\neval( {with {id WAE1} WAE2} )\u00a0 = eval( subst(WAE2,id,WAE1) )\n```", "```\neval( {with {id WAE1} WAE2} )\u00a0 = eval( WAE2[WAE1/id] )\n```", "```\n{with {x 5} {+ x x}}\u00a0  -->\u00a0 {+ 5 5}{with {x 5} {+ 10 4}}\u00a0 -->\u00a0 {+ 10 4}\n```", "```\n{with {x 5} {+ x {with {x 3} 10}}}\u00a0 -->\u00a0 {+ 5 {with {5 3} 10}} ???\n```", "```\n{with {x 5} {+ x x}}\u00a0  -->\u00a0 {+ 5 5}{with {x 5} {+ 10 4}}\u00a0 -->\u00a0 {+ 10 4}\n```", "```\n{with {x 5} {+ x {with {x 3} 10}}}\u00a0 -->\u00a0 {+ 5 {with {x 3} 10}}\u00a0 -->\u00a0 {+ 5 10}\n```", "```\n{with {x 5}\u00a0 {+ x {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0  x}}}\n```", "```\n-->\u00a0 {+ 5 {with {x 3} 5}}-->\u00a0 {+ 5 5}-->\u00a0 10\n```", "```\n{with {x 5} {+ x {with {y 3} x}}}\n```", "```\n-->\u00a0 {+ 5 {with {y 3} x}}-->\u00a0 {+ 5 x}\n```", "```\n(: subst : WAE Symbol WAE -> WAE);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to) ; returns expr[to/from]\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0  expr\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  ;*** don't go in!\u00a0 \u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  named-expr\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]))\n```", "```\n{with {x E1} E2}\n```", "```\neval( {with {x E1} E2} )\u00a0 = eval( E2[eval(E1)/x] )\n```", "```\n{with {x E1} E2}\n```", "```\nE2[E1/x]\n```", "```\neval(...) = ... same as the AE rules ...eval({with {x E1} E2}) = eval(E2[eval(E1)/x])eval(id) = error!\n```", "```\n(: eval : WAE -> Number);; evaluates WAE expressions by reducing them to numbers(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [(Add l r) (+ (eval l) (eval r))]\u00a0 \u00a0 [(Sub l r) (- (eval l) (eval r))]\u00a0 \u00a0 [(Mul l r) (* (eval l) (eval r))]\u00a0 \u00a0 [(Div l r) (/ (eval l) (eval r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Num (eval named-expr))))] ;***\u00a0 \u00a0 [(Id name) (error 'eval \"free identifier: ~s\" name)]))\n```", "```\n;; tests(test (run \"5\") => 5)(test (run \"{+ 5 5}\") => 10)(test (run \"{with {x {+ 5 5}} {+ x x}}\") => 20)(test (run \"{with {x 5} {+ x x}}\") => 10)(test (run \"{with {x {+ 5 5}} {with {y {- x 3}} {+ y y}}}\") => 14)(test (run \"{with {x 5} {with {y {- x 3}} {+ y y}}}\") => 4)(test (run \"{with {x 5} {+ x {with {x 3} 10}}}\") => 15)(test (run \"{with {x 5} {+ x {with {x 3} x}}}\") => 8)(test (run \"{with {x 5} {+ x {with {y 3} x}}}\") => 10)(test (run \"{with {x 5} {with {y x} y}}\") => 5)(test (run \"{with {x 5} {with {x x} x}}\") => 5)(test (run \"{with {x 1} y}\") =error> \"free identifier\")\n```", "```\n#lang pl#| BNF for the WAE language:\u00a0 \u00a0  <WAE> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { + <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { - <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { * <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { / <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { with { <id> <WAE> } <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | <id>|#;; WAE abstract syntax trees(define-type WAE\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 WAE WAE]\u00a0 [Sub\u00a0 WAE WAE]\u00a0 [Mul\u00a0 WAE WAE]\u00a0 [Div\u00a0 WAE WAE]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol WAE WAE])(: parse-sexpr : Sexpr -> WAE);; parses s-expressions into WAEs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> WAE);; parses a string containing a WAE expression to a WAE AST(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)))(: subst : WAE Symbol WAE -> WAE);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0  expr\u00a0 \u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  named-expr\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]))(: eval : WAE -> Number);; evaluates WAE expressions by reducing them to numbers(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [(Add l r) (+ (eval l) (eval r))]\u00a0 \u00a0 [(Sub l r) (- (eval l) (eval r))]\u00a0 \u00a0 [(Mul l r) (* (eval l) (eval r))]\u00a0 \u00a0 [(Div l r) (/ (eval l) (eval r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Num (eval named-expr))))]\u00a0 \u00a0 [(Id name) (error 'eval \"free identifier: ~s\" name)]))(: run : String -> Number);; evaluate a WAE program contained in a string(define (run str)\u00a0 (eval (parse str)));; tests(test (run \"5\") => 5)(test (run \"{+ 5 5}\") => 10)(test (run \"{with {x {+ 5 5}} {+ x x}}\") => 20)(test (run \"{with {x 5} {+ x x}}\") => 10)(test (run \"{with {x {+ 5 5}} {with {y {- x 3}} {+ y y}}}\") => 14)(test (run \"{with {x 5} {with {y {- x 3}} {+ y y}}}\") => 4)(test (run \"{with {x 5} {+ x {with {x 3} 10}}}\") => 15)(test (run \"{with {x 5} {+ x {with {x 3} x}}}\") => 8)(test (run \"{with {x 5} {+ x {with {y 3} x}}}\") => 10)(test (run \"{with {x 5} {with {y x} y}}\") => 5)(test (run \"{with {x 5} {with {x x} x}}\") => 5)(test (run \"{with {x 1} y}\") =error> \"free identifier\")\n```", "```\n{with {x 5}\u00a0 {with {y x}\u00a0 \u00a0 y}}\n```", "```\n(: subst : WAE Symbol WAE -> WAE);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0  expr\u00a0 \u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst named-expr from to)\u00a0 \u00a0 \u00a0  ;*** new\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]))\n```", "```\n{with {x 5}\u00a0 {with {x x}\u00a0 \u00a0 x}}\n```", "```\n(: subst : WAE Symbol WAE -> WAE);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst named-expr from to)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]))\n```", "```\n[\u25b6](wae.rkt \"wae.rkt\")#lang pl#| BNF for the WAE language:\u00a0 \u00a0  <WAE> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { + <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { - <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { * <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { / <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | { with { <id> <WAE> } <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | <id>|#;; WAE abstract syntax trees(define-type WAE\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 WAE WAE]\u00a0 [Sub\u00a0 WAE WAE]\u00a0 [Mul\u00a0 WAE WAE]\u00a0 [Div\u00a0 WAE WAE]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol WAE WAE])(: parse-sexpr : Sexpr -> WAE);; parses s-expressions into WAEs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> WAE);; parses a string containing a WAE expression to a WAE AST(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)))#| Formal specs for `subst':\u00a0  (`N' is a <num>, `E1', `E2' are <WAE>s, `x' is some <id>,\u00a0  `y' is a *different* <id>)\u00a0 \u00a0 \u00a0 N[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = N\u00a0 \u00a0 \u00a0 {+ E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {+ E1[v/x] E2[v/x]}\u00a0 \u00a0 \u00a0 {- E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {- E1[v/x] E2[v/x]}\u00a0 \u00a0 \u00a0 {* E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {* E1[v/x] E2[v/x]}\u00a0 \u00a0 \u00a0 {/ E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {/ E1[v/x] E2[v/x]}\u00a0 \u00a0 \u00a0 y[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = y\u00a0 \u00a0 \u00a0 x[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = v\u00a0 \u00a0 \u00a0 {with {y E1} E2}[v/x] = {with {y E1[v/x]} E2[v/x]}\u00a0 \u00a0 \u00a0 {with {x E1} E2}[v/x] = {with {x E1[v/x]} E2}|#(: subst : WAE Symbol WAE -> WAE);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst named-expr from to)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]))#| Formal specs for `eval':\u00a0 \u00a0  eval(N)\u00a0 \u00a0 \u00a0 \u00a0  = N\u00a0 \u00a0  eval({+ E1 E2}) = eval(E1) + eval(E2)\u00a0 \u00a0  eval({- E1 E2}) = eval(E1) - eval(E2)\u00a0 \u00a0  eval({* E1 E2}) = eval(E1) * eval(E2)\u00a0 \u00a0  eval({/ E1 E2}) = eval(E1) / eval(E2)\u00a0 \u00a0  eval(id)\u00a0 \u00a0 \u00a0 \u00a0 = error!\u00a0 \u00a0  eval({with {x E1} E2}) = eval(E2[eval(E1)/x])|#(: eval : WAE -> Number);; evaluates WAE expressions by reducing them to numbers(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [(Add l r) (+ (eval l) (eval r))]\u00a0 \u00a0 [(Sub l r) (- (eval l) (eval r))]\u00a0 \u00a0 [(Mul l r) (* (eval l) (eval r))]\u00a0 \u00a0 [(Div l r) (/ (eval l) (eval r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Num (eval named-expr))))]\u00a0 \u00a0 [(Id name) (error 'eval \"free identifier: ~s\" name)]))(: run : String -> Number);; evaluate a WAE program contained in a string(define (run str)\u00a0 (eval (parse str)));; tests(test (run \"5\") => 5)(test (run \"{+ 5 5}\") => 10)(test (run \"{with {x {+ 5 5}} {+ x x}}\") => 20)(test (run \"{with {x 5} {+ x x}}\") => 10)(test (run \"{with {x {+ 5 5}} {with {y {- x 3}} {+ y y}}}\") => 14)(test (run \"{with {x 5} {with {y {- x 3}} {+ y y}}}\") => 4)(test (run \"{with {x 5} {+ x {with {x 3} 10}}}\") => 15)(test (run \"{with {x 5} {+ x {with {x 3} x}}}\") => 8)(test (run \"{with {x 5} {+ x {with {y 3} x}}}\") => 10)(test (run \"{with {x 5} {with {y x} y}}\") => 5)(test (run \"{with {x 5} {with {x x} x}}\") => 5)(test (run \"{with {x 1} y}\") =error> \"free identifier\")\n```", "```\n    <WAE> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 | { + <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 | { - <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 | { * <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 | { / <WAE> <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 | { with { <id> <WAE> } <WAE> }\u00a0 \u00a0 \u00a0 \u00a0 | <id>\n    ```", "```\n    (define-type WAE\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 WAE WAE]\u00a0 [Sub\u00a0 WAE WAE]\u00a0 [Mul\u00a0 WAE WAE]\u00a0 [Div\u00a0 WAE WAE]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol WAE WAE])\n    ```", "```\n    (: parse-sexpr : Sexpr -> WAE);; parses s-expressions into WAEs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))\n    ```", "```\n    (: subst : WAE Symbol WAE -> WAE);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst named-expr from to)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]))\n    ```", "```\n    eval(...) = ... same as the AE rules ...eval({with {x E1} E2}) = eval(E2[eval(E1)/x])eval(id) = error!\n    ```", "```\n    (: eval : WAE -> Number);; evaluates WAE expressions by reducing them to numbers(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [(Add l r) (+ (eval l) (eval r))]\u00a0 \u00a0 [(Sub l r) (- (eval l) (eval r))]\u00a0 \u00a0 [(Mul l r) (* (eval l) (eval r))]\u00a0 \u00a0 [(Div l r) (/ (eval l) (eval r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Num (eval named-expr))))]\u00a0 \u00a0 [(Id name) (error 'eval \"free identifier: ~s\" name)]))\n    ```"]