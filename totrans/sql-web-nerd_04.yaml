- en: '| [![Traffic on the 405\.  Los Angeles, California.  View from the Getty Center.](../Images/d16d608950fdcc8f69f6e45ae8885bf1.jpg)](/http://philip.greenspun.com/images/pcd0222/los-angeles-traffic-44.tcl)
    |'
  prefs: []
  type: TYPE_TB
- en: Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: part of [SQL for Web Nerds](index.html) by [Philip Greenspun](http://philip.greenspun.com/)
    | [![Cactus Garden overlooking the city. Getty Center.  Los Angeles, California.](../Images/6cc283cf7205bc1de17df078ca486221.jpg)](/http://philip.greenspun.com/images/pcd0222/getty-center-cactus-garden-7.tcl)
    |
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start up SQL*Plus, you can start browsing around immediately with the
    SELECT statement. You don''t even need to define a table; Oracle provides the
    built-in `dual` table for times when you''re interested in a constant or a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '... or to test your knowledge of three-valued logic (see the "Data Modeling"
    chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: (any expression involving NULL evaluates to NULL).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing magic about the `dual` table for these purposes; you can compute
    functions using the `bboard` table instead of `dual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: but not everyone wants 55010 copies of the same result. The `dual` table is
    predefined during Oracle installation and, though it is just a plain old table,
    it is guaranteed to contain only one row because no user will have sufficient
    privileges to insert or delete rows from `dual`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting beyond Hello World
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get beyond Hello World, pick a table of interest. As we saw in the introduction,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: would retrieve all the information from every row of the `users` table. That's
    good for toy systems but in any production system, you'd be better off starting
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'You don''t really want to look at 7352 rows of data, but you would like to
    see what''s in the users table, start off by asking SQL*Plus to query Oracle''s
    data dictionary and figure out what columns are available in the `users` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The data dictionary is simply a set of built-in tables that Oracle uses to store
    information about the objects (tables, triggers, etc.) that have been defined.
    Thus SQL*Plus isn't performing any black magic when you type `describe`; it is
    simply querying `user_tab_columns`, a view of some of the tables in Oracle's data
    dictionary. You could do the same explicitly, but it is a little cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Here we've had to make sure to put the table name ("USERS") in all-uppercase.
    Oracle is case-insensitive for table and column names in queries but the data
    dictionary records names in uppercase. Now that we know the names of the columns
    in the table, it will be easy to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Queries from One Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A simple query from one table has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: the select list (which columns in our report)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the name of the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the where clauses (which rows we want to see)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the order by clauses (how we want the rows arranged)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see some examples. First, let''s see how many users from MIT are registered
    on our site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The `email like ''%mit.edu''` says "every row where the email column ends in
    ''mit.edu''". The percent sign is Oracle''s wildcard character for "zero or more
    characters". Underscore is the wildcard for "exactly one character":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Suppose that we notice in the above report some similar email addresses. It
    is perhaps time to try out the ORDER BY clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Now we can see that this users table was generated by grinding over pre-ArsDigita
    Community Systems postings starting from 1995\. In those bad old days, users typed
    their email address and name with each posting. Due to typos and people intentionally
    choosing to use different addresses at various times, we can see that we'll have
    to build some sort of application to help human beings merge some of the rows
    in the users table (e.g., all three occurrences of "philg" are in fact the same
    person (me)).
  prefs: []
  type: TYPE_NORMAL
- en: Restricting results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that you were featured on Yahoo in September 1998 and want to see how
    many users signed up during that month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'We''ve combined two restrictions in the WHERE clause with an AND. We can add
    another restriction with another AND:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: OR and NOT are also available within the WHERE clause. For example, the following
    query will tell us how many classified ads we have that either have no expiration
    date or whose expiration date is later than the current date/time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Subqueries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can query one table, restricting the rows returned based on information
    from another table. For example, to find users who have posted at least one classified
    ad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Conceptually, for each row in the `users` table Oracle is running the subquery
    against `classified_ads` to see how many ads are associated with that particular
    user ID. Keep in mind that this is only *conceptually*; the Oracle SQL parser
    may elect to execute this query in a more efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to describe the same result set is using EXISTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: This may be more efficient for Oracle to execute since it hasn't been instructed
    to actually count the number of classified ads for each user, but only to check
    and see if any are present. Think of EXISTS as a Boolean function that
  prefs: []
  type: TYPE_NORMAL
- en: takes a SQL query as its only parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: returns TRUE if the query returns any rows at all, regardless of the contents
    of those rows (this is why we can use the constant 1 as the select list for the
    subquery)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A professional SQL programmer would be unlikely to query for users who''d posted
    classified ads in the preceding manner. The SQL programmer knows that, inevitably,
    the publisher will want information from the classified ad table along with the
    information from the users table. For example, we might want to see the users
    and, for each user, the sequence of ad postings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Because of the JOIN restriction, `where users.user_id = classified_ads.user_id`,
    we only see those users who have posted at least one classified ad, i.e., for
    whom a matching row may be found in the `classified_ads` table. This has the same
    effect as the subquery above.
  prefs: []
  type: TYPE_NORMAL
- en: The `order by users.email, posted` is key to making sure that the rows are lumped
    together by user and then printed in order of ascending posting time.
  prefs: []
  type: TYPE_NORMAL
- en: OUTER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose that we want an alphabetical list of all of our users, with classified
    ad posting dates for those users who have posted classifieds. We can't do a simple
    JOIN because that will exclude users who haven't posted any ads. What we need
    is an OUTER JOIN, where Oracle will "stick in NULLs" if it can't find a corresponding
    row in the `classified_ads` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The plus sign after `classified_ads.user_id` is our instruction to Oracle to
    "add NULL rows if you can't meet this JOIN constraint".
  prefs: []
  type: TYPE_NORMAL
- en: Extending a simple query into a JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that you have a query from one table returning almost everything that
    you need, except for one column that''s in another table. Here''s a way to develop
    the JOIN without risking breaking your application:'
  prefs: []
  type: TYPE_NORMAL
- en: add the new table to your FROM clause
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: add a WHERE constraint to prevent Oracle from building a Cartesian product
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: hunt for ambiguous column names in the SELECT list and other portions of the
    query; prefix these with table names if necessary
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: test that you've not broken anything in your zeal to add additional info
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: add a new column to the SELECT list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s an example from Problem Set 2 of a course that we give at MIT (see
    [http://www.photo.net/teaching/psets/ps2/ps2.adp](http://www.photo.net/teaching/psets/ps2/ps2.adp)).
    Students build a conference room reservation system. They generally define two
    tables: `rooms` and `reservations`. The top level page is supposed to show a user
    what reservations he or she is current holding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: This produces an unacceptable page because the rooms are referred to by an ID
    number rather than by name. The name information is in the `rooms` table, so we'll
    have to turn this into a JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: add the new table to the FROM clause'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: We're in a world of hurt because Oracle is now going to join every row in `rooms`
    with every row in `reservations` where the `user_id` matches that of the logged-in
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: add a constraint to the WHERE clause'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Step 3: look for ambiguously defined columns'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both `reservations` and `rooms` contain columns called "room_id". So we need
    to prefix the `room_id` column in the SELECT list with "reservations.". Note that
    we don't have to prefix `start_time` and `end_time` because these columns are
    only present in `reservations`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Step 4: test'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Test the query to make sure that you haven't broken anything. You should get
    back the same rows with the same columns as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: add a new column to the SELECT list'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We''re finally ready to do what we set out to do: add `room_name` to the list
    of columns for which we''re querying.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Oracle8 Server SQL Reference, [SELECT command section](http://www.oradoc.com/keyword/select)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next: [complex queries](complex-queries.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[philg@mit.edu](http://philip.greenspun.com/)[Add a comment](/comments/add?page_id=3460)'
  prefs: []
  type: TYPE_NORMAL
