- en: Simple ParsingTuesday, January 17th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On to an implementation of a “parser”:'
  prefs: []
  type: TYPE_NORMAL
- en: Unrelated to what the syntax actually looks like, we want to parse it as soon
    as possible — converting the concrete syntax to an abstract syntax tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter how we write our syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`3+4` (infix),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3 4 +` (postfix),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+(3,4)` (prefix with args in parens),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(+ 3 4)` (parenthesized prefix),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we always mean the same abstract thing — adding the number `3` and the number
    `4`. The essence of this is basically a tree structure with an addition operation
    as the root and two leaves holding the two numerals.
  prefs: []
  type: TYPE_NORMAL
- en: With the right data definition, we can describe this in Racket as the expression
    `(Add (Num 3) (Num 4))` where `Add` and `Num` are constructors of a tree type
    for syntax, or in a C-like language, it could be something like `Add(Num(3),Num(4))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the expression `(3-4)+7` will be described in Racket as the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Important note: “expression” was used in two *different* ways in the above
    — each way corresponds to a different language, and the result of evaluating the
    second “expression” is a Racket value that *represents* the first expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the data type and the necessary constructors we will use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note — Racket follows the tradition of Lisp which makes syntax issues almost
    negligible — the language we use is almost as if we are using the parse tree directly.
    Actually, it is a very simple syntax for parse trees, one that makes parsing extremely
    easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[This has an interesting historical reason… Some Lisp history — *M-expressions*
    vs. *S-expressions*, and the fact that we write code that is isomorphic to an
    AST. Later we will see some of the advantages that we get by doing this. See also
    “*The Evolution of Lisp*”, section 3.5.1 (especially the last sentence).]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To make things very simple, we will use the above fact through a double-level
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: we first “parse” our language into an intermediate representation — a Racket
    list — this is mostly done by a modified version of Racket’s `read` function that
    uses curly `{}` braces instead of round `()` parens,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then we write our own `parse` function that will parse the resulting list into
    an instance of the `AE` type — an abstract syntax tree (AST).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is achieved by the following simple recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is pretty simple, but as our languages grow, they will become
    more verbose and more difficult to write. So, instead, we use a new special form:
    `match`, which is matching a value and binds new identifiers to different parts
    (try it with “Check Syntax”). Re-writing the above code using `match`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, to make it more uniform, we will combine this with the function
    that parses a string into a sexpr so we can use strings to represent our programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
