- en: Homework 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type the following into the terminal to copy the template file to the current
    directory (note the period at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Or you can download the template [here](http://inst.eecs.berkeley.edu/~cs61as/templates/hw5.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: Autograder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working on the lab computers, the `grader` command will run the autograder.
    If you are working on your own personal machine, you should download [grader.rkt](http://inst.eecs.berkeley.edu/~cs61as/autograder/grader.rkt)
    and the [HW 5 tests](http://inst.eecs.berkeley.edu/~cs61as/autograder/tests/hw5-tests.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: SICP 2.26'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we define `x` and `y` to be two lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What result is printed by the interpreter in response to evaluating each of
    the following expressions?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2: SICP 2.29'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A binary mobile consists of two branches, a left branch and a right branch.
    Each branch is a rod of a certain length, from which hangs either a weight or
    another binary mobile. We can represent a binary mobile using compound data by
    constructing it from two branches (for example, using list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A branch is constructed from a length (which must be a number) together with
    a structure, which may be either a number (representing a simple weight) or another
    mobile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**a.** Write the corresponding selectors `left-branch` and `right-branch`,
    which return the branches of a mobile, and `branch-length` and `branch-structure`,
    which return the components of a branch.'
  prefs: []
  type: TYPE_NORMAL
- en: '**b.** Using your selectors, define a procedure `total-weight` that returns
    the total weight of a mobile.'
  prefs: []
  type: TYPE_NORMAL
- en: '**c.** A mobile is said to be *balanced* if the torque applied by its top-left
    branch is equal to that applied by its top-right branch (that is, if the length
    of the left rod multiplied by the weight hanging from that rod is equal to the
    corresponding product for the right side) and if each of the submobiles hanging
    off its branches is balanced. Design a predicate that tests whether a binary mobile
    is balanced.'
  prefs: []
  type: TYPE_NORMAL
- en: '**d.** Suppose we change the representation of mobiles so that the constructors
    are'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How much do you need to change your programs to convert to the new representation?
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: SICP 2.30, 2.31'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**a.** Define a procedure `square-tree` analogous to the `square-list` procedure.
    That is, `square-tree` should behave as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**b.** Abstract your answer to produce a procedure `tree-map` with the property
    that `square-tree` could be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (square-tree tree) (tree-map square tree))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: SICP 2.36'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The procedure `accumulate-n` is similar to `accumulate` except that it takes
    as its third argument a sequence of sequences, which are all assumed to have the
    same number of elements. It applies the designated accumulation procedure to combine
    all the first elements of the sequences, all the second elements of the sequences,
    and so on, and returns a sequence of the results. For instance, if s is a sequence
    containing four sequences, `((1 2 3) (4 5 6) (7 8 9) (10 11 12))`, then the value
    of `(accumulate-n + 0 s)` should be the sequence`(22 26 30)`. Fill in the missing
    expressions in the following definition of `accumulate-n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we represent vectors *v* = (*v*[*i*]) as sequences of numbers, and matrices
    *m* = (*m*[*i*,*j*]) as sequences of vectors (the rows of the matrix). For example,
    the matrix
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08b19ae183508723c4b9c4eef0ff4533.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'is represented as the sequence `((1 2 3 4) (4 5 6 6) (6 7 8 9))`. With this
    representation, we can use sequence operations to concisely express the basic
    matrix and vector operations. These operations (which are described in any book
    on matrix algebra) are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/752b164e529b03c16a290c2eb19d5ed0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can define the dot product as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Fill in the missing expressions in the following procedures for computing the
    other matrix operations. (The procedure accumulate-n is defined in the previous
    exercise)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 6: SICP 2.38'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `accumulate` procedure is also known as `fold-right`, because it combines
    the first element of the sequence with the result of combining all the elements
    to the right. There is also a `fold-left`, which is similar to `fold-right`, except
    that it combines elements working in the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What are the values of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Describe a property that `op` should satisfy to guarantee that `fold-right`
    and `fold-left` will produce the same values for any sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: SICP 2.54'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two lists are said to be equal if they contain equal elements arranged in the
    same order. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: is true, but
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: is false. To be more precise, we can define `equal?` recursively in terms of
    the basic `eq?` equality of symbols by saying that a and b are `equal?` if they
    are both symbols and the symbols are `eq?`, or if they are both lists such that
    `(car a)` is `equal?` to `(car b)` and `(cdr a)` is `equal?` to `(cdr b)`. Using
    this idea, implement `equal?` as a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: you should know by now that `equal?` is a built-in procedure as well.
    This means your definition will overwrite the built-in definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can represent a set as a list of distinct elements, and we can represent
    the set of all subsets of the set as a list of lists. For example, if the set
    is `(1 2 3)`, then the set of all subsets is `(() (3) (2) (2 3) (1) (1 3) (1 2)
    (1 2 3))`. Complete the following definition of a procedure that generates the
    set of subsets of a set and give a clear explanation of why it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extend `calc.rkt` to include words as data, providing the operations `first,
    butfirst, last, butlast, and word`. Unlike Racket, your calculator should treat
    words as self-evaluating expressions except when seen as the operator of a compound
    expression. That is, it should work like these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Remember, you can get the program by typing
  prefs: []
  type: TYPE_NORMAL
- en: '`cp ~cs61as/lib/calc.rkt .`'
  prefs: []
  type: TYPE_NORMAL
- en: Or download it from [here](http://inst.eecs.berkeley.edu/~cs61as/library/calc.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10: Extra for Experts'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Do this if you want to. This is NOT for credit.**'
  prefs: []
  type: TYPE_NORMAL
- en: Read [section 2.3.4](http://mitpress.mit.edu/sicp/full- text/book/book-Z-H-16.html#%25_sec_2.3.4)
    and do exercises 2.67 - 2.72.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11: Extra for Experts'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Do this if you want to. This is NOT for credit.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming by example: In some programming systems, instead of writing an
    algorithm, you give examples of how you''d like the program to behave, and the
    language figures out the algorithm itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Write `regroup`. Read `~cs61as/lib/regroup.problem` for details.
  prefs: []
  type: TYPE_NORMAL
- en: Submit Your Homework!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For instructions, see [this guide](../submit.html). It covers basic terminal
    commands and assignment submission.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any trouble submitting, do not hesitate to ask a TA!
  prefs: []
  type: TYPE_NORMAL
