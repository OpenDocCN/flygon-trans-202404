- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Set is a data type used to store a collection of elements. There is no order
    on the collection, and all the elements must be distinct (so you cannot have several
    copies of the same element in the set). In other words, a Set is the Kotlin implementation
    of a set in mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets appear naturally in many problems: Correctly spelled words form a set.
    Prime numbers form a set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we could simply use a list (or an array) to store a collection of
    items that forms a set. But this is not natural and often not efficient: A list
    is an indexed sequence, where the elements have an ordering, the same element
    can appear several times, and searching for an element can only be done by looking
    at all the elements one by one.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the Java standard library used by Kotlin provides for us a very
    nice Set data type. More precisely, Set is a parameterized data type, so there
    is a Set<Int>, Set<String>, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create some sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that for the empty set you have to indicate the type of elements, since
    Kotlin cannot deduce it from the elements themselves. You can also create sets
    by converting other collections (lists, arrays, ranges) using their toSet() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that it doesn''t matter in which order you write the elements, and
    an element cannot appear more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The + and - operators can be used to add elements to a set, and to remove elements
    from a set. The result is a new set. It is okay to add elements already in the
    set, and to remove elements not in the set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard mathematical operations of union, intersection, difference, and
    containment can (mostly) be implemented using Set methods:'
  prefs: []
  type: TYPE_NORMAL
- en: \(|s|\) is s.size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(s \cup t\) is s + t
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(s \setminus t\) is s - t
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(x \in s\)? is s.contains(x) or x in s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(s \subseteq t\)? is t.containsAll(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(s \cap t\) has no method, but can be implemented as s.filter { it in t }.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Sets support many other operations, some of which you are already familiar
    with from lists, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: s.size is the size of the set;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s.isEmpty() is the same as s.size == 0;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s.isNotEmpty() is the same as s.size != 0;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s.max(), s.min(), s.sum() return the largest, smallest, and sum of elements
    in the set;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s.sorted() returns a list with the elements of s in sorted order;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s.joinToString() returns a string with all elements of s concatenated together
    (with the same options as for lists);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s.toList() and s.toMutableList() return a (mutable) list with the same elements
    as the set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a first example of using sets, here is a simple spell checker. It makes use
    of the file [words.txt](code/words.txt), containing 113809 English words, one
    per line.
  prefs: []
  type: TYPE_NORMAL
- en: We read the file and immediately convert it to a set. Then we allow the user
    to enter words from the terminal. We check if the word is in the set of correctly
    spelled words, and report this back ([spell.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/13-sets/spell.kts)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You could also use sets to measure the similarity between two texts (for instance
    to classify documents on the web). Consider the set of words of each text, and
    compare the size of their union with the size of their intersection.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All the sets we have looked at above are immutable: There is no way to change
    the contents of a Set. Set operations like union and intersection actually return
    a new set object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is more efficient or convenient to use a mutable set (but remember
    that these are more dangerous to use). The Java standard library provides a mutable
    set data type, called MutableSet in Kotlin. We add elements with add, and remove
    them with remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A classic application of sets is the Sieve of Erathosthenes to compute prime
    numbers. Here is one implementation ([sieve.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/13-sets/sieve.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output of a run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are many other applications of sets. For instance, when finding your way
    in a maze, you could store the positions already seen in a set. Similarly, when
    implementing a computer game, you could store the game positions already evaluated
    in a set.
  prefs: []
  type: TYPE_NORMAL
