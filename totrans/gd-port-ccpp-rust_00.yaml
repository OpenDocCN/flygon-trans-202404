- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Guide to Porting C/C++ to Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for people familiar with C or C++ who are thinking of using Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go into what Rust is or why it might be preferable to C/C++ *in some
    cases*, let's think of software that is mission critical and must not or should
    not fail.
  prefs: []
  type: TYPE_NORMAL
- en: Operating system services and daemons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet of things devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Industrial control software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Medical devices - MRI, ultrasound, X-ray, ventilators etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High availability servers / databases / cloud storage etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avionics, telemetry, rocketry, drones etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this code must run as efficiently and reliably as possible. It must run
    on devices for days, weeks, months or preferably years without failure. It cannot
    suffer intermittent freezes, erratic performance, memory leaks, crashes or other
    issues without impacting on its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally such software would be written in C or C++, but consider these *every
    day* programming issues that can afflict these languages:'
  prefs: []
  type: TYPE_NORMAL
- en: Dangling pointers. A program calls an invalid pointer causing a crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer overruns / underruns. Code writes beyond an allocated buffer causing
    memory corruption or a page exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory leaks. Code that allocates memory *or resources* without calling the
    corresponding free action. C++ provides classes such as smart pointers and techniques
    like RAII to mitigate these issues but still occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data races. Multiple threads write to data at the same time causing corruption
    or other destabilizing behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rust stops these bad things happening **by design**. And it does so without
    impacting on runtime performance because all of these things are checked at compile
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: Object lifetimes are tracked automatically to prevent memory leaks and dangling
    pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of arrays and collections is enforced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data race conditions are prevented by strict enforcement of mutex / guards and
    object ownership.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that passes the compiler's checks is transformed into machine code with
    similar performance and speed as the equivalent C or C++.
  prefs: []
  type: TYPE_NORMAL
- en: This is a "zero-cost" approach. The compiler enforces the rules so that there
    is zero runtime cost over the equivalent and correctly written program in C or
    C++. Safety does not compromise performance.
  prefs: []
  type: TYPE_NORMAL
- en: In addition Rust plays well C. You may invoke C from Rust or invoke Rust from
    C using foreign function interfaces. You can choose to rewrite a critical section
    of your codebase leave the remainder alone.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Firefox browser uses Rust to analyse video stream data - headers
    and such like where corrupt or malicious code could destabilize the browser or
    even be exploitable.
  prefs: []
  type: TYPE_NORMAL
- en: Why Rust?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by saying if what you have works and is reliable, then the answer
    to the question is "there's no reason" you should consider porting.
  prefs: []
  type: TYPE_NORMAL
- en: However if you have code that *doesn't* work or *isn't* reliable, or *hasn't*
    been written yet or is due a major rewrite then perhaps you have answered your
    own question.
  prefs: []
  type: TYPE_NORMAL
- en: You could write the code or fixes in C/C++ in which case you have to deal with
    all the unsafe issues that the language does not protect you from. Or you might
    consider that choosing a safe-by-design language is a good way to protect you
    from suffering bugs in the field when the code is supposed to be ready for production.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is not a magic wand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Despite the things the language can protect you against, it cannot protect
    you against the following:'
  prefs: []
  type: TYPE_NORMAL
- en: General race conditions such as deadlocks between threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbounded growth, e.g. a loop that pushes values onto a vector until memory
    is exhausted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application logic errors, i.e. errors that have nothing to do with the underlying
    language, e.g. missing out the line that should say "if door_open { sound_alarm();
    }"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit unsafe sections doing unsafe and erroneous things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors in LLVM or something outside of Rust's control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
