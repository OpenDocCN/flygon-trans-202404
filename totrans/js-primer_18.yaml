- en: オブジェクト
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/object/](https://jsprimer.net/basic/object/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: オブジェクトはプロパティの集合です。プロパティとは名前（キー）と値（バリュー）が対になったものです。 プロパティのキーには文字列または`Symbol`が利用でき、値には任意のデータを指定できます。
    また、1つのオブジェクトは複数のプロパティを持てるため、1つのオブジェクトで多種多様な値を表現できます。
  prefs: []
  type: TYPE_NORMAL
- en: 今までも登場してきた、配列や関数などもオブジェクトの一種です。 JavaScriptには、あらゆるオブジェクトの元となる`Object`というビルトインオブジェクトがあります。
    ビルトインオブジェクトは、実行環境にあらかじめ定義されているオブジェクトのことです。 `Object`というビルトインオブジェクトはECMAScriptの仕様で定義されているため、あらゆるJavaScriptの実行環境で利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: この章では、オブジェクトの作成や扱い方、`Object`というビルトインオブジェクトについて見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#create-object)*オブジェクトを作成する*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*オブジェクトを作成するには、オブジェクトリテラル（`{}`）を利用します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: オブジェクトリテラルでは、初期値としてプロパティを持つオブジェクトを作成できます。 プロパティは、オブジェクトリテラル（`{}`）の中にキーと値を`:`（コロン）で区切って記述します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: オブジェクトリテラルのプロパティ名（キー）はクォート（`"`や`'`）を省略できます。 そのため、次のように書いても同じです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: ただし、変数名として利用できないプロパティ名はクォート（`"`や`'`）で囲む必要があります。 次の`my-prop`というプロパティ名は、変数名として利用できない`-`が含まれているため定義できません（「[変数と宣言](../variables/
    "変数と宣言")」の章の「[変数名に使える名前のルール](../variables/#variable-name) 」を参照）
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`my-prop`というプロパティ名を定義する場合は、クォート（`"`や`''`）で囲む必要があります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: オブジェクトリテラルでは複数のプロパティ（キーと値の組み合わせ）を持つオブジェクトも作成できます。 複数のプロパティを定義するには、それぞれのプロパティを`,`（カンマ）で区切ります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: プロパティの値に変数名を指定すれば、そのキーは指定した変数を参照します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: またES2015からは、プロパティ名と値に指定する変数名が同じ場合は`{ name }`のように省略して書けます。 次のコードは、プロパティ名`name`に変数`name`を値にしたプロパティを設定しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: この省略記法は、モジュールや分割代入においても共通した表現です。 そのため、`{}`の中でプロパティ名が単独で書かれている場合は、この省略記法を利用していることに注意してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#object-instance-object)*`{}`は`Object`のインスタンスオブジェクト*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Object`はJavaScriptのビルトインオブジェクトです。 オブジェクトリテラル（`{}`）は、このビルトインオブジェクトである`Object`を元にして新しいオブジェクトを作成するための構文です。'
  prefs: []
  type: TYPE_NORMAL
- en: オブジェクトリテラル以外の方法として、`new`演算子を使うことで、`Object`から新しいオブジェクトを作成できます。 次のコードでは、`new Object()`でオブジェクトを作成していますが、これは空のオブジェクトリテラルと同じ意味です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: オブジェクトリテラルのほうが明らかに簡潔で、プロパティの初期値も指定できるため、`new Object()`を使う利点はありません。
  prefs: []
  type: TYPE_NORMAL
- en: '`new Object()`でオブジェクトを作成することは、「`Object`のインスタンスオブジェクトを作成する」と言います。 しかしながら、`Object`やインスタンスオブジェクトなどややこしい言葉の使い分けが必要となってしまいます。
    そのため、この書籍ではオブジェクトリテラルと`new Object`どちらの方法であっても、単に「オブジェクトを作成する」と呼びます。'
  prefs: []
  type: TYPE_NORMAL
- en: オブジェクトリテラルは、`Object`から新しいインスタンスオブジェクトを作成していることを意識しておくとよいでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#property-access)*プロパティへのアクセス*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*オブジェクトのプロパティにアクセスする方法として、ドット記法（`.`）を使う方法とブラケット記法（`[]`）があります。 それぞれの記法でプロパティ名を指定すると、その名前を持ったプロパティの値を参照できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ドット記法（`.`）では、プロパティ名が変数名と同じく識別子の命名規則を満たす必要があります（「[変数と宣言](../variables/ "変数と宣言")」の章の「[変数名に使える名前のルール](../variables/#variable-name)
    」を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 一方、ブラケット記法では、`[`と`]`の間に任意の式を書けます。 そのため、識別子の命名規則とは関係なく、任意の文字列をプロパティ名として指定できます。
    ただし、プロパティ名は文字列へと暗黙的に変換されることに注意してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: また、ブラケット記法ではプロパティ名に変数も利用できます。 次のコードでは、プロパティ名に`myLang`という変数をブラケット記法で指定しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ドット記法ではプロパティ名に変数は利用できないため、プロパティ名に変数を指定したい場合はブラケット記法を利用します。 基本的には簡潔なドット記法（`.`）を使い、ドット記法で書けない場合はブラケット記法（`[]`）を使うとよいでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#object-destructuring)*[ES2015] オブジェクトと分割代入*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*同じオブジェクトのプロパティに何度もアクセスする場合に、何度も`オブジェクト.プロパティ名`と書くと冗長となりやすいです。 そのため、短い名前で利用できるように、そのプロパティを変数として定義し直すことがあります。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、変数`ja`と`en`を定義し、その初期値として`languages`オブジェクトのプロパティを代入しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: このようにオブジェクトのプロパティを変数として定義し直すときには、分割代入（Destructuring assignment）が利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: オブジェクトの分割代入では、左辺にオブジェクトリテラルのような構文で変数名を定義します。 右辺のオブジェクトから対応するプロパティ名が、左辺で定義した変数に代入されます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、先ほどのコードと同じように`languages`オブジェクトから`ja`と`en`プロパティを取り出して変数として定義しています。 代入演算子のオペランドとして左辺と右辺それぞれに`ja`と`en`と書いていたのが、分割代入では一箇所に書くことができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[](#add-property)*プロパティの追加*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*オブジェクトは、一度作成した後もその値自体を変更できるというミュータブル（mutable）の特性を持ちます。 そのため、作成したオブジェクトに対して、後からプロパティを追加できます。'
  prefs: []
  type: TYPE_NORMAL
- en: プロパティの追加方法は単純で、作成したいプロパティ名へ値を代入するだけです。 そのとき、オブジェクトに指定したプロパティが存在しないなら、自動的にプロパティが作成されます。
  prefs: []
  type: TYPE_NORMAL
- en: プロパティの追加はドット記法、ブラケット記法どちらでも可能です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 先ほども紹介したように、ドット記法は変数の識別子として利用可能なプロパティ名しか利用できません。
  prefs: []
  type: TYPE_NORMAL
- en: 一方、ブラケット記法は`object[式]`の`式`の評価結果を文字列にしたものをプロパティ名として利用できます。 そのため、次のものをプロパティ名として扱う場合にはブラケット記法を利用します。
  prefs: []
  type: TYPE_NORMAL
- en: 変数
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 変数の識別子として扱えない文字列
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: ブラケット記法を用いたプロパティ定義は、オブジェクトリテラルの中でも利用できます。 オブジェクトリテラル内でのブラケット記法を使ったプロパティ名は**Computed
    property names**と呼ばれます。 Computed property namesはES2015から導入された記法ですが、`式`の評価結果をプロパティ名に使う点はブラケット記法と同じです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、Computed property namesを使い`key`変数の評価結果である`"key-string"`をプロパティ名にしています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: JavaScriptのオブジェクトは、作成後にプロパティが変更可能というmutableの特性を持つことを紹介しました。 そのため、関数が受け取ったオブジェクトに対して、勝手にプロパティを追加できてしまいます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードは、`changeProperty`関数が引数として受け取ったオブジェクトにプロパティを追加している悪い例です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: このように、プロパティを初期化時以外に追加してしまうと、そのオブジェクトがどのようなプロパティを持っているかがわかりにくくなります。 そのため、できる限り作成後に新しいプロパティは追加しないほうがよいでしょう。
    オブジェクトの作成時のオブジェクトリテラルの中でプロパティを定義することを推奨します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#remove-property)*プロパティの削除*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*オブジェクトのプロパティを削除するには`delete`演算子を利用します。 削除したいプロパティを`delete`演算子の右辺に指定して、プロパティを削除できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[](#const-and-object)*[コラム] constで定義したオブジェクトは変更可能*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*先ほどのコード例で、`const`で宣言したオブジェクトのプロパティがエラーなく変更できていることがわかります。 次のコードを実行してみると、値であるオブジェクトのプロパティが変更できていることがわかります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: JavaScriptの`const`は値を固定するのではなく、変数への再代入を防ぐためのものです。 そのため、次のような`obj`変数への再代入は防げますが、変数に代入された値であるオブジェクトの変更は防げません（「[変数と宣言](../variables/
    "変数と宣言")」の[const](../variables/#const)を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 作成したオブジェクトのプロパティの変更を防止するには`Object.freeze`メソッドを利用する必要があります。 `Object.freeze`はオブジェクトを凍結します。凍結されたオブジェクトでプロパティの追加や変更をすると例外が発生するようになります。
  prefs: []
  type: TYPE_NORMAL
- en: ただし、`Object.freeze`メソッドを利用する場合は必ずstrict modeと合わせて使います（詳細は「[JavaScriptとは](../introduction/)」の[strict
    mode](../introduction/#strict-mode)を参照）。 strict modeではない場合は、凍結されたオブジェクトのプロパティを変更しても例外が発生せずに単純に無視されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[](#confirm-property)*プロパティの存在を確認する*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*JavaScriptでは、存在しないプロパティに対してアクセスした場合に例外ではなく`undefined`を返します。 次のコードは、`obj`には存在しない`notFound`プロパティにアクセスしているため、`undefined`という値が返ってきます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: このように、JavaScriptでは存在しないプロパティへアクセスした場合に例外が発生しません。 プロパティ名を間違えた場合に単に`undefined`という値を返すため、間違いに気づきにくいという問題があります。
  prefs: []
  type: TYPE_NORMAL
- en: 次のようにプロパティ名を間違えていた場合にも、例外が発生しません。 さらにプロパティ名をネストしてアクセスした場合に、初めて例外が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`undefined`や`null`はオブジェクトではないため、存在しないプロパティへアクセスすると例外が発生してしまいます。 あるオブジェクトがあるプロパティを持っているかを確認する方法として、次の4つがあります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`との比較'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in`演算子'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.hasOwn`静的メソッド^([ES2022])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype.hasOwnProperty`メソッド'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](#compare-to-undefined)*プロパティの存在確認: undefinedとの比較*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*存在しないプロパティへアクセスした場合に`undefined`を返すため、実際にプロパティアクセスすることでも判定できそうです。 次のコードでは、`key`プロパティの値が`undefined`ではないという条件式で、プロパティが存在するかを判定しています。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: しかし、この方法はプロパティの値が`undefined`であった場合に、プロパティそのものが存在するかを区別できないという問題があります。 次のコードでは、`key`プロパティの値が`undefined`であるため、プロパティが存在しているにもかかわらずif文の中は実行されません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: このような問題があるため、プロパティが存在するかを判定するには`in`演算子か`Object.hasOwn`静的メソッドを利用します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#in-operator)*プロパティの存在確認: in演算子を使う*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`in`演算子は、指定したオブジェクト上に指定したプロパティがあるかを判定し真偽値を返します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは`obj`に`key`プロパティが存在するかを判定しています。 `in`演算子は、プロパティの値は関係なく、プロパティが存在した場合に`true`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[](#object-hasown-method)*[ES2022] プロパティの存在確認: `Object.hasOwn`静的メソッド*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Object.hasOwn`静的メソッドは、対象のオブジェクトが指定したプロパティを持っているかを判定できます。 この`Object.hasOwn`静的メソッドの引数には、オブジェクトとオブジェクトが持っているかを確認したいプロパティ名を渡します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは`obj`に`key`プロパティが存在するかを判定しています。 `Object.hasOwn`静的メソッドも、プロパティの値は関係なく、オブジェクトが指定したプロパティを持っている場合に`true`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`in`演算子と`Object.hasOwn`静的メソッドは同じ結果を返していますが、厳密には動作が異なるケースもあります。 この動作の違いを知るにはまずプロトタイプオブジェクトという特殊なオブジェクトについて理解する必要があります。
    そのため、`in`演算子と`Object.hasOwn`静的メソッドの違いについては、次の章の「[プロトタイプオブジェクト](../prototype-object/
    "クラス")」で詳しく解説します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#hasOwnProperty-method)*プロパティの存在確認: `Object.prototype.hasOwnProperty`メソッド*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Object.hasOwn`静的メソッドはES2022で導入されたメソッドです。 ES2022より前では、`Object.prototype.hasOwnProperty`メソッドというよく似たメソッドが利用されていました。
    `hasOwnProperty`メソッドは、`Object.hasOwn`静的メソッドとよく似ていますが、オブジェクトのインスタンスから呼び出す点が異なります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: しかし、`hasOwnProperty`メソッドには欠点があるため、`Object.hasOwn`静的メソッドが利用できる状況では使う理由はありません。
    この欠点もプロトタイプオブジェクトに関係するため、次の章の「[プロトタイプオブジェクト](../prototype-object/ "クラス")」で詳しく解説します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#optional-chaining-operator)*[ES2020] Optional chaining演算子（`?.`）*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*プロパティの存在を確認する方法として4つの方法を紹介しました。 プロパティが存在するかが重要な場合は、基本的には`in`演算子または`Object.hasOwn`静的メソッドを使います。'
  prefs: []
  type: TYPE_NORMAL
- en: しかし、最終的に取得したいものがプロパティの値であるならば、if文で`undefined`と比較しても問題ありません。 なぜなら、値を取得したい場合には、プロパティが存在するかどうかとプロパティの値が`undefined`かどうかの違いを区別する意味はないためです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`widget.window.title`プロパティに値が定義されているなら(`undefined`ではないなら)、そのプロパティの値をコンソールに表示しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: この`widget.window.title`のようなネストしたプロパティにアクセスする際には、プロパティの存在を順番に確認してからアクセスする必要があります。
    なぜなら、`widget`オブジェクトが`window`プロパティを持っていない場合は`undefined`という値を返すためです。このときに、さらにネストした`widget.window.title`プロパティにアクセスすると、`undefined.title`という参照となり例外が発生してしまいます。
  prefs: []
  type: TYPE_NORMAL
- en: しかし、プロパティへアクセスするたびに`undefined`との比較をAND演算子（`&&`）でつなげて書いていくと冗長です。
  prefs: []
  type: TYPE_NORMAL
- en: この問題を解決するために、ES2020ではネストしたプロパティの存在確認とアクセスを簡単に行う構文としてOptional chaining演算子（`?.`）が導入されました。
    Optional chaining演算子（`?.`）は、ドット記法（`.`）の代わりに`?.`をプロパティアクセスに使います。
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining演算子（`?.`）は左辺のオペランドがnullish（`null`または`undefined`）の場合は、それ以上評価せずに`undefined`を返します。一方で、プロパティが存在する場合は、そのプロパティの評価結果を返します。
  prefs: []
  type: TYPE_NORMAL
- en: つまり、Optional chaining演算子（`?.`）では、存在しないプロパティへアクセスした場合でも例外ではなく、`undefined`という値を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 先ほどのウィジェットのタイトルを表示する関数もOptional chaining演算子（`?.`）を使うと、if文を使わずに書けます。 次のコードの`printWidgetTitle`関数では、`widget?.window?.title`にアクセスできる場合はその評価結果が変数`title`に入ります。
    プロパティにアクセスできない場合は`undefined`を返すため、Nullish coalescing演算子(`??`)によって右辺の`"未定義"`が変数`title`のデフォルト値となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: また、Optional chaining演算子（`?.`）はブラケット記法（`[]`）と組み合わせることもできます。 ブラケット記法の場合も、左辺のオペランドがnullish（`null`または`undefined`）の場合は、それ以上評価せずに`undefined`を返します。一方で、プロパティが存在する場合は、そのプロパティの評価結果を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[](#toString-method)*`toString`メソッド*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*オブジェクトの`toString`メソッドは、オブジェクト自身を文字列化するメソッドです。 `String`コンストラクタ関数を使うことでも文字列化できます。
    この2つにはどのような違いがあるのでしょうか？（`String`コンストラクタ関数については「[暗黙的な型変換](../implicit-coercion/#to-string)」を参照）'
  prefs: []
  type: TYPE_NORMAL
- en: 実は`String`コンストラクタ関数は、引数に渡されたオブジェクトの`toString`メソッドを呼び出しています。 そのため、`String`コンストラクタ関数と`toString`メソッドの結果はどちらも同じになります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: このことは、オブジェクトに`toString`メソッドを再定義してみるとわかります。 独自の`toString`メソッドを定義したオブジェクトを`String`コンストラクタ関数で文字列化してみます。
    すると、再定義した`toString`メソッドの返り値が、`String`コンストラクタ関数の返り値になることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[](#object-property-is-to-string)*[コラム] オブジェクトのプロパティ名は文字列化される*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*オブジェクトのプロパティへアクセスする際に、指定したプロパティ名は暗黙的に文字列に変換されます。 ブラケット記法では、オブジェクトをプロパティ名に指定することもできますが、これは意図したようには動作しません。
    なぜなら、オブジェクトを文字列化すると`"[object Object]"`という文字列になるためです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`keyObject1`と`keyObject2`をブラケット記法でプロパティ名に指定しています。 しかし、`keyObject1`と`keyObject2`はどちらも文字列化すると`"[object
    Object]"`という同じプロパティ名となります。 そのため、プロパティは意図せず上書きされてしまいます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 唯一の例外として、Symbolだけは文字列化されずにオブジェクトのプロパティ名として扱えます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 基本的にはオブジェクトのプロパティ名は文字列として扱われることを覚えておくとよいでしょう。 また、`Map`というビルトインオブジェクトはオブジェクトをキーとして扱えます（詳細は「[Map/Set](../map-and-set/)」の章で解説します）。
    そのため、オブジェクトをキーに指定したい場合は`Map`を利用します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#static-method)*オブジェクトの静的メソッド*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*最後にビルトインオブジェクトである`Object`の静的メソッドについて見ていきましょう。 **静的メソッド**（スタティックメソッド）とは、インスタンスの元となるオブジェクトから呼び出せるメソッドのことです。'
  prefs: []
  type: TYPE_NORMAL
- en: Objectの`toString`メソッドなどは、`Object`のインスタンスオブジェクトから呼び出すメソッドでした。 これに対して、`Object.hasOwn`静的メソッドのような静的メソッドは`Object`そのものに実装されているメソッドです。
  prefs: []
  type: TYPE_NORMAL
- en: ここでは、オブジェクトの処理でよく利用されるいくつかの**静的メソッド**を紹介します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#enumeration)*オブジェクトの列挙*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*最初に紹介したように、オブジェクトはプロパティの集合です。 そのオブジェクトのプロパティを列挙する方法として、次の3つの静的メソッドがあります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.keys`メソッド: オブジェクトのプロパティ名の配列にして返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.values`メソッド^([ES2017]): オブジェクトの値の配列にして返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.entries`メソッド^([ES2017]): オブジェクトのプロパティ名と値の配列の配列を返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: それぞれ、オブジェクトのキー、値、キーと値の組み合わせを配列にして返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: これらのプロパティを列挙する静的メソッドと配列の`forEach`メソッドなどを組み合わせれば、プロパティに対して反復処理ができます。 次のコードでは、`Object.keys`メソッドで取得したプロパティ名の一覧をコンソールへ出力しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[](#copy-and-merge)*オブジェクトのマージと複製*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Object.assign`メソッド^([ES2015])は、あるオブジェクトを別のオブジェクトに代入（assign）できます。 このメソッドを使うことで、オブジェクトの複製やオブジェクト同士のマージができます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.assign`メソッドは、`target`オブジェクトに対して、1つ以上の`sources`オブジェクトを指定します。 `sources`オブジェクト自身が持つ列挙可能なプロパティを第一引数の`target`オブジェクトに対してコピーします。
    `Object.assign`メソッドの返り値は、`target`オブジェクトになります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[](#merge)*オブジェクトのマージ*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*具体的なオブジェクトのマージの例を見ていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、新しく作った空のオブジェクトを`target`にしています。 この空のオブジェクト（`target`）に`objectA`と`objectB`をマージしたものが、`Object.assign`メソッドの返り値となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 第一引数には空のオブジェクトではなく、既存のオブジェクトも指定できます。 第一引数に既存のオブジェクトを指定した場合は、そのオブジェクトのプロパティが変更されます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、第一引数に指定された`objectA`に対してプロパティが追加されています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 空のオブジェクトを`target`にすることで、既存のオブジェクトには影響を与えずマージしたオブジェクトを作ることができます。 そのため、`Object.assign`メソッドの第一引数には、空のオブジェクトリテラルを指定するのが典型的な利用方法です。
  prefs: []
  type: TYPE_NORMAL
- en: このとき、プロパティ名が重複した場合は、後ろのオブジェクトのプロパティにより上書きされます。 JavaScriptでは、基本的に処理は先頭から後ろへと順番に行います。
    そのため、空のオブジェクトへ`objectA`を代入してから、その結果に`objectB`を代入するという形になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[](#object-spread-syntax)*[ES2018] オブジェクトのspread構文でのマージ*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*ES2018では、オブジェクトのマージを行うオブジェクトの`...`（spread構文）が追加されました。 ES2015で配列の要素を展開する`...`（spread構文）はサポートされていましたが、オブジェクトに対してもES2018でサポートされました。
    オブジェクトのspread構文は、オブジェクトリテラルの中に指定したオブジェクトのプロパティを展開できます。'
  prefs: []
  type: TYPE_NORMAL
- en: オブジェクトのspread構文は、`Object.assign`とは異なり必ず新しいオブジェクトを作成します。 なぜならspread構文はオブジェクトリテラルの中でのみ記述でき、オブジェクトリテラルは新しいオブジェクトを作成するためです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは`objectA`と`objectB`をマージした新しいオブジェクトを返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: プロパティ名が被った場合の優先順位は、後ろにあるオブジェクトが優先されます。 そのため同じプロパティ名を持つオブジェクトをマージした場合には、後ろにあるオブジェクトによってプロパティが上書きされます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[](#copy)*オブジェクトの複製*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*JavaScriptには、オブジェクトを複製する関数は用意されていません。 しかし、新しく空のオブジェクトを作成し、そこへ既存のオブジェクトのプロパティをコピーすれば、それはオブジェクトの複製をしていると言えます。
    次のように、`Object.assign`メソッドを使うことでオブジェクトを複製できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 注意点として、`Object.assign`メソッドは`sources`オブジェクトのプロパティを浅くコピー（shallow copy）する点です。 shallow
    copyとは、`sources`オブジェクトの直下にあるプロパティだけをコピーするということです。 そのプロパティの値がオブジェクトである場合に、ネストした先のオブジェクトまでも複製するわけではありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 逆にプロパティの値までも再帰的に複製してコピーすることを、深いコピー（deep copy）と呼びます。 deep copyは、再帰的にshallow copyすることで実現できます。
    次のコードでは、`deepClone`を`shallowClone`を使うことで実現しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: このように、JavaScriptのビルトインメソッドは浅い（shallow）実装のみを提供し、深い（deep）実装は提供していないことが多いです。 言語としては最低限の機能を提供し、より複雑な機能はユーザー側で実装するという形式を取るためです。
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScriptは言語仕様で定義されている機能が最低限であるため、それを補うようにユーザーが作成した小さな機能を持つライブラリが数多く公開されています。
    それらのライブラリはnpmと呼ばれるJavaScriptのパッケージ管理ツールで公開され、JavaScriptのエコシステムを築いています。 ライブラリの利用については「[ユースケース:
    Node.jsでCLIアプリケーション](../../use-case/nodecli/)」の章で紹介します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#conclusion)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では、オブジェクトについて学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object`というビルトインオブジェクトがある'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{}`（オブジェクトリテラル）でのオブジェクトの作成や更新方法'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: プロパティの存在を確認するには`in`演算子か`Object.hasOwn`静的メソッドを使う
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional chaining演算子（`?.`）はネストしたプロパティの存在確認とアクセスを同時に行う記法
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: オブジェクトのインスタンスメソッドと静的メソッド
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScriptの`Object`は他のオブジェクトのベースとなるオブジェクトです。 次の「[プロトタイプオブジェクト](../prototype-object/
    "クラス")」の章では、`Object`がどのようにベースとして動作しているのかを見ていきます。**********************
  prefs: []
  type: TYPE_NORMAL
