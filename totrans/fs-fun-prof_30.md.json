["```\nlet ``+1 then sort should be same as sort then +1`` sortFn aList = \n    let add1 x = x + 1\n\n    let result1 = aList |> sortFn |> List.map add1\n    let result2 = aList |> List.map add1 |> sortFn \n    result1 = result2\n\n// test \nlet goodSort = List.sort\nCheck.Quick (``+1 then sort should be same as sort then +1`` goodSort)\n// Ok, passed 100 tests. \n```", "```\nlet badSort aList = aList\nCheck.Quick (``+1 then sort should be same as sort then +1`` badSort)\n// Ok, passed 100 tests. \n```", "```\nlet ``append minValue then sort should be same as sort then prepend minValue`` sortFn aList = \n    let minValue = Int32.MinValue\n\n    let appendThenSort = (aList @ [minValue]) |> sortFn \n    let sortThenPrepend = minValue :: (aList |> sortFn)\n    appendThenSort = sortThenPrepend \n\n// test\nCheck.Quick (``append minValue then sort should be same as sort then prepend minValue`` goodSort)\n// Ok, passed 100 tests. \n```", "```\nCheck.Quick (``append minValue then sort should be same as sort then prepend minValue`` badSort)\n// Falsifiable, after 1 test (2 shrinks) \n// [0] \n```", "```\n// The Enterprise Developer From Hell strikes again\nlet badSort2 aList = \n    match aList with\n    | [] -> []\n    | _ -> \n        let last::reversedTail = List.rev aList \n        if (last = Int32.MinValue) then\n            // if min is last, move to front\n            let unreversedTail = List.rev reversedTail\n            last :: unreversedTail \n        else\n            aList // leave alone \n```", "```\n// Oh dear, the bad implementation passes!\nCheck.Quick (``append minValue then sort should be same as sort then prepend minValue`` badSort2)\n// Ok, passed 100 tests. \n```", "```\nlet ``negate then sort should be same as sort then negate then reverse`` sortFn aList = \n    let negate x = x * -1\n\n    let negateThenSort = aList |> List.map negate |> sortFn \n    let sortThenNegateAndReverse = aList |> sortFn |> List.map negate |> List.rev\n    negateThenSort = sortThenNegateAndReverse \n```", "```\n// test\nCheck.Quick ( ``negate then sort should be same as sort then negate then reverse`` goodSort)\n// Ok, passed 100 tests.\n\n// test\nCheck.Quick ( ``negate then sort should be same as sort then negate then reverse``  badSort)\n// Falsifiable, after 1 test (1 shrinks) \n// [1; 0]\n\n// test\nCheck.Quick ( ``negate then sort should be same as sort then negate then reverse``  badSort2)\n// Falsifiable, after 5 tests (3 shrinks) \n// [1; 0] \n```", "```\nlet ``append any value then reverse should be same as reverse then prepend same value`` revFn anyValue aList = \n\n    let appendThenReverse = (aList @ [anyValue]) |> revFn \n    let reverseThenPrepend = anyValue :: (aList |> revFn)\n    appendThenReverse = reverseThenPrepend \n```", "```\n// test\nlet goodReverse = List.rev\nCheck.Quick (``append any value then reverse should be same as reverse then prepend same value`` goodReverse)\n// Ok, passed 100 tests.\n\n// bad implementation fails\nlet badReverse aList = []\nCheck.Quick (``append any value then reverse should be same as reverse then prepend same value`` badReverse)\n// Falsifiable, after 1 test (2 shrinks) \n// true, []\n\n// bad implementation fails\nlet badReverse2 aList = aList \nCheck.Quick (``append any value then reverse should be same as reverse then prepend same value`` badReverse2)\n// Falsifiable, after 1 test (1 shrinks) \n// true, [false] \n```", "```\nlet ``reverse then reverse should be same as original`` revFn aList = \n    let reverseThenReverse = aList |> revFn |> revFn\n    reverseThenReverse = aList \n```", "```\nlet goodReverse = List.rev\nCheck.Quick (``reverse then reverse should be same as original`` goodReverse)\n// Ok, passed 100 tests. \n```", "```\nlet badReverse aList = aList \nCheck.Quick (``reverse then reverse should be same as original`` badReverse)\n// Ok, passed 100 tests. \n```", "```\nlet concatWithComma s t = s + \",\" + t\n\nlet tokens = originalString.Split [| ',' |] \nlet recombinedString = \n    // can use reduce safely because there is always at least one token\n    tokens |> Array.reduce concatWithComma \n\n// compare the result with the original\noriginalString = recombinedString \n```", "```\nlet ``concatting the elements of a string split by commas recreates the original string`` aListOfStrings = \n    // helper to make a string\n    let addWithComma s t = s + \",\" + t\n    let originalString = aListOfStrings |> List.fold addWithComma \"\"\n\n    // now for the property\n    let tokens = originalString.Split [| ',' |] \n    let recombinedString = \n        // can use reduce safely because there is always at least one token\n        tokens |> Array.reduce addWithComma \n\n    // compare the result with the original\n    originalString = recombinedString \n```", "```\nCheck.Quick ``concatting the elements of a string split by commas recreates the original string`` \n// Ok, passed 100 tests. \n```", "```\nlet ``adjacent pairs from a list should be ordered`` sortFn aList = \n    let pairs = aList |> sortFn |> Seq.pairwise\n    pairs |> Seq.forall (fun (x,y) -> x <= y ) \n```", "```\nlet goodSort = List.sort\nCheck.Quick (``adjacent pairs from a list should be ordered`` goodSort) \n```", "```\nSystem.Exception: Geneflect: type not handled System.IComparable\n   at FsCheck.ReflectArbitrary.reflectObj@102-4.Invoke(String message)\n   at Microsoft.FSharp.Core.PrintfImpl.go@523-3[b,c,d](String fmt, Int32 len, FSharpFunc`2 outputChar, FSharpFunc`2 outa, b os, FSharpFunc`2 finalize, FSharpList`1 args, Int32 i)\n   at Microsoft.FSharp.Core.PrintfImpl.run@521[b,c,d](FSharpFunc`2 initialize, String fmt, Int32 len, FSharpList`1 args) \n```", "```\nlet ``adjacent pairs from a list should be ordered`` sortFn (aList:int list) = \n    let pairs = aList |> sortFn |> Seq.pairwise\n    pairs |> Seq.forall (fun (x,y) -> x <= y ) \n```", "```\nlet goodSort = List.sort\nCheck.Quick (``adjacent pairs from a list should be ordered`` goodSort)\n// Ok, passed 100 tests. \n```", "```\nlet ``adjacent pairs from a string list should be ordered`` sortFn (aList:string list) = \n    let pairs = aList |> sortFn |> Seq.pairwise\n    pairs |> Seq.forall (fun (x,y) -> x <= y )\n\nCheck.Quick (``adjacent pairs from a string list should be ordered`` goodSort)\n// Ok, passed 100 tests. \n```", "```\n// bad implementation passes\nlet badSort aList = []\nCheck.Quick (``adjacent pairs from a list should be ordered`` badSort)\n// Ok, passed 100 tests. \n```", "```\nlet ``sort should have same length as original`` sortFn (aList:int list) = \n    let sorted = aList |> sortFn \n    List.length sorted = List.length aList \n```", "```\nlet goodSort = List.sort\nCheck.Quick (``sort should have same length as original`` goodSort )\n// Ok, passed 100 tests. \n```", "```\nlet badSort aList = []\nCheck.Quick (``sort should have same length as original`` badSort )\n// Falsifiable, after 1 test (1 shrink) \n// [0] \n```", "```\n// bad implementation has same length\nlet badSort2 aList = \n    match aList with \n    | [] -> []\n    | head::_ -> List.replicate (List.length aList) head \n\n// for example \n// badSort2 [1;2;3]  => [1;1;1] \n```", "```\nCheck.Quick (``sort should have same length as original`` badSort2)\n// Ok, passed 100 tests. \n```", "```\nCheck.Quick (``adjacent pairs from a list should be ordered`` badSort2)\n// Ok, passed 100 tests. \n```", "```\nlet ``a sorted list is always a permutation of the original list`` sortFn (aList:int list) = \n    let sorted = aList |> sortFn \n    let permutationsOfOriginalList = permutations aList \n\n    // the sorted list must be in the seq of permutations\n    permutationsOfOriginalList \n    |> Seq.exists (fun permutation -> permutation = sorted) \n```", "```\n/// given aList and anElement to insert,\n/// generate all possible lists with anElement \n/// inserted into aList \nlet rec insertElement anElement aList =\n    // From http://stackoverflow.com/a/4610704/1136133\n    seq { \n        match aList with\n        // empty returns a singleton\n        | [] -> yield [anElement] \n        // not empty? \n        | first::rest ->\n            // return anElement prepended to the list\n            yield anElement::aList\n            // also return first prepended to all the sublists\n            for sublist in insertElement anElement rest do\n                yield first::sublist\n        }\n\n/// Given a list, return all permutations of it\nlet rec permutations aList =\n    seq { \n        match aList with\n        | [] -> yield []\n        | first::rest ->\n            // for each sub-permutation, \n            // return the first inserted into it somewhere\n            for sublist in permutations rest do\n                yield! insertElement first sublist\n        } \n```", "```\npermutations ['a';'b';'c'] |> Seq.toList\n//  [['a'; 'b'; 'c']; ['b'; 'a'; 'c']; ['b'; 'c'; 'a']; ['a'; 'c'; 'b'];\n//  ['c'; 'a'; 'b']; ['c'; 'b'; 'a']]\n\npermutations ['a';'b';'c';'d'] |> Seq.toList\n//  [['a'; 'b'; 'c'; 'd']; ['b'; 'a'; 'c'; 'd']; ['b'; 'c'; 'a'; 'd'];\n//   ['b'; 'c'; 'd'; 'a']; ['a'; 'c'; 'b'; 'd']; ['c'; 'a'; 'b'; 'd'];\n//   ['c'; 'b'; 'a'; 'd']; ['c'; 'b'; 'd'; 'a']; ['a'; 'c'; 'd'; 'b'];\n//   ['c'; 'a'; 'd'; 'b']; ['c'; 'd'; 'a'; 'b']; ['c'; 'd'; 'b'; 'a'];\n//   ['a'; 'b'; 'd'; 'c']; ['b'; 'a'; 'd'; 'c']; ['b'; 'd'; 'a'; 'c'];\n//   ['b'; 'd'; 'c'; 'a']; ['a'; 'd'; 'b'; 'c']; ['d'; 'a'; 'b'; 'c'];\n//   ['d'; 'b'; 'a'; 'c']; ['d'; 'b'; 'c'; 'a']; ['a'; 'd'; 'c'; 'b'];\n//   ['d'; 'a'; 'c'; 'b']; ['d'; 'c'; 'a'; 'b']; ['d'; 'c'; 'b'; 'a']]\n\npermutations [3;3] |> Seq.toList\n//  [[3; 3]; [3; 3]] \n```", "```\nCheck.Quick (``a sorted list is always a permutation of the original list`` goodSort) \n```", "```\nlet ``a sorted list has same contents as the original list`` sortFn (aList:int list) = \n    let sorted = aList |> sortFn \n    isPermutationOf aList sorted \n```", "```\n/// Given an element and a list, and other elements previously skipped,\n/// return a new list without the specified element.\n/// If not found, return None\nlet rec withoutElementRec anElement aList skipped = \n    match aList with\n    | [] -> None\n    | head::tail when anElement = head -> \n        // matched, so create a new list from the skipped and the remaining\n        // and return it\n        let skipped' = List.rev skipped\n        Some (skipped' @ tail)\n    | head::tail  -> \n        // no match, so prepend head to the skipped and recurse \n        let skipped' = head :: skipped\n        withoutElementRec anElement tail skipped' \n\n/// Given an element and a list\n/// return a new list without the specified element.\n/// If not found, return None\nlet withoutElement x aList = \n    withoutElementRec x aList [] \n\n/// Given two lists, return true if they have the same contents\n/// regardless of order\nlet rec isPermutationOf list1 list2 = \n    match list1 with\n    | [] -> List.isEmpty list2 // if both empty, true\n    | h1::t1 -> \n        match withoutElement h1 list2 with\n        | None -> false\n        | Some t2 -> \n            isPermutationOf t1 t2 \n```", "```\nCheck.Quick (``a sorted list has same contents as the original list``  goodSort)\n// Ok, passed 100 tests. \n```", "```\nCheck.Quick (``a sorted list has same contents as the original list``  badSort2)\n// Falsifiable, after 2 tests (5 shrinks) \n// [1; 0] \n```", "```\nlet ``list is sorted``sortFn (aList:int list) = \n    let prop1 = ``adjacent pairs from a list should be ordered`` sortFn aList \n    let prop2 = ``a sorted list has same contents as the original list`` sortFn aList \n    prop1 .&. prop2 \n```", "```\nlet goodSort = List.sort\nCheck.Quick (``list is sorted`` goodSort )\n// Ok, passed 100 tests. \n```", "```\nlet badSort aList = []\nCheck.Quick (``list is sorted`` badSort )\n// Falsifiable, after 1 test (0 shrinks) \n// [0] \n```", "```\nlet ``list is sorted (labelled)``sortFn (aList:int list) = \n    let prop1 = ``adjacent pairs from a list should be ordered`` sortFn aList \n                |@ \"adjacent pairs from a list should be ordered\"\n    let prop2 = ``a sorted list has same contents as the original list`` sortFn aList \n                |@ \"a sorted list has same contents as the original list\"\n    prop1 .&. prop2 \n```", "```\nCheck.Quick (``list is sorted (labelled)`` badSort )\n//  Falsifiable, after 1 test (2 shrinks)\n//  Label of failing property: a sorted list has same contents as the original list\n//  [0] \n```", "```\nA list is sorted if:\n* The first element is smaller (or equal to) the second.\n* The rest of the elements after the first element are also sorted. \n```", "```\nlet rec ``First element is <= than second, and tail is also sorted`` sortFn (aList:int list) = \n    let sortedList = aList |> sortFn \n    match sortedList with\n    | [] -> true\n    | [first] -> true\n    | [first;second] -> \n        first <= second\n    | first::second::tail -> \n        first <= second &&\n        let subList = second::tail \n        ``First element is <= than second, and tail is also sorted`` sortFn subList \n```", "```\nlet goodSort = List.sort\nCheck.Quick (``First element is <= than second, and tail is also sorted`` goodSort )\n// Ok, passed 100 tests. \n```", "```\nlet badSort aList = []\nCheck.Quick (``First element is <= than second, and tail is also sorted`` badSort )\n// Ok, passed 100 tests.\n\nlet badSort2 aList = \n    match aList with \n    | [] -> []\n    | head::_ -> List.replicate (List.length aList) head \n\nCheck.Quick (``First element is <= than second, and tail is also sorted`` badSort2)\n// Ok, passed 100 tests. \n```", "```\nlet ``sorting twice gives the same result as sorting once`` sortFn (aList:int list) =\n    let sortedOnce = aList |> sortFn \n    let sortedTwice = aList |> sortFn |> sortFn \n    sortedOnce = sortedTwice\n\n// test\nlet goodSort = List.sort\nCheck.Quick (``sorting twice gives the same result as sorting once`` goodSort )\n// Ok, passed 100 tests. \n```", "```\ntype NonIdempotentService() =\n    let mutable data = 0\n    member this.Get() = \n        data\n    member this.Set value = \n        data <- value\n\nlet ``querying NonIdempotentService after update gives the same result`` value1 value2 =\n    let service = NonIdempotentService()\n    service.Set value1\n\n    // first GET \n    let get1 = service.Get()\n\n    // another task updates the data store\n    service.Set value2\n\n    // second GET called just like first time\n    let get2 = service.Get() \n    get1 = get2 \n```", "```\nCheck.Quick ``querying NonIdempotentService after update gives the same result``\n// Falsifiable, after 2 tests \n```", "```\ntype IdempotentService() =\n    let mutable data = Map.empty\n    member this.GetAsOf (dt:DateTime) = \n        data |> Map.find dt\n    member this.SetAsOf (dt:DateTime) value = \n        data <- data |> Map.add dt value\n\nlet ``querying IdempotentService after update gives the same result`` value1 value2 =\n    let service = IdempotentService()\n    let dt1 = DateTime.Now.AddMinutes(-1.0)\n    service.SetAsOf dt1 value1\n\n    // first GET \n    let get1 = service.GetAsOf dt1 \n\n    // another task updates the data store\n    let dt2 = DateTime.Now\n    service.SetAsOf dt2 value2\n\n    // second GET called just like first time\n    let get2 = service.GetAsOf dt1 \n    get1 = get2 \n```", "```\nCheck.Quick ``querying IdempotentService after update gives the same result``\n// Ok, passed 100 tests. \n```", "```\nmodule InsertionSort = \n\n    // Insert a new element into a list by looping over the list.\n    // As soon as you find a larger element, insert in front of it\n    let rec insert newElem list = \n        match list with \n        | head::tail when newElem > head -> \n            head :: insert newElem tail\n        | other -> // including empty list\n            newElem :: other \n\n    // Sorts a list by inserting the head into the rest of the list \n    // after the rest have been sorted\n    let rec sort list = \n        match list with\n        | []   -> []\n        | head::tail -> \n            insert head (sort tail)\n\n    // test\n    // insertionSort  [5;3;2;1;1] \n```", "```\nlet ``sort should give same result as insertion sort`` sortFn (aList:int list) = \n    let sorted1 = aList |> sortFn \n    let sorted2 = aList |> InsertionSort.sort\n    sorted1 = sorted2 \n```", "```\nlet goodSort = List.sort\nCheck.Quick (``sort should give same result as insertion sort`` goodSort)\n// Ok, passed 100 tests. \n```", "```\nlet badSort aList = aList \nCheck.Quick (``sort should give same result as insertion sort`` badSort)\n// Falsifiable, after 4 tests (6 shrinks) \n// [1; 0] \n```", "```\nlet arabicToRomanUsingTallying arabic = \n   (String.replicate arabic \"I\")\n    .Replace(\"IIIII\",\"V\")\n    .Replace(\"VV\",\"X\")\n    .Replace(\"XXXXX\",\"L\")\n    .Replace(\"LL\",\"C\")\n    .Replace(\"CCCCC\",\"D\")\n    .Replace(\"DD\",\"M\")\n    // optional substitutions\n    .Replace(\"IIII\",\"IV\")\n    .Replace(\"VIV\",\"IX\")\n    .Replace(\"XXXX\",\"XL\")\n    .Replace(\"LXL\",\"XC\")\n    .Replace(\"CCCC\",\"CD\")\n    .Replace(\"DCD\",\"CM\") \n```", "```\nlet biQuinaryDigits place (unit,five,ten) arabic =\n  let digit =  arabic % (10*place) / place\n  match digit with\n  | 0 -> \"\"\n  | 1 -> unit\n  | 2 -> unit + unit\n  | 3 -> unit + unit + unit\n  | 4 -> unit + five // changed to be one less than five \n  | 5 -> five\n  | 6 -> five + unit\n  | 7 -> five + unit + unit\n  | 8 -> five + unit + unit + unit\n  | 9 -> unit + ten  // changed to be one less than ten\n  | _ -> failwith \"Expected 0-9 only\"\n\nlet arabicToRomanUsingBiQuinary arabic = \n  let units = biQuinaryDigits 1 (\"I\",\"V\",\"X\") arabic\n  let tens = biQuinaryDigits 10 (\"X\",\"L\",\"C\") arabic\n  let hundreds = biQuinaryDigits 100 (\"C\",\"D\",\"M\") arabic\n  let thousands = biQuinaryDigits 1000 (\"M\",\"?\",\"?\") arabic\n  thousands + hundreds + tens + units \n```", "```\nlet ``biquinary should give same result as tallying`` arabic = \n    let tallyResult = arabicToRomanUsingTallying arabic \n    let biquinaryResult = arabicToRomanUsingBiQuinary arabic \n    tallyResult = biquinaryResult \n```", "```\nCheck.Quick ``biquinary should give same result as tallying``\n// ArgumentException: The input must be non-negative. \n```", "```\nlet arabicNumber = Arb.Default.Int32() |> Arb.filter (fun i -> i > 0 && i <= 4000) \n```", "```\nlet ``for all values of arabicNumber biquinary should give same result as tallying`` = \n    Prop.forAll arabicNumber ``biquinary should give same result as tallying`` \n```", "```\nCheck.Quick ``for all values of arabicNumber biquinary should give same result as tallying``\n// Ok, passed 100 tests. \n```", "```\n// OO style class with members\ntype Dollar(amount:int) =\n    member val Amount  = amount with get, set\n    member this.Add add = \n        this.Amount <- this.Amount + add\n    member this.Times multiplier  = \n        this.Amount <- this.Amount * multiplier  \n    static member Create amount  = \n        Dollar amount \n```", "```\nlet d = Dollar.Create 2\nd.Amount  // 2\nd.Times 3 \nd.Amount  // 6\nd.Add 1\nd.Amount  // 7 \n```", "```\nlet ``set then get should give same result`` value = \n    let obj = Dollar.Create 0\n    obj.Amount <- value\n    let newValue = obj.Amount\n    value = newValue \n\nCheck.Quick ``set then get should give same result`` \n// Ok, passed 100 tests. \n```", "```\nlet ``set amount is idempotent`` value = \n    let obj = Dollar.Create 0\n    obj.Amount <- value\n    let afterFirstSet = obj.Amount\n    obj.Amount <- value\n    let afterSecondSet = obj.Amount\n    afterFirstSet = afterSecondSet \n\nCheck.Quick ``set amount is idempotent`` \n// Ok, passed 100 tests. \n```", "```\ntype Dollar(amount:int) =\n    member val Amount  = amount \n    member this.Add add = \n        Dollar (amount + add)\n    member this.Times multiplier  = \n        Dollar (amount * multiplier)\n    static member Create amount  = \n        Dollar amount  \n\n// interactive test\nlet d1 = Dollar.Create 2\nd1.Amount  // 2\nlet d2 = d1.Times 3 \nd2.Amount  // 6\nlet d3 = d2.Add 1\nd3.Amount  // 7 \n```", "```\nlet ``create then times should be same as times then create`` start multiplier = \n    let d0 = Dollar.Create start\n    let d1 = d0.Times(multiplier)\n    let d2 = Dollar.Create (start * multiplier)     \n    d1 = d2 \n```", "```\nCheck.Quick ``create then times should be same as times then create``\n// Falsifiable, after 1 test \n```", "```\nlet ``dollars with same amount must be equal`` amount = \n    let d1 = Dollar.Create amount \n    let d2 = Dollar.Create amount \n    d1 = d2\n\nCheck.Quick ``dollars with same amount must be equal`` \n// Falsifiable, after 1 test \n```", "```\ntype Dollar = {amount:int } \n    with \n    member this.Add add = \n        {amount = this.amount + add }\n    member this.Times multiplier  = \n        {amount = this.amount * multiplier }\n    static member Create amount  = \n        {amount=amount} \n```", "```\nCheck.Quick ``dollars with same amount must be equal`` \n// Ok, passed 100 tests.\n\nCheck.Quick ``create then times should be same as times then create``\n// Ok, passed 100 tests. \n```", "```\nlet ``create then times then get should be same as times`` start multiplier = \n    let d0 = Dollar.Create start\n    let d1 = d0.Times(multiplier)\n    let a1 = d1.amount\n    let a2 = start * multiplier     \n    a1 = a2\n\nCheck.Quick ``create then times then get should be same as times``\n// Ok, passed 100 tests. \n```", "```\nlet ``create then times then add should be same as times then add then create`` start multiplier adder = \n    let d0 = Dollar.Create start\n    let d1 = d0.Times(multiplier)\n    let d2 = d1.Add(adder)\n    let directAmount = (start * multiplier) + adder\n    let d3 = Dollar.Create directAmount \n    d2 = d3\n\nCheck.Quick ``create then times then add should be same as times then add then create`` \n// Ok, passed 100 tests. \n```", "```\ntype Dollar = {amount:int } \n    with \n    member this.Map f = \n        {amount = f this.amount}\n    member this.Times multiplier = \n        this.Map (fun a -> a * multiplier)\n    member this.Add adder = \n        this.Map (fun a -> a + adder)\n    static member Create amount  = \n        {amount=amount} \n```", "```\nlet ``create then map should be same as map then create`` start f = \n    let d0 = Dollar.Create start\n    let d1 = d0.Map f  \n    let d2 = Dollar.Create (f start)     \n    d1 = d2 \n```", "```\nCheck.Quick ``create then map should be same as map then create`` \n// Ok, passed 100 tests. \n```", "```\nCheck.Verbose ``create then map should be same as map then create`` \n```", "```\n0:\n18\n<fun:Invoke@3000>\n1:\n7\n<fun:Invoke@3000>\n-- etc\n98:\n47\n<fun:Invoke@3000>\n99:\n36\n<fun:Invoke@3000>\nOk, passed 100 tests. \n```", "```\nlet ``create then map should be same as map then create2`` start (F (_,f)) = \n    let d0 = Dollar.Create start\n    let d1 = d0.Map f  \n    let d2 = Dollar.Create (f start)     \n    d1 = d2 \n```", "```\nCheck.Verbose ``create then map should be same as map then create2`` \n```", "```\n0:\n0\n{ 0->1 }\n1:\n0\n{ 0->0 }\n2:\n2\n{ 2->-2 }\n-- etc\n98:\n-5\n{ -5->-52 }\n99:\n10\n{ 10->28 }\nOk, passed 100 tests. \n```"]