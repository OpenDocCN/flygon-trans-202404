["```\nprint 'text' \n```", "```\nprint ('text') \n```", "```\nprint(2+2+2+2) \n```", "```\npython >> \n```", "```\ntscript -> \n```", "```\necho Hello! \n```", "```\nthis will not error \n```", "```\nFile \"/project1/chopexec1\", line 11\n    Print(this will error)\n                 ^\nSyntaxError: Invalid syntax \n```", "```\nFile \"/project1/chopexec1\", line 11 \n```", "```\nPrint(this will error) \n```", "```\nSyntaxError: Invalid syntax \n```", "```\nimport this \n```", "```\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those! \n```", "```\n'Explicit is better than implicit' \n```", "```\na = 10\nb = op('value')[0]\n\nop('op12').par.rx = b\n\nc = str(op('numbers')[0])\nd = 'testing'\ne = 'something'\n\nop('lines').par.text = d + e + c \n```", "```\n#Set initial variable\n#get the value from slider input\na = 10\nb = op('value')[0]\n\n#assign the slider value to video input rotation\nop('op12').par.rx = b\n\n#take numeric input from computer keypad\nc = str(op('numbers')[0])\nd = 'You'\ne = 'pressed'\n\n#create a sentence from variables above\n#add it to a Text TOP to display\nop('lines').par.text = d + e + c \n```", "```\nWaiting for frame for 90 - E:/test.mov from harddrive \n```", "```\nWarning: The GLSL Shader has compile error \n```", "```\nPixel Shader Compile Results:\n0(3) : error C0000: syntax error, unexpected '=', expecting '::' at token '=' \n```", "```\nvoid main(){\n    gl_Position = TDWorldToProj(TDDeform(P));\n} \n```", "```\nvoid main(){\n\n} \n```", "```\ngl_Position = TDWorldToProj(TDDeform(P)); \n```", "```\nout vec4 fragColor;\nvoid main(){\n    fragColor = vec4(1,1,1,1);\n} \n```", "```\nout vec4 fragColor; \n```", "```\nfragColor = vec4(1,1,1,1); \n```", "```\nvec3 scaledP;\n\nvoid main(){\n    scaledP = P * 0.5;\n    gl_Position = TDWorldToProj(TDDeform(scaledP));\n} \n```", "```\nscaledP = P * 0.5; \n```", "```\ngl_Position = TDWorldToProj(TDDeform(scaledP)); \n```", "```\nvec3 transformedP;\n\nvoid main(){\n    transformedP = P + vec3(1,0,0);\n    gl_Position = TDWorldToProj(TDDeform(transformedP));\n} \n```", "```\nvec3 transformedP;\nuniform float lfoCHOP;\n\nvoid main(){\n    transformedP = P + vec3(lfoCHOP,0,0);\n    gl_Position = TDWorldToProj(TDDeform(transformedP));\n} \n```", "```\ntransformedP = P + vec3(lfoCHOP,0,0); \n```", "```\nout vec4 fragColor;\nuniform float lfoCHOP;\n\nvoid main(){\n    fragColor = vec4(lfoCHOP,0,0,1);\n} \n```", "```\nvec3 transformedP;\nuniform float lfoCHOP;\nout vec2 texCoord0;\n\nvoid main(){\n    transformedP = P + vec3(lfoCHOP,0,0);\n    gl_Position = TDWorldToProj(TDDeform(transformedP));\n\n    vec3 texCoord = TDInstanceTexCoord(uv[0]);\n    texCoord0.st = texCoord.st;\n} \n```", "```\nout vec2 texCoord0; \n```", "```\ntexCoord0.st = uv[0].st; \n```", "```\nout vec4 fragColor;\n\nvoid main(){\n    vec4 in1 = texture(sTD2DInputs[0], vUV.st);\n    vec4 in2 = texture(sTD2DInputs[1], vUV.st);\n    fragColor = in1 + in2;\n} \n```", "```\nvec4 in1 = texture(sTD2DInputs[0], vUV.st);\nvec4 in2 = texture(sTD2DInputs[1], vUV.st); \n```", "```\nfragColor = in1 + in2; \n```", "```\nout vec4 fragColor;\n\nvoid main(){\n    vec4 in1 = texture(sTD2DInputs[0], vUV.st * 0.5);\n    vec4 in2 = texture(sTD2DInputs[1], vUV.st);\n    vec4 in3 = texture(sTD2DInputs[2], vUV.st - vec2(0.5,0.25));\n    vec4 in4 = texture(sTD2DInputs[3], vUV.st);\n    vec4 in5 = texture(sTD2DInputs[4], vUV.st + vec2(0.5,0.));\n\n    fragColor = in1 + in2 * in3 - in4 * in5;\n} \n```", "```\nout vec4 fragColor[5];\n\nvoid main(){\n    vec4 in1 = texture(sTD2DInputs[0], vUV.st * 0.5);\n    vec4 in2 = texture(sTD2DInputs[1], vUV.st);\n    vec4 in3 = texture(sTD2DInputs[2], vUV.st - vec2(0.5,0.25));\n    vec4 in4 = texture(sTD2DInputs[3], vUV.st);\n    vec4 in5 = texture(sTD2DInputs[4], vUV.st + vec2(0.5,0.));\n\n    fragColor[0] = in1;\n    fragColor[1] = in2;\n    fragColor[2] = in3;\n    fragColor[3] = in4;\n    fragColor[4] = in5;\n\n} \n```", "```\nfragColor[0] = in1; \n```", "```\nz = op('null2')['x']\nw = op('null2')['y']\nop('constant1').par.value0 = z\nop('constant1').par.value1 = w \n```", "```\nop('constant1').par.value0 = 0\nop('constant1').par.value1 = 0 \n```", "```\nvoid main()\n{\n    float r = pow(iMouse.x-gl_FragCoord.x,2.0) + pow(iMouse.y-gl_FragCoord.y,2.0);\n    float max_r = pow(25.0,2.0);\n    vec4 c = vec4(0,0,0,1);\n    if(r <= max_r){\n        c = vec4(1,0,0,1);\n    }\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;    \n    if(iFrame < 5){\n        fragColor = texture2D( iChannel1, uv);\n    }else{\n        fragColor = c+rule(gl_FragCoord.xy);\n    }\n} \n```", "```\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    fragColor = neiborhood(gl_FragCoord.xy)*vec4(uv,0.5+0.5*sin(iGlobalTime),1.0)*4.;\n} \n```", "```\nme.inputPoint.index \n```", "```\nabsTime.frame/100 \n```", "```\nout vec4 fragColor;\n\nvoid main()\n{\n// sample the input\nvec4 inPosition = texture(sTD2DInputs[0], vUV.st);\n\n// scale each color channel (the XYZ of the vector) separately\nvec4 outPosition = vec4(inPosition.x * 5.0 - 2.5, inPosition.y * 5.0 - 2.5, inPosition.z * -5.0 - 20.0, 1.0);\n\n// output the new position\nfragColor = outPosition;\n} \n```", "```\nlayout(location = 0) out vec4 fragColor;\n\nvoid main()\n{\n// shade pixel white\nfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n} \n```", "```\n// setup inputs\nuniform sampler2D sPointPosition;\nuniform float uPointsPerInstance;\nin float pointIndex;\n\nvoid main()\n{\n    // create the uv from point index\n    vec2 uv;\n    uv.x = (pointIndex * uPointsPerInstance) + (uPointsPerInstance * 0.5);\n    uv.y = 0.5;\n\n    // sample the noise texture using the uv\n    vec4 newPosition = texture(sPointPosition, uv);\n\n    // set point size to your liking\n    gl_PointSize = 1.0;\n\n    // move point from object space to screen space and output to gl_Position\n    vec4 worldSpaceVert = TDDeform(newPosition);\n    vec4 camSpaceVert = uTDMat.cam * worldSpaceVert;\n    gl_Position = TDCamToProj(camSpaceVert);\n} \n```", "```\n// setup inputs\nuniform sampler2D sPointPosition;\nuniform float uPointsPerInstance;\nin float pointIndex; \n```", "```\n// create the uv from point index\nvec2 uv;\nuv.x = (pointIndex * uPointsPerInstance) + (uPointsPerInstance * 0.5);\nuv.y = 0.5; \n```", "```\n// sample the noise texture using the uv\nvec4 newPosition = texture(sPointPosition, uv); \n```", "```\n// set point size to your liking\ngl_PointSize = 1.0; \n```", "```\n// move point from object space to screen space and output to gl_Position\nvec4 worldSpaceVert = TDDeform(newPosition);\nvec4 camSpaceVert = uTDMat.cam * worldSpaceVert;\ngl_Position = TDCamToProj(camSpaceVert); \n```", "```\nout vec4 fragColor;\n\nvoid main()\n{\n// sample the input\nvec4 inPosition = texture(sTD2DInputs[0], vUV.st);\n\n// scale each color channel (the XYZ of the vector) separately\nvec4 outPosition = vec4(inPosition.x * 5.0 - 2.5, inPosition.y * 5.0 - 2.5, inPosition.z * -5.0 - 20.0, 1.0);\n\n// output the new position\nfragColor = outPosition;\n} \n```", "```\nvec4 gridPosition = texture(sTD2DInputs[1], vUV.st); \n```", "```\nfragColor = gridPosition; \n```", "```\nfragColor = outPosition; \n```", "```\nvec4 outPosition = vec4(inPosition.x * 5.0 - 2.5, inPosition.y * 5.0 - 2.5, inPosition.z * -5.0 - 20.0, 1.0); \n```", "```\nvec4 outPosition = vec4(gridPosition.x + (inPosition.x * 0.1), gridPosition.y + (inPosition.y * 0.1), gridPosition.z + inPosition.z, 1.0); \n```", "```\nout vec4 fragColor;\n\nvoid main()\n{\n// sample the inputs\nvec4 inPosition = texture(sTD2DInputs[0], vUV.st);\nvec4 gridPosition = texture(sTD2DInputs[1], vUV.st);\n\n// add scaled noise texture values to the grid position values\nvec4 outPosition = vec4(gridPosition.x + (inPosition.x * 0.1), gridPosition.y + (inPosition.y * 0.1), gridPosition.z + inPosition.z, 1.0);\n\n// output the new position\nfragColor = outPosition;\n} \n```", "```\nuniform vec3 uVel; \n```", "```\nvec4 pos = texture(sTD2DInputs[0], vUV.st); \n```", "```\npos.xyz += uVel.xyz; \n```", "```\noPosition = pos; \n```", "```\nuniform vec3 uVel;\n\nout vec4 oPosition;\n\nvoid main()\n{\n    // get input positions\n    vec4 pos = texture(sTD2DInputs[0], vUV.st);\n\n    // add our single velocity values to every point position\n    pos.xyz += uVel.xyz;\n\n    // output the new point position\n    oPosition = pos;\n\n} \n```", "```\nop('feedback1').par.resetpulse.pulse() \n```", "```\nvec4 velocity = texture(sTD2DInputs[1], vUV.st) * 2 - 1; \n```", "```\npos.xyz += velocity.xyz; \n```"]