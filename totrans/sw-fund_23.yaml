- en: TypesType Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors multi.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the syntax, informally:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive tm : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ttrue : tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tfalse : tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tif : tm → tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tzero : tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tsucc : tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tpred : tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tiszero : tm → tm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive bvalue : tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| bv_true : bvalue ttrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| bv_false : bvalue tfalse.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive nvalue : tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| nv_zero : nvalue tzero'
  prefs: []
  type: TYPE_NORMAL
- en: '| nv_succ : ∀t, nvalue t → nvalue (tsucc t).'
  prefs: []
  type: TYPE_NORMAL
- en: Definition value (t:tm) := bvalue t ∨ nvalue t.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors bvalue nvalue.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Unfold value.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Unfold update.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "t1 '⇒' t2" (at level 40).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step : tm → tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IfTrue : ∀t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: (tif ttrue t[1] t[2]) ⇒ t[1]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IfFalse : ∀t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: (tif tfalse t[1] t[2]) ⇒ t[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_If : ∀t[1] t[1]'' t[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: (tif t[1] t[2] t[3]) ⇒ (tif t[1]' t[2] t[3])
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Succ : ∀t[1] t[1]'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: (tsucc t[1]) ⇒ (tsucc t[1]')
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_PredZero :'
  prefs: []
  type: TYPE_NORMAL
- en: (tpred tzero) ⇒ tzero
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_PredSucc : ∀t[1],'
  prefs: []
  type: TYPE_NORMAL
- en: nvalue t[1] →
  prefs: []
  type: TYPE_NORMAL
- en: (tpred (tsucc t[1])) ⇒ t[1]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Pred : ∀t[1] t[1]'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: (tpred t[1]) ⇒ (tpred t[1]')
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IszeroZero :'
  prefs: []
  type: TYPE_NORMAL
- en: (tiszero tzero) ⇒ ttrue
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IszeroSucc : ∀t[1],'
  prefs: []
  type: TYPE_NORMAL
- en: nvalue t[1] →
  prefs: []
  type: TYPE_NORMAL
- en: (tiszero (tsucc t[1])) ⇒ tfalse
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Iszero : ∀t[1] t[1]'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: (tiszero t[1]) ⇒ (tiszero t[1]')
  prefs: []
  type: TYPE_NORMAL
- en: where "t1 '⇒' t2" := (step t[1] t[2]).
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: succ (if true then true else true)
  prefs: []
  type: TYPE_NORMAL
- en: can take a step (once, before becoming stuck).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notation step_normal_form := (normal_form step).
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition stuck (t:tm) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: step_normal_form t ∧ ¬ value t.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Unfold stuck.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Example some_term_is_stuck :'
  prefs: []
  type: TYPE_NORMAL
- en: ∃t, stuck t.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma value_is_nf : ∀t,'
  prefs: []
  type: TYPE_NORMAL
- en: value t → step_normal_form t.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem step_deterministic:'
  prefs: []
  type: TYPE_NORMAL
- en: deterministic step.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next critical observation is that, although this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language has stuck terms, they are always nonsensical, mixing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: booleans and numbers in a way that we don't even *want* to have a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: meaning.  We can easily exclude such ill-typed terms by defining a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*typing relation* that relates terms to the types (either numeric'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or boolean) of their final results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In informal notation, the typing relation is often written
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ t ∈ T and pronounced "t has type T."  The ⊢ symbol
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is called a "turnstile."  Below, we're going to see richer typing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relations where one or more additional "context" arguments are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: written to the left of the turnstile.  For the moment, the context
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is always empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_True)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ true ∈ Bool
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_False)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ false ∈ Bool
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ t[1] ∈ Bool    ⊢ t[2] ∈ T    ⊢ t[3] ∈ T
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_If)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ if t[1] then t[2] else t[3] ∈ T
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_Zero)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ 0 ∈ Nat
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ t[1] ∈ Nat
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_Succ)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ succ t[1] ∈ Nat
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ t[1] ∈ Nat
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_Pred)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ pred t[1] ∈ Nat
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ t[1] ∈ Nat
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_IsZero)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ⊢ iszero t[1] ∈ Bool
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: (Since we've included all the constructors of the typing relation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the hint database, the auto tactic can actually find this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof automatically.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's important to realize that the typing relation is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*conservative* (or *static*) approximation: it does not consider'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: what happens when the term is reduced — in particular, it does
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not calculate the type of its normal form.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optional (succ_hastype_nat__hastype_nat)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma bool_canonical : ∀t,'
  prefs: []
  type: TYPE_NORMAL
- en: ⊢ t ∈ TBool → value t → bvalue t.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t HT HV.
  prefs: []
  type: TYPE_NORMAL
- en: inversion HV; auto.
  prefs: []
  type: TYPE_NORMAL
- en: induction H; inversion HT; auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma nat_canonical : ∀t,'
  prefs: []
  type: TYPE_NORMAL
- en: ⊢ t ∈ TNat → value t → nvalue t.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t HT HV.
  prefs: []
  type: TYPE_NORMAL
- en: inversion HV.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; inversion HT.
  prefs: []
  type: TYPE_NORMAL
- en: auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem progress : ∀t T,'
  prefs: []
  type: TYPE_NORMAL
- en: ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: value t ∨ ∃t', t ⇒ t'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Proof with auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t T HT.
  prefs: []
  type: TYPE_NORMAL
- en: induction HT...
  prefs: []
  type: TYPE_NORMAL
- en: (* The cases that were obviously values, like T_True and      T_False, were eliminated immediately by auto *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_If *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion IHHT1; clear IHHT1.
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: apply ([bool_canonical](Types.html#bool_canonical) t[1] HT[1]) in H.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; clear H.
  prefs: []
  type: TYPE_NORMAL
- en: ∃t[2]...
  prefs: []
  type: TYPE_NORMAL
- en: ∃t[3]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] can take a step *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' H[1]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tif](Types.html#tif) t[1]' t[2] t[3])...
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Type Preservation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second critical property of typing is that, when a well-typed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: term takes a step, the result is also a well-typed term.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (finish_preservation)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Complete the formal proof of the preservation property.  (Again,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: make sure you understand the informal proof fragment in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: following exercise first.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advancedM (finish_preservation_informal)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Complete the following informal proof:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Theorem*: If ⊢ t ∈ T and t ⇒ t'', then ⊢ t'' ∈ T.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Proof*: By induction on a derivation of ⊢ t ∈ T.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the last rule in the derivation is T_If, then t = if t[1] then t[2] else
    t[3], with ⊢ t[1] ∈ Bool, ⊢ t[2] ∈ T and ⊢ t[3] ∈ T.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting the rules for the small-step reduction relation and remembering that
    t has the form if ..., we see that the only ones that could have been used to
    prove t ⇒ t' are ST_IfTrue, ST_IfFalse, or ST_If.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the last rule was ST_IfTrue, then t' = t[2]. But we know that ⊢ t[2] ∈ T,
    so we are done.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the last rule was ST_IfFalse, then t' = t[3]. But we know that ⊢ t[3] ∈ T,
    so we are done.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the last rule was ST_If, then t' = if t[1]' then t[2] else t[3], where t[1]
    ⇒ t[1]'. We know ⊢ t[1] ∈ Bool so, by the IH, ⊢ t[1]' ∈ Bool. The T_If rule then
    gives us ⊢ if t[1]' then t[2] else t[3] ∈ T, as required.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (preservation_alternate_proof)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now prove the same property again by induction on the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*evaluation* derivation instead of on the typing derivation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Begin by carefully reading and thinking about the first few
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lines of the above proofs to make sure you understand what
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: each one is doing.  The set-up for this proof is similar, but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not exactly the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preservation theorem is often called *subject reduction*,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: because it tells us what happens when the "subject" of the typing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation is reduced.  This terminology comes from thinking of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typing statements as sentences, where the term is the subject and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the type is the predicate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Definition multistep := (multi step).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "t1 '⇒*' t2" := (multistep t[1] t[2]) (at level 40).
  prefs: []
  type: TYPE_NORMAL
- en: 'Corollary soundness : ∀t t'' T,'
  prefs: []
  type: TYPE_NORMAL
- en: ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: t ⇒* t' →
  prefs: []
  type: TYPE_NORMAL
- en: ~(stuck t').
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t t' T HT P. induction P; intros [R S].
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([progress](Types.html#progress) x T HT); auto.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHP. apply ([preservation](Types.html#preservation) x y T HT H).
  prefs: []
  type: TYPE_NORMAL
- en: unfold [stuck](Types.html#stuck). split; auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Module NormalizePlayground.
  prefs: []
  type: TYPE_NORMAL
- en: Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example step_example1 :'
  prefs: []
  type: TYPE_NORMAL
- en: (P (C 3) (P (C 3) (C 4)))
  prefs: []
  type: TYPE_NORMAL
- en: ⇒* (C 10).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply multi_step with (P (C 3) (C 7)).
  prefs: []
  type: TYPE_NORMAL
- en: apply ST_Plus2.
  prefs: []
  type: TYPE_NORMAL
- en: apply v_const.
  prefs: []
  type: TYPE_NORMAL
- en: apply ST_PlusConstConst.
  prefs: []
  type: TYPE_NORMAL
- en: apply multi_step with (C 10).
  prefs: []
  type: TYPE_NORMAL
- en: apply ST_PlusConstConst.
  prefs: []
  type: TYPE_NORMAL
- en: apply multi_refl.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Hint Constructors step value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example step_example1'' :'
  prefs: []
  type: TYPE_NORMAL
- en: (P (C 3) (P (C 3) (C 4)))
  prefs: []
  type: TYPE_NORMAL
- en: ⇒* (C 10).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: eapply multi_step. auto. simpl.
  prefs: []
  type: TYPE_NORMAL
- en: eapply multi_step. auto. simpl.
  prefs: []
  type: TYPE_NORMAL
- en: apply multi_refl.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tactic Notation "print_goal" :=
  prefs: []
  type: TYPE_NORMAL
- en: match goal with ⊢ ?x ⇒ idtac x end.
  prefs: []
  type: TYPE_NORMAL
- en: Tactic Notation "normalize" :=
  prefs: []
  type: TYPE_NORMAL
- en: repeat (print_goal; eapply multi_step ;
  prefs: []
  type: TYPE_NORMAL
- en: '[ (eauto 10; fail) | (instantiate; simpl)]);'
  prefs: []
  type: TYPE_NORMAL
- en: apply multi_refl.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example step_example1'''' :'
  prefs: []
  type: TYPE_NORMAL
- en: (P (C 3) (P (C 3) (C 4)))
  prefs: []
  type: TYPE_NORMAL
- en: ⇒* (C 10).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: normalize.
  prefs: []
  type: TYPE_NORMAL
- en: (* The print_goal in the normalize tactic shows      a trace of how the expression reduced...
             (P (C 3) (P (C 3) (C 4)) ==>* C 10)          (P (C 3) (C 7) ==>* C 10)
             (C 10 ==>* C 10)                         *)
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Example step_example1'''''' : ∃e'','
  prefs: []
  type: TYPE_NORMAL
- en: (P (C 3) (P (C 3) (C 4)))
  prefs: []
  type: TYPE_NORMAL
- en: ⇒* e'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: eapply ex_intro. normalize.
  prefs: []
  type: TYPE_NORMAL
- en: '(* This time, the trace is:        (P (C 3) (P (C 3) (C 4)) ==>* ?e'')        (P (C 3) (C 7) ==>* ?e'')
           (C 10 ==>* ?e'')    where ?e'' is the variable ``guessed'''' by eapply. *)'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem normalize_ex : ∃e'','
  prefs: []
  type: TYPE_NORMAL
- en: (P (C 3) (P (C 2) (C 1)))
  prefs: []
  type: TYPE_NORMAL
- en: ⇒* e'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem normalize_ex'' : ∃e'','
  prefs: []
  type: TYPE_NORMAL
- en: (P (C 3) (P (C 2) (C 1)))
  prefs: []
  type: TYPE_NORMAL
- en: ⇒* e'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: End NormalizePlayground.
  prefs: []
  type: TYPE_NORMAL
- en: Tactic Notation "print_goal" :=
  prefs: []
  type: TYPE_NORMAL
- en: match goal with ⊢ ?x ⇒ idtac x end.
  prefs: []
  type: TYPE_NORMAL
- en: Tactic Notation "normalize" :=
  prefs: []
  type: TYPE_NORMAL
- en: repeat (print_goal; eapply multi_step ;
  prefs: []
  type: TYPE_NORMAL
- en: '[ (eauto 10; fail) | (instantiate; simpl)]);'
  prefs: []
  type: TYPE_NORMAL
- en: apply multi_refl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '| T_SuccBool : ∀t,'
  prefs: []
  type: TYPE_NORMAL
- en: ⊢ t ∈ TBool →
  prefs: []
  type: TYPE_NORMAL
- en: ⊢ tsucc t ∈ TBool
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following properties remain true in the presence of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this rule?  For each one, write either "remains true" or
  prefs: []
  type: TYPE_NORMAL
- en: else "becomes false." If a property becomes false, give a
  prefs: []
  type: TYPE_NORMAL
- en: counterexample.
  prefs: []
  type: TYPE_NORMAL
- en: Determinism of step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preservation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 starsM (variation2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose, instead, that we add this new rule to the step relation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| ST_Funny2 : ∀t[1] t[2] t[2]'' t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: t[2] ⇒ t[2]' →
  prefs: []
  type: TYPE_NORMAL
- en: (tif t[1] t[2] t[3]) ⇒ (tif t[1] t[2]' t[3])
  prefs: []
  type: TYPE_NORMAL
- en: Which of the above properties become false in the presence of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this rule?  For each one that does, give a counter-example.
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (variation4)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose instead that we add this rule:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '| T_Funny4 :'
  prefs: []
  type: TYPE_NORMAL
- en: ⊢ tzero ∈ TBool
  prefs: []
  type: TYPE_NORMAL
- en: Which of the above properties become false in the presence of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this rule?  For each one that does, give a counter-example.
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (variation6)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose instead that we add this rule:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
