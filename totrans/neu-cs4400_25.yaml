- en: Implementing First Class Functions (contd.)Tuesday, January 31st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quick Example: the following is working JavaScript code, that uses first class
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the above definition of `foo` does *not* use an anonymous “lambda
    expression” — in Racket terms, it’s translated to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned function is not anonymous, but it’s not really named either: the
    `bar` name is bound only inside the body of `foo`, and outside of it that name
    no longer exists since it’s not its scope. It gets used in the printed form if
    the function value is displayed, but this is merely a debugging aid. The anonymous
    `lambda` version that is common in Racket can be used in JavaScript too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Side-note: GCC includes extensions that allow internal function definitions,
    but it still does not have first class functions — trying to do the above is broken:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
