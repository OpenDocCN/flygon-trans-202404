- en: List Operators and HOFs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Racket provides useful primitive procedures for lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list-ref`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`list-ref` takes as arguments a list and a number `n` and returns the `n`th
    item of the list. The first element of the list is indexed as `0`, meaning it
    is the `0`th element of the list. Here''s how `list-ref` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and here is an example of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`null?`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`null?` takes a list as an argument and returns `#t` if the list is empty.
    Otherwise, it returns `#f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`length`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`length` takes a list as an argument and returns the number of items in a list.
    Here''s how `length` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'and here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Higher Order Functions with Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From here on out, we’ll be mostly using lists and pairs rather than sentences.
    This is great, since it means we'll be able to take a closer look at how data
    is represented by Racket. But, this also means that a lot of the important higher
    order functions we previously defined with sentences must now be rewritten to
    work with pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '`every` vs. `map`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall the HOF `every`, which takes in a function and a sentence, and returns
    a sentence with the function applied to every element of the sentence. The equivalent
    of this HOF using pairs is called `map`, which it takes in a function and a *list*,
    and returns a list with the function *mapped* to every element in the list. `map`
    is a recursively defined function, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The procedure `null?` for lists is analogous to the procedure `empty?` for
    sentences, and checks whether or not the given argument is the empty list. Here
    are a few example calls to `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`keep` vs. `filter`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already had a quick glimpse of `filter` in the `filtered-accumulate` problem
    in Homework 2, so you should already have some idea of what the HOF `filter` should
    do. `filter` takes in two arguments, a predicate and a list, and returns a list
    with only elements that satisfy the predicate. Take a look at the formal definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`accumulate`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, there is the procedure `accumulate` for sentences. This procedure
    takes in a function of two arguments, a base case value, and a sentence of values,
    and continuously combines the values in the list using this operation and ending/starting
    with the base case value. There are two equivalents to accumulate for lists: `foldl`
    and `foldr`. Both take in a function of two values, a base case value, and a list.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fold-left` starts from the last (right-most) element in the list and continuously
    applies the function recursively until it reaches the first element of the list.
    Thus, it *folds* to the left. For example, here are the steps to evaluate a call
    to `foldl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, `fold-right` starts from the first (left-most) element in
    the list and continuously applies the function recursively until it reaches the
    last element of the list. Thus, it *folds* to the right. Take these calls for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now have two versions of `accumulate`, where the values of `foldl` and `foldr`
    would only differ when they are called with combiner functions in which order
    matters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of HOFs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the transition easier, here’s a table illustrating some operations on
    sentences and their equivalent for lists.
  prefs: []
  type: TYPE_NORMAL
- en: '| SENTENCE | LIST |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `se/sentence` | `cons/list/append` |'
  prefs: []
  type: TYPE_TB
- en: '| `first` | `car` |'
  prefs: []
  type: TYPE_TB
- en: '| `bf/butfirst` | `cdr` |'
  prefs: []
  type: TYPE_TB
- en: '| `last` | NO EQUIVALENT |'
  prefs: []
  type: TYPE_TB
- en: '| `bl/butlast` | NO EQUIVALENT |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | `length` |'
  prefs: []
  type: TYPE_TB
- en: '| `item` (one-indexed) | `list-ref` (zero-indexed) |'
  prefs: []
  type: TYPE_TB
- en: '| `every` | `map` |'
  prefs: []
  type: TYPE_TB
- en: '| `keep` | `filter` |'
  prefs: []
  type: TYPE_TB
- en: '| `accumulate` | `foldl/foldr` |'
  prefs: []
  type: TYPE_TB
