- en: RecordsAdding Records to STLC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 STLC 添加记录
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Import Maps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Maps。
- en: Require Import Imp.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Imp。
- en: Require Import Smallstep.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Smallstep。
- en: Require Import Stlc.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Stlc。
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 't ::=                          Terms:'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t ::=                          项：
- en: '| {i1=t1, ..., in=tn}         record'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| {i1=t1, ..., in=tn}         记录'
- en: '| t.i                         projection'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| t.i                         投影'
- en: '| ...'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: 'v ::=                          Values:'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: v ::=                          值：
- en: '| {i1=v1, ..., in=vn}         record value'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| {i1=v1, ..., in=vn}         记录值'
- en: '| ...'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: 'T ::=                          Types:'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T ::=                          类型：
- en: '| {i1:T1, ..., in:Tn}         record type'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| {i1:T1, ..., in:Tn}         记录类型'
- en: '| ...'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Formalizing Records
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形式化记录
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Syntax and Operational Semantics
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法和操作语义
- en: The most obvious way to formalize the syntax of record types would
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 形式化记录类型的语法最明显的方法是
- en: 'be this:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能是这样的：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unfortunately, we encounter here a limitation in Coq: this type'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，在 Coq 中遇到了一个限制：这种类型
- en: 'does not automatically give us the induction principle we expect:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不会自动给我们期望的归纳原理：
- en: the induction hypothesis in the TRcd case doesn't give us
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TRcd 案例中的归纳假设并没有给我们
- en: any information about the ty elements of the list, making it
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何关于列表的 ty 元素的信息，使其
- en: useless for the proofs we want to do.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对我们想要进行的证明没有用处。
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is possible to get a better induction principle out of Coq, but
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以从 Coq 中获得更好的归纳原理，但
- en: the details of how this is done are not very pretty, and the
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如何完成这个任务的细节并不是很美观，而且
- en: principle we obtain is not as intuitive to use as the ones Coq
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们得到的原则并不像 Coq 中的那些直观易用。
- en: generates automatically for simple Inductive definitions.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为简单的归纳定义自动生成。
- en: Fortunately, there is a different way of formalizing records that
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 幸运的是，有一种不同的形式化记录的方法
- en: 'is, in some ways, even simpler and more natural: instead of using'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在某种程度上，更简单更自然：而不是使用
- en: the standard Coq list type, we can essentially incorporate its
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标准的 Coq 列表类型，我们基本上可以将其
- en: constructors ("nil" and "cons") in the syntax of our types.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造子（“nil” 和 “cons”）的语法中。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly, at the level of terms, we have constructors trnil,
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，在项的层面上，我们有构造子 trnil，
- en: for the empty record, and trcons, which adds a single field to
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于空记录，和 trcons，它添加一个字段到
- en: the front of a list of fields.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列字段的前面。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Some examples...
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些例子...
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '{ i[1]:A }'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{ i[1]:A }'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '{ i[1]:A→B, i[2]:A }'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{ i[1]:A→B, i[2]:A }'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Well-Formedness
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合法性
- en: One issue with generalizing the abstract syntax for records from
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从一般化记录的抽象语法存在一个问题
- en: lists to the nil/cons presentation is that it introduces the
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将列表转换为 nil/cons 表示法的原因是它引入了
- en: possibility of writing strange types like this...
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写出像这样奇怪的类型的可能性...
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where the "tail" of a record type is not actually a record type!
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中记录类型的“尾部”实际上不是记录类型！
- en: We'll structure our typing judgement so that no ill-formed types
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将构造我们的类型判断，以便没有不合法的类型
- en: like weird_type are ever assigned to terms.  To support this, we
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像 weird_type 这样的类型从未分配给项。为了支持这一点，我们
- en: define predicates record_ty and record_tm, which identify
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义谓词 record_ty 和 record_tm，用于识别
- en: record types and terms, and well_formed_ty which rules out the
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记录类型和项，以及 well_formed_ty，它排除了
- en: ill-formed types.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不合法的类型。
- en: First, a type is a record type if it is built with just TRNil
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，如果只使用 TRNil 构造一个类型，则该类型是记录类型
- en: and TRCons at the outermost level.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和 TRCons 在最外层。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this, we can define well-formed types.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这个，我们可以定义良好形成的类型。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that record_ty and record_tm are not recursive — they
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 record_ty 和 record_tm 不是递归的 —— 它们
- en: just check the outermost constructor.  The well_formed_ty
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只需检查最外层的构造子。well_formed_ty
- en: property, on the other hand, verifies that the whole type is well
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，该属性验证整个类型是否良好形成
- en: formed in the sense that the tail of every record (the second
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 TRcd 案例中，整个类型都是良好形成的。
- en: argument to TRCons) is a record.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TRCons 的参数）是一个记录。
- en: Of course, we should also be concerned about ill-formed terms, not
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，我们也应该关注不合法的项，而不是
- en: just types; but typechecking can rules those out without the help
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只是类型；但是类型检查可以排除这些，而不需要帮助
- en: of an extra well_formed_tm definition because it already
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于它已经有了额外的 well_formed_tm 定义
- en: examines the structure of terms.  All we need is an analog of
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查项的结构。我们只需要一个类似于
- en: record_ty saying that a term is a record term if it is built
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: record_ty 表示一个项是记录项，如果它是由
- en: with trnil and trcons.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 trnil 和 trcons。
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Substitution
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换
- en: Substitution extends easily.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换很容易扩展。
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Reduction
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规约
- en: A record is a value if all of its fields are.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果所有字段都是，则记录是一个值。
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To define reduction, we'll need a utility function for extracting
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了定义规约，我们需要一个用于提取的实用函数
- en: 'one field from record term:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'one field from record term:'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The step function uses this term-level lookup function in the
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: The step function uses this term-level lookup function in the
- en: projection rule.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: projection rule.
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Typing
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Typing
- en: Next we define the typing rules.  These are nearly direct
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Next we define the typing rules.  These are nearly direct
- en: 'transcriptions of the inference rules shown above: the only'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'transcriptions of the inference rules shown above: the only'
- en: significant difference is the use of well_formed_ty.  In the
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: significant difference is the use of well_formed_ty.  In the
- en: informal presentation we used a grammar that only allowed
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: informal presentation we used a grammar that only allowed
- en: well-formed record types, so we didn't have to add a separate
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: well-formed record types, so we didn't have to add a separate
- en: check.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: check.
- en: One sanity condition that we'd like to maintain is that, whenever
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: One sanity condition that we'd like to maintain is that, whenever
- en: has_type Γ t T holds, will also be the case that
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: has_type Γ t T holds, will also be the case that
- en: well_formed_ty T, so that has_type never assigns ill-formed
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: well_formed_ty T, so that has_type never assigns ill-formed
- en: types to terms.  In fact, we prove this theorem below.  However,
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: types to terms.  In fact, we prove this theorem below.  However,
- en: we don't want to clutter the definition of has_type with
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: we don't want to clutter the definition of has_type with
- en: unnecessary uses of well_formed_ty.  Instead, we place
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unnecessary uses of well_formed_ty.  Instead, we place
- en: 'well_formed_ty checks only where needed: where an inductive call'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'well_formed_ty checks only where needed: where an inductive call'
- en: to has_type won't already be checking the well-formedness of a
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: to has_type won't already be checking the well-formedness of a
- en: type.  For example, we check well_formed_ty T in the T_Var
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: type.  For example, we check well_formed_ty T in the T_Var
- en: case, because there is no inductive has_type call that would
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: case, because there is no inductive has_type call that would
- en: enforce this.  Similarly, in the T_Abs case, we require a proof
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: enforce this.  Similarly, in the T_Abs case, we require a proof
- en: of well_formed_ty T[11] because the inductive call to has_type
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: of well_formed_ty T[11] because the inductive call to has_type
- en: only guarantees that T[12] is well-formed.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: only guarantees that T[12] is well-formed.
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Examples
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Examples
- en: 'Exercise: 2 stars (examples)'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'Exercise: 2 stars (examples)'
- en: Finish the proofs below.  Feel free to use Coq's automation
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Finish the proofs below.  Feel free to use Coq's automation
- en: features in this proof.  However, if you are not confident about
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: features in this proof.  However, if you are not confident about
- en: how the type system works, you may want to carry out the proofs
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: how the type system works, you may want to carry out the proofs
- en: first using the basic features (apply instead of eapply, in
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: first using the basic features (apply instead of eapply, in
- en: particular) and then perhaps compress it using automation.  Before
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: particular) and then perhaps compress it using automation.  Before
- en: starting to prove anything, make sure you understand what it is
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: starting to prove anything, make sure you understand what it is
- en: saying.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: saying.
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Properties of Typing
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Properties of Typing
- en: The proofs of progress and preservation for this system are
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: The proofs of progress and preservation for this system are
- en: essentially the same as for the pure simply typed lambda-calculus,
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: essentially the same as for the pure simply typed lambda-calculus,
- en: but we need to add some technical lemmas involving records.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: but we need to add some technical lemmas involving records.
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lemma wf_rcd_lookup : ∀i T Ti,'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma wf_rcd_lookup : ∀i T Ti,'
- en: well_formed_ty T →
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: well_formed_ty T →
- en: Tlookup i T = Some Ti →
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Tlookup i T = Some Ti →
- en: well_formed_ty Ti.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: well_formed_ty Ti.
- en: Proof with eauto.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros i T.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: intros i T.
- en: induction T; intros; try solve_by_invert.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: induction T; intros; try solve_by_invert.
- en: '- (* TRCons *)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* TRCons *)'
- en: inversion H. subst. unfold [Tlookup](Records.html#STLCExtendedRecords.Tlookup)
    in H[0].
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H. subst. unfold [Tlookup](Records.html#STLCExtendedRecords.Tlookup)
    in H[0].
- en: destruct ([beq_id](Maps.html#beq_id) i i[0])...
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_id](Maps.html#beq_id) i i[0])...
- en: inversion H[0]. subst... Qed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H[0]. subst... Qed.
- en: 'Lemma step_preserves_record_tm : ∀tr tr'','
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma step_preserves_record_tm : ∀tr tr'','
- en: record_tm tr →
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: record_tm tr →
- en: tr ⇒ tr' →
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: tr ⇒ tr' →
- en: record_tm tr'.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: record_tm tr'.
- en: Proof.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof.
- en: intros tr tr' Hrt Hstp.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: intros tr tr' Hrt Hstp.
- en: inversion Hrt; subst; inversion Hstp; subst; auto.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Hrt; subst; inversion Hstp; subst; auto.
- en: Qed.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma has_type__wf : ∀Γ t T,'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma has_type__wf : ∀Γ t T,'
- en: Γ ⊢ t ∈ T → well_formed_ty T.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Γ ⊢ t ∈ T → well_formed_ty T.
- en: Proof with eauto.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros Γ t T Htyp.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: intros Γ t T Htyp.
- en: induction Htyp...
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: induction Htyp...
- en: '- (* T_App *)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: inversion IHHtyp1...
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: inversion IHHtyp1...
- en: '- (* T_Proj *)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Proj *)'
- en: eapply [wf_rcd_lookup](Records.html#STLCExtendedRecords.wf_rcd_lookup)...
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [wf_rcd_lookup](Records.html#STLCExtendedRecords.wf_rcd_lookup)...
- en: Qed.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tlookup i T = Tlookup i Tr
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Tlookup i T = Tlookup i Tr
- en: and
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: and
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lemma lookup_field_in_value : ∀v T i Ti,'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma lookup_field_in_value : ∀v T i Ti,'
- en: value v →
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: value v →
- en: empty ⊢ v ∈ T →
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: empty ⊢ v ∈ T →
- en: Tlookup i T = Some Ti →
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Tlookup i T = Some Ti →
- en: ∃ti, tlookup i v = Some ti ∧ empty ⊢ ti ∈ Ti.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ∃ti, tlookup i v = Some ti ∧ empty ⊢ ti ∈ Ti.
- en: Proof with eauto.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros v T i Ti Hval Htyp Hget.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: intros v T i Ti Hval Htyp Hget.
- en: remember (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty))
    as Γ.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: remember (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty))
    as Γ.
- en: induction Htyp; subst; try solve_by_invert...
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: induction Htyp; subst; try solve_by_invert...
- en: '- (* T_RCons *)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_RCons *)'
- en: simpl in Hget. simpl. destruct ([beq_id](Maps.html#beq_id) i i[0]).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hget 中简化。简化。将 ([beq_id](Maps.html#beq_id) i i[0]) 解构为...
- en: + (* i is first *)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: + (* i 是第一个 *)
- en: simpl. inversion Hget. subst.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。反演 Hget。替换。
- en: ∃t...
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ∃t...
- en: + (* get tail *)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: + (* 获取尾部 *)
- en: destruct IHHtyp2 as [vi [Hgeti Htypi]]...
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IHHtyp2 解构为 [vi [Hgeti Htypi]]...
- en: inversion Hval... Qed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Hval... 完成。
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Theorem progress : ∀t T,'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 progress：对于所有的 t 和 T，
- en: empty ⊢ t ∈ T →
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: empty ⊢ t ∈ T →
- en: value t ∨ ∃t', t ⇒ t'.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 值 t 或 ∃t'，t ⇒ t'。
- en: Proof with eauto.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明使用 eauto。
- en: (* Theorem: Suppose empty |- t : T.  Then either        1. t is a value, or
           2. t ==> t' for some t'.      Proof: By induction on the given typing derivation. *)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 定理：假设 empty |- t : T。  那么要么        1. t 是一个值，要么        2. 存在某个 t'' 使得 t
    ==> t''。       证明：通过对给定的类型推导进行归纳。 *)'
- en: intros t T Ht.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 t 和 T，引入 Ht。
- en: remember (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty))
    as Γ.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty)）作为 Γ。
- en: generalize dependent HeqGamma.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 推广 HeqGamma。
- en: induction Ht; intros HeqGamma; subst.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Ht 进行归纳；引入 HeqGamma；替换。
- en: '- (* T_Var *)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Var *)'
- en: '(* The final rule in the given typing derivation cannot be         T_Var, since it can never be the case that 
           empty ⊢ x : T (since the context is empty). *)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 给定的类型推导中最后一条规则不能是 T_Var，因为永远不可能出现        empty ⊢ x : T（因为上下文为空）。 *)'
- en: inversion H.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H。
- en: '- (* T_Abs *)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: (* If the T_Abs rule was the last used, then         t = tabs x T[11] t[12], which is a value. *)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果最后使用的规则是 T_Abs，那么     ��  t = tabs x T[11] t[12]，这是一个值。 *)
- en: left...
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: left...
- en: '- (* T_App *)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: '(* If the last rule applied was T_App, then t = t[1] t[2],         and we know from the form of the rule that
             empty ⊢ t[1] : T[1] → T[2]          empty ⊢ t[2] : T[1]        By the induction hypothesis, each of t[1] and t[2] either is a value
           or can take a step. *)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果应用的最后一条规则是 T_App，那么 t = t[1] t[2]，        并且根据规则的形式我们知道          empty
    ⊢ t[1] : T[1] → T[2]          empty ⊢ t[2] : T[1]        根据归纳假设，t[1] 和 t[2] 要么是值，要么可以进行一步操作。 *)'
- en: right.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: right。
- en: destruct IHHt1; subst...
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IHHt1 解构；替换...
- en: + (* t[1] is a value *)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是值 *)
- en: destruct IHHt2; subst...
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IHHt2 解构；替换...
- en: '* (* t[2] is a value *)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 是值 *)'
- en: (* If both t[1] and t[2] are values, then we know that          t[1] = tabs
    x T[11] t[12], since abstractions are the only           values that can have an arrow type.  But
             (tabs x T[11] t[12]) t[2] ⇒ [x:=t[2]]t[12] by ST_AppAbs. *)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果 t[1] 和 t[2] 都是值，那么我们知道          t[1] = tabs x T[11] t[12]，因为抽象是唯一          可能具有箭头类型的值。  但
             (tabs x T[11] t[12]) t[2] ⇒ [x:=t[2]]t[12] 通过 ST_AppAbs。 *)
- en: inversion H; subst; try solve_by_invert.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H；替换；尝试通过反演解决。
- en: ∃([x:=t[2]]t[12])...
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([x:=t[2]]t[12])...
- en: '* (* t[2] steps *)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 步骤 *)'
- en: (* If t[1] is a value and t[2] ⇒ t[2]', then             t[1] t[2] ⇒ t[1] t[2]' by ST_App2. *)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果 t[1] 是一个值且 t[2] ⇒ t[2]'，那么            t[1] t[2] ⇒ t[1] t[2]' 通过 ST_App2。 *)
- en: destruct H[0] as [t[2]' Hstp]. ∃([tapp](Records.html#STLCExtendedRecords.tapp)
    t[1] t[2]')...
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将 H[0] 解构为 [t[2]' Hstp]。∃([tapp](Records.html#STLCExtendedRecords.tapp) t[1]
    t[2]')...
- en: + (* t[1] steps *)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: (* Finally, If t[1] ⇒ t[1]', then t[1] t[2] ⇒ t[1]' t[2]           by ST_App1. *)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: (* 最后，如果 t[1] ⇒ t[1]'，那么 t[1] t[2] ⇒ t[1]' t[2]           通过 ST_App1。 *)
- en: destruct H as [t[1]' Hstp]. ∃([tapp](Records.html#STLCExtendedRecords.tapp)
    t[1]' t[2])...
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将 H 解构为 [t[1]' Hstp]. ∃([tapp](Records.html#STLCExtendedRecords.tapp) t[1]'
    t[2])...
- en: '- (* T_Proj *)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Proj *)'
- en: '(* If the last rule in the given derivation is T_Proj, then        t = tproj
    t i and            empty ⊢ t : (TRcd Tr)        By the IH, t either is a value or takes a step. *)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果给定推导中最后一条规则是 T_Proj，那么        t = tproj t i 且            empty ⊢ t : (TRcd
    Tr)        根据 IH，t 要么是一个值，要么会进行一步操作。 *)'
- en: right. destruct IHHt...
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: right。将 IHHt 解构为...
- en: + (* rcd is value *)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: + (* rcd 是值 *)
- en: (* If t is a value, then we may use lemma          lookup_field_in_value to show tlookup
    i t = Some ti           for some ti which gives us tproj i t ⇒ ti by           ST_ProjRcd. *)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果 t 是一个值，那么我们可以使用引理          lookup_field_in_value 来展示 tlookup i t = Some
    ti           对于某个 ti，这给我们 tproj i t ⇒ ti 通过          ST_ProjRcd。 *)
- en: destruct ([lookup_field_in_value](Records.html#STLCExtendedRecords.lookup_field_in_value)
    _ _ _ _ H[0] Ht H)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ([lookup_field_in_value](Records.html#STLCExtendedRecords.lookup_field_in_value)
    _ _ _ _ H[0] Ht H) 解构为...
- en: as [ti [Hlkup _]].
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [ti [Hlkup _]] 作为右值。
- en: ∃ti...
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ∃ti...
- en: + (* rcd_steps *)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: + (* rcd 步骤 *)
- en: (* On the other hand, if t ⇒ t', then           tproj t i ⇒ tproj t' i by ST_Proj1. *)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (* 另一方面，如果 t ⇒ t'，那么          tproj t i ⇒ tproj t' i 通过 ST_Proj1。 *)
- en: destruct H[0] as [t' Hstp]. ∃([tproj](Records.html#STLCExtendedRecords.tproj)
    t' i)...
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将 H[0] 解构为 [t' Hstp]。∃([tproj](Records.html#STLCExtendedRecords.tproj) t' i)...
- en: '- (* T_RNil *)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_RNil *)'
- en: (* If the last rule in the given derivation is T_RNil,         then t = trnil, which is a value. *)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果给定推导中最后一条规则是 T_RNil，        那么 t = trnil，这是一个值。 *)
- en: left...
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: left...
- en: '- (* T_RCons *)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_RCons *)'
- en: '(* If the last rule is T_RCons, then t = trcons i t tr and          empty ⊢
    t : T          empty ⊢ tr : Tr        By the IH, each of t and tr either is a value or can 
           take a step. *)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果最后一条规则是 T_RCons，那么 t = trcons i t tr 并且 empty ⊢ t : T empty ⊢ tr : Tr
    通过 IH，t 和 tr 中的每一个要么是一个值，要么可以进行一步操作。*)'
- en: destruct IHHt1...
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt1...
- en: + (* head is a value *)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: + (* 头是一个值*)
- en: destruct IHHt2; try reflexivity.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt2; try reflexivity.
- en: '* (* tail is a value *)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* 尾部是一个值*)'
- en: (* If t and tr are both values, then trcons i t tr          is a value as well. *)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果 t 和 tr 都是值，那么 trcons i t tr 也是一个值。*)
- en: left...
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 左边...
- en: '* (* tail steps *)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* 尾部步骤*)'
- en: (* If t is a value and tr ⇒ tr', then            trcons i t tr ⇒ trcons i t
    tr' by            ST_Rcd_Tail. *)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果 t 是一个值，并且 tr ⇒ tr'，那么 trcons i t tr ⇒ trcons i t tr' 通过 ST_Rcd_Tail。*)
- en: right. destruct H[2] as [tr' Hstp].
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: right. destruct H[2] as [tr' Hstp].
- en: ∃([trcons](Records.html#STLCExtendedRecords.trcons) i t tr')...
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([trcons](Records.html#STLCExtendedRecords.trcons) i t tr')...
- en: + (* head steps *)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: + (* 头步骤*)
- en: (* If t ⇒ t', then          trcons i t tr ⇒ trcons i t' tr          by ST_Rcd_Head. *)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果 t ⇒ t'，那么 trcons i t tr ⇒ trcons i t' tr 通过 ST_Rcd_Head。*)
- en: right. destruct H[1] as [t' Hstp].
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: right. destruct H[1] as [t' Hstp].
- en: ∃([trcons](Records.html#STLCExtendedRecords.trcons) i t' tr)... Qed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([trcons](Records.html#STLCExtendedRecords.trcons) i t' tr)... 完成。
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inductive appears_free_in : id → tm → Prop :='
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive appears_free_in : id → tm → Prop :='
- en: '| afi_var : ∀x,'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_var : ∀x,'
- en: appears_free_in x (tvar x)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tvar x)
- en: '| afi_app1 : ∀x t[1] t[2],'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_app1 : ∀x t[1] t[2],'
- en: appears_free_in x t[1] → appears_free_in x (tapp t[1] t[2])
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[1] → appears_free_in x (tapp t[1] t[2])
- en: '| afi_app2 : ∀x t[1] t[2],'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_app2 : ∀x t[1] t[2],'
- en: appears_free_in x t[2] → appears_free_in x (tapp t[1] t[2])
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[2] → appears_free_in x (tapp t[1] t[2])
- en: '| afi_abs : ∀x y T[11] t[12],'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_abs : ∀x y T[11] t[12],'
- en: y ≠ x  →
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: y ≠ x  →
- en: appears_free_in x t[12] →
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[12] →
- en: appears_free_in x (tabs y T[11] t[12])
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tabs y T[11] t[12])
- en: '| afi_proj : ∀x t i,'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_proj : ∀x t i,'
- en: appears_free_in x t →
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t →
- en: appears_free_in x (tproj t i)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tproj t i)
- en: '| afi_rhead : ∀x i ti tr,'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_rhead : ∀x i ti tr,'
- en: appears_free_in x ti →
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x ti →
- en: appears_free_in x (trcons i ti tr)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (trcons i ti tr)
- en: '| afi_rtail : ∀x i ti tr,'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_rtail : ∀x i ti tr,'
- en: appears_free_in x tr →
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x tr →
- en: appears_free_in x (trcons i ti tr).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (trcons i ti tr).
- en: Hint Constructors appears_free_in.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hint Constructors appears_free_in。
- en: 'Lemma context_invariance : ∀Γ Γ'' t S,'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma context_invariance : ∀Γ Γ'' t S,'
- en: Γ ⊢ t ∈ S  →
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Γ ⊢ t ∈ S  →
- en: (∀x, appears_free_in x t → Γ x = Γ' x)  →
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: (∀x, appears_free_in x t → Γ x = Γ' x)  →
- en: Γ' ⊢ t ∈ S.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Γ' ⊢ t ∈ S.
- en: Proof with eauto.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros. generalize dependent Γ'.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: intros. generalize dependent Γ'.
- en: induction H;
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对 H 进行归纳；
- en: intros Γ' Heqv...
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: intros Γ' Heqv...
- en: '- (* T_Var *)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Var *)'
- en: apply [T_Var](Records.html#STLCExtendedRecords.T_Var)... rewrite ← Heqv...
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_Var](Records.html#STLCExtendedRecords.T_Var)... 重写 ← Heqv...
- en: '- (* T_Abs *)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: apply [T_Abs](Records.html#STLCExtendedRecords.T_Abs)... apply IHhas_type. intros
    y Hafi.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_Abs](Records.html#STLCExtendedRecords.T_Abs)... 应用 IHhas_type。intros y
    Hafi。
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). destruct
    ([beq_idP](Maps.html#beq_idP) x y)...
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [update](Maps.html#update), [t_update](Maps.html#t_update)。对 ([beq_idP](Maps.html#beq_idP)
    x y) 进行分析...
- en: '- (* T_App *)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: apply [T_App](Records.html#STLCExtendedRecords.T_App) with T[1]...
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_App](Records.html#STLCExtendedRecords.T_App) with T[1]...
- en: '- (* T_RCons *)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_RCons *)'
- en: apply [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... Qed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... 完成。
- en: 'Lemma free_in_context : ∀x t T Γ,'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma free_in_context : ∀x t T Γ,'
- en: appears_free_in x t →
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t →
- en: Γ ⊢ t ∈ T →
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Γ ⊢ t ∈ T →
- en: ∃T', Γ x = Some T'.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ∃T', Γ x = Some T'.
- en: Proof with eauto.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros x t T Γ Hafi Htyp.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: intros x t T Γ Hafi Htyp.
- en: induction Htyp; inversion Hafi; subst...
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Htyp 进行归纳；反演 Hafi；替换...
- en: '- (* T_Abs *)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: destruct IHHtyp as [T' Hctx]... ∃T'.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHtyp as [T' Hctx]... ∃T'.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hctx 中展开 [update](Maps.html#update), [t_update](Maps.html#t_update)。
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hctx 中重写 [false_beq_id](Maps.html#false_beq_id)...
- en: Qed.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE27]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
- en: (update Γ x U) ⊢ t ∈ S  →
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: (update Γ x U) ⊢ t ∈ S  →
- en: empty ⊢ v ∈ U   →
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: empty ⊢ v ∈ U   →
- en: Γ ⊢ ([x:=v]t) ∈ S.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Γ ⊢ ([x:=v]t) ∈ S.
- en: Proof with eauto.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: (* Theorem: If Gamma,x:U |- t : S and empty |- v : U, then      Gamma |- (x:=vt) S. *)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 定理：如果 Gamma,x:U |- t : S 并且 empty |- v : U，则 Gamma |- (x:=vt) S。*)'
- en: intros Γ x U v t S Htypt Htypv.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: intros Γ x U v t S Htypt Htypv.
- en: generalize dependent Γ. generalize dependent S.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: generalize dependent Γ. generalize dependent S.
- en: (* Proof: By induction on the term t.  Most cases follow       directly from the IH, with the exception of tvar, 
         tabs, trcons. The former aren't automatic because we       must reason about how the variables interact. In the 
         case of trcons, we must do a little extra work to show       that substituting into a term doesn't change whether 
         it is a record term. *)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: (* 证明：通过对项 t 进行归纳。大多数情况都可以      直接从 IH 推导出来，除了 tvar，      tabs，trcons。前者不是自动的，因为我们
         必须推理变量如何相互作用。在      trcons 的情况下，我们必须做一些额外的工作来展示      替换一个项不会改变它是否      是一个记录项。*)
- en: induction t;
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t 进行归纳;
- en: intros S Γ Htypt; simpl; inversion Htypt; subst...
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 推理 S Γ Htypt; 简化; 反演 Htypt; 替换...
- en: '- (* tvar *)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tvar *)'
- en: simpl. rename i into y.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。将 i 重命名为 y。
- en: '(* If t = y, we know that          empty ⊢ v : U and          Γ,x:U ⊢ y : S
           and, by inversion, update Γ x U y = Some S.          We want to show that Γ
    ⊢ [x:=v]y : S.        There are two cases to consider: either x=y or x≠y. *)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 t = y，我们知道          empty ⊢ v : U 和          Γ,x:U ⊢ y : S        ��且，通过反演，update
    Γ x U y = Some S。          我们想要展示 Γ ⊢ [x:=v]y : S。        有两种情况要考虑：要么 x=y，要么 x≠y。*)'
- en: unfold update, t_update in H[0].
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 update, t_update 在 H[0] 中。
- en: destruct (beq_idP x y) as [Hxy|Hxy].
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 (beq_idP x y) 得到 [Hxy|Hxy]。
- en: + (* x=y *)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x=y *)
- en: '(* If x = y, then we know that U = S, and that         [x:=v]y = v. So what we really must show is that 
           if empty ⊢ v : U then Γ ⊢ v : U.  We have         already proven a more general version of this theorem, 
            called context invariance! *)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x = y，那么我们知道 U = S，并且        [x:=v]y = v。所以我们真正需要展示的是        如果 empty
    ⊢ v : U，则 Γ ⊢ v : U。我们已经        证明了这个定理的一个更一般的版本，        称为上下文不变性！*)'
- en: subst.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。
- en: inversion H[0]; subst. clear H[0].
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H[0]; 替换。清除 H[0]。
- en: eapply context_invariance...
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 context_invariance...
- en: intros x Hcontra.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 推理 x Hcontra。
- en: destruct (free_in_context _ _ S empty Hcontra)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 (free_in_context _ _ S empty Hcontra)
- en: as [T' HT']...
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [T' HT']...
- en: inversion HT'.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HT'。
- en: + (* x<>y *)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x<>y *)
- en: '(* If x ≠ y, then Γ y = Some S and the substitution        has no effect.  We can show that Γ
    ⊢ y : S by         T_Var. *)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x ≠ y，那么 Γ y = Some S，替换        没有影响。我们可以展示 Γ ⊢ y : S 通过        T_Var。*)'
- en: apply T_Var...
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 T_Var...
- en: '- (* tabs *)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tabs *)'
- en: rename i into y. rename t into T[11].
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 将 i 重命名为 y。将 t 重命名为 T[11]。
- en: '(* If t = tabs y T[11] t[0], then we know that          Γ,x:U ⊢ tabs y T[11]
    t[0] : T[11]→T[12]          Γ,x:U,y:T[11] ⊢ t[0] : T[12]          empty ⊢ v :
    U        As our IH, we know that forall S Gamma,          Γ,x:U ⊢ t[0] : S → Γ
    ⊢ [x:=v]t[0] S.        We can calculate that         [x:=v]t = tabs y T[11] (if
    beq_id x y then t[0] else [x:=v]t[0]) ,        and we must show that Γ ⊢ [x:=v]t
    : T[11]→T[12].  We know        we will do so using T_Abs, so it remains to be shown that:
             Γ,y:T[11] ⊢ if beq_id x y then t[0] else [x:=v]t[0] : T[12]        We consider two cases: x
    = y and x ≠ y. *)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 t = tabs y T[11] t[0]，那么我们知道          Γ,x:U ⊢ tabs y T[11] t[0] : T[11]→T[12]
             Γ,x:U,y:T[11] ⊢ t[0] : T[12]          empty ⊢ v : U        根据我们的 IH，我们知道对于所有的
    S 和 Gamma，          Γ,x:U ⊢ t[0] : S → Γ ⊢ [x:=v]t[0] S。        我们可以计算出        
    [x:=v]t = tabs y T[11] (if beq_id x y then t[0] else [x:=v]t[0]) ，        我们必须展示
    Γ ⊢ [x:=v]t : T[11]→T[12]。  我们知道        我们将使用 T_Abs 来做到这一点，所以我们还需要展示：          Γ,y:T[11]
    ⊢ if beq_id x y then t[0] else [x:=v]t[0] : T[12]        我们考虑两种情况：x = y 和 x ≠
    y。*)'
- en: apply [T_Abs](Records.html#STLCExtendedRecords.T_Abs)...
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_Abs](Records.html#STLCExtendedRecords.T_Abs)...
- en: destruct ([beq_idP](Maps.html#beq_idP) x y) as [Hxy|Hxy].
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_idP](Maps.html#beq_idP) x y) 得到 [Hxy|Hxy]。
- en: + (* x=y *)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x=y *)
- en: '(* If x = y, then the substitution has no effect.  Context          invariance shows that Γ,y:U,y:T[11] and Γ,y:T[11] are
             equivalent.  Since t[0] : T[12] under the former context,           this is also the case under the latter. *)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x = y，那么替换没有影响。        上下文不变性表明 Γ,y:U,y:T[11] 和 Γ,y:T[11] 是        等价的。由于
    t[0] : T[12] 在前者的上下文下，        在后者的上下文下也是如此。*)'
- en: eapply [context_invariance](Records.html#STLCExtendedRecords.context_invariance)...
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [context_invariance](Records.html#STLCExtendedRecords.context_invariance)...
- en: subst.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。
- en: intros x Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 推理 x Hafi。展开 [update](Maps.html#update)，[t_update](Maps.html#t_update)。
- en: destruct ([beq_id](Maps.html#beq_id) y x)...
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_id](Maps.html#beq_id) y x)...
- en: + (* x<>y *)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x<>y *)
- en: '(* If x ≠ y, then the IH and context invariance allow           us to show that
               Γ,x:U,y:T[11] ⊢ t[0] : T[12]       =>            Γ,y:T[11],x:U ⊢ t[0]
    : T[12]       =>            Γ,y:T[11] ⊢ [x:=v]t[0] : T[12] *)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x ≠ y，那么 IH 和上下文不变性允许        我们展示          Γ,x:U,y:T[11] ⊢ t[0] : T[12]       =>
             Γ,y:T[11],x:U ⊢ t[0] : T[12]       =>          Γ,y:T[11] ⊢ [x:=v]t[0]
    : T[12] *)'
- en: apply IHt. eapply [context_invariance](Records.html#STLCExtendedRecords.context_invariance)...
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHt。应用 [context_invariance](Records.html#STLCExtendedRecords.context_invariance)...
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 z Hafi。展开 [update](Maps.html#update)，[t_update](Maps.html#t_update)。
- en: destruct ([beq_idP](Maps.html#beq_idP) y z)...
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_idP](Maps.html#beq_idP) y z)...
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。重写 [false_beq_id](Maps.html#false_beq_id)...
- en: '- (* trcons *)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* trcons *)'
- en: apply [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... inversion H[7];
    subst; simpl...
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... 反演 H[7]；替换；简化...
- en: Qed.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: 'Theorem preservation : ∀t t'' T,'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 定理保持性：∀t t' T，
- en: '[empty](Maps.html#empty) ⊢ [t](Records.html#t) ∈ [T](Records.html#T)  →'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[空](Maps.html#empty) ⊢ [t](Records.html#t) ∈ [T](Records.html#T)  →'
- en: '[t](Records.html#t) ⇒ [t''](Records.html#t'')  →'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[t](Records.html#t) ⇒ [t''](Records.html#t'')  →'
- en: '[empty](Maps.html#empty) ⊢ [t''](Records.html#t'') ∈ [T](Records.html#T).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[空](Maps.html#empty) ⊢ [t''](Records.html#t'') ∈ [T](Records.html#T)。'
- en: Proof with eauto.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 证明与 eauto。
- en: intros t t' T HT.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 t t' T HT。
- en: '(* Theorem: If empty ⊢ t : T and t ⇒ t'', then       empty ⊢ t'' : T. *)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 定理：如果 empty ⊢ t : T 并且 t ⇒ t''，那么 empty ⊢ t'' : T。*)'
- en: remember (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty))
    as Γ. generalize dependent HeqGamma.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty)) 作为
    Γ。泛化依赖于 HeqGamma。
- en: generalize dependent t'.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化依赖于 t'。
- en: (* Proof: By induction on the given typing derivation.        Many cases are contradictory (T_Var, T_Abs) or follow 
         directly from the IH (T_RCons).  We show just the       interesting ones. *)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: (* 证明：根据给定的类型推导进行归纳。许多情况是矛盾的（T_Var，T_Abs），或直接从归纳假设中得出（T_RCons）。我们只展示有趣的情况。*)
- en: induction HT;
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HT 进行归纳；
- en: intros t' HeqGamma HE; subst; inversion HE; subst...
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 t' HeqGamma HE；替换；反演 HE；替换...
- en: '- (* T_App *)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: (* If the last rule used was T_App, then t = t[1] t[2],         and three rules could have been used to show t
    ⇒ t':         ST_App1, ST_App2, and ST_AppAbs. In the first two         cases, the result follows directly from the IH. *)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果最后使用的规则是 T_App，则 t = t[1] t[2]，并且有三条规则可以用来展示 t ⇒ t'：ST_App1，ST_App2 和 ST_AppAbs。在前两种情况下，结果直接从归纳假设中得出。*)
- en: inversion HE; subst...
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HE；替换...
- en: + (* ST_AppAbs *)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: + (* ST_AppAbs *)
- en: '(* For the third case, suppose            t[1] = tabs x T[11] t[12]          and
               t[2] = v[2].  We must show that empty ⊢ [x:=v[2]]t[12] : T[2].          We know by assumption that
                 empty ⊢ tabs x T[11] t[12] : T[1]→T[2]          and by inversion
                 x:T[1] ⊢ t[12] : T[2]          We have already proven that substitution_preserves_typing and
                 empty ⊢ v[2] : T[1]          by assumption, so we are done. *)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 对于第三种情况，假设            t[1] = tabs x T[11] t[12]          并且            t[2]
    = v[2]。我们必须展示 empty ⊢ [x:=v[2]]t[12] : T[2]。根据假设，我们知道              empty ⊢ tabs
    x T[11] t[12] : T[1]→T[2]          并且通过反演              x:T[1] ⊢ t[12] : T[2]。我们已经证明了
    substitution_preserves_typing，并且              empty ⊢ v[2] : T[1]。因此，我们完成了。*)'
- en: apply [substitution_preserves_typing](Records.html#STLCExtendedRecords.substitution_preserves_typing)
    with T[1]...
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [substitution_preserves_typing](Records.html#STLCExtendedRecords.substitution_preserves_typing)
    与 T[1]...
- en: inversion HT[1]...
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HT[1]...
- en: '- (* T_Proj *)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Proj *)'
- en: (* If the last rule was T_Proj, then t = tproj t[1] i.          Two rules could have caused t
    ⇒ t': T_Proj1 and         T_ProjRcd.  The typing of t' follows from the IH         in the former case, so we only consider T_ProjRcd.
           Here we have that t is a record value.  Since rule         T_Proj was used, we know empty
    ⊢ t ∈ Tr and         Tlookup i Tr = Some Ti for some i and Tr.          We may therefore apply lemma lookup_field_in_value 
           to find the record element this projection steps to. *)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果最后一条规则是 T_Proj，则 t = tproj t[1] i。两条规则可能导致 t ⇒ t'：T_Proj1 和 T_ProjRcd。在前一种情况中，t'
    的类型遵循自归纳假设，因此我们只考虑 T_ProjRcd。在这里，我们知道 t 是一个记录值。由于使用了规则 T_Proj，我们知道 empty ⊢ t ∈
    Tr，并且对于某个 i 和 Tr，Tlookup i Tr = Some Ti。因此，我们可以应用引理 lookup_field_in_value 找到此投影步骤到的记录元素。*)
- en: destruct ([lookup_field_in_value](Records.html#STLCExtendedRecords.lookup_field_in_value)
    _ _ _ _ H[2] HT H)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([lookup_field_in_value](Records.html#STLCExtendedRecords.lookup_field_in_value)
    _ _ _ _ H[2] HT H)
- en: as [vi [Hget Htyp]].
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [vi [Hget Htyp]]。
- en: rewrite H[4] in Hget. inversion Hget. subst...
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 H[4] 在 Hget 中。反演 Hget。替换...
- en: '- (* T_RCons *)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_RCons *)'
- en: (* If the last rule was T_RCons, then t = trcons i t tr         for some i, t and tr such that record_tm
    tr.  If         the step is by ST_Rcd_Head, the result is immediate by         the IH.  If the step is by ST_Rcd_Tail, tr
    ⇒ tr[2]'         for some tr[2]' and we must also use lemma step_preserves_record_tm 
           to show record_tm tr[2]'. *)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果最后一条规则是 T_RCons，则 t = trcons i t tr，其中存在某个 i、t 和 tr，使得 record_tm tr 成立。如果步骤是通过
    ST_Rcd_Head，结果立即由归纳假设得出。如果步骤是通过 ST_Rcd_Tail，tr ⇒ tr[2]'，对于某个 tr[2]'，我们还必须使用引理
    step_preserves_record_tm 来展示 record_tm tr[2]'。*)
- en: apply [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... eapply [step_preserves_record_tm](Records.html#STLCExtendedRecords.step_preserves_record_tm)...
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... 应用 [step_preserves_record_tm](Records.html#STLCExtendedRecords.step_preserves_record_tm)...
- en: Qed.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: QED。
- en: '[PRE28]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: End STLCExtendedRecords.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 STLCExtendedRecords。
- en: '[PRE29]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
