- en: RecordsAdding Records to STLC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 't ::=                          Terms:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| {i1=t1, ..., in=tn}         record'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| t.i                         projection'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'v ::=                          Values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| {i1=v1, ..., in=vn}         record value'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'T ::=                          Types:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| {i1:T1, ..., in:Tn}         record type'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Formalizing Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Syntax and Operational Semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most obvious way to formalize the syntax of record types would
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'be this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, we encounter here a limitation in Coq: this type'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'does not automatically give us the induction principle we expect:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the induction hypothesis in the TRcd case doesn't give us
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: any information about the ty elements of the list, making it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useless for the proofs we want to do.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to get a better induction principle out of Coq, but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the details of how this is done are not very pretty, and the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: principle we obtain is not as intuitive to use as the ones Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: generates automatically for simple Inductive definitions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fortunately, there is a different way of formalizing records that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is, in some ways, even simpler and more natural: instead of using'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the standard Coq list type, we can essentially incorporate its
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors ("nil" and "cons") in the syntax of our types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, at the level of terms, we have constructors trnil,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for the empty record, and trcons, which adds a single field to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the front of a list of fields.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Some examples...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '{ i[1]:A }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '{ i[1]:A→B, i[2]:A }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Well-Formedness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One issue with generalizing the abstract syntax for records from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lists to the nil/cons presentation is that it introduces the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: possibility of writing strange types like this...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: where the "tail" of a record type is not actually a record type!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We'll structure our typing judgement so that no ill-formed types
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: like weird_type are ever assigned to terms.  To support this, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: define predicates record_ty and record_tm, which identify
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: record types and terms, and well_formed_ty which rules out the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ill-formed types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, a type is a record type if it is built with just TRNil
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and TRCons at the outermost level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can define well-formed types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that record_ty and record_tm are not recursive — they
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: just check the outermost constructor.  The well_formed_ty
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: property, on the other hand, verifies that the whole type is well
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: formed in the sense that the tail of every record (the second
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argument to TRCons) is a record.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Of course, we should also be concerned about ill-formed terms, not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: just types; but typechecking can rules those out without the help
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of an extra well_formed_tm definition because it already
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: examines the structure of terms.  All we need is an analog of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: record_ty saying that a term is a record term if it is built
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with trnil and trcons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Substitution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Substitution extends easily.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Reduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A record is a value if all of its fields are.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To define reduction, we'll need a utility function for extracting
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'one field from record term:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The step function uses this term-level lookup function in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: projection rule.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we define the typing rules.  These are nearly direct
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'transcriptions of the inference rules shown above: the only'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: significant difference is the use of well_formed_ty.  In the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: informal presentation we used a grammar that only allowed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: well-formed record types, so we didn't have to add a separate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: check.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One sanity condition that we'd like to maintain is that, whenever
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: has_type Γ t T holds, will also be the case that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: well_formed_ty T, so that has_type never assigns ill-formed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: types to terms.  In fact, we prove this theorem below.  However,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we don't want to clutter the definition of has_type with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unnecessary uses of well_formed_ty.  Instead, we place
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'well_formed_ty checks only where needed: where an inductive call'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to has_type won't already be checking the well-formedness of a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type.  For example, we check well_formed_ty T in the T_Var
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: case, because there is no inductive has_type call that would
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: enforce this.  Similarly, in the T_Abs case, we require a proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of well_formed_ty T[11] because the inductive call to has_type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: only guarantees that T[12] is well-formed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (examples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finish the proofs below.  Feel free to use Coq's automation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: features in this proof.  However, if you are not confident about
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: how the type system works, you may want to carry out the proofs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: first using the basic features (apply instead of eapply, in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: particular) and then perhaps compress it using automation.  Before
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: starting to prove anything, make sure you understand what it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: saying.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Properties of Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proofs of progress and preservation for this system are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: essentially the same as for the pure simply typed lambda-calculus,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: but we need to add some technical lemmas involving records.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma wf_rcd_lookup : ∀i T Ti,'
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty T →
  prefs: []
  type: TYPE_NORMAL
- en: Tlookup i T = Some Ti →
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty Ti.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros i T.
  prefs: []
  type: TYPE_NORMAL
- en: induction T; intros; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* TRCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. subst. unfold [Tlookup](Records.html#STLCExtendedRecords.Tlookup)
    in H[0].
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) i i[0])...
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0]. subst... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma step_preserves_record_tm : ∀tr tr'','
  prefs: []
  type: TYPE_NORMAL
- en: record_tm tr →
  prefs: []
  type: TYPE_NORMAL
- en: tr ⇒ tr' →
  prefs: []
  type: TYPE_NORMAL
- en: record_tm tr'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros tr tr' Hrt Hstp.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hrt; subst; inversion Hstp; subst; auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma has_type__wf : ∀Γ t T,'
  prefs: []
  type: TYPE_NORMAL
- en: Γ ⊢ t ∈ T → well_formed_ty T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros Γ t T Htyp.
  prefs: []
  type: TYPE_NORMAL
- en: induction Htyp...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion IHHtyp1...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Proj *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [wf_rcd_lookup](Records.html#STLCExtendedRecords.wf_rcd_lookup)...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tlookup i T = Tlookup i Tr
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lemma lookup_field_in_value : ∀v T i Ti,'
  prefs: []
  type: TYPE_NORMAL
- en: value v →
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ v ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: Tlookup i T = Some Ti →
  prefs: []
  type: TYPE_NORMAL
- en: ∃ti, tlookup i v = Some ti ∧ empty ⊢ ti ∈ Ti.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros v T i Ti Hval Htyp Hget.
  prefs: []
  type: TYPE_NORMAL
- en: remember (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty))
    as Γ.
  prefs: []
  type: TYPE_NORMAL
- en: induction Htyp; subst; try solve_by_invert...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl in Hget. simpl. destruct ([beq_id](Maps.html#beq_id) i i[0]).
  prefs: []
  type: TYPE_NORMAL
- en: + (* i is first *)
  prefs: []
  type: TYPE_NORMAL
- en: simpl. inversion Hget. subst.
  prefs: []
  type: TYPE_NORMAL
- en: ∃t...
  prefs: []
  type: TYPE_NORMAL
- en: + (* get tail *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHtyp2 as [vi [Hgeti Htypi]]...
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hval... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem progress : ∀t T,'
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: value t ∨ ∃t', t ⇒ t'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* Theorem: Suppose empty |- t : T.  Then either        1. t is a value, or
           2. t ==> t' for some t'.      Proof: By induction on the given typing derivation. *)
  prefs: []
  type: TYPE_NORMAL
- en: intros t T Ht.
  prefs: []
  type: TYPE_NORMAL
- en: remember (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty))
    as Γ.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent HeqGamma.
  prefs: []
  type: TYPE_NORMAL
- en: induction Ht; intros HeqGamma; subst.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Var *)'
  prefs: []
  type: TYPE_NORMAL
- en: '(* The final rule in the given typing derivation cannot be         T_Var, since it can never be the case that 
           empty ⊢ x : T (since the context is empty). *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If the T_Abs rule was the last used, then         t = tabs x T[11] t[12], which is a value. *)
  prefs: []
  type: TYPE_NORMAL
- en: left...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: '(* If the last rule applied was T_App, then t = t[1] t[2],         and we know from the form of the rule that
             empty ⊢ t[1] : T[1] → T[2]          empty ⊢ t[2] : T[1]        By the induction hypothesis, each of t[1] and t[2] either is a value
           or can take a step. *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1; subst...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] is a value *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If both t[1] and t[2] are values, then we know that          t[1] = tabs
    x T[11] t[12], since abstractions are the only           values that can have an arrow type.  But
             (tabs x T[11] t[12]) t[2] ⇒ [x:=t[2]]t[12] by ST_AppAbs. *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: ∃([x:=t[2]]t[12])...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If t[1] is a value and t[2] ⇒ t[2]', then             t[1] t[2] ⇒ t[1] t[2]' by ST_App2. *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct H[0] as [t[2]' Hstp]. ∃([tapp](Records.html#STLCExtendedRecords.tapp)
    t[1] t[2]')...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: (* Finally, If t[1] ⇒ t[1]', then t[1] t[2] ⇒ t[1]' t[2]           by ST_App1. *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct H as [t[1]' Hstp]. ∃([tapp](Records.html#STLCExtendedRecords.tapp)
    t[1]' t[2])...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Proj *)'
  prefs: []
  type: TYPE_NORMAL
- en: '(* If the last rule in the given derivation is T_Proj, then        t = tproj
    t i and            empty ⊢ t : (TRcd Tr)        By the IH, t either is a value or takes a step. *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt...
  prefs: []
  type: TYPE_NORMAL
- en: + (* rcd is value *)
  prefs: []
  type: TYPE_NORMAL
- en: (* If t is a value, then we may use lemma          lookup_field_in_value to show tlookup
    i t = Some ti           for some ti which gives us tproj i t ⇒ ti by           ST_ProjRcd. *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([lookup_field_in_value](Records.html#STLCExtendedRecords.lookup_field_in_value)
    _ _ _ _ H[0] Ht H)
  prefs: []
  type: TYPE_NORMAL
- en: as [ti [Hlkup _]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃ti...
  prefs: []
  type: TYPE_NORMAL
- en: + (* rcd_steps *)
  prefs: []
  type: TYPE_NORMAL
- en: (* On the other hand, if t ⇒ t', then           tproj t i ⇒ tproj t' i by ST_Proj1. *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct H[0] as [t' Hstp]. ∃([tproj](Records.html#STLCExtendedRecords.tproj)
    t' i)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RNil *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If the last rule in the given derivation is T_RNil,         then t = trnil, which is a value. *)
  prefs: []
  type: TYPE_NORMAL
- en: left...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: '(* If the last rule is T_RCons, then t = trcons i t tr and          empty ⊢
    t : T          empty ⊢ tr : Tr        By the IH, each of t and tr either is a value or can 
           take a step. *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  prefs: []
  type: TYPE_NORMAL
- en: + (* head is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2; try reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* tail is a value *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If t and tr are both values, then trcons i t tr          is a value as well. *)
  prefs: []
  type: TYPE_NORMAL
- en: left...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* tail steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If t is a value and tr ⇒ tr', then            trcons i t tr ⇒ trcons i t
    tr' by            ST_Rcd_Tail. *)
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct H[2] as [tr' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([trcons](Records.html#STLCExtendedRecords.trcons) i t tr')...
  prefs: []
  type: TYPE_NORMAL
- en: + (* head steps *)
  prefs: []
  type: TYPE_NORMAL
- en: (* If t ⇒ t', then          trcons i t tr ⇒ trcons i t' tr          by ST_Rcd_Head. *)
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct H[1] as [t' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([trcons](Records.html#STLCExtendedRecords.trcons) i t' tr)... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive appears_free_in : id → tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_var : ∀x,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tvar x)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_app1 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] → appears_free_in x (tapp t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_app2 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] → appears_free_in x (tapp t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_abs : ∀x y T[11] t[12],'
  prefs: []
  type: TYPE_NORMAL
- en: y ≠ x  →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[12] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tabs y T[11] t[12])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_proj : ∀x t i,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tproj t i)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_rhead : ∀x i ti tr,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x ti →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (trcons i ti tr)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_rtail : ∀x i ti tr,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x tr →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (trcons i ti tr).
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors appears_free_in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma context_invariance : ∀Γ Γ'' t S,'
  prefs: []
  type: TYPE_NORMAL
- en: Γ ⊢ t ∈ S  →
  prefs: []
  type: TYPE_NORMAL
- en: (∀x, appears_free_in x t → Γ x = Γ' x)  →
  prefs: []
  type: TYPE_NORMAL
- en: Γ' ⊢ t ∈ S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros. generalize dependent Γ'.
  prefs: []
  type: TYPE_NORMAL
- en: induction H;
  prefs: []
  type: TYPE_NORMAL
- en: intros Γ' Heqv...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Var *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Var](Records.html#STLCExtendedRecords.T_Var)... rewrite ← Heqv...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Abs](Records.html#STLCExtendedRecords.T_Abs)... apply IHhas_type. intros
    y Hafi.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). destruct
    ([beq_idP](Maps.html#beq_idP) x y)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_App](Records.html#STLCExtendedRecords.T_App) with T[1]...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma free_in_context : ∀x t T Γ,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: Γ ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: ∃T', Γ x = Some T'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros x t T Γ Hafi Htyp.
  prefs: []
  type: TYPE_NORMAL
- en: induction Htyp; inversion Hafi; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHtyp as [T' Hctx]... ∃T'.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  prefs: []
  type: TYPE_NORMAL
- en: (update Γ x U) ⊢ t ∈ S  →
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ v ∈ U   →
  prefs: []
  type: TYPE_NORMAL
- en: Γ ⊢ ([x:=v]t) ∈ S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* Theorem: If Gamma,x:U |- t : S and empty |- v : U, then      Gamma |- (x:=vt) S. *)
  prefs: []
  type: TYPE_NORMAL
- en: intros Γ x U v t S Htypt Htypv.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent Γ. generalize dependent S.
  prefs: []
  type: TYPE_NORMAL
- en: (* Proof: By induction on the term t.  Most cases follow       directly from the IH, with the exception of tvar, 
         tabs, trcons. The former aren't automatic because we       must reason about how the variables interact. In the 
         case of trcons, we must do a little extra work to show       that substituting into a term doesn't change whether 
         it is a record term. *)
  prefs: []
  type: TYPE_NORMAL
- en: induction t;
  prefs: []
  type: TYPE_NORMAL
- en: intros S Γ Htypt; simpl; inversion Htypt; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tvar *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rename i into y.
  prefs: []
  type: TYPE_NORMAL
- en: '(* If t = y, we know that          empty ⊢ v : U and          Γ,x:U ⊢ y : S
           and, by inversion, update Γ x U y = Some S.          We want to show that Γ
    ⊢ [x:=v]y : S.        There are two cases to consider: either x=y or x≠y. *)'
  prefs: []
  type: TYPE_NORMAL
- en: unfold update, t_update in H[0].
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_idP x y) as [Hxy|Hxy].
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x = y, then we know that U = S, and that         [x:=v]y = v. So what we really must show is that 
           if empty ⊢ v : U then Γ ⊢ v : U.  We have         already proven a more general version of this theorem, 
            called context invariance! *)'
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0]; subst. clear H[0].
  prefs: []
  type: TYPE_NORMAL
- en: eapply context_invariance...
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hcontra.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (free_in_context _ _ S empty Hcontra)
  prefs: []
  type: TYPE_NORMAL
- en: as [T' HT']...
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT'.
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x ≠ y, then Γ y = Some S and the substitution        has no effect.  We can show that Γ
    ⊢ y : S by         T_Var. *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply T_Var...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tabs *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i into y. rename t into T[11].
  prefs: []
  type: TYPE_NORMAL
- en: '(* If t = tabs y T[11] t[0], then we know that          Γ,x:U ⊢ tabs y T[11]
    t[0] : T[11]→T[12]          Γ,x:U,y:T[11] ⊢ t[0] : T[12]          empty ⊢ v :
    U        As our IH, we know that forall S Gamma,          Γ,x:U ⊢ t[0] : S → Γ
    ⊢ [x:=v]t[0] S.        We can calculate that         [x:=v]t = tabs y T[11] (if
    beq_id x y then t[0] else [x:=v]t[0]) ,        and we must show that Γ ⊢ [x:=v]t
    : T[11]→T[12].  We know        we will do so using T_Abs, so it remains to be shown that:
             Γ,y:T[11] ⊢ if beq_id x y then t[0] else [x:=v]t[0] : T[12]        We consider two cases: x
    = y and x ≠ y. *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Abs](Records.html#STLCExtendedRecords.T_Abs)...
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y) as [Hxy|Hxy].
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x = y, then the substitution has no effect.  Context          invariance shows that Γ,y:U,y:T[11] and Γ,y:T[11] are
             equivalent.  Since t[0] : T[12] under the former context,           this is also the case under the latter. *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](Records.html#STLCExtendedRecords.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) y x)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x ≠ y, then the IH and context invariance allow           us to show that
               Γ,x:U,y:T[11] ⊢ t[0] : T[12]       =>            Γ,y:T[11],x:U ⊢ t[0]
    : T[12]       =>            Γ,y:T[11] ⊢ [x:=v]t[0] : T[12] *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt. eapply [context_invariance](Records.html#STLCExtendedRecords.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y z)...
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* trcons *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... inversion H[7];
    subst; simpl...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem preservation : ∀t t'' T,'
  prefs: []
  type: TYPE_NORMAL
- en: '[empty](Maps.html#empty) ⊢ [t](Records.html#t) ∈ [T](Records.html#T)  →'
  prefs: []
  type: TYPE_NORMAL
- en: '[t](Records.html#t) ⇒ [t''](Records.html#t'')  →'
  prefs: []
  type: TYPE_NORMAL
- en: '[empty](Maps.html#empty) ⊢ [t''](Records.html#t'') ∈ [T](Records.html#T).'
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: intros t t' T HT.
  prefs: []
  type: TYPE_NORMAL
- en: '(* Theorem: If empty ⊢ t : T and t ⇒ t'', then       empty ⊢ t'' : T. *)'
  prefs: []
  type: TYPE_NORMAL
- en: remember (@[empty](Maps.html#empty) [ty](Records.html#STLCExtendedRecords.ty))
    as Γ. generalize dependent HeqGamma.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent t'.
  prefs: []
  type: TYPE_NORMAL
- en: (* Proof: By induction on the given typing derivation.        Many cases are contradictory (T_Var, T_Abs) or follow 
         directly from the IH (T_RCons).  We show just the       interesting ones. *)
  prefs: []
  type: TYPE_NORMAL
- en: induction HT;
  prefs: []
  type: TYPE_NORMAL
- en: intros t' HeqGamma HE; subst; inversion HE; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If the last rule used was T_App, then t = t[1] t[2],         and three rules could have been used to show t
    ⇒ t':         ST_App1, ST_App2, and ST_AppAbs. In the first two         cases, the result follows directly from the IH. *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion HE; subst...
  prefs: []
  type: TYPE_NORMAL
- en: + (* ST_AppAbs *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* For the third case, suppose            t[1] = tabs x T[11] t[12]          and
               t[2] = v[2].  We must show that empty ⊢ [x:=v[2]]t[12] : T[2].          We know by assumption that
                 empty ⊢ tabs x T[11] t[12] : T[1]→T[2]          and by inversion
                 x:T[1] ⊢ t[12] : T[2]          We have already proven that substitution_preserves_typing and
                 empty ⊢ v[2] : T[1]          by assumption, so we are done. *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [substitution_preserves_typing](Records.html#STLCExtendedRecords.substitution_preserves_typing)
    with T[1]...
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT[1]...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Proj *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If the last rule was T_Proj, then t = tproj t[1] i.          Two rules could have caused t
    ⇒ t': T_Proj1 and         T_ProjRcd.  The typing of t' follows from the IH         in the former case, so we only consider T_ProjRcd.
           Here we have that t is a record value.  Since rule         T_Proj was used, we know empty
    ⊢ t ∈ Tr and         Tlookup i Tr = Some Ti for some i and Tr.          We may therefore apply lemma lookup_field_in_value 
           to find the record element this projection steps to. *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([lookup_field_in_value](Records.html#STLCExtendedRecords.lookup_field_in_value)
    _ _ _ _ H[2] HT H)
  prefs: []
  type: TYPE_NORMAL
- en: as [vi [Hget Htyp]].
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H[4] in Hget. inversion Hget. subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If the last rule was T_RCons, then t = trcons i t tr         for some i, t and tr such that record_tm
    tr.  If         the step is by ST_Rcd_Head, the result is immediate by         the IH.  If the step is by ST_Rcd_Tail, tr
    ⇒ tr[2]'         for some tr[2]' and we must also use lemma step_preserves_record_tm 
           to show record_tm tr[2]'. *)
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_RCons](Records.html#STLCExtendedRecords.T_RCons)... eapply [step_preserves_record_tm](Records.html#STLCExtendedRecords.step_preserves_record_tm)...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: End STLCExtendedRecords.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
