- en: Using curl
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 curl
- en: Using curl
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 curl
- en: Previous chapters have described some basic details on what curl is and something
    about the basic command lines. You use command-line options and you pass on URLs
    to work with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的章节描述了 curl 的一些基本细节以及有关基本命令行的一些内容。您使用命令行选项，并传递要处理的 URL。
- en: In this chapter, we are going to dive deeper into a variety of different concepts
    of what curl can do and how to tell curl to use these features. You should consider
    all these features as different tools that are here to help you do your file transfer
    tasks as conveniently as possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将深入探讨 curl 能够做什么以及如何告诉 curl 使用这些功能的各种不同概念。您应该将所有这些功能都视为不同的工具，这些工具可以帮助您尽可能方便地执行文件传输任务。
- en: Supported protocols
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的协议
- en: curl supports or can be made to support (if built so) the following protocols.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: curl 支持或可以支持（如果构建）以下协议。
- en: DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3,
    POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMTP, SMTPS, TELNET and TFTP
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: DICT、FILE、FTP、FTPS、GOPHER、HTTP、HTTPS、IMAP、IMAPS、LDAP、LDAPS、POP3、POP3S、RTMP、RTSP、SCP、SFTP、SMB、SMTP、SMTPS、TELNET
    和 TFTP
- en: Verbose
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细
- en: Verbose mode
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细模式
- en: If your curl command doesn't execute or return what you expected it to, your
    first gut reaction should always be to run the command with the `-v / --verbose`
    option to get more information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 curl 命令未执行或未返回您期望的结果，您的第一反应应该始终是使用 `-v / --verbose` 选项运行命令以获取更多信息。
- en: 'When verbose mode is enabled, curl gets more talkative and will explain and
    show a lot more of its doings. It will add informational tests and prefix them
    with ''*''. For example, let''s see what curl might say when trying a simple HTTP
    example (saving the downloaded data in the file called ''saved''):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 启用详细模式时，curl 会变得更健谈，并会解释和显示更多的操作。它将添加信息性测试，并用 '*' 前缀标记它们。例如，让我们看看在尝试一个简单的 HTTP
    示例时 curl 可能会说些什么（将下载的数据保存在名为 'saved' 的文件中）：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ok so we invoked curl with a URL that it considers incomplete so it helps us
    and it adds a trailing slash before it moves on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Ok，所以我们使用一个 URL 调用 curl，它认为这个 URL 不完整，所以它帮助我们，在移动之前在其后添加一个尾随斜杠。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This tells us curl now tries to connect to this IP address. It means the name
    'example.com' has been resolved to one or more addresses and this is the first
    (and possibly only) address curl will try to connect to.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 curl 现在尝试连接到这个 IP 地址。这意味着名称 'example.com' 已经解析为一个或多个地址，这是 curl 将尝试连接的第一个（可能是唯一的）地址。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It worked! curl connected to the site and here it explains how the name maps
    to the IP address and on which port it has connected to. The '(#0)' part is which
    internal number curl has given this connection. If you try multiple URLs in the
    same command line you can see it use more connections or reuse connections, so
    the connection counter may increase or not increase depending on what curl decides
    it needs to do.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！curl 连接到了站点，这里解释了名称是如何映射到 IP 地址上以及它连接到了哪个端口。'(＃0)' 部分是 curl 给这个连接分配的内部编号。如果您在同一条命令行中尝试多个
    URL，您可以看到它使用更多的连接或重复使用连接，因此连接计数器可能会增加或不增加，这取决于 curl 决定需要做什么。
- en: If we use an HTTPS:// URL instead of an HTTP one, there will also be a whole
    bunch of lines explaining how curl uses CA certs to verify the server's certificate
    and some details from the server's certificate, etc. Including which ciphers were
    selected and more TLS details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 HTTPS:// URL 而不是 HTTP，还将有一大堆行解释 curl 如何使用 CA 证书来验证服务器的证书以及来自服务器证书的一些详细信息等。包括选择了哪些密码以及更多的
    TLS 详细信息。
- en: In addition to the added information given from curl internals, the -v verbose
    mode will also make curl show all headers it sends and receives. For protocols
    without headers (like FTP, SMTP, POP3 and so on), we can consider commands and
    responses as headers and they will thus also be shown with -v.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从 curl 内部添加的信息外，-v 详细模式还将使 curl 显示它发送和接收的所有标头。对于没有标头的协议（如 FTP、SMTP、POP3 等），我们可以将命令和响应视为标头，因此它们也将在
    -v 中显示。
- en: 'If we then continue the output seen from the command above (but ignore the
    actual HTML response), curl will show:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续上面命令看到的输出（但忽略实际的 HTML 响应），curl 将显示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the full HTTP request to the site. This request is how it looks in a
    default curl 7.45.0 installation and it may, of course, differ slightly between
    different releases and in particular it will change if you add command line options.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是发送到站点的完整 HTTP 请求。此请求在默认 curl 7.45.0 安装中的样子，当然，它可能在不同的发布版本之间略有不同，特别是如果您添加了命令行选项，它将发生变化。
- en: The last line of the HTTP request headers looks empty, and it is. It signals
    the separation between the headers and the body, and in this request there is
    no "body" to send.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求标头的最后一行是空的，确实如此。它表示标头和主体之间的分隔，在此请求中没有要发送的 "主体"。
- en: 'Moving on and assuming everything goes according to plan, the sent request
    will get a corresponding response from the server and that HTTP response will
    start with a set of headers before the response body:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接着假设一切顺利进行，发送的请求将会从服务器获得相应，并且 HTTP 响应在响应体之前会以一组标头开始：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This may look mostly like mumbo jumbo to you, but this is normal set of HTTP
    headers—metadata—about the response. The first line's "200" might be the most
    important piece of information in there and means "everything is fine".
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对你来说，这可能大部分看起来像胡言乱语，但这是关于响应的一组正常的 HTTP 标头元数据。第一行的 "200" 可能是其中最重要的信息，表示 "一切正常"。
- en: The last line of the received headers is, as you can see, empty, and that is
    the marker used for the HTTP protocol to signal the end of the headers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 收到的标头的最后一行是空的，正如你所见，这是 HTTP 协议用来标志标头结束的标记。
- en: After the headers comes the actual response body, the data payload. The regular
    -v verbose mode does not show that data but only displays
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在标头之后就是实际的响应体，即数据有效载荷。常规的 -v 详细模式不会显示该数据，只显示
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That 1270 bytes should then be in the ''saved'' file. You can also see that
    there was a header named Content-Length: in the response that contained the exact
    file length (it won''t always be present in responses).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那 1270 字节应该在 'saved' 文件中。你还可以看到响应中有一个名为 Content-Length 的头，其中包含确切的文件长度（它不会总是出现在响应中）。
- en: --trace and --trace-ascii
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --trace 和 --trace-ascii
- en: There are times when `-v` is not enough. In particular, when you want to store
    the complete stream including the actual transferred data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候 `-v` 是不够的。特别是当你想要存储完整的流，包括实际传输的数据时。
- en: For situations when curl does encrypted file transfers with protocols such as
    HTTPS, FTPS or SFTP, other network monitoring tools (like Wireshark or tcpdump)
    won't be able to do this job as easily for you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 HTTPS、FTPS 或 SFTP 等协议进行加密文件传输的情况，其他网络监控工具（如 Wireshark 或 tcpdump）将无法像此工具那样轻松地为您执行此任务。
- en: For this, curl offers two other options that you use instead of `-v`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对此，curl 提供了另外两个选项，你可以使用它们代替 `-v`。
- en: '`--trace [filename]` will save a full trace in the given file name. You can
    also use ''-'' (a single minus) instead of a file name to get it passed to stdout.
    You would use it like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`--trace [filename]` 将在给定的文件名中保存完整的跟踪。你也可以使用 ''-''（一个减号）代替文件名，将其传递到标准输出。你可以像这样使用它：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When completed, there''s a ''dump'' file that can turn out pretty sizable.
    In this case, the 15 first lines of the dump file looks like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，会有一个 'dump' 文件，它可能相当大。在这种情况下，转储文件的前 15 行看起来是这样的：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Every single sent and received byte get displayed individually in hexadecimal
    numbers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个发送和接收的字节都以十六进制数单独显示。
- en: 'If you think the hexadecimals aren''t helping, you can try `--trace-ascii [filename]`
    instead, also this accepting ''-'' for stdout and that makes the 15 first lines
    of tracing look like:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得十六进制并没有帮助，你可以尝试使用 `--trace-ascii [filename]`，同时也接受使用 '-' 表示标准输出，这样跟踪的前
    15 行看起来会是这样的：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: --trace-time
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --trace-time
- en: This options prefixes all verbose/trace outputs with a high resolution timer
    for when the line is printed. It works with the regular `-v / --verbose` option
    as well as with `--trace` and `--trace-ascii`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项将所有详细/跟踪输出的每一行都以高分辨率计时器作为前缀，用于打印行时。它与常规的 `-v / --verbose` 选项以及 `--trace`
    和 `--trace-ascii` 一样有效。
- en: 'An example could look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是这样的：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The lines are all the local time as hours:minutes:seconds and then number of
    microseconds in that second.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有行都是本地时间，格式为小时：分钟：秒，然后是该秒内的微秒数。
- en: HTTP/2
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP/2
- en: When doing file transfers using version two of the HTTP protocol, HTTP/2, curl
    sends and receives **compressed** headers. So to display outgoing and incoming
    HTTP/2 headers in a readable and understandable way, curl will actually show the
    uncompressed versions in a style similar to how they appear with HTTP/1.1.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 HTTP 协议的第二个版本，HTTP/2 进行文件传输时，curl 发送和接收 **压缩** 标头。因此，为了以可读和可理解的方式显示出站和入站的
    HTTP/2 标头，curl 实际上会显示未压缩版本，样式类似于 HTTP/1.1。
- en: --write-out
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --write-out
- en: This is one of the often forgotten little gems in the curl arsenal of command
    line options. `--write-out` or just `-w` for short, writes out information after
    a transfer has completed and it has a large range of variables that you can include
    in the output, variables that have been set with values and information from the
    transfer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 curl 命令行选项库中经常被遗忘的一项宝藏之一。`--write-out` 或简写为 `-w`，在传输完成后输出信息，它具有一系列大量的变量，您可以在输出中包含这些变量，这些变量已经被设置为来自传输的值和信息。
- en: 'You tell curl to write a string just by passing that string to this option:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将该字符串传递给此选项，您可以告诉 curl 写入一个字符串：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '…and you can also have curl read that string from a given file instead if you
    prefix the string with ''@'':'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: …而且，如果你在字符串前加上 '@'，你还可以让 curl 从给定文件中读取该字符串：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '…or even have curl read the string from stdin if you use ''-'' as filename:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: …或者甚至让 curl 从标准输入读取字符串，如果您将文件名指定为 '-'：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The variables that are available are accessed by writing `%{variable_name}`
    in the string and that variable will then be substituted by the correct value.
    To output a normal '%' you just write it as '%%'. You can also output a newline
    by using '\n', a carriage return with '\r' and a tab space with '\t'.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过在字符串中写入 `%{variable_name}` 来访问可用的变量，然后该变量将被正确的值替换。要输出普通的 '%'，只需将其写为 '%%'。您还可以通过使用
    '\n' 输出换行符，使用 '\r' 输出回车符，使用 '\t' 输出制表符。
- en: (The %-symbol is special on the Windows command line, where all occurrences
    of % must be doubled when using this option.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: （在 Windows 命令行上，'%' 符号是特殊字符，在使用该选项时，所有出现的 % 必须加倍。）
- en: 'As an example, we can output the Content-Type and the response code from an
    HTTP transfer, separated with newlines and some extra text like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以输出 HTTP 传输的 Content-Type 和响应代码，用换行符和一些额外的文本分隔，如下所示：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This feature writes the output to stdout so you probably want to make sure that
    you don't also send the downloaded content to stdout as then you might have a
    hard time to separate out the data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能将输出写入 stdout，因此您可能希望确保您不将下载的内容也发送到 stdout，否则您可能很难分离数据。
- en: Available --write-out variables
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可用的 --write-out 变量
- en: Some of these variables are not available in really old curl versions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些变量在非常旧的 curl 版本中不可用。
- en: '%{content_type} shows the Content-Type of the requested document, if there
    was any.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{content_type} 显示请求文档的 Content-Type（如果有的话）。'
- en: '%{filename_effective} shows the ultimate filename that curl writes out to.
    This is only meaningful if curl is told to write to a file with the `--remote-name`
    or `--output` option. It''s most useful in combination with the `--remote-header-name`
    option.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{filename_effective} 显示 curl 写出的最终文件名。只有在 curl 被告知使用 `--remote-name` 或 `--output`
    选项写入文件时，这才有意义。与 `--remote-header-name` 选项结合使用时最有用。'
- en: '%{ftp_entry_path} shows the initial path curl ended up in when logging on to
    the remote FTP server.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{ftp_entry_path} 显示 curl 登录到远程 FTP 服务器时所处的初始路径。'
- en: '%{response_code} shows the numerical response code that was found in the last
    transfer.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{response_code} 显示在最后一次传输中找到的数字响应代码。'
- en: '%{http_connect} shows the numerical code that was found in the last response
    (from a proxy) to a curl CONNECT request.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{http_connect} 显示在 curl CONNECT 请求的最后响应（来自代理）中找到的数字代码。'
- en: '%{local_ip} shows the IP address of the local end of the most recently done
    connection—can be either IPv4 or IPv6'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{local_ip} 显示最近完成的连接的本地端 IP 地址，可以是 IPv4 或 IPv6'
- en: '%{local_port} shows the local port number of the most recently made connection'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{local_port} 显示最近建立连接的本地端口号'
- en: '%{num_connects} shows the number of new connects made in the recent transfer.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{num_connects} 显示最近传输中进行的新连接数。'
- en: '%{num_redirects} shows the number of redirects that were followed in the request.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{num_redirects} 显示请求中遵循的重定向数量。'
- en: '%{redirect_url} shows the actual URL a redirect *would* take you to when an
    HTTP request was made without `-L` to follow redirects.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{redirect_url} 显示在没有 `-L` 跟随重定向时，HTTP 请求实际上会将您重定向到的 URL。'
- en: '%{remote_ip} shows the remote IP address of the most recently made connection—can
    be either IPv4 or IPv6.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{remote_ip} 显示最近建立连接的远程 IP 地址，可以是 IPv4 或 IPv6。'
- en: '%{remote_port} shows the remote port number of the most recently made connection.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{remote_port} 显示最近建立连接的远程端口号。'
- en: '%{size_download} shows the total number of bytes that were downloaded.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{size_download} 显示已下载的总字节数。'
- en: '%{size_header} shows the total number of bytes of the downloaded headers.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{size_header} 显示已下载标头的总字节数。'
- en: '%{size_request} shows the total number of bytes that were sent in the HTTP
    request.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{size_request} 显示了在 HTTP 请求中发送的总字节数。'
- en: '%{size_upload} shows the total number of bytes that were uploaded.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{size_upload} 显示了上传的总字节数。'
- en: '%{speed_download} shows the average download speed that curl measured for the
    complete download in bytes per second.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{speed_download} 显示了 curl 测量的完成下载的平均下载速度（以字节每秒为单位）。'
- en: '%{speed_upload} shows the average upload speed that curl measured for the complete
    upload in bytes per second.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{speed_upload} 显示了 curl 测量的完成上传的平均上传速度（以字节每秒为单位）。'
- en: '%{ssl_verify_result} shows the result of the SSL peer certificate verification
    that was requested. 0 means the verification was successful.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{ssl_verify_result} 显示了请求的 SSL 对等证书验证结果。0 表示验证成功。'
- en: '%{time_appconnect} shows the time, in seconds, it took from the start until
    the SSL/SSH/etc connect/handshake to the remote host was completed.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{time_appconnect} 显示了从开始到 SSL/SSH 等连接/握手到远程主机完成的时间（以秒为单位）。'
- en: '%{time_connect} shows the time, in seconds, it took from the start until the
    TCP connect to the remote host (or proxy) was completed.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{time_connect} 显示了从开始到 TCP 连接到远程主机（或代理）完成所花费的时间（以秒为单位）。'
- en: '%{time_namelookup} shows the time, in seconds, it took from the start until
    the name resolving was completed.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{time_namelookup} 显示了从开始到名称解析完成所花费的时间（以秒为单位）。'
- en: '%{time_pretransfer} shows the time, in seconds, it took from the start until
    the file transfer was just about to begin. This includes all pre-transfer commands
    and negotiations that are specific to the particular protocol(s) involved.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{time_pretransfer} 显示了从开始到文件传输即将开始所花费的时间（以秒为单位）。这包括与涉及的特定协议相关的所有预传输命令和协商。'
- en: '%{time_redirect} shows the time, in seconds, it took for all redirection steps
    including name lookup, connect, pre-transfer and transfer before the final transaction
    was started. time_redirect shows the complete execution time for multiple redirections.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{time_redirect} 显示了所有重定向步骤的时间（包括名称查找、连接、预传输和传输），直到最终事务开始的时间（以秒为单位）。time_redirect
    显示了多次重定向的完整执行时间。'
- en: '%{time_starttransfer} shows the time, in seconds, it took from the start until
    the first byte was just about to be transferred. This includes time_pretransfer
    and also the time the server needed to calculate the result.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{time_starttransfer} 显示了从开始到第一个字节即将传输的时间（以秒为单位）。这包括 time_pretransfer，以及服务器计算结果所需的时间。'
- en: '%{time_total} shows the total time, in seconds, that the full operation lasted.
    The time will be displayed with millisecond resolution.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{time_total} 显示了完整操作持续的总时间（以秒为单位）。时间将以毫秒分辨率显示。'
- en: '%{url_effective} shows the URL that was fetched last. This is particularly
    meaningful if you have told curl to follow Location: headers (with `-L`).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%{url_effective} 显示了最后获取的 URL。如果您已经告诉 curl 跟随 Location: 标头（使用 `-L` 参数），这将特别有意义。'
- en: Silence
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沉默
- en: The opposite of verbose is, of course, to make curl more silent. With the `-s`
    (or `--silent`) option you make curl switch off the progress meter and not output
    any error messages for when errors occur. It gets mute. It will still output the
    downloaded data you ask it to.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与冗长相反，当然也可以让 curl 更加沉默。使用 `-s`（或 `--silent`）选项，您可以让 curl 关闭进度条，并且不输出任何错误消息（当发生错误时）。它会变得静音。它仍然会输出您要求的已下载数据。
- en: With silence activated, you can ask for it to still output the error message
    on failures by adding `-S` or `--show-error`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用激活沉默状态，您可以要求在失败时仍然输出错误消息，方法是添加 `-S` 或 `--show-error`。
- en: Persistent connections
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久连接
- en: Persistent connections
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久连接
- en: When setting up TCP connections to sites, curl will keep the old connection
    around for a while so that if the next transfer is to the same host it can reuse
    the same connection again and thus save a lot of time. We call this persistent
    connections. curl will always try to keep connections alive and reuse existing
    connections as far as it can.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置 TCP 连接到站点时，curl 会保持旧连接一段时间，以便如果下一个传输是到同一主机，则可以再次重用相同的连接，从而节省大量时间。我们称之为持久连接。curl
    将始终尝试保持连接活动，并尽可能重用现有连接。
- en: The curl command-line tool can, however, only keep connections alive for as
    long as it runs, so as soon as it exits back to your command line it has to close
    down all currently open connections (and also free and clean up all the other
    caches it uses to decrease time of subsequent operations). We call the pool of
    alive connections the "connection cache".
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，curl 命令行工具只能在运行时保持连接处于活动状态，所以一旦退出回到你的命令行，它就必须关闭所有当前打开的连接（并且释放和清理它用来减少后续操作时间的所有其他缓存）。我们将活动连接池称为"连接缓存"。
- en: If you want to perform N transfers or operations against the same host or same
    base URL, you could gain a lot of speed by trying to do them in as few curl command
    lines as possible instead of repeatedly invoking curl with one URL at a time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对同一主机或同一基本 URL 执行 N 次传输或操作，那么尽量用尽可能少的 curl 命令行来尝试它们，而不是反复使用一个 URL 调用 curl。
- en: Downloads
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载
- en: Downloads
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载
- en: '"Download" means getting data from a server on a network, and the server is
    then clearly considered to be "above" you. This is loading data down from the
    server onto your machine where you are running curl.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '"下载" 意味着从网络上的服务器获取数据，服务器显然被认为是"在上面"。这是从服务器加载数据到你正在运行 curl 的机器上。'
- en: Downloading is probably the most common use case for curl—retrieving the specific
    data pointed to by a URL onto your machine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下载可能是 curl 的最常见用法 —— 将 URL 指向的特定数据下载到你的计算机上。
- en: What exactly is downloading?
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 到底是什么在下载？
- en: 'You specify the resource to download by giving curl a URL. curl defaults to
    downloading a URL unless told otherwise, and the URL identifies what to download.
    In this example the URL to download is "[http://example.com](http://example.com)":'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过给 curl 一个 URL 来指定要下载的资源。curl 默认会下载一个 URL，除非另有指示，而 URL 标识了要下载的内容。在这个例子中，要下载的
    URL 是 "[http://example.com](http://example.com)"：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The URL is broken down into its individual components ([as explained elsewhere](cmdline-urls.html)),
    the correct server is contacted and is then asked to deliver the specific resource—often
    a file. The server then delivers the data, or it refuses or perhaps the client
    asked for the wrong data and then that data is delivered.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: URL 被分解为其各个组件（[如其他地方所述](cmdline-urls.html)），正确的服务器被联系，然后被要求传送特定资源 —— 通常是一个文件。然后服务器传送数据，或者拒绝，或者客户端请求错误的数据，然后交付该数据。
- en: A request for a resource is protocol-specific so a FTP:// URL works differently
    than an HTTP:// URL or an SFTP:// URL.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对资源的请求是协议特定的，因此 FTP:// URL 的工作方式与 HTTP:// URL 或 SFTP:// URL 不同。
- en: A URL without a path part, that is a URL that has a host name part only (like
    the "[http://example.com](http://example.com)" example above) will get a slash
    ('/') appended to it internally and then that is the resource curl will ask for
    from the server.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有路径部分的 URL，即只有主机名部分的 URL（就像上面的 "[http://example.com](http://example.com)" 示例），将在内部附加一个斜杠('/')，然后这就是
    curl 将要从服务器请求的资源。
- en: If you specify multiple URLs on the command line, curl will download each URL
    one by one. It won't start the second transfer until the first one is complete,
    etc.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行上指定了多个 URL，curl 将逐个下载每个 URL。它不会在第一个传输完成之前开始第二个传输，以此类推。
- en: Storing downloads
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储下载
- en: If you try the example download as in the previous section, you will notice
    that curl will output the downloaded data to stdout unless told to do something
    else. Outputting data to stdout is really useful when you want to pipe it into
    another program or similar, but it is not always the optimal way to deal with
    your downloads.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试像上一节那样执行示例下载，你会注意到 curl 会将下载的数据输出到 stdout，除非被告知做其他事情。将数据输出到 stdout 在你想要将其导入到另一个程序或类似情况时非常有用，但这并不总是处理下载的最佳方式。
- en: Give curl a specific file name to save the download in with `-o [filename]`
    (with `--output` as the long version of the option), where filename is either
    just a file name, a relative path to a file name or a full path to the file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 给 curl 一个特定的文件名来保存下载内容，使用 `-o [filename]`（`--output` 是该选项的长版本），其中 filename 可以是文件名、相对路径到文件名或文件的完整路径。
- en: 'Also note that you can put the `-o` before or after the URL; it makes no difference:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，你可以将 `-o` 放在 URL 之前或之后；这没有区别：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is, of course, not limited to http:// URLs but works the same way no matter
    which type of URL you download:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不仅限于 http:// URL，无论你下载哪种类型的 URL，它都以相同的方式工作：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you ask curl to send the output to the terminal, it attempts to detect and
    prevent binary data from being sent there since that can seriously mess up your
    terminal (sometimes to the point where it basically stops working). You can override
    curl's binary-output-prevention and force the output to get sent to stdout by
    using `-o -`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要求 curl 将输出发送到终端，它会尝试检测并阻止二进制数据发送到那里，因为那可能严重破坏你的终端（有时甚至会导致终端基本停止工作）。你可以通过使用`-o
    -`来覆盖 curl 的二进制输出防止机制，并强制输出发送到标准输出。
- en: curl has several other ways to store and name the downloaded data. Details follow!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: curl 有几种其他存储和命名下载数据的方式。详情见下文！
- en: Download to a file named by the URL
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载到由 URL 命名的文件
- en: 'Many URLs, however, already contain the file name part in the rightmost end.
    curl lets you use that as a shortcut so you don''t have to repeat it with `-o`.
    So instead of:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多 URL 已经包含了右端的文件名部分。curl 允许你使用这个作为快捷方式，所以你不必用 `-o` 重复它。所以，不是：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can save the remove URL resource into the local file ''file.html'' with
    this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下方式将远程 URL 资源保存到本地文件'file.html'中：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the `-O` (uppercase letter o) option, or `--remote-name` for the long
    name version. The -O option selects the local file name to use by picking the
    file name part of the URL that you provide. This is important. You specify the
    URL and curl picks the name from this data. If the site redirects curl further
    (and if you tell curl to follow redirects), it doesn't change the file name curl
    will use for storing this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `-O`（大写字母 o）选项，或者长名称版本的 `--remote-name`。-O 选项通过选择你提供的 URL 的文件名部分来选择本地文件名。这很重要。你指定
    URL，curl 从这个数据中选择名称。如果网站进一步重定向 curl（如果你告诉 curl 跟随重定向），它不会更改 curl 用于存储此数据的文件名。
- en: Get the target file name from the server
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从服务器获取目标文件名
- en: HTTP servers have the option to provide a header named `Content-Disposition:`
    in responses. That header may contain a suggested file name for the contents delivered,
    and curl can be told to use that hint to name its local file. The `-J / --remote-header-name`
    enables this. If you also use the `-O` option, it makes curl use the file name
    from the URL by default and only *if* there's actually a valid Content-Disposition
    header available, it switches to saving using that name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器在响应中提供了一个名为`Content-Disposition:`的头部选项。该头部可能包含一个建议的文件名，用于传送内容，并且 curl
    可以被告知使用该提示来命名其本地文件。`-J / --remote-header-name`启用了这个选项。如果你还使用了`-O`选项，它会让 curl 默认使用
    URL 中的文件名，并且*仅在*确实有有效的 Content-Disposition 头部可用时，才切换到使用该名称保存。
- en: '-J has some problems and risks associated with it that users need to be aware
    of:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: -J 有一些与之相关的问题和风险，用户需要注意：
- en: It will only use the rightmost part of the suggested file name, so any path
    or directories the server suggests will be stripped out.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将只使用建议文件名的最右端部分，因此服务器建议的任何路径或目录都将被剥离。
- en: Since the file name is entirely selected by the server, curl will, of course,
    overwrite any preexisting local file in your current directory if the server happens
    to provide such a file name.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于文件名完全由服务器选择，如果服务器提供了这样的文件名，curl 当然会覆盖当前目录中的任何现有本地文件。
- en: File name encoding and character sets issues. curl does not decode the name
    in any way, so you may end up with a URL-encoded file name where a browser would
    otherwise decode it to something more readable using a sensible character set.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件名编码和字符集问题。curl 不以任何方式解码名称，所以你可能会得到一个 URL 编码的文件名，而浏览器否则会使用合理的字符集将其解码为更可读的东西。
- en: HTML and charsets
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML 和字符集
- en: curl will download the exact binary data that the server sends. This might be
    of importance to you in case, for example, you download a HTML page or other text
    data that uses a certain character encoding that your browser then displays as
    expected. curl will then not translate the arriving data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: curl 将下载服务器发送的确切二进制数据。这对你可能很重要，例如，你下载一个 HTML 页面或其他文本数据，该数据使用特定的字符编码，然后你的浏览器按预期显示。curl
    将不会转换到达的数据。
- en: 'A common example where this causes some surprising results is when a user downloads
    a web page with something like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子，这会导致一些令人惊讶的结果，是当用户下载一个网页，比如：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: …and when inspecting the `storage.html` file after the fact, the user realizes
    that one or more characters look funny or downright wrong. This can then very
    well be because the server sent the characters using charset X, while your editor
    and environment use charset Y. In an ideal world, we would all use UTF-8 everywhere
    but unfortunately, that is still not the case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: …当事后检查 `storage.html` 文件时，用户意识到一个或多个字符看起来很奇怪或者完全错误。这很可能是因为服务器使用字符集 X 发送了字符，而你的编辑器和环境使用字符集
    Y。在理想的情况下，我们都应该在所有地方使用 UTF-8，但不幸的是，情况仍然没有改变。
- en: A common work-around for this issue that works decently is to use the common
    `iconv` utility to translate a text file to and from different charsets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的解决方法是使用常见的 `iconv` 实用程序将文本文件在不同字符集之间进行转换。
- en: Compression
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩
- en: curl allows you to ask HTTP and HTTPS servers to provide compressed versions
    of the data and then perform automatic decompression of it on arrival. In situations
    where bandwidth is more limited than CPU this will help you receive more data
    in a shorter amount of time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: curl 允许你要求 HTTP 和 HTTPS 服务器提供数据的压缩版本，然后在到达时对其进行自动解压缩。在带宽比 CPU 更有限的情况下，这将帮助你在更短的时间内接收更多的数据。
- en: 'HTTP compression can be done using two different mechanisms, one which might
    be considered "The Right Way" and the other that is the way that everyone actually
    uses and is the widespread and popular way to do it! The common way to compress
    HTTP content is using the **Content-Encoding** header. You ask curl to use this
    with the `--compressed` option:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 压缩可以使用两种不同的机制来完成，一种可能被认为是“正确的方式”，另一种是每个人实际使用的方式，也是普遍和流行的方式！压缩 HTTP 内容的常见方式是使用
    **Content-Encoding** 头。你可以让 curl 使用 `--compressed` 选项来使用它：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this option enabled (and if the server supports it) it delivers the data
    in a compressed way and curl will decompress it before saving it or sending it
    to stdout. This usually means that as a user you don't really see or experience
    the compression other than possibly noticing a faster transfer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此选项（如果服务器支持）会以压缩方式传送数据，curl 将在保存或发送到 stdout 之前对其进行解压缩。这通常意味着作为用户，你实际上并没有看到或体验到压缩，除非可能注意到传输速度更快。
- en: 'The `--compressed` option asks for Content-Encoding compression using one of
    the supported compression algorithms. There''s also the rarer **Transfer-Encoding**
    method, which is the header that was created for this automated method but was
    never really widely adopted. You can tell curl to ask for Transfer-Encoded compression
    with `--tr-encoding`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`--compressed` 选项请求使用受支持的压缩算法进行 Content-Encoding 压缩。还有更罕见的 **Transfer-Encoding**
    方法，这是为这种自动化方法创建的标头，但实际上从未真正被广泛采用。你可以告诉 curl 使用 `--tr-encoding` 来请求 Transfer-Encoded
    压缩：'
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In theory, there's nothing that prevents you from using both in the same command
    line, although in practice, you may then experience that some servers get a little
    confused when ask to compress in two different ways. It's generally safer to just
    pick one.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以在同一命令行中同时使用两种方式，但在实践中，你可能会发现一些服务器在被要求以两种不同方式压缩时会有些混乱。通常最安全的做法是选择其中一种。
- en: Shell redirects
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell 重定向
- en: When you invoke curl from a shell or some other command-line prompt system,
    that environment generally provides you with a set of output redirection abilities.
    In most Linux and Unix shells and with Windows' command prompts, you direct stdout
    to a file with `> filename`. Using this, of course, makes the use of -o or -O
    superfluous.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从 shell 或其他命令行提示系统调用 curl 时，该环境通常会为你提供一组输出重定向功能。在大多数 Linux 和 Unix shell 中，以及
    Windows 的命令提示符中，你可以使用 `> filename` 将 stdout 重定向到文件。当然，使用这种方法使得使用 -o 或 -O 成为多余。
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Redirecting output to a file redirects all output from curl to that file, so
    even if you ask to transfer more than one URL to stdout, redirecting the output
    will get all the URLs' output stored in that single file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出重定向到文件会将 curl 的所有输出都重定向到该文件，因此，即使你要求将多个 URL 传输到 stdout，重定向输出也会将所有 URL 的输出存储在单个文件中。
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unix shells usually allow you to redirect the *stderr* stream separately. The
    stderr stream is usually a stream that also gets shown in the terminal, but you
    can redirect it separately from the stdout stream. The stdout stream is for the
    data while stderr is metadata and errors, etc., that aren''t data. You can redirect
    stderr with `2>file` like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Unix shell 通常允许你单独重定向 *stderr* 流。stderr 流通常是在终端中显示的流，但你可以将其与 stdout 流分开重定向。stdout
    流用于数据，而 stderr 是元数据和错误等，并非数据。你可以像这样使用 `2>file` 重定向 stderr：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Multiple downloads
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个下载
- en: As curl can be told to download many URLs in a single command line, there are,
    of course, times when you want to store these downloads in nicely-named local
    files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 curl 可以在单个命令行中告知下载许多 URL，当然也有时候您希望将这些下载存储在命名合理的本地文件中。
- en: 'The key to understanding this is that each download URL needs its own "storage
    instruction". Without said "storage instruction", curl will default to sending
    the data to stdout. If you ask for two URLs and only tell curl where to save the
    first URL, the second one is sent to stdout. Like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点的关键是每个下载 URL 都需要自己的“存储指令”。如果没有这样的“存储指令”，curl 将默认将数据发送到标准输出。如果您请求两个 URL
    并且只告诉 curl 如何保存第一个 URL，那么第二个 URL 就会发送到标准输出。就像这样：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The "storage instructions" are read and handled in the same order as the download
    URLs so they don't have to be next to the URL in any way. You can round up all
    the output options first, last or interleaved with the URLs. You choose!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: “存储指令”按照下载 URL 的顺序读取和处理，因此它们不必与 URL 相邻。您可以首先、最后或与 URL 交错地收集所有输出选项。由您决定！
- en: 'These examples all work the same way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例都是相同的工作方式：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `-O` is similarly just an instruction for a single download so if you download
    multiple URLs, use more of them:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`-O` 同样只是针对单个下载的指令，因此如果您下载多个 URL，请使用更多：'
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use the URL's file name part for all URLs
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对所有 URL 使用 URL 的文件名部分
- en: As a reaction to adding a hundred `-O` options when using a hundred URLs, we
    introduced an option called `--remote-name-all`. This makes `-O` the default operation
    for all given URLs. You can still provide individual "storage instructions" for
    URLs but if you leave one out for a URL that gets downloaded, the default action
    is then switched from stdout to -O style.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对在使用一百个 URL 时添加一百个 `-O` 选项的情况，我们引入了一个称为 `--remote-name-all` 的选项。这使 `-O` 成为所有给定
    URL 的默认操作。您仍然可以为 URL 提供单独的“存储指令”，但是如果您在下载 URL 时没有提供其中一个的指令，那么默认操作就会从标准输出切换到 -O
    样式。
- en: '"My browser shows something else"'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “我的浏览器显示其他内容”
- en: A very common use case is using curl to get a URL that you can get in your browser
    when you paste the URL in the browser's address bar.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的用例是使用 curl 获取一个 URL，当您将 URL 粘贴到浏览器的地址栏中时，您可以在浏览器中获取该 URL。
- en: But a browser getting a URL does so much more and in so many different ways
    than curl that what curl shows in your terminal output is probably not at all
    what you see in your browser window.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但是浏览器获取 URL 的方式和 curl 完全不同，curl 在终端输出中显示的内容可能与您在浏览器窗口中看到的完全不同。
- en: Client differences
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 客户端差异
- en: Curl only gets exactly what you ask it to get and it never parses the actual
    content—the data—that the server delivers. A browser gets data and it activates
    different parsers depending on what kind of content it thinks it gets. For example,
    if the data is HTML it will parse it to display a web page and possibly download
    other sub resources such as images, JavaScript and CSS files. When curl downloads
    a HTML it will just get that single HTML resource, even if it, when parsed by
    a browser, would trigger a whole busload of more downloads. If you want curl to
    download any sub-resources as well, you need to pass those URLs to curl and ask
    it to get those, just like any other URLs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Curl 只会获取您要求获取的内容，它从不解析服务器传送的实际内容——数据。浏览器会获取数据并根据其认为获取的内容类型激活不同的解析器。例如，如果数据是
    HTML，浏览器将解析它以显示网页，并可能下载其他子资源，如图像、JavaScript 和 CSS 文件。当 curl 下载 HTML 时，它只会获取该单个
    HTML 资源，即使在浏览器解析时，它可能会触发大量其他下载。如果您希望 curl 也下载任何子资源，您需要将这些 URL 传递给 curl，并要求它获取这些资源，就像获取任何其他
    URL 一样。
- en: Clients also differ in how they send their requests, and some aspects of a request
    for a resource include, for example, format preferences, asking for compressed
    data, or just telling the server from which previous page we are "coming from".
    curl's requests will differ a little or a lot from how your browser sends its
    requests.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在发送请求时也有所不同，请求资源的一些方面包括格式偏好、请求压缩数据，或者只是告诉服务器我们是从哪个先前的页面“跳转”过来的。curl 的请求方式可能与您的浏览器发送请求的方式有很大差异。
- en: Server differences
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务器差异
- en: The server that receives the request and delivers data is often setup to act
    in certain ways depending on what kind of client it thinks communicates with it.
    Sometimes it is as innocent as trying to deliver the best content for the client,
    sometimes it is to hide some content for some clients or even to try to work around
    known problems in specific browsers. Then there's also, of course, various kind
    of login systems that might rely on HTTP authentication or cookies or the client
    being from the pre-validated IP address range.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接收请求并提供数据的服务器通常会根据它认为在与其通信的客户端的类型进行设置。有时候只是试图为客户端提供最佳内容，有时候是为了隐藏某些内容，有时甚至是为了尝试解决特定浏览器中已知的问题。当然，还有各种各样的登录系统，可能依赖于
    HTTP 认证、cookies 或客户端来自预验证的 IP 地址范围。
- en: Sometimes getting the same response from a server using curl as the response
    you get with a browser ends up really hard work. Users then typically record their
    browser sessions with the browser's networking tools and then compare that recording
    with recorded data from curl's `--trace-ascii` option and proceed to modify curl's
    requests (often with `-H / --header`) until the server starts to respond the same
    to both.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用 curl 从服务器得到与浏览器相同的响应是一项非常困难的工作。用户通常会使用浏览器的网络工具记录他们的浏览器会话，然后将该记录与 curl
    的 `--trace-ascii` 选项记录的数据进行比较，并开始修改 curl 的请求（通常是使用 `-H / --header`），直到服务器开始对两者都做出相同的响应为止。
- en: This type of work can be both time consuming and tedious. You should always
    do this with permission from the server owners or admins.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作可能既耗时又烦琐。你应该始终征得服务器所有者或管理员的许可。
- en: Intermediaries' fiddlings
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中介的操纵
- en: Intermediaries are proxies, explicit or implicit ones. Some environments will
    force you to use one or you may choose to use one for various reasons, but there
    are also the transparent ones that will intercept your network traffic silently
    and proxy it for you no matter what you want.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 中介是代理，明确或隐式的。有些环境会强制你使用一个，或者出于各种原因你可能选择使用一个，但也有透明的中介，它们会在你不知情的情况下截取你的网络流量并为你代理，不管你想要什么。
- en: Proxies are "middle men" that terminate the traffic and then act on your behalf
    to the remote server. This can introduce all sorts of explicit filtering and "saving"
    you from certain content or even "protecting" the remote server from what data
    you try to send to it, but even more so it introduces another software's view
    on how the protocol works and what the right things to do are.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是“中间人”，它终止流量然后代表你向远程服务器执行操作。这可能会引入各种显式的过滤，并“保存”你不希望访问的某些内容，甚至“保护”远程服务器免受你试图发送给它的数据的影响，但更重要的是，它引入了另一个软件对协议工作方式及正确操作的观点。
- en: Interfering intermediaries are often the cause of lots of head aches and mysteries
    down to downright malicious modifications of content.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 干扰性的中介往往是许多头痛和神秘的根源，甚至可能导致对内容进行明显恶意的修改。
- en: We strongly encourage you to use HTTPS or other means to verify that the contents
    you are downloading or uploading are really the data that the remote server has
    sent to you and that your precious bytes end up verbatim at the intended destination.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您使用 HTTPS 或其他手段验证您正在下载或上传的内容是否确实是远程服务器发送给您的数据，并且您宝贵的字节最终原样到达预期目的地。
- en: Rate limiting
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速率限制
- en: When curl transfers data, it will attempt to do that as fast as possible. It
    goes for both uploads and downloads. Exactly how fast that will be depends on
    several factors, including your computer's ability, your own network connection's
    bandwidth, the load on the remote server you are transferring to/from and the
    latency to that server. And your curl transfers are also likely to compete with
    other transfers on the networks the data travels over, from other users or just
    other apps by the same user.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当 curl 传输数据时，它会尽可能快地进行。这适用于上传和下载。实际传输速度取决于几个因素，包括您的计算机性能、您自己的网络连接带宽、您正在传输数据到/从的远程服务器的负载以及与该服务器的延迟。此外，您的
    curl 传输还可能与数据传输的网络上的其他传输竞争，这些传输可能来自其他用户或仅仅是同一用户的其他应用程序。
- en: In many setups, however, you will find that you can more or less saturate your
    own network connection with a single curl command line. If you have a 10 megabit
    per second connection to the Internet, chances are curl can use all of those 10
    megabits to transfer data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多设置中，您可能会发现您几乎可以使用单个 curl 命令行饱和您自己的网络连接。如果您的互联网连接速度为每秒 10 兆比特，那么 curl 可能会使用所有这
    10 兆比特来传输数据。
- en: For most use cases, using as much bandwidth as possible is a good thing. It
    makes the transfer faster, it makes the curl command complete sooner and it will
    make the transfer use resources from the server for a shorter period of time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用例来说，尽可能使用尽可能多的带宽是一件好事。它使传输更快，使 curl 命令更早完成，并且它将使传输在较短的时间内使用服务器资源。
- en: Sometimes you will, however, find that having curl starve out other network
    functions on your local network connection is inconvenient. In these situations
    you may want to tell curl to slow down so that other network users get a better
    chance to get their data through as well. With `--limit-rate [speed]` you can
    tell curl to not go faster than the given number of bytes per second. The rate
    limit value can be given with a letter suffix using one of K, M and G for kilobytes,
    megabytes and gigabytes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会发现，让 curl 在你的本地网络连接上饿死其他网络功能是不方便的。在这些情况下，你可能想告诉 curl 减慢速度，以便其他网络用户也有更好的机会通过。使用
    `--limit-rate [speed]` 可以告诉 curl 不要超过每秒给定的字节数。速率限制值可以用 K、M 和 G 中的一个字母后缀给出，分别表示千字节、兆字节和千兆字节。
- en: 'To make curl not download data any faster than 200 kilobytes per second:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 curl 下载数据不超过每秒 200 千字节：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The given limit is the maximum *average speed* allowed, counted during the entire
    transfer. It means that curl might use higher transfer speeds in short bursts,
    but over time it uses no more than the given rate.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的限制是在整个传输过程中允许的最大*平均速度*，在整个传输过程中计算。这意味着 curl 可能会在短时间内使用更高的传输速度，但随着时间的推移，它不会超过给定的速率。
- en: Also note that curl never knows what the maximum possible speed is—it will simply
    go as fast as it can and is allowed. You may know your connection's maximum speed,
    but curl does not.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另外要注意，curl 永远不知道最大可能的速度是多少——它只会尽可能快地下载，并且是被允许的速度。你可能知道你的连接的最大速度，但 curl 不知道。
- en: Maximum filesize
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最大文件大小
- en: 'When you want to make sure your curl command line won''t try to download a
    too-large file, you can instruct curl to stop before doing that, if it knows the
    size before the transfer starts! Maybe that would use too much bandwidth, take
    too long time or you don''t have enough space on your hard drive:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想确保你的 curl 命令行不会尝试下载一个太大的文件时，你可以在传输开始之前告诉 curl 在那之前停止，如果它在传输开始之前就知道文件大小的话！也许那会占用太多带宽，花费太长时间，或者你的硬盘空间不够：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Give curl the largest download you will accept in number of bytes and if curl
    can figure out the size before the transfer starts it will abort before trying
    to download something larger.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 给 curl 一个你将接受的最大下载字节数，如果 curl 在传输开始之前能够确定大小，它将在尝试下载较大文件之前中止。
- en: There are many situations in which curl cannot figure out the size at the time
    the transfer starts and this option will not affect those transfers, even if they
    may end up larger than the specified amount.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，curl 在传输开始时无法确定大小，此选项不会影响这些传输，即使它们可能最终比指定的数量大。
- en: Metalink
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Metalink
- en: Metalink is a file description standard that tells a client multiple locations
    where the same content resides. A client can then opt to transfer that content
    from one or many of those sources.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Metalink 是一个文件描述标准，告诉客户端同一内容的多个位置。然后客户端可以选择从这些位置中的一个或多个传输该内容。
- en: 'curl supports the Metalink format when asked to with the `--metalink` option.
    Then given URL should then point to a Metalink file. Such as:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `--metalink` 选项询问时，curl 支持 Metalink 格式。然后给定的 URL 应该指向一个 Metalink 文件。例如：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: curl will make use of the mirrors listed within the file for failover if there
    are errors (such as the file or server not being available). It will also verify
    the hash of the file after the download completes. The Metalink file itself is
    downloaded and processed in memory and not stored in the local file system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误（如文件或服务器不可用），curl 将使用文件中列出的镜像进行故障转移。下载完成后，它还将验证文件的哈希值。Metalink 文件本身在内存中下载和处理，并不存储在本地文件系统中。
- en: Storing metadata in file system
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文件系统中存储元数据
- en: When saving a download to a file with curl, the `--xattr` option tells curl
    to also store certain file metadata in "extended file attributes". These extended
    attributes are basically standardized name/value pairs stored in the file system,
    assuming one of the supported file systems and operating systems are used.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 curl 将下载保存到文件时，`--xattr` 选项告诉 curl 也在“扩展文件属性”中存储某些文件元数据。这些扩展属性基本上是标准化的名称/值对，存储在文件系统中，假设使用了其中一个受支持的文件系统和操作系统。
- en: Currently, the URL is stored in the `xdg.origin.url` attribute and, for HTTP,
    the content type is stored in the `mime_type` attribute. If the file system does
    not support extended attributes when this option is set, a warning is issued.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，URL 存储在 `xdg.origin.url` 属性中，对于 HTTP，内容类型存储在 `mime_type` 属性中。如果在设置此选项时文件系统不支持扩展属性，则会发出警告。
- en: Raw
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始
- en: When `--raw` is used, it disables all internal HTTP decoding of content or transfer
    encodings and instead makes curl passed on unaltered, raw, data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `--raw` 时，它禁用所有内部 HTTP 内容或传输编码的解码，而是使 curl 传递未经更改的原始数据。
- en: This is typically used if you are writing some sort of middle software and you
    want to pass on the content to perhaps another HTTP client and allow that to do
    the decoding instead.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于您正在编写某种中间软件，并且希望将内容传递给可能是另一个 HTTP 客户端，并允许其进行解码。
- en: Retrying failed attempts
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重试失败的尝试
- en: Normally curl will only make a single attempt to perform a transfer and return
    an error if not successful. Using the `--retry` option you can tell curl to retry
    certain failed transfers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，curl 只会尝试执行一次传输，并在不成功时返回错误。使用 `--retry` 选项，您可以告诉 curl 重新尝试某些失败的传输。
- en: 'If a transient error is returned when curl tries to perform a transfer, it
    will retry this number of times before giving up. Setting the number to 0 makes
    curl do no retries (which is the default). Transient error means either: a timeout,
    an FTP 4xx response code or an HTTP 5xx response code.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 curl 尝试执行传输时返回瞬时错误，则在放弃之前将重试此次数。将数字设置为 0 使 curl 不进行重试（这是默认值）。瞬时错误意味着：超时、FTP
    4xx 响应代码或 HTTP 5xx 响应代码。
- en: When curl is about to retry a transfer, it will first wait one second and then
    for all forthcoming retries it will double the waiting time until it reaches 10
    minutes which then will be the delay between the rest of the retries. Using `--retry-delay`
    you can disable this exponential backoff algorithm and set your own delay between
    the attempts. With `--retry-max-time` you cap the total time allowed for retries.
    The `--max-time` option will still specify the longest time a single of these
    transfers is allowed to spend.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当 curl 准备重试传输时，它将首先等待一秒钟，然后在所有接下来的重试中将等待时间加倍，直到达到 10 分钟，这将是其余重试之间的延迟。使用 `--retry-delay`
    可以禁用此指数回退算法，并设置尝试之间的自定义延迟。使用 `--retry-max-time` 您可以限制重试的总时间。`--max-time` 选项仍将指定单个传输允许花费的最长时间。
- en: Resuming and ranges
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继续和范围
- en: Resuming a download means first checking the size of what is already present
    locally and then asking the server to send the rest of it so it can be appended.
    curl also allows resuming the transfer at a custom point without actually having
    anything already locally present.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复下载意味着首先检查本地已经存在的内容大小，然后要求服务器发送其余部分以便附加。curl 还允许在实际上本地没有任何内容的情况下从自定义点恢复传输。
- en: curl supports resumed downloads on several protocols. Tell it where to start
    the transfer with the `-C, --continue-at` option that takes either a plain numerical
    byte counter offset where to start or the string `-` that asks curl to figure
    it out itself based on what it knows. When using `-`, curl will use the destination
    file name to figure out how much data that is already present locally and ask
    use that as an offset when asking for more data from the server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: curl 支持在多个协议上恢复下载。使用 `-C, --continue-at` 选项告诉它从哪里开始传输，可以是纯数字字节计数偏移量，也可以是字符串`-`，让
    curl 根据自身所知自行确定。使用 `-` 时，curl 将使用目标文件名来确定本地已经存在多少数据，并将其作为从服务器请求更多数据时的偏移量。
- en: 'To start downloading an FTP file from byte offset 100:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字节偏移量为 100 的 FTP 文件开始下载：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Continue downloading a previously interrupted download:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 继续下载先前中断的下载：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you instead just want a specific byte range from the remote resource transferred,
    you can ask for only that. For example, when you only want 1000 bytes from offset
    100 to avoid having to download the entire huge remote file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想从远程资源转移特定的字节范围，可以仅请求该范围。例如，当您只想要从偏移量为 100 的位置获取 1000 字节，以避免下载整个庞大的远程文件时：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Uploads
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传
- en: Uploads
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传
- en: Uploading is a term for sending data to a remote server. Uploading is done differently
    for each protocol, and several protocols may even allow different ways of uploading
    data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上载是将数据发送到远程服务器的术语。每个协议的上传方式都不同，甚至几个协议可能允许以不同的方式上传数据。
- en: Protocols allowing upload
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许上传的协议
- en: 'You can upload data using one of these protocols: FILE, FTP, FTPS, HTTP, HTTPS,
    IMAP, IMAPS, SCP, SFTP, SMB, SMBS, SMTP, SMTPS and TFTP.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下协议之一上传数据：FILE、FTP、FTPS、HTTP、HTTPS、IMAP、IMAPS、SCP、SFTP、SMB、SMBS、SMTP、SMTPS
    和 TFTP。
- en: HTTP offers several "uploads"
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 提供了几种“上传”方式
- en: HTTP (and its bigger brother HTTPS) provides several different ways to upload
    data to a server and curl offers easy command-line options to do it the three
    most common ways, described below.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP（及其更大的兄弟 HTTPS）提供了将数据上传到服务器的几种不同方式，curl 提供了简单的命令行选项来进行这三种最常见的方式，如下所述。
- en: An interesting detail with HTTP is also that an upload can also be a download,
    in the same operation and in fact many downloads are initiated with an HTTP POST.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 的一个有趣细节是，上传也可以是下载，在同一个操作中，事实上许多下载都是通过 HTTP POST 启动的。
- en: POST
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POST
- en: POST is the HTTP method that was invented to send data to a receiving web application,
    and it is, for example, how most common HTML forms on the web work. It usually
    sends a chunk of relatively small amounts of data to the receiver.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: POST 是发明用于将数据发送到接收 Web 应用程序的 HTTP 方法，例如，这是 Web 上大多数常见 HTML 表单的工作方式。它通常向接收方发送相对较小量的数据块。
- en: The upload kind is usually done with the `-d` or `--data` options, but there
    are a few additional alterations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上传类型通常使用 `-d` 或 `--data` 选项进行，但也有一些其他的改变。
- en: Read the detailed description on how to do this with curl in the [HTTP POST
    with curl](http-post.html) chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读关于如何使用 curl 进行此操作的详细描述，在 [HTTP POST with curl](http-post.html) 章节中。
- en: multipart formpost
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多部分表单提交
- en: Multipart formposts are also used in HTML forms on web sites; typically when
    there's a file upload involved. This type of upload is also an HTTP POST but it
    sends the data formatted according to some special rules, which is what the "multipart"
    name means.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 多部分表单提交也用于 Web 站点上的 HTML 表单；通常涉及文件上传时。这种类型的上传也是一个 HTTP POST，但它按照一些特殊规则格式化数据，这就是“多部分”的含义。
- en: Since it sends the data formatted completely differently, you cannot select
    which type of POST to use at your own whim but it entirely depends on what the
    receiving server end expects and can handle.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它发送的数据格式完全不同，你无法随心所欲地选择要使用的 POST 类型，而是完全取决于接收服务器端期望和能够处理的内容。
- en: HTTP multipart formposts are done with `-F`. See the detailed description in
    the [HTTP multipart formposts](http-multipart.html) chapter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 多部分表单提交使用 `-F` 完成。请参阅 [HTTP 多部分表单提交](http-multipart.html) 章节中的详细描述。
- en: PUT
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PUT
- en: HTTP PUT is the sort of upload that was designed to send a complete resource
    that is meant to be put as-is on the remote site or even replace an existing resource
    there. That said, this is also the least used upload method for HTTP on the web
    today and lots, if not most, web servers don't even have PUT enabled.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP PUT 是一种上传类型，旨在发送一个完整的资源，以原样放置在远程站点上，甚至替换那里的现有资源。话虽如此，这也是今天 Web 上最不常用的 HTTP
    上传方法，并且许多，如果不是大多数，Web 服务器甚至没有启用 PUT。
- en: 'You send off an HTTP upload using the -T option with the file to upload:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 -T 选项发送 HTTP 上传，并附上要上传的文件：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: FTP uploads
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FTP 上传
- en: 'Working with FTP, you get to see the remote file system you will be accessing.
    You tell the server exactly in which directory you want the upload to be placed
    and which file name to use. If you specify the upload URL with a trailing slash,
    curl will append the locally used file name to the URL and then that will be the
    file name used when stored remotely:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 FTP 时，你将看到你将要访问的远程文件系统。你告诉服务器确切地你希望将上传放置在哪个目录中以及使用哪个文件名。如果你在上传 URL 中指定了一个斜杠结尾的
    URL，curl 将把本地使用的文件名附加到 URL 中，然后在远程存储时将使用该文件名：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So if you prefer to select a different file name on the remote side than what
    you have used locally, you specify it in the URL:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢在远程端选择一个与本地使用不同的文件名，你可以在 URL 中指定：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Learn more about FTPing with curl in the [Using curl/FTP](usingcurl-ftp.html)
    section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Using curl/FTP](usingcurl-ftp.html) 部分了解更多关于使用 curl 进行 FTP 的信息。
- en: SMTP uploads
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SMTP 上传
- en: You may not consider sending an e-mail to be "uploading", but to curl it is.
    You upload the mail body to the SMTP server. With SMTP, you also need to include
    all the e-mail headers you need (To:, From:, Date:, etc.) in the mail body as
    curl will not add any at all.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不认为发送电子邮件是“上传”，但对于 curl 而言是的。你将邮件正文上传到 SMTP 服务器。使用 SMTP，你还需要在邮件正文中包含所有你需要的电子邮件头部（收件人、发件人、日期等），因为
    curl 不会添加任何内容。
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Learn more about using SMTP with curl in the [Using curl/SMTP](usingcurl-smtp.html)
    section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Using curl/SMTP](usingcurl-smtp.html) 部分了解更多关于使用 curl 进行 SMTP 的信息。
- en: Progress meter for uploads
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传的进度条
- en: The general progress meter curl provides (see the [Progress meter](cmdline-progressmeter.html)
    section) works fine for uploads as well. What needs to be remembered is that the
    progress meter is automatically disabled when you are sending output to stdout,
    and most protocols curl support can output something even for an upload.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: curl 提供的通用进度表（请参阅[进度表](cmdline-progressmeter.html)部分）对上传也有效。需要记住的是，当您将输出发送到
    stdout 时，进度表会自动禁用，curl 支持的大多数协议甚至可以为上传输出一些内容。
- en: Therefore, you may need to explicitly redirect the downloaded data to a file
    (using shell redirect '>', `-o` or similar) to get the progress meter displayed
    for upload.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能需要显式地将下载的数据重定向到一个文件（使用 shell 重定向 '>', `-o` 或类似的）以便上传时显示进度表。
- en: Rate limiting
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速率限制
- en: Rate limiting works exactly the same for uploads as for downloads and curl,
    in fact, only has a single limit that will limit the speed in both directions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制对上传和下载完全相同，而 curl 实际上只有一个限制，它会限制两个方向的速度。
- en: See further details in the [Download Rate limiting section](usingcurl-downloads.html#rate-limiting).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[下载速率限制部分](usingcurl-downloads.html#rate-limiting)以获取更多详细信息。
- en: Connections
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: Connections
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: Most of the protocols you use with curl speak TCP. With TCP, a client such as
    curl must first figure out the IP address(es) of the host you want to communicate
    with, then connect to it. "Connecting to it" means performing a TCP protocol handshake.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 curl 时大多数协议都会使用 TCP 进行通信。使用 TCP 时，如 curl 等客户端必须首先找出您要通信的主机的 IP 地址，然后连接到它。"连接到它"
    意味着执行 TCP 协议握手。
- en: For ordinary command line usage, operating on a URL, these are details which
    are taken care of under the hood, and which you can mostly ignore. But at times
    you might find yourself wanting to tweak the specifics…
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通的命令行使用，对 URL 进行操作，这些都是在幕后处理的细节，你大多数时候可以忽略这些。但有时您可能会发现自己想要微调细节...
- en: Name resolve tricks
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称解析技巧
- en: Edit the hosts file
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑 hosts 文件
- en: Maybe you want the command `curl http://example.com` to connect to your local
    server instead of the actual server.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你希望命令 `curl http://example.com` 连接到你的本地服务器而不是实际的服务器。
- en: You can normally and easily do that by editing your `hosts` file (`/etc/hosts`
    on Linux and Unix systems) and adding, for example, `127.0.0.1 example.com` to
    redirect the host to your localhost. However this edit requires admin access and
    it has the downside that it affects all other applications at the same time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编辑你的 `hosts` 文件（Linux 和 Unix 系统上的 `/etc/hosts`）并添加，例如，`127.0.0.1 example.com`
    来将主机重定向到你的 localhost。然而，这种编辑需要管理员访问权限，并且它的缺点是同时影响所有其他应用程序。
- en: 'Change the Host: header'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '更改 Host: 标头'
- en: The `Host:` header is the normal way an HTTP client tells the HTTP server which
    server it speaks to, as typically an HTTP server serves many different names using
    the same software instance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: 标头是 HTTP 客户端告诉 HTTP 服务器它要与哪个服务器通信的正常方式，因为通常一个 HTTP 服务器使用同一软件实例为许多不同的名称提供服务。'
- en: So, by passing in a custom modified `Host:` header you can have the server respond
    with the contents of the site even when you didn't actually connect to that host
    name.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，通过传递一个自定义修改的 Host: 标头，即使您实际上没有连接到该主机名，您也可以让服务器响应站点的内容。'
- en: 'For example, you run a test instance of your main site `www.example.com` on
    your local machine and you want to have curl ask for the index html:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您在本地机器上运行主站的测试实例`www.example.com`，并且您希望 curl 请求索引 html：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When setting a custom `Host:` header and using cookies, curl will extract the
    custom name and use that as host when matching cookies to send off.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '在设置自定义 Host: 标头并使用 cookie 时，curl 将提取自定义名称并将其用作与发送 cookie 匹配的主机。'
- en: The `Host:` header is not enough when communicating with an HTTPS server. With
    HTTPS there's a separate extension field in the TLS protocol called SNI (Server
    Name Indication) that lets the client tell the server the name of the server it
    wants to talk to. curl will only extract the SNI name to send from the given URL.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '在与 HTTPS 服务器通信时，Host: 标头是不够的。对于 HTTPS，TLS 协议中有一个名为 SNI（服务器名称指示）的独立扩展字段，它允许客户端告诉服务器它想要与哪个服务器通信。curl
    将仅从给定的 URL 中提取 SNI 名称以发送。'
- en: Provide a custom IP address for a name
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为名称提供自定义 IP 地址
- en: 'Do you know better than the name resolver where curl should go? Then you can
    give an IP address to curl yourself! If you want to redirect port 80 access for
    `example.com` to instead reach your localhost:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否比域名解析器更清楚 curl 应该去哪里？那么你可以自己给 curl 提供一个 IP 地址！如果你想将对`example.com`端口 80 的访问重定向到你的本地主机：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can even specify multiple `--resolve` switches to provide multiple redirects
    of this sort, which can be handy if the URL you work with uses HTTP redirects
    or if you just want to have your command line work with multiple URLs.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以指定多个 `--resolve` 开关来提供这种类型的多个重定向，如果您处理的 URL 使用 HTTP 重定向或者只想使您的命令行与多个 URL
    一起工作，则这将非常方便。
- en: '`--resolve` inserts the address into curl''s DNS cache, so it will effectively
    make curl believe that''s the address it got when it resolved the name.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`--resolve` 将地址插入 curl 的 DNS 缓存中，因此它将有效地使 curl 相信这是它在解析名称时得到的地址。'
- en: When talking HTTPS, this will send SNI for the name in the URL and curl will
    verify the server's response to make sure it serves for the name in the URL.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 HTTPS 时，这将为 URL 中的名称发送 SNI，并且 curl 将验证服务器的响应，以确保它为 URL 中的名称提供服务。
- en: Provide a replacement name
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供一个替换名称
- en: As a close relative to the `--resolve` option, the `--connect-to` option provides
    a minor variation. It allows you to specify a replacement name and port number
    for curl to use under the hood when a specific name and port number is used to
    connect.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `--resolve` 选项的近亲，`--connect-to` 选项提供了一个微小的变化。它允许您在特定名称和端口号用于连接时，在底层为 curl
    指定一个替换名称和端口号。
- en: 'For example, suppose you have a single site called `www.example.com` that in
    turn is actually served by three different individual HTTP servers: load1, load2
    and load3, for load balancing purposes. In a typical normal procedure, curl resolves
    the main site and gets to speak to one of the load balanced servers (as it gets
    a list back and just picks one of them) and all is well. If you want to send a
    test request to one specific server out of the load balanced set (`load1.example.com`
    for example) you can instruct curl to do that.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个名为 `www.example.com` 的单个站点，实际上它由三个不同的独立 HTTP 服务器提供服务：load1、load2 和
    load3，用于负载平衡目的。在典型的正常过程中，curl 解析主站点并与负载平衡服务器中的一个进行通信（因为它返回一个列表，只需选择其中一个），一切都很好。如果您想向负载平衡集合中的一个特定服务器发送一个测试请求（例如
    `load1.example.com`），您可以指示 curl 这样做。
- en: 'You *can* still use `--resolve` to accomplish this if you know the specific
    IP address of load1\. But without having to first resolve and fix the IP address
    separately, you can tell curl:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道 load1 的特定 IP 地址，仍然可以使用 `--resolve` 来完成此操作。但是，您可以告诉 curl 而不必首先分别解析和修复 IP
    地址：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It redirects from a SOURCE NAME + SOURCE PORT to a DESTINATION NAME + DESTINATION
    PORT. curl will then resolve the `load1.example.com` name and connect, but in
    all other ways still assume it is talking to `www.example.com`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 它将重定向从一个源名称 + 源端口到一个目标名称 + 目标端口。然后 curl 将解析 `load1.example.com` 名称并连接，但在所有其他方面仍然假设它正在与
    `www.example.com` 通信。
- en: Name resolve tricks with c-ares
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 c-ares 的名称解析技巧
- en: As should be detailed elsewhere in this book, curl may be built with several
    different name resolving backends. One of those backends is powered by the c-ares
    library and when curl is built to use c-ares, it gets a few extra superpowers
    that curl built to use other name resolve backends don't get. Namely, it gains
    the ability to more specifically instruct what DNS servers to use and how that
    DNS traffic is using the network.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书的其他地方详细说明的那样，curl 可能会构建具有几种不同名称解析后端的不同版本。其中之一的后端由 c-ares 库提供动力，当 curl 构建为使用
    c-ares 时，它获得了一些其他名称解析后端构建的 curl 没有获得的额外超级能力。也就是说，它可以更具体地指示要使用哪些 DNS 服务器以及该 DNS
    流量如何使用网络。
- en: With `--dns-servers`, you can specify exactly which DNS server curl should use
    instead of the default one. This lets you run your own experimental server that
    answers differently, or use a backup one if your regular one is unreliable or
    dead.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--dns-servers`，您可以指定 curl 应该使用的确切 DNS 服务器，而不是默认的 DNS 服务器。这样可以让您运行自己的实验服务器以提供不同的回答，或者在您的常规服务器不可靠或死机时使用备用服务器。
- en: With `--dns-ipv4-addr` and `--dns-ipv6-addr` you ask curl to "bind" its local
    end of the DNS communication to a specific IP address and with `--dns-interface`
    you can instruct curl to use a specific network interface to use for its DNS requests.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--dns-ipv4-addr` 和 `--dns-ipv6-addr`，您要求 curl 将其 DNS 通信的本地端绑定到特定的 IP 地址，并使用
    `--dns-interface`，您可以指示 curl 使用特定的网络接口来进行 DNS 请求。
- en: These `--dns-*` options are very advanced and are only meant for people who
    know what they are doing and understand what these options do. But they offer
    very customizable DNS name resolution operations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `--dns-*` 选项非常高级，只适用于知道自己在做什么并且了解这些选项作用的人。但它们提供了非常可定制的 DNS 名称解析操作。
- en: Connection timeout
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接超时
- en: curl will typically make a TCP connection to the host as an initial part of
    its network transfer. This TCP connection can fail or be very slow, if there are
    shaky network conditions or faulty remote servers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: curl 通常会在其网络传输的初始阶段向主机建立一个 TCP 连接。如果存在不稳定的网络条件或有故障的远程服务器，此 TCP 连接可能会失败或非常缓慢。
- en: To reduce the impact on your scripts or other use, you can set the maximum time
    in seconds which curl will allow for the connection attempt. With `--connnect-timeout`
    you tell curl the maximum time to allow for connecting, and if curl has not connected
    in that time it returns a failure.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少对你的脚本或其他用途的影响，你可以设置 curl 允许连接尝试的最大时间（以秒为单位）。使用 `--connect-timeout`，你告诉 curl
    允许连接的最大时间，并且如果在那个时间内 curl 还没有连接，它将返回一个失败。
- en: The connection timeout only limits the time curl is allowed to spend up until
    the moment it connects, so once the TCP connection has been established it can
    take longer time. See the [Timeouts](usingcurl-timeouts.html) section for more
    on generic curl timeouts.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 连接超时只限制 curl 允许花费的时间，直到它连接，所以一旦 TCP 连接建立，可能需要更长的时间。有关通用 curl 超时的更多信息，请参见[超时](usingcurl-timeouts.html)部分。
- en: If you specify a low timeout, you effectively disable curl's ability to connect
    to remote servers, slow servers or servers you access over unreliable networks.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定一个低超时时间，你实际上禁用了 curl 连接到远程服务器、慢服务器或你通过不可靠网络访问的服务器的能力。
- en: 'The connection timeout can be specified as a decimal value for sub-second precision.
    For example, to allow 2781 milliseconds to connect:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 连接超时可以指定为小数值，以实现亚秒精度。例如，允许 2781 毫秒连接：
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Network interface
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络接口
- en: On machines with multiple network interfaces that are connected to multiple
    networks, there are situations where you can decide which network interface you
    would prefer the outgoing network traffic to use. Or which originating IP address
    (out of the multiple ones you have) to use in the communication.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有多个连接到多个网络的网络接口的机器上，存在这样的情况：你可以决定你希望出站网络流量使用哪个网络接口。或者在通信中使用哪个起始 IP 地址（在你拥有的多个
    IP 地址中选择）。
- en: 'Tell curl which network interface, which IP address or even host name that
    you would like to "bind" your local end of the communication to, with the `--interface`
    option:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--interface` 选项告诉 curl 哪个网络接口、哪个 IP 地址甚至主机名，你想要"绑定"你的通信的本地端点到哪里：
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Local port number
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地端口号
- en: A TCP connection is created between an IP address and a port number in the local
    end and an IP address and a port number in the remote end. The remote port number
    can be specified in the URL and usually helps identify which service you are targeting.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 连接在本地端点的 IP 地址和端口号之间以及远程端点的 IP 地址和端口号之间创建。远程端口号可以在 URL 中指定，通常有助于识别你所针对的服务。
- en: The local port number is usually randomly assigned to your TCP connection by
    the network stack and you normally don't have to think about it much further.
    However, in some circumstances you find yourself behind network equipment, firewalls
    or similar setups that put restrictions on what source port numbers that can be
    allowed to set up the outgoing connections.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本地端口号通常由网络堆栈随机分配给你的 TCP 连接，你通常不需要进一步考虑它。然而，在某些情况下，你会发现自己身处网络设备、防火墙或类似设置后面，这些设置对可以设置的出站连接的源端口号施加了限制。
- en: For situations like this, you can specify which local ports curl should bind
    the the connection to. You can specify a single port number to use, or a range
    of ports. We recommend using a range because ports are scarce resources and the
    exact one you want may already be in use. If you ask for a local port number (or
    range) that curl can't obtain for you, it will exit with a failure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的情况，你可以指定 curl 应该绑定连接到哪些本地端口。你可以指定要使用的单个端口号，或者一系列端口。我们建议使用一系列端口，因为端口是稀缺资源，你想要的确切端口可能已经被使用了。如果你请求一个
    curl 无法为你获取到的本地端口号（或范围），它将以失败退出。
- en: Also, on most operating systems you cannot bind to port numbers below 1024 without
    having a higher privilege level (root) and we generally advise against running
    curl as root if you can avoid it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在大多数操作系统上，你不能绑定到低于 1024 的端口号，除非你有更高的特权级别（root），我们通常建议尽量避免以 root 权限运行 curl。
- en: 'Ask curl to use a local port number between 4000 and 4200 when getting this
    HTTPS page:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取此 HTTPS 页面时，请 curl 使用一个在 4000 到 4200 之间的本地端口号：
- en: '[PRE43]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Keep alive
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持连接活动
- en: TCP connections can be totally without traffic in either direction when they
    are not used. A totally idle connection can therefore not be clearly separated
    from a connection that has gone completely stale because of network or server
    issues.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TCP 连接未被使用时，可以在任一方向上完全没有流量。因此，完全空闲的连接无法与因网络或服务器问题而完全失效的连接清楚地区分开来。
- en: At the same time, lots of network equipment such as firewalls or NATs are keeping
    track of TCP connections these days, so that they can translate addresses, block
    "wrong" incoming packets, etc. These devices often count completely idle connections
    as dead after N minutes, where N varies between device to device but at times
    is as short as 10 minutes or even less.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，许多网络设备（如防火墙或 NAT 设备）如今都在跟踪 TCP 连接，以便它们可以转换地址、阻止“错误”的传入数据包等。这些设备通常在 N 分钟后将完全空闲的连接视为死连接，其中
    N 的值因设备而异，但有时甚至只有 10 分钟或更短的时间。
- en: One way to help avoid a really slow connection (or an idle one) getting treated
    as dead and wrongly killed, is to make sure TCP keep alive is used. TCP keepalive
    is a feature in the TCP protocol that makes it send "ping frames" back and forth
    when it would otherwise be totally idle. It helps idle connections to detect breakage
    even when no traffic is moving over it, and helps intermediate systems not consider
    the connection dead.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助避免将一个真正缓慢的连接（或者是一个空闲的连接）错误地视为死连接并杀掉的一种方法是确保使用 TCP keepalive。TCP keepalive
    是 TCP 协议中的一项功能，使其在完全空闲时发送 “ping 帧” 来回传输。它有助于空闲连接在没有流量传输时检测到断开，以及帮助中间系统不将连接视为死连接。
- en: 'curl uses TCP keepalive by default for the reasons mentioned here. But there
    might be times when you want to *disable* keepalive or you may want to change
    the interval between the TCP "pings" (curl defaults to 60 seconds). You can switch
    off keepalive with:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: curl 默认使用 TCP keepalive，原因在这里已经提到。但是可能会有一些时候你想要 *禁用* keepalive 或者你可能想要改变 TCP
    “ping” 之间的间隔（curl 默认为 60 秒）。你可以通过以下方法关闭 keepalive：
- en: '[PRE44]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'or change the interval to 5 minutes (300 seconds) with:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 或将间隔更改为5分钟（300秒）：
- en: '[PRE45]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Timeouts
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: Timeouts
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: Network operations are by their nature rather unreliable or perhaps fragile
    operations as they depend on a set of services and networks to be up and working
    for things to work. The availability of these services can come and go and the
    performance of them may also vary greatly from time to time.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 网络操作由于其本质而相当不可靠或者说是脆弱的操作，因为它们依赖于一组服务和网络的正常工作。这些服务的可用性可能时好时坏，它们的性能也可能随时变化。
- en: The design of TCP even allows the network to get completely disconnected for
    an extended period of time without it necessarily getting noticed by the participants
    in the transfer.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 的设计甚至允许网络在长时间内完全断开连接，而不会被传输过程中的参与者注意到。
- en: The result of this is that sometimes Internet transfers take a very long time.
    Further, most operations in curl have no time-out by default!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是有时互联网传输需要很长时间。此外，curl 中的大多数操作默认没有超时！
- en: Maximum time allowed to spend
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许花费的最长时间
- en: Tell curl with `-m / --max-time` the maximum time, in seconds, that you allow
    the command line to spend before curl exits with a timeout error code (28). When
    the set time has elapsed, curl will exit no matter what is going on at that moment—including
    if it is transferring data. It really is the maximum time allowed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `-m / --max-time` 告诉 curl 允许命令行花费的最长时间（以秒为单位），在此时间之后，curl 将退出并显示超时错误代码（28）。当经过设定的时间后，curl
    将退出，无论此时发生了什么情况——包括是否正在传输数据。这确实是允许的最长时间。
- en: The given maximum time can be specified with a decimal precision; `0.5` means
    500 milliseconds and `2.37` equals 2370 milliseconds.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的最大时间可以使用小数精度指定；`0.5` 表示 500 毫秒，`2.37` 等于 2370 毫秒。
- en: 'Example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Never spend more than this to connect
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要花费超过此时间来连接
- en: '`--connect-timeout` limits the time curl will spend trying to connect to the
    host. All the necessary steps done before the connection is considered complete
    have to be completed within the given time frame. Failing to connect within the
    given time will cause curl to exit with a timeout exit code (28).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`--connect-timeout` 限制了 curl 尝试连接到主机的时间。连接被视为完成之前必须在给定的时间范围内完成所有必要的步骤。连接在给定时间内未能建立将导致
    curl 退出，并显示超时退出代码（28）。'
- en: 'The given maximum connect time can be specified with a decimal precision; `0.5`
    means 500 milliseconds and `2.37` equals 2370 milliseconds:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的最大连接时间可以使用小数精度指定；`0.5` 表示 500 毫秒，`2.37` 等于 2370 毫秒：
- en: '[PRE47]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Transfer speeds slower than this means exit
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 慢于这个传输速度意味着退出
- en: Having a fixed maximum time for a curl operation can be cumbersome, especially
    if you, for example, do scripted transfers and the file sizes and transfer times
    vary a lot. A fixed timeout value then needs to be set unnecessarily high to cover
    for worst cases.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对 curl 操作设置固定的最大时间可能很麻烦，特别是如果您例如进行脚本传输，文件大小和传输时间变化很大。 然后，需要将固定超时值设置得过高以涵盖最坏情况。
- en: As an alternative to a fixed time-out, you can tell curl to abandon the transfer
    if it gets below a certain speed and stays below that threshold for a specific
    period of time.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 作为固定超时的替代方案，您可以告诉 curl 如果传输速度低于某个特定速度并在该阈值下保持一段时间，则放弃传输。
- en: 'For example, if a transfer speed goes below 1000 bytes per second during 15
    seconds, stop it:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果传输速度在 15 秒内低于每秒 1000 字节，则停止传输：
- en: '[PRE48]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Keep connections alive
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持连接保持活动
- en: curl enables TCP keep-alive by default. TCP keep-alive is a feature that makes
    the TCP stack send a probe to the other side when there's no traffic, to make
    sure that it is still there and "alive". By using keep-alive, curl is much more
    likely to discover that the TCP connection is dead.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: curl 默认启用 TCP keep-alive。 TCP keep-alive 是一项功能，使 TCP 栈在没有流量时向另一端发送探测，以确保其仍然存在并且“活着”。通过使用
    keep-alive，curl 更有可能发现 TCP 连接已断开。
- en: Use `--keepalive-time` to specify how often in full seconds you would like the
    probe to get sent to the peer. The default value is 60 seconds.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--keepalive-time` 指定要多少秒发送一次探测到对等方。 默认值为 60 秒。
- en: Sometimes this probing disturbs what you are doing and then you can easily disable
    it with `--no-keepalive`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这种探测会干扰您正在进行的操作，然后您可以轻松地使用 `--no-keepalive` 禁用它。
- en: .netrc
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .netrc
- en: .netrc
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .netrc
- en: Unix systems have for a very long time offered a way for users to store their
    user name and password for remote FTP servers. ftp clients have supported this
    for decades and this way allowed users to quickly login to known servers without
    manually having to reenter the credentials each time. The `.netrc` file is typically
    stored in a user's home directory. (On Windows, curl will look for it with the
    name `_netrc`).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 系统长期以来一直提供一种方式让用户存储他们的远程 FTP 服务器的用户名和密码。 多年来，ftp 客户端已支持此功能，这种方式允许用户快速登录到已知服务器，而无需手动每次重新输入凭据。
    `.netrc` 文件通常存储在用户的主目录中。 （在 Windows 上，curl 将使用名称 `_netrc` 查找它）。
- en: This being a widespread and well used concept, curl also supports it—if you
    ask it to. curl does not, however, limit this feature to FTP, but can get credentials
    for machines for any protocol with this. See further below for how.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个广泛使用的概念，curl 也支持它——如果你要求的话。然而，curl 并不将此功能限制在 FTP 上，而是可以为任何协议的机器获取凭据。请参见下文了解详细信息。
- en: The .netrc file format
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .netrc 文件格式
- en: 'The .netrc file format is simple: you specify lines with a machine name and
    follow that with lines for the login and password that are associated with that
    machine.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: .netrc 文件格式很简单：您指定一个机器名称并在其后跟随与该机器关联的登录和密码的行。
- en: '**machine name**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器名称**'
- en: Identifies a remote machine name. curl searches the .netrc file for a machine
    token that matches the remote machine specified in the URL. Once a match is made,
    the subsequent .netrc tokens are processed, stopping when the end of file is reached
    or another machine is encountered.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 标识远程机器名称。 curl 在 .netrc 文件中搜索与 URL 中指定的远程机器匹配的机器令牌。 一旦找到匹配项，将处理后续的 .netrc 令牌，直到达到文件结尾或遇到另一个机器为止。
- en: '**login name**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**登录名称**'
- en: The user name string for the remote machine.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 远程机器的用户名字符串。
- en: '**password string**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码字符串**'
- en: Supply a password. If this token is present, curl will supply the specified
    string if the remote server requires a password as part of the login process.
    Note that if this token is present in the .netrc file you really **should** make
    sure the file is not readable by anyone besides the user.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 提供密码。 如果存在此令牌，则 curl 将在远程服务器要求密码作为登录过程的一部分时提供指定的字符串。 请注意，如果此令牌存在于 .netrc 文件中，确实应确保该文件除了用户之外没有其他人可以读取。
- en: 'An example .netrc for the host example.com with a user named ''daniel'', using
    the password ''qwerty'' would look like:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有名为 'daniel' 的用户、使用密码 'qwerty' 的主机 example.com 的示例 .netrc 如下所示：
- en: '[PRE49]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Enable netrc
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用 netrc
- en: '`-n, --netrc` tells curl to look for and use the .netrc file.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`-n, --netrc` 告诉 curl 查找并使用 .netrc 文件。'
- en: '`--netrc-file [file]` is similar to `--netrc`, except that you also provide
    the path to the actual file to use. This is useful when you want to provide the
    information in another directory or with another file name.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`--netrc-file [file]` 与 `--netrc` 类似，只是您还提供要使用的实际文件的路径。当您想要在另一个目录或使用另一个文件名提供信息时，这非常有用。'
- en: '`--netrc-optional` is similar to `--netrc`, but this option makes the .netrc
    usage optional and not mandatory as the `--netrc` option.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`--netrc-optional` 与 `--netrc` 类似，但此选项使 .netrc 的使用成为可选项，而不是强制性的，如 `--netrc`
    选项。'
- en: Proxies
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: Proxies
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: A proxy is a machine or software that does something on behalf of you, the client.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是一台机器或软件，代表您，即客户端，执行某些操作。
- en: You can also see it as a middle man that sits between you and the server you
    want to work with, a middle man that you connect to instead of the actual remote
    server. You ask the proxy to perform your desired operation for you and then it
    will run off and do that and then return back the data to you.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将其视为坐落在您和您想要处理的服务器之间的中间人，一个中间人，您连接到它而不是实际的远程服务器。您请求代理代替您执行所需的操作，然后它将运行并返回数据给您。
- en: There are several different types of proxies and we shall list and discuss them
    further down in this section.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同类型的代理，我们将在本节中列出并讨论它们。
- en: Discover your proxy
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现您的代理
- en: Some networks are setup to require a proxy in order for you to reach the Internet
    or perhaps that special network you are interested in. The use of proxies are
    introduced on your network by the people and management that run your network
    for policy or technical reasons.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络设置要求您使用代理才能访问互联网或者您感兴趣的特定网络。代理的使用是由管理您的网络的人员和管理人员基于政策或技术原因引入到您的网络中的。
- en: In the networking space there are a few methods for the automatic detection
    of proxies and how to connect to them, but none of those methods are truly universal
    and curl supports none of them. Furthermore, when you communicate to the outside
    world through a proxy that often means that you have to put a lot of trust on
    the proxy as it will be able to see and modify all the non-secure network traffic
    you send or get through it. That trust is not easy to assume automatically.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络空间中，有几种方法可以自动检测代理以及如何连接到它们，但这些方法都不是真正通用的，curl 不支持其中任何一种。此外，当您通过代理与外界通信时，这通常意味着您必须对代理放置大量信任，因为它能够查看和修改您通过它发送或接收的所有非安全网络流量。这种信任不容易自动假设。
- en: If you check your browser's network settings, sometimes under an advanced settings
    tab, you can learn what proxy or proxies your browser is configured to use. Chances
    are very big that you should use the same one or ones when you use curl.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查浏览器的网络设置，有时可以在高级设置选项卡下，您可以了解您的浏览器配置为使用哪个代理或代理。很大的机会是，当您使用 curl 时，您应该使用相同的一个或多个代理。
- en: 'TBD: screenshots of how to find proxy settings in Firefox and Chrome?'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 待定：如何在 Firefox 和 Chrome 中找到代理设置的截图？
- en: PAC
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PAC
- en: Some network environments provides several different proxies that should be
    used in different situations, and a very customizable way to handle that is supported
    by the browsers. This is called "proxy auto-config", or PAC.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络环境提供了几种不同的代理，应该在不同的情况下使用，浏览器支持的处理方式非常灵活。这称为“代理自动配置”，或 PAC。
- en: A PAC file contains a JavaScript function that decides which proxy a given network
    connection (URL) should use, and even if it should not use a proxy at all. Browsers
    most typically read the PAC file off a URL on the local network.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: PAC 文件包含一个 JavaScript 函数，该函数决定给定网络连接（URL）应该使用哪个代理，甚至是否根本不应该使用代理。浏览器最常读取 PAC
    文件位于本地网络上的 URL。
- en: Since curl has no JavaScript capabilities, curl doesn't support PAC files. If
    your browser and network use PAC files, the easiest route forward is usually to
    read the PAC file manually and figure out the proxy you need to specify to run
    curl successfully.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 curl 没有 JavaScript 能力，因此不支持 PAC 文件。如果您的浏览器和网络使用 PAC 文件，最简单的前进路线通常是手动阅读 PAC
    文件，并找出您需要指定以成功运行 curl 的代理。
- en: Captive portals
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获门户
- en: (these aren't proxies but in the way)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: （这些不是代理，而是在路上）
- en: TBD
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Proxy type
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理类型
- en: curl supports several different types of proxies.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: curl 支持几种不同类型的代理。
- en: The default proxy type is HTTP so if you specify a proxy host name (or IP address)
    without a scheme part (the part that is often written as "http://") curl goes
    with assuming it's an HTTP proxy.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的代理类型是 HTTP，因此如果您指定一个代理主机名（或 IP 地址）而没有方案部分（通常写为“http://”的部分），curl 会假定它是一个
    HTTP 代理。
- en: curl also allows a number of different options to set the proxy type instead
    of using the scheme prefix. See the [SOCKS](#socks) section below.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: curl 还允许设置代理类型的许多不同选项，而不是使用方案前缀。请参见下面的 [SOCKS](#socks) 部分。
- en: HTTP
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP
- en: An HTTP proxy is a proxy that the client speaks HTTP with to get the transfer
    done. curl will, by default, assume that a host you point out with `-x` or `--proxy`
    is an HTTP proxy, and unless you also specify a port number it will default to
    port 3128 (and the reason for that particular port number is purely historical).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 代理是客户端与之交谈以完成传输的代理。curl 将默认假设您用 `-x` 或 `--proxy` 指出的主机是 HTTP 代理，除非您还指定端口号，默认端口号是
    3128（这个特定端口号的原因纯粹是历史原因）。
- en: 'If you want to request the example.com web page using a proxy on 192.168.0.1
    port 8080, a command line could look like:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用位于 192.168.0.1 端口 8080 上的代理请求 example.com 网页，命令行可能如下所示：
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Recall that the proxy receives your request, forwards it to the real server,
    then reads the response from the server and then hands that back to the client.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆一下，代理接收到您的请求，将其转发给真实服务器，然后从服务器读取响应，然后将其返回给客户端。
- en: If you enable verbose mode with `-v` when talking to a proxy, you will see that
    curl connects to the proxy instead of the remote server, and you will see that
    it uses a slightly different request line.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在与代理交谈时启用了详细模式（使用 `-v`），您将看到 curl 连接到代理而不是远程服务器，并且您将看到它使用略有不同的请求行。
- en: HTTPS and proxy
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTPS 和代理
- en: HTTPS was designed to allow and provide secure and safe end-to-end privacy from
    the client to the server (and back). In order to provide that when speaking to
    an HTTP proxy, the HTTP protocol has a special request that curl uses to setup
    a tunnel through the proxy that it then can encrypt and verify. This HTTP method
    is known as `CONNECT`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 的设计是为了允许并提供安全的端到端隐私，从客户端到服务器（和返回）。为了在与 HTTP 代理通话时提供这一点，HTTP 协议有一个特殊的请求，curl
    使用它来设置通过代理的隧道，然后可以加密和验证它。此 HTTP 方法称为 `CONNECT`。
- en: 'When the proxy tunnels encrypted data through to the remote server after a
    CONNECT method sets it up, the proxy cannot see nor modify the traffic without
    breaking the encryption:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理通过 CONNECT 方法设置加密数据传输到远程服务器之后，代理不能看到也不能修改流量而不破坏加密：
- en: '[PRE51]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: MITM-proxies
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MITM 代理
- en: MITM means Man-In-The-Middle. MITM-proxies are usually deployed by companies
    in "enterprise environments" and elsewhere, where the owners of the network have
    a desire to investigate even TLS encrypted traffic.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: MITM 意思是中间人攻击。MITM 代理通常由公司在“企业环境”和其他地方部署，网络所有者希望调查甚至是 TLS 加密流量。
- en: To do this, they require users to install a custom "trust root" (CA cert) in
    the client, and then the proxy terminates all TLS traffic from the client, impersonates
    the remote server and acts like a proxy. The proxy then sends back a generated
    certificate signed by the custom CA. Such proxy setups usually transparently capture
    all traffic from clients to TCP port 443 on a remote machine. Running curl in
    such a network would also get its HTTPS traffic captured.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，它们要求用户在客户端安装一个自定义的“信任根”（CA 证书），然后代理终止来自客户端的所有 TLS 流量，冒充远程服务器并充当代理。代理然后发送回一个由自定义
    CA 签名的生成的证书。这样的代理设置通常会透明地捕获来自客户端到远程机器的 TCP 端口 443 的所有流量。在这样的网络中运行 curl 也会捕获其 HTTPS
    流量。
- en: This practice, of course, allows the middle man to decrypt and snoop on all
    TLS traffic.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种做法允许中间人解密和窥探所有 TLS 流量。
- en: Non-HTTP protocols over an HTTP proxy
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 HTTP 代理发送非 HTTP 协议
- en: An "HTTP proxy" means the proxy itself speaks HTTP. HTTP proxies are primarily
    used to proxy HTTP but it is also fairly common that they support other protocols
    as well. In particular, FTP is fairly commonly supported.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: “HTTP 代理”意味着代理本身使用 HTTP。HTTP 代理主要用于代理 HTTP，但它也相当常见地支持其他协议。特别是，FTP 相当常见。
- en: 'When talking FTP "over" an HTTP proxy, it is usually done by more or less pretending
    the other protocol works like HTTP and asking the proxy to "get this URL" even
    if the URL isn''t using HTTP. This distinction is important because it means that
    when sent over an HTTP proxy like this, curl doesn''t really speak FTP even though
    given an FTP URL; thus FTP-specific features will not work:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 FTP “通过” HTTP 代理时，通常是通过更多或更少地假装另一个协议工作像 HTTP，并请求代理“获取此 URL”，即使 URL 没有使用
    HTTP。这种区别很重要，因为这意味着当通过这样的 HTTP 代理发送时，curl 实际上并不会说 FTP，即使给定了 FTP URL；因此 FTP 特定的功能将不起作用：
- en: '[PRE52]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What you can do instead then, is to "tunnel through" the HTTP proxy!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您可以做的是“通过”HTTP 代理隧道！
- en: HTTP proxy tunneling
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 代理隧道
- en: Most HTTP proxies allow clients to "tunnel through" it to a server on the other
    side. That's exactly what's done every time you use HTTPS through the HTTP proxy.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 HTTP 代理允许客户端“隧道连接”到另一侧的服务器。这正是每次通过 HTTP 代理使用 HTTPS 时所做的。
- en: You tunnel through an HTTP proxy with curl using `-p` or `--proxytunnel`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-p` 或 `--proxytunnel` 通过 curl 隧道连接 HTTP 代理。
- en: When you do HTTPS through a proxy you normally connect through to the default
    HTTPS remote TCP port number 443, so therefore you will find that most HTTP proxies
    white list and allow connections only to hosts on that port number and perhaps
    a few others. Most proxies will deny clients from connecting to just any random
    port (for reasons only the proxy administrators know).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过代理进行 HTTPS 时，通常会连接到默认的 HTTPS 远程 TCP 端口号 443，因此你会发现大多数 HTTP 代理只会允许连接到该端口号上的主机，可能还有一些其他端口号。大多数代理会拒绝客户端连接到任意随机端口（只有代理管理员才知道的原因）。
- en: 'Still, assuming that the HTTP proxy allows it, you can ask it to tunnel through
    to a remote server on any port number so you can do other protocols "normally"
    even when tunneling. You can do FTP tunneling like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 依然假设 HTTP 代理允许，你可以要求它通过任何端口号隧道连接到远程服务器，这样即使在进行隧道连接时，你也可以“正常”使用其他协议。你可以这样进行 FTP
    隧道连接：
- en: '[PRE53]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can tell curl to use HTTP/1.0 in its CONNECT request issued to the HTTP
    proxy by using `--proxy1.0 [proxy]` instead of `-x`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `--proxy1.0 [proxy]` 而不是 `-x` 来告诉 curl 在其向 HTTP 代理发出的 CONNECT 请求中使用
    HTTP/1.0。
- en: SOCKS types
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SOCKS 类型
- en: SOCKS is a protocol used for proxies and curl supports it. curl supports both
    SOCKS version 4 as well as version 5, and both versions come in two flavors.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: SOCKS 是用于代理的协议，curl 支持它。curl 支持 SOCKS 版本 4 和版本 5，这两个版本都有两种类型。
- en: You can select the specific SOCKS version to use by using the correct scheme
    part for the given proxy host with `-x`, or you can specify it with a separate
    option instead of `-x`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `-x` 对给定代理主机使用正确的方案部分来选择要使用的特定 SOCKS 版本，或者你可以使用单独的选项指定它，而不是使用 `-x`。
- en: 'SOCKS4 is for the version 4 and SOCKS4a is for the version 4 without resolving
    the host name locally:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: SOCKS4 用于版本 4，而 SOCKS4a 用于版本 4，不会在本地解析主机名：
- en: '[PRE54]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The SOCKS4a versions:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: SOCKS4a 版本：
- en: '[PRE55]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'SOCKS5 is for the version 5 and SOCKS5-hostname is for the version 5 without
    resolving the host name locally:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: SOCKS5 用于版本 5，而 SOCKS5-hostname 用于版本 5，不会在本地解析主机名：
- en: '[PRE56]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The SOCKS5-hostname versions. This sends the host name to the server so there''s
    no name resolving done locally:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: SOCKS5-hostname 版本。这将主机名发送到服务器，因此不会在本地执行名称解析：
- en: '[PRE57]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Proxy authentication
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理身份验证
- en: HTTP proxies can require authentication, so curl then needs to provide the proper
    credentials to the proxy to be allowed to use it, and failing to do will only
    make the proxy return back HTTP responses using code 407.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 代理可能需要身份验证，所以 curl 需要提供适当的凭据给代理以允许使用它，而未能这样做只会使代理返回使用代码 407 的 HTTP 响应。
- en: Authentication for proxies is very similar to "normal" HTTP authentication,
    but is separate from the server authentication to allow clients to independently
    use both normal host authentication as well as proxy authentication.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的身份验证与“正常”的 HTTP 身份验证非常相似，但是是单独的，以允许客户端独立使用正常主机身份验证以及代理身份验证。
- en: 'With curl, you set the user name and password for the proxy authentication
    with the `-U user:password` or `--proxy-user user:password` option:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 curl，你可以使用 `-U user:password` 或 `--proxy-user user:password` 选项为代理身份验证设置用户名和密码：
- en: '[PRE58]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This example will default to using the Basic authentication scheme. Some proxies
    will require another authentication scheme (and the headers that are returned
    when you get a 407 response will tell you which) and then you can ask for a specific
    method with `--proxy-digest`, `--proxy-negotiate`, `--proxy-ntlm`. The above example
    command again, but asking for NTLM auth with the proxy:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将默认使用基本身份验证方案。有些代理需要另一种身份验证方案（当你收到 407 响应时返回的头信息将告诉你），然后你可以用 `--proxy-digest`、`--proxy-negotiate`、`--proxy-ntlm`
    请求特定的方法。上面的示例命令再次，但要求使用代理进行 NTLM 身份验证：
- en: '[PRE59]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'There''s also the option that asks curl to figure out which method the proxy
    wants and supports and then go with that (with the possible expense of extra roundtrips)
    using `--proxy-anyauth`. Asking curl to use any method the proxy wants is then
    like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选项是让 curl 弄清楚代理想要和支持的方法，然后按照那种方法进行（可能会额外增加往返次数的开销），使用 `--proxy-anyauth`。要求
    curl 使用代理想要的任何方法，就像这样：
- en: '[PRE60]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: HTTPS to proxy
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTPS 到代理
- en: All the previously mentioned protocols to speak with the proxy are clear text
    protocols, HTTP and the SOCKS versions. Using these methods could allow someone
    to eavesdrop on your traffic the local network where you or the proxy reside.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前提到的与代理通信的协议都是明文协议，包括HTTP和SOCKS版本。使用这些方法可能允许某人在你或代理所在的本地网络上窃听你的流量。
- en: One solution for that is to use HTTPS to the proxy, which then establishes a
    secure and encrypted connection that is safe from easy surveillance.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个解决方案是通过HTTPS到代理，这样建立一个安全加密的连接，不易受���视。
- en: curl does not currently support HTTPS to the proxy, but there is work in progress
    for this that we hope to land in a future curl version.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 目前curl不支持通过HTTPS到代理的连接，但我们正在进行相关工作，希望在未来的curl版本中实现这一功能。
- en: Proxy environment variables
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理环境变量
- en: curl checks for the existence of specially-named environment variables before
    it runs to see if a proxy is requested to get used.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，curl会检查特定命名的环境变量是否存在，以确定是否需要使用代理。
- en: 'You specify the proxy by setting a variable named `[scheme]_proxy` to hold
    the proxy host name (the same way you would specify the host with `-x`). So if
    you want to tell curl to use a proxy when access a HTTP server, you set the ''http_proxy''
    environment variable. Like this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置一个名为`[scheme]_proxy`的变量来指定代理主机名（就像你使用`-x`指定主机一样）。因此，如果你想告诉curl在访问HTTP服务器时使用代理，你需要设置'http_proxy'环境变量。就像这样：
- en: '[PRE61]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: While the above example shows HTTP, you can, of course, also set ftp_proxy,
    https_proxy, and so on. All these proxy environment variable names except http_proxy
    can also be specified in uppercase, like HTTPS_PROXY.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上面的示例展示了HTTP，当然，你也可以设置ftp_proxy、https_proxy等。除了http_proxy之外，所有这些代理环境变量名称也可以使用大写形式，比如HTTPS_PROXY。
- en: To set a single variable that controls *all* protocols, the ALL_PROXY exists.
    If a specific protocol variable one exists, such a one will take precedence.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置一个控制*所有*协议的单个变量，存在ALL_PROXY。如果存在特定协议变量，则该变量将优先。
- en: When using environment variables to set a proxy, you could easily end up in
    a situation where one or a few host names should be excluded from going through
    the proxy. This is then done with the NO_PROXY variable. Set that to a comma-
    separated list of host names that should not use a proxy when being accessed.
    You can set NO_PROXY to be a single asterisk ('*') to match all hosts.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用环境变量设置代理时，可能会出现一种情况，即需要排除一些主机名不通过代理。这可以通过设置NO_PROXY变量来实现。将其设置为一个逗号分隔的主机名列表，这些主机名在访问时不使用代理。你可以将NO_PROXY设置为单个星号（'*'）以匹配所有主机。
- en: As an alternative to the NO_PROXY variable, there's also a `--noproxy` command
    line option that serves the same purpose and works the same way.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 作为NO_PROXY变量的替代方案，还有一个`--noproxy`命令行选项，具有相同的目的并且工作方式相同。
- en: Proxy headers
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理头
- en: --proxy-header
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: --proxy-header
- en: TBD
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Exit status
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出状态
- en: Exit status
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出状态
- en: A lot of effort has gone into the project to make curl return a usable exit
    code when something goes wrong and it will always return 0 (zero) when the operation
    went as planned.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 项目已经付出了大量努力，使curl在出现问题时返回一个可用的退出代码，当操作顺利完成时，它将始终返回0（零）。
- en: If you write a shell script or batch file that invokes curl, you can always
    check the return code to detect problems in the invoked command. Below, you will
    find a list of return codes as of the time of this writing. Over time we tend
    to slowly add new ones so if you get a code back not listed here, please refer
    to more updated curl documentation for aid.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写一个调用curl的shell脚本或批处理文件，你可以始终检查返回代码以检测调用命令中的问题。在下面，你将找到此时的返回代码列表。随着时间的推移，我们倾向于慢慢添加新的代码，因此如果你收到一个此处未列出的代码，请参考更更新的curl文档以获取帮助。
- en: 'A very basic Unix shell script could look like something like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常基本的Unix shell脚本可能看起来像这样：
- en: '[PRE62]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Available exit codes
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的退出代码
- en: Unsupported protocol. This build of curl has no support for this protocol. Usually
    this happens because the URL was misspelled to use a scheme part that either has
    a space in front of it or spells "http" like "htpt" or similar. Another common
    mistake is that you use a libcurl installation that was built with one or more
    protocols disabled and you now ask libcurl to use one of those protocols that
    were disabled in the build.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不支持的协议。此curl版本不支持此协议。通常这是因为URL拼写错误，使用了一个在其前面有空格或拼写为"htpt"等的方案部分。另一个常见的错误是你使用了一个在构建时禁用了一个或多个协议的libcurl安装，现在要求libcurl使用其中一个在构建中禁用的协议。
- en: Failed to initialize. This is mostly an internal error or a problem with the
    libcurl installation or system libcurl runs in.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化失败。这主要是内部错误或 libcurl 安装或 libcurl 运行的系统中的问题。
- en: URL malformed. The syntax was not correct. This happens when you mistype a URL
    so that it ends up wrong, or in rare situations you are using a URL that is accepted
    by another tool that curl doesn't support only because there is no universal URL
    standard that everyone adheres to.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL 格式错误。语法不正确。当您误输入 URL 以致它错误时，或者在罕见情况下，您使用的 URL 被另一个 curl 不支持的工具接受，只因为没有每个人都遵循的通用
    URL 标准。
- en: A feature or option that was needed to perform the desired request was not enabled
    or was explicitly disabled at build-time. To make curl able to do this, you probably
    need another build of libcurl!
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所需请求的功能或选项未启用或在构建时显式禁用。要使 curl 能够执行此操作，您可能需要另一个 libcurl 的构建版本！
- en: Couldn't resolve proxy. The address of the given proxy host could not be resolved.
    Either the given proxy name is just wrong, or the DNS server is misbehaving and
    doesn't know about this name when it should or perhaps even the system you run
    curl on is misconfigured so that it doesn't find/use the correct DNS server.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法解析代理。无法解析给定代理主机的地址。要么给定的代理名错误，要么 DNS 服务器的行为不当，在应该知道该名称的情况下却不知道，甚至您运行 curl
    的系统可能被错误配置，以便找不到/使用正确的 DNS 服务器。
- en: Couldn't resolve host. The given remote host's address was not resolved. The
    address of the given server could not be resolved. Either the given host name
    is just wrong, or the DNS server is misbehaving and doesn't know about this name
    when it should or perhaps even the system you run curl on is misconfigured so
    that it doesn't find/use the correct DNS server.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法解析主机。未解析给定远程主机的地址。无法解析给定服务器的地址。要么给定的主机名错误，要么 DNS 服务器的行为不当，在应该知道该名称的情况下却不知道，甚至您运行
    curl 的系统可能被错误配置，以便找不到/使用正确的 DNS 服务器。
- en: Failed to connect to host. curl managed to get an IP address to the machine
    and it tried to setup a TCP connection to the host but failed. This can be because
    you have specified the wrong port number, entered the wrong host name, the wrong
    protocol or perhaps because there is a firewall or another network equipment in
    between that blocks the traffic from getting through.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接主机失败。curl 成功获取了到达该主机的 IP 地址，并尝试设置到主机的 TCP 连接，但失败了。这可能是因为您指定了错误的端口号、输入了错误的主机名、使用了错误的协议，或者可能是因为存在防火墙或其他阻止流量通过的网络设备。
- en: Unknown FTP server response. The server sent data curl couldn't parse. This
    is either because of a bug in curl, a bug in the server or because the server
    is using an FTP protocol extension that curl doesn't support. The only real work-around
    for this is to tweak curl options to try it to use other FTP commands that perhaps
    won't get this unknown server response back.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未知的 FTP 服务器响应。服务器发送了 curl 无法解析的数据。这可能是因为 curl 中存在错误、服务器中存在错误，或者因为服务器正在使用 curl
    不支持的 FTP 协议扩展。对此唯一真正的解决方法是调整 curl 选项，尝试使用其他可能不会收到此未知服务器响应的 FTP 命令。
- en: FTP access denied. The server denied login or denied access to the particular
    resource or directory you wanted to reach. Most often you tried to change to a
    directory that doesn't exist on the server. The directory of course is what you
    specify in the URL.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP 访问被拒绝。服务器拒绝了登录或拒绝了访问您想要访问的特定资源或目录。大多数情况下，您试图切换到服务器上不存在的目录。当然，该目录就是您在 URL
    中指定的目录。
- en: FTP accept failed. While waiting for the server to connect back when an active
    FTP session is used, an error code was sent over the control connection or similar.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP 接受失败。在使用主动 FTP 会话等待服务器连接回来时，控制连接或类似连接上发送了错误代码。
- en: FTP weird PASS reply. Curl couldn't parse the reply sent to the PASS request.
    PASS in the command curl sends the password to the server with, and even anonymous
    connections to FTP server actually sends a password - a fixed anonymous string.
    Getting a response back from this command that curl doesn't understand is a strong
    indication that this isn't an FTP server at all or that the server is badly broken.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP 异常 PASS 响应。Curl 无法解析发送到 PASS 请求的响应。curl 发送的命令 PASS 将密码发送到服务器，并且甚至匿名连接到 FTP
    服务器实际上也发送一个密码 - 一个固定的匿名字符串。从此命令获得 curl 不理解的响应是一个强烈的指示，表明这根本不是一个 FTP 服务器，或者服务器严重损坏。
- en: During an active FTP session (PORT is used) while waiting for the server to
    connect, the timeout expired. It took too long for the server to get back. This
    is usually a sign that something is preventing the server from reaching curl successfully.
    Like a firewall or other network arrangements. .
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在等待服务器连接期间的活动 FTP 会话（使用 PORT）时，超时已过期。服务器花费了太长时间才能回复。这通常是一个迹象，表明某些因素阻止服务器成功到达
    curl。比如防火墙或其他网络设置。
- en: Unknown response to FTP PASV command, Curl couldn't parse the reply sent to
    the PASV request. This is a strange server. PASV is used to setup the second data
    transfer connection in passive mode, see the [FTP uses two connections](ftp-twoconnections.html)
    section for more on that. You might be able to work-around this problem by using
    PORT instead, with the `--ftp-port` option.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 FTP PASV 命令的未知响应，Curl 无法解析发送到 PASV 请求的响应。这是一个奇怪的服务器。PASV 用于在被动模式下设置第二个数据传输连接，请参阅[FTP
    使用两个连接](ftp-twoconnections.html)部分了解更多信息。您可以尝试通过使用 `--ftp-port` 选项，改用 PORT 来解决此问题。
- en: Unknown FTP 227 format. Curl couldn't parse the 227-line the server sent. This
    is most certainly a broken server. A 227 is the FTP server's response when sending
    back information on how curl should connect back to it in passive mode. You might
    be able to work-around this problem by using PORT instead, with the `--ftp-port`
    option.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未知的 FTP 227 格式。Curl 无法解析服务器发送的 227 行。这肯定是一个坏掉的服务器。当发送 FTP 服务器的响应时，227 是 FTP
    服务器的响应，用于回送有关 curl 应如何连接回它的信息。您可以尝试通过使用 `--ftp-port` 选项改用 PORT 来解决此问题。
- en: FTP can't get host. Couldn't use the host IP address we got in the 227-line.
    This is most likely an internal error!
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP 无法获取主机。无法使用 227 行中获取的主机 IP 地址。这很可能是内部错误！
- en: HTTP/2 error. A problem was detected in the HTTP2 framing layer. This is somewhat
    generic and can be one out of several problems, see the error message for details.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP/2 错误。在 HTTP2 帧层中检测到问题。这有点通用，可能是几个问题之一，请查看错误消息以获取详细信息。
- en: FTP couldn't set binary. Couldn't change transfer method to binary. This server
    is broken. curl needs to set the transfer to the correct mode before it is started
    as otherwise the transfer can't work.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP 无法设置二进制。无法将传输方法更改为二进制。这个服务器坏了。curl 需要在启动之前将传输设置为正确的模式，否则传输无法工作。
- en: Partial file. Only a part of the file was transferred. When the transfer is
    considered complete, curl will verify that it actually received the same amount
    of data that it was told before-hand that it was going to get. If the two numbers
    don't match, this is the error code. It could mean that curl got fewer bytes than
    advertised or that it got more. curl itself cannot know which number that is wrong
    or which is correct. If any.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部分文件。只传输了文件的一部分。当传输被认为完成时，curl 将验证实际接收到的数据量是否与之前预告的相同。如果两个数字不匹配，则是错误代码。这可能意味着
    curl 比广告的少接收了字节，或者比广告的多接收了字节。curl 本身无法知道哪个数字是错误的或哪个是正确的。如果有的话。
- en: FTP couldn't download/access the given file. The RETR (or similar) command failed.
    curl got an error from the server when trying to download the file.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP 无法下载/访问给定的文件。RETR（或类似）命令失败。当尝试下载文件时，curl 从服务器收到错误。
- en: '**Not used**'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: Quote error. A quote command returned an error from the server. curl allows
    several different ways to send custom commands to a IMAP, POP3, SMTP or FTP server
    and features a generic check that the commands work. When any of the individually
    issued commands fails, this is exit status is returned. The advice is generally
    to watch the headers in the FTP communication to better understand exactly what
    failed and how.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引号错误。引号命令从服务器返回了错误。curl 允许以多种不同的方式向 IMAP、POP3、SMTP 或 FTP 服务器发送自定义命令，并且具有通用检查以确保这些命令有效。当任何一个单独的命令失败时，会返回此退出状态。一般建议查看
    FTP 通信中的头信息，以更好地理解到底发生了什么以及如何处理。
- en: HTTP page not retrieved. The requested url was not found or returned another
    error with the HTTP error code being 400 or above. This return code only appears
    if `-f, --fail` is used.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未检索到 HTTP 页面。未找到请求的 URL 或返回了另一个 HTTP 错误，HTTP 错误代码为 400 或更高。仅在使用 `-f, --fail`
    时才会出现此返回代码。
- en: Write error. Curl couldn't write data to a local filesystem or similar. curl
    receives data chunk by chunk from the network and it stores it like at (or writes
    it to stdout), one piece at a time. If that write action gets an error, this is
    the exit status.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入错误。Curl 无法将数据写入本地文件系统或类似位置。curl 从网络逐块接收数据，并将其像在（或将其写入标准输出）一样存储，每次一块。如果写入操作出错，这是退出状态。
- en: '**Not used**'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: Upload failed. The server refused to accept or store the file that curl tried
    to send to it. This is usually due to wrong access rights on the server but can
    also happen due to out of disk space or other resource constraints. This error
    can happen for many protocols.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传失败。服务器拒绝接受或存储 curl 尝试发送的文件。这通常是由于服务器上错误的访问权限引起的，但也可能是由于磁盘空间不足或其他资源限制引起的。此错误可能发生在许多协议中。
- en: Read error. Various reading problems. The inverse to exit status 23\. When curl
    sends data to a server, it reads data chunk by chunk from a local file or stdin
    or similar, and if that reading fails in some way this is the exit status curl
    will return.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取错误。各种读取问题。与退出状态 23 相反。当 curl 向服务器发送数据时，它会从本地文件或 stdin 或类似地逐块读取数据，如果读取方式出现问题，则此退出状态是
    curl 将返回的。
- en: Out of memory. A memory allocation request failed. curl needed to allocate more
    memory than what the system was willing to give it and curl had to exit. Try using
    smaller files or make sure that curl gets more memory to work with.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存不足。内存分配请求失败。curl 需要分配的内存超过了系统愿意提供的内存，因此必须退出。尝试使用较小的文件或确保 curl 获得更多的可用内存。
- en: Operation timeout. The specified time-out period was reached according to the
    conditions. curl offers several [timeouts](usingcurl-timeouts.html), and this
    exit code tells one of those timeout limits were reached. Extend the timeout or
    try changing something else that allows curl to finish its operation faster. Often,
    this happens due to network and remote server situations that you cannot affect
    locally.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作超时。根据条件，达到了指定的超时时间。curl 提供了几个 [超时](usingcurl-timeouts.html)，此退出代码表示其中一个超时限制已达到。延长超时时间或尝试更改其他允许
    curl 更快完成操作的内容。通常，这是由于无法在本地影响的网络和远程服务器情况引起的。
- en: '**Not used**'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: FTP PORT failed. The PORT command failed. Not all FTP servers support the PORT
    command; try doing a transfer using PASV instead! The PORT command is used to
    ask the server to create the data connection by *connecting back* to curl. See
    also the [FTP uses two connections](ftp-twoconnections.html) section.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP PORT 失败。PORT 命令失败。并非所有 FTP 服务器都支持 PORT 命令；尝试使用 PASV 进行传输！PORT 命令用于要求服务器通过*回连*到
    curl 来创建数据连接。另请参阅 [FTP uses two connections](ftp-twoconnections.html) 部分。
- en: FTP couldn't use REST. The REST command failed. This command is used for resumed
    FTP transfers. curl needs to issue the REST command to do range or resumed transfers.
    The server is broken, try the same operation without range/resume as a crude work-around!
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP 无法使用 REST。REST 命令失败。此命令用于恢复 FTP 传输。curl 需要发出 REST 命令以进行范围或恢复传输。服务器出现故障，请尝试不带范围/恢复的相同操作作为一个粗糙的解决方法！
- en: '**Not used**'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: HTTP range error. The range request didn't work. Resumed HTTP requests aren't
    necessary acknowledged or supported, so this exit code signals that for this resource
    on this server, there can be no range or resumed transfers.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP 范围错误。范围请求未成功。不会明确承认或支持恢复的 HTTP 请求，因此此退出代码表示对于此服务器上的此资源，无法进行范围或恢复传输。
- en: HTTP post error. Internal post-request generation error. If you get this error,
    please report the exact circumstances to the curl project!
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP post 错误。内部发布请求生成错误。如果遇到此错误，请向 curl 项目报告确切的情况！
- en: A TLS/SSL connect error. The SSL handshake failed. The SSL handshake can fail
    due to numerous different reasons so the error message may offer some additional
    clues. Maybe the parties couldn't agree to a SSL/TLS version, an agreeable cipher
    suite or similar.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TLS/SSL 连接错误。SSL 握手失败。SSL 握手可能由于许多不同原因而失败，因此错误消息可能会提供一些额外的线索。也许各方无法就 SSL/TLS
    版本、适合的密码套件或类似事项达成一致。
- en: Bad download resume. Couldn't continue an earlier aborted download. When asking
    to resume a transfer that then ends up not possible to do, this error can get
    returned. For FILE, FTP or SFTP.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误的下载恢复。无法继续先前中断的下载。当请求恢复一个然后不可能执行的传输时，会返回此错误。适用于 FILE、FTP 或 SFTP。
- en: Couldn't read the given file when using the FILE:// scheme. Failed to open the
    file. The file could be non-existing or is it a permission problem perhaps?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 FILE:// 方案时无法读取给定的文件。打开文件失败。该文件可能不存在，或者可能是权限问题？
- en: LDAP cannot bind. LDAP "bind" operation failed, which is a necessary step in
    the LDAP operation and thus this means the LDAP query could not be performed.
    This might happen because of wrong username or password, or for other reasons.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LDAP 无法绑定。LDAP "bind" 操作失败，这是 LDAP 操作中必要的一步，因此这意味着无法执行 LDAP 查询。这可能是因为用户名或密码错误，或者其他原因。
- en: LDAP search failed. The given search terms caused the LDAP search to return
    an error.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LDAP搜索失败。给定的搜索条件导致LDAP搜索返回错误。
- en: '**Not used**'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: '**Not used**'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: Aborted by callback. An application told libcurl to abort the operation. This
    error code is not generally made visible to users and not to users of the curl
    tool.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过回调中止。应用程序告诉libcurl中止操作。此错误代码通常不向用户显示，也不向curl工具的用户显示。
- en: Bad function argument. A function was called with a bad parameter - this return
    code is present to help application authors to understand why libcurl can't perform
    certain actions and should never be return by the curl tool. Please file a bug
    report to the curl project if this happens to you!
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数参数错误。调用函数时使用了错误的参数-此返回代码存在是为了帮助应用程序作者理解为什么libcurl无法执行某些操作，并且永远不应由curl工具返回。如果发生这种情况，请向curl项目提交错误报告！
- en: '**Not used**'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: Interface error. A specified outgoing network interface could not be used. curl
    will typically decide outgoing network and IP addresses by itself but when explicitly
    asked to use a specific one that curl can't use, this error can occur.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 界面错误。无法使用指定的出站网络接口。curl通常会自行决定出站网络和IP地址，但当明确要求使用curl无法使用的特定接口时，可能会出现此错误。
- en: '**Not used**'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: Too many redirects. When following HTTP redirects, libcurl hit the maximum number
    set by the application. The maximum number of redirects is unlimited by libcurl
    but is set to 50 by default by the curl tool. The limit is present to stop endless
    redirect loops. Change the limit with `--max-redirs`.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重定向次数过多。在遵循HTTP重定向时，libcurl达到了应用程序设置的最大数量。libcurl的重定向次数上限由libcurl无限制，但是默认情况下由curl工具设置为50。该限制存在是为了阻止无限重定向循环。使用`--max-redirs`更改限制。
- en: 'Unknown option specified to libcurl. This could happen if you use a curl version
    that is out of sync with the underlying libcurl version. Perhaps your newer curl
    tries to use an option in the older libcurl that wasn''t introduced until after
    the libcurl version you''re using but is known to your curl tool code as that
    is newer. To decrease the risk of this and make sure it doesn''t happen: use curl
    and libcurl of the same version number.'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定给libcurl的选项未知。如果您使用的curl版本与底层libcurl版本不同步，可能会发生这种情况。也许您较新的curl尝试使用较旧的libcurl中未引入的选项，但是对您的curl工具代码来说是较新的。为了减少这种情况发生的风险并确保不会发生：使用相同版本号的curl和libcurl。
- en: Malformed telnet option. The telnet options you provide to curl was not using
    the correct syntax.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式错误的telnet选项。您提供给curl的telnet选项未使用正确的语法。
- en: '**Not used**'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: The server's SSL/TLS certificate or SSH fingerprint failed verification. curl
    can then not be sure of the server being who it claims to be. See the [using TLS
    with curl](usingcurl-tls.html) section for more TLS details and [using SCP and
    SFTP with curl](usingcurl-scpsftp.html) for more SSH specific details.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器的SSL/TLS证书或SSH指纹验证失败。curl随后无法确定服务器是否是其声称的那样。请参阅[使用TLS与curl](usingcurl-tls.html)部分了解更多TLS详细信息和[使用curl进行SCP和SFTP](usingcurl-scpsftp.html)以获取更多SSH特定详细信息。
- en: The server didn't reply anything, which in this context is considered an error.
    When a HTTP(S) server responds to a HTTP(S) request, it will always return *something*
    as long as it is alive and sound. All valid HTTP responses have a status line
    and responses header. Not getting anything at all back is an indication the server
    is faulty or perhaps that something prevented curl from reaching the right server
    or that you're trying to connect to the wrong port number etc.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器未回复任何内容，在此上下文中被视为错误。当HTTP(S)服务器响应HTTP(S)请求时，只要它处于活动和正常状态，它就会始终返回*某些内容*。所有有效的HTTP响应都有状态行和响应标头。根本没有得到任何回复表明服务器存在故障，或者可能有些事情阻止了curl访问正确的服务器，或者您试图连接到错误的端口号等。
- en: SSL crypto engine not found.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未找到SSL加密引擎。
- en: Cannot set SSL crypto engine as default.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法将SSL加密引擎设置为默认。
- en: Failed sending network data. Sending data over the network is a crucial part
    of most curl operations and when curl gets an error from the lowest networking
    layers that the sending failed, this exit status gets returned. To pinpoint why
    this happens, some serious digging is usually required. Start with enabling verbose
    mode, do tracing and if possible check the network traffic with a tool like Wireshark
    or similar.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送网络数据失败。在大多数curl操作中，发送数据到网络是至关重要的一部分，当curl从最低网络层收到发送失败的错误时，将返回此退出状态。要找出发生这种情况的原因，通常需要进行严格的挖掘。首先启用详细模式，进行跟踪，如果可能的话使用诸如Wireshark之类的工具检查网络流量。
- en: Failure in receiving network data. Receiving data over the network is a crucial
    part of most curl operations and when curl gets an error from the lowest networking
    layers that the receiving of data failed, this exit status gets returned. To pinpoint
    why this happens, some serious digging is usually required. Start with enabling
    verbose mode, do tracing and if possible check the network traffic with a tool
    like Wireshark or similar.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收网络数据失败。从网络接收数据是大多数 curl 操作的关键部分，当 curl 从最低网络层收到数据接收失败的错误时，将返回此退出状态。要找出原因，通常需要进行深入挖掘。首先启用详细模式，进行跟踪，如果可能的话，使用
    Wireshark 或类似工具检查网络流量。
- en: '**Not used**'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: Problem with the local certificate. The client certificate had a problem so
    it couldn't be used. Permissions? The wrong pass phrase?
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地证书存在问题。客户端证书存在问题，因此无法使用。权限？密码错误？
- en: Couldn't use the specified SSL cipher.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法使用指定的 SSL 密码。
- en: Peer certificate cannot be authenticated with known CA certificates.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对等证书无法使用已知 CA 证书进行身份验证。
- en: Unrecognized transfer encoding.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法识别的传输编码。
- en: Invalid LDAP URL.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无效的 LDAP URL。
- en: Maximum file size exceeded.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超过最大文件大小限制。
- en: Requested FTP SSL level failed.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求的FTP SSL级别失败。
- en: Sending the data requires a rewind that failed.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送数据需要失败的倒带。
- en: Failed to initialize SSL Engine.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法初始化 SSL 引擎。
- en: The user name, password, or similar was not accepted and curl failed to log
    in.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户名、密码或类似信息未被接受，curl 登录失败。
- en: File not found on TFTP server.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 TFTP 服务器上找不到文件。
- en: Permission problem on TFTP server.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TFTP 服务器上的权限问题。
- en: Out of disk space on TFTP server.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TFTP 服务器上的磁盘空间不足。
- en: Illegal TFTP operation.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非法的TFTP操作。
- en: Unknown TFTP transfer ID.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未知的 TFTP 传输 ID。
- en: File already exists (TFTP).
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件已存在（TFTP）。
- en: No such user (TFTP).
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不存在此用户（TFTP）。
- en: Character conversion failed.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符转换失败。
- en: Character conversion functions required.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要字符转换函数。
- en: Problem with reading the SSL CA cert
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 SSL CA 证书时出现问题
- en: The resource referenced in the URL does not exist.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL 中引用的资源不存在。
- en: An unspecified error occurred during the SSH session.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH 会话期间发生未指定的错误。
- en: Failed to shut down the SSL connection.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法关闭 SSL 连接。
- en: '**Not used**'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用**'
- en: Could not load CRL file, missing or wrong format
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法加载 CRL 文件，缺失或格式错误
- en: TLS certificate issuer check failed
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TLS 证书颁发者检查失败
- en: The FTP PRET command failed
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP PRET 命令失败
- en: 'RTSP: mismatch of CSeq numbers'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTSP：CSeq 数字不匹配
- en: 'RTSP: mismatch of Session Identifiers'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTSP：会话标识符不匹配
- en: unable to parse FTP file list
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法解析 FTP 文件列表
- en: FTP chunk callback reported error
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP块回调报告错误
- en: No connection available, the session will be queued
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有可用连接，会将会话排队
- en: SSL public key does not matched pinned public key
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSL 公钥与固定公钥不匹配
- en: Error message
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误消息
- en: When curl exits with a non-zero code, it will also output an error message (unless
    `--silent` is used). That error message may add some additional information or
    circumstances to the exit status number itself so the same error number can get
    different error messages.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当 curl 以非零代码退出时，它还将输出错误消息（除非使用 `--silent`）。该错误消息可能会为退出状态数字本身添加一些额外信息或情况，因此相同的错误号可能会有不同的错误消息。
- en: '"Not used"'
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"未使用"'
- en: The list of exit codes above contains a number of values marked as 'not used'.
    Those are exit status codes that aren't used in modern versions of curl but that
    have been used or were intended to be used in the past. They may very well be
    used in a future version of curl.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的退出代码列表中包含一些标记为“未使用”的值。这些是在现代版本的 curl 中未使用的退出状态代码，但在过去曾被使用或打算使用。它们很可能会在未来的
    curl 版本中使用。
- en: Additionally, the highest used error status in this list is 90, but there is
    no guarantee that a future curl version won't decide to add more exit codes after
    that number.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中使用的最高错误状态是 90，但不能保证未来的 curl 版本不会决定在该数字之后添加更多的退出代码。
- en: FTP
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP
- en: FTP
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP
- en: FTP, the File Transfer Protocol, is probably the oldest network protocol that
    curl supports—it was created in the early 1970s. The official spec that still
    is the go-to documentation is [RFC 959](http://www.ietf.org/rfc/rfc959.txt), from
    1985, published well over a decade before the first curl release.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: FTP，文件传输协议，可能是 curl 支持的最古老的网络协议 —— 它是在 1970 年代初创建的。仍然是首选文档的官方规范是 [RFC 959](http://www.ietf.org/rfc/rfc959.txt)，于
    1985 年发布，比第一个 curl 发布版本早十多年。
- en: FTP was created in a different era of the Internet and computers and as such
    it works a little bit differently than most other protocols. These differences
    can often be ignored and things will just work, but they are also important to
    know at times when things don't run as planned.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: FTP是在互联网和计算机不同时代创建的，因此它的工作方式与大多数其他协议有些不同。这些差异通常可以忽略，事情会正常运行，但在计划外情况下，了解这些差异也很重要。
- en: Ping-pong
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ping-pong
- en: The FTP protocol is a command and response protocol; the client sends a command
    and the server responds. If you use curl's `-v` option you will get to see all
    the commands and responses during a transfer.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: FTP协议是一种命令和响应协议；客户端发送一个命令，服务器响应。如果您使用curl的`-v`选项，您将在传输过程中看到所有命令和响应。
- en: For an ordinary transfer, there are something like 5 to 8 commands necessary
    to send and as many responses to wait for and read. Perhaps needlessly to say,
    if the server is in a remote location there will be a lot of time waiting for
    the ping pong to go through before the actual file transfer can be set up and
    get started. For small files, the initial commands can very well take longer time
    than the actual data transfer.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通的传输，通常需要5到8个命令来发送，以及同样数量的响应需要等待和读取。也许不用说，如果服务器在远程位置，那么在实际文件传输开始之前，会有很多时间等待ping
    pong通过。对于小文件来说，初始命令可能比实际数据传输花费的时间还要长。
- en: Transfer mode
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输模式
- en: When an FTP client is about to transfer data, it specifies to the server which
    "transfer mode" it would like the upcoming transfer to use. The two transfer modes
    curl supports are 'ASCII' and 'BINARY'. Ascii is basically for text and usually
    means that the server will send the files with converted newlines while binary
    means sending the data unaltered and assuming the file is not text.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 当FTP客户端准备传输数据时，它会告诉服务器希望使用哪种“传输模式”进行即将到来的传输。curl支持的两种传输模式是'ASCII'和'BINARY'。ASCII基本上用于文本，通常意味着服务器将发送转换后的换行符文件，而二进制意味着发送未更改的数据，并假定文件不是文本。
- en: curl will default to binary transfer mode for FTP, and you ask for ascii mode
    instead with `-B, --use-ascii` or by making sure the URL ends with `;type=A`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: curl在FTP上默认使用二进制传输模式，您可以使用`-B, --use-ascii`要求使用ASCII模式，或者确保URL以`;type=A`结尾。
- en: Authentication
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: FTP is one of the protocols you normally don't access without a user name and
    password. It just happens that for systems that allow "anonymous" FTP access you
    can login with pretty much any name and password you like. When curl is used on
    an FTP URL to do transfer without any given user name or password, it uses the
    name `anonymous` with the password `ftp@example.com`.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: FTP是您通常不会在没有用户名和密码的情况下访问的协议之一。恰好对于允许“匿名”FTP访问的系统，您可以使用几乎任何名称和密码登录。当在FTP URL上使用curl进行没有给定用户名或密码的传输时，它将使用名称`anonymous`和密码`ftp@example.com`。
- en: 'If you want to provide another user name and password, you can pass them on
    to curl either with the `-u, --user` option or embed the info in the URL:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想提供另一个用户名和密码，可以使用`-u, --user`选项将它们传递给curl，或者将信息嵌入在URL中：
- en: curl --user daniel:secret ftp://example.com/download
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: curl --user daniel:secret ftp://example.com/download
- en: curl ftp://daniel:secret@example.com/download
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: curl ftp://daniel:secret@example.com/download
- en: Two connections
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个连接
- en: FTP uses two connections
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP使用两个连接
- en: FTP uses two TCP connections! The first connection is setup by the client when
    it connects to an FTP server, and is called the *control connection*. As the initial
    connection, it gets to handle authentication and changing to the correct directory
    on the remote server, etc. When the client then is ready to transfer a file, a
    second TCP connection is established and the data is transferred over that.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: FTP使用两个TCP连接！第一个连接由客户端在连接到FTP服务器时建立，称为*控制连接*。作为初始连接，它负责身份验证和切换到远程服务器上的正确目录等。当客户端准备传输文件时，将建立第二个TCP连接，并通过该连接传输数据。
- en: This setting up of a second connection causes nuisances and headaches for several
    reasons.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 建立第二个连接会因为几个原因而引起麻烦和头痛。
- en: Active connections
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动连接
- en: 'The client can opt to ask the server to connect to the client to set it up,
    a so-called "active" connection. This is done with the PORT or EPRT commands.
    Allowing a remote host to connect back to a client on a port that the client opens
    up requires that there''s no firewall or other network appliance in between that
    refuses that to go through and that is far from always the case. You ask for an
    active transfer using `curl -P [arg]` (also known as `--ftp-port` in long form)
    and while the option allows you to specify exactly which address to use, just
    setting the same as you come from is almost always the correct choice and you
    do that with `-P -`, like this way to ask for a file:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You can also explicitly ask curl to not use EPRT (which is a slightly newer
    command than PORT) with the `--no-eprt` command-line option.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Passive connections
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Curl defaults to asking for a "passive" connection, which means it sends a PASV
    or EPSV command to the server and then the server opens up a new port for the
    second connection that then curl connects to. Outgoing connections to a new port
    are generally easier and less restricted for end users and clients, but it then
    requires that the network in the server's end allows it.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Passive connections are enabled by default, but if you have switched on active
    before, you can switch back to passive with `--ftp-pasv`.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: You can also explicitly ask curl not to use EPSV (which is a slightly newer
    command than PASV) with the `--no-epsv` command-line option.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the server is running a funky setup so that when curl issues the PASV
    command and the server responds with an IP address for curl to connect to, that
    address is wrong and then curl fails to setup the data connection. For this (hopefully
    rare) situation, you can ask curl to ignore the IP address mentioned in the PASV
    response (`--ftp-skip-pasv-ip`) and instead use the same IP address it has for
    the control connection even for the second connection.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Firewall issues
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using either active or passive transfers, any existing firewalls in the network
    path pretty much have to have stateful inspection of the FTP traffic to figure
    out the new port to open that up and accept it for the second connection.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Directory traversing
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to traverse directories
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When doing FTP commands to traverse the remote file system, there are a few
    different ways curl can proceed to reach the target file, the file the user wants
    to transfer.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: multicwd
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'curl can do one change directory (CWD) command for every individual directory
    down the file tree hierarchy. If the full path is `one/two/three/file.txt`, that
    method means doing three `CWD` commands before asking for the `file.txt` file
    to get transferred. This method thus creates quite a large number of commands
    if the path is many levels deep. This method is mandated by an early spec (RFC
    1738) and is how curl acts by default:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This then equals this FTP command/response sequence (simplified):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: nocwd
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The opposite to doing one CWD for each directory part is to not change the
    directory at all. This method asks the server using the entire path at once and
    is thus very fast. Occasionally servers have a problem with this and it isn''t
    purely standards-compliant:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个目录部分执行一个 CWD 的相反方法是根本不更改目录。此方法一次性使用整个路径询问服务器，因此非常快速。偶尔服务器可能会有问题，而且它并非纯粹符合标准：
- en: '[PRE66]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This then equals this FTP command/response sequence (simplified):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这等于这个 FTP 命令/响应序列（简化）：
- en: '[PRE67]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: singlecwd
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单个目录
- en: 'This is the in-between the other two FTP methods. This makes a single `CWD`
    command to the target directory and then it asks for the given file:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其他两种 FTP 方法之间的中间方法。它对目标目录执行单个 `CWD` 命令，然后请求给定的文件：
- en: '[PRE68]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This then equals this FTP command/response sequence (simplified):'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这等于这个 FTP 命令/响应序列（简化）：
- en: '[PRE69]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Advanced FTP use
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 FTP 使用
- en: More advanced FTP
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的 FTP
- en: FTP Directory listing
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP 目录列表
- en: You can list a remote FTP directory with curl by making sure the URL ends with
    a trailing slash. If the URL ends with a slash, curl will presume that it is a
    directory you want to list. If it isn't actually a directory, you will most likely
    instead get an error.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过确保 URL 以斜杠结尾来使用 curl 列出远程 FTP 目录。如果 URL 以斜杠结尾，curl 将假定您要列出的是目录。如果实际上不是目录，您很可能会得到一个错误。
- en: '[PRE70]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With FTP there is no standard syntax for the directory output that is returned
    for this sort of command that uses the standard FTP command `LIST`. The listing
    is usually humanly readable and perfectly understandable but you will see that
    different servers will return the listing in slightly different ways.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FTP 时，对于使用标准 FTP 命令 `LIST` 的此类命令返回的目录输出，没有标准语法。列表通常是可读的和易于理解的，但您会发现不同的服务器会以稍微不同的方式返回列表。
- en: 'One way to get just a listing of all the names in a directory and thus to avoid
    the special formatting of the regular directory listings is to tell curl to `--list-only`
    (or just `-l`). curl then issues the `NLST` FTP command instead:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取目录中所有名称的列表，从而避免常规目录列表的特殊格式化，一种方法是告诉 curl 使用 `--list-only`（或者只用 `-l`）。curl
    然后发出 `NLST` FTP 命令：
- en: '[PRE71]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: NLST has its own quirks though, as some FTP servers list only actual *files*
    in their response to NLST; they do not include directories and symbolic links!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，NLST 也有其自己的怪癖，因为一些 FTP 服务器在响应 NLST 时仅列出实际的 *文件*；它们不包括目录和符号链接！
- en: Uploading with FTP
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 FTP 上传
- en: To upload to an FTP server, you specify the entire target file path and name
    in the URL, and you specify the local file name to upload with `-T, --upload-file`.
    Optionally, you end the target URL with a slash and then the file component from
    the local path will be appended by curl and used as the remote file name.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 要上传到 FTP 服务器，您在 URL 中指定整个目标文件路径和名称，并使用 `-T, --upload-file` 指定要上传的本地文件名。可选地，您可以在目标
    URL 末尾加上斜杠，然后 curl 将附加本地路径的文件组件，并将其用作远程文件名。
- en: 'Like:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样：
- en: '[PRE72]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'or to use the local file name as the remote name:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 或者将本地文件名用作远程文件名：
- en: '[PRE73]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'curl also supports [globbing](cmdline-globbing.html) in the -T argument so
    you can opt to easily upload a range or a series of files:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: curl 还支持在 `-T` 参数中使用 [通配符](cmdline-globbing.html)，因此您可以选择轻松上传一系列文件或文件：
- en: '[PRE74]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: or
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE75]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Custom FTP commands
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 FTP 命令
- en: TBD
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: FTPS
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTPS
- en: TBD
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Common FTP problems
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的 FTP 问题
- en: TBD
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: SCP and SFTP
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SCP 和 SFTP
- en: SCP and SFTP
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SCP 和 SFTP
- en: curl supports the SCP and SFTP protocols if built with the correct prerequisite
    3rd party library, [libssh2](https://www.libssh2.org/).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用正确的先决条件第三方库 [libssh2](https://www.libssh2.org/) 构建，curl 支持 SCP 和 SFTP 协议。
- en: SCP and SFTP are both protocols that are built on top of SSH, a secure and encrypted
    data protocol that is similar to TLS but differs in a few important ways. For
    example, SSH doesn't use certificates of any sort but instead it uses public and
    private keys. Both SSH and TLS provide strong crypto and secure transfers when
    used correctly.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: SFTP 和 SCP 都是构建在 SSH 之上的协议，SSH 是一种安全的加密数据协议，类似于 TLS，但在某些重要方面有所不同。例如，SSH 不使用任何证书，而是使用公钥和私钥。当正确使用时，SSH
    和 TLS 都提供强大的加密和安全传输。
- en: The SCP protocol is generally considered to be the black sheep of the two since
    it isn't very portable and usually only works between Unix systems.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 两者中的 SCP 协议通常被认为是黑羊，因为它不太可移植，通常只在 Unix 系统之间工作。
- en: URLs
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网址
- en: 'SFTP and SCP URLs are similar to other URLs and you download files using these
    protocols the same as with others:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: SFTP 和 SCP 的 URL 与其他 URL 类似，您可以像使用其他协议一样使用这些协议下载文件：
- en: '[PRE76]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'and:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 和：
- en: '[PRE77]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'SFTP (but not SCP) supports getting a file listing back when the URL ends with
    a trailing slash:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 当 URL 以斜杠结尾时，SFTP（但不包括 SCP）支持返回文件列表：
- en: '[PRE78]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that both these protocols work with "users" and you don't ask for a file
    anonymously or with a standard generic name. Most systems will require that users
    authenticate, as outlined below.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两种协议都与“用户”一起工作，您不会匿名请求文件或使用标准通用名称。大多数系统将要求用户进行身份验证，如下所述。
- en: When requesting a file from an SFTP or SCP URL, the file path given is considered
    to be the absolute path on the remote server unless you specifically ask for the
    path relative to the user's home directory. You do that by making sure the path
    starts with `/~/`. This is quite the opposite to how FTP URLs work and is a common
    cause for confusion among users.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 SFTP 或 SCP URL 请求文件时，除非您明确要求相对于用户主目录的路径，否则给定的文件路径被视为远程服务器上的绝对路径。您可以通过确保路径以`/~/`开头来做到这一点。这与
    FTP URL 的工作方式完全相反，这是用户常常感到困惑的常见原因。
- en: 'For user `daniel` to transfer `todo.txt` from his home directory, it would
    look similar to this:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户`daniel`从他的主目录传输`todo.txt`，看起来类似于这样：
- en: '[PRE79]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Auth
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证
- en: TBD
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Known hosts
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已知主机
- en: A secure network client needs to make sure that the remote host is exactly the
    host that it thinks it is communicating with. With TLS based protocols, it is
    done by the client verifying the server's certificate.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的网络客户端需要确保远程主机确实是它认为正在通信的主机。对于基于 TLS 的协议，客户端通过验证服务器的证书来实现这一点。
- en: With SSH protocols there are no server certificates, but instead each server
    can provide its unique key. And unlike TLS, SSH has no certificate authorities
    or anything so the client simply has to make sure that the host's key matches
    what it already knows (via other means) it should look like.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SSH 协议时没有服务器证书，而是每个服务器可以提供其唯一的密钥。与 TLS 不同，SSH 没有证书颁发机构或任何东西，因此客户端只需确保主机的密钥与其已知的（通过其他方式）相匹配即可。
- en: The matching of keys is typically done using hashes of the key and the file
    that the client stores the hashes for known servers is often called `known_hosts`
    and is put in a dedicated SSH directory. On Linux systems that is usually called
    `~/.ssh`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用密钥的匹配是使用密钥和客户端存储已知服务器哈希的文件的哈希来完成的，该文件通常称为`known_hosts`，并放在专用的 SSH 目录中。在
    Linux 系统上，通常称为`~/.ssh`。
- en: When curl connects to a SFTP and SCP host, it will make sure that the host's
    key hash is already present in the known hosts file or it will deny continued
    operation because it cannot trust that the server is the right one. Once the correct
    hash exists in `known_hosts` curl can perform transfers.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 当 curl 连接到 SFTP 和 SCP 主机时，它将确保主机的密钥哈希已经存在于已知主机文件中，否则它将拒绝继续操作，因为它无法信任服务器是否正确。一旦正确的哈希存在于`known_hosts`中，curl
    就可以执行传输。
- en: To force curl to skip checking and obeying to the the `known_hosts` file, you
    can use the `-k / --insecure` command-line option. You must use this option with
    extreme care since it makes it possible for man-in-the-middle attacks not to be
    detected.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制 curl 跳过检查并遵守`known_hosts`文件，您可以使用`-k / --insecure`命令行选项。您必须非常小心地使用此选项，因为它使得无法检测到中间人攻击。
- en: IMAP and POP3
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IMAP 和 POP3
- en: Reading email
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读电子邮件
- en: There are two dominant protocols on the Internet for reading/downloading email
    from servers (at least if we don't count web based reading), and they are IMAP
    and POP3\. The former being the slightly more modern alternative. curl supports
    both.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有两种主要的协议用于从服务器读取/下载电子邮件（至少在我们不考虑基于 Web 的阅读时），它们是 IMAP 和 POP3。前者是稍微现代化的选择。curl
    支持两者。
- en: POP3
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POP3
- en: 'To list message numbers and sizes:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出消息编号和大小：
- en: '[PRE80]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To download message 1:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载消息 1：
- en: '[PRE81]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To delete message 1:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除消息 1：
- en: '[PRE82]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: IMAP
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IMAP
- en: TBD
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: SMTP
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SMTP
- en: SMTP
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SMTP
- en: SMTP stands for [Simple Mail Transfer Protocol](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol).
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 代表 [简单邮件传输协议](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol)。
- en: curl supports sending data to a an SMTP server, which combined with the right
    set of command line options makes an email get sent to a set of receivers of your
    choice.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: curl 支持将数据发送到 SMTP 服务器，结合正确的一组命令行选项，可以将电子邮件发送到您选择的一组接收者。
- en: When sending SMTP with curl, there are a two necessary command line options
    that **must** be used.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 curl 发送 SMTP 时，有两个必须使用的命令行选项。
- en: You need to tell the server at least one recipient with `--mail-rcpt`. You can
    use this option several times and then curl will tell the server that all those
    email addresses should receive the email.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要使用`--mail-rcpt`告诉服务器至少一个收件人。你可以多次使用此选项，然后 curl 将告诉服务器所有这些电子邮件地址都应该收到邮件。
- en: You need to tell the server which email address that is the sender of the email
    with `--mail-from`. It is important to realize that this email address is not
    necessarily the same as is shown in the `From:` line of the email text.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要告诉服务器哪个电子邮件地址是邮件的发送者，使用`--mail-from`。重要的是要意识到，这个电子邮件地址不一定与邮件文本中的`From:`行显示的相同。
- en: Then, you need to provide the actual email data. This is a (text) file formatted
    according to [RFC 5322](https://tools.ietf.org/html/rfc5322.html). It is a set
    of headers and a body. Both the headers and the body need to be correctly encoded.
    The headers typically include `To:`, `From:`, `Subject:`, `Date:` etc.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要提供实际的电子邮件数据。这是一个按照[RFC 5322](https://tools.ietf.org/html/rfc5322.html)格式化的（文本）文件。它是一组标头和一个正文。标头和正文都需要正确编码。标头通常包括`To:`、`From:`、`Subject:`、`Date:`等。
- en: 'A basic command to send an email:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 发送邮件的基本命令：
- en: '[PRE83]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Example email.txt
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例邮件.txt
- en: '[PRE84]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Secure mail transfer
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全邮件传输
- en: Some mail providers allow or require using SSL for SMTP. They may use a dedicated
    port for SSL or allow SSL upgrading over a plaintext connection.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 一些邮件提供商允许或要求使用 SSL 进行 SMTP。它们可能会使用专用的 SSL 端口，也可能允许在明文连接上升级 SSL。
- en: If your mail provider has a dedicated SSL port you can use smtps:// instead
    of smtp://, which uses the SMTP SSL port of 465 by default and requires the entire
    connection to be SSL. For example smtps://smtp.gmail.com/.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的邮件提供商有一个专用的 SSL 端口，你可以使用 smtps:// 而不是 smtp://，它默认使用 SMTP SSL 端口465，并且需要整个连接都是
    SSL。例如 smtps://smtp.gmail.com/。
- en: 'However, if your provider allows upgrading from plaintext to secure transfers
    you can use one of these options:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您的提供商允许从明文升级到安全传输，则可以使用以下选项之一：
- en: '[PRE85]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You can tell curl to *try* but not require upgrading to secure transfers by
    adding `--ssl` to the command:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在命令中添加`--ssl`来告诉 curl *尝试* 但不要求升级到安全传输：
- en: '[PRE86]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can tell curl to *require* upgrading to using secure transfers by adding
    `--ssl-reqd` to the command:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在命令中添加`--ssl-reqd`来告诉 curl *需要* 升级到使用安全传输：
- en: '[PRE87]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The SMTP URL
  id: totrans-664
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SMTP URL
- en: The path part of a SMTP request specifies the host name to present during communication
    with the mail server. If the path is omitted then curl will attempt to figure
    out the local computer's host name and use that. However, this may not return
    the fully qualified domain name that is required by some mail servers and specifying
    this path allows you to set an alternative name, such as your machine's fully
    qualified domain name, which you might have obtained from an external function
    such as gethostname or getaddrinfo.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 请求的路径部分指定了在与邮件服务器通信期间要呈现的主机名。如果省略了路径，则 curl 将尝试找出本地计算机的主机名并使用该主机名。但是，这可能不会返回一些邮件服务器所需的完全限定域名，并且指定此路径允许您设置另一个名称，例如您的机器的完全限定域名，您可能已经从
    gethostname 或 getaddrinfo 等外部函数获取到。
- en: 'To connect to the mail server at `mail.example.com` and send your local computer''s
    host name in the HELO / EHLO command:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到`mail.example.com`的邮件服务器，并在 HELO / EHLO 命令中发送你本地计算机的主机名：
- en: '[PRE88]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You can of course as always use the `-v` option to get to see the client-server
    communication.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你始终可以使用 `-v` 选项来查看客户端和服务器的通信。
- en: 'To instead have curl send `client.example.com` in the `HELO` / `EHLO` command
    to the mail server at `mail.example.com`, use:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果要 curl 在`HELO` / `EHLO` 命令中发送`client.example.com`到`mail.example.com`的邮件服务器，请使用：
- en: '[PRE89]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: No MX lookup!
  id: totrans-671
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有 MX 查找！
- en: When you send email with an ordinary mail client, it will first check for an
    MX record for the particular domain you want to send email to. If you send an
    email to joe@example.com, the client will get the MX records for `example.com`
    to learn which mail server(s) to use when sending email to example.com users.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用普通邮件客户端发送邮件时，它首先会检查你要发送邮件到的特定域的 MX 记录。如果你发送邮件给 joe@example.com，客户端将获取`example.com`的
    MX 记录，以了解发送邮件给 example.com 用户时要使用哪些邮件服务器。
- en: curl does no MX lookups by itself. If you want to figure out which server to
    send an email to for a particular domain, we recommend you figure that out first
    and then call curl to use those servers. Useful command line tools to get MX records
    with include 'dig' and 'nslookup'.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: curl 本身不执行 MX 查找。如果你想弄清楚发送邮件给特定域名的服务器，我们建议你先弄清楚这一点，然后调用 curl 使用这些服务器。获取 MX 记录的有用命令行工具包括
    'dig' 和 'nslookup'。
- en: TELNET
  id: totrans-674
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TELNET
- en: TELNET
  id: totrans-675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TELNET
- en: TBD
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: TLS
  id: totrans-677
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS
- en: TLS
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS
- en: TLS stands for Transport Layer Security and is the name for the technology that
    was formerly called SSL. The term SSL hasn't really died though so these days
    both the terms TLS and SSL are often used interchangeably to describe the same
    thing.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 代表传输层安全性，是以前称为 SSL 的技术的名称。虽然 SSL 这个术语并没有真正消失，但如今 TLS 和 SSL 这两个术语通常可互换使用，用来描述相同的事物。
- en: TLS is a cryptographic security layer "on top" of TCP that makes the data tamper
    proof and guarantees server authenticity, based on strong public key cryptography
    and digital signatures.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 是 TCP 的加密安全层，使数据防篡改，并基于强大的公钥密码学和数字签名保证服务器的真实性。
- en: Ciphers
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码
- en: When curl connections to a TLS server, it negotiates how to speak the protocol
    and that negotiation involves several parameters and variables that both parties
    need to agree to. One of the parameters is which cryptography algorithms to use,
    the so called cipher. Over time, security researchers figure out flaws and weaknesses
    in existing ciphers and they are gradually phased out over time.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 当 curl 连接到 TLS 服务器时，它会协商如何使用协议，这个协商涉及到双方需要达成一致的几个参数和变量。其中一个参数是使用哪些加密算法，即所谓的密码。随着时间的推移，安全研究人员发现了现有密码的缺陷和弱点，并逐渐淘汰了它们。
- en: Using the verbose option, `-v`, you can get information about which cipher and
    TLS version are negotiated. By using the `--ciphers` option, you can change what
    cipher to prefer in the negotiation, but mind you, this is a power feature that
    takes knowledge to know how to use in ways that don't just make things worse.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 使用详细选项 `-v`，你可以获取关于协商了哪种密码和 TLS 版本的信息。通过使用 `--ciphers` 选项，你可以更改协商中首选的密码，但请注意，这是一个强大的功能，需要知道如何使用，以避免让事情变得更糟。
- en: Enable TLS
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 TLS
- en: curl supports the TLS version of many protocols. HTTP has HTTPS, FTP has FTPS,
    LDAP has LDAPS, POP3 has POP3S, IMAP has IMAPS and SMTP has SMTPS.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: curl 支持许多协议的 TLS 版本。HTTP 有 HTTPS，FTP 有 FTPS，LDAP 有 LDAPS，POP3 有 POP3S，IMAP 有
    IMAPS，SMTP 有 SMTPS。
- en: If the server side supports it, you can use the TLS version of these protocols
    with curl.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器端支持，你可以使用 curl 来使用这些协议的 TLS 版本。
- en: There are two general approaches to do TLS with protocols. One of them is to
    speak TLS already from the first connection handshake while the other is to "upgrade"
    the connection from plain-text to TLS using protocol specific instructions.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种一般方法来使用协议进行 TLS。其中一种是在第一次连接握手时就开始使用 TLS，而另一种是使用协议特定的指令将连接从纯文本升级到 TLS。
- en: With curl, if you explicitly specify the TLS version of the protocol (the one
    that has a name that ends with an 'S' character) in the URL, curl will try to
    connect with TLS from start, while if you specify the non-TLS version in the URL
    you can *usually* upgrade the connection to TLS-based with the `--ssl` option.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 curl，如果在 URL 中明确指定了协议的 TLS 版本（以 'S' 字符结尾的版本），curl 将尝试从一开始就使用 TLS 连接，而如果在
    URL 中指定了非 TLS 版本，则通常可以使用 `--ssl` 选项将连接升级到基于 TLS 的版本。
- en: 'The support table looks like this:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 支持表格如下：
- en: '| Clear | TLS version | --ssl |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| 清除 | TLS 版本 | --ssl |'
- en: '| --- | --- | --- |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| HTTP | HTTPS | no |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| HTTP | HTTPS | 否 |'
- en: '| LDAP | LDAPS | no |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| LDAP | LDAPS | 否 |'
- en: '| FTP | FTPS | **yes** |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| FTP | FTPS | **是** |'
- en: '| POP3 | POP3S | **yes** |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| POP3 | POP3S | **是** |'
- en: '| IMAP | IMAPS | **yes** |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| IMAP | IMAPS | **是** |'
- en: '| SMTP | SMTPS | **yes** |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| SMTP | SMTPS | **是** |'
- en: The protocols that *can* do `--ssl` all favor that method. Using `--ssl` means
    that curl will *attempt* to upgrade the connection to TLS but if that fails, it
    will still continue with the transfer using the plain-text version of the protocol.
    To make the `--ssl` option **require** TLS to continue, there's instead the `--ssl-reqd`
    option which will make the transfer fail if curl cannot successfully negotiate
    TLS.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可以使用 `--ssl` 的协议都倾向于使用该方法。使用 `--ssl` 意味着 curl 将尝试将连接升级到 TLS，但如果失败，它仍将继续使用协议的纯文本版本进行传输。要使
    `--ssl` 选项**要求**使用 TLS 继续，而不是继续传输，可以使用 `--ssl-reqd` 选项，如果 curl 无法成功协商 TLS，则传输将失败。
- en: 'Require TLS security for your FTP transfer:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 要求 FTP 传输使用 TLS 安全性：
- en: '[PRE90]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Suggest TLS to be used for your FTP transfer:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用 TLS 来进行 FTP 传输：
- en: '[PRE91]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Connecting directly with TLS (to HTTPS://, LDAPS://, FTPS:// etc) means that
    TLS is mandatory and curl will return an error if TLS isn't negotiated.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用 TLS 进行连接（到 HTTPS://、LDAPS://、FTPS:// 等）意味着 TLS 是强制性的，如果 TLS 没有被协商，curl
    将返回错误。
- en: 'Get a file over HTTPS:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 HTTPS 上的文件：
- en: '[PRE92]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: SSL and TLS versions
  id: totrans-706
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL 和 TLS 版本
- en: SSL was invented in the mid 90s and has developed ever since. SSL version 2
    was the first widespread version used on the Internet but that was deemed insecure
    already a very long time ago. SSL version 3 took over from there, and it too has
    been deemed not safe enough for use.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 是在90年代中期发明的，并一直在发展。SSL 版本 2 是第一个广泛用于互联网的版本，但很久以前就被认为不安全了。SSL 版本 3 接替了它，但也被认为不够安全，不能再使用了。
- en: TLS version 1.0 was the first "standard". RFC 2246 was published 1999\. After
    that, TLS 1.1 came and and in November 2016 TLS 1.2 is the gold standard. TLS
    1.3 is in the works and we expect to see it finalized and published as a standard
    by the IETF at some point during 2017.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 版本 1.0 是第一个“标准”。RFC 2246 于 1999 年发布。此后，TLS 1.1 出现了，在 2016 年 11 月，TLS 1.2
    成为了黄金标准。TLS 1.3 正在制定中，我们预计在 2017 年某个时候将其定稿并发布为标准。
- en: curl is designed to use a "safe version" of SSL/TLS by default. It means that
    it will not negotiate SSLv2 or SSLv3 unless specifically told to, and in fact
    several TLS libraries no longer provide support for those protocols so in many
    cases curl is not even able to speak those protocol versions unless you make a
    serious effort.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: curl 默认使用“安全版本”的SSL/TLS。这意味着它不会默认协商SSLv2或SSLv3，除非明确告知，事实上，一些TLS库不再支持这些协议，因此在许多情况下，curl
    甚至无法与这些协议版本通信，除非您做出认真的努力。
- en: '| Option | Use |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 用法 |'
- en: '| --- | --- |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| --sslv2 | SSL version 2 |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| --sslv2 | SSL 版本 2 |'
- en: '| --sslv3 | SSL version 3 |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| --sslv3 | SSL 版本 3 |'
- en: '| --tlsv1 | TLS >= version 1.0 |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| --tlsv1 | TLS >= 版本 1.0 |'
- en: '| --tlsv1.0 | TLS version 1.0 |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| --tlsv1.0 | TLS 版本 1.0 |'
- en: '| --tlsv1.1 | TLS version 1.1 |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| --tlsv1.1 | TLS 版本 1.1 |'
- en: '| --tlsv1.2 | TLS version 1.2 |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| --tlsv1.2 | TLS 版本 1.2 |'
- en: '| --tlsv1.3 | TLS version 1.3 |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| --tlsv1.3 | TLS 版本 1.3 |'
- en: '**NOTE:** TLS version 1.3 is only supported in selected very recent development
    versions of certain TLS libraries and requires curl 7.52.0 or later.'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**TLS 版本 1.3 仅在某些非常新的开发版本的特定TLS库中受支持，并且需要 curl 7.52.0 或更高版本。'
- en: Verifying server certificates
  id: totrans-720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证服务器证书
- en: Having a secure connection to a server is not worth a lot if you cannot also
    be certain that you are communicating with the **correct** host. If we don't know
    that, we could just as well be talking with an impostor that just *appears* to
    be who we think it is.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能确信自己正在与**正确**的主机通信，那么与服务器建立安全连接就没有多大意义。如果我们不知道这一点，我们可能会与一个冒充者交谈，他只是*看起来*像我们认为的那个人。
- en: To check that it communicates with the right TLS server, curl uses a set of
    locally stored CA certificates to verify the signature of the server's certificate.
    All servers provide a certificate to the client as part of the TLS handshake and
    all public TLS-using servers have acquired that certificate from an established
    Certificate Authority.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查它是否与正确的TLS服务器通信，curl使用一组本地存储的CA证书来验证服务器证书的签名。所有服务器都会在TLS握手的一部分向客户端提供证书，所有公共TLS服务器都从已建立的证书颁发机构获得该证书。
- en: After some applied crypto magic, curl knows that the server is in fact the correct
    one that acquired that certificate for the host name that curl used to connect
    to it. Failing to verify the server's certificate is a TLS handshake failure and
    curl exits with an error.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些应用密码学的魔法，curl 知道服务器实际上是为 curl 用于连接的主机名获取了该证书的正确证书。未能验证服务器的证书是 TLS 握手失败，curl
    将以错误退出。
- en: In rare circumstances, you may decide that you still want to communicate with
    a TLS server even if the certificate verification fails. You then accept the fact
    that your communication may be subject to Man-In-The-Middle attacks. You lower
    your guards with the `-k` or `--insecure` option.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，您可能会决定即使证书验证失败也要与TLS服务器通信。然后您接受这样一个事实，即您的通信可能会受到中间人攻击的影响。您可以使用 `-k`
    或 `--insecure` 选项降低您的警惕。
- en: CA store
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CA存储
- en: curl needs a "CA store", a collection of CA certificates, to verify the TLS
    server it talks to.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: curl 需要一个“CA存储”，即一组CA证书，来验证其所通信的TLS服务器。
- en: If curl is built to use a TLS library that is "native" to your platform, chances
    are that library will use the native CA store as well. If not, curl has to either
    have been built to know where the local CA store is, or users need to provide
    a path to the CA store when curl is invoked.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 curl 构建为使用与您的平台“本机”相对应的TLS库，则该库很可能也会使用本机 CA 存储。如果不是，则 curl 必须已经构建以了解本地 CA
    存储的位置，或者在调用 curl 时用户需要提供 CA 存储的路径。
- en: You can point out a specific CA bundle to use in the TLS handshake with the
    `--cacert` command line option. That bundle needs to be in PEM format. You can
    also set the environment variable `CURL_CA_BUNDLE` to the full path.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `--cacert` 命令行选项指定要在 TLS 握手中使用的特定 CA 捆绑包。该捆绑包必须采用 PEM 格式。您还可以将环境变量 `CURL_CA_BUNDLE`
    设置为完整路径。
- en: CA store on windows
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 上的 CA 存储
- en: curl built on windows that isn't using the native TLS library (Schannel), have
    an extra sequence for how the CA store can be found and used.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上构建的 curl 如果没有使用本机 TLS 库（Schannel），则有一个额外的序列来确定和使用 CA 存储库。
- en: 'curl will search for a CA cert file named "curl-ca-bundle.crt" in these directories
    and in this order:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: curl 将按照以下顺序在这些目录中搜索名为 "curl-ca-bundle.crt" 的 CA 证书文件：
- en: application's directory
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序目录
- en: current working directory
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前工作目录
- en: Windows System directory (e.g. `C:\windows\system32`)
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows 系统目录（例如 `C:\windows\system32`）
- en: Windows Directory (e.g. `C:\windows`)
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows 目录（例如 `C:\windows`）
- en: all directories along `%PATH%`
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿着 `%PATH%` 的所有目录
- en: Certificate pinning
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书固定
- en: TLS certificate pinning is a way to verify that the public key used to sign
    the servers certificate has not changed. It is "pinned".
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 证书固定是一种验证服务器证书签名所使用的公钥是否已更改的方法。它被"固定"。
- en: When negotiating a TLS or SSL connection, the server sends a certificate indicating
    its identity. A public key is extracted from this certificate and if it does not
    exactly match the public key provided to this option, curl will abort the connection
    before sending or receiving any data.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在协商 TLS 或 SSL 连接时，服务器会发送一个指示其身份的证书。从此证书中提取公钥，如果它与提供给此选项的公钥不完全匹配，则 curl 将在发送或接收任何数据之前中止连接。
- en: You tell curl a file name to read the sha256 value from, or you specify the
    base64 encoded hash directly in the command line with a "sha256//" prefix. You
    can specify one or more hashes like that, separated with semicolons (;).
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以告诉 curl 从文件名中读取 sha256 值，或者您可以直接在命令行中使用"sha256//"前缀指定 base64 编码的哈希。您可以使用分号（;）分隔这样的一个或多个哈希。
- en: '[PRE93]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This feature is not supported by all TLS backends.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能并非所有 TLS 后端都支持。
- en: OCSP stapling
  id: totrans-743
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OCSP Stapling
- en: This uses the TLS extension called Certificate Status Request to ask the server
    to provide a fresh "proof" from the CA in the handshake, that the certificate
    that it returns is still valid. This is a way to make really sure the server's
    certificate hasn't been revoked.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用称为证书状态请求的 TLS 扩展，要求服务器在握手中提供来自 CA 的新的 "证明"，以确保其返回的证书仍然有效。这是确保服务器证书未被吊销的一种方式。
- en: If the server doesn't support this extension, the test will fail and curl returns
    an error. And it is still far too common that servers don't support this.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器不支持此扩展，则测试将失败，curl 将返回错误。而且服务器不支持这种情况仍然非常普遍。
- en: 'Ask for the handshake to use the status request like this:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 请求握手使用状态请求的方式如下：
- en: '[PRE94]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This feature is only supported by the OpenSSL, GnuTLS and NSS backends.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能仅由 OpenSSL、GnuTLS 和 NSS 后端支持。
- en: Client certificates
  id: totrans-749
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端证书
- en: TLS client certificates are a way for clients to cryptographically prove to
    servers that they are truly the right peer. A command line that uses a client
    certificate specifies the certificate and the corresponding key, and they are
    then passed on the TLS handshake with the server.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 客户端证书是客户端向服务器加密证明其为正确对等方的一种方式。使用客户端证书的命令行指定证书和相应的密钥，然后它们将与服务器的 TLS 握手一起传递。
- en: You need to have your client certificate already stored in a file when doing
    this and you should supposedly have gotten it from the right instance via a different
    channel previously.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作时，您需要已经将客户端证书存储在文件中，并且您应该已经通过其他渠道获得了正确实例的证书。
- en: The key is typically protected by a password that you need to provide or get
    prompted for interactively.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 该密钥通常由您提供或交互式提示输入的密码保护。
- en: 'curl offers options to let you specify a single file that is both the client
    certificate and the private key concatenated using `--cert`, or you can specify
    the key file independently with `--key`:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: curl 提供了选项，让您指定一个单独的文件，该文件既是客户端证书又是私钥，使用 `--cert`，或者您可以独立指定密钥文件使用 `--key`：
- en: '[PRE95]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'For some TLS backends you can also pass in the key and certificate using different
    types:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些 TLS 后端，您还可以使用不同类型的密钥和证书传入：
- en: '[PRE96]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: TLS auth
  id: totrans-757
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TLS 身份验证
- en: TBD
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Different TLS backends
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的 TLS 后端
- en: TBD
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Multiple TLS backends
  id: totrans-761
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个 TLS 后端
- en: TBD
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Debug
  id: totrans-763
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: When things don't run the way you thought they would
  id: totrans-764
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当事情不像您想象的那样运行时
- en: TBD
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Copy as curl
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 curl 形式复制
- en: Copy as curl
  id: totrans-767
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 curl 形式复制
- en: Using curl to perform an operation a user just managed to do with his or her
    browser is one of the more common requests and areas people ask for help about.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: How do you get a curl command line to get a resource, just like the browser
    would get it, nice and easy? Both Chrome and Firefox have provided this feature
    for quite some time already!
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: From Firefox
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You get the site shown with Firefox's network tools. You then right-click on
    the specific request you want to repeat in the "Web Developer->Network" tool when
    you see the HTTP traffic, and in the menu that appears you select "Copy as cURL".
    Like this screenshot below shows. The operation then generates a curl command
    line to your clipboard and you can then paste that into your favorite shell window.
    This feature is available by default in all Firefox installations.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '![copy as curl with Firefox](firefox-copy-as-curl.png)'
  id: totrans-772
  prefs: []
  type: TYPE_IMG
- en: From Chrome
  id: totrans-773
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you pop up the More tools->Developer mode in Chrome, and you select the
    Network tab you see the HTTP traffic used to get the resources of the site. On
    the line of the specific resource you are interested in, you right-click with
    the mouse and you select "Copy as cURL" and it will generate a command line for
    you in your clipboard. Paste that in a shell to get a curl command line that makes
    the transfer. This feature is available by default in all Chrome and Chromium
    installations.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '![copy as curl with Chrome](chrome-copy-as-curl.png)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
- en: On Firefox, without using the devtools
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If this is something you would like to get done more often, you probably find
    using the developer tools a bit inconvenient and cumbersome to pop up just to
    get the command line copied. Then [cliget](https://addons.mozilla.org/en-US/firefox/addon/cliget/)
    is the perfect add-on for you as it gives you a new option in the right-click
    menu, so you can get a quick command line generated really quickly, like this
    example when I right-click an image in Firefox:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '![cliget with Firefox](firefox-cliget.png)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
- en: Not perfect
  id: totrans-779
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These methods all give you a command line to reproduce their HTTP transfers,
    but you will also learn they they are still often not the perfect solution to
    your problems. Why? Well mostly because these tools are written to rerun the *exact*
    same request that you copied, while you often want to rerun the same logic but
    not sending an exact copy of the same cookies and file contents etc.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: These tools will give you command lines with static and fixed cookie contents
    to send in the request, because that is the contents of the cookies that were
    sent in the browser's requests. You will most likely want to rewrite the command
    line to dynamically adapt to whatever the content is in the cookie that the server
    told you in a previous response. And so on.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: The copy as curl functionality is also often notoriously bad at using `-F` and
    instead they provide handcrafted `--data-binary` solutions including the mime
    separator strings etc.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: curl examples
  id: totrans-783
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: curl examples
  id: totrans-784
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TBD
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Fetch many variations on a URL
  id: totrans-786
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: Follow redirects automatically
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动跟随重定向
- en: TBD
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Impersonating a specific web browser
  id: totrans-790
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冒充特定的网络浏览器
- en: TBD
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Issuing a web search
  id: totrans-792
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发起网络搜索
- en: TBD
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Tell the server where you didn't come from
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 告诉服务器你来自哪里
- en: TBD
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Maintain state with cookies
  id: totrans-796
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cookies维护状态
- en: TBD
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Login to a web service with POST
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用POST登录到一个网络服务
- en: TBD
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Upload a file as with a HTML form
  id: totrans-800
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传文件就像使用HTML表单一样
- en: TBD
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
