- en: Using curl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using curl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous chapters have described some basic details on what curl is and something
    about the basic command lines. You use command-line options and you pass on URLs
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to dive deeper into a variety of different concepts
    of what curl can do and how to tell curl to use these features. You should consider
    all these features as different tools that are here to help you do your file transfer
    tasks as conveniently as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Supported protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl supports or can be made to support (if built so) the following protocols.
  prefs: []
  type: TYPE_NORMAL
- en: DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3,
    POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMTP, SMTPS, TELNET and TFTP
  prefs: []
  type: TYPE_NORMAL
- en: Verbose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verbose mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your curl command doesn't execute or return what you expected it to, your
    first gut reaction should always be to run the command with the `-v / --verbose`
    option to get more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'When verbose mode is enabled, curl gets more talkative and will explain and
    show a lot more of its doings. It will add informational tests and prefix them
    with ''*''. For example, let''s see what curl might say when trying a simple HTTP
    example (saving the downloaded data in the file called ''saved''):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ok so we invoked curl with a URL that it considers incomplete so it helps us
    and it adds a trailing slash before it moves on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This tells us curl now tries to connect to this IP address. It means the name
    'example.com' has been resolved to one or more addresses and this is the first
    (and possibly only) address curl will try to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It worked! curl connected to the site and here it explains how the name maps
    to the IP address and on which port it has connected to. The '(#0)' part is which
    internal number curl has given this connection. If you try multiple URLs in the
    same command line you can see it use more connections or reuse connections, so
    the connection counter may increase or not increase depending on what curl decides
    it needs to do.
  prefs: []
  type: TYPE_NORMAL
- en: If we use an HTTPS:// URL instead of an HTTP one, there will also be a whole
    bunch of lines explaining how curl uses CA certs to verify the server's certificate
    and some details from the server's certificate, etc. Including which ciphers were
    selected and more TLS details.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the added information given from curl internals, the -v verbose
    mode will also make curl show all headers it sends and receives. For protocols
    without headers (like FTP, SMTP, POP3 and so on), we can consider commands and
    responses as headers and they will thus also be shown with -v.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we then continue the output seen from the command above (but ignore the
    actual HTML response), curl will show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the full HTTP request to the site. This request is how it looks in a
    default curl 7.45.0 installation and it may, of course, differ slightly between
    different releases and in particular it will change if you add command line options.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the HTTP request headers looks empty, and it is. It signals
    the separation between the headers and the body, and in this request there is
    no "body" to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on and assuming everything goes according to plan, the sent request
    will get a corresponding response from the server and that HTTP response will
    start with a set of headers before the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This may look mostly like mumbo jumbo to you, but this is normal set of HTTP
    headers—metadata—about the response. The first line's "200" might be the most
    important piece of information in there and means "everything is fine".
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the received headers is, as you can see, empty, and that is
    the marker used for the HTTP protocol to signal the end of the headers.
  prefs: []
  type: TYPE_NORMAL
- en: After the headers comes the actual response body, the data payload. The regular
    -v verbose mode does not show that data but only displays
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That 1270 bytes should then be in the ''saved'' file. You can also see that
    there was a header named Content-Length: in the response that contained the exact
    file length (it won''t always be present in responses).'
  prefs: []
  type: TYPE_NORMAL
- en: --trace and --trace-ascii
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are times when `-v` is not enough. In particular, when you want to store
    the complete stream including the actual transferred data.
  prefs: []
  type: TYPE_NORMAL
- en: For situations when curl does encrypted file transfers with protocols such as
    HTTPS, FTPS or SFTP, other network monitoring tools (like Wireshark or tcpdump)
    won't be able to do this job as easily for you.
  prefs: []
  type: TYPE_NORMAL
- en: For this, curl offers two other options that you use instead of `-v`.
  prefs: []
  type: TYPE_NORMAL
- en: '`--trace [filename]` will save a full trace in the given file name. You can
    also use ''-'' (a single minus) instead of a file name to get it passed to stdout.
    You would use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When completed, there''s a ''dump'' file that can turn out pretty sizable.
    In this case, the 15 first lines of the dump file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Every single sent and received byte get displayed individually in hexadecimal
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think the hexadecimals aren''t helping, you can try `--trace-ascii [filename]`
    instead, also this accepting ''-'' for stdout and that makes the 15 first lines
    of tracing look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: --trace-time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This options prefixes all verbose/trace outputs with a high resolution timer
    for when the line is printed. It works with the regular `-v / --verbose` option
    as well as with `--trace` and `--trace-ascii`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The lines are all the local time as hours:minutes:seconds and then number of
    microseconds in that second.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When doing file transfers using version two of the HTTP protocol, HTTP/2, curl
    sends and receives **compressed** headers. So to display outgoing and incoming
    HTTP/2 headers in a readable and understandable way, curl will actually show the
    uncompressed versions in a style similar to how they appear with HTTP/1.1.
  prefs: []
  type: TYPE_NORMAL
- en: --write-out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is one of the often forgotten little gems in the curl arsenal of command
    line options. `--write-out` or just `-w` for short, writes out information after
    a transfer has completed and it has a large range of variables that you can include
    in the output, variables that have been set with values and information from the
    transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You tell curl to write a string just by passing that string to this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '…and you can also have curl read that string from a given file instead if you
    prefix the string with ''@'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '…or even have curl read the string from stdin if you use ''-'' as filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The variables that are available are accessed by writing `%{variable_name}`
    in the string and that variable will then be substituted by the correct value.
    To output a normal '%' you just write it as '%%'. You can also output a newline
    by using '\n', a carriage return with '\r' and a tab space with '\t'.
  prefs: []
  type: TYPE_NORMAL
- en: (The %-symbol is special on the Windows command line, where all occurrences
    of % must be doubled when using this option.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can output the Content-Type and the response code from an
    HTTP transfer, separated with newlines and some extra text like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This feature writes the output to stdout so you probably want to make sure that
    you don't also send the downloaded content to stdout as then you might have a
    hard time to separate out the data.
  prefs: []
  type: TYPE_NORMAL
- en: Available --write-out variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some of these variables are not available in really old curl versions.
  prefs: []
  type: TYPE_NORMAL
- en: '%{content_type} shows the Content-Type of the requested document, if there
    was any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{filename_effective} shows the ultimate filename that curl writes out to.
    This is only meaningful if curl is told to write to a file with the `--remote-name`
    or `--output` option. It''s most useful in combination with the `--remote-header-name`
    option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{ftp_entry_path} shows the initial path curl ended up in when logging on to
    the remote FTP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{response_code} shows the numerical response code that was found in the last
    transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{http_connect} shows the numerical code that was found in the last response
    (from a proxy) to a curl CONNECT request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{local_ip} shows the IP address of the local end of the most recently done
    connection—can be either IPv4 or IPv6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{local_port} shows the local port number of the most recently made connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{num_connects} shows the number of new connects made in the recent transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{num_redirects} shows the number of redirects that were followed in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{redirect_url} shows the actual URL a redirect *would* take you to when an
    HTTP request was made without `-L` to follow redirects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{remote_ip} shows the remote IP address of the most recently made connection—can
    be either IPv4 or IPv6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{remote_port} shows the remote port number of the most recently made connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{size_download} shows the total number of bytes that were downloaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{size_header} shows the total number of bytes of the downloaded headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{size_request} shows the total number of bytes that were sent in the HTTP
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{size_upload} shows the total number of bytes that were uploaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{speed_download} shows the average download speed that curl measured for the
    complete download in bytes per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{speed_upload} shows the average upload speed that curl measured for the complete
    upload in bytes per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{ssl_verify_result} shows the result of the SSL peer certificate verification
    that was requested. 0 means the verification was successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{time_appconnect} shows the time, in seconds, it took from the start until
    the SSL/SSH/etc connect/handshake to the remote host was completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{time_connect} shows the time, in seconds, it took from the start until the
    TCP connect to the remote host (or proxy) was completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{time_namelookup} shows the time, in seconds, it took from the start until
    the name resolving was completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{time_pretransfer} shows the time, in seconds, it took from the start until
    the file transfer was just about to begin. This includes all pre-transfer commands
    and negotiations that are specific to the particular protocol(s) involved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{time_redirect} shows the time, in seconds, it took for all redirection steps
    including name lookup, connect, pre-transfer and transfer before the final transaction
    was started. time_redirect shows the complete execution time for multiple redirections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{time_starttransfer} shows the time, in seconds, it took from the start until
    the first byte was just about to be transferred. This includes time_pretransfer
    and also the time the server needed to calculate the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{time_total} shows the total time, in seconds, that the full operation lasted.
    The time will be displayed with millisecond resolution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%{url_effective} shows the URL that was fetched last. This is particularly
    meaningful if you have told curl to follow Location: headers (with `-L`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Silence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The opposite of verbose is, of course, to make curl more silent. With the `-s`
    (or `--silent`) option you make curl switch off the progress meter and not output
    any error messages for when errors occur. It gets mute. It will still output the
    downloaded data you ask it to.
  prefs: []
  type: TYPE_NORMAL
- en: With silence activated, you can ask for it to still output the error message
    on failures by adding `-S` or `--show-error`.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persistent connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When setting up TCP connections to sites, curl will keep the old connection
    around for a while so that if the next transfer is to the same host it can reuse
    the same connection again and thus save a lot of time. We call this persistent
    connections. curl will always try to keep connections alive and reuse existing
    connections as far as it can.
  prefs: []
  type: TYPE_NORMAL
- en: The curl command-line tool can, however, only keep connections alive for as
    long as it runs, so as soon as it exits back to your command line it has to close
    down all currently open connections (and also free and clean up all the other
    caches it uses to decrease time of subsequent operations). We call the pool of
    alive connections the "connection cache".
  prefs: []
  type: TYPE_NORMAL
- en: If you want to perform N transfers or operations against the same host or same
    base URL, you could gain a lot of speed by trying to do them in as few curl command
    lines as possible instead of repeatedly invoking curl with one URL at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Downloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Downloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Download" means getting data from a server on a network, and the server is
    then clearly considered to be "above" you. This is loading data down from the
    server onto your machine where you are running curl.'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading is probably the most common use case for curl—retrieving the specific
    data pointed to by a URL onto your machine.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is downloading?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You specify the resource to download by giving curl a URL. curl defaults to
    downloading a URL unless told otherwise, and the URL identifies what to download.
    In this example the URL to download is "[http://example.com](http://example.com)":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The URL is broken down into its individual components ([as explained elsewhere](cmdline-urls.html)),
    the correct server is contacted and is then asked to deliver the specific resource—often
    a file. The server then delivers the data, or it refuses or perhaps the client
    asked for the wrong data and then that data is delivered.
  prefs: []
  type: TYPE_NORMAL
- en: A request for a resource is protocol-specific so a FTP:// URL works differently
    than an HTTP:// URL or an SFTP:// URL.
  prefs: []
  type: TYPE_NORMAL
- en: A URL without a path part, that is a URL that has a host name part only (like
    the "[http://example.com](http://example.com)" example above) will get a slash
    ('/') appended to it internally and then that is the resource curl will ask for
    from the server.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify multiple URLs on the command line, curl will download each URL
    one by one. It won't start the second transfer until the first one is complete,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: Storing downloads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you try the example download as in the previous section, you will notice
    that curl will output the downloaded data to stdout unless told to do something
    else. Outputting data to stdout is really useful when you want to pipe it into
    another program or similar, but it is not always the optimal way to deal with
    your downloads.
  prefs: []
  type: TYPE_NORMAL
- en: Give curl a specific file name to save the download in with `-o [filename]`
    (with `--output` as the long version of the option), where filename is either
    just a file name, a relative path to a file name or a full path to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that you can put the `-o` before or after the URL; it makes no difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is, of course, not limited to http:// URLs but works the same way no matter
    which type of URL you download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you ask curl to send the output to the terminal, it attempts to detect and
    prevent binary data from being sent there since that can seriously mess up your
    terminal (sometimes to the point where it basically stops working). You can override
    curl's binary-output-prevention and force the output to get sent to stdout by
    using `-o -`.
  prefs: []
  type: TYPE_NORMAL
- en: curl has several other ways to store and name the downloaded data. Details follow!
  prefs: []
  type: TYPE_NORMAL
- en: Download to a file named by the URL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many URLs, however, already contain the file name part in the rightmost end.
    curl lets you use that as a shortcut so you don''t have to repeat it with `-o`.
    So instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can save the remove URL resource into the local file ''file.html'' with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the `-O` (uppercase letter o) option, or `--remote-name` for the long
    name version. The -O option selects the local file name to use by picking the
    file name part of the URL that you provide. This is important. You specify the
    URL and curl picks the name from this data. If the site redirects curl further
    (and if you tell curl to follow redirects), it doesn't change the file name curl
    will use for storing this.
  prefs: []
  type: TYPE_NORMAL
- en: Get the target file name from the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP servers have the option to provide a header named `Content-Disposition:`
    in responses. That header may contain a suggested file name for the contents delivered,
    and curl can be told to use that hint to name its local file. The `-J / --remote-header-name`
    enables this. If you also use the `-O` option, it makes curl use the file name
    from the URL by default and only *if* there's actually a valid Content-Disposition
    header available, it switches to saving using that name.
  prefs: []
  type: TYPE_NORMAL
- en: '-J has some problems and risks associated with it that users need to be aware
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: It will only use the rightmost part of the suggested file name, so any path
    or directories the server suggests will be stripped out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the file name is entirely selected by the server, curl will, of course,
    overwrite any preexisting local file in your current directory if the server happens
    to provide such a file name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File name encoding and character sets issues. curl does not decode the name
    in any way, so you may end up with a URL-encoded file name where a browser would
    otherwise decode it to something more readable using a sensible character set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTML and charsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: curl will download the exact binary data that the server sends. This might be
    of importance to you in case, for example, you download a HTML page or other text
    data that uses a certain character encoding that your browser then displays as
    expected. curl will then not translate the arriving data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common example where this causes some surprising results is when a user downloads
    a web page with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: …and when inspecting the `storage.html` file after the fact, the user realizes
    that one or more characters look funny or downright wrong. This can then very
    well be because the server sent the characters using charset X, while your editor
    and environment use charset Y. In an ideal world, we would all use UTF-8 everywhere
    but unfortunately, that is still not the case.
  prefs: []
  type: TYPE_NORMAL
- en: A common work-around for this issue that works decently is to use the common
    `iconv` utility to translate a text file to and from different charsets.
  prefs: []
  type: TYPE_NORMAL
- en: Compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: curl allows you to ask HTTP and HTTPS servers to provide compressed versions
    of the data and then perform automatic decompression of it on arrival. In situations
    where bandwidth is more limited than CPU this will help you receive more data
    in a shorter amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP compression can be done using two different mechanisms, one which might
    be considered "The Right Way" and the other that is the way that everyone actually
    uses and is the widespread and popular way to do it! The common way to compress
    HTTP content is using the **Content-Encoding** header. You ask curl to use this
    with the `--compressed` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this option enabled (and if the server supports it) it delivers the data
    in a compressed way and curl will decompress it before saving it or sending it
    to stdout. This usually means that as a user you don't really see or experience
    the compression other than possibly noticing a faster transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--compressed` option asks for Content-Encoding compression using one of
    the supported compression algorithms. There''s also the rarer **Transfer-Encoding**
    method, which is the header that was created for this automated method but was
    never really widely adopted. You can tell curl to ask for Transfer-Encoded compression
    with `--tr-encoding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In theory, there's nothing that prevents you from using both in the same command
    line, although in practice, you may then experience that some servers get a little
    confused when ask to compress in two different ways. It's generally safer to just
    pick one.
  prefs: []
  type: TYPE_NORMAL
- en: Shell redirects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you invoke curl from a shell or some other command-line prompt system,
    that environment generally provides you with a set of output redirection abilities.
    In most Linux and Unix shells and with Windows' command prompts, you direct stdout
    to a file with `> filename`. Using this, of course, makes the use of -o or -O
    superfluous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting output to a file redirects all output from curl to that file, so
    even if you ask to transfer more than one URL to stdout, redirecting the output
    will get all the URLs' output stored in that single file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Unix shells usually allow you to redirect the *stderr* stream separately. The
    stderr stream is usually a stream that also gets shown in the terminal, but you
    can redirect it separately from the stdout stream. The stdout stream is for the
    data while stderr is metadata and errors, etc., that aren''t data. You can redirect
    stderr with `2>file` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Multiple downloads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As curl can be told to download many URLs in a single command line, there are,
    of course, times when you want to store these downloads in nicely-named local
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to understanding this is that each download URL needs its own "storage
    instruction". Without said "storage instruction", curl will default to sending
    the data to stdout. If you ask for two URLs and only tell curl where to save the
    first URL, the second one is sent to stdout. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The "storage instructions" are read and handled in the same order as the download
    URLs so they don't have to be next to the URL in any way. You can round up all
    the output options first, last or interleaved with the URLs. You choose!
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples all work the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-O` is similarly just an instruction for a single download so if you download
    multiple URLs, use more of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Use the URL's file name part for all URLs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a reaction to adding a hundred `-O` options when using a hundred URLs, we
    introduced an option called `--remote-name-all`. This makes `-O` the default operation
    for all given URLs. You can still provide individual "storage instructions" for
    URLs but if you leave one out for a URL that gets downloaded, the default action
    is then switched from stdout to -O style.
  prefs: []
  type: TYPE_NORMAL
- en: '"My browser shows something else"'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common use case is using curl to get a URL that you can get in your browser
    when you paste the URL in the browser's address bar.
  prefs: []
  type: TYPE_NORMAL
- en: But a browser getting a URL does so much more and in so many different ways
    than curl that what curl shows in your terminal output is probably not at all
    what you see in your browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Client differences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Curl only gets exactly what you ask it to get and it never parses the actual
    content—the data—that the server delivers. A browser gets data and it activates
    different parsers depending on what kind of content it thinks it gets. For example,
    if the data is HTML it will parse it to display a web page and possibly download
    other sub resources such as images, JavaScript and CSS files. When curl downloads
    a HTML it will just get that single HTML resource, even if it, when parsed by
    a browser, would trigger a whole busload of more downloads. If you want curl to
    download any sub-resources as well, you need to pass those URLs to curl and ask
    it to get those, just like any other URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Clients also differ in how they send their requests, and some aspects of a request
    for a resource include, for example, format preferences, asking for compressed
    data, or just telling the server from which previous page we are "coming from".
    curl's requests will differ a little or a lot from how your browser sends its
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Server differences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The server that receives the request and delivers data is often setup to act
    in certain ways depending on what kind of client it thinks communicates with it.
    Sometimes it is as innocent as trying to deliver the best content for the client,
    sometimes it is to hide some content for some clients or even to try to work around
    known problems in specific browsers. Then there's also, of course, various kind
    of login systems that might rely on HTTP authentication or cookies or the client
    being from the pre-validated IP address range.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes getting the same response from a server using curl as the response
    you get with a browser ends up really hard work. Users then typically record their
    browser sessions with the browser's networking tools and then compare that recording
    with recorded data from curl's `--trace-ascii` option and proceed to modify curl's
    requests (often with `-H / --header`) until the server starts to respond the same
    to both.
  prefs: []
  type: TYPE_NORMAL
- en: This type of work can be both time consuming and tedious. You should always
    do this with permission from the server owners or admins.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediaries' fiddlings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Intermediaries are proxies, explicit or implicit ones. Some environments will
    force you to use one or you may choose to use one for various reasons, but there
    are also the transparent ones that will intercept your network traffic silently
    and proxy it for you no matter what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Proxies are "middle men" that terminate the traffic and then act on your behalf
    to the remote server. This can introduce all sorts of explicit filtering and "saving"
    you from certain content or even "protecting" the remote server from what data
    you try to send to it, but even more so it introduces another software's view
    on how the protocol works and what the right things to do are.
  prefs: []
  type: TYPE_NORMAL
- en: Interfering intermediaries are often the cause of lots of head aches and mysteries
    down to downright malicious modifications of content.
  prefs: []
  type: TYPE_NORMAL
- en: We strongly encourage you to use HTTPS or other means to verify that the contents
    you are downloading or uploading are really the data that the remote server has
    sent to you and that your precious bytes end up verbatim at the intended destination.
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When curl transfers data, it will attempt to do that as fast as possible. It
    goes for both uploads and downloads. Exactly how fast that will be depends on
    several factors, including your computer's ability, your own network connection's
    bandwidth, the load on the remote server you are transferring to/from and the
    latency to that server. And your curl transfers are also likely to compete with
    other transfers on the networks the data travels over, from other users or just
    other apps by the same user.
  prefs: []
  type: TYPE_NORMAL
- en: In many setups, however, you will find that you can more or less saturate your
    own network connection with a single curl command line. If you have a 10 megabit
    per second connection to the Internet, chances are curl can use all of those 10
    megabits to transfer data.
  prefs: []
  type: TYPE_NORMAL
- en: For most use cases, using as much bandwidth as possible is a good thing. It
    makes the transfer faster, it makes the curl command complete sooner and it will
    make the transfer use resources from the server for a shorter period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you will, however, find that having curl starve out other network
    functions on your local network connection is inconvenient. In these situations
    you may want to tell curl to slow down so that other network users get a better
    chance to get their data through as well. With `--limit-rate [speed]` you can
    tell curl to not go faster than the given number of bytes per second. The rate
    limit value can be given with a letter suffix using one of K, M and G for kilobytes,
    megabytes and gigabytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make curl not download data any faster than 200 kilobytes per second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The given limit is the maximum *average speed* allowed, counted during the entire
    transfer. It means that curl might use higher transfer speeds in short bursts,
    but over time it uses no more than the given rate.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that curl never knows what the maximum possible speed is—it will simply
    go as fast as it can and is allowed. You may know your connection's maximum speed,
    but curl does not.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum filesize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you want to make sure your curl command line won''t try to download a
    too-large file, you can instruct curl to stop before doing that, if it knows the
    size before the transfer starts! Maybe that would use too much bandwidth, take
    too long time or you don''t have enough space on your hard drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Give curl the largest download you will accept in number of bytes and if curl
    can figure out the size before the transfer starts it will abort before trying
    to download something larger.
  prefs: []
  type: TYPE_NORMAL
- en: There are many situations in which curl cannot figure out the size at the time
    the transfer starts and this option will not affect those transfers, even if they
    may end up larger than the specified amount.
  prefs: []
  type: TYPE_NORMAL
- en: Metalink
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Metalink is a file description standard that tells a client multiple locations
    where the same content resides. A client can then opt to transfer that content
    from one or many of those sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'curl supports the Metalink format when asked to with the `--metalink` option.
    Then given URL should then point to a Metalink file. Such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: curl will make use of the mirrors listed within the file for failover if there
    are errors (such as the file or server not being available). It will also verify
    the hash of the file after the download completes. The Metalink file itself is
    downloaded and processed in memory and not stored in the local file system.
  prefs: []
  type: TYPE_NORMAL
- en: Storing metadata in file system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When saving a download to a file with curl, the `--xattr` option tells curl
    to also store certain file metadata in "extended file attributes". These extended
    attributes are basically standardized name/value pairs stored in the file system,
    assuming one of the supported file systems and operating systems are used.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the URL is stored in the `xdg.origin.url` attribute and, for HTTP,
    the content type is stored in the `mime_type` attribute. If the file system does
    not support extended attributes when this option is set, a warning is issued.
  prefs: []
  type: TYPE_NORMAL
- en: Raw
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `--raw` is used, it disables all internal HTTP decoding of content or transfer
    encodings and instead makes curl passed on unaltered, raw, data.
  prefs: []
  type: TYPE_NORMAL
- en: This is typically used if you are writing some sort of middle software and you
    want to pass on the content to perhaps another HTTP client and allow that to do
    the decoding instead.
  prefs: []
  type: TYPE_NORMAL
- en: Retrying failed attempts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally curl will only make a single attempt to perform a transfer and return
    an error if not successful. Using the `--retry` option you can tell curl to retry
    certain failed transfers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a transient error is returned when curl tries to perform a transfer, it
    will retry this number of times before giving up. Setting the number to 0 makes
    curl do no retries (which is the default). Transient error means either: a timeout,
    an FTP 4xx response code or an HTTP 5xx response code.'
  prefs: []
  type: TYPE_NORMAL
- en: When curl is about to retry a transfer, it will first wait one second and then
    for all forthcoming retries it will double the waiting time until it reaches 10
    minutes which then will be the delay between the rest of the retries. Using `--retry-delay`
    you can disable this exponential backoff algorithm and set your own delay between
    the attempts. With `--retry-max-time` you cap the total time allowed for retries.
    The `--max-time` option will still specify the longest time a single of these
    transfers is allowed to spend.
  prefs: []
  type: TYPE_NORMAL
- en: Resuming and ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resuming a download means first checking the size of what is already present
    locally and then asking the server to send the rest of it so it can be appended.
    curl also allows resuming the transfer at a custom point without actually having
    anything already locally present.
  prefs: []
  type: TYPE_NORMAL
- en: curl supports resumed downloads on several protocols. Tell it where to start
    the transfer with the `-C, --continue-at` option that takes either a plain numerical
    byte counter offset where to start or the string `-` that asks curl to figure
    it out itself based on what it knows. When using `-`, curl will use the destination
    file name to figure out how much data that is already present locally and ask
    use that as an offset when asking for more data from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start downloading an FTP file from byte offset 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue downloading a previously interrupted download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you instead just want a specific byte range from the remote resource transferred,
    you can ask for only that. For example, when you only want 1000 bytes from offset
    100 to avoid having to download the entire huge remote file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uploading is a term for sending data to a remote server. Uploading is done differently
    for each protocol, and several protocols may even allow different ways of uploading
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols allowing upload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can upload data using one of these protocols: FILE, FTP, FTPS, HTTP, HTTPS,
    IMAP, IMAPS, SCP, SFTP, SMB, SMBS, SMTP, SMTPS and TFTP.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP offers several "uploads"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP (and its bigger brother HTTPS) provides several different ways to upload
    data to a server and curl offers easy command-line options to do it the three
    most common ways, described below.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting detail with HTTP is also that an upload can also be a download,
    in the same operation and in fact many downloads are initiated with an HTTP POST.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: POST is the HTTP method that was invented to send data to a receiving web application,
    and it is, for example, how most common HTML forms on the web work. It usually
    sends a chunk of relatively small amounts of data to the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: The upload kind is usually done with the `-d` or `--data` options, but there
    are a few additional alterations.
  prefs: []
  type: TYPE_NORMAL
- en: Read the detailed description on how to do this with curl in the [HTTP POST
    with curl](http-post.html) chapter.
  prefs: []
  type: TYPE_NORMAL
- en: multipart formpost
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Multipart formposts are also used in HTML forms on web sites; typically when
    there's a file upload involved. This type of upload is also an HTTP POST but it
    sends the data formatted according to some special rules, which is what the "multipart"
    name means.
  prefs: []
  type: TYPE_NORMAL
- en: Since it sends the data formatted completely differently, you cannot select
    which type of POST to use at your own whim but it entirely depends on what the
    receiving server end expects and can handle.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP multipart formposts are done with `-F`. See the detailed description in
    the [HTTP multipart formposts](http-multipart.html) chapter.
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HTTP PUT is the sort of upload that was designed to send a complete resource
    that is meant to be put as-is on the remote site or even replace an existing resource
    there. That said, this is also the least used upload method for HTTP on the web
    today and lots, if not most, web servers don't even have PUT enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'You send off an HTTP upload using the -T option with the file to upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: FTP uploads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working with FTP, you get to see the remote file system you will be accessing.
    You tell the server exactly in which directory you want the upload to be placed
    and which file name to use. If you specify the upload URL with a trailing slash,
    curl will append the locally used file name to the URL and then that will be the
    file name used when stored remotely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So if you prefer to select a different file name on the remote side than what
    you have used locally, you specify it in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Learn more about FTPing with curl in the [Using curl/FTP](usingcurl-ftp.html)
    section.
  prefs: []
  type: TYPE_NORMAL
- en: SMTP uploads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may not consider sending an e-mail to be "uploading", but to curl it is.
    You upload the mail body to the SMTP server. With SMTP, you also need to include
    all the e-mail headers you need (To:, From:, Date:, etc.) in the mail body as
    curl will not add any at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Learn more about using SMTP with curl in the [Using curl/SMTP](usingcurl-smtp.html)
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Progress meter for uploads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The general progress meter curl provides (see the [Progress meter](cmdline-progressmeter.html)
    section) works fine for uploads as well. What needs to be remembered is that the
    progress meter is automatically disabled when you are sending output to stdout,
    and most protocols curl support can output something even for an upload.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you may need to explicitly redirect the downloaded data to a file
    (using shell redirect '>', `-o` or similar) to get the progress meter displayed
    for upload.
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rate limiting works exactly the same for uploads as for downloads and curl,
    in fact, only has a single limit that will limit the speed in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: See further details in the [Download Rate limiting section](usingcurl-downloads.html#rate-limiting).
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the protocols you use with curl speak TCP. With TCP, a client such as
    curl must first figure out the IP address(es) of the host you want to communicate
    with, then connect to it. "Connecting to it" means performing a TCP protocol handshake.
  prefs: []
  type: TYPE_NORMAL
- en: For ordinary command line usage, operating on a URL, these are details which
    are taken care of under the hood, and which you can mostly ignore. But at times
    you might find yourself wanting to tweak the specifics…
  prefs: []
  type: TYPE_NORMAL
- en: Name resolve tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Edit the hosts file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maybe you want the command `curl http://example.com` to connect to your local
    server instead of the actual server.
  prefs: []
  type: TYPE_NORMAL
- en: You can normally and easily do that by editing your `hosts` file (`/etc/hosts`
    on Linux and Unix systems) and adding, for example, `127.0.0.1 example.com` to
    redirect the host to your localhost. However this edit requires admin access and
    it has the downside that it affects all other applications at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the Host: header'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Host:` header is the normal way an HTTP client tells the HTTP server which
    server it speaks to, as typically an HTTP server serves many different names using
    the same software instance.
  prefs: []
  type: TYPE_NORMAL
- en: So, by passing in a custom modified `Host:` header you can have the server respond
    with the contents of the site even when you didn't actually connect to that host
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you run a test instance of your main site `www.example.com` on
    your local machine and you want to have curl ask for the index html:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When setting a custom `Host:` header and using cookies, curl will extract the
    custom name and use that as host when matching cookies to send off.
  prefs: []
  type: TYPE_NORMAL
- en: The `Host:` header is not enough when communicating with an HTTPS server. With
    HTTPS there's a separate extension field in the TLS protocol called SNI (Server
    Name Indication) that lets the client tell the server the name of the server it
    wants to talk to. curl will only extract the SNI name to send from the given URL.
  prefs: []
  type: TYPE_NORMAL
- en: Provide a custom IP address for a name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Do you know better than the name resolver where curl should go? Then you can
    give an IP address to curl yourself! If you want to redirect port 80 access for
    `example.com` to instead reach your localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can even specify multiple `--resolve` switches to provide multiple redirects
    of this sort, which can be handy if the URL you work with uses HTTP redirects
    or if you just want to have your command line work with multiple URLs.
  prefs: []
  type: TYPE_NORMAL
- en: '`--resolve` inserts the address into curl''s DNS cache, so it will effectively
    make curl believe that''s the address it got when it resolved the name.'
  prefs: []
  type: TYPE_NORMAL
- en: When talking HTTPS, this will send SNI for the name in the URL and curl will
    verify the server's response to make sure it serves for the name in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Provide a replacement name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a close relative to the `--resolve` option, the `--connect-to` option provides
    a minor variation. It allows you to specify a replacement name and port number
    for curl to use under the hood when a specific name and port number is used to
    connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have a single site called `www.example.com` that in
    turn is actually served by three different individual HTTP servers: load1, load2
    and load3, for load balancing purposes. In a typical normal procedure, curl resolves
    the main site and gets to speak to one of the load balanced servers (as it gets
    a list back and just picks one of them) and all is well. If you want to send a
    test request to one specific server out of the load balanced set (`load1.example.com`
    for example) you can instruct curl to do that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You *can* still use `--resolve` to accomplish this if you know the specific
    IP address of load1\. But without having to first resolve and fix the IP address
    separately, you can tell curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It redirects from a SOURCE NAME + SOURCE PORT to a DESTINATION NAME + DESTINATION
    PORT. curl will then resolve the `load1.example.com` name and connect, but in
    all other ways still assume it is talking to `www.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Name resolve tricks with c-ares
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As should be detailed elsewhere in this book, curl may be built with several
    different name resolving backends. One of those backends is powered by the c-ares
    library and when curl is built to use c-ares, it gets a few extra superpowers
    that curl built to use other name resolve backends don't get. Namely, it gains
    the ability to more specifically instruct what DNS servers to use and how that
    DNS traffic is using the network.
  prefs: []
  type: TYPE_NORMAL
- en: With `--dns-servers`, you can specify exactly which DNS server curl should use
    instead of the default one. This lets you run your own experimental server that
    answers differently, or use a backup one if your regular one is unreliable or
    dead.
  prefs: []
  type: TYPE_NORMAL
- en: With `--dns-ipv4-addr` and `--dns-ipv6-addr` you ask curl to "bind" its local
    end of the DNS communication to a specific IP address and with `--dns-interface`
    you can instruct curl to use a specific network interface to use for its DNS requests.
  prefs: []
  type: TYPE_NORMAL
- en: These `--dns-*` options are very advanced and are only meant for people who
    know what they are doing and understand what these options do. But they offer
    very customizable DNS name resolution operations.
  prefs: []
  type: TYPE_NORMAL
- en: Connection timeout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl will typically make a TCP connection to the host as an initial part of
    its network transfer. This TCP connection can fail or be very slow, if there are
    shaky network conditions or faulty remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the impact on your scripts or other use, you can set the maximum time
    in seconds which curl will allow for the connection attempt. With `--connnect-timeout`
    you tell curl the maximum time to allow for connecting, and if curl has not connected
    in that time it returns a failure.
  prefs: []
  type: TYPE_NORMAL
- en: The connection timeout only limits the time curl is allowed to spend up until
    the moment it connects, so once the TCP connection has been established it can
    take longer time. See the [Timeouts](usingcurl-timeouts.html) section for more
    on generic curl timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify a low timeout, you effectively disable curl's ability to connect
    to remote servers, slow servers or servers you access over unreliable networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection timeout can be specified as a decimal value for sub-second precision.
    For example, to allow 2781 milliseconds to connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Network interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On machines with multiple network interfaces that are connected to multiple
    networks, there are situations where you can decide which network interface you
    would prefer the outgoing network traffic to use. Or which originating IP address
    (out of the multiple ones you have) to use in the communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tell curl which network interface, which IP address or even host name that
    you would like to "bind" your local end of the communication to, with the `--interface`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Local port number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A TCP connection is created between an IP address and a port number in the local
    end and an IP address and a port number in the remote end. The remote port number
    can be specified in the URL and usually helps identify which service you are targeting.
  prefs: []
  type: TYPE_NORMAL
- en: The local port number is usually randomly assigned to your TCP connection by
    the network stack and you normally don't have to think about it much further.
    However, in some circumstances you find yourself behind network equipment, firewalls
    or similar setups that put restrictions on what source port numbers that can be
    allowed to set up the outgoing connections.
  prefs: []
  type: TYPE_NORMAL
- en: For situations like this, you can specify which local ports curl should bind
    the the connection to. You can specify a single port number to use, or a range
    of ports. We recommend using a range because ports are scarce resources and the
    exact one you want may already be in use. If you ask for a local port number (or
    range) that curl can't obtain for you, it will exit with a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Also, on most operating systems you cannot bind to port numbers below 1024 without
    having a higher privilege level (root) and we generally advise against running
    curl as root if you can avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ask curl to use a local port number between 4000 and 4200 when getting this
    HTTPS page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Keep alive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TCP connections can be totally without traffic in either direction when they
    are not used. A totally idle connection can therefore not be clearly separated
    from a connection that has gone completely stale because of network or server
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, lots of network equipment such as firewalls or NATs are keeping
    track of TCP connections these days, so that they can translate addresses, block
    "wrong" incoming packets, etc. These devices often count completely idle connections
    as dead after N minutes, where N varies between device to device but at times
    is as short as 10 minutes or even less.
  prefs: []
  type: TYPE_NORMAL
- en: One way to help avoid a really slow connection (or an idle one) getting treated
    as dead and wrongly killed, is to make sure TCP keep alive is used. TCP keepalive
    is a feature in the TCP protocol that makes it send "ping frames" back and forth
    when it would otherwise be totally idle. It helps idle connections to detect breakage
    even when no traffic is moving over it, and helps intermediate systems not consider
    the connection dead.
  prefs: []
  type: TYPE_NORMAL
- en: 'curl uses TCP keepalive by default for the reasons mentioned here. But there
    might be times when you want to *disable* keepalive or you may want to change
    the interval between the TCP "pings" (curl defaults to 60 seconds). You can switch
    off keepalive with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'or change the interval to 5 minutes (300 seconds) with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network operations are by their nature rather unreliable or perhaps fragile
    operations as they depend on a set of services and networks to be up and working
    for things to work. The availability of these services can come and go and the
    performance of them may also vary greatly from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: The design of TCP even allows the network to get completely disconnected for
    an extended period of time without it necessarily getting noticed by the participants
    in the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this is that sometimes Internet transfers take a very long time.
    Further, most operations in curl have no time-out by default!
  prefs: []
  type: TYPE_NORMAL
- en: Maximum time allowed to spend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tell curl with `-m / --max-time` the maximum time, in seconds, that you allow
    the command line to spend before curl exits with a timeout error code (28). When
    the set time has elapsed, curl will exit no matter what is going on at that moment—including
    if it is transferring data. It really is the maximum time allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The given maximum time can be specified with a decimal precision; `0.5` means
    500 milliseconds and `2.37` equals 2370 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Never spend more than this to connect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`--connect-timeout` limits the time curl will spend trying to connect to the
    host. All the necessary steps done before the connection is considered complete
    have to be completed within the given time frame. Failing to connect within the
    given time will cause curl to exit with a timeout exit code (28).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The given maximum connect time can be specified with a decimal precision; `0.5`
    means 500 milliseconds and `2.37` equals 2370 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Transfer speeds slower than this means exit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a fixed maximum time for a curl operation can be cumbersome, especially
    if you, for example, do scripted transfers and the file sizes and transfer times
    vary a lot. A fixed timeout value then needs to be set unnecessarily high to cover
    for worst cases.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to a fixed time-out, you can tell curl to abandon the transfer
    if it gets below a certain speed and stays below that threshold for a specific
    period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a transfer speed goes below 1000 bytes per second during 15
    seconds, stop it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Keep connections alive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl enables TCP keep-alive by default. TCP keep-alive is a feature that makes
    the TCP stack send a probe to the other side when there's no traffic, to make
    sure that it is still there and "alive". By using keep-alive, curl is much more
    likely to discover that the TCP connection is dead.
  prefs: []
  type: TYPE_NORMAL
- en: Use `--keepalive-time` to specify how often in full seconds you would like the
    probe to get sent to the peer. The default value is 60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes this probing disturbs what you are doing and then you can easily disable
    it with `--no-keepalive`.
  prefs: []
  type: TYPE_NORMAL
- en: .netrc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .netrc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unix systems have for a very long time offered a way for users to store their
    user name and password for remote FTP servers. ftp clients have supported this
    for decades and this way allowed users to quickly login to known servers without
    manually having to reenter the credentials each time. The `.netrc` file is typically
    stored in a user's home directory. (On Windows, curl will look for it with the
    name `_netrc`).
  prefs: []
  type: TYPE_NORMAL
- en: This being a widespread and well used concept, curl also supports it—if you
    ask it to. curl does not, however, limit this feature to FTP, but can get credentials
    for machines for any protocol with this. See further below for how.
  prefs: []
  type: TYPE_NORMAL
- en: The .netrc file format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The .netrc file format is simple: you specify lines with a machine name and
    follow that with lines for the login and password that are associated with that
    machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '**machine name**'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies a remote machine name. curl searches the .netrc file for a machine
    token that matches the remote machine specified in the URL. Once a match is made,
    the subsequent .netrc tokens are processed, stopping when the end of file is reached
    or another machine is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '**login name**'
  prefs: []
  type: TYPE_NORMAL
- en: The user name string for the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**password string**'
  prefs: []
  type: TYPE_NORMAL
- en: Supply a password. If this token is present, curl will supply the specified
    string if the remote server requires a password as part of the login process.
    Note that if this token is present in the .netrc file you really **should** make
    sure the file is not readable by anyone besides the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example .netrc for the host example.com with a user named ''daniel'', using
    the password ''qwerty'' would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Enable netrc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-n, --netrc` tells curl to look for and use the .netrc file.'
  prefs: []
  type: TYPE_NORMAL
- en: '`--netrc-file [file]` is similar to `--netrc`, except that you also provide
    the path to the actual file to use. This is useful when you want to provide the
    information in another directory or with another file name.'
  prefs: []
  type: TYPE_NORMAL
- en: '`--netrc-optional` is similar to `--netrc`, but this option makes the .netrc
    usage optional and not mandatory as the `--netrc` option.'
  prefs: []
  type: TYPE_NORMAL
- en: Proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A proxy is a machine or software that does something on behalf of you, the client.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see it as a middle man that sits between you and the server you
    want to work with, a middle man that you connect to instead of the actual remote
    server. You ask the proxy to perform your desired operation for you and then it
    will run off and do that and then return back the data to you.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different types of proxies and we shall list and discuss them
    further down in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Discover your proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some networks are setup to require a proxy in order for you to reach the Internet
    or perhaps that special network you are interested in. The use of proxies are
    introduced on your network by the people and management that run your network
    for policy or technical reasons.
  prefs: []
  type: TYPE_NORMAL
- en: In the networking space there are a few methods for the automatic detection
    of proxies and how to connect to them, but none of those methods are truly universal
    and curl supports none of them. Furthermore, when you communicate to the outside
    world through a proxy that often means that you have to put a lot of trust on
    the proxy as it will be able to see and modify all the non-secure network traffic
    you send or get through it. That trust is not easy to assume automatically.
  prefs: []
  type: TYPE_NORMAL
- en: If you check your browser's network settings, sometimes under an advanced settings
    tab, you can learn what proxy or proxies your browser is configured to use. Chances
    are very big that you should use the same one or ones when you use curl.
  prefs: []
  type: TYPE_NORMAL
- en: 'TBD: screenshots of how to find proxy settings in Firefox and Chrome?'
  prefs: []
  type: TYPE_NORMAL
- en: PAC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some network environments provides several different proxies that should be
    used in different situations, and a very customizable way to handle that is supported
    by the browsers. This is called "proxy auto-config", or PAC.
  prefs: []
  type: TYPE_NORMAL
- en: A PAC file contains a JavaScript function that decides which proxy a given network
    connection (URL) should use, and even if it should not use a proxy at all. Browsers
    most typically read the PAC file off a URL on the local network.
  prefs: []
  type: TYPE_NORMAL
- en: Since curl has no JavaScript capabilities, curl doesn't support PAC files. If
    your browser and network use PAC files, the easiest route forward is usually to
    read the PAC file manually and figure out the proxy you need to specify to run
    curl successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Captive portals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (these aren't proxies but in the way)
  prefs: []
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Proxy type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: curl supports several different types of proxies.
  prefs: []
  type: TYPE_NORMAL
- en: The default proxy type is HTTP so if you specify a proxy host name (or IP address)
    without a scheme part (the part that is often written as "http://") curl goes
    with assuming it's an HTTP proxy.
  prefs: []
  type: TYPE_NORMAL
- en: curl also allows a number of different options to set the proxy type instead
    of using the scheme prefix. See the [SOCKS](#socks) section below.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An HTTP proxy is a proxy that the client speaks HTTP with to get the transfer
    done. curl will, by default, assume that a host you point out with `-x` or `--proxy`
    is an HTTP proxy, and unless you also specify a port number it will default to
    port 3128 (and the reason for that particular port number is purely historical).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to request the example.com web page using a proxy on 192.168.0.1
    port 8080, a command line could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the proxy receives your request, forwards it to the real server,
    then reads the response from the server and then hands that back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If you enable verbose mode with `-v` when talking to a proxy, you will see that
    curl connects to the proxy instead of the remote server, and you will see that
    it uses a slightly different request line.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS and proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTPS was designed to allow and provide secure and safe end-to-end privacy from
    the client to the server (and back). In order to provide that when speaking to
    an HTTP proxy, the HTTP protocol has a special request that curl uses to setup
    a tunnel through the proxy that it then can encrypt and verify. This HTTP method
    is known as `CONNECT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the proxy tunnels encrypted data through to the remote server after a
    CONNECT method sets it up, the proxy cannot see nor modify the traffic without
    breaking the encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: MITM-proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MITM means Man-In-The-Middle. MITM-proxies are usually deployed by companies
    in "enterprise environments" and elsewhere, where the owners of the network have
    a desire to investigate even TLS encrypted traffic.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, they require users to install a custom "trust root" (CA cert) in
    the client, and then the proxy terminates all TLS traffic from the client, impersonates
    the remote server and acts like a proxy. The proxy then sends back a generated
    certificate signed by the custom CA. Such proxy setups usually transparently capture
    all traffic from clients to TCP port 443 on a remote machine. Running curl in
    such a network would also get its HTTPS traffic captured.
  prefs: []
  type: TYPE_NORMAL
- en: This practice, of course, allows the middle man to decrypt and snoop on all
    TLS traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Non-HTTP protocols over an HTTP proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An "HTTP proxy" means the proxy itself speaks HTTP. HTTP proxies are primarily
    used to proxy HTTP but it is also fairly common that they support other protocols
    as well. In particular, FTP is fairly commonly supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'When talking FTP "over" an HTTP proxy, it is usually done by more or less pretending
    the other protocol works like HTTP and asking the proxy to "get this URL" even
    if the URL isn''t using HTTP. This distinction is important because it means that
    when sent over an HTTP proxy like this, curl doesn''t really speak FTP even though
    given an FTP URL; thus FTP-specific features will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What you can do instead then, is to "tunnel through" the HTTP proxy!
  prefs: []
  type: TYPE_NORMAL
- en: HTTP proxy tunneling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most HTTP proxies allow clients to "tunnel through" it to a server on the other
    side. That's exactly what's done every time you use HTTPS through the HTTP proxy.
  prefs: []
  type: TYPE_NORMAL
- en: You tunnel through an HTTP proxy with curl using `-p` or `--proxytunnel`.
  prefs: []
  type: TYPE_NORMAL
- en: When you do HTTPS through a proxy you normally connect through to the default
    HTTPS remote TCP port number 443, so therefore you will find that most HTTP proxies
    white list and allow connections only to hosts on that port number and perhaps
    a few others. Most proxies will deny clients from connecting to just any random
    port (for reasons only the proxy administrators know).
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, assuming that the HTTP proxy allows it, you can ask it to tunnel through
    to a remote server on any port number so you can do other protocols "normally"
    even when tunneling. You can do FTP tunneling like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can tell curl to use HTTP/1.0 in its CONNECT request issued to the HTTP
    proxy by using `--proxy1.0 [proxy]` instead of `-x`.
  prefs: []
  type: TYPE_NORMAL
- en: SOCKS types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SOCKS is a protocol used for proxies and curl supports it. curl supports both
    SOCKS version 4 as well as version 5, and both versions come in two flavors.
  prefs: []
  type: TYPE_NORMAL
- en: You can select the specific SOCKS version to use by using the correct scheme
    part for the given proxy host with `-x`, or you can specify it with a separate
    option instead of `-x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SOCKS4 is for the version 4 and SOCKS4a is for the version 4 without resolving
    the host name locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The SOCKS4a versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'SOCKS5 is for the version 5 and SOCKS5-hostname is for the version 5 without
    resolving the host name locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The SOCKS5-hostname versions. This sends the host name to the server so there''s
    no name resolving done locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Proxy authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP proxies can require authentication, so curl then needs to provide the proper
    credentials to the proxy to be allowed to use it, and failing to do will only
    make the proxy return back HTTP responses using code 407.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication for proxies is very similar to "normal" HTTP authentication,
    but is separate from the server authentication to allow clients to independently
    use both normal host authentication as well as proxy authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'With curl, you set the user name and password for the proxy authentication
    with the `-U user:password` or `--proxy-user user:password` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will default to using the Basic authentication scheme. Some proxies
    will require another authentication scheme (and the headers that are returned
    when you get a 407 response will tell you which) and then you can ask for a specific
    method with `--proxy-digest`, `--proxy-negotiate`, `--proxy-ntlm`. The above example
    command again, but asking for NTLM auth with the proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also the option that asks curl to figure out which method the proxy
    wants and supports and then go with that (with the possible expense of extra roundtrips)
    using `--proxy-anyauth`. Asking curl to use any method the proxy wants is then
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: HTTPS to proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the previously mentioned protocols to speak with the proxy are clear text
    protocols, HTTP and the SOCKS versions. Using these methods could allow someone
    to eavesdrop on your traffic the local network where you or the proxy reside.
  prefs: []
  type: TYPE_NORMAL
- en: One solution for that is to use HTTPS to the proxy, which then establishes a
    secure and encrypted connection that is safe from easy surveillance.
  prefs: []
  type: TYPE_NORMAL
- en: curl does not currently support HTTPS to the proxy, but there is work in progress
    for this that we hope to land in a future curl version.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: curl checks for the existence of specially-named environment variables before
    it runs to see if a proxy is requested to get used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You specify the proxy by setting a variable named `[scheme]_proxy` to hold
    the proxy host name (the same way you would specify the host with `-x`). So if
    you want to tell curl to use a proxy when access a HTTP server, you set the ''http_proxy''
    environment variable. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: While the above example shows HTTP, you can, of course, also set ftp_proxy,
    https_proxy, and so on. All these proxy environment variable names except http_proxy
    can also be specified in uppercase, like HTTPS_PROXY.
  prefs: []
  type: TYPE_NORMAL
- en: To set a single variable that controls *all* protocols, the ALL_PROXY exists.
    If a specific protocol variable one exists, such a one will take precedence.
  prefs: []
  type: TYPE_NORMAL
- en: When using environment variables to set a proxy, you could easily end up in
    a situation where one or a few host names should be excluded from going through
    the proxy. This is then done with the NO_PROXY variable. Set that to a comma-
    separated list of host names that should not use a proxy when being accessed.
    You can set NO_PROXY to be a single asterisk ('*') to match all hosts.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to the NO_PROXY variable, there's also a `--noproxy` command
    line option that serves the same purpose and works the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: --proxy-header
  prefs: []
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Exit status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exit status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of effort has gone into the project to make curl return a usable exit
    code when something goes wrong and it will always return 0 (zero) when the operation
    went as planned.
  prefs: []
  type: TYPE_NORMAL
- en: If you write a shell script or batch file that invokes curl, you can always
    check the return code to detect problems in the invoked command. Below, you will
    find a list of return codes as of the time of this writing. Over time we tend
    to slowly add new ones so if you get a code back not listed here, please refer
    to more updated curl documentation for aid.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very basic Unix shell script could look like something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Available exit codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unsupported protocol. This build of curl has no support for this protocol. Usually
    this happens because the URL was misspelled to use a scheme part that either has
    a space in front of it or spells "http" like "htpt" or similar. Another common
    mistake is that you use a libcurl installation that was built with one or more
    protocols disabled and you now ask libcurl to use one of those protocols that
    were disabled in the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failed to initialize. This is mostly an internal error or a problem with the
    libcurl installation or system libcurl runs in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: URL malformed. The syntax was not correct. This happens when you mistype a URL
    so that it ends up wrong, or in rare situations you are using a URL that is accepted
    by another tool that curl doesn't support only because there is no universal URL
    standard that everyone adheres to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A feature or option that was needed to perform the desired request was not enabled
    or was explicitly disabled at build-time. To make curl able to do this, you probably
    need another build of libcurl!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Couldn't resolve proxy. The address of the given proxy host could not be resolved.
    Either the given proxy name is just wrong, or the DNS server is misbehaving and
    doesn't know about this name when it should or perhaps even the system you run
    curl on is misconfigured so that it doesn't find/use the correct DNS server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Couldn't resolve host. The given remote host's address was not resolved. The
    address of the given server could not be resolved. Either the given host name
    is just wrong, or the DNS server is misbehaving and doesn't know about this name
    when it should or perhaps even the system you run curl on is misconfigured so
    that it doesn't find/use the correct DNS server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failed to connect to host. curl managed to get an IP address to the machine
    and it tried to setup a TCP connection to the host but failed. This can be because
    you have specified the wrong port number, entered the wrong host name, the wrong
    protocol or perhaps because there is a firewall or another network equipment in
    between that blocks the traffic from getting through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unknown FTP server response. The server sent data curl couldn't parse. This
    is either because of a bug in curl, a bug in the server or because the server
    is using an FTP protocol extension that curl doesn't support. The only real work-around
    for this is to tweak curl options to try it to use other FTP commands that perhaps
    won't get this unknown server response back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP access denied. The server denied login or denied access to the particular
    resource or directory you wanted to reach. Most often you tried to change to a
    directory that doesn't exist on the server. The directory of course is what you
    specify in the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP accept failed. While waiting for the server to connect back when an active
    FTP session is used, an error code was sent over the control connection or similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP weird PASS reply. Curl couldn't parse the reply sent to the PASS request.
    PASS in the command curl sends the password to the server with, and even anonymous
    connections to FTP server actually sends a password - a fixed anonymous string.
    Getting a response back from this command that curl doesn't understand is a strong
    indication that this isn't an FTP server at all or that the server is badly broken.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During an active FTP session (PORT is used) while waiting for the server to
    connect, the timeout expired. It took too long for the server to get back. This
    is usually a sign that something is preventing the server from reaching curl successfully.
    Like a firewall or other network arrangements. .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unknown response to FTP PASV command, Curl couldn't parse the reply sent to
    the PASV request. This is a strange server. PASV is used to setup the second data
    transfer connection in passive mode, see the [FTP uses two connections](ftp-twoconnections.html)
    section for more on that. You might be able to work-around this problem by using
    PORT instead, with the `--ftp-port` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unknown FTP 227 format. Curl couldn't parse the 227-line the server sent. This
    is most certainly a broken server. A 227 is the FTP server's response when sending
    back information on how curl should connect back to it in passive mode. You might
    be able to work-around this problem by using PORT instead, with the `--ftp-port`
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP can't get host. Couldn't use the host IP address we got in the 227-line.
    This is most likely an internal error!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP/2 error. A problem was detected in the HTTP2 framing layer. This is somewhat
    generic and can be one out of several problems, see the error message for details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP couldn't set binary. Couldn't change transfer method to binary. This server
    is broken. curl needs to set the transfer to the correct mode before it is started
    as otherwise the transfer can't work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partial file. Only a part of the file was transferred. When the transfer is
    considered complete, curl will verify that it actually received the same amount
    of data that it was told before-hand that it was going to get. If the two numbers
    don't match, this is the error code. It could mean that curl got fewer bytes than
    advertised or that it got more. curl itself cannot know which number that is wrong
    or which is correct. If any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP couldn't download/access the given file. The RETR (or similar) command failed.
    curl got an error from the server when trying to download the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quote error. A quote command returned an error from the server. curl allows
    several different ways to send custom commands to a IMAP, POP3, SMTP or FTP server
    and features a generic check that the commands work. When any of the individually
    issued commands fails, this is exit status is returned. The advice is generally
    to watch the headers in the FTP communication to better understand exactly what
    failed and how.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP page not retrieved. The requested url was not found or returned another
    error with the HTTP error code being 400 or above. This return code only appears
    if `-f, --fail` is used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write error. Curl couldn't write data to a local filesystem or similar. curl
    receives data chunk by chunk from the network and it stores it like at (or writes
    it to stdout), one piece at a time. If that write action gets an error, this is
    the exit status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload failed. The server refused to accept or store the file that curl tried
    to send to it. This is usually due to wrong access rights on the server but can
    also happen due to out of disk space or other resource constraints. This error
    can happen for many protocols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read error. Various reading problems. The inverse to exit status 23\. When curl
    sends data to a server, it reads data chunk by chunk from a local file or stdin
    or similar, and if that reading fails in some way this is the exit status curl
    will return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Out of memory. A memory allocation request failed. curl needed to allocate more
    memory than what the system was willing to give it and curl had to exit. Try using
    smaller files or make sure that curl gets more memory to work with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operation timeout. The specified time-out period was reached according to the
    conditions. curl offers several [timeouts](usingcurl-timeouts.html), and this
    exit code tells one of those timeout limits were reached. Extend the timeout or
    try changing something else that allows curl to finish its operation faster. Often,
    this happens due to network and remote server situations that you cannot affect
    locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP PORT failed. The PORT command failed. Not all FTP servers support the PORT
    command; try doing a transfer using PASV instead! The PORT command is used to
    ask the server to create the data connection by *connecting back* to curl. See
    also the [FTP uses two connections](ftp-twoconnections.html) section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP couldn't use REST. The REST command failed. This command is used for resumed
    FTP transfers. curl needs to issue the REST command to do range or resumed transfers.
    The server is broken, try the same operation without range/resume as a crude work-around!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP range error. The range request didn't work. Resumed HTTP requests aren't
    necessary acknowledged or supported, so this exit code signals that for this resource
    on this server, there can be no range or resumed transfers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP post error. Internal post-request generation error. If you get this error,
    please report the exact circumstances to the curl project!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A TLS/SSL connect error. The SSL handshake failed. The SSL handshake can fail
    due to numerous different reasons so the error message may offer some additional
    clues. Maybe the parties couldn't agree to a SSL/TLS version, an agreeable cipher
    suite or similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bad download resume. Couldn't continue an earlier aborted download. When asking
    to resume a transfer that then ends up not possible to do, this error can get
    returned. For FILE, FTP or SFTP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Couldn't read the given file when using the FILE:// scheme. Failed to open the
    file. The file could be non-existing or is it a permission problem perhaps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LDAP cannot bind. LDAP "bind" operation failed, which is a necessary step in
    the LDAP operation and thus this means the LDAP query could not be performed.
    This might happen because of wrong username or password, or for other reasons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LDAP search failed. The given search terms caused the LDAP search to return
    an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Aborted by callback. An application told libcurl to abort the operation. This
    error code is not generally made visible to users and not to users of the curl
    tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bad function argument. A function was called with a bad parameter - this return
    code is present to help application authors to understand why libcurl can't perform
    certain actions and should never be return by the curl tool. Please file a bug
    report to the curl project if this happens to you!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interface error. A specified outgoing network interface could not be used. curl
    will typically decide outgoing network and IP addresses by itself but when explicitly
    asked to use a specific one that curl can't use, this error can occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Too many redirects. When following HTTP redirects, libcurl hit the maximum number
    set by the application. The maximum number of redirects is unlimited by libcurl
    but is set to 50 by default by the curl tool. The limit is present to stop endless
    redirect loops. Change the limit with `--max-redirs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unknown option specified to libcurl. This could happen if you use a curl version
    that is out of sync with the underlying libcurl version. Perhaps your newer curl
    tries to use an option in the older libcurl that wasn''t introduced until after
    the libcurl version you''re using but is known to your curl tool code as that
    is newer. To decrease the risk of this and make sure it doesn''t happen: use curl
    and libcurl of the same version number.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Malformed telnet option. The telnet options you provide to curl was not using
    the correct syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server's SSL/TLS certificate or SSH fingerprint failed verification. curl
    can then not be sure of the server being who it claims to be. See the [using TLS
    with curl](usingcurl-tls.html) section for more TLS details and [using SCP and
    SFTP with curl](usingcurl-scpsftp.html) for more SSH specific details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server didn't reply anything, which in this context is considered an error.
    When a HTTP(S) server responds to a HTTP(S) request, it will always return *something*
    as long as it is alive and sound. All valid HTTP responses have a status line
    and responses header. Not getting anything at all back is an indication the server
    is faulty or perhaps that something prevented curl from reaching the right server
    or that you're trying to connect to the wrong port number etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSL crypto engine not found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cannot set SSL crypto engine as default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failed sending network data. Sending data over the network is a crucial part
    of most curl operations and when curl gets an error from the lowest networking
    layers that the sending failed, this exit status gets returned. To pinpoint why
    this happens, some serious digging is usually required. Start with enabling verbose
    mode, do tracing and if possible check the network traffic with a tool like Wireshark
    or similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failure in receiving network data. Receiving data over the network is a crucial
    part of most curl operations and when curl gets an error from the lowest networking
    layers that the receiving of data failed, this exit status gets returned. To pinpoint
    why this happens, some serious digging is usually required. Start with enabling
    verbose mode, do tracing and if possible check the network traffic with a tool
    like Wireshark or similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Problem with the local certificate. The client certificate had a problem so
    it couldn't be used. Permissions? The wrong pass phrase?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Couldn't use the specified SSL cipher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Peer certificate cannot be authenticated with known CA certificates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unrecognized transfer encoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invalid LDAP URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximum file size exceeded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Requested FTP SSL level failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sending the data requires a rewind that failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failed to initialize SSL Engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user name, password, or similar was not accepted and curl failed to log
    in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File not found on TFTP server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Permission problem on TFTP server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Out of disk space on TFTP server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Illegal TFTP operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unknown TFTP transfer ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File already exists (TFTP).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No such user (TFTP).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Character conversion failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Character conversion functions required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Problem with reading the SSL CA cert
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource referenced in the URL does not exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An unspecified error occurred during the SSH session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failed to shut down the SSL connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not used**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Could not load CRL file, missing or wrong format
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TLS certificate issuer check failed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The FTP PRET command failed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'RTSP: mismatch of CSeq numbers'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'RTSP: mismatch of Session Identifiers'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: unable to parse FTP file list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FTP chunk callback reported error
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No connection available, the session will be queued
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSL public key does not matched pinned public key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Error message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When curl exits with a non-zero code, it will also output an error message (unless
    `--silent` is used). That error message may add some additional information or
    circumstances to the exit status number itself so the same error number can get
    different error messages.
  prefs: []
  type: TYPE_NORMAL
- en: '"Not used"'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list of exit codes above contains a number of values marked as 'not used'.
    Those are exit status codes that aren't used in modern versions of curl but that
    have been used or were intended to be used in the past. They may very well be
    used in a future version of curl.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the highest used error status in this list is 90, but there is
    no guarantee that a future curl version won't decide to add more exit codes after
    that number.
  prefs: []
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP, the File Transfer Protocol, is probably the oldest network protocol that
    curl supports—it was created in the early 1970s. The official spec that still
    is the go-to documentation is [RFC 959](http://www.ietf.org/rfc/rfc959.txt), from
    1985, published well over a decade before the first curl release.
  prefs: []
  type: TYPE_NORMAL
- en: FTP was created in a different era of the Internet and computers and as such
    it works a little bit differently than most other protocols. These differences
    can often be ignored and things will just work, but they are also important to
    know at times when things don't run as planned.
  prefs: []
  type: TYPE_NORMAL
- en: Ping-pong
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FTP protocol is a command and response protocol; the client sends a command
    and the server responds. If you use curl's `-v` option you will get to see all
    the commands and responses during a transfer.
  prefs: []
  type: TYPE_NORMAL
- en: For an ordinary transfer, there are something like 5 to 8 commands necessary
    to send and as many responses to wait for and read. Perhaps needlessly to say,
    if the server is in a remote location there will be a lot of time waiting for
    the ping pong to go through before the actual file transfer can be set up and
    get started. For small files, the initial commands can very well take longer time
    than the actual data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Transfer mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an FTP client is about to transfer data, it specifies to the server which
    "transfer mode" it would like the upcoming transfer to use. The two transfer modes
    curl supports are 'ASCII' and 'BINARY'. Ascii is basically for text and usually
    means that the server will send the files with converted newlines while binary
    means sending the data unaltered and assuming the file is not text.
  prefs: []
  type: TYPE_NORMAL
- en: curl will default to binary transfer mode for FTP, and you ask for ascii mode
    instead with `-B, --use-ascii` or by making sure the URL ends with `;type=A`.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FTP is one of the protocols you normally don't access without a user name and
    password. It just happens that for systems that allow "anonymous" FTP access you
    can login with pretty much any name and password you like. When curl is used on
    an FTP URL to do transfer without any given user name or password, it uses the
    name `anonymous` with the password `ftp@example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to provide another user name and password, you can pass them on
    to curl either with the `-u, --user` option or embed the info in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: curl --user daniel:secret ftp://example.com/download
  prefs: []
  type: TYPE_NORMAL
- en: curl ftp://daniel:secret@example.com/download
  prefs: []
  type: TYPE_NORMAL
- en: Two connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP uses two connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FTP uses two TCP connections! The first connection is setup by the client when
    it connects to an FTP server, and is called the *control connection*. As the initial
    connection, it gets to handle authentication and changing to the correct directory
    on the remote server, etc. When the client then is ready to transfer a file, a
    second TCP connection is established and the data is transferred over that.
  prefs: []
  type: TYPE_NORMAL
- en: This setting up of a second connection causes nuisances and headaches for several
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Active connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The client can opt to ask the server to connect to the client to set it up,
    a so-called "active" connection. This is done with the PORT or EPRT commands.
    Allowing a remote host to connect back to a client on a port that the client opens
    up requires that there''s no firewall or other network appliance in between that
    refuses that to go through and that is far from always the case. You ask for an
    active transfer using `curl -P [arg]` (also known as `--ftp-port` in long form)
    and while the option allows you to specify exactly which address to use, just
    setting the same as you come from is almost always the correct choice and you
    do that with `-P -`, like this way to ask for a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You can also explicitly ask curl to not use EPRT (which is a slightly newer
    command than PORT) with the `--no-eprt` command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: Passive connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Curl defaults to asking for a "passive" connection, which means it sends a PASV
    or EPSV command to the server and then the server opens up a new port for the
    second connection that then curl connects to. Outgoing connections to a new port
    are generally easier and less restricted for end users and clients, but it then
    requires that the network in the server's end allows it.
  prefs: []
  type: TYPE_NORMAL
- en: Passive connections are enabled by default, but if you have switched on active
    before, you can switch back to passive with `--ftp-pasv`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also explicitly ask curl not to use EPSV (which is a slightly newer
    command than PASV) with the `--no-epsv` command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the server is running a funky setup so that when curl issues the PASV
    command and the server responds with an IP address for curl to connect to, that
    address is wrong and then curl fails to setup the data connection. For this (hopefully
    rare) situation, you can ask curl to ignore the IP address mentioned in the PASV
    response (`--ftp-skip-pasv-ip`) and instead use the same IP address it has for
    the control connection even for the second connection.
  prefs: []
  type: TYPE_NORMAL
- en: Firewall issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using either active or passive transfers, any existing firewalls in the network
    path pretty much have to have stateful inspection of the FTP traffic to figure
    out the new port to open that up and accept it for the second connection.
  prefs: []
  type: TYPE_NORMAL
- en: Directory traversing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to traverse directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When doing FTP commands to traverse the remote file system, there are a few
    different ways curl can proceed to reach the target file, the file the user wants
    to transfer.
  prefs: []
  type: TYPE_NORMAL
- en: multicwd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'curl can do one change directory (CWD) command for every individual directory
    down the file tree hierarchy. If the full path is `one/two/three/file.txt`, that
    method means doing three `CWD` commands before asking for the `file.txt` file
    to get transferred. This method thus creates quite a large number of commands
    if the path is many levels deep. This method is mandated by an early spec (RFC
    1738) and is how curl acts by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This then equals this FTP command/response sequence (simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: nocwd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The opposite to doing one CWD for each directory part is to not change the
    directory at all. This method asks the server using the entire path at once and
    is thus very fast. Occasionally servers have a problem with this and it isn''t
    purely standards-compliant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This then equals this FTP command/response sequence (simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: singlecwd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the in-between the other two FTP methods. This makes a single `CWD`
    command to the target directory and then it asks for the given file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This then equals this FTP command/response sequence (simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Advanced FTP use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More advanced FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP Directory listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can list a remote FTP directory with curl by making sure the URL ends with
    a trailing slash. If the URL ends with a slash, curl will presume that it is a
    directory you want to list. If it isn't actually a directory, you will most likely
    instead get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: With FTP there is no standard syntax for the directory output that is returned
    for this sort of command that uses the standard FTP command `LIST`. The listing
    is usually humanly readable and perfectly understandable but you will see that
    different servers will return the listing in slightly different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to get just a listing of all the names in a directory and thus to avoid
    the special formatting of the regular directory listings is to tell curl to `--list-only`
    (or just `-l`). curl then issues the `NLST` FTP command instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: NLST has its own quirks though, as some FTP servers list only actual *files*
    in their response to NLST; they do not include directories and symbolic links!
  prefs: []
  type: TYPE_NORMAL
- en: Uploading with FTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To upload to an FTP server, you specify the entire target file path and name
    in the URL, and you specify the local file name to upload with `-T, --upload-file`.
    Optionally, you end the target URL with a slash and then the file component from
    the local path will be appended by curl and used as the remote file name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'or to use the local file name as the remote name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'curl also supports [globbing](cmdline-globbing.html) in the -T argument so
    you can opt to easily upload a range or a series of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Custom FTP commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: FTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Common FTP problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: SCP and SFTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCP and SFTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl supports the SCP and SFTP protocols if built with the correct prerequisite
    3rd party library, [libssh2](https://www.libssh2.org/).
  prefs: []
  type: TYPE_NORMAL
- en: SCP and SFTP are both protocols that are built on top of SSH, a secure and encrypted
    data protocol that is similar to TLS but differs in a few important ways. For
    example, SSH doesn't use certificates of any sort but instead it uses public and
    private keys. Both SSH and TLS provide strong crypto and secure transfers when
    used correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The SCP protocol is generally considered to be the black sheep of the two since
    it isn't very portable and usually only works between Unix systems.
  prefs: []
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SFTP and SCP URLs are similar to other URLs and you download files using these
    protocols the same as with others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'SFTP (but not SCP) supports getting a file listing back when the URL ends with
    a trailing slash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note that both these protocols work with "users" and you don't ask for a file
    anonymously or with a standard generic name. Most systems will require that users
    authenticate, as outlined below.
  prefs: []
  type: TYPE_NORMAL
- en: When requesting a file from an SFTP or SCP URL, the file path given is considered
    to be the absolute path on the remote server unless you specifically ask for the
    path relative to the user's home directory. You do that by making sure the path
    starts with `/~/`. This is quite the opposite to how FTP URLs work and is a common
    cause for confusion among users.
  prefs: []
  type: TYPE_NORMAL
- en: 'For user `daniel` to transfer `todo.txt` from his home directory, it would
    look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Auth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Known hosts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A secure network client needs to make sure that the remote host is exactly the
    host that it thinks it is communicating with. With TLS based protocols, it is
    done by the client verifying the server's certificate.
  prefs: []
  type: TYPE_NORMAL
- en: With SSH protocols there are no server certificates, but instead each server
    can provide its unique key. And unlike TLS, SSH has no certificate authorities
    or anything so the client simply has to make sure that the host's key matches
    what it already knows (via other means) it should look like.
  prefs: []
  type: TYPE_NORMAL
- en: The matching of keys is typically done using hashes of the key and the file
    that the client stores the hashes for known servers is often called `known_hosts`
    and is put in a dedicated SSH directory. On Linux systems that is usually called
    `~/.ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: When curl connects to a SFTP and SCP host, it will make sure that the host's
    key hash is already present in the known hosts file or it will deny continued
    operation because it cannot trust that the server is the right one. Once the correct
    hash exists in `known_hosts` curl can perform transfers.
  prefs: []
  type: TYPE_NORMAL
- en: To force curl to skip checking and obeying to the the `known_hosts` file, you
    can use the `-k / --insecure` command-line option. You must use this option with
    extreme care since it makes it possible for man-in-the-middle attacks not to be
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: IMAP and POP3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two dominant protocols on the Internet for reading/downloading email
    from servers (at least if we don't count web based reading), and they are IMAP
    and POP3\. The former being the slightly more modern alternative. curl supports
    both.
  prefs: []
  type: TYPE_NORMAL
- en: POP3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To list message numbers and sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To download message 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete message 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: IMAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: SMTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SMTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SMTP stands for [Simple Mail Transfer Protocol](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol).
  prefs: []
  type: TYPE_NORMAL
- en: curl supports sending data to a an SMTP server, which combined with the right
    set of command line options makes an email get sent to a set of receivers of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: When sending SMTP with curl, there are a two necessary command line options
    that **must** be used.
  prefs: []
  type: TYPE_NORMAL
- en: You need to tell the server at least one recipient with `--mail-rcpt`. You can
    use this option several times and then curl will tell the server that all those
    email addresses should receive the email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to tell the server which email address that is the sender of the email
    with `--mail-from`. It is important to realize that this email address is not
    necessarily the same as is shown in the `From:` line of the email text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you need to provide the actual email data. This is a (text) file formatted
    according to [RFC 5322](https://tools.ietf.org/html/rfc5322.html). It is a set
    of headers and a body. Both the headers and the body need to be correctly encoded.
    The headers typically include `To:`, `From:`, `Subject:`, `Date:` etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic command to send an email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Example email.txt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Secure mail transfer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some mail providers allow or require using SSL for SMTP. They may use a dedicated
    port for SSL or allow SSL upgrading over a plaintext connection.
  prefs: []
  type: TYPE_NORMAL
- en: If your mail provider has a dedicated SSL port you can use smtps:// instead
    of smtp://, which uses the SMTP SSL port of 465 by default and requires the entire
    connection to be SSL. For example smtps://smtp.gmail.com/.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if your provider allows upgrading from plaintext to secure transfers
    you can use one of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You can tell curl to *try* but not require upgrading to secure transfers by
    adding `--ssl` to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You can tell curl to *require* upgrading to using secure transfers by adding
    `--ssl-reqd` to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The SMTP URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The path part of a SMTP request specifies the host name to present during communication
    with the mail server. If the path is omitted then curl will attempt to figure
    out the local computer's host name and use that. However, this may not return
    the fully qualified domain name that is required by some mail servers and specifying
    this path allows you to set an alternative name, such as your machine's fully
    qualified domain name, which you might have obtained from an external function
    such as gethostname or getaddrinfo.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the mail server at `mail.example.com` and send your local computer''s
    host name in the HELO / EHLO command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: You can of course as always use the `-v` option to get to see the client-server
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instead have curl send `client.example.com` in the `HELO` / `EHLO` command
    to the mail server at `mail.example.com`, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: No MX lookup!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you send email with an ordinary mail client, it will first check for an
    MX record for the particular domain you want to send email to. If you send an
    email to joe@example.com, the client will get the MX records for `example.com`
    to learn which mail server(s) to use when sending email to example.com users.
  prefs: []
  type: TYPE_NORMAL
- en: curl does no MX lookups by itself. If you want to figure out which server to
    send an email to for a particular domain, we recommend you figure that out first
    and then call curl to use those servers. Useful command line tools to get MX records
    with include 'dig' and 'nslookup'.
  prefs: []
  type: TYPE_NORMAL
- en: TELNET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TELNET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TLS stands for Transport Layer Security and is the name for the technology that
    was formerly called SSL. The term SSL hasn't really died though so these days
    both the terms TLS and SSL are often used interchangeably to describe the same
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: TLS is a cryptographic security layer "on top" of TCP that makes the data tamper
    proof and guarantees server authenticity, based on strong public key cryptography
    and digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Ciphers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When curl connections to a TLS server, it negotiates how to speak the protocol
    and that negotiation involves several parameters and variables that both parties
    need to agree to. One of the parameters is which cryptography algorithms to use,
    the so called cipher. Over time, security researchers figure out flaws and weaknesses
    in existing ciphers and they are gradually phased out over time.
  prefs: []
  type: TYPE_NORMAL
- en: Using the verbose option, `-v`, you can get information about which cipher and
    TLS version are negotiated. By using the `--ciphers` option, you can change what
    cipher to prefer in the negotiation, but mind you, this is a power feature that
    takes knowledge to know how to use in ways that don't just make things worse.
  prefs: []
  type: TYPE_NORMAL
- en: Enable TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl supports the TLS version of many protocols. HTTP has HTTPS, FTP has FTPS,
    LDAP has LDAPS, POP3 has POP3S, IMAP has IMAPS and SMTP has SMTPS.
  prefs: []
  type: TYPE_NORMAL
- en: If the server side supports it, you can use the TLS version of these protocols
    with curl.
  prefs: []
  type: TYPE_NORMAL
- en: There are two general approaches to do TLS with protocols. One of them is to
    speak TLS already from the first connection handshake while the other is to "upgrade"
    the connection from plain-text to TLS using protocol specific instructions.
  prefs: []
  type: TYPE_NORMAL
- en: With curl, if you explicitly specify the TLS version of the protocol (the one
    that has a name that ends with an 'S' character) in the URL, curl will try to
    connect with TLS from start, while if you specify the non-TLS version in the URL
    you can *usually* upgrade the connection to TLS-based with the `--ssl` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The support table looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Clear | TLS version | --ssl |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP | HTTPS | no |'
  prefs: []
  type: TYPE_TB
- en: '| LDAP | LDAPS | no |'
  prefs: []
  type: TYPE_TB
- en: '| FTP | FTPS | **yes** |'
  prefs: []
  type: TYPE_TB
- en: '| POP3 | POP3S | **yes** |'
  prefs: []
  type: TYPE_TB
- en: '| IMAP | IMAPS | **yes** |'
  prefs: []
  type: TYPE_TB
- en: '| SMTP | SMTPS | **yes** |'
  prefs: []
  type: TYPE_TB
- en: The protocols that *can* do `--ssl` all favor that method. Using `--ssl` means
    that curl will *attempt* to upgrade the connection to TLS but if that fails, it
    will still continue with the transfer using the plain-text version of the protocol.
    To make the `--ssl` option **require** TLS to continue, there's instead the `--ssl-reqd`
    option which will make the transfer fail if curl cannot successfully negotiate
    TLS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Require TLS security for your FTP transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Suggest TLS to be used for your FTP transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Connecting directly with TLS (to HTTPS://, LDAPS://, FTPS:// etc) means that
    TLS is mandatory and curl will return an error if TLS isn't negotiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get a file over HTTPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: SSL and TLS versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSL was invented in the mid 90s and has developed ever since. SSL version 2
    was the first widespread version used on the Internet but that was deemed insecure
    already a very long time ago. SSL version 3 took over from there, and it too has
    been deemed not safe enough for use.
  prefs: []
  type: TYPE_NORMAL
- en: TLS version 1.0 was the first "standard". RFC 2246 was published 1999\. After
    that, TLS 1.1 came and and in November 2016 TLS 1.2 is the gold standard. TLS
    1.3 is in the works and we expect to see it finalized and published as a standard
    by the IETF at some point during 2017.
  prefs: []
  type: TYPE_NORMAL
- en: curl is designed to use a "safe version" of SSL/TLS by default. It means that
    it will not negotiate SSLv2 or SSLv3 unless specifically told to, and in fact
    several TLS libraries no longer provide support for those protocols so in many
    cases curl is not even able to speak those protocol versions unless you make a
    serious effort.
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| --sslv2 | SSL version 2 |'
  prefs: []
  type: TYPE_TB
- en: '| --sslv3 | SSL version 3 |'
  prefs: []
  type: TYPE_TB
- en: '| --tlsv1 | TLS >= version 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| --tlsv1.0 | TLS version 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| --tlsv1.1 | TLS version 1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| --tlsv1.2 | TLS version 1.2 |'
  prefs: []
  type: TYPE_TB
- en: '| --tlsv1.3 | TLS version 1.3 |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE:** TLS version 1.3 is only supported in selected very recent development
    versions of certain TLS libraries and requires curl 7.52.0 or later.'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying server certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a secure connection to a server is not worth a lot if you cannot also
    be certain that you are communicating with the **correct** host. If we don't know
    that, we could just as well be talking with an impostor that just *appears* to
    be who we think it is.
  prefs: []
  type: TYPE_NORMAL
- en: To check that it communicates with the right TLS server, curl uses a set of
    locally stored CA certificates to verify the signature of the server's certificate.
    All servers provide a certificate to the client as part of the TLS handshake and
    all public TLS-using servers have acquired that certificate from an established
    Certificate Authority.
  prefs: []
  type: TYPE_NORMAL
- en: After some applied crypto magic, curl knows that the server is in fact the correct
    one that acquired that certificate for the host name that curl used to connect
    to it. Failing to verify the server's certificate is a TLS handshake failure and
    curl exits with an error.
  prefs: []
  type: TYPE_NORMAL
- en: In rare circumstances, you may decide that you still want to communicate with
    a TLS server even if the certificate verification fails. You then accept the fact
    that your communication may be subject to Man-In-The-Middle attacks. You lower
    your guards with the `-k` or `--insecure` option.
  prefs: []
  type: TYPE_NORMAL
- en: CA store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl needs a "CA store", a collection of CA certificates, to verify the TLS
    server it talks to.
  prefs: []
  type: TYPE_NORMAL
- en: If curl is built to use a TLS library that is "native" to your platform, chances
    are that library will use the native CA store as well. If not, curl has to either
    have been built to know where the local CA store is, or users need to provide
    a path to the CA store when curl is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: You can point out a specific CA bundle to use in the TLS handshake with the
    `--cacert` command line option. That bundle needs to be in PEM format. You can
    also set the environment variable `CURL_CA_BUNDLE` to the full path.
  prefs: []
  type: TYPE_NORMAL
- en: CA store on windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: curl built on windows that isn't using the native TLS library (Schannel), have
    an extra sequence for how the CA store can be found and used.
  prefs: []
  type: TYPE_NORMAL
- en: 'curl will search for a CA cert file named "curl-ca-bundle.crt" in these directories
    and in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: application's directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: current working directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows System directory (e.g. `C:\windows\system32`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows Directory (e.g. `C:\windows`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: all directories along `%PATH%`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Certificate pinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TLS certificate pinning is a way to verify that the public key used to sign
    the servers certificate has not changed. It is "pinned".
  prefs: []
  type: TYPE_NORMAL
- en: When negotiating a TLS or SSL connection, the server sends a certificate indicating
    its identity. A public key is extracted from this certificate and if it does not
    exactly match the public key provided to this option, curl will abort the connection
    before sending or receiving any data.
  prefs: []
  type: TYPE_NORMAL
- en: You tell curl a file name to read the sha256 value from, or you specify the
    base64 encoded hash directly in the command line with a "sha256//" prefix. You
    can specify one or more hashes like that, separated with semicolons (;).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This feature is not supported by all TLS backends.
  prefs: []
  type: TYPE_NORMAL
- en: OCSP stapling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This uses the TLS extension called Certificate Status Request to ask the server
    to provide a fresh "proof" from the CA in the handshake, that the certificate
    that it returns is still valid. This is a way to make really sure the server's
    certificate hasn't been revoked.
  prefs: []
  type: TYPE_NORMAL
- en: If the server doesn't support this extension, the test will fail and curl returns
    an error. And it is still far too common that servers don't support this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ask for the handshake to use the status request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This feature is only supported by the OpenSSL, GnuTLS and NSS backends.
  prefs: []
  type: TYPE_NORMAL
- en: Client certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TLS client certificates are a way for clients to cryptographically prove to
    servers that they are truly the right peer. A command line that uses a client
    certificate specifies the certificate and the corresponding key, and they are
    then passed on the TLS handshake with the server.
  prefs: []
  type: TYPE_NORMAL
- en: You need to have your client certificate already stored in a file when doing
    this and you should supposedly have gotten it from the right instance via a different
    channel previously.
  prefs: []
  type: TYPE_NORMAL
- en: The key is typically protected by a password that you need to provide or get
    prompted for interactively.
  prefs: []
  type: TYPE_NORMAL
- en: 'curl offers options to let you specify a single file that is both the client
    certificate and the private key concatenated using `--cert`, or you can specify
    the key file independently with `--key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'For some TLS backends you can also pass in the key and certificate using different
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: TLS auth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Different TLS backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Multiple TLS backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When things don't run the way you thought they would
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Copy as curl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copy as curl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using curl to perform an operation a user just managed to do with his or her
    browser is one of the more common requests and areas people ask for help about.
  prefs: []
  type: TYPE_NORMAL
- en: How do you get a curl command line to get a resource, just like the browser
    would get it, nice and easy? Both Chrome and Firefox have provided this feature
    for quite some time already!
  prefs: []
  type: TYPE_NORMAL
- en: From Firefox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You get the site shown with Firefox's network tools. You then right-click on
    the specific request you want to repeat in the "Web Developer->Network" tool when
    you see the HTTP traffic, and in the menu that appears you select "Copy as cURL".
    Like this screenshot below shows. The operation then generates a curl command
    line to your clipboard and you can then paste that into your favorite shell window.
    This feature is available by default in all Firefox installations.
  prefs: []
  type: TYPE_NORMAL
- en: '![copy as curl with Firefox](firefox-copy-as-curl.png)'
  prefs: []
  type: TYPE_IMG
- en: From Chrome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you pop up the More tools->Developer mode in Chrome, and you select the
    Network tab you see the HTTP traffic used to get the resources of the site. On
    the line of the specific resource you are interested in, you right-click with
    the mouse and you select "Copy as cURL" and it will generate a command line for
    you in your clipboard. Paste that in a shell to get a curl command line that makes
    the transfer. This feature is available by default in all Chrome and Chromium
    installations.
  prefs: []
  type: TYPE_NORMAL
- en: '![copy as curl with Chrome](chrome-copy-as-curl.png)'
  prefs: []
  type: TYPE_IMG
- en: On Firefox, without using the devtools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If this is something you would like to get done more often, you probably find
    using the developer tools a bit inconvenient and cumbersome to pop up just to
    get the command line copied. Then [cliget](https://addons.mozilla.org/en-US/firefox/addon/cliget/)
    is the perfect add-on for you as it gives you a new option in the right-click
    menu, so you can get a quick command line generated really quickly, like this
    example when I right-click an image in Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![cliget with Firefox](firefox-cliget.png)'
  prefs: []
  type: TYPE_IMG
- en: Not perfect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These methods all give you a command line to reproduce their HTTP transfers,
    but you will also learn they they are still often not the perfect solution to
    your problems. Why? Well mostly because these tools are written to rerun the *exact*
    same request that you copied, while you often want to rerun the same logic but
    not sending an exact copy of the same cookies and file contents etc.
  prefs: []
  type: TYPE_NORMAL
- en: These tools will give you command lines with static and fixed cookie contents
    to send in the request, because that is the contents of the cookies that were
    sent in the browser's requests. You will most likely want to rewrite the command
    line to dynamically adapt to whatever the content is in the cookie that the server
    told you in a previous response. And so on.
  prefs: []
  type: TYPE_NORMAL
- en: The copy as curl functionality is also often notoriously bad at using `-F` and
    instead they provide handcrafted `--data-binary` solutions including the mime
    separator strings etc.
  prefs: []
  type: TYPE_NORMAL
- en: curl examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: curl examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Fetch many variations on a URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Follow redirects automatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Impersonating a specific web browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Issuing a web search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Tell the server where you didn't come from
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Maintain state with cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Login to a web service with POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Upload a file as with a HTML form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
