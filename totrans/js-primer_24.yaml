- en: 関数とスコープ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/function-scope/](https://jsprimer.net/basic/function-scope/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 定義された関数はそれぞれのスコープを持っています。スコープとは変数や関数の引数などを参照できる範囲を決めるものです。 JavaScriptでは、新しい関数を定義するとその関数にひもづけられた新しいスコープが作成されます。関数を定義するということは処理をまとめるというだけではなく、変数が有効な範囲を決める新しいスコープを作っていると言えます。
  prefs: []
  type: TYPE_NORMAL
- en: スコープの仕組みを理解することは関数をより深く理解することにつながります。なぜなら関数とスコープは密接な関係を持っているからです。 この章では関数とスコープの関係を中心に、スコープとはどのような働きをしていて、スコープ内では変数の名前から取得する値がどのように決まるかを見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptのスコープは、ES2015において直感的に理解しやすい仕組みが整備されました。 基本的にはES2015以降の仕組みを理解していればコードを書く場合には問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: しかし、既存のコードを理解するためには、ES2015より前に決められた古い仕組みについても知る必要があります。 なぜなら、既存のコードは古い仕組みを使って書かれていることもあるためです。
    また、JavaScriptでは古い仕組みと新しい仕組みを混在して書くことができます。 古い仕組みによるスコープは直感的でない挙動も多いため、古い仕組みについても補足していきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#what-is-scope)*スコープとは*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*スコープとは変数の名前や関数などの参照できる範囲を決めるものです。 スコープの中で定義された変数はスコープの内側でのみ参照でき、スコープの外側からは参照できません。'
  prefs: []
  type: TYPE_NORMAL
- en: 身近なスコープの例として関数によるスコープを見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`fn`関数のブロック（`{`と`}`）内で変数`x`を定義しています。 この変数`x`は`fn`関数のスコープに定義されているため、`fn`関数の内側では参照できます。
    一方、`fn`関数の外側から変数`x`は参照できないため`ReferenceError`が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: このコードを見てわかるように、変数`x`は`fn`関数のスコープにひもづけて定義されます。 そのため、変数`x`は`fn`関数のスコープ内でのみ参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: 関数は**仮引数**を持てますが、仮引数は関数のスコープにひもづけて定義されます。 そのため、仮引数はその関数の中でのみ参照が可能で、関数の外からは参照できません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: このような、関数によるスコープのことを**関数スコープ**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: 「[変数と宣言](../variables/)」の章にて、`let`や`const`は同じスコープ内に同じ名前の変数を二重に定義できないという話をしました。
    これは、各スコープには同じ名前の変数は1つしか宣言できないためです（`var`による変数宣言と`function`による関数宣言は例外的に可能です）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 一方、スコープが異なれば同じ名前で変数を宣言できます。 次のコードでは、`fnA`関数と`fnB`関数という異なるスコープで、それぞれ変数`x`を定義できていることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: このように、スコープが異なれば同じ名前の変数を定義できます。 スコープの仕組みがないと、グローバルな空間内で一意な変数名を考える必要があります。 スコープがあることで同じ名前の変数をスコープごとに定義できるため、スコープの役割は重要です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#block-scope)*ブロックスコープ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`{`と`}`で囲んだ範囲をブロックと呼びます（「[文と式](../statement-expression/)」の章を参照）。 ブロックもスコープを作成します。
    ブロック内で宣言された変数は、スコープ内でのみ参照でき、スコープの外側からは参照できません。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ブロックによるスコープのことを**ブロックスコープ**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: if文やwhile文などもブロックスコープを作成します。 単独のブロックと同じく、ブロックの中で宣言した変数は外から参照できません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: for文は、ループごとに新しいブロックスコープを作成します。 このことは「各スコープには同じ名前の変数は1つしか宣言できない」のルールを考えてみるとわかりやすいです。
    次のコードでは、ループごとに`const`で`element`変数を定義していますが、エラーなく定義できています。 これは、ループごとに別々のブロックスコープが作成され、変数の宣言もそれぞれ別々のスコープで行われるためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[](#scope-chain)*スコープチェーン*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*関数やブロックはネスト（入れ子）して書けますが、同様にスコープもネストできます。 次のコードではブロックの中にブロックを書いています。 このとき外側のブロックスコープのことを`OUTER`、内側のブロックスコープのことを`INNER`と呼ぶことにします。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: スコープがネストしている場合に、内側のスコープから外側のスコープにある変数を参照できます。 次のコードでは、内側のINNERブロックスコープから外側のOUTERブロックスコープに定義されている変数`x`を参照できます。
    これは、ブロックスコープに限らず関数スコープでも同様です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 変数を参照する際には、現在のスコープ（変数を参照する式が書かれているスコープ）から外側のスコープへと順番に変数が定義されているかを確認します。 上記のコードでは、内側のINNERブロックスコープには変数`x`はありませんが、外側のOUTERブロックスコープに変数`x`が定義されているため参照できます。
    つまり、次のようなステップで参照したい変数を探索しています。
  prefs: []
  type: TYPE_NORMAL
- en: INNERブロックスコープに変数`x`があるかを確認 => ない
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ひとつ外側のOUTERブロックスコープに変数`x`があるかを確認 => ある
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 一方、現在のスコープも含め、外側のどのスコープにも該当する変数が定義されていない場合は、`ReferenceError`の例外が発生します。 次の例では、どのスコープにも存在しない`xyz`を参照しているため、`ReferenceError`の例外が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: このときも、現在のスコープ（変数を参照する式が書かれているスコープ）から外側のスコープへと順番に変数が定義されているかを確認しています。 しかし、どのスコープにも変数`xyz`は定義されていないため、`ReferenceError`の例外が発生していました。
    つまり次のようなステップで参照したい変数を探索しています。
  prefs: []
  type: TYPE_NORMAL
- en: INNERブロックスコープに変数`xyz`があるかを確認 => ない
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ひとつ外側のOUTERブロックスコープに変数`xyz`があるかを確認 => ない
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 一番外側のスコープにも変数`xyz`は定義されていない => `ReferenceError`が発生
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: この内側から外側のスコープへと順番に変数が定義されているか探す仕組みのことを**スコープチェーン**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: 内側と外側のスコープ両方に同じ名前の変数が定義されている場合もスコープチェーンの仕組みで解決できます。 次のコードでは、内側のINNERブロックスコープと外側のOUTERブロックスコープに同じ名前の変数`x`が定義されています。
    スコープチェーンの仕組みにより、現在のスコープに定義されている変数`x`を優先的に参照します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: このようにスコープは階層的な構造となっており、変数を参照する際にどの変数が参照できるかはスコープチェーンによって解決されています。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#global-scope)*グローバルスコープ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*今までコードをプログラム直下に書いていましたが、ここにも暗黙的な**グローバルスコープ**（大域スコープ）と呼ばれるスコープが存在します。 グローバルスコープとは名前のとおりもっとも外側にあるスコープで、プログラム実行時に暗黙的に作成されます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: グローバルスコープで定義した変数は**グローバル変数**と呼ばれ、グローバル変数はあらゆるスコープから参照できる変数となります。 なぜなら、スコープチェーンの仕組みにより、最終的にもっとも外側のグローバルスコープに定義されている変数を参照できるためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: グローバルスコープには自分で定義したグローバル変数以外に、プログラム実行時に自動的に定義される**ビルトインオブジェクト**があります。
  prefs: []
  type: TYPE_NORMAL
- en: ビルトインオブジェクトには、大きく分けて2種類のものがあります。 1つ目はECMAScript仕様が定義する`undefined`のような変数（「[undefinedはリテラルではない](../data-type/#undefined-is-not-literal)」を参照）や`isNaN`のような関数、`Array`や`RegExp`などのコンストラクタ関数です。2つ目は実行環境（ブラウザやNode.jsなど）が定義するオブジェクトで`document`や`module`などがあります。
    どちらもグローバルスコープに自動的に定義されているという点で大きな使い分けはないため、この章ではどちらも**ビルトインオブジェクト**と呼ぶことにします。
  prefs: []
  type: TYPE_NORMAL
- en: ビルトインオブジェクトは、プログラム開始時にグローバルスコープへ自動的に定義されているためどのスコープからも参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 自分で定義したグローバル変数とビルトインオブジェクトでは、グローバル変数が優先して参照されます。 つまり次のようにビルトインオブジェクトと同じ名前の変数を定義すると、定義した変数が参照されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: ビルトインオブジェクトと同じ名前の変数を定義したことにより、ビルトインオブジェクトを参照できなくなります。 このように内側のスコープで外側のスコープと同じ名前の変数を定義することで、外側の変数が参照できなくなることを**変数の隠蔽**（shadowing）と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: この問題を回避する方法としては、むやみにグローバルスコープへ変数を定義しないことです。グローバルスコープでビルトインオブジェクトと名前が衝突するとすべてのスコープへ影響を与えますが、関数のスコープ内では影響範囲がその関数の中だけにとどまります。
  prefs: []
  type: TYPE_NORMAL
- en: ビルトインオブジェクトと同じ名前を避けることは難しいです。 なぜならビルトインオブジェクトには実行環境（ブラウザやNode.jsなど）がそれぞれ独自に定義したものが多く存在するためです。
    関数などを活用して小さなスコープを中心にしてプログラムを書くことで、ビルトインオブジェクトと同じ名前の変数があっても影響範囲を限定できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#reduce-scope)*[コラム] 変数を参照できる範囲を小さくする*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*グローバル変数に限らず、特定の変数を参照できる範囲を小さくするのはよいことです。 なぜなら、現在のスコープの変数を参照するつもりがグローバル変数を参照したり、その逆も起きることがあるからです。
    あらゆる変数がグローバルスコープにあると、どこでその変数が参照されているのかを把握できなくなります。 これを避けるシンプルな考え方は、変数はできるだけ利用するスコープ内に定義するというものです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`doHeavyTask`関数の実行時間を計測しようとしています。 `Date.now`メソッドは現在の時刻をミリ秒にして返す関数です。
    `Date.now`メソッドを使った**実行後の時刻**から**実行前の時刻**を引くことで、間に行われた処理の実行時間が得られます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: このコードでは、計測処理以外で利用しない`startTime`と`endTime`という変数がグローバルスコープに定義されています。 プログラム全体が短い場合はあまり問題になりませんが、プログラムが長くなっていくにつれ影響の範囲が広がっていきます。
    この2つの変数を参照できる範囲を小さくする簡単な方法は、この実行時間を計測する処理を関数にすることです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: これにより、`startTime`と`endTime`という変数をグローバルスコープからなくせました。 また、実行時間を計測するという処理を`measureTask`という関数にしたことで再利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: コードの量が増えていくにつれ、人が一度に把握できる量にも限界がやってきます。 そのため、人が一度に把握できる範囲のサイズに処理をまとめていくことが必要です。
    この問題を解決するアプローチとして、変数を参照できる範囲を小さくするために、処理を関数にまとめるという手法がよく利用されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#hoisting-var)*関数スコープとvarの巻き上げ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*変数宣言には`var`、`let`、`const`が利用できます。 「[変数と宣言](../variables/)」の章において、「`let`は`var`を改善したバージョン」と紹介したように、`let`は`var`を改善する目的で導入された構文です。`const`は再代入できないという点以外は`let`と同じ動作になります。そのため、`let`が使える場合に`var`を使う理由はありませんが、既存のコードや既存のライブラリなどでは`var`が利用されている場面もあるため、`var`の動作を理解する必要があります。'
  prefs: []
  type: TYPE_NORMAL
- en: まず最初に、`let`と`var`で共通する動作を見ていきます。 `let`と`var`どちらも、初期値を指定せずに宣言した変数の評価結果は暗黙的に`undefined`になります。
    また、`let`と`var`どちらも、変数宣言をした後に値を代入できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、それぞれ初期値を持たない変数を**宣言した後**に参照すると、変数の評価結果は`undefined`となっています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 次に、`let`と`var`で異なる動作を見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '`let`では、変数を**宣言する前**にその変数を参照すると`ReferenceError`の例外が発生して参照できません。 次のコードでは、変数を宣言する前に変数`x`を参照したため`ReferenceError`となっています。
    エラーメッセージから、変数`x`が存在しないからエラーになっているのではなく、実際に宣言した行より前に参照したためエラーとなっているのがわかります。^([1](#fn_1))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 一方`var`では、変数を**宣言する前**にその変数を参照しても`undefined`となります。 次のコードは、変数を宣言する前に参照しているにもかかわらずエラーにはならず、変数`x`の評価結果は`undefined`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: このように`var`で宣言された変数が宣言前に参照でき、その値が`undefined`となる特殊な動きをしていることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: この`var`の振る舞いを理解するために、変数宣言が**宣言**と**代入**の2つの部分から構成されていると考えてみましょう。 `var`による変数宣言は、**宣言**部分が暗黙的にもっとも近い関数またはグローバルスコープの先頭に巻き上げられ、**代入**部分はそのままの位置に残るという特殊な動作をします。
  prefs: []
  type: TYPE_NORMAL
- en: この動作により、変数`x`を参照するコードより前に変数`x`の宣言部分が移動し、変数`x`の評価結果は暗黙的に`undefined`となっています。 つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: さらに、`var`変数の宣言の巻き上げは、ブロックスコープを無視してもっとも近い関数またはグローバルスコープに変数をひもづけます。 そのため、次のようにブロック`{}`で`var`による変数宣言を囲んでも、もっとも近い関数スコープである`fn`関数の直下に**宣言**部分が巻き上げられます
    （if文やfor文におけるブロックスコープも同様に無視されます）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: この変数の**宣言**部分がもっとも近い関数またはグローバルスコープの先頭に移動しているように見える動作のことを変数の**巻き上げ**（hoisting）と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: このように`var`は`let`、`const`とは異なった動作をしています。 `var`は巻き上げによりブロックスコープを無視して、宣言部分を自動的に関数スコープの先頭に移動するという予測しにくい問題を持っています。
    この問題のもっとも簡単な回避方法は`var`を使わないことですが、`var`を含んだコードではこの動作に気をつける必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#function-declaration-hoisting)*関数宣言と巻き上げ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`function`キーワードを使った関数宣言も`var`と同様に、もっとも近い関数またはグローバルスコープの先頭に**巻き上げ**られます。 次のコードでは、実際に`hello`関数を宣言した行より前に関数を呼び出せます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: これは、関数宣言は**宣言**そのものであるため、`hello`関数そのものがスコープの先頭に巻き上げられます。 つまり先ほどのコードは、次のように解釈されて実行されていると考えられます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`function`キーワードによる関数宣言も巻き上げられます。 しかし、`var`による変数宣言の巻き上げとは異なり、問題となることはほとんどありません。
    なぜなら、実際に巻き上げられた関数を呼び出せるためです。'
  prefs: []
  type: TYPE_NORMAL
- en: 注意点として、`var`で宣言された変数へ関数を代入した場合は`var`のルールで巻き上げられます。 そのため、`var`で変数へ関数を代入する関数式では、`hello`変数が巻き上げにより`undefined`となるため呼び出せません（「[関数と宣言（関数式）](../function-declaration/#function-expression)」を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[](#immediate-function)*[コラム] 即時実行関数*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*即時実行関数（**IIFE**, *Immediately-Invoked Function Expression*）は、 グローバルスコープの汚染を避けるために生まれたイディオムです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のように、無名関数を宣言した直後に呼び出すことで、任意の処理を関数のスコープに閉じて実行できます。 関数スコープを作ることで`foo`変数は無名関数の外側からはアクセスできません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 関数を**式**として定義して、そのまま呼び出しています。 `function`からはじまってしまうとJavaScriptエンジンが**関数宣言**と解釈してしまうため、無害なカッコなどで囲んで**関数式**として解釈させるのが特徴的な記法です。これは次のように書いた場合と意味は同じですが、無名関数を定義して実行するため短く書くことができ、余計な関数定義がグローバルスコープに残りません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ECMAScript 5までは、変数を宣言する方法は`var`しか存在しませんでした。 そのため、即時実行関数は`var`によるグローバルスコープの汚染を防ぐために使われていました。
  prefs: []
  type: TYPE_NORMAL
- en: しかしECMAScript 2015で導入された`let`と`const`により、ブロックスコープに対して変数宣言できるようになりました。 そのため、グローバルスコープの汚染を防ぐための即時実行関数は不要です。
    先ほどの即時実行関数は次のように`let`や`const`とブロックスコープで置き換えられます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[](#closure)*クロージャー*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*最後にこの章ではクロージャーと呼ばれる関数とスコープに関わる性質について見ていきます。 クロージャーとは「外側のスコープにある変数への参照を保持できる」という関数が持つ性質のことです。'
  prefs: []
  type: TYPE_NORMAL
- en: クロージャーは言葉で説明しただけではわかりにくい性質です。 このセクションでは、クロージャーを使ったコードがどのように動くのかを理解することを目標にします。
  prefs: []
  type: TYPE_NORMAL
- en: 次の例では`createCounter`関数が、関数内で定義した`increment`関数を返しています。 その返された`increment`関数を`myCounter`変数に代入しています。この`myCounter`変数を実行するたびに1,
    2, 3と1ずつ増えた値を返しています。
  prefs: []
  type: TYPE_NORMAL
- en: さらに、もう一度`createCounter`関数を実行して、その返り値を`newCounter`変数に代入します。 `newCounter`変数も実行するたびに1ずつ増えていますが、`myCounter`変数とその値を共有しているわけではないことがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: このように、まるで関数が状態（ここでは1ずつ増える`count`という値）を持っているように振る舞える仕組みの背景にはクロージャーがあります。 クロージャーは直感的に理解しにくいため、まずはクロージャーを理解するために必要な「静的スコープ」と「メモリ管理の仕組み」について見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#static-scope)*静的スコープ*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*クロージャーを理解するために、今まで意識してこなかったスコープの性質について見ていきます。 JavaScriptのスコープには、どの識別子がどの変数を参照するかが静的に決定されるという性質があります。
    つまり、コードを実行する前にどの識別子がどの変数を参照しているかがわかるということです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のような例を見てみます。 `printX`関数内で変数`x`を参照していますが、変数`x`はグローバルスコープと関数`run`の中で、それぞれ定義されています。
    このとき`printX`関数内の`x`という識別子がどの変数`x`を参照するかは静的に決定されます。
  prefs: []
  type: TYPE_NORMAL
- en: 結論から言えば、`printX`関数中にある識別子`x`はグローバルスコープ（＊1）の変数`x`を参照します。 そのため、`printX`関数の実行結果は常に`10`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: スコープチェーンの仕組みを思い出すと、この識別子`x`は次のように名前解決されてグローバルスコープの変数`x`を参照することがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '`printX`の関数スコープに変数`x`が定義されていない'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ひとつ外側のスコープ（グローバルスコープ）を確認する
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ひとつ外側のスコープに`const x = 10;`が定義されているので、識別子`x`はこの変数を参照する
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: つまり、`printX`関数中に書かれた`x`という識別子は、`run`関数の実行とは関係なく、静的に＊1で定義された変数`x`を参照することが決定されます。
    このように、どの識別子がどの変数を参照しているかを静的に決定する性質を**静的スコープ**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: この静的スコープの仕組みは`function`キーワードを使った関数宣言、メソッド、Arrow Functionなどすべての関数で共通する性質です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#dynamic-scope)*[コラム] 動的スコープ*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptは静的スコープです。 しかし、動的スコープという呼び出し元により識別子がどの変数を参照するかが変わる仕組みを持つ言語もあります。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードは、動的スコープの動きを説明する**疑似的な言語のコード例**です。 識別子`x`が呼び出し元のスコープを参照する仕組みである場合には、次のような結果になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: このように関数呼び出し時に呼び出し元のスコープの変数を参照する仕組みを**動的スコープ**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptは変数や関数の参照先は静的スコープで決まるため、上記のような動的スコープではありません。 しかし、JavaScriptでも`this`という特別なキーワードだけは、呼び出し元によって動的に参照先が変わります。
    `this`というキーワードについては次の章で解説します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#memory-management)*メモリ管理の仕組み*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*プログラミング言語は、使わなくなった変数やデータを解放する仕組みを持っています。 なぜなら、変数や関数を定義すると定義されたデータはメモリ上に確保されますが、ハードウェアのメモリは有限だからです。
    そのため、メモリからデータがあふれないように、必要なタイミングで不要なデータをメモリから解放する必要があります。'
  prefs: []
  type: TYPE_NORMAL
- en: 不要なデータをメモリから解放する方法は言語によって異なりますが、JavaScriptでは**ガベージコレクション**が採用されています。 ガベージコレクションとは、どこからも参照されなくなったデータを不要なデータと判断して自動的にメモリ上から解放する仕組みのことです。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptにはガベージコレクションがあるため、手動でメモリを解放するコードを書く必要はありません。 しかし、ガベージコレクションといったメモリ管理の仕組みを理解することは、スコープやクロージャーに関係するため大切です。
  prefs: []
  type: TYPE_NORMAL
- en: どのようなタイミングでメモリ上から不要なデータが解放されるのか、具体的な例を見てみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: 次の例では、最初に`"before text"`という文字列のデータがメモリ上に確保され、変数`x`はそのメモリ上のデータを参照しています。 その後、`"after
    text"`という新しい文字列のデータを作り、変数`x`はその新しいデータへ参照先を変えています。
  prefs: []
  type: TYPE_NORMAL
- en: このとき、最初にメモリ上へ確保した`"before text"`という文字列のデータはどこからも参照されなくなっています。 どこからも参照されなくなった時点で不要になったデータと判断されるためガベージコレクションの回収対象となります。
    その後、任意のタイミングでガベージコレクションによって回収されてメモリ上から解放されます。^([2](#fn_2))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 次にこのガベージコレクションと関数の関係性について考えてみましょう。 よくある誤解として「関数の中で作成したデータは、その関数の実行が終了したら解放される」というのがあります。
    関数の中で作成したデータは、その関数の実行が終了した時点で必ずしも解放されるわけではありません。
  prefs: []
  type: TYPE_NORMAL
- en: 具体的に、「関数の実行が終了した際に解放される場合」と「関数の実行が終了しても解放されない場合」の例をそれぞれ見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: まずは、関数の実行が終了した際に解放されるデータの例です。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`printX`関数の中で変数`x`を定義しています。 この変数`x`は、`printX`関数が実行されるたびに定義され、実行終了後にどこからも参照されなくなります。
    どこからも参照されなくなったものは、ガベージコレクションによって回収されてメモリ上から解放されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 次に、関数の実行が終了しても解放されないデータの例です。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`createArray`関数の中で定義された変数`tempArray`は、`createArray`関数の返り値となっています。 この、関数で定義された変数`tempArray`は返り値として、別の変数`array`に代入されています。
    つまり、変数`tempArray`が参照している配列オブジェクトは、`createArray`関数の実行終了後も変数`array`から参照され続けています。
    ひとつでも参照されているならば、そのデータが自動的に解放されることはありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: つまり、関数の実行が終了したことと関数内で定義したデータの解放のタイミングは直接関係ないことがわかります。 そのデータがメモリ上から解放されるかどうかはあくまで、そのデータが参照されているかによって決定されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#why-closure-work)*クロージャーがなぜ動くのか*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ここまでで「静的スコープ」と「メモリ管理の仕組み」について説明してきました。'
  prefs: []
  type: TYPE_NORMAL
- en: '静的スコープ: ある変数がどの値を参照するかは静的に決まる'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'メモリ管理の仕組み: 参照されなくなったデータはガベージコレクションにより解放される'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: クロージャーとはこの２つの仕組みを利用して、関数内から特定の変数を参照し続けることで関数が状態を持てる仕組みのことを言います。
  prefs: []
  type: TYPE_NORMAL
- en: 最初にクロージャーの例として紹介した`createCounter`関数の例を改めて見てみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: つまり次のような参照の関係が`myCounter`変数と`count`変数の間にはあることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '`myCounter`変数は`createCounter`関数の返り値である`increment`関数を参照している'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myCounter`変数は`increment`関数を経由して`count`変数を参照している'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myCounter`変数を実行した後も`count`変数への参照は保たれている'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myCounter` → `increment` → `count`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`count`変数を参照するものがいるため、`count`変数は自動的に解放されません。 そのため`count`変数の値は保持され続け、`myCounter`変数を実行するたびに1ずつ大きくなっていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: このように`count`変数が自動解放されずに保持できているのは「`increment`関数内から外側の`createCounter`関数スコープにある`count`変数を参照している」ためです。
    このような性質のことを**クロージャー**（関数閉包）と呼びます。クロージャーは「静的スコープ」と「参照され続けている変数のデータが保持される」という2つの性質によって成り立っています。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptの関数は静的スコープとメモリ管理という2つの性質を常に持っています。そのため、ある意味ではすべての関数がクロージャーとなりますが、ここでは関数が特定の変数を参照することで関数が状態を持っていることを指します。
  prefs: []
  type: TYPE_NORMAL
- en: 先ほどの例では`createCounter`関数を実行するたびに、それぞれ`count`と`increment`関数が定義されます。そのため、`createCounter`関数を実行すると、それぞれ別々の`increment`関数が定義され、別々の`count`変数を参照します。
  prefs: []
  type: TYPE_NORMAL
- en: 次のように`createCounter`関数を複数回呼び出してみると、別々の状態を持っていることが確認できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[](#closure-usecase)*クロージャーの用途*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*クロージャーはさまざまな用途に利用されますが、次のような用途で利用されることが多いです。'
  prefs: []
  type: TYPE_NORMAL
- en: 関数に状態を持たせる手段として
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 外から参照できない変数を定義する手段として
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: グローバル変数を減らす手段として
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 高階関数の一部分として
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: これらはクロージャーの特徴でもあるので、同時に使われることがあります。
  prefs: []
  type: TYPE_NORMAL
- en: たとえば次の例では、`privateCount`という変数を関数の中に定義しています。 この`privateCount`変数は、外のグローバルスコープからは直接参照できません。
    外から参照する必要がない変数をクロージャーとなる関数に閉じ込めることで、グローバルに定義する変数を減らせています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: また、関数を返す関数のことを高階関数と呼びますが、クロージャーの性質を使うことで次のように`n`より大きいかを判定する高階関数を作れます。 最初から`greaterThan5`という関数を定義すればよいのですが、高階関数を使うことで条件を後から定義できるなどの柔軟性があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: クロージャーは、変数が参照する値が静的に決まる静的スコープという性質とデータは参照されていれば保持されるという2つの性質によって成り立っています。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptには、関数を短く定義できるArrow Functionや高階関数であるArrayの`forEach`メソッドなどクロージャーを自然と利用しやすい環境があります。
    関数を理解する上ではクロージャーを理解することが大切です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#closure-vs-function-object)*[コラム] 状態を持つ関数オブジェクト*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptでは関数はオブジェクトの一種です。オブジェクトであるため直接プロパティに値を代入できます。 そのため、クロージャーを使わなくても、次のように関数にプロパティとして状態を持たせることが可能です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: しかし、この方法は推奨されていません。なぜなら、関数の外から`count`プロパティを変更できるためです。 関数オブジェクトのプロパティは外からも参照でき、そのプロパティ値は変更できます。
    関数の中でのみ参照可能な状態を扱いたい場合には、それを強制できるクロージャーが有効です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[](#conclusion)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では関数を中心にスコープについて学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: 関数やブロックはスコープを持つ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: スコープはネストできる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: もっとも外側にはグローバルスコープがある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: スコープチェーンは内側から外側のスコープへと順番に変数が定義されているか探す仕組みのこと
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var`キーワードでの変数宣言や`function`での関数宣言では巻き上げが発生する'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: クロージャーは静的スコープとメモリ管理の仕組みからなる関数が持つ性質
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ¹. この仕組みはTemporal Dead Zone（TDZ）と呼ばれます。 [↩](#reffn_1 "Jump back to footnote
    [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ². ECMAScriptの仕様ではガベージコレクションの実装の規定はないため、実装依存の処理となります。 [↩](#reffn_2 "Jump back
    to footnote [2] in the text.")****************
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
