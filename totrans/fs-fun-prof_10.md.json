["```\npublic void IfThenElseStatement(bool aBool) {\n   int result;     //what is the value of result before it is used?\n   if (aBool)\n   {\n      result = 42; //what is the result in the 'else' case?\n   }\n   Console.WriteLine(\"result={0}\", result);\n} \n```", "```\npublic void IfThenElseExpression(bool aBool) {\n    int result = aBool ? 42 : 0;\n    Console.WriteLine(\"result={0}\", result);\n} \n```", "```\nlet IfThenElseStatement aBool = \n   let mutable result = 0       // mutable keyword required\n   if (aBool) then result <- 42 \n   printfn \"result=%i\" result \n```", "```\nlet IfThenElseExpression aBool = \n   let result = if aBool then 42 else 0   \n                // note that the else case must be specified \n   printfn \"result=%i\" result \n```", "```\npublic int StandaloneSubexpression(bool aBool) {\n    return aBool ? 42 : 0;\n}\n\npublic void IfThenElseExpressionRefactored(bool aBool) {\n    int result = StandaloneSubexpression(aBool);\n    Console.WriteLine(\"result={0}\", result);\n} \n```", "```\nlet StandaloneSubexpression aBool = \n   if aBool then 42 else 0   \n\nlet IfThenElseExpressionRefactored aBool = \n   let result = StandaloneSubexpression aBool \n   printfn \"result=%i\" result \n```", "```\npublic void LoopStatement() {\n    int i;    //what is the value of i before it is used? \n    int length;\n    var array = new int[] { 1, 2, 3 };\n    int sum;  //what is the value of sum if the array is empty?\n\n    length = array.Length;   //what if I forget to assign to length?\n    for (i = 0; i < length; i++)\n    {\n        sum += array[i];\n    }\n\n    Console.WriteLine(\"sum={0}\", sum);\n} \n```", "```\npublic void LoopStatementBetter() {\n    var array = new int[] { 1, 2, 3 };\n    int sum = 0;        // initialization is required\n\n    for (var i = 0; i < array.Length; i++)\n    {\n        sum += array[i];\n    }\n\n    Console.WriteLine(\"sum={0}\", sum);\n} \n```", "```\npublic void LoopStatementForEach() {\n    var array = new int[] { 1, 2, 3 };\n    int sum = 0;        // initialization is required\n\n    foreach (var i in array)\n    {\n        sum += i;\n    }\n\n    Console.WriteLine(\"sum={0}\", sum);\n} \n```", "```\npublic void LoopExpression() {\n    var array = new int[] { 1, 2, 3 };\n\n    var sum = array.Aggregate(0, (sumSoFar, i) => sumSoFar + i);\n\n    Console.WriteLine(\"sum={0}\", sum);\n} \n```", "```\n1                            // literal\n[1;2;3]                      // list expression\n-2                           // prefix operator \n2 + 2                        // infix operator \n\"string\".Length              // dot lookup\nprintf \"hello\"               // function application \n```", "```\nfun () -> 1                  // lambda expression\n\nmatch 1 with                 // match expression\n    | 1 -> \"a\"\n    | _ -> \"b\"\n\nif true then \"a\" else \"b\"    // if-then-else\n\nfor i in [1..10]             // for loop\n  do printf \"%i\" i\n\ntry                          // exception handling\n  let result = 1 / 0\n  printfn \"%i\" result\nwith\n  | e -> \n     printfn \"%s\" e.Message\n\nlet n=1 in n+2               // let expression \n```", "```\nlet x1 = fun () -> 1                  \n\nlet x2 = match 1 with                 \n         | 1 -> \"a\"\n         | _ -> \"b\"\n\nlet x3 = if true then \"a\" else \"b\"    \n\nlet x4 = for i in [1..10]             \n          do printf \"%i\" i\n\nlet x5 = try                          \n            let result = 1 / 0\n            printfn \"%i\" result\n         with\n            | e -> \n                printfn \"%s\" e.Message\n\nlet x6 = let n=1 in n+2 \n```", "```\nlet x5 = let n=1 in n+2 \n```", "```\nlet f x =                           // one expression per line\n      printfn \"x=%i\" x\n      x + 1\n\nlet f x = printfn \"x=%i\" x; x + 1   // all on same line with \";\" \n```", "```\nlet x = 1;2              // error: \"1;\" should be a unit expression\nlet x = ignore 1;2       // ok\nlet x = printf \"hello\";2 // ok \n```", "```\n// create a clone of if-then-else\nlet test b t f = if b then t else f\n\n// call it with two different choices\ntest true (printfn \"true\") (printfn \"false\") \n```", "```\n// create a clone of if-then-else that accepts functions rather than simple values\nlet test b t f = if b then t() else f()\n\n// call it with two different functions\ntest true (fun () -> printfn \"true\") (fun () -> printfn \"false\") \n```", "```\n// create a clone of if-then-else with no restrictions...\nlet test b t f = if b then t else f\n\n// ...but call it with lazy values\nlet f = test true (lazy (printfn \"true\")) (lazy (printfn \"false\")) \n```", "```\nf.Force()     // use Force() to force the evaluation of a lazy value \n```", "```\nlet aName = someExpression \n```", "```\nmodule MyModule = \n\n    let topLevelName = \n        let nestedName1 = someExpression\n        let nestedName2 = someOtherExpression\n        finalExpression \n```", "```\nlet a,b = 1,2\n\ntype Person = {First:string; Last:string}\nlet alice = {First=\"Alice\"; Last=\"Doe\"}\nlet {First=first} = alice \n```", "```\n// pattern match the parameters\nlet add (x,y) = x + y\n\n// test \nlet aTuple = (1,2)\nadd aTuple \n```", "```\nlet nestedName = someExpression \n```", "```\nlet nestedName = [some expression] in [some other expression involving nestedName] \n```", "```\n// standard syntax\nlet f () = \n  let x = 1  \n  let y = 2\n  x + y          // the result \n```", "```\n// syntax using \"in\" keyword\nlet f () = \n  let x = 1 in   // the \"in\" keyword is available in F#\n    let y = 2 in \n      x + y      // the result \n```", "```\n(definition of x) + (definition of y) \n// or\n(1) + (2) \n```", "```\nlet f () = \n  let x = 1  \n// error FS0588: Block following this 'let' is unfinished. \n//               Expect an expression. \n```", "```\nlet f () = \n  2 + 2      // warning FS0020: This expression should \n             // have type 'unit'\n  let x = 1  \n  x + 1      // this is the final result \n```", "```\nlet f () = \n  2 + 2 |> ignore \n  let x = 1  \n  x + 1      // this is the final result \n```", "```\nmodule A = \n    use f () =  // Error\n      let x = 1  \n      x + 1 \n```", "```\n// create a new object that implements IDisposable\nlet makeResource name = \n   { new System.IDisposable \n     with member this.Dispose() = printfn \"%s disposed\" name } \n```", "```\nlet exampleUseBinding name =\n    use myResource = makeResource name\n    printfn \"done\"\n\n//test\nexampleUseBinding \"hello\" \n```", "```\nlet exampleLetBinding name =\n    let myResource = makeResource name\n    printfn \"done\"\n\n//test\nexampleLetBinding \"hello\" \n```", "```\nlet exampleUseBinding2 name =\n    use s = \"hello\"  // Error: The type 'string' is \n                     // not compatible with the type 'IDisposable'\n    printfn \"done\" \n```", "```\nlet returnInvalidResource name =\n    use myResource = makeResource name\n    myResource // don't do this!\n\n// test\nlet resource = returnInvalidResource  \"hello\" \n```", "```\nlet usingResource name callback =\n    use myResource = makeResource name\n    callback myResource\n    printfn \"done\"\n\nlet callback aResource = printfn \"Resource is %A\" aResource\ndo usingResource \"hello\" callback \n```", "```\nlet returnValidResource name =\n    // \"let\" binding here instead of \"use\"\n    let myResource = makeResource name\n    myResource // still valid\n\nlet testValidResource =\n    // \"use\" binding here instead of \"let\"\n    use resource = returnValidResource  \"hello\"\n    printfn \"done\" \n```", "```\nlet callback aResource = printfn \"Resource is %A\" aResource\nusing (makeResource \"hello\") callback \n```", "```\nmodule TimerExtensions = \n\n    type System.Timers.Timer with \n        static member StartWithDisposable interval handler = \n            // create the timer\n            let timer = new System.Timers.Timer(interval)\n\n            // add the handler and start it\n            do timer.Elapsed.Add handler \n            timer.Start()\n\n            // return an IDisposable that calls \"Stop\"\n            { new System.IDisposable with \n                member disp.Dispose() = \n                    do timer.Stop() \n                    do printfn \"Timer stopped\"\n                } \n```", "```\nopen TimerExtensions\nlet testTimerWithDisposable =     \n    let handler = (fun _ -> printfn \"elapsed\")\n    use timer = System.Timers.Timer.StartWithDisposable 100.0 handler  \n    System.Threading.Thread.Sleep 500 \n```", "```\ndo printf \"logging\" \n```", "```\nprintf \"logging\" \n```", "```\ndo 1 + 1    // warning: This expression is a function \n```", "```\ndo ( 1+1 |> ignore ) \n```", "```\nmodule A =\n\n    module B =\n        do printfn \"Module B initialized\"\n\n    module C =\n        do printfn \"Module C initialized\"\n\n    do printfn \"Module A initialized\" \n```", "```\n//This simple workflow just sleeps for 2 seconds.\nopen System\nlet sleepWorkflow  = async{\n    printfn \"Starting sleep workflow at %O\" DateTime.Now.TimeOfDay\n\n    // do! means to wait as well\n    do! Async.Sleep 2000\n    printfn \"Finished sleep workflow at %O\" DateTime.Now.TimeOfDay\n    }\n\n//test\nAsync.RunSynchronously sleepWorkflow  \n\n// Workflows with other async workflows nested inside them. \n/// Within the braces, the nested workflows can be blocked on by using the let! or use! syntax.\nlet nestedWorkflow  = async{\n\n    printfn \"Starting parent\"\n\n    // let! means wait and then bind to the childWorkflow value\n    let! childWorkflow = Async.StartChild sleepWorkflow\n\n    // give the child a chance and then keep working\n    do! Async.Sleep 100\n    printfn \"Doing something useful while waiting \"\n\n    // block on the child\n    let! result = childWorkflow\n\n    // done\n    printfn \"Finished parent\" \n    }\n\n// run the whole workflow\nAsync.RunSynchronously nestedWorkflow \n```", "```\nclass AttributeTest\n{\n    [Obsolete]\n    public static int MyObsoleteFunction(int x, int y) {\n        return x + y;\n    }\n\n    [CLSCompliant(false)]\n    public static void NonCompliant() {\n    }\n} \n```", "```\nmodule AttributeTest = \n    [<Obsolete>]\n    let myObsoleteFunction x y = x + y\n\n    [<CLSCompliant(false)>]\n    let nonCompliant () = () \n```", "```\nclass Program\n{\n    static int Main(string[] args) {\n        foreach (var arg in args)\n        {\n            Console.WriteLine(arg);\n        }\n\n        //same as Environment.Exit(code)\n        return 0;\n    }\n} \n```", "```\nmodule Program\n\n[<EntryPoint>]\nlet main args =\n    args |> Array.iter printfn \"%A\" \n\n    0  // return is required! \n```", "```\nerror FS0191: A function labelled with the 'EntryPointAttribute' atribute must be the last declaration in the last file in the compilation sequence \n```", "```\n[<EntryPoint>]\nlet main args =\n    the entire application as a set of subexpressions \n```", "```\nopen System.Reflection\n\nmodule AssemblyInfo = \n    [<assembly: AssemblyTitle(\"MyAssembly\")>]\n    [<assembly: AssemblyVersion(\"1.2.0.0\")>]\n    [<assembly: AssemblyFileVersion(\"1.2.3.4152\")>]\n    do ()   // do nothing -- just a placeholder for the attribute \n```", "```\nusing System.Runtime.InteropServices;\n\n[TestFixture]\npublic class TestDllImport\n{\n    [DllImport(\"shlwapi\", CharSet = CharSet.Auto, EntryPoint = \"PathCanonicalize\", SetLastError = true)]\n    private static extern bool PathCanonicalize(StringBuilder lpszDst, string lpszSrc);\n\n    [Test]\n    public void TestPathCanonicalize() {\n        var input = @\"A:\\name_1\\.\\name_2\\..\\name_3\";\n        var expected = @\"A:\\name_1\\name_3\";\n\n        var builder = new StringBuilder(260);\n        PathCanonicalize(builder, input);\n        var actual = builder.ToString();\n\n        Assert.AreEqual(expected,actual);\n    }\n} \n```", "```\nopen System.Runtime.InteropServices\nopen System.Text\n\n[<DllImport(\"shlwapi\", CharSet = CharSet.Ansi, EntryPoint = \"PathCanonicalize\", SetLastError = true)>]\nextern bool PathCanonicalize(StringBuilder lpszDst, string lpszSrc)\n\nlet TestPathCanonicalize() = \n    let input = @\"A:\\name_1\\.\\name_2\\..\\name_3\"\n    let expected = @\"A:\\name_1\\name_3\"\n\n    let builder = new StringBuilder(260)\n    let success = PathCanonicalize(builder, input)\n    let actual = builder.ToString()\n\n    printfn \"actual=%s success=%b\" actual (expected = actual)\n\n// test\nTestPathCanonicalize() \n```", "```\n//character columns\n//3456789\nlet f = \n  let x=1     // offside line is at column 3\n  let y=1     // this line must start at column 3\n  x+y         // this line must start at column 3 \n\nlet f = \n  let x=1     // offside line is at column 3 \n   x+1        // oops! don't start at column 4\n              // error FS0010: Unexpected identifier in binding\n\nlet f = \n  let x=1    // offside line is at column 3 \n x+1         // offside! You are ahead of the ball!\n             // error FS0588: Block following this \n             // 'let' is unfinished \n```", "```\n//character columns\n//34567890123456789\nlet f =   let x=1  // line is now at column 11 (start of \"let x=\")\n          x+1      // must start at column 11 from now on\n\n//        |        // offside line at col 11 \nlet f =   let x=1  // line is now at column 11 (start of \"let x=\")\n         x+1       // offside!\n\n// |        // offside line at col 4\nlet f =  \n   let x=1  // first word after = sign defines the line \n            // offside line is now at column 4\n   x+1      // must start at column 4 from now on \n```", "```\n//character columns\n//34567890123456789\nlet f = \n   let g = (         \n    1+2)             // first char after \"(\" defines \n                     // a new line at col 5\n   g \n\nlet f = \n   if true then\n    1+2             // first char after \"then\" defines \n                    // a new line at col 5\n\nlet f = \n   match 1 with \n   | 1 ->\n       1+2          // first char after match \"->\" defines \n                    // a new line at col 8 \n```", "```\n//character columns\n//34567890123456789\nlet f = \n   let g = let x = 1 // first word after \"let g =\" \n                     // defines a new offside line at col 12\n           x + 1     // \"x\" must align at col 12\n                     // pop the offside line stack now\n   g + 1             // back to previous line. \"g\" must align\n                     // at col 4 \n```", "```\nlet f = \n   let g = (         // let defines a new line at col 4\n  1+2)               // oops! Cant define new line less than 4\n   g \n```", "```\n//character columns\n//34567890123456789\nlet x =  1   // defines a new line at col 10\n       + 2   // \"+\" allowed to be outside the line\n       + 3\n\nlet f g h =   g   // defines a new line at col 15\n           >> h   // \">>\" allowed to be outside the line \n```", "```\nlet x =  1   // defines a new line at col 10\n        + 2   // infix operators that start a line don't count\n             * 3  // starts with \"*\" so doesn't need to align\n         - 4  // starts with \"-\" so doesn't need to align \n```", "```\n//character columns\n//34567890123456789\nlet f = fun x ->  // \"fun\" should define a new line at col 9\n   let y = 1      // but doesn't. The real line starts here.\n   x + y \n```", "```\n#indent \"off\"\n\n      let f = \n    let x = 1 in\n  if x=2 then \nbegin \"a\" end else begin\n\"b\" \nend\n\n#indent \"on\" \n```", "```\nlet x = let y = 1 in let z = 2 in y + z \n```", "```\nlet primesUpTo n = \n    // create a recursive intermediate function\n    let rec sieve listOfNumbers  = \n        match listOfNumbers with \n        | [] -> []\n        | primeP::sievedNumbersBiggerThanP-> \n            let sievedNumbersNotDivisibleByP = \n                sievedNumbersBiggerThanP\n                |> List.filter (fun i-> i % primeP > 0)\n            //recursive part\n            let newPrimes = sieve sievedNumbersNotDivisibleByP\n            primeP :: newPrimes\n    // use the sieve\n    let listOfNumbers = [2..n]\n    sieve listOfNumbers     // return\n\n//test\nprimesUpTo 100 \n```", "```\nlet primesUpTo n = \n   let rec sieve l  = \n      match l with \n      | [] -> []\n      | p::xs -> \n            p :: sieve [for x in xs do if (x % p) > 0 then yield x]\n   [2..n] |> sieve \n```", "```\nlet (|>) x f = f x \n```", "```\nlet (|>) aValue aFunction = aFunction aValue // any better? \n```", "```\n// bad\nlet f x = \n    if x = 1 \n    then \"a\" \n    else \"b\"\n\n// not much better\nlet f x = \n    match x=1 with\n    | true -> \"a\" \n    | false -> \"b\"\n\n// best\nlet f x = \n    match x with\n    | 1 -> \"a\" \n    | _ -> \"b\" \n```", "```\n// bad\nlet f list = \n    if List.isEmpty list\n    then printfn \"is empty\" \n    else printfn \"first element is %s\" (List.head list)\n\n// much better\nlet f list = \n    match list with\n    | [] -> printfn \"is empty\" \n    | x::_ -> printfn \"first element is %s\" x \n```", "```\n// bad\nlet f list = \n    if List.isEmpty list\n        then printfn \"is empty\" \n        elif (List.head list) > 0\n            then printfn \"first element is > 0\" \n            else printfn \"first element is <= 0\" \n\n// much better\nlet f list = \n    match list with\n    | [] -> printfn \"is empty\" \n    | x::_ when x > 0 -> printfn \"first element is > 0\" \n    | x::_ -> printfn \"first element is <= 0\" \n```", "```\nlet v = if true then \"a\" else \"b\"    // value : string\nlet f x = if x then \"a\" else \"b\"     // function : bool->string \n```", "```\nlet v = if true then \"a\" else 2  \n  // error FS0001: This expression was expected to have \n  //               type string but here has type int \n```", "```\nlet v = if true then \"a\"    \n  // error FS0001: This expression was expected to have type unit \n  //               but here has type string \n```", "```\nlet v2 = if true then printfn \"a\"   // OK as printfn returns unit \n```", "```\nlet posNeg x = if x > 0 then \"+\" elif x < 0 then \"-\" else \"0\"\n[-5..5] |> List.map posNeg \n```", "```\nlet greetings = \n    if (System.DateTime.Now.Hour < 12) \n    then (fun name -> \"good morning, \" + name)\n    else (fun name -> \"good day, \" + name)\n\n//test \ngreetings \"Alice\" \n```", "```\n// bad\nfor i = 1 to 10 do\n   printf \"%i\" i\n\n// much better\n[1..10] |> List.iter (printf \"%i\") \n```", "```\n// bad\nlet sum list = \n    let mutable total = 0    // uh-oh -- mutable value \n    for e in list do\n        total <- total + e   // update the mutable value\n    total                    // return the total\n\n// much better\nlet sum list = List.reduce (+) list\n\n//test\nsum [1..10] \n```", "```\n// bad\nlet printRandomNumbersUntilMatched matchValue maxValue =\n  let mutable continueLooping = true  // another mutable value\n  let randomNumberGenerator = new System.Random()\n  while continueLooping do\n    // Generate a random number between 1 and maxValue.\n    let rand = randomNumberGenerator.Next(maxValue)\n    printf \"%d \" rand\n    if rand = matchValue then \n       printfn \"\\nFound a %d!\" matchValue\n       continueLooping <- false\n\n// much better\nlet printRandomNumbersUntilMatched matchValue maxValue =\n  let randomNumberGenerator = new System.Random()\n  let sequenceGenerator _ = randomNumberGenerator.Next(maxValue)\n  let isNotMatch = (<>) matchValue\n\n  //create and process the sequence of rands\n  Seq.initInfinite sequenceGenerator \n    |> Seq.takeWhile isNotMatch\n    |> Seq.iter (printf \"%d \")\n\n  // done\n  printfn \"\\nFound a %d!\" matchValue\n\n//test\nprintRandomNumbersUntilMatched 10 20 \n```", "```\nlet f =\n  for i in [1..10] do\n    i + i  // warning: This expression should have type 'unit'\n\n// version 2\nlet f =\n  for i in [1..10] do\n    i + i |> ignore   // fixed \n```", "```\nlet myList = [for x in 0..100 do if x*x < 100 then yield x ] \n```", "```\nexception MyFSharpError1 of string\nexception MyFSharpError2 of string * int \n```", "```\n// throws a generic System.Exception\nlet f x = \n   if x then \"ok\"\n   else failwith \"message\"\n\n// throws an ArgumentException\nlet f x = \n   if x then \"ok\"\n   else invalidArg \"paramName\" \"message\" \n\n// throws a NullArgumentException\nlet f x = \n   if x then \"ok\"\n   else nullArg \"paramName\" \"message\"   \n\n// throws an InvalidOperationException\nlet f x = \n   if x then \"ok\"\n   else invalidOp \"message\" \n```", "```\nopen System\nlet f x = \n    if x = \"bad\" then\n        failwithf \"Operation '%s' failed at time %O\" x DateTime.Now\n    else\n        printfn \"Operation '%s' succeeded at time %O\" x DateTime.Now\n\n// test \nf \"good\"\nf \"bad\" \n```", "```\n// you control the exception type\nlet f x = \n   if x then \"ok\"\n   else raise (new InvalidOperationException(\"message\")) \n```", "```\n// using your own F# exception types\nlet f x = \n   if x then \"ok\"\n   else raise (MyFSharpError1 \"message\") \n```", "```\nlet f x = \n   if x then 42\n   elif true then failwith \"message\"\n   else invalidArg \"paramName\" \"message\" \n```", "```\nlet f x = \n   if x then failwith \"error in true branch\"\n   else failwith \"error in false branch\" \n```", "```\ntry\n    failwith \"fail\"\nwith\n    | Failure msg -> \"caught: \" + msg\n    | MyFSharpError1 msg -> \" MyFSharpError1: \" + msg\n    | :? System.InvalidOperationException as ex -> \"unexpected\" \n```", "```\n:? (exception class) as ex \n```", "```\nlet divide x y=\n    try\n        (x+1) / y                      // error here -- see below\n    with\n    | :? System.DivideByZeroException as ex -> \n          printfn \"%s\" ex.Message \n```", "```\nerror FS0043: The type 'unit' does not match the type 'int' \n```", "```\nlet divide x y=\n    try\n        (x+1) / y                      \n    with\n    | :? System.DivideByZeroException as ex -> \n          printfn \"%s\" ex.Message; 0            // added 0 here!\n\n//test\ndivide 1 1\ndivide 1 0 \n```", "```\nlet divide x y=\n    try\n        (x+1) / y                      \n    with\n    | :? System.DivideByZeroException as ex -> \n          printfn \"%s\" ex.Message\n          reraise()\n\n//test\ndivide 1 1\ndivide 1 0 \n```", "```\nlet f x = \n    try\n        if x then \"ok\" else failwith \"fail\"\n    finally\n        printf \"this will always be printed\" \n```", "```\nlet f x = \n    try\n        if x then \"ok\" else failwith \"fail\"\n    finally\n        1+1  // This expression should have type 'unit \n```", "```\nlet divide x y=\n   try\n      try       \n         (x+1) / y                      \n      finally\n         printf \"this will always be printed\"\n   with\n   | :? System.DivideByZeroException as ex -> \n           printfn \"%s\" ex.Message; 0 \n```", "```\n// library function that doesn't handle exceptions\nlet divideExn x y = x / y\n\n// library function that converts exceptions to None\nlet tryDivide x y = \n   try\n       Some (x / y)\n   with\n   | :? System.DivideByZeroException -> None // return missing \n```", "```\n// client code must handle exceptions explicitly\ntry\n    let n = divideExn 1 0\n    printfn \"result is %i\" n\nwith\n| :? System.DivideByZeroException as ex -> printfn \"divide by zero\" \n```", "```\n// client code must test both cases\nmatch tryDivide 1 0 with\n| Some n -> printfn \"result is %i\" n\n| None -> printfn \"divide by zero\" \n```", "```\nopen System.Data.SqlClient\n\ntype NonQueryResult =\n    | Success of int\n    | LoginError of SqlException\n    | ConstraintError of SqlException\n    | ForeignKeyError of SqlException \n\nlet executeNonQuery (sqlCommmand:SqlCommand) =\n    try\n       use sqlConnection = new SqlConnection(\"myconnection\")\n       sqlCommmand.Connection <- sqlConnection \n       let result = sqlCommmand.ExecuteNonQuery()\n       Success result\n    with    \n    | :?SqlException as ex ->     // if a SqlException\n        match ex.Number with      \n        | 18456 ->                // login Failed\n            LoginError ex     \n        | 2601 | 2627 ->          // handle constraint error\n            ConstraintError ex     \n        | 547 ->                  // handle FK error\n            ForeignKeyError ex     \n        | _ ->                    // don't handle any other cases \n            reraise()          \n       // all non SqlExceptions are thrown normally \n```", "```\nlet myCmd = new SqlCommand(\"DELETE Product WHERE ProductId=1\")\nlet result =  executeNonQuery myCmd\nmatch result with\n| Success n -> printfn \"success\"\n| LoginError ex -> printfn \"LoginError: %s\" ex.Message\n| ConstraintError ex -> printfn \"ConstraintError: %s\" ex.Message\n| ForeignKeyError ex -> printfn \"ForeignKeyError: %s\" ex.Message \n```", "```\nlet lowLevelFunction commandString = \n  let myCmd = new SqlCommand(commandString)\n  executeNonQuery myCmd          //returns result \n\nlet deleteProduct id = \n  let commandString = sprintf \"DELETE Product WHERE ProductId=%i\" id\n  lowLevelFunction commandString  //returns without handling errors\n\nlet presentationLayerFunction = \n  let result = deleteProduct 1\n  match result with\n  | Success n -> printfn \"success\"\n  | errorCase -> printfn \"error %A\" errorCase \n```", "```\nlet presentationLayerFunction = \n  do deleteProduct 1    // error: throwing away a result code! \n```", "```\nmatch [something] with \n| pattern1 -> expression1\n| pattern2 -> expression2\n| pattern3 -> expression3 \n```", "```\nmatch [something] with \n| lambda-expression-1\n| lambda-expression-2\n| lambda-expression-3 \n```", "```\nparam -> expression \n```", "```\n_ -> expression \n```", "```\nlet x = \n    match 1 with \n    | 1 -> \"a\"\n    | 2 -> \"b\"  \n    | _ -> \"z\" \n```", "```\nfun 1 -> \"a\"\nfun 2 -> \"b\"\nfun _ -> \"z\" \n```", "```\nlet x = \n    match 1 with \n    | _ -> \"z\" \n    | 1 -> \"a\"\n    | 2 -> \"b\" \n```", "```\nlet f x =   match x with \n            // aligned\n            | 1 -> \"pattern 1\" \n            // aligned\n            | 2 -> \"pattern 2\" \n            // aligned\n            | _ -> \"anything\" \n```", "```\n // ugly alignment! \nlet myVeryLongNameForAFunction myParameter =  match myParameter with \n                                              | 1 -> \"something\" \n                                              | _ -> \"anything\" \n\n// much better\nlet myVeryLongNameForAFunction myParameter =  \n    match myParameter with \n    | 1 -> \"something\" \n    | _ -> \"anything\" \n```", "```\nlet f x =  \n    match x with \n    | \"a very long pattern that breaks up the flow\" -> \"something\" \n    | _ -> \"anything\" \n\nlet f x =  \n    match x with \n    | \"a very long pattern that breaks up the flow\" -> \n        \"something\" \n    | _ -> \n        \"anything\" \n```", "```\nlet f list =  \n    match list with \n    | [] -> \"something\" \n    | x::xs -> \"something else\" \n```", "```\nlet x = \n    match 1 with \n    | 1 -> 42\n    | 2 -> true  // error wrong type\n    | _ -> \"hello\" // error wrong type \n```", "```\n// nested match..withs are ok\nlet f aValue = \n    match aValue with \n    | x -> \n        match x with \n        | _ -> \"something\" \n```", "```\n[2..10]\n|> List.map (fun i ->\n        match i with \n        | 2 | 3 | 5 | 7 -> sprintf \"%i is prime\" i\n        | _ -> sprintf \"%i is not prime\" i\n        ) \n```", "```\nlet x = \n    match 42 with \n    | 1 -> \"a\"\n    | 2 -> \"b\" \n```", "```\nlet x = \n    match 42 with \n    | 1 -> \"a\"\n    | 2 -> \"b\"\n    | _ -> \"z\" \n```", "```\ntype Choices = A | B | C\nlet x = \n    match A with \n    | A -> \"a\"\n    | B -> \"b\"\n    | C -> \"c\"\n    //NO default match \n```", "```\nlet x = \n    match -1 with \n    | 1 -> \"a\"\n    | 2 -> \"b\"\n    | i when i >= 0 && i<=100 -> \"ok\"\n    // the last case will always match\n    | x -> failwithf \"%i is out of range\" x \n```", "```\nlet y = \n    match (1,0) with \n    // binding to a named value\n    | (1,x) -> printfn \"x=%A\" x \n```", "```\nlet elementsAreEqual aTuple = \n    match aTuple with \n    | (x,x) -> \n        printfn \"both parts are the same\" \n    | (_,_) -> \n        printfn \"both parts are different\" \n```", "```\nlet elementsAreEqual aTuple = \n    match aTuple with \n    | (x,y) -> \n        if (x=y) then printfn \"both parts are the same\" \n        else printfn \"both parts are different\" \n```", "```\nlet y = \n    match (1,0) with \n    // OR  -- same as multiple cases on one line\n    | (2,x) | (3,x) | (4,x) -> printfn \"x=%A\" x \n\n    // AND  -- must match both patterns at once\n    // Note only a single \"&\" is used\n    | (2,x) & (_,1) -> printfn \"x=%A\" x \n```", "```\ntype Choices = A | B | C | D\nlet x = \n    match A with \n    | A | B | C -> \"a or b or c\"\n    | D -> \"d\" \n```", "```\nlet y = \n    match [1;2;3] with \n    // binding to explicit positions\n    // square brackets used!\n    | [1;x;y] -> printfn \"x=%A y=%A\" x y\n\n    // binding to head::tail. \n    // no square brackets used!\n    | 1::tail -> printfn \"tail=%A\" tail \n\n    // empty list\n    | [] -> printfn \"empty\" \n```", "```\n// loop through a list and print the values\nlet rec loopAndPrint aList = \n    match aList with \n    // empty list means we're done.\n    | [] -> \n        printfn \"empty\" \n\n    // binding to head::tail. \n    | x::xs -> \n        printfn \"element=%A,\" x\n        // do all over again with the \n        // rest of the list\n        loopAndPrint xs \n\n//test\nloopAndPrint [1..5]\n\n// ------------------------\n// loop through a list and sum the values\nlet rec loopAndSum aList sumSoFar = \n    match aList with \n    // empty list means we're done.\n    | [] -> \n        sumSoFar  \n\n    // binding to head::tail. \n    | x::xs -> \n        let newSumSoFar = sumSoFar + x\n        // do all over again with the \n        // rest of the list and the new sum\n        loopAndSum xs newSumSoFar \n\n//test\nloopAndSum [1..5] 0 \n```", "```\n// -----------------------\n// Tuple pattern matching\nlet aTuple = (1,2)\nmatch aTuple with \n| (1,_) -> printfn \"first part is 1\"\n| (_,2) -> printfn \"second part is 2\"\n\n// -----------------------\n// Record pattern matching\ntype Person = {First:string; Last:string}\nlet person = {First=\"john\"; Last=\"doe\"}\nmatch person with \n| {First=\"john\"}  -> printfn \"Matched John\" \n| _  -> printfn \"Not John\" \n\n// -----------------------\n// Union pattern matching\ntype IntOrBool= I of int | B of bool\nlet intOrBool = I 42\nmatch intOrBool with \n| I i  -> printfn \"Int=%i\" i\n| B b  -> printfn \"Bool=%b\" b \n```", "```\nlet y = \n    match (1,0) with \n    // binding to three values\n    | (x,y) as t -> \n        printfn \"x=%A and y=%A\" x y\n        printfn \"The whole tuple is %A\" t \n```", "```\nlet x = new Object()\nlet y = \n    match x with \n    | :? System.Int32 -> \n        printfn \"matched an int\"\n    | :? System.DateTime -> \n        printfn \"matched a datetime\"\n    | _ -> \n        printfn \"another type\" \n```", "```\nlet detectType v =\n    match v with\n        | :? int -> printfn \"this is an int\"\n        | _ -> printfn \"something else\"\n// error FS0008: This runtime coercion or type test from type 'a to int \n// involves an indeterminate type based on information prior to this program point. \n// Runtime type tests are not allowed on some types. Further type annotations are needed. \n```", "```\nlet detectTypeBoxed v =\n    match box v with      // used \"box v\" \n        | :? int -> printfn \"this is an int\"\n        | _ -> printfn \"something else\"\n\n//test\ndetectTypeBoxed 1\ndetectTypeBoxed 3.14 \n```", "```\nlet matchOnTwoParameters x y = \n    match (x,y) with \n    | (1,y) -> \n        printfn \"x=1 and y=%A\" y\n    | (x,1) -> \n        printfn \"x=%A and y=1\" x \n```", "```\nlet matchOnTwoTuples x y = \n    match (x,y) with \n    | (1,_),(1,_) -> \"both start with 1\"\n    | (_,2),(_,2) -> \"both end with 2\"\n    | _ -> \"something else\"\n\n// test\nmatchOnTwoTuples (1,3) (1,2)\nmatchOnTwoTuples (3,2) (1,2) \n```", "```\nlet elementsAreEqual aTuple = \n    match aTuple with \n    | (x,y) -> \n        if (x=y) then printfn \"both parts are the same\" \n        else printfn \"both parts are different\" \n```", "```\nlet elementsAreEqual aTuple = \n    match aTuple with \n    | (x,y) when x=y -> \n        printfn \"both parts are the same\" \n    | _ ->\n        printfn \"both parts are different\" \n```", "```\n// --------------------------------\n// comparing values in a when clause\nlet makeOrdered aTuple = \n    match aTuple with \n    // swap if x is bigger than y\n    | (x,y) when x > y -> (y,x)\n\n    // otherwise leave alone\n    | _ -> aTuple\n\n//test \nmakeOrdered (1,2)        \nmakeOrdered (2,1)\n\n// --------------------------------\n// testing properties in a when clause \nlet isAM aDate = \n    match aDate:System.DateTime with \n    | x when x.Hour <= 12-> \n        printfn \"AM\"\n\n    // otherwise leave alone\n    | _ -> \n        printfn \"PM\"\n\n//test\nisAM System.DateTime.Now\n\n// --------------------------------\n// pattern matching using regular expressions\nopen System.Text.RegularExpressions\n\nlet classifyString aString = \n    match aString with \n    | x when Regex.Match(x,@\".+@.+\").Success-> \n        printfn \"%s is an email\" aString\n\n    // otherwise leave alone\n    | _ -> \n        printfn \"%s is something else\" aString\n\n//test\nclassifyString \"alice@example.com\"\nclassifyString \"google.com\"\n\n// --------------------------------\n// pattern matching using arbitrary conditionals\nlet fizzBuzz x = \n    match x with \n    | i when i % 15 = 0 -> \n        printfn \"fizzbuzz\" \n    | i when i % 3 = 0 -> \n        printfn \"fizz\" \n    | i when i % 5 = 0 -> \n        printfn \"buzz\" \n    | i  -> \n        printfn \"%i\" i\n\n//test\n[1..30] |> List.iter fizzBuzz \n```", "```\nopen System.Text.RegularExpressions\n\n// create an active pattern to match an email address\nlet (|EmailAddress|_|) input =\n   let m = Regex.Match(input,@\".+@.+\") \n   if (m.Success) then Some input else None  \n\n// use the active pattern in the match \nlet classifyString aString = \n    match aString with \n    | EmailAddress x -> \n        printfn \"%s is an email\" x\n\n    // otherwise leave alone\n    | _ -> \n        printfn \"%s is something else\" aString\n\n//test\nclassifyString \"alice@example.com\"\nclassifyString \"google.com\" \n```", "```\nlet f aValue = \n    match aValue with \n    | _ -> \"something\" \n```", "```\nlet f = \n    function \n    | _ -> \"something\" \n```", "```\n// using match..with\nlet f aValue = \n    match aValue with \n    | x -> \n        match x with \n        | _ -> \"something\" \n\n// using function keyword\nlet f = \n    function \n    | x -> \n        function \n        | _ -> \"something\" \n```", "```\n// using match..with\n[2..10] |> List.map (fun i ->\n        match i with \n        | 2 | 3 | 5 | 7 -> sprintf \"%i is prime\" i\n        | _ -> sprintf \"%i is not prime\" i\n        )\n\n// using function keyword\n[2..10] |> List.map (function \n        | 2 | 3 | 5 | 7 -> sprintf \"prime\"\n        | _ -> sprintf \"not prime\"\n        ) \n```", "```\ntry\n    failwith \"fail\"\nwith\n    | Failure msg -> \"caught: \" + msg\n    | :? System.InvalidOperationException as ex -> \"unexpected\" \n```", "```\nlet debugMode = false\ntry\n    failwith \"fail\"\nwith\n    | Failure msg when debugMode  -> \n        reraise()\n    | Failure msg when not debugMode -> \n        printfn \"silently logged in production: %s\" msg \n```", "```\nlet times6 x = x * 6\n\nlet isAnswerToEverything x = \n    match x with \n    | 42 -> (x,true)\n    | _ -> (x,false)\n\n// the function can be used for chaining or composition\n[1..10] |> List.map (times6 >> isAnswerToEverything) \n```", "```\nlet rec loopAndSum aList sumSoFar = \n    match aList with \n    | [] -> \n        sumSoFar  \n    | x::xs -> \n        let newSumSoFar = sumSoFar + x\n        loopAndSum xs newSumSoFar \n```", "```\n// simplest\nlet loopAndSum1 aList = List.sum aList \n[1..10] |> loopAndSum1 \n\n// reduce is very powerful \nlet loopAndSum2 aList = List.reduce (+) aList \n[1..10] |> loopAndSum2 \n\n// fold is most powerful of all\nlet loopAndSum3 aList = List.fold (fun sum i -> sum+i) 0 aList \n[1..10] |> loopAndSum3 \n```", "```\n// unnecessary to implement this explicitly\nlet addOneIfValid optionalInt = \n    match optionalInt with \n    | Some i -> Some (i + 1)\n    | None -> None\n\nSome 42 |> addOneIfValid\n\n// much easier to use the built in function\nlet addOneIfValid2 optionalInt = \n    optionalInt |> Option.map (fun i->i+1)\n\nSome 42 |> addOneIfValid2 \n```", "```\ntype TemperatureType = F of float | C of float \n```", "```\nmodule Temperature =\n    let fold fahrenheitFunction celsiusFunction aTemp =\n        match aTemp with\n        | F f -> fahrenheitFunction f\n        | C c -> celsiusFunction c \n```", "```\nlet fFever tempF =\n    if tempF > 100.0 then \"Fever!\" else \"OK\"\n\nlet cFever tempC =\n    if tempC > 38.0 then \"Fever!\" else \"OK\"\n\n// combine using the fold\nlet isFever aTemp = Temperature.fold fFever cFever aTemp \n```", "```\nlet normalTemp = C 37.0\nlet result1 = isFever normalTemp \n\nlet highTemp = F 103.1\nlet result2 = isFever highTemp \n```", "```\nlet fConversion tempF =\n    let convertedValue = (tempF - 32.0) / 1.8\n    TemperatureType.C convertedValue    //wrapped in type\n\nlet cConversion tempC =\n    let convertedValue = (tempC * 1.8) + 32.0\n    TemperatureType.F convertedValue    //wrapped in type\n\n// combine using the fold\nlet convert aTemp = Temperature.fold fConversion cConversion aTemp \n```", "```\nval convert : TemperatureType -> TemperatureType \n```", "```\nlet c20 = C 20.0\nlet resultInF = convert c20\n\nlet f75 = F 75.0\nlet resultInC = convert f75 \n```", "```\nlet resultInC = C 20.0 |> convert |> convert \n```", "```\nConsole.WriteLine(\"A string: {0}. An int: {1}. A float: {2}. A bool: {3}\",\"hello\",42,3.14,true) \n```", "```\nprintfn \"A string: %s. An int: %i. A float: %f. A bool: %b\" \"hello\" 42 3.14 true \n```", "```\n// wrong parameter type\nprintfn \"A string: %s\" 42 \n\n// wrong number of parameters\nprintfn \"A string: %s\" \"Hello\" 42 \n```", "```\n// wrong parameter type\nConsole.WriteLine(\"A string: {0}\", 42)   //works!\n\n// wrong number of parameters\nConsole.WriteLine(\"A string: {0}\",\"Hello\",42)  //works!\nConsole.WriteLine(\"A string: {0}. An int: {1}\",\"Hello\") //FormatException \n```", "```\n// partial application - explicit parameters\nlet printStringAndInt s i =  printfn \"A string: %s. An int: %i\" s i\nlet printHelloAndInt i = printStringAndInt \"Hello\" i\ndo printHelloAndInt 42\n\n// partial application - point free style\nlet printInt =  printfn \"An int: %i\"\ndo printInt 42 \n```", "```\nlet doSomething printerFn x y = \n    let result = x + y\n    printerFn \"result is\" result \n\nlet callback = printfn \"%s %i\"\ndo doSomething callback 3 4 \n```", "```\n[1..5] |> List.map (sprintf \"i=%i\") \n```", "```\n// tuple printing\nlet t = (1,2)\nConsole.WriteLine(\"A tuple: {0}\", t)\nprintfn \"A tuple: %A\" t\n\n// record printing\ntype Person = {First:string; Last:string}\nlet johnDoe = {First=\"John\"; Last=\"Doe\"}\nConsole.WriteLine(\"A record: {0}\", johnDoe )\nprintfn \"A record: %A\" johnDoe \n\n// union types printing\ntype Temperature = F of int | C of int\nlet freezing = F 32\nConsole.WriteLine(\"A union: {0}\", freezing )\nprintfn \"A union: %A\" freezing \n```", "```\n// too few parameters\nprintfn \"A string: %s An int: %i\" \"Hello\" \n```", "```\nlet netFormatString = \"A string: {0}\"\nConsole.WriteLine(netFormatString, \"hello\") \n```", "```\nlet fsharpFormatString = \"A string: %s\"\nprintfn fsharpFormatString  \"Hello\" \n```", "```\nlet format:Printf.TextWriterFormat<_> = \"A string: %s\"\nprintfn format \"Hello\" \n```", "```\nlet formatAString = \"A string: %s\"\nlet formatAStringAndInt = \"A string: %s. An int: %i\"\n\n//convert to TextWriterFormat\nlet twFormat1  = Printf.TextWriterFormat<string->unit>(formatAString)\nprintfn twFormat1 \"Hello\" \nlet twFormat2  = Printf.TextWriterFormat<string->int->unit>(formatAStringAndInt)\nprintfn twFormat2  \"Hello\" 42 \n```", "```\n%[flags][width][.precision]specifier \n```", "```\nprintfn \"unescaped: %\" // error\nprintfn \"escape: %%\" \n```", "```\nlet rows = [ (1,\"a\"); (-22,\"bb\"); (333,\"ccc\"); (-4444,\"dddd\") ] \n\n// no alignment\nfor (i,s) in rows do\n    printfn \"|%i|%s|\" i s\n\n// with alignment\nfor (i,s) in rows do\n    printfn \"|%5i|%5s|\" i s\n\n// with left alignment for column 2\nfor (i,s) in rows do\n    printfn \"|%5i|%-5s|\" i s\n\n// with dynamic column width=20 for column 1\nfor (i,s) in rows do\n    printfn \"|%*i|%-5s|\" 20 i s \n\n// with dynamic column width for column 1 and column 2\nfor (i,s) in rows do\n    printfn \"|%*i|%-*s|\" 20 i 10 s \n```", "```\nprintfn \"signed8: %i unsigned8: %u\" -1y -1y\nprintfn \"signed16: %i unsigned16: %u\" -1s -1s\nprintfn \"signed32: %i unsigned32: %u\" -1 -1\nprintfn \"signed64: %i unsigned64: %u\" -1L -1L\nprintfn \"uppercase hex: %X lowercase hex: %x octal: %o\" 255 255 255\nprintfn \"byte: %i \" 'A'B \n```", "```\nprintfn \"bigInt: %i \" 123456789I  // Error\nprintfn \"bigInt: %A \" 123456789I  // OK \n```", "```\nlet rows = [ (1,\"a\"); (-22,\"bb\"); (333,\"ccc\"); (-4444,\"dddd\") ] \n\n// with alignment\nfor (i,s) in rows do\n    printfn \"|%5i|%5s|\" i s\n\n// with plus signs\nfor (i,s) in rows do\n    printfn \"|%+5i|%5s|\" i s\n\n// with zero pad\nfor (i,s) in rows do\n    printfn \"|%0+5i|%5s|\" i s \n\n// with left align\nfor (i,s) in rows do\n    printfn \"|%-5i|%5s|\" i s \n\n// with left align and plus\nfor (i,s) in rows do\n    printfn \"|%+-5i|%5s|\" i s \n\n// with left align and space instead of plus\nfor (i,s) in rows do\n    printfn \"|% -5i|%5s|\" i s \n```", "```\nlet pi = 3.14\nprintfn \"float: %f exponent: %e compact: %g\" pi pi pi \n\nlet petabyte = pown 2.0 50\nprintfn \"float: %f exponent: %e compact: %g\" petabyte petabyte petabyte \n```", "```\nlet largeM = 123456789.123456789M  // a decimal\nprintfn \"float: %f decimal: %M\" largeM largeM \n```", "```\nprintfn \"2 digits precision: %.2f. 4 digits precision: %.4f.\" 123.456789 123.456789\n// output => 2 digits precision: 123.46\\. 4 digits precision: 123.4568.\nprintfn \"2 digits precision: %.2e. 4 digits precision: %.4e.\" 123.456789 123.456789\n// output => 2 digits precision: 1.23e+002\\. 4 digits precision: 1.2346e+002.\nprintfn \"2 digits precision: %.2g. 4 digits precision: %.4g.\" 123.456789 123.456789\n// output => 2 digits precision: 1.2e+02\\. 4 digits precision: 123.5. \n```", "```\nprintfn \"|%f|\" pi     // normal \nprintfn \"|%10f|\" pi   // width\nprintfn \"|%010f|\" pi  // zero-pad\nprintfn \"|%-10f|\" pi  // left aligned\nprintfn \"|%0-10f|\" pi // left zero-pad \n```", "```\nopen System.IO\n\n//define the function\nlet printHello (tw:TextWriter) = tw.Write(\"hello\")\n\n//test it\nprintfn \"custom function: %t\" printHello \n```", "```\nopen System\nopen System.IO\n\n//define the function using a closure\nlet printRand = \n    let rand = new Random()\n    // return the actual printing function\n    fun (tw:TextWriter) -> tw.Write(rand.Next(1,100))\n\n//test it\nfor i in [1..5] do\n    printfn \"rand = %t\" printRand \n```", "```\nopen System\nopen System.IO\n\n//define the callback function\n//note that the data parameter comes after the TextWriter\nlet printLatLong (tw:TextWriter) (lat,long) = \n    tw.Write(\"lat:{0} long:{1}\", lat, long)\n\n// test it\nlet latLongs = [ (1,2); (3,4); (5,6)]\nfor latLong  in latLongs  do\n    // function and value both passed in to printfn\n    printfn \"latLong = %a\" printLatLong latLong \n```", "```\n// function to format a date\nlet yymmdd1 (date:DateTime) = date.ToString(\"yy.MM.dd\")\n\n// function to format a date onto a TextWriter\nlet yymmdd2 (tw:TextWriter) (date:DateTime) = tw.Write(\"{0:yy.MM.dd}\", date)\n\n// test it\nfor i in [1..5] do\n    let date = DateTime.Now.AddDays(float i)\n\n    // using %s\n    printfn \"using ToString = %s\" (yymmdd1 date)\n\n    // using %a\n    printfn \"using a callback = %a\" yymmdd2 date \n```", "```\nlet printToSb s i = \n    let sb = new System.Text.StringBuilder()\n\n    // use partial application to fix the StringBuilder\n    let myPrint format = Printf.bprintf sb format    \n\n    do myPrint \"A string: %s. \" s\n    do myPrint \"An int: %i\" i\n\n    //get the result\n    sb.ToString()\n\n// test\nprintToSb \"hello\" 42 \n```", "```\nopen System\nopen System.IO\n\nlet printToFile filename s i =\n    let myDocsPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) \n    let fullPath = Path.Combine(myDocsPath, filename)\n    use sw = new StreamWriter(path=fullPath)\n\n    // use partial application to fix the TextWriter\n    let myPrint format = fprintf sw format\n\n    do myPrint \"A string: %s. \" s\n    do myPrint \"An int: %i\" i\n\n    //get the result\n    sw.Close()\n\n// test\nprintToFile \"myfile.txt\" \"hello\" 42 \n```", "```\nlet myPrint format = fprintf sw format \n```", "```\nlet myPrint  = fprintf sw \n```", "```\nlet doAfter s = \n    printfn \"Done\"\n    // return the result\n    s\n\nlet result = Printf.ksprintf doAfter \"%s\" \"Hello\" \n```", "```\nopen System\nopen System.IO\n\n// a logging library such as log4net \n// or System.Diagnostics.Trace\ntype Logger(name) = \n\n    let currentTime (tw:TextWriter) = \n        tw.Write(\"{0:s}\",DateTime.Now)\n\n    let logEvent level msg = \n        printfn \"%t %s [%s] %s\" currentTime level name msg\n\n    member this.LogInfo msg = \n        logEvent \"INFO\" msg\n\n    member this.LogError msg = \n        logEvent \"ERROR\" msg\n\n    static member CreateLogger name = \n        new Logger(name) \n```", "```\n// my application code\nmodule MyApplication = \n\n    let logger = Logger.CreateLogger(\"MyApp\")\n\n    // create a logInfo using the Logger class\n    let logInfo format = \n        let doAfter s = \n            logger.LogInfo(s)\n        Printf.ksprintf doAfter format \n\n    // create a logError using the Logger class\n    let logError format = \n        let doAfter s = \n            logger.LogError(s)\n            System.Windows.Forms.MessageBox.Show(s) |> ignore\n        Printf.ksprintf doAfter format \n\n    // function to exercise the logging\n    let test() = \n        do logInfo \"Message #%i\" 1\n        do logInfo \"Message #%i\" 2\n        do logError \"Oops! an error occurred in my app\" \n```", "```\nMyApplication.test() \n```", "```\ntype FormattingLogger(name) = \n\n    let logger = Logger.CreateLogger(name)\n\n    // create a logInfo using the Logger class\n    member this.logInfo format = \n        let doAfter s = \n            logger.LogInfo(s)\n        Printf.ksprintf doAfter format \n\n    // create a logError using the Logger class\n    member this.logError format = \n        let doAfter s = \n            logger.LogError(s)\n            System.Windows.Forms.MessageBox.Show(s) |> ignore\n        Printf.ksprintf doAfter format \n\n    static member createLogger name = \n        new FormattingLogger(name)\n\n// my application code\nmodule MyApplication2 = \n\n    let logger = FormattingLogger.createLogger(\"MyApp2\")\n\n    let test() = \n        do logger.logInfo \"Message #%i\" 1\n        do logger.logInfo \"Message #%i\" 2\n        do logger.logError \"Oops! an error occurred in app 2\"\n\n// test\nMyApplication2.test() \n```", "```\nMYAPP [/V] [/S] [/O order]\n/V    verbose\n/S    include subdirectories\n/O    order by. Parameter is one of \n        N - order by name. \n        S - order by size \n```", "```\n// constants used later\nlet OrderByName = \"N\"\nlet OrderBySize = \"S\"\n\n// set up a type to represent the options\ntype CommandLineOptions = {\n    verbose: bool;\n    subdirectories: bool;\n    orderby: string; \n    } \n```", "```\nlet rec parseCommandLine args optionsSoFar = \n    match args with \n    // empty list means we're done.\n    | [] -> \n        optionsSoFar  \n\n    // match verbose flag\n    | \"/v\"::xs -> \n        let newOptionsSoFar = { optionsSoFar with verbose=true}\n        parseCommandLine xs newOptionsSoFar \n\n    // match subdirectories flag\n    | \"/s\"::xs -> \n        let newOptionsSoFar = { optionsSoFar with subdirectories=true}\n        parseCommandLine xs newOptionsSoFar \n\n    // match orderBy by flag\n    | \"/o\"::xs -> \n        //start a submatch on the next arg\n        match xs with\n        | \"S\"::xss -> \n            let newOptionsSoFar = { optionsSoFar with orderby=OrderBySize}\n            parseCommandLine xss newOptionsSoFar \n\n        | \"N\"::xss -> \n            let newOptionsSoFar = { optionsSoFar with orderby=OrderByName}\n            parseCommandLine xss newOptionsSoFar \n\n        // handle unrecognized option and keep looping\n        | _ -> \n            eprintfn \"OrderBy needs a second argument\"\n            parseCommandLine xs optionsSoFar \n\n    // handle unrecognized option and keep looping\n    | x::xs -> \n        eprintfn \"Option '%s' is unrecognized\" x\n        parseCommandLine xs optionsSoFar \n```", "```\nparseCommandLine [\"/v\"; \"/s\"] \n```", "```\n// define the defaults to pass in\nlet defaultOptions = {\n    verbose = false;\n    subdirectories = false;\n    orderby = ByName\n    }\n\n// test it\nparseCommandLine [\"/v\"] defaultOptions\nparseCommandLine [\"/v\"; \"/s\"] defaultOptions\nparseCommandLine [\"/o\"; \"S\"] defaultOptions \n```", "```\nparseCommandLine [\"/v\"; \"xyz\"] defaultOptions\nparseCommandLine [\"/o\"; \"xyz\"] defaultOptions \n```", "```\n// create the \"helper\" recursive function\nlet rec parseCommandLineRec args optionsSoFar = \n    // implementation as above\n\n// create the \"public\" parse function\nlet parseCommandLine args = \n    // create the defaults\n    let defaultOptions = {\n        verbose = false;\n        subdirectories = false;\n        orderby = OrderByName\n        }\n\n    // call the recursive one with the initial options\n    parseCommandLineRec args defaultOptions \n```", "```\n// create the \"public\" parse function\nlet parseCommandLine args = \n    // create the defaults\n    let defaultOptions = \n        // implementation as above\n\n    // inner recursive function\n    let rec parseCommandLineRec args optionsSoFar = \n        // implementation as above\n\n    // call the recursive one with the initial options\n    parseCommandLineRec args defaultOptions \n```", "```\nmodule CommandLineV1 =\n\n    // constants used later\n    let OrderByName = \"N\"\n    let OrderBySize = \"S\"\n\n    // set up a type to represent the options\n    type CommandLineOptions = {\n        verbose: bool;\n        subdirectories: bool;\n        orderby: string; \n        }\n\n    // create the \"helper\" recursive function\n    let rec parseCommandLineRec args optionsSoFar = \n        match args with \n        // empty list means we're done.\n        | [] -> \n            optionsSoFar  \n\n        // match verbose flag\n        | \"/v\"::xs -> \n            let newOptionsSoFar = { optionsSoFar with verbose=true}\n            parseCommandLineRec xs newOptionsSoFar \n\n        // match subdirectories flag\n        | \"/s\"::xs -> \n            let newOptionsSoFar = { optionsSoFar with subdirectories=true}\n            parseCommandLineRec xs newOptionsSoFar \n\n        // match orderBy by flag\n        | \"/o\"::xs -> \n            //start a submatch on the next arg\n            match xs with\n            | \"S\"::xss -> \n                let newOptionsSoFar = { optionsSoFar with orderby=OrderBySize}\n                parseCommandLineRec xss newOptionsSoFar \n\n            | \"N\"::xss -> \n                let newOptionsSoFar = { optionsSoFar with orderby=OrderByName}\n                parseCommandLineRec xss newOptionsSoFar \n\n            // handle unrecognized option and keep looping\n            | _ -> \n                eprintfn \"OrderBy needs a second argument\"\n                parseCommandLineRec xs optionsSoFar \n\n        // handle unrecognized option and keep looping\n        | x::xs -> \n            eprintfn \"Option '%s' is unrecognized\" x\n            parseCommandLineRec xs optionsSoFar \n\n    // create the \"public\" parse function\n    let parseCommandLine args = \n        // create the defaults\n        let defaultOptions = {\n            verbose = false;\n            subdirectories = false;\n            orderby = OrderByName\n            }\n\n        // call the recursive one with the initial options\n        parseCommandLineRec args defaultOptions \n\n// happy path\nCommandLineV1.parseCommandLine [\"/v\"] \nCommandLineV1.parseCommandLine  [\"/v\"; \"/s\"] \nCommandLineV1.parseCommandLine  [\"/o\"; \"S\"] \n\n// error handling\nCommandLineV1.parseCommandLine [\"/v\"; \"xyz\"] \nCommandLineV1.parseCommandLine [\"/o\"; \"xyz\"] \n```", "```\ntype CommandLineOptions = {\n    verbose: bool;\n    subdirectories: bool;\n    orderby: string; \n    } \n```", "```\nmyObject.SetUpComplicatedOptions(true,false,true,false,false); \n```", "```\ntype OrderByOption = OrderBySize | OrderByName\ntype SubdirectoryOption = IncludeSubdirectories | ExcludeSubdirectories\ntype VerboseOption = VerboseOutput | TerseOutput\n\ntype CommandLineOptions = {\n    verbose: VerboseOption;\n    subdirectories: SubdirectoryOption;\n    orderby: OrderByOption\n    } \n```", "```\nmodule CommandLineV2 =\n\n    type OrderByOption = OrderBySize | OrderByName\n    type SubdirectoryOption = IncludeSubdirectories | ExcludeSubdirectories\n    type VerboseOption = VerboseOutput | TerseOutput\n\n    type CommandLineOptions = {\n        verbose: VerboseOption;\n        subdirectories: SubdirectoryOption;\n        orderby: OrderByOption\n        }\n\n    // create the \"helper\" recursive function\n    let rec parseCommandLineRec args optionsSoFar = \n        match args with \n        // empty list means we're done.\n        | [] -> \n            optionsSoFar  \n\n        // match verbose flag\n        | \"/v\"::xs -> \n            let newOptionsSoFar = { optionsSoFar with verbose=VerboseOutput}\n            parseCommandLineRec xs newOptionsSoFar \n\n        // match subdirectories flag\n        | \"/s\"::xs -> \n            let newOptionsSoFar = { optionsSoFar with subdirectories=IncludeSubdirectories}\n            parseCommandLineRec xs newOptionsSoFar \n\n        // match sort order flag\n        | \"/o\"::xs -> \n            //start a submatch on the next arg\n            match xs with\n            | \"S\"::xss -> \n                let newOptionsSoFar = { optionsSoFar with orderby=OrderBySize}\n                parseCommandLineRec xss newOptionsSoFar \n            | \"N\"::xss -> \n                let newOptionsSoFar = { optionsSoFar with orderby=OrderByName}\n                parseCommandLineRec xss newOptionsSoFar \n            // handle unrecognized option and keep looping\n            | _ -> \n                printfn \"OrderBy needs a second argument\"\n                parseCommandLineRec xs optionsSoFar \n\n        // handle unrecognized option and keep looping\n        | x::xs -> \n            printfn \"Option '%s' is unrecognized\" x\n            parseCommandLineRec xs optionsSoFar \n\n    // create the \"public\" parse function\n    let parseCommandLine args = \n        // create the defaults\n        let defaultOptions = {\n            verbose = TerseOutput;\n            subdirectories = ExcludeSubdirectories;\n            orderby = OrderByName\n            }\n\n        // call the recursive one with the initial options\n        parseCommandLineRec args defaultOptions \n\n// ==============================\n// tests \n\n// happy path\nCommandLineV2.parseCommandLine [\"/v\"] \nCommandLineV2.parseCommandLine [\"/v\"; \"/s\"] \nCommandLineV2.parseCommandLine [\"/o\"; \"S\"] \n\n// error handling\nCommandLineV2.parseCommandLine [\"/v\"; \"xyz\"] \nCommandLineV2.parseCommandLine [\"/o\"; \"xyz\"] \n```", "```\nmodule CommandLineV3 =\n\n    type OrderByOption = OrderBySize | OrderByName\n    type SubdirectoryOption = IncludeSubdirectories | ExcludeSubdirectories\n    type VerboseOption = VerboseOutput | TerseOutput\n\n    type CommandLineOptions = {\n        verbose: VerboseOption;\n        subdirectories: SubdirectoryOption;\n        orderby: OrderByOption\n        }\n\n    type ParseMode = TopLevel | OrderBy\n\n    type FoldState = {\n        options: CommandLineOptions ;\n        parseMode: ParseMode;\n        }\n\n    // parse the top-level arguments\n    // return a new FoldState\n    let parseTopLevel arg optionsSoFar = \n        match arg with \n\n        // match verbose flag\n        | \"/v\" -> \n            let newOptionsSoFar = {optionsSoFar with verbose=VerboseOutput}\n            {options=newOptionsSoFar; parseMode=TopLevel}\n\n        // match subdirectories flag\n        | \"/s\"-> \n            let newOptionsSoFar = { optionsSoFar with subdirectories=IncludeSubdirectories}\n            {options=newOptionsSoFar; parseMode=TopLevel}\n\n        // match sort order flag\n        | \"/o\" -> \n            {options=optionsSoFar; parseMode=OrderBy}\n\n        // handle unrecognized option and keep looping\n        | x -> \n            printfn \"Option '%s' is unrecognized\" x\n            {options=optionsSoFar; parseMode=TopLevel}\n\n    // parse the orderBy arguments\n    // return a new FoldState\n    let parseOrderBy arg optionsSoFar = \n        match arg with\n        | \"S\" -> \n            let newOptionsSoFar = { optionsSoFar with orderby=OrderBySize}\n            {options=newOptionsSoFar; parseMode=TopLevel}\n        | \"N\" -> \n            let newOptionsSoFar = { optionsSoFar with orderby=OrderByName}\n            {options=newOptionsSoFar; parseMode=TopLevel}\n        // handle unrecognized option and keep looping\n        | _ -> \n            printfn \"OrderBy needs a second argument\"\n            {options=optionsSoFar; parseMode=TopLevel}\n\n    // create a helper fold function\n    let foldFunction state element  = \n        match state with\n        | {options=optionsSoFar; parseMode=TopLevel} ->\n            // return new state\n            parseTopLevel element optionsSoFar\n\n        | {options=optionsSoFar; parseMode=OrderBy} ->\n            // return new state\n            parseOrderBy element optionsSoFar\n\n    // create the \"public\" parse function\n    let parseCommandLine args = \n\n        let defaultOptions = {\n            verbose = TerseOutput;\n            subdirectories = ExcludeSubdirectories;\n            orderby = OrderByName\n            }\n\n        let initialFoldState = \n            {options=defaultOptions; parseMode=TopLevel}\n\n        // call fold with the initial state\n        args |> List.fold foldFunction initialFoldState \n\n// ==============================\n// tests \n\n// happy path\nCommandLineV3.parseCommandLine [\"/v\"] \nCommandLineV3.parseCommandLine [\"/v\"; \"/s\"] \nCommandLineV3.parseCommandLine [\"/o\"; \"S\"] \n\n// error handling\nCommandLineV3.parseCommandLine [\"/v\"; \"xyz\"] \nCommandLineV3.parseCommandLine [\"/o\"; \"xyz\"] \n```", "```\n// verbose set\nCommandLineV2.parseCommandLine [\"/o\"; \"/v\"] \n\n// verbose not set! \nCommandLineV3.parseCommandLine [\"/o\"; \"/v\"] \n```", "```\n1) Accept a string of letters like \"MMMXCLXXIV\" as a string and convert it to an integer.\nThe conversions are: I=1; V=5; X=10; L=50; C=100; D=500; and M=1000;\n\nIf a lower letter comes before a higher one, the value of the higher is reduced accordingly, so\nIV=4; IX=9; XC=90; and so on.\n\n2) As an additional step, validate the string of letters to see if it is a valid number. For example: \"IIVVMM\" is a not a valid roman numeral. \n```", "```\ntype RomanDigit = int\ntype RomanNumeral = RomanDigit list \n```", "```\ntype RomanDigit = I | V | X | L | C | D | M\ntype RomanNumeral = RomanNumeral of RomanDigit list \n```", "```\n/// Converts a single RomanDigit to an integer\nlet digitToInt =\n    function\n    | I -> 1\n    | V -> 5\n    | X -> 10\n    | L -> 50\n    | C -> 100\n    | D -> 500\n    | M -> 1000\n\n// tests\nI  |> digitToInt\nV  |> digitToInt\nM  |> digitToInt \n```", "```\nlet rec digitsToInt =\n    function\n\n    // empty is 0\n    | [] -> 0\n\n    // special case when a smaller comes before larger\n    // convert both digits and add the difference to the sum \n    // Example: \"IV\" and \"CM\"\n    | smaller::larger::ns when smaller < larger -> \n        (digitToInt larger - digitToInt smaller)  + digitsToInt ns\n\n    // otherwise convert the digit and add to the sum \n    | digit::ns -> \n        digitToInt digit + digitsToInt ns\n\n// tests\n[I;I;I;I]  |> digitsToInt\n[I;V]  |> digitsToInt\n[V;I]  |> digitsToInt\n[I;X]  |> digitsToInt\n[M;C;M;L;X;X;I;X]  |> digitsToInt // 1979\n[M;C;M;X;L;I;V] |> digitsToInt // 1944 \n```", "```\n/// converts a RomanNumeral to an integer\nlet toInt (RomanNumeral digits) = digitsToInt digits\n\n// test\nlet x = RomanNumeral [I;I;I;I]\nx |> toInt\n\nlet x = RomanNumeral [M;C;M;L;X;X;I;X]\nx |> toInt \n```", "```\nlet charToRomanDigit =\n    function\n    | 'I' -> I\n    | 'V' -> V\n    | 'X' -> X\n    | 'L' -> L\n    | 'C' -> C\n    | 'D' -> D\n    | 'M' -> M \n```", "```\nlet charToRomanDigit =\n    function\n    | 'I' -> I\n    | 'V' -> V\n    | 'X' -> X\n    | 'L' -> L\n    | 'C' -> C\n    | 'D' -> D\n    | 'M' -> M\n    | ch -> eprintf \"%c is not a valid character\" ch \n```", "```\ntype ParsedChar = \n    | Digit of RomanDigit \n    | BadChar of char\n\nlet charToRomanDigit =\n    function\n    | 'I' -> Digit I\n    | 'V' -> Digit V\n    | 'X' -> Digit X\n    | 'L' -> Digit L\n    | 'C' -> Digit C\n    | 'D' -> Digit D\n    | 'M' -> Digit M\n    | ch -> BadChar ch \n```", "```\ncharToRomanDigit : char -> ParsedChar \n```", "```\nlet toRomanDigitList s = \n    s.ToCharArray() // error FS0072\n    |> List.ofArray \n    |> List.map charToRomanDigit \n```", "```\nlet toRomanDigitList (s:string) = \n    s.ToCharArray() \n    |> List.ofArray \n    |> List.map charToRomanDigit \n```", "```\ntoRomanDigitList : string -> ParsedChar list \n```", "```\n// convert a string to a RomanNumeral\nlet toRomanNumeral s = \n    toRomanDigitList s\n    |> RomanNumeral \n```", "```\n/// Convert a string to a RomanNumeral\n/// Does not validate the input.E.g. \"IVIV\" would be valid\nlet toRomanNumeral s = \n    toRomanDigitList s\n    |> List.choose (\n        function \n        | Digit digit -> \n            Some digit \n        | BadChar ch -> \n            eprintfn \"%c is not a valid character\" ch\n            None\n        )\n    |> RomanNumeral \n```", "```\n// test good cases\n\n\"IIII\"  |> toRomanNumeral\n\"IV\"  |> toRomanNumeral\n\"VI\"  |> toRomanNumeral\n\"IX\"  |> toRomanNumeral\n\"MCMLXXIX\"  |> toRomanNumeral\n\"MCMXLIV\" |> toRomanNumeral\n\"\" |> toRomanNumeral\n\n// error cases\n\"MC?I\" |> toRomanNumeral\n\"abc\" |> toRomanNumeral \n```", "```\nlet runsAllowed = \n    function \n    | I | X | C | M -> true\n    | V | L | D -> false\n\nlet noRunsAllowed  = runsAllowed >> not \n\n// check for validity\nlet rec isValidDigitList digitList =\n    match digitList with\n\n    // empty list is valid\n    | [] -> true\n\n    // A run of 5 or more anything is invalid\n    // Example:  XXXXX\n    | d1::d2::d3::d4::d5::_ \n        when d1=d2 && d1=d3 && d1=d4 && d1=d5 -> \n            false\n\n    // 2 or more non-runnable digits is invalid\n    // Example:  VV\n    | d1::d2::_ \n        when d1=d2 && noRunsAllowed d1 -> \n            false\n\n    // runs of 2,3,4 in the middle are invalid if next digit is higher\n    // Example:  IIIX\n    | d1::d2::d3::d4::higher::ds \n        when d1=d2 && d1=d3 && d1=d4 \n        && runsAllowed d1 // not really needed because of the order of matching\n        && higher > d1 -> \n            false\n\n    | d1::d2::d3::higher::ds \n        when d1=d2 && d1=d3 \n        && runsAllowed d1 \n        && higher > d1 -> \n            false\n\n    | d1::d2::higher::ds \n        when d1=d2 \n        && runsAllowed d1 \n        && higher > d1 -> \n            false\n\n    // three ascending numbers in a row is invalid\n    // Example:  IVX\n    | d1::d2::d3::_  when d1<d2 && d2<= d3 -> \n        false\n\n    // A single digit with no runs is always allowed\n    | _::ds -> \n        // check the remainder of the list\n        isValidDigitList ds \n```", "```\n// test valid \nlet validList = [\n    [I;I;I;I]\n    [I;V]\n    [I;X]\n    [I;X;V]\n    [V;X]\n    [X;I;V]\n    [X;I;X]\n    [X;X;I;I]\n    ]\n\nlet testValid = validList |> List.map isValidDigitList\n\nlet invalidList = [\n    // Five in a row of any digit is not allowed\n    [I;I;I;I;I]\n    // Two in a row for V,L, D is not allowed\n    [V;V] \n    [L;L] \n    [D;D]\n    // runs of 2,3,4 in the middle are invalid if next digit is higher\n    [I;I;V]\n    [X;X;X;M]\n    [C;C;C;C;D]\n    // three ascending numbers in a row is invalid\n    [I;V;X]\n    [X;L;D]\n    ]\nlet testInvalid = invalidList |> List.map isValidDigitList \n```", "```\n// top level check for validity\nlet isValid (RomanNumeral digitList) =\n    isValidDigitList digitList\n\n// test good cases\n\"IIII\"  |> toRomanNumeral |> isValid\n\"IV\"  |> toRomanNumeral |> isValid\n\"\" |> toRomanNumeral |> isValid\n\n// error cases\n\"IIXX\" |> toRomanNumeral |> isValid\n\"VV\" |> toRomanNumeral |> isValid\n\n// grand finale\n[ \"IIII\"; \"XIV\"; \"MMDXC\"; \n\"IIXX\"; \"VV\"; ]\n|> List.map toRomanNumeral \n|> List.iter (function\n    | n when isValid n ->\n        printfn \"%A is valid and its integer value is %i\" n (toInt n) \n    | n ->\n        printfn \"%A is not valid\" n\n    ) \n```", "```\nmodule RomanNumeralsV1 =\n\n    // ==========================================\n    // Types\n    // ==========================================\n\n    type RomanDigit = I | V | X | L | C | D | M\n    type RomanNumeral = RomanNumeral of RomanDigit list \n\n    // ==========================================\n    // Output logic\n    // ==========================================\n\n    /// Converts a single RomanDigit to an integer\n    let digitToInt =\n        function\n        | I -> 1\n        | V -> 5\n        | X -> 10\n        | L -> 50\n        | C -> 100\n        | D -> 500\n        | M -> 1000\n\n    /// converts a list of digits to an integer\n    let rec digitsToInt =\n        function\n\n        // empty is 0\n        | [] -> 0\n\n        // special case when a smaller comes before larger\n        // convert both digits and add the difference to the sum \n        // Example: \"IV\" and \"CM\"\n        | smaller::larger::ns when smaller < larger -> \n            (digitToInt larger - digitToInt smaller)  + digitsToInt ns\n\n        // otherwise convert the digit and add to the sum \n        | digit::ns -> \n            digitToInt digit + digitsToInt ns\n\n    /// converts a RomanNumeral to an integer\n    let toInt (RomanNumeral digits) = digitsToInt digits\n\n    // ==========================================\n    // Input logic\n    // ==========================================\n\n    type ParsedChar = \n        | Digit of RomanDigit \n        | BadChar of char\n\n    let charToRomanDigit =\n        function\n        | 'I' -> Digit I\n        | 'V' -> Digit V\n        | 'X' -> Digit X\n        | 'L' -> Digit L\n        | 'C' -> Digit C\n        | 'D' -> Digit D\n        | 'M' -> Digit M\n        | ch -> BadChar ch\n\n    let toRomanDigitList (s:string) = \n        s.ToCharArray() \n        |> List.ofArray \n        |> List.map charToRomanDigit\n\n    /// Convert a string to a RomanNumeral\n    /// Does not validate the input.E.g. \"IVIV\" would be valid\n    let toRomanNumeral s = \n        toRomanDigitList s\n        |> List.choose (\n            function \n            | Digit digit -> \n                Some digit \n            | BadChar ch -> \n                eprintfn \"%c is not a valid character\" ch\n                None\n            )\n        |> RomanNumeral\n\n    // ==========================================\n    // Validation logic\n    // ==========================================\n\n    let runsAllowed = \n        function \n        | I | X | C | M -> true\n        | V | L | D -> false\n\n    let noRunsAllowed  = runsAllowed >> not \n\n    // check for validity\n    let rec isValidDigitList digitList =\n        match digitList with\n\n        // empty list is valid\n        | [] -> true\n\n        // A run of 5 or more anything is invalid\n        // Example:  XXXXX\n        | d1::d2::d3::d4::d5::_ \n            when d1=d2 && d1=d3 && d1=d4 && d1=d5 -> \n                false\n\n        // 2 or more non-runnable digits is invalid\n        // Example:  VV\n        | d1::d2::_ \n            when d1=d2 && noRunsAllowed d1 -> \n                false\n\n        // runs of 2,3,4 in the middle are invalid if next digit is higher\n        // Example:  IIIX\n        | d1::d2::d3::d4::higher::ds \n            when d1=d2 && d1=d3 && d1=d4 \n            && runsAllowed d1 // not really needed because of the order of matching\n            && higher > d1 -> \n                false\n\n        | d1::d2::d3::higher::ds \n            when d1=d2 && d1=d3 \n            && runsAllowed d1 \n            && higher > d1 -> \n                false\n\n        | d1::d2::higher::ds \n            when d1=d2 \n            && runsAllowed d1 \n            && higher > d1 -> \n                false\n\n        // three ascending numbers in a row is invalid\n        // Example:  IVX\n        | d1::d2::d3::_  when d1<d2 && d2<= d3 -> \n            false\n\n        // A single digit with no runs is always allowed\n        | _::ds -> \n            // check the remainder of the list\n            isValidDigitList ds \n\n    // top level check for validity\n    let isValid (RomanNumeral digitList) =\n        isValidDigitList digitList \n```", "```\n\"VIV\" |> toRomanNumeral |> isValid \n```", "```\ntype RomanDigit = \n    | I | II | III | IIII \n    | IV | V \n    | IX | X | XX | XXX | XXXX  \n    | XL | L \n    | XC | C | CC | CCC | CCCC \n    | CD | D \n    | CM | M | MM | MMM | MMMM\ntype RomanNumeral = RomanNumeral of RomanDigit list \n```", "```\n/// Converts a single RomanDigit to an integer\nlet digitToInt =\n    function\n    | I -> 1 | II -> 2 | III -> 3 | IIII -> 4 \n    | IV -> 4 | V -> 5\n    | IX -> 9 | X -> 10 | XX -> 20 | XXX -> 30 | XXXX -> 40 \n    | XL -> 40 | L -> 50 \n    | XC -> 90 | C -> 100 | CC -> 200 | CCC -> 300 | CCCC -> 400 \n    | CD -> 400 | D -> 500 \n    | CM -> 900 | M -> 1000 | MM -> 2000 | MMM -> 3000 | MMMM -> 4000\n\n// tests\nI  |> digitToInt\nIII  |> digitToInt\nV  |> digitToInt\nCM  |> digitToInt \n```", "```\n/// converts a list of digits to an integer\nlet digitsToInt list = \n    list |> List.sumBy digitToInt \n\n// tests\n[IIII]  |> digitsToInt\n[IV]  |> digitsToInt\n[V;I]  |> digitsToInt\n[IX]  |> digitsToInt\n[M;CM;L;X;X;IX]  |> digitsToInt // 1979\n[M;CM;XL;IV] |> digitsToInt // 1944 \n```", "```\n/// converts a RomanNumeral to an integer\nlet toInt (RomanNumeral digits) = digitsToInt digits\n\n// test\nlet x = RomanNumeral [M;CM;LX;X;IX]\nx |> toInt \n```", "```\ntype ParsedChar = \n    | Digit of RomanDigit \n    | BadChar of char\n\nlet rec toRomanDigitListRec charList = \n    match charList with\n    // match the longest patterns first\n\n    // 4 letter matches\n    | 'I'::'I'::'I'::'I'::ns -> \n        Digit IIII :: (toRomanDigitListRec ns)\n    | 'X'::'X'::'X'::'X'::ns -> \n        Digit XXXX :: (toRomanDigitListRec ns)\n    | 'C'::'C'::'C'::'C'::ns -> \n        Digit CCCC :: (toRomanDigitListRec ns)\n    | 'M'::'M'::'M'::'M'::ns -> \n        Digit MMMM :: (toRomanDigitListRec ns)\n\n    // 3 letter matches\n    | 'I'::'I'::'I'::ns -> \n        Digit III :: (toRomanDigitListRec ns)\n    | 'X'::'X'::'X'::ns -> \n        Digit XXX :: (toRomanDigitListRec ns)\n    | 'C'::'C'::'C'::ns -> \n        Digit CCC :: (toRomanDigitListRec ns)\n    | 'M'::'M'::'M'::ns -> \n        Digit MMM :: (toRomanDigitListRec ns)\n\n    // 2 letter matches\n    | 'I'::'I'::ns -> \n        Digit II :: (toRomanDigitListRec ns)\n    | 'X'::'X'::ns -> \n        Digit XX :: (toRomanDigitListRec ns)\n    | 'C'::'C'::ns -> \n        Digit CC :: (toRomanDigitListRec ns)\n    | 'M'::'M'::ns -> \n        Digit MM :: (toRomanDigitListRec ns)\n\n    | 'I'::'V'::ns -> \n        Digit IV :: (toRomanDigitListRec ns)\n    | 'I'::'X'::ns -> \n        Digit IX :: (toRomanDigitListRec ns)\n    | 'X'::'L'::ns -> \n        Digit XL :: (toRomanDigitListRec ns)\n    | 'X'::'C'::ns -> \n        Digit XC :: (toRomanDigitListRec ns)\n    | 'C'::'D'::ns -> \n        Digit CD :: (toRomanDigitListRec ns)\n    | 'C'::'M'::ns -> \n        Digit CM :: (toRomanDigitListRec ns)\n\n    // 1 letter matches\n    | 'I'::ns -> \n        Digit I :: (toRomanDigitListRec ns)\n    | 'V'::ns -> \n        Digit V :: (toRomanDigitListRec ns)\n    | 'X'::ns -> \n        Digit X :: (toRomanDigitListRec ns)\n    | 'L'::ns -> \n        Digit L :: (toRomanDigitListRec ns)\n    | 'C'::ns -> \n        Digit C :: (toRomanDigitListRec ns)\n    | 'D'::ns -> \n        Digit D :: (toRomanDigitListRec ns)\n    | 'M'::ns -> \n        Digit M :: (toRomanDigitListRec ns)\n\n    // bad letter matches\n    | badChar::ns -> \n        BadChar badChar :: (toRomanDigitListRec ns)\n\n    // 0 letter matches\n    | [] -> \n        [] \n```", "```\nlet toRomanDigitList (s:string) = \n    s.ToCharArray() \n    |> List.ofArray \n    |> toRomanDigitListRec\n\n/// Convert a string to a RomanNumeral\nlet toRomanNumeral s = \n    toRomanDigitList s\n    |> List.choose (\n        function \n        | Digit digit -> \n            Some digit \n        | BadChar ch -> \n            eprintfn \"%c is not a valid character\" ch\n            None\n        )\n    |> RomanNumeral\n\n// test good cases\n\"IIII\"  |> toRomanNumeral\n\"IV\"  |> toRomanNumeral\n\"VI\"  |> toRomanNumeral\n\"IX\"  |> toRomanNumeral\n\"MCMLXXIX\"  |> toRomanNumeral\n\"MCMXLIV\" |> toRomanNumeral\n\"\" |> toRomanNumeral\n\n// error cases\n\"MC?I\" |> toRomanNumeral\n\"abc\" |> toRomanNumeral \n```", "```\n// check for validity\nlet rec isValidDigitList digitList =\n    match digitList with\n\n    // empty list is valid\n    | [] -> true\n\n    // a following digit that is equal or larger is an error\n    | d1::d2::_ \n        when d1 <= d2  -> \n            false\n\n    // A single digit is always allowed\n    | _::ds -> \n        // check the remainder of the list\n        isValidDigitList ds \n\n// top level check for validity\nlet isValid (RomanNumeral digitList) =\n    isValidDigitList digitList\n\n// test good cases\n\"IIII\"  |> toRomanNumeral |> isValid\n\"IV\"  |> toRomanNumeral |> isValid\n\"\" |> toRomanNumeral |> isValid\n\n// error cases\n\"IIXX\" |> toRomanNumeral |> isValid\n\"VV\" |> toRomanNumeral |> isValid \n```", "```\n\"VIV\" |> toRomanNumeral |> isValid \n```", "```\nmodule RomanNumeralsV2 =\n\n    // ==========================================\n    // Types\n    // ==========================================\n\n    type RomanDigit = \n        | I | II | III | IIII \n        | IV | V \n        | IX | X | XX | XXX | XXXX  \n        | XL | L \n        | XC | C | CC | CCC | CCCC \n        | CD | D \n        | CM | M | MM | MMM | MMMM\n    type RomanNumeral = RomanNumeral of RomanDigit list \n\n    // ==========================================\n    // Output logic\n    // ==========================================\n\n    /// Converts a single RomanDigit to an integer\n    let digitToInt =\n        function\n        | I -> 1 | II -> 2 | III -> 3 | IIII -> 4 \n        | IV -> 4 | V -> 5\n        | IX -> 9 | X -> 10 | XX -> 20 | XXX -> 30 | XXXX -> 40 \n        | XL -> 40 | L -> 50 \n        | XC -> 90 | C -> 100 | CC -> 200 | CCC -> 300 | CCCC -> 400 \n        | CD -> 400 | D -> 500 \n        | CM -> 900 | M -> 1000 | MM -> 2000 | MMM -> 3000 | MMMM -> 4000\n\n    /// converts a RomanNumeral to an integer\n    let toInt (RomanNumeral digits) = digitsToInt digits\n\n    // ==========================================\n    // Input logic\n    // ==========================================\n\n    type ParsedChar = \n        | Digit of RomanDigit \n        | BadChar of char\n\n    let rec toRomanDigitListRec charList = \n        match charList with\n        // match the longest patterns first\n\n        // 4 letter matches\n        | 'I'::'I'::'I'::'I'::ns -> \n            Digit IIII :: (toRomanDigitListRec ns)\n        | 'X'::'X'::'X'::'X'::ns -> \n            Digit XXXX :: (toRomanDigitListRec ns)\n        | 'C'::'C'::'C'::'C'::ns -> \n            Digit CCCC :: (toRomanDigitListRec ns)\n        | 'M'::'M'::'M'::'M'::ns -> \n            Digit MMMM :: (toRomanDigitListRec ns)\n\n        // 3 letter matches\n        | 'I'::'I'::'I'::ns -> \n            Digit III :: (toRomanDigitListRec ns)\n        | 'X'::'X'::'X'::ns -> \n            Digit XXX :: (toRomanDigitListRec ns)\n        | 'C'::'C'::'C'::ns -> \n            Digit CCC :: (toRomanDigitListRec ns)\n        | 'M'::'M'::'M'::ns -> \n            Digit MMM :: (toRomanDigitListRec ns)\n\n        // 2 letter matches\n        | 'I'::'I'::ns -> \n            Digit II :: (toRomanDigitListRec ns)\n        | 'X'::'X'::ns -> \n            Digit XX :: (toRomanDigitListRec ns)\n        | 'C'::'C'::ns -> \n            Digit CC :: (toRomanDigitListRec ns)\n        | 'M'::'M'::ns -> \n            Digit MM :: (toRomanDigitListRec ns)\n\n        | 'I'::'V'::ns -> \n            Digit IV :: (toRomanDigitListRec ns)\n        | 'I'::'X'::ns -> \n            Digit IX :: (toRomanDigitListRec ns)\n        | 'X'::'L'::ns -> \n            Digit XL :: (toRomanDigitListRec ns)\n        | 'X'::'C'::ns -> \n            Digit XC :: (toRomanDigitListRec ns)\n        | 'C'::'D'::ns -> \n            Digit CD :: (toRomanDigitListRec ns)\n        | 'C'::'M'::ns -> \n            Digit CM :: (toRomanDigitListRec ns)\n\n        // 1 letter matches\n        | 'I'::ns -> \n            Digit I :: (toRomanDigitListRec ns)\n        | 'V'::ns -> \n            Digit V :: (toRomanDigitListRec ns)\n        | 'X'::ns -> \n            Digit X :: (toRomanDigitListRec ns)\n        | 'L'::ns -> \n            Digit L :: (toRomanDigitListRec ns)\n        | 'C'::ns -> \n            Digit C :: (toRomanDigitListRec ns)\n        | 'D'::ns -> \n            Digit D :: (toRomanDigitListRec ns)\n        | 'M'::ns -> \n            Digit M :: (toRomanDigitListRec ns)\n\n        // bad letter matches\n        | badChar::ns -> \n            BadChar badChar :: (toRomanDigitListRec ns)\n\n        // 0 letter matches\n        | [] -> \n            []\n\n    let toRomanDigitList (s:string) = \n        s.ToCharArray() \n        |> List.ofArray \n        |> toRomanDigitListRec\n\n    /// Convert a string to a RomanNumeral\n    /// Does not validate the input.E.g. \"IVIV\" would be valid\n    let toRomanNumeral s = \n        toRomanDigitList s\n        |> List.choose (\n            function \n            | Digit digit -> \n                Some digit \n            | BadChar ch -> \n                eprintfn \"%c is not a valid character\" ch\n                None\n            )\n        |> RomanNumeral\n\n    // ==========================================\n    // Validation logic\n    // ==========================================\n\n    // check for validity\n    let rec isValidDigitList digitList =\n        match digitList with\n\n        // empty list is valid\n        | [] -> true\n\n        // a following digit that is equal or larger is an error\n        | d1::d2::_ \n            when d1 <= d2  -> \n                false\n\n        // A single digit is always allowed\n        | _::ds -> \n            // check the remainder of the list\n            isValidDigitList ds \n\n    // top level check for validity\n    let isValid (RomanNumeral digitList) =\n        isValidDigitList digitList \n```", "```\ntype RomanNumeral with\n\n    static member FromString s = \n        toRomanNumeral s\n\n    member this.ToInt() = \n        toInt this\n\n    override this.ToString() = \n        sprintf \"%A\" this \n```", "```\nlet r = RomanNumeral.FromString \"XXIV\"\nlet s = r.ToString()\nlet i = r.ToInt() \n```"]