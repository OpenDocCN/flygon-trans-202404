- en: Typing the Y CombinatorTuesday, February 14th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typing the Y combinator is a tricky issue. For example, in standard ML you
    must write a new type definition to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Can you find a pattern in the places where `T` is used? — Roughly speaking,
    that type definition is
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'First note that the two `fn a => ...` parts are the same as our protection,
    so ignoring that we get:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if you now replace `T` with `Quote`, things make more sense:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'and with our syntax, this would be:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'it’s not really quotation — but the analogy should help: it uses `Quote` to
    distinguish functions as values that are applied (the `x`s) from functions that
    are passed as arguments.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In OCaml, this looks a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'but OCaml has also a `-rectypes` command line argument, which will make it
    infer the type by itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to write this expression in Typed Racket, but we will need
    to write a proper type definition. First of all, the type of Y should be straightforward:
    it is a fixpoint operation, so it takes a `T -> T` function and produces its fixpoint.
    The fixpoint itself is some `T` (such that applying the function on it results
    in itself). So this gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, in our case `make-recursive` computes a *functional* fixpoint, for
    unary `S -> T` functions, so we should narrow down the type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the body of `make-recursive` we need to add a type for the `x` argument
    which is behaving in a weird way: it is used both as a function and as its own
    argument. (Remember — I will say the next sentence twice: “I will say the next
    sentence twice”.) We need a recursive type definition for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This type is tailored for our use of `x`: given a type `T`, `x` is a function
    that will consume *itself* (hence the `Rec`) and spit out the value that the `f`
    argument consumes — an `S -> T` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting full version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
