- en: Chapter 7\. Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。输入和输出
- en: All input and output operations are performed through *ports*. A port is a pointer
    into a (possibly infinite) stream of data (often a file), an opening through which
    programs may draw bytes or characters from the stream or place bytes or characters
    into the stream. A port may be an input port, an output port, or both simultaneously.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的输入和输出操作都是通过*端口*执行的。端口是指向（可能是无限的）数据流（通常是文件）的指针，是程序可以从流中提取字节或字符或将字节或字符放入流中的开口。端口可以是输入端口、输出端口或同时是两者。
- en: 'Ports are first-class objects, like any other object in Scheme. Like procedures,
    ports do not have a printed representation the way strings and numbers do. There
    are initially three ports: the current input port, current output port, and current
    error port, which are textual ports connected to the process''s standard input,
    standard output, and standard error streams. Several ways to open new ports are
    provided.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是Scheme中的一等对象，就像任何其他对象一样。与过程一样，端口没有像字符串和数字那样的打印表示。最初有三个端口：当前输入端口、当前输出端口和当前错误端口，它们是连接到进程标准输入、标准输出和标准错误流的文本端口。提供了几种打开新端口的方法。
- en: An input port often points to a finite stream, e.g., an input file stored on
    disk. If one of the input operations, e.g., `get-u8`, `get-char`, or `get-datum`,
    is asked to read from a port that has reached the end of a finite stream, it returns
    a special *eof* (end of file) *object*. The predicate `eof-object?` may be used
    to determine if the value returned from the input operation is the eof object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 输入端口通常指向有限流，例如，存储在磁盘上的输入文件。如果输入操作中的一个，例如，`get-u8`、`get-char`或`get-datum`，被要求从已经到达有限流末尾的端口读取时，它会返回一个特殊的*eof*（文件结束）*对象*。谓词`eof-object?`可以用来确定从输入操作返回的值是否是eof对象。
- en: Ports are either *binary* or *textual*. A binary port allows a program to read
    or write 8-bit unsigned bytes, or "octets," from or to the underlying stream.
    A textual port allows a program to read or write characters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 端口可以是*二进制*或*文本*。二进制端口允许程序从底层流中读取或写入8位无符号字节，或“八位字节”，文本端口允许程序读取或写入字符。
- en: 'In many cases, the underlying stream is organized as a sequence of bytes, but
    these bytes should be treated as encodings for characters. In this case, a textual
    port may be created with a *transcoder* to decode bytes to characters (for input)
    or encode characters to bytes (for output). A transcoder encapsulates a *codec*
    that determines how characters are represented as bytes. Three standard codecs
    are provided: a *latin-1* codec, a Unicode *utf-8* codec, and a Unicode *utf-16*
    codec. For the *latin-1* encoding, each character is represented by exactly one
    byte. For *utf-8*, each character is represented by from one to four bytes, and
    for *utf-16*, each character is represented by two or four bytes.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，底层流被组织为一系列字节，但这些字节应被视为字符的编码。在这种情况下，可以使用*转码器*创建文本端口来将字节解码为字符（用于输入）或将字符编码为字节（用于输出）。转码器封装了一个确定字符如何表示为字节的*编解码器*。提供了三种标准编解码器：*latin-1*编解码器，Unicode
    *utf-8*编解码器和Unicode *utf-16*编解码器。对于*latin-1*编码，每个字符由一个字节表示。对于*utf-8*，每个字符由一个到四个字节表示，对于*utf-16*，每个字符由两个或四个字节表示。
- en: 'A transcoder also encapsulates an *eol style* that determines whether and how
    line endings are recognized. If the eol style is `none`, no line endings are recognized.
    The six other standard eol styles are the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 转码器还封装了一个确定如何识别行尾的*eol样式*。如果eol样式是`none`，则不识别行尾。另外提供了六种标准eol样式，如下所示：
- en: '| `lf`: | line-feed character |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `lf`: | 换行符字符 |'
- en: '| `cr`: | carriage-return character |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `cr`: | 回车字符 |'
- en: '| `nel`: | Unicode next-line character |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `nel`: | Unicode下一行字符 |'
- en: '| `ls`: | Unicode line-separator character |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `ls`: | Unicode换行符字符 |'
- en: '| `crlf`: | carriage return followed by line feed, and |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `crlf`: | 回车后跟换行，并 |'
- en: '| `crnel`: | carriage return followed by next line |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `crnel`: | 回车后跟下一行 |'
- en: The eol style affects input and output operations differently. For input, any
    eol style except `none` causes each of the line-ending characters or two-character
    sequences to be converted into a single line-feed character. For output, any eol
    style except `none` causes line-feed characters to be converted into the specific
    one- or two-character sequence associated with the eol style. In the input direction,
    all eol styles except `none` are equivalent, while in the output direction, the
    eol styles `none` and `lf` are equivalent.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 换行样式会对输入和输出操作产生不同影响。对于输入而言，除了 `none` 外的任何换行样式都会导致每个换行字符或两个字符序列被转换为一个换行字符。对于输出而言，除了
    `none` 外的任何换行样式都会导致换行字符被转换为与换行样式关联的特定的一个或两个字符序列。在输入方向上，除了 `none` 外的所有换行样式都是等效的，而在输出方向上，换行样式
    `none` 和 `lf` 是等效的。
- en: 'In addition to the codec and eol style, a transcoder encapsulates just one
    other piece of information: an *error-handling mode* that determines what happens
    if a decoding or encoding error occurs, i.e., if a sequence of bytes cannot be
    converted to a character with the encapsulated codec in the input direction or
    a character cannot be converted to a sequence of bytes with the encapsulated codec
    in the output direction. The error-handling mode is `ignore`, `raise`, or `replace`.
    If the error-handling mode is `ignore`, the offending sequence of bytes or the
    character is ignored. If the error-handling mode is `raise`, an exception with
    condition type `i/o-decoding` or `i/o-encoding` is raised; in the input direction,
    the port is positioned beyond the sequence of bytes. If the error-handling mode
    is `replace`, a replacement character or character encoding is produced: in the
    input direction, the replacement character is U+FFFD, while in the output direction,
    the replacement is either the encoding of U+FFFD for `utf-8` and `utf-16` codecs
    or the encoding of the question-mark character ( ? ) for the `latin-1` codec.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编解码器和换行样式外，转码器还封装了另一个信息：一个 *错误处理模式*，用于确定在发生解码或编码错误时会发生什么，即如果一个字节序列无法在输入方向上用封装的编解码器转换为字符，或者一个字符无法在输出方向上用封装的编解码器转换为字节序列。错误处理模式是
    `ignore`、`raise` 或 `replace`。如果错误处理模式是 `ignore`，则会忽略有问题的字节序列或字符。如果错误处理模式是 `raise`，则会引发一个带有
    `i/o-decoding` 或 `i/o-encoding` 条件类型的异常；在输入方向上，端口会被定位到字节序列之后。如果错误处理模式是 `replace`，则会产生一个替换字符或字符编码：在输入方向上，替换字符是
    U+FFFD，而在输出方向上，替换字符是 `utf-8` 和 `utf-16` 编解码器的编码或者 `latin-1` 编解码器的问号字符 ( ? ) 的编码。
- en: 'A port may be buffered for efficiency, to eliminate the overhead of a call
    into the operating system for each byte or character. Three standard buffer modes
    are supported: *block*, *line*, and *none*. With block buffering, input is drawn
    from a stream and output is sent to the stream in chunks of some implementation-dependent
    size. With line buffering, buffering is performed on a line-by-line basis or on
    some other implementation-dependent basis. Line buffering is typically distinguished
    from block buffering only for textual output ports; there are no line divisions
    in binary ports, and input is likely to be drawn from a stream as it becomes available.
    With buffer-mode none, no buffering is performed, so output is sent immediately
    to the stream and input is drawn only as needed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，可以对端口进行缓冲，以消除每个字节或字符调用操作系统的开销。支持三种标准的缓冲模式：*block*、*line* 和 *none*。使用块缓冲时，输入从流中获取，输出以一些与实现相关的大小的块发送到流中。使用行缓冲时，缓冲是基于行或其他某种与实现相关的基础进行的。行缓冲通常仅对文本输出端口进行区分；在二进制端口中没有行分隔，输入可能会在流中可用时获取。使用无缓冲区模式时，不进行缓冲，因此输出立即发送到流中，并且只有在需要时才获取输入。
- en: The remainder of this chapter covers operations on transcoders, file ports,
    standard ports, string and bytevector ports, custom ports, general port operations,
    input operations, output operations, convenience I/O, filesystem operations, and
    conversions between bytevectors and strings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分涵盖了对转码器、文件端口、标准端口、字符串和字节向量端口、自定义端口、一般端口操作、输入操作、输出操作、便捷I/O、文件系统操作以及字节向量和字符串之间的转换的操作。
- en: Section 7.1\. Transcoders
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 7.1 节。转码器
- en: 'As described above, transcoders encapsulate three values: a codec, an eol style,
    and an error-handling mode. This section describes the procedures that create
    or operate on transcoders and the values that transcoders encapsulate.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，转码器封装了三个值：编解码器、换行样式和错误处理模式。本节描述了创建或操作转码器以及转码器封装的值的过程。
- en: '**procedure**: `(make-transcoder *codec*)`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-transcoder *codec*)`'
- en: '**procedure**: `(make-transcoder *codec* *eol-style*)`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-transcoder *codec* *eol-style*)`'
- en: '**procedure**: `(make-transcoder *codec* *eol-style* *error-handling-mode*)`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-transcoder *codec* *eol-style* *error-handling-mode*)`'
- en: '**returns:** a transcoder encapsulating `*codec*`, `*eol-style*`, and `*error-handling-mode*`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 封装了 `*codec*`、`*eol-style*` 和 `*error-handling-mode*` 的转码器'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '`*eol-style*` must be a valid eol-style symbol (`lf`, `cr`, `nel`, `ls`, `crlf`,
    `crnel`, or `none`); it defaults to the native eol-style for the platform. `*error-handling-mode*`
    must be a valid error-handling-mode symbol (`ignore`, `raise`, or `replace`) and
    defaults to `replace`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`*eol-style*` 必须是有效的 eol-style 符号之一（`lf`、`cr`、`nel`、`ls`、`crlf`、`crnel` 或 `none`）；它默认为平台的本机
    eol 样式。`*error-handling-mode*` 必须是有效的错误处理模式符号（`ignore`、`raise` 或 `replace`）并默认为
    `replace`。'
- en: '**procedure**: `(transcoder-codec *transcoder*)`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(transcoder-codec *transcoder*)`'
- en: '**returns:** the codec encapsulated in `*transcoder*`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 以 `*transcoder*` 封装的编解码器'
- en: '**procedure**: `(transcoder-eol-style *transcoder*)`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(transcoder-eol-style *transcoder*)`'
- en: '**returns:** the eol-style symbol encapsulated in `*transcoder*`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 以 `*transcoder*` 封装的 eol-style 符号'
- en: '**procedure**: `(transcoder-error-handling-mode *transcoder*)`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(transcoder-error-handling-mode *transcoder*)`'
- en: '**returns:** the error-handling-mode symbol encapsulated in `*transcoder*`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 以 `*transcoder*` 封装的错误处理模式符号'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '**procedure**: `(native-transcoder)`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(native-transcoder)`'
- en: '**returns:** the native transcoder'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 本机转码器'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: The native transcoder is implementation-dependent and may vary by platform or
    locale.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本机编解码器是实现相关的，可能会因平台或语言环境而异。
- en: '**procedure**: `(latin-1-codec)`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(latin-1-codec)`'
- en: '**returns:** a codec for ISO 8859-1 (Latin 1) character encodings'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 用于 ISO 8859-1（Latin 1）字符编码的编解码器'
- en: '**procedure**: `(utf-8-codec)`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(utf-8-codec)`'
- en: '**returns:** a codec for Unicode UTF-8 character encodings'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 用于 Unicode UTF-8 字符编码的编解码器'
- en: '**procedure**: `(utf-16-codec)`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(utf-16-codec)`'
- en: '**returns:** a codec for Unicode UTF-16 character encodings'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 用于 Unicode UTF-16 字符编码的编解码器'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '**syntax**: `(eol-style *symbol*)`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(eol-style *symbol*)`'
- en: '**returns:** `*symbol*`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*symbol*`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '`*symbol*` must be one of the symbols `lf`, `cr`, `nel`, `ls`, `crlf`, `crnel`,
    or `none`. The expression `(eol-style *symbol*)` is equivalent to the expression
    `(quote *symbol*)` except the former checks at expansion time that `*symbol*`
    is one of the eol-style symbols. The `eol-style` syntax provides useful documentation
    as well.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`*symbol*` 必须是 `lf`、`cr`、`nel`、`ls`、`crlf`、`crnel` 或 `none` 符号之一。表达式 `(eol-style *symbol*)`
    等同于 `(quote *symbol*)`，除了前者在扩展时检查 `*symbol*` 是否为 eol-style 符号之外。`eol-style` 语法还提供了有用的文档。'
- en: '`(eol-style crlf) ![<graphic>](ch2_0.gif) crlf'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eol-style crlf) ![<graphic>](ch2_0.gif) crlf'
- en: (eol-style lfcr) ![<graphic>](ch2_0.gif) *syntax violation*`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: (eol-style lfcr) ![<graphic>](ch2_0.gif) *syntax violation*`
- en: '**procedure**: `(native-eol-style)`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(native-eol-style)`'
- en: '**returns:** the native eol style'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 本机 eol 样式'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: The native eol style is implementation-dependent and may vary by platform or
    locale.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本机 eol 样式是实现相关的，可能会因平台或语言环境而异。
- en: '**syntax**: `(error-handling-mode *symbol*)`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(error-handling-mode *symbol*)`'
- en: '**returns:** `*symbol*`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*symbol*`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '`*symbol*` must be one of the symbols `ignore`, `raise`, or `replace`. The
    expression `(error-handling-mode *symbol*)` is equivalent to the expression `(quote *symbol*)`
    except that the former checks at expansion time that `*symbol*` is one of the
    error-handling-mode symbols. The `error-handling-mode` syntax provides useful
    documentation as well.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`*symbol*` 必须是 `ignore`、`raise` 或 `replace` 符号之一。表达式 `(error-handling-mode *symbol*)`
    等同于 `(quote *symbol*)`，除了前者在扩展时检查 `*symbol*` 是否为错误处理模式符号之外。`error-handling-mode`
    语法还提供了有用的文档。'
- en: '`(error-handling-mode replace) ![<graphic>](ch2_0.gif) replace'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`(error-handling-mode replace) ![<graphic>](ch2_0.gif) replace'
- en: (error-handling-mode relpace) ![<graphic>](ch2_0.gif) *syntax violation*`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`(error-handling-mode replace) ![<graphic>](ch2_0.gif) *syntax violation*`'
- en: Section 7.2\. Opening Files
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 7.2 节。打开文件
- en: The procedures in this section are used for opening file ports. Procedures for
    opening other kinds of ports, e.g., string ports or custom ports, are described
    in subsequent sections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的程序用于打开文件端口。用于打开其他类型的端口（例如字符串端口或自定义端口）的程序在随后的部分中描述。
- en: Each of the file-open operations accepts a `*path*` argument that names the
    file to be opened. It must be a string or some other implementation-dependent
    value that names a file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件打开操作都接受一个 `*path*` 参数，该参数指定要打开的文件。它必须是一个字符串或其他一些实现相关的值，指定了一个文件的名称。
- en: Some of the file-open procedures accept optional `*options*`, `*b-mode*`, and
    `*?transcoder*` arguments. `*options*` must be an enumeration set over the symbols
    constituting valid file options described in the `file-options` entry below, and
    it defaults to the value of `(file-options)`. `*b-mode*` must be a valid buffer
    mode described in the `buffer-mode` entry below, and it defaults to `block`. `*?transcoder*`
    must be a transcoder or `#f`; if it is a transcoder, the open operation returns
    a transcoded port for the underlying binary file, while if it is `#f` (the default),
    the open operation returns a binary port.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件打开程序接受可选的 `*options*`、`*b-mode*` 和 `*?transcoder*` 参数。`*options*` 必须是一个枚举集，包含了下面描述的有效文件选项符号，并且默认值为
    `(file-options)` 的值。`*b-mode*` 必须是下面描述的有效缓冲区模式，并且默认为 `block`。`*?transcoder*` 必须是一个转码器或
    `#f`；如果它是一个转码器，则打开操作返回底层二进制文件的转码端口，而如果它是 `#f`（默认值），则打开操作返回二进制端口。
- en: Binary ports created by the procedures in this section support the `port-position`
    and `set-port-position!` operations. Whether textual ports created by the procedures
    in this section support these operations is implementation-dependent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中创建的二进制端口支持 `port-position` 和 `set-port-position!` 操作。由本节中的程序创建的文本端口是否支持这些操作是依赖于实现的。
- en: '**syntax**: `(file-options *symbol* ...)`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `(file-options *symbol* ...)`'
- en: '**returns:** a file-options enumeration set'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值：** 文件选项枚举集'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`，`(rnrs)`'
- en: 'File-options enumeration sets may be passed to file-open operations to control
    aspects of the open operation. There are three standard file options: `no-create`,
    `no-fail`, and `no-truncate`, which affect only file-open operations that create
    output (including input/output) ports.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 文件选项枚举集可以传递给文件打开操作，以控制打开操作的各个方面。有三个标准文件选项：`no-create`、`no-fail` 和 `no-truncate`，它们仅影响创建输出（包括输入/输出）端口的文件打开操作。
- en: With the default file options, i.e., the value of `(file-options)`, when a program
    attempts to open a file for output, an exception is raised with condition type
    `i/o-file-already-exists` if the file already exists, and the file is created
    if it does not already exist. If the `no-fail` option is included, no exception
    is raised if the file already exists; instead, the file is opened and truncated
    to zero length. If the `no-create` option is included, the file is not created
    if it does not exist; instead, an exception is raised with condition type `i/o-file-does-not-exist`.
    The `no-create` option implies the `no-fail` option. The `no-truncate` option
    is relevant only if the `no-fail` option is included or implied, in which case
    if an existing file is opened, it is not truncated, but the port's position is
    still set to the beginning of the file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认文件选项，即 `(file-options)` 的值，在程序尝试打开文件进行输出时，如果文件已经存在，则引发 `i/o-file-already-exists`
    条件类型的异常，并且如果文件不存在，则创建该文件。如果包括 `no-fail` 选项，则如果文件已经存在，则不会引发异常；相反，文件会被打开并截断为零长度。如果包括
    `no-create` 选项，则如果文件不存在，则不会创建该文件；相反，会引发 `i/o-file-does-not-exist` 条件类型的异常。`no-create`
    选项暗示了 `no-fail` 选项。`no-truncate` 选项仅在包括或隐含了 `no-fail` 选项时相关，此时如果打开了现有文件，则不会将其截断，但端口的位置仍然设置为文件的开头。
- en: It is perhaps easier to imagine that the default file options are the imaginary
    option symbols `create`, `fail-if-exists`, and `truncate`; `no-create` removes
    `create`, `no-fail` removes `fail-if-exists`, and `no-truncate` removes `truncate`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或许更容易想象默认文件选项是虚构的选项符号 `create`、`fail-if-exists` 和 `truncate`；`no-create` 移除
    `create`，`no-fail` 移除 `fail-if-exists`，而 `no-truncate` 移除 `truncate`。
- en: Implementations may support additional file option symbols. Chez Scheme, for
    example, supports options that control whether the file is or should be compressed,
    whether it is locked for exclusive access, and what permissions are given to the
    file if it is created [[9](bibliography.html#g227)].
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可能支持其他文件选项符号。例如，Chez Scheme支持控制文件是否或应该被压缩、文件是否被锁定以进行独占访问以及如果创建文件，则给予文件什么权限的选项[[9](bibliography.html#g227)]。
- en: '**syntax**: `(buffer-mode *symbol*)`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `(buffer-mode *符号*)`'
- en: '**returns:** `*symbol*`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** `*符号*`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`, `(rnrs)`'
- en: '`*symbol*` must be one of the symbols `block`, `line`, or `none`. The expression
    `(buffer-mode *symbol*)` is equivalent to the expression `(quote *symbol*)` except
    that the former checks at expansion time that `*symbol*` is one of the buffer-mode
    symbols. The `buffer-mode` syntax provides useful documentation as well.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`*符号*`必须是`block`、`line`或`none`中的一个符号。表达式`(buffer-mode *符号*)`等价于表达式`(quote *符号*)`，但前者在扩展时检查`*符号*`是否是缓冲区模式符号之一。`buffer-mode`语法还提供了有用的文档。'
- en: '`(buffer-mode block) ![<graphic>](ch2_0.gif) block'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`(buffer-mode block) ![<图形>](ch2_0.gif) block`'
- en: (buffer-mode cushion) ![<graphic>](ch2_0.gif) *syntax violation*`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: (buffer-mode cushion) ![<图形>](ch2_0.gif) *语法违规*
- en: '**syntax**: `(buffer-mode? *obj*)`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `(buffer-mode? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a valid buffer mode, `#f` otherwise'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 如果`*obj*`是有效的缓冲区模式，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`, `(rnrs)`'
- en: '`(buffer-mode? ''block) ![<graphic>](ch2_0.gif) #t'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`(buffer-mode? ''block) ![<图形>](ch2_0.gif) #t'
- en: (buffer-mode? 'line) ![<graphic>](ch2_0.gif) #t
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (buffer-mode? 'line) ![<图形>](ch2_0.gif) #t
- en: (buffer-mode? 'none) ![<graphic>](ch2_0.gif) #t
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: (buffer-mode? 'none) ![<图形>](ch2_0.gif) #t
- en: (buffer-mode? 'something-else) ![<graphic>](ch2_0.gif) #f`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (buffer-mode? 'something-else) ![<图形>](ch2_0.gif) #f`
- en: '**procedure**: `(open-file-input-port *path*)`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-input-port *路径*)`'
- en: '**procedure**: `(open-file-input-port *path* *options*)`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-input-port *路径* *选项*)`'
- en: '**procedure**: `(open-file-input-port *path* *options* *b-mode*)`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-input-port *路径* *选项* *b-模式*)`'
- en: '**procedure**: `(open-file-input-port *path* *options* *b-mode* *?transcoder*)`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-input-port *路径* *选项* *b-模式* *?编码转换器*)`'
- en: '**returns:** a new input port for the named file'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 命名文件的新的输入端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`, `(rnrs)`'
- en: If `*?transcoder*` is present and not `#f`, it must be a transcoder, and this
    procedure returns a textual input port whose transcoder is `*?transcoder*`. Otherwise,
    this procedure returns a binary input port. See the lead-in to this section for
    a description of the constraints on and effects of the other arguments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*?编码转换器*`存在且不为`#f`，则它必须是一个编码转换器，并且此过程返回一个其编码转换器为`*?编码转换器*`的文本输入端口。否则，此过程返回一个二进制输入端口。有关其他参数的约束和效果的描述，请参阅本节的导言。
- en: '**procedure**: `(open-file-output-port *path*)`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-output-port *路径*)`'
- en: '**procedure**: `(open-file-output-port *path* *options*)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-output-port *路径* *选项*)`'
- en: '**procedure**: `(open-file-output-port *path* *options* *b-mode*)`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-output-port *路径* *选项* *b-模式*)`'
- en: '**procedure**: `(open-file-output-port *path* *options* *b-mode* *?transcoder*)`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-output-port *路径* *选项* *b-模式* *?编码转换器*)`'
- en: '**returns:** a new output port for the named file'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 命名文件的新的输出端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`, `(rnrs)`'
- en: If `*?transcoder*` is present and not `#f`, it must be a transcoder, and this
    procedure returns a textual output port whose transcoder is `*?transcoder*`. Otherwise,
    this procedure returns a binary output port. See the lead-in to this section for
    a description of the constraints on and effects of the other arguments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*?编码转换器*`存在且不为`#f`，则它必须是一个编码转换器，并且此过程返回一个其编码转换器为`*?编码转换器*`的文本输出端口。否则，此过程返回一个二进制输出端口。有关其他参数的约束和效果的描述，请参阅本节的导言。
- en: '**procedure**: `(open-file-input/output-port *path*)`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-input/output-port *路径*)`'
- en: '**procedure**: `(open-file-input/output-port *path* *options*)`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-input/output-port *路径* *选项*)`'
- en: '**procedure**: `(open-file-input/output-port *path* *options* *b-mode*)`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-input/output-port *路径* *选项* *b-模式*)`'
- en: '**procedure**: `(open-file-input/output-port *path* *options* *b-mode* *?transcoder*)`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(open-file-input/output-port *路径* *选项* *b-模式* *?编码转换器*)`'
- en: '**returns:** a new input/output port for the named file'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 命名文件的新的输入/输出端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`, `(rnrs)`'
- en: If `*?transcoder*` is present and not `#f`, it must be a transcoder, and this
    procedure returns a textual input/output port whose transcoder is `*?transcoder*`.
    Otherwise, this procedure returns a binary input/output port. See the lead-in
    to this section for a description of the constraints on and effects of the other
    arguments.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*?transcoder*`存在且不为`#f`，则必须是一个转码器，此过程返回其转码器为`*?transcoder*`的文本输入/输出端口。否则，此过程返回一个二进制输入/输出端口。有关其他参数的约束和效果的描述，请参见本节的导言。
- en: Section 7.3\. Standard Ports
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7.3节。标准端口
- en: The procedures described in this section return ports that are attached to a
    process's standard input, standard output, and standard error streams. The first
    set returns "ready-made" textual ports with implementation-dependent transcoders
    (if any) and buffer modes. The second set creates fresh binary ports and can be
    used either for binary input/output or, with the help of `transcoded-port`, for
    textual input/output with program-supplied transcoders and buffer modes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的过程返回连接到进程的标准输入、标准输出和标准错误流的端口。第一组返回具有实现相关的转码器（如果有）和缓冲模式的“现成”文本端口。第二组创建新的二进制端口，可以用于二进制输入/输出，或者借助`transcoded-port`进行文本输入/输出，使用程序提供的转码器和缓冲模式。
- en: '**procedure**: `(current-input-port)`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(current-input-port)`'
- en: '**returns:** the current input port'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 当前的输入端口'
- en: '**procedure**: `(current-output-port)`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(current-output-port)`'
- en: '**returns:** the current output port'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 当前的输出端口'
- en: '**procedure**: `(current-error-port)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(current-error-port)`'
- en: '**returns:** the current error port'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 当前的错误端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs)`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs)`'
- en: The current-input, current-output, and current-error ports return pre-built
    textual ports that are initially associated with a process's standard input, standard
    output, and standard error streams.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: current-input、current-output和current-error端口返回预先构建的文本端口，最初与进程的标准输入、标准输出和标准错误流相关联。
- en: The values returned by `current-input-port` and `current-output-port` can be
    altered temporarily by the convenience I/O procedures `with-input-from-file` and
    `with-output-to-file` (Section [7.9](io.html#g130)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`current-input-port`和`current-output-port`返回的值可以通过方便的I/O过程`with-input-from-file`和`with-output-to-file`（第[7.9](io.html#g130)节）暂时更改。'
- en: '**procedure**: `(standard-input-port)`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(standard-input-port)`'
- en: '**returns:** a fresh binary input port connected to the standard input stream'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个连接到标准输入流的新的二进制输入端口'
- en: '**procedure**: `(standard-output-port)`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(standard-output-port)`'
- en: '**returns:** a fresh binary output port connected to the standard output stream'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个连接到标准输出流的新的二进制输出端口'
- en: '**procedure**: `(standard-error-port)`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(standard-error-port)`'
- en: '**returns:** a fresh binary output port connected to the standard error stream'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个连接到标准错误流的新的二进制输出端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: Because ports may be buffered, confusion can result if operations on more than
    one port attached to one of a process's standard streams are interleaved. Thus,
    these procedures are typically appropriate only when a program no longer needs
    to use any existing ports attached to the standard streams.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为端口可能被缓冲，如果对连接到进程的标准流之一的多个端口进行交错操作，可能会导致混乱。因此，这些过程通常只适用于程序不再需要使用连接到标准流的任何现有端口时。
- en: Section 7.4\. String and Bytevector Ports
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7.4节。字符串和字节向量端口
- en: The procedures in this section allow bytevectors and strings to be used as input
    or output streams.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的过程允许字节向量和字符串用作输入或输出流。
- en: Binary ports created by the procedures in this section support the `port-position`
    and `set-port-position!` operations. Whether textual ports created by the procedures
    in this section support these operations is implementation-dependent.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的过程创建的二进制端口支持`port-position`和`set-port-position!`操作。由本节中的过程创建的文本端口是否支持这些操作取决于实现。
- en: '**procedure**: `(open-bytevector-input-port *bytevector*)`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(open-bytevector-input-port *bytevector*)`'
- en: '**procedure**: `(open-bytevector-input-port *bytevector* *?transcoder*)`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(open-bytevector-input-port *bytevector* *?transcoder*)`'
- en: '**returns:** a new input port that draws input from `*bytevector*`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个从`*bytevector*`获取输入的新的输入端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: If `*?transcoder*` is present and not `#f`, it must be a transcoder, and this
    procedure returns a textual input port whose transcoder is `*?transcoder*`. Otherwise,
    this procedure returns a binary input port.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*?transcoder*`存在且不是`#f`，它必须是一个转码器，此过程返回其转码器为`*?transcoder*`的文本输入端口。否则，此过程返回一个二进制输入端口。
- en: The effect of modifying `*bytevector*` after this procedure is called is unspecified.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此过程后修改`*bytevector*`的效果未指定。
- en: '`(let ([ip (open-bytevector-input-port #vu8(1 2))])'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([ip (open-bytevector-input-port #vu8(1 2))])'
- en: (let* ([x1 (get-u8 ip)] [x2 (get-u8 ip)] [x3 (get-u8 ip)])
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let* ([x1 (get-u8 ip)] [x2 (get-u8 ip)] [x3 (get-u8 ip)])'
- en: (list x1 x2 (eof-object? x3)))) ![<graphic>](ch2_0.gif) (1 2 #t)`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: (list x1 x2 (eof-object? x3)))) ![<graphic>](ch2_0.gif) (1 2 #t)`
- en: There is no need to close a bytevector port; it's storage will be reclaimed
    automatically when it is no longer needed, as with any other object, and an open
    bytevector port does not tie up any operating system resources.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无需关闭字节向量端口；当不再需要时，其存储将自动回收，就像任何其他对象一样，并且打开的字节向量端口不会占用任何操作系统资源。
- en: '**procedure**: `(open-string-input-port *string*)`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(open-string-input-port *string*)`'
- en: '**returns:** a new textual input port that draws input from `*string*`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：从`*string*`获取输入的新文本输入端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs io ports)`，`(rnrs)`'
- en: The effect of modifying `*string*` after this procedure is called is unspecified.
    The new port may or may not have a transcoder, and if it does, the transcoder
    is implementation-dependent. While not required, implementations are encouraged
    to support `port-position` and `set-port-position!` for string ports.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此过程后修改`*string*`的效果未指定。新端口可能有也可能没有转码器，如果有，转码器是实现相关的。虽然不是必需的，但鼓励实现支持字符串端口的`port-position`和`set-port-position!`。
- en: '`(get-line (open-string-input-port "hi.\nwhat''s up?\n")) ![<graphic>](ch2_0.gif) "hi."`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`(get-line (open-string-input-port "hi.\nwhat''s up?\n")) ![<graphic>](ch2_0.gif) "hi."`'
- en: There is no need to close a string port; it's storage will be reclaimed automatically
    when it is no longer needed, as with any other object, and an open string port
    does not tie up any operating system resources.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 无需关闭字符串端口；当不再需要时，其存储将自动回收，就像任何其他对象一样，并且打开的字符串端口不会占用任何操作系统资源。
- en: '**procedure**: `(open-bytevector-output-port)`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(open-bytevector-output-port)`'
- en: '**procedure**: `(open-bytevector-output-port *?transcoder*)`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(open-bytevector-output-port *?transcoder*)`'
- en: '**returns:** two values, a new output port and an extraction procedure'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：两个值，一个新的输出端口和一个提取过程'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs io ports)`，`(rnrs)`'
- en: If `*?transcoder*` is present and not `#f`, it must be a transcoder, and the
    port value is a textual output port whose transcoder is `*?transcoder*`. Otherwise,
    the port value is a binary output port.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*?transcoder*`存在且不是`#f`，它必须是一个转码器，端口值是其转码器为`*?transcoder*`的文本输出端口。否则，端口值是一个二进制输出端口。
- en: The extraction procedure is a procedure that, when called without arguments,
    creates a bytevector containing the accumulated bytes in the port, clears the
    port of its accumulated bytes, resets its position to zero, and returns the bytevector.
    The accumulated bytes include any bytes written beyond the end of the current
    position, if the position has been set back from its maximum extent.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 提取过程是一个过程，当无参数调用时，创建一个包含端口中累积字节的字节向量，清除端口的累积字节，将其位置重置为零，并返回字节向量。累积的字节包括任何写入超出当前位置的字节，如果位置已从其最大范围设置回来。
- en: '`(let-values ([(op g) (open-bytevector-output-port)])'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let-values ([(op g) (open-bytevector-output-port)])'
- en: (put-u8 op 15)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: (put-u8 op 15)
- en: (put-u8 op 73)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (put-u8 op 73)
- en: (put-u8 op 115)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (put-u8 op 115)
- en: (set-port-position! op 2)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (set-port-position! op 2)
- en: (let ([bv1 (g)])
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([bv1 (g)])
- en: (put-u8 op 27)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (put-u8 op 27)
- en: (list bv1 (g)))) ![<graphic>](ch2_0.gif) (#vu8(15 73 115) #vu8(27))`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (list bv1 (g)))) ![<graphic>](ch2_0.gif) (#vu8(15 73 115) #vu8(27))`
- en: There is no need to close a bytevector port; it's storage will be reclaimed
    automatically when it is no longer needed, as with any other object, and an open
    bytevector port does not tie up any operating system resources.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 无需关闭字节向量端口；当不再需要时，其存储将自动回收，就像任何其他对象一样，并且打开的字节向量端口不会占用任何操作系统资源。
- en: '**procedure**: `(open-string-output-port)`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(open-string-output-port)`'
- en: '**returns:** two values, a new textual output port and an extraction procedure'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：两个值，一个新的文本输出端口和一个提取过程'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs io ports)`，`(rnrs)`'
- en: The extraction procedure is a procedure that, when called without arguments,
    creates a string containing the accumulated characters in the port, clears the
    port of its accumulated characters, resets its position to zero, and returns the
    string. The accumulated characters include any characters written beyond the end
    of the current position, if the position has been set back from its maximum extent.
    While not required, implementations are encouraged to support `port-position`
    and `set-port-position!` for string ports.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 提取过程是一个过程，当无参数调用时，将创建一个包含端口中累积字符的字符串，清除端口的累积字符，将其位置重置为零，并返回字符串。如果位置已从其最大范围设置回来，则累积字符包括写在当前位置之外的任何字符。虽然不是必需的，但鼓励实现支持字符串端口的`port-position`和`set-port-position!`。
- en: '`(let-values ([(op g) (open-string-output-port)])'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: （让-值（（`op` `g`）（打开字符串输出端口））
- en: (put-string op "some data")
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: （放置字符串`op` "一些数据"）
- en: (let ([str1 (g)])
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: （让）`[str1]`是`g`）
- en: (put-string op "new stuff")
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: （放置字符串`op` "新东西")
- en: (list str1 (g)))) ![<graphic>](ch2_0.gif) ("some data" "new stuff")`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: （列出`str1` `g`）![<graphic>](ch2_0.gif)（"一些数据" "新东西"）
- en: There is no need to close a string port; it's storage will be reclaimed automatically
    when it is no longer needed, as with any other object, and an open string port
    does not tie up any operating system resources.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要关闭字符串端口；当不再需要时，其存储将自动回收，就像任何��他对象一样，并且打开的字符串端口不会占用任何操作系统资源。
- en: '**procedure**: `(call-with-bytevector-output-port *procedure*)`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(call-with-bytevector-output-port *procedure*)`'
- en: '**procedure**: `(call-with-bytevector-output-port *procedure* *?transcoder*)`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(call-with-bytevector-output-port *procedure* *?transcoder*)`'
- en: '**returns:** a bytevector containing the accumulated bytes'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：包含累积字节的字节向量'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`（rnrs io ports）`，`（rnrs）`'
- en: If `*?transcoder*` is present and not `#f`, it must be a transcoder, and `*procedure*`
    is called with a textual bytevector output port whose transcoder is `*?transcoder*`.
    Otherwise, `*procedure*` is called with a binary bytevector output port. If `*procedure*`
    returns, a bytevector containing the bytes accumulated in the port is created,
    the accumulated bytes are cleared from the port, the port's position is reset
    to zero, and the bytevector is returned from `call-with-bytevector-output-port`.
    These actions occur each time `*procedure*` returns, if it returns multiple times
    due to the invocation of a continuation created while `*procedure*` is active.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*?transcoder*`存在且不是`#f`，它必须是一个转码器，并且将使用带有文本字节向量输出端口的转码器`*?transcoder*`调用`*procedure*`。否则，将使用二进制字节向量输出端口调用`*procedure*`。如果`*procedure*`返回，将创建一个包含端口中累积字节的字节向量，清除端口中的累积字节，将端口位置重置为零，并从`call-with-bytevector-output-port`返回字节向量。这些操作每次`*procedure*`返回时发生，如果由于在`*procedure*`活动时创建的延续调用而多次返回。
- en: '`(let ([tx (make-transcoder (latin-1-codec) (eol-style lf)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: （让）`[tx]`（制作转码器（latin-1-codec）（eol-style lf）
- en: (error-handling-mode replace))])
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: （错误处理模式替换））]
- en: (call-with-bytevector-output-port
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (调用带字节向量输出端口的过程
- en: (lambda (p) (put-string p "abc"))
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda（p）（放置字符串`p` "abc"）
- en: tx)) ![<graphic>](ch2_0.gif) #vu8(97 98 99)`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'tx）![<graphic>](ch2_0.gif) #vu8（97 98 99）'
- en: '**procedure**: `(call-with-string-output-port *procedure*)`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(call-with-string-output-port *procedure*)`'
- en: '**returns:** a string containing the accumulated characters'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：包含累积字符的字符串'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`（rnrs io ports）`，`（rnrs）`'
- en: '`*procedure*` is called with one argument, a string output port. If `*procedure*`
    returns, a string containing the characters accumulated in the port is created,
    the accumulated characters are cleared from the port, the port''s position is
    reset to zero, and the string is returned from `call-with-string-output-port`.
    These actions occur each time `*procedure*` returns, if it returns multiple times
    due to the invocation of a continuation created while `*procedure*` is active.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`*procedure*`被调用时带有一个参数，即一个字符串输出端口。如果`*procedure*`返回，将创建一个包含端口中累积字符的字符串，清除端口中的累积字符，将端口位置重置为零，并从`call-with-string-output-port`返回字符串。这些操作每次`*procedure*`返回时发生，如果由于在`*procedure*`活动时创建的延续调用而多次返回。'
- en: '`call-with-string-output-port` can be used along with `put-datum` to define
    a procedure, `object->string`, that returns a string containing the printed representation
    of an object.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-string-output-port`可以与`put-datum`一起使用来定义一个过程`object->string`，该过程返回包含对象的打印表示的字符串。'
- en: '`(define (object->string x)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: （定义）`（object->string x）
- en: (call-with-string-output-port
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: （调用带字符串输出端口
- en: (lambda (p) (put-datum p x))))
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda（p）（放置数据`p` `x`））
- en: (object->string (cons 'a '(b c))) ![<graphic>](ch2_0.gif) "(a b c)"`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (object->string (cons 'a '(b c))) ![<graphic>](ch2_0.gif) "(a b c)"
- en: Section 7.5\. Opening Custom Ports
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7.5节。打开自定义端口
- en: '**procedure**: `(make-custom-binary-input-port *id* *r!* *gp* *sp!* *close*)`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-custom-binary-input-port *id* *r!* *gp* *sp!* *close*)`'
- en: '**returns:** a new custom binary input port'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个新的自定义二进制输入端口'
- en: '**procedure**: `(make-custom-binary-output-port *id* *w!* *gp* *sp!* *close*)`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-custom-binary-output-port *id* *w!* *gp* *sp!* *close*)`'
- en: '**returns:** a new custom binary output port'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个新的自定义二进制输出端口'
- en: '**procedure**: `(make-custom-binary-input/output-port *id* *r!* *w!* *gp* *sp!* *close*)`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-custom-binary-input/output-port *id* *r!* *w!* *gp* *sp!* *close*)`'
- en: '**returns:** a new custom binary input/output port'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个新的自定义二进制输入/输出端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: These procedures allow programs to create ports from arbitrary byte streams.
    `*id*` must be a string naming the new port; the name is used for informational
    purposes only, and an implementation may choose to include it in the printed syntax,
    if any, of a custom port. `*r!*` and `*w!*` must be procedures, while `*gp*`,
    `*sp!*`, and `*close*` must each be a procedure or `#f`. These arguments are described
    below.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程允许程序从任意字节流创建端口。`*id*`必须是一个命名新端口的字符串；该名称仅用于信息目的，并且实现可以选择在自定义端口的打印语法（如果有）中包含它。`*r!*`和`*w!*`必须是过程，而`*gp*`，`*sp!*`和`*close*`必须是过程或`#f`。下面描述了这些参数。
- en: '`*r!*`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`*r!*`'
- en: 'is called to draw input from the custom port, e.g., to support `get-u8` or
    `get-bytevector-n`. It is called with three arguments: `*bytevector*`, `*start*`,
    and `*n*`. `*start*` will be a nonnegative exact integer, `*n*` will be a positive
    exact integer, and the sum of `*start*` and `*n*` will not exceed the length of
    `*bytevector*`. If the byte stream is at end of file, `*r!*` should return exact
    0. Otherwise, it should read at least one and at most `*n*` bytes from the stream,
    store these bytes in consecutive locations of `*bytevector*` starting at `*start*`,
    and return as an exact positive integer the number of bytes actually read.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用以从自定义端口获取输入，例如，支持`get-u8`或`get-bytevector-n`。它被调用时带有三个参数：`*bytevector*`，`*start*`和`*n*`。`*start*`将是一个非负的精确整数，`*n*`将是一个正的精确整数，并且`*start*`和`*n*`的和不会超过`*bytevector*`的长度。如果字节流已到达文件末尾，`*r!*`应返回精确的0。否则，它应该从流中读取至少一个字节，最多`*n*`个字节，将这些字节存储在`*bytevector*`的连续位置中，从`*start*`开始，并返回实际读取的字节数，作为一个精确的正整数。
- en: '`*w!*`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`*w!*`'
- en: 'is called to send output to the port, e.g., to support `put-u8` or `put-bytevector`.
    It is called with three arguments: `*bytevector*`, `*start*`, and `*n*`. `*start*`
    and `*n*` will be nonnegative exact integers, and the sum of `*start*` and `*n*`
    will not exceed the length of `*bytevector*`. `*w!*` should write up to `*n*`
    consecutive bytes from `*bytevector*` starting at `*start*` and return, as an
    exact nonnegative integer, the number of bytes actually written.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用以向端口发送输出，例如，支持`put-u8`或`put-bytevector`。它被调用时带有三个参数：`*bytevector*`，`*start*`和`*n*`。`*start*`和`*n*`将是非负的精确整数，并且`*start*`和`*n*`的和不会超过`*bytevector*`的长度。`*w!*`应该从`*bytevector*`的`*start*`位置开始写入最多`*n*`个连续字节，并返回实际写入的字节数，作为一个精确的非负整数。
- en: '`*gp*`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`*gp*`'
- en: is called to query the port's position. If it is `#f`, the port will not support
    `port-position`. If it is not `#f`, it will be passed zero arguments and should
    return the current position as a displacement in bytes from the start of the byte
    stream as an exact nonnegative integer.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用以查询端口的位置。如果是`#f`，则端口不支持`port-position`。如果不是`#f`，则将传递零个参数，并应返回当前位置，作为从字节流开始的位移（以精确的非负整数表示）。
- en: '`*sp!*`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`*sp!*`'
- en: is called to set the port's position. If it is `#f`, the port will not support
    `set-port-position!`. If it is not `#f`, it will be passed one argument, an exact
    nonnegative integer representing the new position as a displacement in bytes from
    the start of the byte stream, and it should set the position to this value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用以设置端口的位置。如果是`#f`，则端口不支持`set-port-position!`。如果不是`#f`，则将传递一个参数，一个表示从字节流开始的位移的精确非负整数，它应将位置设置为此值。
- en: '`*close*`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`*close*`'
- en: is called to close the byte stream. If it is `#f`, no action will be taken to
    close the byte stream when the new port is closed. If it is not `#f`, it will
    be passed zero arguments and should take whatever actions are necessary to close
    the byte stream.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用以关闭字节流。如果是`#f`，则在关闭新端口时不会采取任何操作来关闭字节流。如果不是`#f`，则将传递零个参数，并应采取必要的操作来关闭字节流。
- en: If the new port is an input/output port and does not provide either a `*gp*`
    or `*sp!*` procedure, it may not be possible for the implementation to position
    the port properly if an output operation occurs after an input operation, due
    to input buffering that must be done to support `lookahead-u8` and is often done
    anyway for efficiency. For the same reason, a call to `port-position` after an
    input operation may not return an accurate position if the `*sp!*` procedure is
    not provided. Thus, programs that create custom binary input/output ports should
    generally provide both `*gp*` and `*sp!*` procedures.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新端口是输入/输出端口，并且没有提供`*gp*`或`*sp!*`过程，那么如果在输入操作之后发生输出操作，实现可能无法正确定位端口，因为必须进行输入缓冲以支持`lookahead-u8`，通常也为了效率而这样做。出于同样的原因，如果没有提供`*sp!*`过程，那么在输入操作之后调用`port-position`可能不会返回准确的位置。因此，通常应该为创建自定义二进制输入/输出端口的程序提供`*gp*`和`*sp!*`过程。
- en: '**procedure**: `(make-custom-textual-input-port *id* *r!* *gp* *sp!* *close*)`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-custom-textual-input-port *id* *r!* *gp* *sp!* *close*)`'
- en: '**returns:** a new custom textual input port'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：一个新的自定义文本输入端口'
- en: '**procedure**: `(make-custom-textual-output-port *id* *w!* *gp* *sp!* *close*)`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-custom-textual-output-port *id* *w!* *gp* *sp!* *close*)`'
- en: '**returns:** a new custom textual output port'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：一个新的自定义文本输出端口'
- en: '**procedure**: `(make-custom-textual-input/output-port *id* *r!* *w!* *gp* *sp!* *close*)`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-custom-textual-input/output-port *id* *r!* *w!* *gp* *sp!* *close*)`'
- en: '**returns:** a new custom textual input/output port'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：一个新的自定义文本输入/输出端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs)`'
- en: These procedures allow programs to create ports from arbitrary character streams.
    `*id*` must be a string naming the new port; the name is used for informational
    purposes only, and an implementation may choose to include it in the printed syntax,
    if any, of a custom port. `*r!*` and `*w!*` must be procedures, while `*gp*`,
    `*sp!*`, and `*close*` must each be a procedure or `#f`. These arguments are described
    below.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程允许程序从任意字符流创建端口。`*id*`必须是命名新端口的字符串；该名称仅用于信息目的，如果有的话，实现可以选择将其包含在自定义端口的打印语法中。`*r!*`和`*w!*`必须是过程，而`*gp*`，`*sp!*`和`*close*`必须是过程或`#f`。下面描述了这些参数。
- en: '`*r!*`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`*r!*`'
- en: 'is called to draw input from the port, e.g., to support `get-char` or `get-string-n`.
    It is called with three arguments: `*string*`, `*start*`, and `*n*`. `*start*`
    will be a nonnegative exact integer, `*n*` will be a positive exact integer, and
    the sum of `*start*` and `*n*` will not exceed the length of `*string*`. If the
    character stream is at end of file, `*r!*` should return exact 0. Otherwise, it
    should read at least one and at most `*n*` characters from the stream, store these
    characters in consecutive locations of `*string*` starting at `*start*`, and return
    as an exact positive integer the number of characters actually read.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从端口中提取输入，例如，支持`get-char`或`get-string-n`。它接受三个参数：`*string*`，`*start*`和`*n*`。`*start*`将是非负确切整数，`*n*`将是正确切整数，并且`*start*`和`*n*`的总和不会超过`*string*`的长度。如果字符流已到达文件末尾，`*r!*`应返回确切的0。否则，它应该从流中读取至少一个字符，最多`*n*`个字符，将这些字符存储在从`*start*`开始的`*string*`的连续位置，并返回实际读取的字符数作为确切的正整数。
- en: '`*w!*`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`*w!*`'
- en: 'is called to send output to the port, e.g., to support `put-char` or `put-string`.
    It is called with three arguments: `*string*`, `*start*`, and `*n*`. `*start*`
    and `*n*` will be nonnegative exact integers, and the sum of `*start*` and `*n*`
    will not exceed the length of `*string*`. `*w!*` should write up to `*n*` consecutive
    characters from `*string*` starting at `*start*` and return, as an exact nonnegative
    integer, the number of characters actually written.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 用于向端口发送输出，例如，支持`put-char`或`put-string`。它接受三个参数：`*string*`，`*start*`和`*n*`。`*start*`和`*n*`将是非负确切整数，并且`*start*`和`*n*`的总和不会超过`*string*`的长度。`*w!*`应该从`*start*`开始的`*string*`中写入最多`*n*`个连续字符，并返回实际写入的字符数作为确切的非负整数。
- en: '`*gp*`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`*gp*`'
- en: is called to query the port's position. If it is `#f`, the port will not support
    `port-position`. If it is not `#f`, it will be passed zero arguments and should
    return the current position, which may be an arbitrary value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 用于查询端口的位置。如果是`#f`，端口将不支持`port-position`。如果不是`#f`，将传递零个参数，并应返回当前位置，这可能是任意值。
- en: '`*sp!*`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`*sp!*`'
- en: is called to set the port's position. If it is `#f`, the port will not support
    `set-port-position!`. If it is not `#f`, it will be passed one argument, `*pos*`,
    a value representing the new position. If `*pos*` is the result of a previous
    call to `*gp*`, `*sp!*` should set the position to `*pos*`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用以设置端口的位置。如果为`#f`，则端口将不支持`set-port-position!`。如果不是`#f`，则将传递一个参数`*pos*`，表示新位置的值。如果`*pos*`是先前调用`*gp*`的结果，则`*sp!*`应将位置设置为`*pos*`。
- en: '`*close*`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`*close*`'
- en: is called to close the character stream. If it is `#f`, no action will be taken
    to close the character stream when the new port is closed. If it is not `#f`,
    it will be passed zero arguments and should take whatever actions are necessary
    to close the character stream.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用以关闭字符流。如果为`#f`，则在关闭新端口时不会执行任何操作以关闭字符流。如果不是`#f`，则将传递零个参数，并应执行必要的操作以关闭字符流。
- en: If the new port is an input/output port, it may not be possible for the implementation
    to position the port properly if an output operation occurs after an input operation,
    even if the `*gp*` and `*sp!*` procedures are provided, due to input buffering
    that must be done to support `lookahead-char` and is often done anyway for efficiency.
    Since the representations of port positions are not specified, it is not possible
    for the implementation to adjust the `*gp*` return value to account for the number
    of buffered characters. For the same reason, a call to `port-position` after an
    input operation may not return an accurate position, even if the `*sp!*` procedure
    is provided.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新端口是输入/输出端口，则在输入操作之后发生输出操作时，即使提供了`*gp*`和`*sp!*`过程，由于必须进行支持`lookahead-char`的输入缓冲，甚至为了效率而经常进行的输入缓冲，实现可能无法正确定位端口。由于端口位置的表示未指定，因此实现无法调整`*gp*`返回值以考虑缓冲字符的数量。出于同样的原因，即使提供了`*sp!*`过程，输入操作后调用`port-position`可能不会返回准确的位置。
- en: It should, however, be possible to perform output reliably after reading if
    the position is reset to the starting position. Thus, programs that create custom
    textual input/output ports should generally provide both `*gp*` and `*sp!*` procedures,
    and consumers of these ports should obtain the starting position via `port-position`
    before any input operations and reset the position back to the starting position
    before doing any output operations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果将位置重置到起始位置后，应该可以可靠地执行输出。因此，创建自定义文本输入/输出端口的程序通常应提供`*gp*`和`*sp!*`两种过程，这些端口的使用者在进行任何输入操作之前应通过`port-position`获取起始位置，并在进行任何输出操作之前将位置重置回起始位置。
- en: Section 7.6\. Port Operations
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7.6节。端口操作
- en: This section describes a variety of operations on ports that do not directly
    involve either reading from or writing to a port. The input and output operations
    are described in subsequent sections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了一系列与端口相关的操作，这些操作不直接涉及从端口读取或写入。输入和输出操作在后续章节中描述。
- en: '**procedure**: `(port? *obj*)`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(port? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a port, `#f` otherwise'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是端口，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`，`(rnrs)`'
- en: '**procedure**: `(input-port? *obj*)`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(input-port? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is an input or input/output port, `#f` otherwise'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是输入或输入/输出端口，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(output-port? *obj*)`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(output-port? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is an output or input/output port, `#f` otherwise'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是输出或输入/输出端口，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs)`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`，`(rnrs io simple)`，`(rnrs)`'
- en: '**procedure**: `(binary-port? *obj*)`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(binary-port? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a binary port, `#f` otherwise'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是二进制端口，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(textual-port? *obj*)`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(textual-port? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a textual port, `#f` otherwise'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是文本端口，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`，`(rnrs)`'
- en: '**procedure**: `(close-port *port*)`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(close-port *port*)`'
- en: '**returns:** unspecified'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 未指定'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`，`(rnrs)`'
- en: If `*port*` is not already closed, `close-port` closes it, first flushing any
    buffered bytes or characters to the underlying stream if the port is an output
    port. Once a port has been closed, no more input or output operations may be performed
    on the port. Because the operating system may place limits on the number of file
    ports open at one time or restrict access to an open file, it is good practice
    to close any file port that will no longer be used for input or output. If the
    port is an output port, closing the port explicitly also ensures that buffered
    data is written to the underlying stream. Some Scheme implementations close file
    ports automatically after they become inaccessible to the program or when the
    Scheme program exits, but it is best to close file ports explicitly whenever possible.
    Closing a port that has already been closed has no effect.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*port*`尚未关闭，`close-port`将关闭它，首先将任何缓冲的字节或字符刷新到底层流（如果端口是输出端口）。一旦关闭了端口，就无法对该端口执行更多的输入或输出操作。因为操作系统可能会对同时打开的文件端口数设置限制，或者限制对打开文件的访问，所以最好关闭任何不再用于输入或输出的文件端口。如果端口是输出端口，则显式关闭端口还确保缓冲数据被写入底层流。一些Scheme实现在程序无法访问文件端口或Scheme程序退出后会自动关闭文件端口，但最好在可能的情况下显式关闭文件端口。关闭已经关闭的端口不会产生任何效果。
- en: '**procedure**: `(transcoded-port *binary-port* *transcoder*)`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(transcoded-port *binary-port* *transcoder*)`'
- en: '**returns:** a new textual port with the same byte stream as `*binary-port*`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 具有与`*binary-port*`相同字节流的新文本端口'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`，`(rnrs)`'
- en: This procedure returns a new textual port with transcoder `*transcoder*` and
    the same underlying byte stream as `*binary-port*`, positioned at the current
    position of `*binary-port*`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程返回一个具有转码器`*transcoder*`和与`*binary-port*`相同的底层字节流的新文本端口，定位在`*binary-port*`的当前位置。
- en: As a side effect of creating the textual port, `*binary-port*` is closed to
    prevent read or write operations on `*binary-port*` from interfering with read
    and write operations on the new textual port. The underlying byte stream remains
    open, however, until the textual port is closed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创建文本端口的副作用，关闭`*binary-port*`以防止对`*binary-port*`的读写操作干扰新文本端口上的读写操作。然而，底层字节流仍然保持打开状态，直到关闭文本端口为止。
- en: '**procedure**: `(port-transcoder *port*)`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(port-transcoder *port*)`'
- en: '**returns:** the transcoder associated with `*port*` if any, `#f` otherwise'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果有的话，返回与`*port*`关联的转码器，否则返回`#f`。'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`，`(rnrs)`'
- en: This procedure always returns `#f` for binary ports and may return `#f` for
    some textual ports.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二进制端口，此过程始终返回`#f`，对于某些文本端口可能返回`#f`。
- en: '**procedure**: `(port-position *port*)`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(port-position *port*)`'
- en: '**returns:** the port''s current position'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 端口的当前位置'
- en: '**procedure**: `(port-has-port-position? *port*)`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(port-has-port-position? *port*)`'
- en: '**returns:** `#t` if the port supports `port-position`, `#f` otherwise'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果端口支持`port-position`，则返回`#t`，否则返回`#f`。'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`，`(rnrs)`'
- en: A port may allow queries to determine its current position in the underlying
    stream of bytes or characters. If so, the procedure `port-has-port-position?`
    returns `#t` and `port-position` returns the current position. For binary ports,
    the position is always an exact nonnegative integer byte displacement from the
    start of the byte stream. For textual ports, the representation of a position
    is unspecified; it may not be an exact nonnegative integer and, even if it is,
    it may not represent either a byte or character displacement in the underlying
    stream. The position may be used at some later time to reset the position if the
    port supports `set-port-position!`. If `port-position` is called on a port that
    does not support it, an exception with condition type `&assertion` is raised.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个端口可以允许查询以确定其在底层字节流或字符流中的当前位置。如果是这样，那么过程`port-has-port-position?`返回`#t`，而`port-position`返回当前位置。对于二进制端口，位置始终是从字节流的开头的精确非负整数字节偏移。对于文本端口，位置的表示未指定；它可能不是精确的非负整数，即使是，它也可能不代表底层流中的字节或字符偏移。稍后可能会使用位置重置位置，如果端口支持`set-port-position!`。如果在不支持它的端口上调用`port-position`，则会引发带有条件类型`&assertion`的异常。
- en: '**procedure**: `(set-port-position! *port* *pos*)`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(set-port-position! *port* *pos*)`'
- en: '**returns:** unspecified'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 未指定'
- en: '**procedure**: `(port-has-set-port-position!? *port*)`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(port-has-set-port-position!? *port*)`'
- en: '**returns:** `#t` if the port supports `set-port-position!`, `#f` otherwise'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果端口支持`set-port-position!`则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: A port may allow its current position to be moved directly to a different position
    in the underlying stream of bytes or characters. If so, the procedure `port-has-set-port-position!?`
    returns `#t` and `set-port-position!` changes the current position. For binary
    ports, the position `*pos*` must be an exact nonnegative integer byte displacement
    from the start of the byte stream. For textual ports, the representation of a
    position is unspecified, as described in the entry for `port-position` above,
    but `*pos*` must be an appropriate position for the textual port, which is usually
    guaranteed to be the case only if it was obtained from a call to `port-position`
    on the same port. If `set-port-position!` is called on a port that does not support
    it, an exception with condition type `&assertion` is raised.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一个端口可以允许将其当前位置直接移动到字节流或字符流的不同位置。如果是这样，过程`port-has-set-port-position!?`返回`#t`，并且`set-port-position!`改变当前位置。对于二进制端口，位置`*pos*`必须是从字节流开始的精确非负整数位移。对于文本端口，位置的表示是未指定的，如上面的`port-position`条目中所述，但`*pos*`必须是文本端口的适当位置，通常只有在从同一端口调用`port-position`时才能保证。如果在不支持的端口上调用`set-port-position!`，则会引发条件类型为`&assertion`的异常。
- en: If `*port*` is a binary output port and the position is set beyond the current
    end of the data in the underlying stream, the stream is not extended until new
    data is written at that position. If new data is written at that position, the
    contents of each intervening position is unspecified. Binary ports created with
    `open-file-output-port` and `open-file-input/output-port` can always be extended
    in this manner within the limits of the underlying operating system. In other
    cases, attempts to set the port beyond the current end of data in the underlying
    object may result in an exception with condition type `&i/o-invalid-position`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*port*`是一个二进制输出端口，并且位置设置超出了底层流中当前数据的末尾，直到在该位置写入新数据，流才会被扩展。如果在该位置写入新数据，则每个中间位置的内容是未指定的。使用`open-file-output-port`和`open-file-input/output-port`创建的二进制端口始终可以在底层操作系统的限制范围内以这种方式扩展。在其他情况下，尝试将端口设置到底层对象中当前数据的末尾可能会导致异常，条件类型为`&i/o-invalid-position`。
- en: '**procedure**: `(call-with-port *port* *procedure*)`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(call-with-port *port* *procedure*)`'
- en: '**returns:** the values returned by `*procedure*`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*procedure*`返回的值'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '`call-with-port` calls `*procedure*` with `*port*` as the only argument. If
    `*procedure*` returns, `call-with-port` closes the port and returns the values
    returned by `*procedure*`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-port`使用`*port*`作为唯一参数调用`*procedure*`。如果`*procedure*`返回，`call-with-port`关闭端口并返回`*procedure*`返回的值。'
- en: '`call-with-port` does not automatically close the port if a continuation created
    outside of `*procedure*` is invoked, since it is possible that another continuation
    created inside of `*procedure*` will be invoked at a later time, returning control
    to `*procedure*`. If `*procedure*` does not return, an implementation is free
    to close the port only if it can prove that the output port is no longer accessible.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-port` 不会在外部调用`*procedure*`时自动关闭端口，因为可能会在稍后调用在`*procedure*`内部创建的另一个续体，将控制返回给`*procedure*`。如果`*procedure*`没有返回，实现可以自由地关闭端口，只要能证明输出端口不再可访问。'
- en: The example below copies the contents of infile to outfile, overwriting outfile
    if it exists. Unless an error occurs, the ports are closed after the copy has
    been completed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例将infile的内容复制到outfile，如果outfile存在则覆盖。除非发生错误，在复制完成后关闭端口。
- en: '`(call-with-port (open-file-input-port "infile" (file-options)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-port (open-file-input-port "infile" (file-options)'
- en: (buffer-mode block) (native-transcoder))
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: (buffer-mode block) (native-transcoder))
- en: (lambda (ip)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ip)
- en: (call-with-port (open-file-output-port "outfile"
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: (call-with-port (open-file-output-port "outfile"
- en: (file-options no-fail)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: (file-options no-fail)
- en: (buffer-mode block)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: (buffer-mode block)
- en: (native-transcoder))
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: (native-transcoder))
- en: (lambda (op)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (op)
- en: (do ([c (get-char ip) (get-char ip)])
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([c (get-char ip) (get-char ip)])
- en: ((eof-object? c))
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ((eof-object? c))
- en: (put-char op c))))))`
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char op c))))))`
- en: A definition of `call-with-port` is given on page [135](control.html#defn:call-with-port).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-port`的定义在第[135](control.html#defn:call-with-port)页上。'
- en: '**procedure**: `(output-port-buffer-mode *port*)`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(output-port-buffer-mode *port*)`'
- en: '**returns:** the symbol representing the buffer mode of `*port*`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 代表`*port*`的缓冲区模式的符号'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: Section 7.7\. Input Operations
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 7.7 节 输入操作
- en: Procedures whose primary purpose is to read data from an input port are described
    in this section, along with related procedures for recognizing or creating end-of-file
    (eof) objects.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了主要目的是从输入端口读取数据的过程，以及用于识别或创建文件末尾（eof）对象的相关过程。
- en: '**procedure**: `(eof-object? *obj*)`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(eof-object? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is an eof object, `#f` otherwise'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是 eof 对象，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs)`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs)`'
- en: The end-of-file object is returned by input operations, e.g., `get-datum`, when
    an input port has reached the end of input.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 输入操作返回文件末尾对象，例如，当输入端口已达到输入末尾时，`get-datum`等。
- en: '**procedure**: `(eof-object)`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(eof-object)`'
- en: '**returns:** the eof object'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs)`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs)`'
- en: '`(eof-object? (eof-object)) ![<graphic>](ch2_0.gif) #t`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eof-object? (eof-object)) ![<graphic>](ch2_0.gif) #t`'
- en: '**procedure**: `(get-u8 *binary-input-port*)`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(get-u8 *binary-input-port*)`'
- en: '**returns:** the next byte from `*binary-input-port*`, or the eof object'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 从`*binary-input-port*`中获取下一个字节，或 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: If `*binary-input-port*` is at end of file, the eof object is returned. Otherwise,
    the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact
    unsigned integer less than or equal to 255, and the port's position is advanced
    one byte.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*binary-input-port*`在文件末尾，将返回 eof 对象。否则，下一个可用的字节将作为无符号 8 位数量返回，即小于或等于 255
    的精确无符号整数，并且端口的位置将向前移动一个字节。
- en: '**procedure**: `(lookahead-u8 *binary-input-port*)`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(lookahead-u8 *binary-input-port*)`'
- en: '**returns:** the next byte from `*binary-input-port*`, or the eof object'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 从`*binary-input-port*`中获取下一个字节，或 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: If `*binary-input-port*` is at end of file, the eof object is returned. Otherwise,
    the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact
    unsigned integer less than or equal to 255. In contrast to `get-u8`, `lookahead-u8`
    does not consume the byte it reads from the port, so if the next operation on
    the port is a call to `lookahead-u8` or `get-u8`, the same byte is returned.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*binary-input-port*`在文件末尾，将返回 eof 对象。否则，下一个可用的字节将作为无符号 8 位数量返回，即小于或等于 255
    的精确无符号整数。与`get-u8`相反，`lookahead-u8`不会消耗从端口读取的字节，因此如果端口的下一个操作是调用`lookahead-u8`或`get-u8`，则将返回相同的字节。
- en: '**procedure**: `(get-bytevector-n *binary-input-port* *n*)`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(get-bytevector-n *binary-input-port* *n*)`'
- en: '**returns:** a nonempty bytevector containing up to `*n*` bytes, or the eof
    object'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 包含最多`*n*`个字节的非空字节向量，或 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '`*n*` must be an exact nonnegative integer. If `*binary-input-port*` is at
    end of file, the eof object is returned. Otherwise, `get-bytevector-n` reads (as
    if with `get-u8`) as many bytes, up to `*n*`, as are available before the port
    is at end of file, and returns a new (nonempty) bytevector containing these bytes.
    The port''s position is advanced past the bytes read.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`*n*`必须是一个精确的非负整数。如果`*binary-input-port*`在文件末尾，将返回 eof 对象。否则，`get-bytevector-n`读取（就像使用`get-u8`一样）尽可能多的字节，最多达到`*n*`，在端口到达文件末尾之前可用，并返回一个包含这些字节的新（非空）字节向量。端口的位置将超过读取的字节。'
- en: '**procedure**: `(get-bytevector-n! *binary-input-port* *bytevector* *start* *n*)`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(get-bytevector-n! *binary-input-port* *bytevector* *start* *n*)`'
- en: '**returns:** the count of bytes read or the eof object'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 返回读取的字节数或 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '`*start*` and `*n*` must be exact nonnegative integers, and the sum of `*start*`
    and `*n*` must not exceed the length of `*bytevector*`.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`*start*`和`*n*`必须是精确的非负整数，并且`*start*`和`*n*`的总和不得超过`*bytevector*`的长度。'
- en: If `*binary-input-port*` is at end of file, the eof object is returned. Otherwise,
    `get-bytevector-n!` reads (as if with `get-u8`) as many bytes, up to `*n*`, as
    are available before the port is at end of file, stores the bytes in consecutive
    locations of `*bytevector*` starting at `*start*`, and returns the count of bytes
    read as an exact positive integer. The port's position is advanced past the bytes
    read.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*binary-input-port*`已经到达文件末尾，则返回 eof 对象。否则，`get-bytevector-n!`读取（如同使用`get-u8`）尽可能多的字节，最多达到`*n*`个，在端口到达文件末尾之前，将这些字节存储在`*bytevector*`的连续位置中，返回读取的字节数作为一个确切的正整数。端口的位置会向前移动到读取的字节之后。
- en: '**procedure**: `(get-bytevector-some *binary-input-port*)`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(get-bytevector-some *binary-input-port*)`'
- en: '**returns:** a nonempty bytevector or the eof object'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个非空的字节向量或者 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: If `*binary-input-port*` is at end of file, the eof object is returned. Otherwise,
    `get-bytevector-some` reads (as if with `get-u8`) at least one byte and possibly
    more, and returns a bytevector containing these bytes. The port's position is
    advanced past the bytes read. The maximum number of bytes read by this operation
    is implementation-dependent.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*binary-input-port*`已经到达文件末尾，则返回 eof 对象。否则，`get-bytevector-some`读取（如同使用`get-u8`）至少一个字节，可能更多，并返回包含这些字节的字节向量。端口的位置会向前移动到读取的字节之后。此操作读取的最大字节数取决于实现。
- en: '**procedure**: `(get-bytevector-all *binary-input-port*)`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(get-bytevector-all *binary-input-port*)`'
- en: '**returns:** a nonempty bytevector or the eof object'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个非空的字节向量或者 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: If `*binary-input-port*` is at end of file, the eof object is returned. Otherwise,
    `get-bytevector-all` reads (as if with `get-u8`) all of the bytes available before
    the port is at end of file and returns a bytevector containing these bytes. The
    port's position is advanced past the bytes read.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*binary-input-port*`已经到达文件末尾，则返回 eof 对象。否则，`get-bytevector-all`读取（如同使用`get-u8`）在端口到达文件末尾之前的所有可用字节，并返回包含这些字节的字节向量。端口的位置会向前移动到读取的字节之后。
- en: '**procedure**: `(get-char *textual-input-port*)`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(get-char *textual-input-port*)`'
- en: '**returns:** the next character from `*textual-input-port*`, or the eof object'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 从`*textual-input-port*`中获取下一个字符，或者返回 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: If `*textual-input-port*` is at end of file, the eof object is returned. Otherwise,
    the next available character is returned and the port's position is advanced one
    character. If `*textual-input-port*` is a transcoded port, the position in the
    underlying byte stream may advance by more than one byte.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*textual-input-port*`已经到达文件末尾，则返回 eof 对象。否则，返回下一个可用字符，并且端口的位置向前移动一个字符。如果`*textual-input-port*`是一个转码端口，则底层字节流中的位置可能会向前移动超过一个字节。
- en: '**procedure**: `(lookahead-char *textual-input-port*)`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(lookahead-char *textual-input-port*)`'
- en: '**returns:** the next character from `*textual-input-port*`, or the eof object'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 从`*textual-input-port*`中获取下一个字符，或者返回 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: If `*textual-input-port*` is at end of file, the eof object is returned. Otherwise,
    the next available character is returned. In contrast to `get-char`, `lookahead-char`
    does not consume the character it reads from the port, so if the next operation
    on the port is a call to `lookahead-char` or `get-char`, the same character is
    returned.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*textual-input-port*`已经到达文件末尾，则返回 eof 对象。否则，返回下一个可用字符。与`get-char`不同，`lookahead-char`不会消耗它从端口读取的字符，因此如果端口的下一个操作是调用`lookahead-char`或`get-char`，则会返回相同的字符。
- en: '`lookahead-char` is provided for applications requiring one character of lookahead.
    The procedure `get-word` defined below returns the next word from a textual input
    port as a string, where a word is defined to be a sequence of alphabetic characters.
    Since `get-word` does not know until it sees one character beyond the word that
    it has read the entire word, it uses `lookahead-char` to determine the next character
    and `get-char` to consume the character.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookahead-char`用于需要向前查看一个字符的应用程序。下面定义的`get-word`过程从文本输入端口中返回下一个单词作为字符串，其中一个单词被定义为一系列字母字符。由于`get-word`在看到单词之外的一个字符之前不知道它已经读取了整个单词，它使用`lookahead-char`来确定下一个字符，并使用`get-char`来消耗该字符。'
- en: '`(define get-word'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define get-word'
- en: (lambda (p)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p)
- en: (list->string
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: (list->string
- en: (let f ()
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ()
- en: (let ([c (lookahead-char p)])
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([c (lookahead-char p)])
- en: (cond
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(eof-object? c) ''()]'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eof-object? c) ''()]'
- en: '[(char-alphabetic? c) (get-char p) (cons c (f))]'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[(char-alphabetic? c) (get-char p) (cons c (f))]'
- en: '[else ''()]))))))`'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[else ''()]))))))`'
- en: '**procedure**: `(get-string-n *textual-input-port* *n*)`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a nonempty string containing up to `*n*` characters, or the eof
    object'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. If `*textual-input-port*` is at
    end of file, the eof object is returned. Otherwise, `get-string-n` reads (as if
    with `get-char`) as many characters, up to `*n*`, as are available before the
    port is at end of file, and returns a new (nonempty) string containing these characters.
    The port''s position is advanced past the characters read.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(get-string-n! *textual-input-port* *string* *start* *n*)`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the count of characters read or the eof object'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '`*start*` and `*n*` must be exact nonnegative integers, and the sum of `*start*`
    and `*n*` must not exceed the length of `*string*`.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: If `*textual-input-port*` is at end of file, the eof object is returned. Otherwise,
    `get-string-n!` reads (as if with `get-char`) as many characters, up to `*n*`,
    as are available before the port is at end of file, stores the characters in consecutive
    locations of `*string*` starting at `*start*`, and returns the count of characters
    read as an exact positive integer. The port's position is advanced past the characters
    read.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '`get-string-n!` may be used to implement `string-set!` and `string-fill!`,
    as illustrated below, although this is not its primary purpose.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string-set!'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s i c)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: (let ([sip (open-string-input-port (string c))])
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: (get-string-n! sip s i 1)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '; return unspecified values:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: (if #f #f))))
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: (define string-fill!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s c)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (string-length s)])
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: (let ([sip (open-string-input-port (make-string n c))])
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: (get-string-n! sip s 0 n)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '; return unspecified values:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: (if #f #f)))))
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-string 3)])
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: (string-fill! x #\-)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! x 2 #\))
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! x 0 #\;)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: x) ![<graphic>](ch2_0.gif) ";-)"`
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(get-string-all *textual-input-port*)`'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a nonempty string or the eof object'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: If `*textual-input-port*` is at end of file, the eof object is returned. Otherwise,
    `get-string-all` reads (as if with `get-char`) all of the characters available
    before the port is at end of file and returns a string containing these characters.
    The port's position is advanced past the characters read.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(get-line *textual-input-port*)`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string or the eof object'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: If `*textual-input-port*` is at end of file, the eof object is returned. Otherwise,
    `get-line` reads (as if with `get-char`) all of the characters available before
    the port is at end of file or a line-feed character has been read and returns
    a string containing all but the line-feed character of the characters read. The
    port's position is advanced past the characters read.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([sip (open-string-input-port "one\ntwo\n")])'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: (let* ([s1 (get-line sip)] [s2 (get-line sip)])
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: (list s1 s2 (port-eof? sip)))) ![<graphic>](ch2_0.gif) ("one" "two" #t)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: (list s1 s2 (port-eof? sip)))) ![<graphic>](ch2_0.gif) ("one" "two" #t)
- en: (let ([sip (open-string-input-port "one\ntwo")])
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([sip (open-string-input-port "one\ntwo")])
- en: (let* ([s1 (get-line sip)] [s2 (get-line sip)])
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ([s1 (get-line sip)] [s2 (get-line sip)])
- en: (list s1 s2 (port-eof? sip)))) ![<graphic>](ch2_0.gif) ("one" "two" #t)`
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: (list s1 s2 (port-eof? sip)))) ![<graphic>](ch2_0.gif) ("one" "two" #t)`
- en: '**procedure**: `(get-datum *textual-input-port*)`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(get-datum *textual-input-port*)`'
- en: '**returns:** a Scheme datum object or the eof object'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个 Scheme 数据对象或 eof 对象'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`，`(rnrs)`'
- en: This procedure scans past whitespace and comments to find the start of the external
    representation of a datum. If `*textual-input-port*` reaches end of file before
    the start of the external representation of a datum is found, the eof object is
    returned.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程扫描空白和注释，以找到数据的外部表示的开始。如果 `*textual-input-port*` 在找到数据的外部表示的开始之前到达文件末尾，则返回
    eof 对象。
- en: Otherwise, `get-datum` reads as many characters as necessary, and no more, to
    parse a single datum, and returns a newly allocated object whose structure is
    determined by the external representation. The port's position is advanced past
    the characters read. If an end-of-file is reached before the external representation
    of the datum is complete, or an unexpected character is read, an exception is
    raised with condition types `&lexical` and `i/o-read`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`get-datum` 读取尽可能多的字符，以解析单个数据，并返回一个由外部表示确定结构的新分配对象。端口的位置将在读取的字符之后前进。如果在数据的外部表示完成之前达到文件末尾，或者读取到意外字符，则会引发带有条件类型
    `&lexical` 和 `i/o-read` 的异常。
- en: '`(let ([sip (open-string-input-port "; a\n\n one (two)\n")])'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([sip (open-string-input-port "; a\n\n one (two)\n")])'
- en: (let* ([x1 (get-datum sip)]
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ([x1 (get-datum sip)]
- en: '[c1 (lookahead-char sip)]'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[c1 (lookahead-char sip)]'
- en: '[x2 (get-datum sip)])'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[x2 (get-datum sip)]) '
- en: (list x1 c1 x2 (port-eof? sip)))) ![<graphic>](ch2_0.gif) (one #\space (two) #f)`
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: (list x1 c1 x2 (port-eof? sip)))) ![<graphic>](ch2_0.gif) (one #\space (two) #f)`
- en: '**procedure**: `(port-eof? *input-port*)`'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(port-eof? *input-port*)`'
- en: '**returns:** `#t` if `*input-port*` is at end-of-file, `#f` otherwise'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 如果 `*input-port*` 处于文件末尾，则返回 `#t`，否则返回 `#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`，`(rnrs)`'
- en: This procedure is similar to `lookahead-u8` on a binary input port or `lookahead-char`
    on a textual input port, except that instead of returning the next byte/character
    or eof object, it returns a boolean value to indicate whether the value would
    be the eof object.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程类似于二进制输入端口上的 `lookahead-u8` 或文本输入端口上的 `lookahead-char`，不同之处在于它不返回下一个字节/字符或
    eof 对象，而是返回一个布尔值，指示该值是否为 eof 对象。
- en: Section 7.8\. Output Operations
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 7.8 节。输出操作
- en: Procedures whose primary purpose is to send data to an output port are described
    in this section.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目的是向输出端口发送数据的过��在本节中描述。
- en: '**procedure**: `(put-u8 *binary-output-port* *octet*)`'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(put-u8 *binary-output-port* *octet*)`'
- en: '**returns:** unspecified'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 未指定'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`，`(rnrs)`'
- en: '`*octet*` must be an exact nonnegative integer less than or equal to 255. This
    procedure writes `*octet*` to `*binary-output-port*`, advancing the port''s position
    by one byte.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`*octet*` 必须是小于或等于 255 的非负确切整数。此过程将 `*octet*` 写入 `*binary-output-port*`，将端口的位置前进一个字节。'
- en: '**procedure**: `(put-bytevector *binary-output-port* *bytevector*)`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(put-bytevector *binary-output-port* *bytevector*)`'
- en: '**procedure**: `(put-bytevector *binary-output-port* *bytevector* *start*)`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(put-bytevector *binary-output-port* *bytevector* *start*)`'
- en: '**procedure**: `(put-bytevector *binary-output-port* *bytevector* *start* *n*)`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(put-bytevector *binary-output-port* *bytevector* *start* *n*)`'
- en: '**returns:** unspecified'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 未指定'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`，`(rnrs)`'
- en: '`*start*` and `*n*` must be nonnegative exact integers, and the sum of `*start*`
    and `*n*` must not exceed the length of `*bytevector*`. If not supplied, `*start*`
    defaults to zero and `*n*` defaults to the difference between the length of `*bytevector*`
    and `*start*`.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`*start*` 和 `*n*` 必须是非负确切整数，并且 `*start*` 和 `*n*` 的总和不能超过 `*bytevector*` 的长度。如果未提供，则
    `*start*` 默认为零，`*n*` 默认为 `*bytevector*` 的长度与 `*start*` 之差。'
- en: This procedure writes the `*n*` bytes of `*bytevector*` starting at `*start*`
    to the port and advances the its position past the end of the bytes written.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将从 `*start*` 处开始的 `*bytevector*` 的 `*n*` 个字节写入端口，并将其位置移至写入字节的末尾之后。
- en: '**procedure**: `(put-char *textual-output-port* *char*)`'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(put-char *textual-output-port* *char*)`'
- en: '**returns:** unspecified'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 未指定'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: This procedure writes `*char*` to `*textual-output-port*`, advancing the port's
    position by one character. If `*textual-output-port*` is a transcoded port, the
    position in the underlying byte stream may advance by more than one byte.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将 `*char*` 写入 `*textual-output-port*`，并将端口的位置向前移动一个字符。如果 `*textual-output-port*`
    是一个转码端口，则底层字节流中的位置可能会向前移动多于一个字节。
- en: '**procedure**: `(put-string *textual-output-port* *string*)`'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(put-string *textual-output-port* *string*)`'
- en: '**procedure**: `(put-string *textual-output-port* *string* *start*)`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(put-string *textual-output-port* *string* *start*)`'
- en: '**procedure**: `(put-string *textual-output-port* *string* *start* *n*)`'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(put-string *textual-output-port* *string* *start* *n*)`'
- en: '**returns:** unspecified'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 未指定'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: '`*start*` and `*n*` must be nonnegative exact integers, and the sum of `*start*`
    and `*n*` must not exceed the length of `*string*`. If not supplied, `*start*`
    defaults to zero and `*n*` defaults to the difference between the length of `*string*`
    and `*start*`.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`*start*` 和 `*n*` 必须是非负确切整数，并且 `*start*` 和 `*n*` 的总和不能超过 `*string*` 的长度。如果未提供，则
    `*start*` 默认为零，`*n*` 默认为 `*string*` 的长度与 `*start*` 的差值。'
- en: This procedure writes the `*n*` characters of `*string*` starting at `*start*`
    to the port and advances the its position past the end of the characters written.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将从 `*start*` 开始写入 `*string*` 的 `*n*` 个字符到端口，并将其位置移至已写入字符的末尾之后。
- en: '**procedure**: `(put-datum *textual-output-port* *obj*)`'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(put-datum *textual-output-port* *obj*)`'
- en: '**returns:** unspecified'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 未指定'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: This procedure writes an external representation of `*obj*` to `*textual-output-port*`.
    If `*obj*` does not have an external representation as a datum, the behavior is
    unspecified. The precise external representation is implementation-dependent,
    but when `*obj*` does have an external representation as a datum, `put-datum`
    should produce a sequence of characters that can later be read by `get-datum`
    as an object equivalent (in the sense of `equal?`) to `*obj*`. See Section [12.5](examples.html#g176)
    for an implementation of `put-datum`, `write`, and `display`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将 `*obj*` 的外部表示写入 `*textual-output-port*`。如果 `*obj*` 没有作为数据的外部表示，行为是未指定的。精确的外部表示是依赖于实现的，但是当
    `*obj*` 确实有作为数据的外部表示时，`put-datum` 应该生成一个字符序列，稍后可以被 `get-datum` 读取为等效对象（在 `equal?`
    的意义上）为 `*obj*`。参见第[12.5](examples.html#g176)节中 `put-datum`、`write` 和 `display`
    的实现示例。
- en: '**procedure**: `(flush-output-port *output-port*)`'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(flush-output-port *output-port*)`'
- en: '**returns:** unspecified'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 未指定'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: This procedure forces any bytes or characters in the buffer associated with
    `*output-port*` to be sent immediately to the underlying stream.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程强制将与 `*output-port*` 关联的缓冲区中的任何字节或字符立即发送到底层流。
- en: Section 7.9\. Convenience I/O
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7.9节 便利I/O
- en: The procedures in this section are referred to as "convenience" I/O operators
    because they present a somewhat simplified interface for creating and interacting
    with textual ports. They also provide backward compatibility with the Revised⁵
    Report, which did not support separate binary and textual I/O.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的过程被称为“便利”I/O运算符，因为它们提供了一个相对简化的接口来创建和与文本端口交互。它们还提供了与 Revised⁵ Report 的向后兼容性，该报告不支持单独的二进制和文本I/O。
- en: The convenience input/output procedures may be called with or without an explicit
    port argument. If called without an explicit port argument, the current input
    or output port is used, as appropriate. For example, `(read-char)` and `(read-char (current-input-port))`
    both return the next character from the current input port.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 便利的输入/输出过程可以使用或不使用显式的端口参数进行调用。如果没有显式的端口参数进行调用，则使用当前的输入或输出端口，视情况而定。例如，`(read-char)`
    和 `(read-char (current-input-port))` 都会从当前输入端口返回下一个字符。
- en: '**procedure**: `(open-input-file *path*)`'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(open-input-file *path*)`'
- en: '**returns:** a new input port'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个新的输入端口'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
- en: '`*path*` must be a string or some other implementation-dependent value that
    names a file. `open-input-file` creates a new textual input port for the file
    named by `*path*`, as if by `open-file-input-port` with default options, an implementation-dependent
    buffer mode, and an implementation-dependent transcoder.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`*path*` 必须是一个字符串或其他一些依赖于实现的值，用于命名一个文件。 `open-input-file` 为名为 `*path*` 的文件创建一个新的文本输入端口，就像使用默认选项的
    `open-file-input-port`，一个依赖于实现的缓冲模式和一个依赖于实现的转码器一样。'
- en: The following shows the use of `open-input-file`, `read`, and `close-port` in
    an expression that gathers a list of objects from the file named by "myfile.ss."
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了在从名为 "myfile.ss" 的文件中收集对象列表的表达式中使用 `open-input-file`、`read` 和 `close-port`。
- en: '`(let ([p (open-input-file "myfile.ss")])'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([p (open-input-file "myfile.ss")])'
- en: (let f ([x (read p)])
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([x (read p)])
- en: (if (eof-object? x)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: (if (eof-object? x)
- en: (begin
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (close-port p)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: (close-port p)
- en: '''())'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '''())'
- en: (cons x (f (read p))))))`
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: (cons x (f (read p))))))`
- en: '**procedure**: `(open-output-file *path*)`'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(open-output-file *path*)`'
- en: '**returns:** a new output port'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个新的输出端口'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
- en: '`*path*` must be a string or some other implementation-dependent value that
    names a file. `open-output-file` creates a new output port for the file named
    by `*path*`, as if by `open-file-output-port` with default options, an implementation-dependent
    buffer mode, and an implementation-dependent transcoder.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`*path*` 必须是一个字符串或其他一些依赖于实现的值，用于命名一个文件。 `open-output-file` 为名为 `*path*` 的文件创建一个新的输出端口，就像使用默认选项的
    `open-file-output-port`，一个依赖于实现的缓冲模式和一个依赖于实现的转码器一样。'
- en: The following shows the use of `open-output-file` to write a list of objects
    (the value of `list-to-be-printed`), separated by newlines, to the file named
    by "myfile.ss."
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用 `open-output-file` 将对象列表（`list-to-be-printed` 的值）写入以换行符分隔的名为 "myfile.ss"
    的文件。
- en: '`(let ([p (open-output-file "myfile.ss")])'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([p (open-output-file "myfile.ss")])'
- en: (let f ([ls list-to-be-printed])
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([ls list-to-be-printed])
- en: (if (not (null? ls))
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: (if (not (null? ls))
- en: (begin
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (write (car ls) p)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: (write (car ls) p)
- en: (newline p)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: (newline p)
- en: (f (cdr ls)))))
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: (f (cdr ls)))))
- en: (close-port p))`
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: (close-port p))
- en: '**procedure**: `(call-with-input-file *path* *procedure*)`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(call-with-input-file *path* *procedure*)`'
- en: '**returns:** the values returned by `*procedure*`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*procedure*` 返回的值'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
- en: '`*path*` must be a string or some other implementation-dependent value that
    names a file. `*procedure*` should accept one argument.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`*path*` 必须是一个字符串或其他一些依赖于实现的值，用于命名一个文件。 `*procedure*` 应接受一个参数。'
- en: '`call-with-input-file` creates a new input port for the file named by `*path*`,
    as if with `open-input-file`, and passes this port to `*procedure*`. If `*procedure*`
    returns, `call-with-input-file` closes the input port and returns the values returned
    by `*procedure*`.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-input-file` 为名为 `*path*` 的文件创建一个新的输入端口，就像使用 `open-input-file` 一样，并将此端口传递给
    `*procedure*`。 如果 `*procedure*` 返回，`call-with-input-file` 将关闭输入端口并返回 `*procedure*`
    返回的值。'
- en: '`call-with-input-file` does not automatically close the input port if a continuation
    created outside of `*procedure*` is invoked, since it is possible that another
    continuation created inside of `*procedure*` will be invoked at a later time,
    returning control to `*procedure*`. If `*procedure*` does not return, an implementation
    is free to close the input port only if it can prove that the input port is no
    longer accessible. As shown in Section [5.6](control.html#g102), `dynamic-wind`
    may be used to ensure that the port is closed if a continuation created outside
    of `*procedure*` is invoked.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `*procedure*` 外部创建的延续被调用，`call-with-input-file` 不会自动关闭输入端口，因为可能会在以后的某个时候调用在
    `*procedure*` 内部创建的另一个延续，将控制返回给 `*procedure*`。 如果 `*procedure*` 不返回，实现可以自由地仅在能够证明输入端口不再可访问时关闭输入端口。
    如第 [5.6](control.html#g102) 节所示，`dynamic-wind` 可用于确保在调用在 `*procedure*` 外部创建的延续时关闭端口。
- en: The following example shows the use of `call-with-input-file` in an expression
    that gathers a list of objects from the file named by "myfile.ss." It is functionally
    equivalent to the example given for `open-input-file` above.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了在从名为 "myfile.ss" 的文件中收集对象列表的表达式中使用 `call-with-input-file`，其功能等同于上面给出的
    `open-input-file` 示例。
- en: '`(call-with-input-file "myfile.ss"'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-input-file "myfile.ss"'
- en: (lambda (p)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p)
- en: (let f ([x (read p)])
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([x (read p)])
- en: (if (eof-object? x)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: (if (eof-object? x)
- en: '''()'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons x (f (read p)))))))`
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: (cons x (f (read p)))))))`
- en: '`call-with-input-file` might be defined without error checking as follows.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-input-file` 可能被定义为以下不带错误检查的形式。'
- en: '`(define call-with-input-file'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define call-with-input-file'
- en: (lambda (filename proc)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (filename proc)
- en: (let ([p (open-input-file filename)])
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([p (open-input-file filename)])
- en: (let-values ([v* (proc p)])
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: (let-values ([v* (proc p)])
- en: (close-port p)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: (close-port p)
- en: (apply values v*)))))`
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: (apply values v*)))))`
- en: '**procedure**: `(call-with-output-file *path* *procedure*)`'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(call-with-output-file *path* *procedure*)`'
- en: '**returns:** the values returned by `*procedure*`'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*procedure*`返回的值'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
- en: '`*path*` must be a string or some other implementation-dependent value that
    names a file. `*procedure*` should accept one argument.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`*path*`必须是一个字符串或其他一些依赖于实现的值，用于命名文件。`*procedure*`应该接受一个参数。'
- en: '`call-with-output-file` creates a new output port for the file named by `*path*`,
    as if with `open-output-file`, and passes this port to `*procedure*`. If `*procedure*`
    returns, `call-with-output-file` closes the output port and returns the values
    returned by `*procedure*`.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-output-file` 创建一个新的输出端口，用于文件名为`*path*`，就像使用`open-output-file`一样，并将此端口传递给`*procedure*`。如果`*procedure*`返回，`call-with-output-file`关闭输出端口并返回`*procedure*`返回的值。'
- en: '`call-with-output-file` does not automatically close the output port if a continuation
    created outside of `*procedure*` is invoked, since it is possible that another
    continuation created inside of `*procedure*` will be invoked at a later time,
    returning control to `*procedure*`. If `*procedure*` does not return, an implementation
    is free to close the output port only if it can prove that the output port is
    no longer accessible. As shown in Section [5.6](control.html#g102), `dynamic-wind`
    may be used to ensure that the port is closed if a continuation created outside
    of `*procedure*` is invoked.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-output-file` 如果在`*procedure*`外部创建的延续被调用，则不会自动关闭输出端口，因为可能会在以后的某个时候调用在`*procedure*`内部创建的另一个延续，将控制返回给`*procedure*`。如果`*procedure*`不返回，实现可以自由地仅在可以证明输出端口不再可访问时关闭输出端口。如第[5.6](control.html#g102)节所示，可以使用`dynamic-wind`来确保在调用在`*procedure*`外部创建的延续时关闭端口。'
- en: The following shows the use of `call-with-output-file` to write a list of objects
    (the value of `list-to-be-printed`), separated by newlines, to the file named
    by "myfile.ss." It is functionally equivalent to the example given for `open-output-file`
    above.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了使用`call-with-output-file`将对象列表（`list-to-be-printed`的值）写入由"myfile.ss"命名的文件中，用换行符分隔。在功能上等同于上面给出的`open-output-file`示例。
- en: '`(call-with-output-file "myfile.ss"'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`(call-with-output-file "myfile.ss"'
- en: (lambda (p)
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p)
- en: (let f ([ls list-to-be-printed])
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([ls list-to-be-printed])
- en: (unless (null? ls)
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: (unless (null? ls)
- en: (write (car ls) p)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: (write (car ls) p)
- en: (newline p)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: (newline p)
- en: (f (cdr ls))))))`
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: (f (cdr ls))))))`
- en: '`call-with-output-file` might be defined without error checking as follows.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`call-with-output-file` 可能如下定义，不带错误检查。'
- en: '`(define call-with-output-file'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define call-with-output-file'
- en: (lambda (filename proc)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (filename proc)
- en: (let ([p (open-output-file filename)])
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([p (open-output-file filename)])
- en: (let-values ([v* (proc p)])
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: (let-values ([v* (proc p)])
- en: (close-port p)
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: (close-port p)
- en: (apply values v*)))))`
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: (apply values v*)))))`
- en: '**procedure**: `(with-input-from-file *path* *thunk*)`'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(with-input-from-file *path* *thunk*)`'
- en: '**returns:** the values returned by `*thunk*`'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*thunk*`返回的值'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
- en: '`*path*` must be a string or some other implementation-dependent value that
    names a file. `*thunk*` must be a procedure and should accept zero arguments.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`*path*`必须是一个字符串或其他一些依赖于实现的值，用于命名文件。`*thunk*`必须是一个过程，并且应该接受零个参数。'
- en: '`with-input-from-file` temporarily changes the current input port to be the
    result of opening the file named by `*path*`, as if with `open-input-file`, during
    the application of `*thunk*`. If `*thunk*` returns, the port is closed and the
    current input port is restored to its old value.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-input-from-file` 在应用`*thunk*`期间，临时将当前输入端口更改为打开文件名为`*path*`的文件的结果，就像使用`open-input-file`一样。如果`*thunk*`返回，端口将被关闭，并且当前输入端口将恢复到其旧值。'
- en: The behavior of `with-input-from-file` is unspecified if a continuation created
    outside of `*thunk*` is invoked before `*thunk*` returns. An implementation may
    close the port and restore the current input port to its old value---but it may
    not.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`*thunk*`返回之前调用了在`*thunk*`外部创建的延续，则`with-input-from-file`的行为是未指定的。实现可以关闭端口并将当前输入端口恢复到其旧值---但也可能不这样做。
- en: '**procedure**: `(with-output-to-file *path* *thunk*)`'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(with-output-to-file *path* *thunk*)`'
- en: '**returns:** the values returned by `*thunk*`'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*thunk*`返回的值'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
- en: '`*path*` must be a string or some other implementation-dependent value that
    names a file. `*thunk*` must be a procedure and should accept zero arguments.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '`with-output-to-file` temporarily rebinds the current output port to be the
    result of opening the file named by `*path*`, as if with `open-output-file`, during
    the application of `*thunk*`. If `*thunk*` returns, the port is closed and the
    current output port is restored to its old value.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of `with-output-to-file` is unspecified if a continuation created
    outside of `*thunk*` is invoked before `*thunk*` returns. An implementation may
    close the port and restore the current output port to its old value---but it may
    not.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(read)`'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(read *textual-input-port*)`'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a Scheme datum object or the eof object'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: If `*textual-input-port*` is not supplied, it defaults to the current input
    port. This procedure is otherwise equivalent to `get-datum`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(read-char)`'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(read-char *textual-input-port*)`'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the next character from `*textual-input-port*`'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: If `*textual-input-port*` is not supplied, it defaults to the current input
    port. This procedure is otherwise equivalent to `get-char`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(peek-char)`'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(peek-char *textual-input-port*)`'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the next character from `*textual-input-port*`'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: If `*textual-input-port*` is not supplied, it defaults to the current input
    port. This procedure is otherwise equivalent to `lookahead-char`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(write *obj*)`'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(write *obj* *textual-output-port*)`'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: If `*textual-output-port*` is not supplied, it defaults to the current output
    port. This procedure is otherwise equivalent to `put-datum`, with the arguments
    reversed. See Section [12.5](examples.html#g176) for an implementation of `put-datum`,
    `write`, and `display`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(display *obj*)`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(display *obj* *textual-output-port*)`'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: If `*textual-output-port*` is not supplied, it defaults to the current output
    port.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '`display` is similar to `write` or `put-datum` but prints strings and characters
    found within `*obj*` directly. Strings are printed without quotation marks or
    escapes for special characters, as if by `put-string`, and characters are printed
    without the `#\` notation, as if by `put-char`. With `display`, the three-element
    list `(a b c)` and the two-element list `("a b" c)` both print as `(a b c)`. Because
    of this, `display` should not be used to print objects that are intended to be
    read with `read`. `display` is useful primarily for printing messages, with `*obj*`
    most often being a string. See Section [12.5](examples.html#g176) for an implementation
    of `put-datum`, `write`, and `display`.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(write-char *char*)`'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(write-char *char*)`'
- en: '**procedure**: `(write-char *char* *textual-output-port*)`'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(write-char *char* *textual-output-port*)`'
- en: '**returns:** unspecified'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：未指定'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io simple)`，`(rnrs)`'
- en: If `*textual-output-port*` is not supplied, it defaults to the current output
    port. This procedure is otherwise equivalent to `put-char`, with the arguments
    reversed.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供`*textual-output-port*`，则默认为当前输出端口。否则，此过程等效于`put-char`，参数顺序相反。
- en: '**procedure**: `(newline)`'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(newline)`'
- en: '**procedure**: `(newline *textual-output-port*)`'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(newline *textual-output-port*)`'
- en: '**returns:** unspecified'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：未指定'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io simple)`，`(rnrs)`'
- en: If `*textual-output-port*` is not supplied, it defaults to the current output
    port. `newline` sends a line-feed character to the port.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供`*textual-output-port*`，则默认为当前输出端口。`newline`向端口发送一个换行符。
- en: '**procedure**: `(close-input-port *input-port*)`'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(close-input-port *input-port*)`'
- en: '**procedure**: `(close-output-port *output-port*)`'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(close-output-port *output-port*)`'
- en: '**returns:** unspecified'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：未指定'
- en: '**libraries:** `(rnrs io simple)`, `(rnrs)`'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io simple)`，`(rnrs)`'
- en: '`close-input-port` closes an input port, and `close-output-port` closes an
    output port. These procedures are provided for backward compatibility with the
    Revised⁵ Report; they are not actually more convenient to use than `close-port`.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`close-input-port`关闭一个输入端口，`close-output-port`关闭一个输出端口。这些过程是为了与修订⁵报告向后兼容而提供的；实际上，它们并不比`close-port`更方便使用。'
- en: Section 7.10\. Filesystem Operations
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7.10节。文件系统操作
- en: 'Scheme has two standard operations, beyond file input/output, for interacting
    with the filesystem: `file-exists?` and `delete-file`. Most implementations support
    additional operations.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme有两个标准操作，除了文件输入/输出，用于与文件系统交互：`file-exists?`和`delete-file`。大多数实现支持额外的操作。
- en: '**procedure**: `(file-exists? *path*)`'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(file-exists? *path*)`'
- en: '**returns:** `#t` if the file named by `*path*` exists, `#f` otherwise'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果由`*path*`命名的文件存在，则为`#t`，否则为`#f`'
- en: '**libraries:** `(rnrs files)`, `(rnrs)`'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs files)`，`(rnrs)`'
- en: '`*path*` must be a string or some other implementation-dependent value that
    names a file. Whether `file-exists?` follows symbolic links is unspecified.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`*path*`必须是一个字符串或其他一些特定于实现的值，用于命名一个文件。`file-exists?`是否遵循符号链接是未指定的。'
- en: '**procedure**: `(delete-file *path*)`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(delete-file *path*)`'
- en: '**returns:** unspecified'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：未指定'
- en: '**libraries:** `(rnrs files)`, `(rnrs)`'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs files)`，`(rnrs)`'
- en: '`*path*` must be a string or some other implementation-dependent value that
    names a file. `delete-file` removes the file named by `*path*` if it exists and
    can be deleted, otherwise it raises an exception with condition type `&i/o-filename`.
    Whether `delete-file` follows symbolic links is unspecified.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`*path*`必须是一个字符串或其他一些特定于实现的值，用于命名一个文件。`delete-file`如果存在并且可以删除，则删除由`*path*`命名的文件，否则引发一个带有条件类型`&i/o-filename`的异常。`delete-file`是否遵循符号链接是未指定的。'
- en: Section 7.11\. Bytevector/String Conversions
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7.11节。字节向量/字符串转换
- en: The procedures described in this section encode or decode character sequences,
    converting from strings to bytevectors or bytevectors to strings. They do not
    necessarily involve input/output, though they might be implemented using bytevector
    input and output ports.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的过程编码或解码字符序列，将字符串转换为字节向量或字节向量转换为字符串。它们不一定涉及输入/输出，尽管它们可能是使用字节向量输入和输出端口实现的。
- en: The first two procedures, `bytevector->string` and `string->bytevector`, take
    an explicit transcoder argument that determines the character encodings, eol styles,
    and error-handling modes. The others perform specific Unicode conversions with
    an implicit eol-style of `none` and error-handling mode of `replace`.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个过程，`bytevector->string`和`string->bytevector`，需要一个显式的转码器参数，确定字符编码、行尾样式和错误处理模式。其他过程执行特定的Unicode转换，隐含的行尾样式为`none`，错误处理模式为`replace`。
- en: '**procedure**: `(bytevector->string *bytevector* *transcoder*)`'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(bytevector->string *bytevector* *transcoder*)`'
- en: '**returns:** a string containing the characters encoded in `*bytevector*`'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：包含在`*bytevector*`中编码的字符的字符串'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs)`'
- en: This operation, at least in effect, creates a bytevector input port with the
    specified `*transcoder*` from which all of the available characters are read,
    as if by `get-string-all`, and placed into the output string.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作，至少在效果上，创建了一个具有指定`*transcoder*`的字节向量输入端口，从中读取所有可用的字符，就像通过`get-string-all`一样，并将其放入输出字符串中。
- en: '`(let ([tx (make-transcoder (utf-8-codec) (eol-style lf)'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: (error-handling-mode replace))])
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector->string #vu8(97 98 99) tx)) ![<graphic>](ch2_0.gif) "abc"`
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->bytevector *string* *transcoder*)`'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a bytevector containing the encodings of the characters in `*string*`'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: This operation, at least in effect, creates a bytevector output port with the
    specified `*transcoder*` to which all of the characters of `*string*` are written,
    then extracts a bytevector containing the accumulated bytes.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([tx (make-transcoder (utf-8-codec) (eol-style none)'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: (error-handling-mode raise))])
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: (string->bytevector "abc" tx)) ![<graphic>](ch2_0.gif) #vu8(97 98 99)`
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->utf8 *string*)`'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a bytevector containing the UTF-8 encoding of `*string*`'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->utf16 *string*)`'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->utf16 *string* *endianness*)`'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->utf32 *string*)`'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->utf32 *string* *endianness*)`'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a bytevector containing the specified encoding of `*string*`'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '`*endianness*` must be one of the symbols `big` or `little`. If `*endianness*`
    is not provided or is the symbol `big`, `string->utf16` returns the UTF-16BE encoding
    of `*string*` and `string->utf32` returns the UTF-32BE encoding of `*string*`.
    If `*endianness*` is the symbol `little`, `string->utf16` returns the UTF-16LE
    encoding of `*string*` and `string->utf32` returns the UTF-32LE encoding of `*string*`.
    No byte-order mark is included in the encoding.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(utf8->string *bytevector*)`'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string containing the UTF-8 decoding of `*bytevector*`'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(utf16->string *bytevector* *endianness*)`'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(utf16->string *bytevector* *endianness* *endianness-mandatory?*)`'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(utf32->string *bytevector* *endianness*)`'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(utf32->string *bytevector* *endianness* *endianness-mandatory?*)`'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string containing the specified decoding of `*bytevector*`'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '`*endianness*` must be one of the symbols `big` or `little`. These procedures
    return a UTF-16 or UTF-32 decoding of `*bytevector*`, with the endianness of the
    representation determined from the endianness argument or byte-order mark (BOM).
    If `*endianness-mandatory?*` is not provided or is `#f`, the endianness is determined
    by a BOM at the front of `*bytevector*` or, if no BOM is present, by `*endianness*`.
    If `*endianness-mandatory?*` is `#t`, the endianness is determined by `*endianness*`,
    and, if a BOM appears at the front of `*bytevector*`, it is treated as a regular
    character encoding.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: The UTF-16 BOM is the two-byte sequence `#xFE`, `#xFF` specifying "big" or the
    two-byte sequence `#xFF`, `#xFE` specifying "little." The UTF-32 BOM is the four-byte
    sequence `#x00`, `#x00`, `#xFE`, `#xFF` specifying "big" or the four-byte sequence
    `#xFF`, `#xFE`, `#x00`, `#x00` specifying "little."
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16 BOM 是指定“big”的两字节序列 `#xFE`, `#xFF` 或指定“little”的两字节序列 `#xFF`, `#xFE`。UTF-32
    BOM 是指定“big”的四字节序列 `#x00`, `#x00`, `#xFE`, `#xFF` 或指定“little”的四字节序列 `#xFF`, `#xFE`,
    `#x00`, `#x00`。
