- en: 'Chapter 9: Classes in Depth'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes In Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers TypeScript classes in more depth, including:'
  prefs: []
  type: TYPE_NORMAL
- en: More on public and private methods and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessors (Getters and Setters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using interfaces to simplify constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inheritance: Build a hierarchy of classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hiding Information: protecting your class data and methods from the outside
    world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with interfaces: Hide your implementation and enable greater levels
    of abstraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Abstract classes: Define templates with minimum standards of functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you'll see, TypeScript supports classes in mach the same way as C#, Java
    and other class oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: Public, Private and Generated JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bus example from the previous chapter shows both public and private class
    members (`SayRoute` and `myRouteNumber` respectively). You can declare both methods
    and properties as public or private. Here''s a slightly more complex example showing
    a private method and public property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a new public property, `SeatingCapacity`. Since it's public,
    client functions may both read (get) it and write (set) it. Client functions may
    not invoke the private method, `calculateRunCost`. However, the constructor is
    allowed to invoke calculateRunCost since they both belong to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Transpiled Objects and Implications Thereof
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to remember that TypeScript eventually compiles down to JavaScript.
    Let's correct the TypeScript syntax error and show the resulting JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript Bus Object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Transpiled JavaScript Bus Object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, TypeScript creates an Immediately Invoked Function Expression
    (IIFE) called Bus3 with the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Comments from TypeScript source emitted into transpiled JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function named "Bus3". This maps to the TypeScript constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two prototype methods, "SayRoute" and "calculateRunCost".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, it also shows that TypeScript can't always enforce privacy the
    same way that C# and Java can. At the end of the day, you're working with JavaScript
    and you do anything that JavaScript lets you do. This means access object properties
    using bracket notation.
  prefs: []
  type: TYPE_NORMAL
- en: Accessors (Getters and Setters)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript provides syntax to create Accessors, often called "getters" and
    "setters". These are functions that look and feel a lot like properties but are,
    in fact, functions. Client code uses them just like it uses any other property,
    Here''s a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Bus4` class defines a private property, `_mySeatingCapacity`. It defines
    a corresponding getter and setter, `SeatingCapacity`. Client code then interacts
    with SeatingCapacity as if it were a public property by setting the value to 80
    and then reading the value when logging it out to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript compiles getters and setters down to plain JavaScript "Object.DefineProperty"
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If all you want to do is wrap a public getter and setter around a private property,
    it's hardly worth the trouble^([1](#fn_1)) - and indeed can be misleading. Here's
    a more comprehensive example showing how a getter can perform a more meaningful
    calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This examples shows a getter, `CostPerRider`. When client code refers to the
    CostPerRider, it calculates a value at run-time by taking into account distance,
    cost per mile and total riders. It then returns that value.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Note Regarding Accessors and Performance*Be wary of long-running accessors.
    Some frameworks, such as Angular 1.x, use two-way binding to keep the UI in sync
    with the back end data. If you bind a field in your Angular template to a long-running
    accessor, your users won''t be wishing you a happy birthday.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Use Interfaces to Define Constructor Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, the Bus5 object''s constructor takes four numeric
    arguments as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's difficult to know what those arguments mean. Sure, intellisense helps a
    lot, but you need to hover your mouse over the code to get that context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have create an empty constructor and gone with public accessors or
    properties instead. In this case, we''d end up with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are at least two problems with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires public properties. This means that they can be changed after they've
    been initialized and that can lead to pernicious side effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you add a new public property, IDEs can't easily tell you everywhere you
    need to change the code to initialize it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the second point. Let''s say you have a non-trivial Bus management
    solution and you''re instantiating Bus objects in multiple modules in the solution.
    One day, you realize you need to model a new property, `StandardRouteTime` to
    record how long a particular bus route should take from start to finish. It''s
    easy to update the class definition and and likewise easy enough to update any
    given bit of code that creates a new instance of the bus object. However, it can
    be hard to find every place that you need to change. Interfaces help solve this,
    as shown in the following bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is better for at least three important reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Clarity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Long-term maintenance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Better information hiding
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clarity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code defines an interface, `Bus6Args`. The class constructor then takes
    an argument of type Bus6Args. This allows us to write a line of code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a lot easier to understand than:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It's immediately obvious what each of these four parameters do.
  prefs: []
  type: TYPE_NORMAL
- en: Long-term Maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall the scenario from above - complex Bus management system with many modules,
    thousands or more lines of code and many, many times when the code instantiates
    a new Bus6 object. To model a new property, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the class definition to include the new property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the constructor and class business logic to make use of the property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile all the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time you do this, the TypeScript compiler will report an error everywhere
    you've instantiated a new Bus object since all of your constructor arguments will
    be missing the new property. This gives you a comprehensive checklist of every
    place you need to account for this new property^([2](#fn_2)).
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many common software design patterns find their best implementation rooted in
    interfaces. In object oriented languages like TypeScript, C# and Java, developers
    use interfaces to abstract implementation details and to create generic functionality
    that works against a collection of seemingly disparate classes instead of individual
    named classes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, Interfaces and Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we've used interfaces to define the "shape" of data. We can also use
    interfaces to define the shape - the required properties - of a class. Let's step
    away from Buses for the moment and think instead about a product recommendation
    engine. Imagine that you have a database of clothing products such as pants, shirts,
    jackets, shoes, sneakers, etc. You've created a nice search screen that allows
    users to state a preferred color and price range. You want to iterate over all
    of your products and show anything that meets the user's preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily model these products as classes and if we''re careful about it,
    we can make sure that each class includes a `color` and `price` property. This
    would then allow us to iterate over a collection of these objects and recommend
    them based on the user''s preferences. Taking this approach, we might come up
    with a models like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the three classes has `color` and `price` and this lets us write some
    comparison logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we build up a random array of products. The code doesn't show
    it, but you can easily pretend that each object is initialized with appropriate
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The code defines a function, `Recommend` and that function iterates (via `reduce`)
    over the collection of products, extracting those that match the user's criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works well enough, but it''s really pretty awful overall. There''s an
    `any` array. It''s referencing object properties via bracket notation. If we accidentally
    put a colorless product in the allProducts array, such as bottled water, the code
    throws a runtime error or returns an undefined value. Even if we add a new product,
    such as a scarf, we need to be very careful that we follow the expected naming
    convention. This, for instance, will cause a runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It would fail because color is capitalized in the Scarf object but the `Recommend`
    function expects lower case names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid all this trouble by using interfaces to define required properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this looks a lot like the interfaces discussed earlier in the book.
    However, we can also apply interfaces to classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `implements` keyword tells TypeScript that `Scarf` objects always minimally
    define `color` and `price` properties. They can define more properties and as
    you can see, they do. However, they must at least define those two.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make other "Recommendable" objects and by doing this, we can now enjoy
    some intellisense support. Consider this refactored code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has many advantages over the earlier, non-interface style approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allRecommendableProducts` contains a collection of objects (`IRecommendable[]`)
    each of which is guaranteed to hold a `price` and `color` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we try to add another object, such as `ProductDisplay` to that collection,
    the IDE will warn us that it does not meet the interface requirements of the collection's
    objects. This means that our code can safely assume the object properties are
    present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reference the color and price properties using dot notation inside the
    reduce function. In fact, the IDE even gives helpful intellisense hints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a video showing the whole thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/97u6yaGJ1T4](https://www.youtube.com/embed/97u6yaGJ1T4)'
  prefs: []
  type: TYPE_NORMAL
- en: '(If you can''t see the video, [try clicking here](https://youtu.be/97u6yaGJ1T4)
    or type this URL into your web browser: [https://youtu.be/97u6yaGJ1T4](https://youtu.be/97u6yaGJ1T4).)'
  prefs: []
  type: TYPE_NORMAL
- en: Classes, Interfaces and Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to defining data requirements, you can define required methods.
    Let's explore this in the context of a data export. You've modeled a collection
    of products as objects and you want to allow an end user to export those products
    out to an Excel spreadsheet. Excel works great with comma separated lists, so
    if your objects can create a comma-separated version of themselves, then it's
    a piece of cake to export that out and let Excel do its magic.
  prefs: []
  type: TYPE_NORMAL
- en: This wouldn't be very hard to do in a generic way using plain JavaScript, so
    let's complicate matters a little bit by introducing a bit of security. Some objects
    contain sensitive information, such as `cost` and you want to restrict access
    to that property based on the user's role (e.g. "operator", "supervisor", "administrator").
    Lastly, we're not only worried about the `cost` property. Some products, but not
    all, are subject to inventory control measures. In these cases, rather than providing
    the product's actual inventory-on-hand, we need to show a message, "contact sales."
  prefs: []
  type: TYPE_NORMAL
- en: We *could* write a big messy CSV generator that generically iterates over object
    properties and then litter it with a bunch of if/then/else statements. Let's instead
    delegate the field level logic to the product objects themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a moderately complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the first things you''ll notice is that the code defines two interfaces:
    `StandardProduct` and `SecuredFieldsItem`. Then, both classes (Fidget and HotItem)
    implement both interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class Fidget implements StandardProduct, SecuredFieldsItem`'
  prefs: []
  type: TYPE_NORMAL
- en: Classes can implement more than one interface. All you do is define your interfaces
    as usual and then `implement` each one, separating multiple interfaces with a
    comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the `SecuredFieldItem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Classes that implement the `SecuredFieldsItem` interface must implement a method,
    `GetAllowedFieldNames`. That method must take a string input parameter and it
    must return an array of strings. In a more realistic scenario, you would probably
    pass in some kind of object representing the user as a whole, including his/her
    roles. This example uses hard coded strings to simplify things.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, GetAllowedFieldsNames has its own independent implementation
    in each class. Fidget is only concerned about users whose role is "Price Admin".
    HotItem products perform an additional check for users with the "Inventory Admin"
    role.
  prefs: []
  type: TYPE_NORMAL
- en: '`getGeneratedCsv` invokes GetAllowedFieldNames on each product. Note the function
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function getGeneratedCsv(forProducts: SecuredFieldsItem[], forRoleLabel: string)`'
  prefs: []
  type: TYPE_NORMAL
- en: It can iterate over disparate products with significantly different properties
    because they each implement the SecuredFieldsItem interface. Therefore, they will
    always have the GetAllowedFieldNames method to invoke.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the helper function `getFormattedCsvRow` generates a properly formatted
    row of comma separated data based on the current item and the allowed fields.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Java and C#, TypeScript supports hierarchical class structures. This allows
    you to incrementally build complex classes by starting with a minimal "base" class
    and then extending it to a new class. This new extended class is said to *inherit*
    the functionality of its base class. "Extend" means to add new class members (properties
    and/or methods).
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate inheritance by means of US residency models. In this case,
    "resident" means a person living permanently or temporarily in the US.
  prefs: []
  type: TYPE_NORMAL
- en: All residents have a name. They have a name irrespective of their residency
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A temporary resident is a resident with two additional properties: A country
    of origin and the date that they need to exit the country (i.e. when their visa
    expires).'
  prefs: []
  type: TYPE_NORMAL
- en: A US citizen, like a temporary resident is just a resident with some additional
    properties - the name of the city in which they were born.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this, we can infer a class hierarchy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Temporary Resident US Citizen
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s show some code. Here''s a `Resident`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This simplistic class defines a single private property, `_name`. It can only
    be set when it''s first created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It has one accessor (a getter) to retrieve the resident''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the model for a temporary resident:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This model introduces new syntax, the `extends` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This means that `TemporaryResident` shares the same members as `Resident`. In
    this case, it's both the `_name` property, as well as the Resident's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any class that extends another must always invoke the extended class'' constructor
    via a call to `super`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it doesn't need to have the same signature as the extended class.
    `TemporaryResident` takes three parameters. It passes one of those, `name`, to
    its extended class' constructor via the `super(name)` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets round out the example with one more model, a U.S. Citizen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like a `TemporaryResident`, the `USCitizen` class shares the same class
    members as `Resident`. It uses the `extend` keyword to define its parent class.
    `USCitizen`''s constructor invokes its parent class'' constructor, passing in
    the name: `super(birthCity)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a full featured video that demonstrates this in great detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/-P1uYVlYEc4](https://www.youtube.com/embed/-P1uYVlYEc4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t see the video, [try clicking this link](https://youtu.be/-P1uYVlYEc4)
    or type this URL into your web browser: [https://youtu.be/-P1uYVlYEc4](https://youtu.be/-P1uYVlYEc4)).'
  prefs: []
  type: TYPE_NORMAL
- en: Hiding and Exposing Class Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already see how the `public` keyword and `private` keyword protect or
    grant access to your class members, both properties and methods. Inheritance adds
    a small bit of complexity and enables you to control access to class members via
    public/private as well as a new data control keyword, `protected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` members may always be accessed up and down the hierarchy and from
    outside the client (i.e. client code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private` members may only be access from within the class itself. This means
    that extended classes may not access their parents'' private members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript provides a new keyword, `protected`. Protected members act like both
    public and private members. They are private to any external client code. They
    are public from their point of definition and all extended sub-classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This bit of code should help clarify matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The code sample shows:'
  prefs: []
  type: TYPE_NORMAL
- en: A class, `BaseClass`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BaseClass defines three members: `_myPrivateProperty`, `_myProtectedProperty`
    and `MyPublicProperty`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines another class, `ExtendedBaseClass`. This extends BaseClass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ExtendedBaseClass is allowed to access _myProtectedProperty and MyPublicProperty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ExtendedBaseClass *may not* access _myPrivateProperty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some client code defines a new const variable, `myExtendedBaseClass`. It holds
    a reference to an instance of ExtendedBaseClass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client code is able to access the instance's `MyPublicProperty` but is prevented
    from accessing either the private or the protected properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Abstract classes round out TypeScript''s support for hierarchies of this nature.
    An abstract class looks and feels like a standard class with a key exception:
    abstract classes may never be instantiated. If JavaScript is your first and primary
    programming language, this may seem strange. However, abstract classes, along
    with interfaces, enable developers to express many common software design patterns
    naturally and gracefully. Let''s consider an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you are a writing a game. Players place different types of military
    bases (e.g. "Army", "Navy") on a two dimensional map. Bases share some common
    features, like "name" but diverge from each other in important details. Army bases
    consist of soldiers while navy bases consist of ships. Lastly, at run-time, players
    can "activate" a base. This triggers the base to do something meaningful in the
    game. Here''s a naive way to model it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, this is pretty straight-forward. A `NaiveBase` class holds a private
    property, `_myName` and provides an get accessor to retrieve the value. Two other
    classes extend it and add their own properties: `NaiveArmyBase` and `NaiveNavyBase`.'
  prefs: []
  type: TYPE_NORMAL
- en: Both the army an navy base classes implement the `Activatable` interface, albeit
    in this example, each class' `ActiveSelf()` method simply throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a problem with this modelling approach: there''s no such thing as
    plain vanilla NaiveBase. Players never create vanilla bases, they always create
    a specific kind of base. However, there''s nothing stopping the code from doing
    that.'
  prefs: []
  type: TYPE_NORMAL
- en: There's another problem here as well. This approach forces us to implement the
    `Activatable` interface on every class. We could implement it on the base class,
    but that just compounds the first problem - now we've implemented an interface
    on a class we should never instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract classes solve this problem for us. Here''s the code re-written using
    an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This example introduces the `abstract` keyword. We now have an abstract class,
    `Base`. This abstract class implements the `Activatable` interface. In doing so,
    you can see another characteristic of TypeScript''s abstract functionality: you
    may mark classes and *class members* as abstract. (In fact, you must mark the
    class abstract if it contains any abstract members). The Activatable interface
    requires a method, `ActiveSelf`. However, this method only makes sense for "real"
    bases - army and navy bases. Hence, we mark the ActivateSelf method itself as
    abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This abstract ActivateSelf method meets the requirements of the Activatable
    interface. This is perfect since a vanilla "base" can''t meaningfully activate
    itself - only army and navy bases can do that. At the same time, it forces subclasses
    to implement the method. This is good for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You can't forget to do it since the IDE and compiler won't let you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the subclasses implement the interface, we can write code that leverages
    their type as `Activatable` where and when we need to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The abstract Base class shows another feature: Abstract classes can define
    non-abstract class members. Since every base has a name, regardless of base type,
    it makes sense to define a concrete `_myName` property and associated getter.
    Sub-classes inherit these concrete class members (properties and methods) just
    like they do with concrete classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The army and navy bases extend the abstract class just as if it were a concrete
    class using the same `extends` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapping up the example, you can see that newing up army and navy bases works
    the same way as it does in the naive example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since both types of bases implement Activatable, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put it all together in a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/ska4WEeG3pM](https://www.youtube.com/embed/ska4WEeG3pM)'
  prefs: []
  type: TYPE_NORMAL
- en: '(If you can''t view that video, [try clicking tis link](https://youtu.be/ska4WEeG3pM)
    or typing this url into your web browser: [https://youtu.be/ska4WEeG3pM](https://youtu.be/ska4WEeG3pM).)'
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I wrote a blog post that combines unions, Rest parameters and interfaces (wrapped
    inside class) that implements a general purpose logger function: [https://blog.hellojs.org/simple-javascript-logger-in-typescript-demonstrating-interfaces-union-types-and-rest-parameters-6efc5aee2c97](https://blog.hellojs.org/simple-javascript-logger-in-typescript-demonstrating-interfaces-union-types-and-rest-parameters-6efc5aee2c97)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter gave you a sip and this chapter turned on the fire hose.
  prefs: []
  type: TYPE_NORMAL
- en: Use interfaces to define both the shape of data and the shape of classes. In
    this case, "shape" means required class members (both methods and properties).
  prefs: []
  type: TYPE_NORMAL
- en: Classes *implement* interfaces. Classes may implement multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript allows you to create hierarchies. A class can *extend* another class
    and it, in turn, may be extended. A given class can only extend one other class.
  prefs: []
  type: TYPE_NORMAL
- en: A special kind of class, the *Abstract Class*, can never be instantiated but
    otherwise looks and feel the same as non-abstract classes. Abstract classes can
    (and often do) implement interfaces and they can even define concrete members
    (properties and methods).
  prefs: []
  type: TYPE_NORMAL
- en: We're nearly done with classes. The next chapter provides te final word on classes,
    as well as introducing the final bit of typing TypeScript offers - Generics.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¹. Get accessors are well-used when you want to make a property available to
    client code but you don't want to let that client code edit the value. In this
    case, you'd define a private variable paired with its own Get accessor but no
    Set accessor. Don't create a private variable and then pair it with a public getter
    *and* setter. In that case, you may as well just keep it public. [↩](#reffn_1
    "Jump back to footnote [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ². Since you're still reading at this point, it's probably safe to say that
    you're satisfied that TypeScript is pretty useful. If you're still on the fence,
    consider how you'd address this same issue with plain JavaScript. If you needed
    to make a change of this nature, it would be much more difficult to achieve given
    that you can't get the same kind of great tooling support. You can't force a syntax
    error the same way. You have to rely on global search and/or find/replace. Not
    very fun. [↩](#reffn_2 "Jump back to footnote [2] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
