- en: Network and protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network and protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving in and talking about how to use curl to get things done, let's
    take a look at what all this networking is and how it works, using simplifications
    and some minor shortcuts to give an easy overview.
  prefs: []
  type: TYPE_NORMAL
- en: The basics are in the [networking simplified](protocols-network.html) chapter
    that tries to just draw a simple picture of what networking is from a curl perspective,
    and the [protocols](protocols-protocols.html) section which explains what exactly
    a "protocol" is and how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Networking simplified
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking simplified
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Networking means communicating between two endpoints on the Internet. The Internet
    is just a bunch of interconnected machines (computers really), each using their
    own private addresses (called IP addresses). The addresses each machine have can
    be of different types and machines can even have temporary addresses. These computers
    are often called hosts.
  prefs: []
  type: TYPE_NORMAL
- en: The computer, tablet or phone you sit in front of is usually called "the client"
    and the machine out there somewhere that you want to exchange data with is called
    "the server". The main difference between the client and the server is in the
    roles they play here. There's nothing that prevents the roles from being reversed
    in a subsequent operation.
  prefs: []
  type: TYPE_NORMAL
- en: Which machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you want to initiate a transfer to one of the machines out there (a server),
    you usually don't know its IP addresses but instead you usually know its name.
    The name of the machine you will talk to is embedded in the URL that you work
    with when you use curl.
  prefs: []
  type: TYPE_NORMAL
- en: You might use a URL like "[http://example.com/index.html](http://example.com/index.html)",
    which means you will connect to and communicate with the host named example.com.
  prefs: []
  type: TYPE_NORMAL
- en: Host name resolving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we know the host name, we need to figure out which IP addresses that host
    has so that we can contact it.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the name to an IP address is often called 'name resolving'. The name
    is "resolved" to a set of addresses. This is usually done by a "DNS server", DNS
    being like a big lookup table that can convert names to addresses—all the names
    on the Internet, really. Your computer normally already knows the address of a
    computer that runs the DNS server as that is part of setting up the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'curl will therefore ask the DNS server: "Hello, please give me all the addresses
    for example.com", and the server responds with a list of them. Or in the case
    you spell the name wrong, it can answer back that the name doesn''t exist.'
  prefs: []
  type: TYPE_NORMAL
- en: Establish a connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a list of IP addresses for the host curl wants to contact, curl sends out
    a "connect request". The connection curl wants to establish is called TCP and
    it works sort of like connecting an invisible string between two computers. Once
    established, it can be used to send a stream of data in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: As curl gets a list of addresses for the host, it will actually traverse that
    list of addresses when connecting and in case one fails it will try to connect
    to the next one until either one works or they all fail.
  prefs: []
  type: TYPE_NORMAL
- en: Connects to "port numbers"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When connecting with TCP to a remote server, a client selects which port number
    to do that on. A port number is just a dedicated place for a particular service,
    which allows that same server to listen to other services on other port numbers
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Most common protocols have default port numbers that clients and servers use.
    For example, when using the "[http://example.com/index.html](http://example.com/index.html)"
    URL, that URL specifies a scheme called "http" which tells the client that it
    should try TCP port number 80 on the server by default. The URL can optionally
    provide another, custom, port number but if nothing special is specified, it will
    use the default port for the scheme used in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: TLS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the TCP connection has been established, many transfers will require that
    both sides negotiate a better security level before continuing, and that is often
    TLS; Transport Layer Security. If that is used, the client and server will do
    a TLS handshake first and only continue further if that succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Transfer data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the connecting "string" we call TCP is attached to the remote computer
    (and we have done the possible additional TLS handshake), there's an established
    connection between the two machines and that connection can then be used to exchange
    data. That communication is done using a "protocol", as discussed in the following
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The language used to ask for data to get sent—in either direction—is called
    **the protocol**. The protocol describes exactly how to ask the server for data,
    or to tell the server that there is data coming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocols are typically defined by the IETF ([Internet Engineering Task Force](http://www.ietf.org)),
    which hosts RFC documents that describe exactly how each protocol works: how clients
    and servers are supposed to act and what to send and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: What protocols does curl support?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: curl supports protocols that allow "data transfers" in either or both directions.
    We usually also restrict ourselves to protocols which have a "URI format" described
    in an RFC or at least is somewhat widely used, as curl works primarily with URLs
    (URIs really) as the input key that specifies the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest curl (as of this writing) supports these protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3,
    POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP
  prefs: []
  type: TYPE_NORMAL
- en: To complicate matters further, the protocols often exist in different versions
    or flavors as well.
  prefs: []
  type: TYPE_NORMAL
- en: What other protocols are there?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The world is full of protocols, both old and new. Old protocols get abandoned
    and dropped and new ones get introduced. There's never a state of stability but
    the situation changes from day to day and year to year. You can rest assured that
    there will be new protocols added in the list above in the future and that there
    will be new versions of the protocols already listed.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, already other protocols in existence that curl doesn't
    yet support. We are open to supporting more protocols that suit the general curl
    paradigms, we just need developers to write the necessary code adjustments for
    them.
  prefs: []
  type: TYPE_NORMAL
- en: How are protocols developed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both new versions of existing protocols and entirely new protocols are usually
    developed by persons or teams that feel that the existing ones are not good enough.
    Something about them makes them not suitable for a particular use case or perhaps
    some new idea has popped up that could be applied to improve things.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, nothing prevents anyone from developing a protocol entirely on their
    own at their own pleasure in their own backyard, but the major protocols are usually
    brought to the IETF at a fairly early stage where they are then discussed, refined,
    debated and polished and then eventually, hopefully, turned into a published RFC
    document.
  prefs: []
  type: TYPE_NORMAL
- en: Software developers then read the RFC specifications and deploy their code in
    the world based on their interpretations of the words in those documents. It sometimes
    turn out that some of the specifications are subject to vastly different interpretations
    or sometimes the engineers are just lazy and ignore sound advice in the specs
    and deploy something that doesn't adhere. Writing software that interoperates
    with other implementations of the specifications can therefore end up being hard
    work.
  prefs: []
  type: TYPE_NORMAL
- en: How much do protocols change?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like software, protocol specifications are frequently updated and new protocol
    versions are created.
  prefs: []
  type: TYPE_NORMAL
- en: Most protocols allow some level of extensibility which makes new extensions
    show up over time, extensions that make sense to support.
  prefs: []
  type: TYPE_NORMAL
- en: The interpretation of a protocol sometimes changes even if the spec remains
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: The protocols mentioned in this chapter are all "Application Protocols", which
    means they are transferred over more lower level protocols, like TCP, UDP and
    TLS. They are also themselves protocols that change over time, get new features
    and get attacked so that new ways of handling security, etc., forces curl to adapt
    and change.
  prefs: []
  type: TYPE_NORMAL
- en: About adhering to standards and who's right
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, there are protocol specs that tell us how to send and receive data
    for specific protocols. The protocol specs we follow are RFCs put together and
    published by IETF.
  prefs: []
  type: TYPE_NORMAL
- en: Some protocols are not properly documented in a final RFC, like, for example,
    SFTP for which our implementation is based on an Internet-draft that isn't even
    the last available one.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols are, however, spoken by two parties and like in any given conversation,
    there are then two sides of understanding something or interpreting the given
    instructions in a spec. Also, lots of network software is written without the
    authors paying very close attention to the spec so they end up taking some shortcuts,
    or perhaps they just interpreted the text differently. Sometimes even mistakes
    and bugs make software behave in ways that are not mandated by the spec and sometimes
    even downright forbidden in the specs.
  prefs: []
  type: TYPE_NORMAL
- en: In the curl project we use the published specs as rules on how to act until
    we learn anything else. If popular alternative implementations act differently
    than what we think the spec says and that alternative behavior is what works widely
    on the big Internet, then chances are we will change foot and instead decide to
    act like those others. If a server refuses to talk with us when we think we follow
    the spec but works fine when we bend the rules every so slightly, then we probably
    end up bending them exactly that way—if we can still work successfully with other
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, it is a personal decision and up for discussion in every case where
    we think a spec and the real world don't align.
  prefs: []
  type: TYPE_NORMAL
- en: In the worst cases we introduce options to let application developers and curl
    users have the final say on what curl should do. I say worst because it is often
    really tough to ask users to make these decisions as it usually involves very
    tricky details and weirdness going on and it is a lot to ask of users. We should
    always do our very best to avoid pushing such protocol decisions to users.
  prefs: []
  type: TYPE_NORMAL
- en: curl protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The protocols curl supports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: curl supports about 22 protocols. We say "about" because it depends on how you
    count and what you consider to be distinctly different protocols.
  prefs: []
  type: TYPE_NORMAL
- en: DICT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DICT is a dictionary network protocol, it allows clients to ask dictionary servers
    about a meaning or explanation for words. See RFC 2229\. Dict servers and clients
    use TCP port 2628.
  prefs: []
  type: TYPE_NORMAL
- en: FILE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FILE is not actually a "network" protocol. It is a URL scheme that allows you
    to tell curl to get a file from the local file system instead of getting it over
    the network from a remote server. See RFC 1738.
  prefs: []
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FTP stands for File Transfer Protocol and is an old (originates in the early
    1970s) way to transfer files back and forth between a client and a server. See
    RFC 959\. It has been extended muchly over the years. FTP servers and clients
    use TCP port 21 plus one more port, though the second one is usually dynamicly
    established during communication.
  prefs: []
  type: TYPE_NORMAL
- en: See the external page [FTP vs HTTP](https://daniel.haxx.se/docs/ftp-vs-http.html)
    for how it differs to HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: FTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FTPS stands for Secure File Transfer Protocol. It follows the tradition of appending
    an 'S' to the protocol name to signify that the protocol is done like normal FTP
    but with an added SSL/TLS security layer. See RFC 4217.
  prefs: []
  type: TYPE_NORMAL
- en: This protocol is very problematic to use through firewalls and other network
    equipments.
  prefs: []
  type: TYPE_NORMAL
- en: GOPHER
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Designed for "distributing, searching, and retrieving documents over the Internet",
    Gopher is somewhat of the grand father to HTTP as HTTP has mostly taken over completely
    for the same use cases. See RFC 1436\. Gopher servers and clients use TCP port
    70.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Hypertext Transfer Protocol, HTTP, is the most widely used protocol for
    transferring data on the web and over the Internet. See RFC 7230 for HTTP/1.1
    and RFC 7540 for HTTP/2, the successor. HTTP servers and clients use TCP port
    80.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secure HTTP is HTTP done over an SSL/TLS connection. See RFC 2818\. HTTPS servers
    and clients use TCP port 443.
  prefs: []
  type: TYPE_NORMAL
- en: IMAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Internet Message Access Protocol, IMAP, is a protocol for accessing, controlling
    and "reading" email. See RFC 3501\. IMAP servers and clients use TCP port 143.
  prefs: []
  type: TYPE_NORMAL
- en: IMAPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secure IMAP is IMAP done over an SSL/TLS connection. Such connections usually
    start out as a "normal" IMAP connection that is then upgraded to IMAPS using the
    `STARTTLS` command.
  prefs: []
  type: TYPE_NORMAL
- en: LDAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Lightweight Directory Access Protocol, LDAP, is a protocol for accessing
    and maintaining distributed directory information. Basically a database lookup.
    See RFC 4511\. LDAP servers and clients use TCP port 389.
  prefs: []
  type: TYPE_NORMAL
- en: LDAPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secure LDAP is LDAP done over an SSL/TLS connection.
  prefs: []
  type: TYPE_NORMAL
- en: POP3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Post Office Protocol version 3 (POP3) is a protocol for retrieving email
    from a server. See RFC 1939\. POP3 servers and clients use TCP port 110.
  prefs: []
  type: TYPE_NORMAL
- en: POP3S
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secure POP3 is POP3 done over an SSL/TLS connection. Such connections usually
    start out as a "normal" POP3 connection that is then upgraded to POP3S using the
    `STARTTLS` command.
  prefs: []
  type: TYPE_NORMAL
- en: RTMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Real-Time Messaging Protocol (RTMP) is a protocol for streaming audio, video
    and data. RTMP servers and clients use TCP port 1935.
  prefs: []
  type: TYPE_NORMAL
- en: RTSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Real Time Streaming Protocol (RTSP) is a network control protocol to control
    streaming media servers. See RFC 2326\. RTSP servers and clients use TCP and UDP
    port 554.
  prefs: []
  type: TYPE_NORMAL
- en: SCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Secure Copy (SCP) protocol is designed to copy files to and from a remote
    SSH server. SCP servers and clients use TCP port 22.
  prefs: []
  type: TYPE_NORMAL
- en: SFTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSH File Transfer Protocol (SFTP) that provides file access, file transfer,
    and file management over a reliable data stream. SFTP servers and clients use
    TCP port 22.
  prefs: []
  type: TYPE_NORMAL
- en: SMB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Server Message Block (SMB) protocol is also known as CIFS. It is a an application-layer
    network protocol mainly used for providing shared access to files, printers, and
    serial ports and miscellaneous communications between nodes on a network. SMB
    servers and clients use TCP port 485.
  prefs: []
  type: TYPE_NORMAL
- en: SMTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Simple Mail Transfer Protocol (SMTP) is a protocol for email transmission.
    See RFC 821\. SMTP servers and clients use TCP port 25.
  prefs: []
  type: TYPE_NORMAL
- en: SMTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secure SMTP is SMTP done over an SSL/TLS connection. Such connections usually
    start out as a "normal" SMTP connection that is then upgraded to SMTPS using the
    `STARTTLS` command.
  prefs: []
  type: TYPE_NORMAL
- en: TELNET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TELNET is an application layer protocol used over networks to provide a bidirectional
    interactive text-oriented communication facility using a virtual terminal connection.
    See RFC 854\. TELNET servers and clients use TCP port 23.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Trivial File Transfer Protocol (TFTP) is a protocol for doing simple file
    transfers over UDP to get a file from or put a file onto a remote host. TFTP servers
    and clients use UDP port 69.
  prefs: []
  type: TYPE_NORMAL
