["```\n\n```", "```\n\n### Some Advice for Working on Exercises:\n\n*   Most of the Coq proofs we ask you to do are similar to proofs that we've provided. Before starting to work on exercises problems, take the time to work through our proofs (both informally, on paper, and in Coq) and make sure you understand them in detail. This will save you a lot of time. \n\n*   The Coq proofs we're doing now are sufficiently complicated that it is more or less impossible to complete them simply by random experimentation or \"following your nose.\" You need to start with an idea about why the property is true and how the proof is going to go. The best way to do this is to write out at least a sketch of an informal proof on paper \u2014 one that intuitively convinces you of the truth of the theorem \u2014 before starting to work on the formal one. Alternately, grab a friend and try to convince them that the theorem is true; then try to formalize your explanation. \n\n*   Use automation to save work! The proofs in this chapter's exercises can get pretty long if you try to write out all the cases explicitly.\n\n```", "```\n\n## Definitions\n\n    For aexps and bexps with variables, the definition we want is\n    clear.  We say that two aexps or bexps are *behaviorally equivalent* if they evaluate to the same result in every state.\n\n```", "```\n\n    Here are some simple examples of equivalences of arithmetic\n    and boolean expressions.\n\n```", "```\n\n    For commands, the situation is a little more subtle.  We can't\n    simply say \"two commands are behaviorally equivalent if they\n    evaluate to the same ending state whenever they are started in the\n    same initial state,\" because some commands, when run in some\n    starting states, don't terminate in any final state at all!  What\n    we need instead is this: two commands are behaviorally equivalent\n    if, for any given starting state, they either (1) both diverge\n    or (2) both terminate in the same final state.  A compact way to\n    express this is \"if the first one terminates in a particular state\n    then so does the second, and vice versa.\"\n\n```", "```\n\n## Simple Examples\n\n    For examples of command equivalence, let's start by looking at\n    some trivial program transformations involving SKIP:\n\n```", "```\n\n#### Exercise: 2 stars (skip_right)\n\n    Prove that adding a SKIP after a command results in an\n    equivalent program\n\n```", "```\n\n    \u2610 \n\n    Similarly, here is a simple transformation that optimizes IFB\n    commands:\n\n```", "```\n\n    Of course, few programmers would be tempted to write a conditional\n    whose guard is literally BTrue.  A more interesting case is when\n    the guard is *equivalent* to true:  *Theorem*: If b is equivalent to BTrue, then IFB b THEN c[1] ELSE c[2] FI is equivalent to c[1]. \n\n    *Proof*:\n\n*   (\u2192) We must show, for all st and st', that if IFB b THEN c[1] ELSE c[2] FI / st \u21d3 st' then c[1] / st \u21d3 st'. \n\n     Proceed by cases on the rules that could possibly have been used to show IFB b THEN c[1] ELSE c[2] FI / st \u21d3 st', namely E_IfTrue and E_IfFalse. \n\n    *   Suppose the final rule rule in the derivation of IFB b THEN c[1] ELSE c[2] FI / st \u21d3 st' was E_IfTrue. We then have, by the premises of E_IfTrue, that c[1] / st \u21d3 st'. This is exactly what we set out to prove. \n\n    *   On the other hand, suppose the final rule in the derivation of IFB b THEN c[1] ELSE c[2] FI / st \u21d3 st' was E_IfFalse. We then know that beval st b = false and c[2] / st \u21d3 st'. \n\n         Recall that b is equivalent to BTrue, i.e., forall st, beval st b = beval st BTrue. In particular, this means that beval st b = true, since beval st BTrue = true. But this is a contradiction, since E_IfFalse requires that beval st b = false. Thus, the final rule could not have been E_IfFalse. \n\n*   (\u2190) We must show, for all st and st', that if c[1] / st \u21d3 st' then IFB b THEN c[1] ELSE c[2] FI / st \u21d3 st'. \n\n     Since b is equivalent to BTrue, we know that beval st b = beval st BTrue = true. Together with the assumption that c[1] / st \u21d3 st', we can apply E_IfTrue to derive IFB b THEN c[1] ELSE c[2] FI / st \u21d3 st'. \u2610\n\n    Here is the formal version of this proof:\n\n```", "```\n\n#### Exercise: 2 stars, recommended (IFB_false)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars (swap_if_branches)\n\n    Show that we can swap the branches of an IF if we also negate its\n    guard.\n\n```", "```\n\n    \u2610 \n\n    For WHILE loops, we can give a similar pair of theorems.  A loop\n    whose guard is equivalent to BFalse is equivalent to SKIP,\n    while a loop whose guard is equivalent to BTrue is equivalent to\n    WHILE BTrue DO SKIP END (or any other non-terminating program).\n    The first of these facts is easy.\n\n```", "```\n\n#### Exercise: 2 stars, advanced, optional (WHILE_false_informal)\n\n    Write an informal proof of WHILE_false.\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n    To prove the second fact, we need an auxiliary lemma stating that\n    WHILE loops whose guards are equivalent to BTrue never\n    terminate. \n\n    *Lemma*: If b is equivalent to BTrue, then it cannot be the\n    case that (WHILE b DO c END) / st \u21d3 st'.\n\n    *Proof*: Suppose that (WHILE b DO c END) / st \u21d3 st'.  We show,\n    by induction on a derivation of (WHILE b DO c END) / st \u21d3 st',\n    that this assumption leads to a contradiction.\n\n*   Suppose (WHILE b DO c END) / st \u21d3 st' is proved using rule E_WhileEnd. Then by assumption beval st b = false. But this contradicts the assumption that b is equivalent to BTrue. \n\n*   Suppose (WHILE b DO c END) / st \u21d3 st' is proved using rule E_WhileLoop. Then we are given the induction hypothesis that (WHILE b DO c END) / st \u21d3 st' is contradictory, which is exactly what we are trying to prove! \n\n*   Since these are the only rules that could have been used to prove (WHILE b DO c END) / st \u21d3 st', the other cases of the induction are immediately contradictory. \u2610\n\n```", "```\n\n#### Exercise: 2 stars, optional (WHILE_true_nonterm_informal)\n\n    Explain what the lemma WHILE_true_nonterm means in English.\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 stars, recommended (WHILE_true)\n\n    Prove the following theorem. *Hint*: You'll want to use\n    WHILE_true_nonterm here.\n\n```", "```\n\n    \u2610 \n\n    A more interesting fact about WHILE commands is that any finite\n    number of copies of the body can be \"unrolled\" without changing\n    meaning.  Unrolling is a common transformation in real compilers.\n\n```", "```\n\n#### Exercise: 2 stars, optional (seq_assoc)\n\n```", "```\n\n    \u2610 \n\n    Proving program properties involving assignments is one place\n    where the Functional Extensionality axiom often comes in handy.\n\n```", "```\n\n#### Exercise: 2 stars, recommended (assign_aequiv)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars (equiv_classes)\n\n    Given the following programs, group together those that are\n    equivalent in Imp. Your answer should be given as a list of lists,\n    where each sub-list represents a group of equivalent programs. For\n    example, if you think programs (a) through (h) are all equivalent\n    to each other, but not to (i), your answer should look like this:\n\n```", "```\nDefinition prog_a : com :=\n\u00a0\u00a0WHILE BNot (BLe (AId X) (ANum 0)) DO\n\u00a0\u00a0\u00a0\u00a0X ::= APlus (AId X) (ANum 1)\n\u00a0\u00a0END.\n\nDefinition prog_b : com :=\n\u00a0\u00a0IFB BEq (AId X) (ANum 0) THEN\n\u00a0\u00a0\u00a0\u00a0X ::= APlus (AId X) (ANum 1);;\n\u00a0\u00a0\u00a0\u00a0Y ::= ANum 1\n\u00a0\u00a0ELSE\n\u00a0\u00a0\u00a0\u00a0Y ::= ANum 0\n\u00a0\u00a0FI;;\n\u00a0\u00a0X ::= AMinus (AId X) (AId Y);;\n\u00a0\u00a0Y ::= ANum 0.\n\nDefinition prog_c : com :=\n\u00a0\u00a0SKIP.\n\nDefinition prog_d : com :=\n\u00a0\u00a0WHILE BNot (BEq (AId X) (ANum 0)) DO\n\u00a0\u00a0\u00a0\u00a0X ::= APlus (AMult (AId X) (AId Y)) (ANum 1)\n\u00a0\u00a0END.\n\nDefinition prog_e : com :=\n\u00a0\u00a0Y ::= ANum 0.\n\nDefinition prog_f : com :=\n\u00a0\u00a0Y ::= APlus (AId X) (ANum 1);;\n\u00a0\u00a0WHILE BNot (BEq (AId X) (AId Y)) DO\n\u00a0\u00a0\u00a0\u00a0Y ::= APlus (AId X) (ANum 1)\n\u00a0\u00a0END.\n\nDefinition prog_g : com :=\n\u00a0\u00a0WHILE BTrue DO\n\u00a0\u00a0\u00a0\u00a0SKIP\n\u00a0\u00a0END.\n\nDefinition prog_h : com :=\n\u00a0\u00a0WHILE BNot (BEq (AId X) (AId X)) DO\n\u00a0\u00a0\u00a0\u00a0X ::= APlus (AId X) (ANum 1)\n\u00a0\u00a0END.\n\nDefinition prog_i : com :=\n\u00a0\u00a0WHILE BNot (BEq (AId X) (AId Y)) DO\n\u00a0\u00a0\u00a0\u00a0X ::= APlus (AId Y) (ANum 1)\n\u00a0\u00a0END.\n\nDefinition equiv_classes : list (list com)\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\n```", "```\n\n# Properties of Behavioral Equivalence\n\n    We next consider some fundamental properties of the program\n    equivalence relations.\n\n```", "```\nLemma refl_aequiv : \u2200(a : aexp), aequiv a a.\n\n    Proof.\n\u00a0\u00a0intros a st. reflexivity. Qed.\n\nLemma sym_aequiv : \u2200(a[1] a[2] : aexp),\n\u00a0\u00a0aequiv a[1] a[2] \u2192 aequiv a[2] a[1].\n\n    Proof.\n\u00a0\u00a0intros a[1] a[2] H. intros st. symmetry. apply H. Qed.\n\nLemma trans_aequiv : \u2200(a[1] a[2] a[3] : aexp),\n\u00a0\u00a0aequiv a[1] a[2] \u2192 aequiv a[2] a[3] \u2192 aequiv a[1] a[3].\n\n    Proof.\n\u00a0\u00a0unfold [aequiv](Equiv.html#aequiv). intros a[1] a[2] a[3] H[12] H[23] st.\n\u00a0\u00a0rewrite (H[12] st). rewrite (H[23] st). reflexivity. Qed.\n\nLemma refl_bequiv : \u2200(b : bexp), bequiv b b.\n\n    Proof.\n\u00a0\u00a0unfold [bequiv](Equiv.html#bequiv). intros b st. reflexivity. Qed.\n\nLemma sym_bequiv : \u2200(b[1] b[2] : bexp),\n\u00a0\u00a0bequiv b[1] b[2] \u2192 bequiv b[2] b[1].\n\n    Proof.\n\u00a0\u00a0unfold [bequiv](Equiv.html#bequiv). intros b[1] b[2] H. intros st. symmetry. apply H. Qed.\n\nLemma trans_bequiv : \u2200(b[1] b[2] b[3] : bexp),\n\u00a0\u00a0bequiv b[1] b[2] \u2192 bequiv b[2] b[3] \u2192 bequiv b[1] b[3].\n\n    Proof.\n\u00a0\u00a0unfold [bequiv](Equiv.html#bequiv). intros b[1] b[2] b[3] H[12] H[23] st.\n\u00a0\u00a0rewrite (H[12] st). rewrite (H[23] st). reflexivity. Qed.\n\nLemma refl_cequiv : \u2200(c : com), cequiv c c.\n\n    Proof.\n\u00a0\u00a0unfold [cequiv](Equiv.html#cequiv). intros c st st'. apply [iff_refl](http://coq.inria.fr/library/Coq.Init.Logic.html#iff_refl). Qed.\n\nLemma sym_cequiv : \u2200(c[1] c[2] : com),\n\u00a0\u00a0cequiv c[1] c[2] \u2192 cequiv c[2] c[1].\n\n    Proof.\n\u00a0\u00a0unfold [cequiv](Equiv.html#cequiv). intros c[1] c[2] H st st'.\n\u00a0\u00a0assert (c[1] / st \u21d3 st' \u2194 c[2] / st \u21d3 st') as H'.\n\u00a0\u00a0{ (*\u00a0Proof\u00a0of\u00a0assertion\u00a0*) apply H. }\n\u00a0\u00a0apply [iff_sym](http://coq.inria.fr/library/Coq.Init.Logic.html#iff_sym). assumption.\n    Qed.\n\nLemma iff_trans : \u2200(P[1] P[2] P[3] : Prop),\n\u00a0\u00a0(P[1] \u2194 P[2]) \u2192 (P[2] \u2194 P[3]) \u2192 (P[1] \u2194 P[3]).\n\n    Proof.\n\u00a0\u00a0intros P[1] P[2] P[3] H[12] H[23].\n\u00a0\u00a0inversion H[12]. inversion H[23].\n\u00a0\u00a0split; intros A.\n\u00a0\u00a0\u00a0\u00a0apply H[1]. apply H. apply A.\n\u00a0\u00a0\u00a0\u00a0apply H[0]. apply H[2]. apply A. Qed.\n\nLemma trans_cequiv : \u2200(c[1] c[2] c[3] : com),\n\u00a0\u00a0cequiv c[1] c[2] \u2192 cequiv c[2] c[3] \u2192 cequiv c[1] c[3].\n\n    Proof.\n\u00a0\u00a0unfold [cequiv](Equiv.html#cequiv). intros c[1] c[2] c[3] H[12] H[23] st st'.\n\u00a0\u00a0apply [iff_trans](Equiv.html#iff_trans) with (c[2] / st \u21d3 st'). apply H[12]. apply H[23]. Qed.\n\n```", "```\nTheorem CAss_congruence : \u2200i a[1] a[1]',\n\u00a0\u00a0aequiv a[1] a[1]' \u2192\n\u00a0\u00a0cequiv (CAss i a[1]) (CAss i a[1]').\n\n    Proof.\n\u00a0\u00a0intros i a[1] a[2] Heqv st st'.\n\u00a0\u00a0split; intros Hceval.\n\u00a0\u00a0- (*\u00a0->\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion Hceval. subst. apply [E_Ass](Imp.html#E_Ass).\n\u00a0\u00a0\u00a0\u00a0rewrite Heqv. reflexivity.\n\u00a0\u00a0- (*\u00a0<-\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion Hceval. subst. apply [E_Ass](Imp.html#E_Ass).\n\u00a0\u00a0\u00a0\u00a0rewrite Heqv. reflexivity. Qed.\n\n```", "```\nTheorem CWhile_congruence : \u2200b[1] b[1]' c[1] c[1]',\n\u00a0\u00a0bequiv b[1] b[1]' \u2192 cequiv c[1] c[1]' \u2192\n\u00a0\u00a0cequiv (WHILE b[1] DO c[1] END) (WHILE b[1]' DO c[1]' END).\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0unfold bequiv,cequiv.\n\u00a0\u00a0intros b[1] b[1]' c[1] c[1]' Hb1e Hc1e st st'.\n\u00a0\u00a0split; intros Hce.\n\u00a0\u00a0- (*\u00a0->\u00a0*)\n\u00a0\u00a0\u00a0\u00a0remember (WHILE b[1] DO c[1] END) as cwhile\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eqn:Heqcwhile.\n\u00a0\u00a0\u00a0\u00a0induction Hce; inversion Heqcwhile; subst.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0E_WhileEnd\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_WhileEnd. rewrite \u2190 Hb1e. apply H.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0E_WhileLoop\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_WhileLoop with (st' := st').\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0show\u00a0loop\u00a0runs\u00a0*) rewrite \u2190 Hb1e. apply H.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0body\u00a0execution\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply (Hc1e st st'). apply Hce1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0subsequent\u00a0loop\u00a0execution\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHHce2. reflexivity.\n\u00a0\u00a0- (*\u00a0<-\u00a0*)\n\u00a0\u00a0\u00a0\u00a0remember (WHILE b[1]' DO c[1]' END) as c'while\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eqn:Heqc'while.\n\u00a0\u00a0\u00a0\u00a0induction Hce; inversion Heqc'while; subst.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0E_WhileEnd\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_WhileEnd. rewrite \u2192 Hb1e. apply H.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0E_WhileLoop\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_WhileLoop with (st' := st').\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0show\u00a0loop\u00a0runs\u00a0*) rewrite \u2192 Hb1e. apply H.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0body\u00a0execution\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply (Hc1e st st'). apply Hce1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0subsequent\u00a0loop\u00a0execution\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHHce2. reflexivity. Qed.\n\n```", "```\nTheorem CSeq_congruence : \u2200c[1] c[1]' c[2] c[2]',\n\u00a0\u00a0cequiv c[1] c[1]' \u2192 cequiv c[2] c[2]' \u2192\n\u00a0\u00a0cequiv (c[1];;c[2]) (c[1]';;c[2]').\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem CIf_congruence : \u2200b b' c[1] c[1]' c[2] c[2]',\n\u00a0\u00a0bequiv b b' \u2192 cequiv c[1] c[1]' \u2192 cequiv c[2] c[2]' \u2192\n\u00a0\u00a0cequiv (IFB b THEN c[1] ELSE c[2] FI)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(IFB b' THEN c[1]' ELSE c[2]' FI).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nExample congruence_example:\n\u00a0\u00a0cequiv\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Program\u00a01:\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(X ::= ANum 0;;\n\u00a0\u00a0\u00a0\u00a0\u00a0IFB (BEq (AId X) (ANum 0))\n\u00a0\u00a0\u00a0\u00a0\u00a0THEN\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y ::= ANum 0\n\u00a0\u00a0\u00a0\u00a0\u00a0ELSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y ::= ANum 42\n\u00a0\u00a0\u00a0\u00a0\u00a0FI)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Program\u00a02:\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(X ::= ANum 0;;\n\u00a0\u00a0\u00a0\u00a0\u00a0IFB (BEq (AId X) (ANum 0))\n\u00a0\u00a0\u00a0\u00a0\u00a0THEN\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y ::= AMinus (AId X) (AId X)   (*\u00a0<---\u00a0changed\u00a0here\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0ELSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y ::= ANum 42\n\u00a0\u00a0\u00a0\u00a0\u00a0FI).\nProof.\n\u00a0\u00a0apply CSeq_congruence.\n\u00a0\u00a0\u00a0\u00a0apply refl_cequiv.\n\u00a0\u00a0\u00a0\u00a0apply CIf_congruence.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply refl_bequiv.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply CAss_congruence. unfold aequiv. simpl.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0symmetry. apply minus_diag.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply refl_cequiv.\nQed.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n# Program Transformations\n\n    A *program transformation* is a function that takes a program as\n    input and produces some variant of the program as output.\n    Compiler optimizations such as constant folding are a canonical\n    example, but there are many others. \n\n    A program transformation is *sound* if it preserves the\n    behavior of the original program.\n\n```", "```\n\n## The Constant-Folding Transformation\n\n    An expression is *constant* when it contains no variable\n    references.\n\n    Constant folding is an optimization that finds constant\n    expressions and replaces them by their values.\n\n```", "```\n\n    Note that this version of constant folding doesn't eliminate\n    trivial additions, etc. \u2014 we are focusing attention on a single\n    optimization for the sake of simplicity.  It is not hard to\n    incorporate other ways of simplifying expressions; the definitions\n    and proofs just get longer.\n\n```", "```\n\n    Not only can we lift fold_constants_aexp to bexps (in the\n    BEq and BLe cases); we can also look for constant *boolean*\n    expressions and evaluate them in-place.\n\n```", "```\n\n    To fold constants in a command, we apply the appropriate folding\n    functions on all embedded expressions.\n\n```", "```\n\n## Soundness of Constant Folding\n\n    Now we need to show that what we've done is correct. \n\n    Here's the proof for arithmetic expressions:\n\n```", "```\n\n#### Exercise: 3 stars, optional (fold_bexp_Eq_informal)\n\n    Here is an informal proof of the BEq case of the soundness\n    argument for boolean expression constant folding.  Read it\n    carefully and compare it to the formal proof that follows.  Then\n    fill in the BLe case of the formal proof (without looking at the\n    BEq case, if possible).\n\n    *Theorem*: The constant folding function for booleans,\n   fold_constants_bexp, is sound.\n\n    *Proof*: We must show that b is equivalent to fold_constants_bexp,\n   for all boolean expressions b.  Proceed by induction on b.  We\n   show just the case where b has the form BEq a[1] a[2].\n\n    In this case, we must show\n\n```", "```\n    \u00a0\u00a0\u00a0\u00a0fold_constants_bexp\u00a0(BEq\u00a0a[1]\u00a0a[2])\n    \u00a0\u00a0=\u00a0if\u00a0beq_nat\u00a0n[1]\u00a0n[2]\u00a0then\u00a0BTrue\u00a0else\u00a0BFalse\n\n     and \n\n    ```", "```\n    \u00a0\u00a0\u00a0\u00a0aeval\u00a0st\u00a0a[1]\n    \u00a0\u00a0=\u00a0aeval\u00a0st\u00a0(fold_constants_aexp\u00a0a[1])\n    \u00a0\u00a0=\u00a0aeval\u00a0st\u00a0(ANum\u00a0n[1])\n    \u00a0\u00a0=\u00a0n[1]\n\n     and \n\n    ```", "```\n    \u00a0\u00a0\u00a0\u00a0beval\u00a0st\u00a0(BEq\u00a0a[1]\u00a0a[2])\n    \u00a0\u00a0=\u00a0beq_nat\u00a0(aeval\u00a0a[1])\u00a0(aeval\u00a0a[2])\n    \u00a0\u00a0=\u00a0beq_nat\u00a0n[1]\u00a0n[2].\n\n     Also, it is easy to see (by considering the cases n[1] = n[2] and n[1] \u2260 n[2] separately) that \n\n    ```", "```\n    \u00a0\u00a0\u00a0\u00a0beval\u00a0st\u00a0(BEq\u00a0a[1]\u00a0a[2])\n    \u00a0\u00a0=\u00a0beq_nat\u00a0n[1]\u00a0n[2].\n    \u00a0\u00a0=\u00a0beval\u00a0st\u00a0(if\u00a0beq_nat\u00a0n[1]\u00a0n[2]\u00a0then\u00a0BTrue\u00a0else\u00a0BFalse),\n\n     as required. \n\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n    \u00a0\u00a0\u00a0\u00a0beval\u00a0st\u00a0(BEq\u00a0a[1]\u00a0a[2])\n    \u00a0\u00a0=\u00a0beval\u00a0st\u00a0(BEq\u00a0(fold_constants_aexp\u00a0a[1])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(fold_constants_aexp\u00a0a[2])),\n\n     which, by the definition of beval, is the same as showing \n\n    ```", "```\n    \u00a0\u00a0aeval\u00a0st\u00a0a[1]\u00a0=\u00a0aeval\u00a0st\u00a0(fold_constants_aexp\u00a0a[1])\n    \u00a0\u00a0aeval\u00a0st\u00a0a[2]\u00a0=\u00a0aeval\u00a0st\u00a0(fold_constants_aexp\u00a0a[2]),\n\n     completing the case. \u2610\n    ```", "```\n\n    ```", "```\nTheorem fold_constants_bexp_sound:\n\u00a0\u00a0btrans_sound fold_constants_bexp.\nProof.\n\u00a0\u00a0unfold btrans_sound. intros b. unfold bequiv. intros st.\n\u00a0\u00a0induction b;\n\u00a0\u00a0\u00a0\u00a0(*\u00a0BTrue\u00a0and\u00a0BFalse\u00a0are\u00a0immediate\u00a0*)\n\u00a0\u00a0\u00a0\u00a0try reflexivity.\n\u00a0\u00a0- (*\u00a0BEq\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rename a into a[1]. rename a[0] into a[2]. simpl.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0remember (fold_constants_aexp a[1]) as a[1]' eqn:Heqa1'.\n\u00a0\u00a0\u00a0\u00a0remember (fold_constants_aexp a[2]) as a[2]' eqn:Heqa2'.\n\u00a0\u00a0\u00a0\u00a0replace (aeval st a[1]) with (aeval st a[1]') by\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(subst a[1]'; rewrite \u2190 fold_constants_aexp_sound; reflexivity).\n\u00a0\u00a0\u00a0\u00a0replace (aeval st a[2]) with (aeval st a[2]') by\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(subst a[2]'; rewrite \u2190 fold_constants_aexp_sound; reflexivity).\n\u00a0\u00a0\u00a0\u00a0destruct a[1]'; destruct a[2]'; try reflexivity.\n\n\u00a0\u00a0\u00a0\u00a0(*\u00a0The\u00a0only\u00a0interesting\u00a0case\u00a0is\u00a0when\u00a0both\u00a0a[1]\u00a0and\u00a0a[2] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0become\u00a0constants\u00a0after\u00a0folding\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl. destruct (beq_nat n n[0]); reflexivity.\n\u00a0\u00a0- (*\u00a0BLe\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\n\u00a0\u00a0- (*\u00a0BNot\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. remember (fold_constants_bexp b) as b' eqn:Heqb'.\n\u00a0\u00a0\u00a0\u00a0rewrite IHb.\n\u00a0\u00a0\u00a0\u00a0destruct b'; reflexivity.\n\u00a0\u00a0- (*\u00a0BAnd\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl.\n\u00a0\u00a0\u00a0\u00a0remember (fold_constants_bexp b[1]) as b[1]' eqn:Heqb1'.\n\u00a0\u00a0\u00a0\u00a0remember (fold_constants_bexp b[2]) as b[2]' eqn:Heqb2'.\n\u00a0\u00a0\u00a0\u00a0rewrite IHb1. rewrite IHb2.\n\u00a0\u00a0\u00a0\u00a0destruct b[1]'; destruct b[2]'; reflexivity.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem fold_constants_com_sound :\n\u00a0\u00a0ctrans_sound fold_constants_com.\nProof.\n\u00a0\u00a0unfold ctrans_sound. intros c.\n\u00a0\u00a0induction c; simpl.\n\u00a0\u00a0- (*\u00a0SKIP\u00a0*) apply refl_cequiv.\n\u00a0\u00a0- (*\u00a0::=\u00a0*) apply CAss_congruence.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply fold_constants_aexp_sound.\n\u00a0\u00a0- (*\u00a0;;\u00a0*) apply CSeq_congruence; assumption.\n\u00a0\u00a0- (*\u00a0IFB\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (bequiv b (fold_constants_bexp b)). {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply fold_constants_bexp_sound. }\n\u00a0\u00a0\u00a0\u00a0destruct (fold_constants_bexp b) eqn:Heqb;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try (apply CIf_congruence; assumption).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(*\u00a0(If\u00a0the\u00a0optimization\u00a0doesn't\u00a0eliminate\u00a0the\u00a0if,\u00a0then\u00a0the \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result\u00a0is\u00a0easy\u00a0to\u00a0prove\u00a0from\u00a0the\u00a0IH\u00a0and \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fold_constants_bexp_sound.)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0always\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply trans_cequiv with c[1]; try assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IFB_true; assumption.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0always\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply trans_cequiv with c[2]; try assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IFB_false; assumption.\n\u00a0\u00a0- (*\u00a0WHILE\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n### Soundness of (0 + n) Elimination, Redux\n\n#### Exercise: 4 stars, advanced, optional (optimize_0plus)\n\n    Recall the definition optimize_0plus from the [Imp](Imp.html) chapter:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0optimize_0plus_aexp\n\u00a0\u00a0\u00a0\u00a0\u00a0optimize_0plus_bexp\n\u00a0\u00a0\u00a0\u00a0\u00a0optimize_0plus_com\n\n    Prove that these three functions are sound, as we did for\n   fold_constants_*.  Make sure you use the congruence lemmas in\n   the proof of optimize_0plus_com \u2014 otherwise it will be *long*!\n\n    Then define an optimizer on commands that first folds\n   constants (using fold_constants_com) and then eliminates 0 + n\n   terms (using optimize_0plus_com).\n\n*   Give a meaningful example of this optimizer's output. \n\n*   Prove that the optimizer is sound. (This part should be *very* easy.)\n\n```", "```\n\n    \u2610\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1]\u00a0\u00a0=\u00a0\u00a0(X\u00a0::=\u00a042\u00a0+\u00a053;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a0X)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[2]\u00a0\u00a0=\u00a0\u00a0(X\u00a0::=\u00a042\u00a0+\u00a053;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a0(42\u00a0+\u00a053))\n\n    Clearly, this *particular* c[1] and c[2] are equivalent.  Is this\n    true in general? \n\n    We will see in a moment that it is not, but it is worthwhile\n    to pause, now, and see if you can find a counter-example on your\n    own. \n\n    More formally, here is the function that substitutes an arithmetic\n    expression for each occurrence of a given variable in another\n    expression:\n\n```", "```\n\n    And here is the property we are interested in, expressing the\n    claim that commands c[1] and c[2] as described above are\n    always equivalent.\n\n```", "```\n\n    Sadly, the property does *not* always hold \u2014 i.e., it is not the\n    case that, for all i[1], i[2], a[1], and a[2],\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cequiv\u00a0(i[1]\u00a0::=\u00a0a[1];;\u00a0i[2]\u00a0::=\u00a0a[2])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(i[1]\u00a0::=\u00a0a[1];;\u00a0i[2]\u00a0::=\u00a0subst_aexp\u00a0i[1]\u00a0a[1]\u00a0a[2]).\n\n    Consider the following program:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(X\u00a0::=\u00a0APlus\u00a0(AId\u00a0X)\u00a0(ANum\u00a01);;\u00a0Y\u00a0::=\u00a0AId\u00a0X)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0empty_state\u00a0\u21d3\u00a0st[1],\n\n    where st[1] = { X \u21a6 1, Y \u21a6 1 }.\n\n    By assumption, we know that\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(X\u00a0::=\u00a0APlus\u00a0(AId\u00a0X)\u00a0(ANum\u00a01);;\u00a0Y\u00a0::=\u00a0APlus\u00a0(AId\u00a0X)\u00a0(ANum\u00a01))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0empty_state\u00a0\u21d3\u00a0st[1].\n\n    But we can also derive\n\n```", "```\nTheorem subst_inequiv :\n\u00a0\u00a0\u00ac subst_equiv_property.\n\n    Proof.\n\u00a0\u00a0unfold [subst_equiv_property](Equiv.html#subst_equiv_property).\n\u00a0\u00a0intros Contra.\n\n\u00a0\u00a0(*\u00a0Here\u00a0is\u00a0the\u00a0counterexample:\u00a0assuming\u00a0that\u00a0subst_equiv_property \u00a0\u00a0\u00a0\u00a0\u00a0holds\u00a0allows\u00a0us\u00a0to\u00a0prove\u00a0that\u00a0these\u00a0two\u00a0programs\u00a0are \u00a0\u00a0\u00a0\u00a0\u00a0equivalent...\u00a0*)\n\u00a0\u00a0remember ([X](Imp.html#X) ::= [APlus](Imp.html#APlus) ([AId](Imp.html#AId) [X](Imp.html#X)) ([ANum](Imp.html#ANum) 1);;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Y](Imp.html#Y) ::= [AId](Imp.html#AId) [X](Imp.html#X))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0as c[1].\n\u00a0\u00a0remember ([X](Imp.html#X) ::= [APlus](Imp.html#APlus) ([AId](Imp.html#AId) [X](Imp.html#X)) ([ANum](Imp.html#ANum) 1);;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Y](Imp.html#Y) ::= [APlus](Imp.html#APlus) ([AId](Imp.html#AId) [X](Imp.html#X)) ([ANum](Imp.html#ANum) 1))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0as c[2].\n\u00a0\u00a0assert ([cequiv](Equiv.html#cequiv) c[1] c[2]) by (subst; apply Contra).\n\n\u00a0\u00a0(*\u00a0...\u00a0allows\u00a0us\u00a0to\u00a0show\u00a0that\u00a0the\u00a0command\u00a0c[2]\u00a0can\u00a0terminate \u00a0\u00a0\u00a0\u00a0\u00a0in\u00a0two\u00a0different\u00a0final\u00a0states: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st[1]\u00a0=\u00a0{X\u00a0|->\u00a01,\u00a0Y\u00a0|->\u00a01} \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st[2]\u00a0=\u00a0{X\u00a0|->\u00a01,\u00a0Y\u00a0|->\u00a02}.\u00a0*)\n\u00a0\u00a0remember ([t_update](Maps.html#t_update) ([t_update](Maps.html#t_update) [empty_state](Imp.html#empty_state) [X](Imp.html#X) 1) [Y](Imp.html#Y) 1) as st[1].\n\u00a0\u00a0remember ([t_update](Maps.html#t_update) ([t_update](Maps.html#t_update) [empty_state](Imp.html#empty_state) [X](Imp.html#X) 1) [Y](Imp.html#Y) 2) as st[2].\n\u00a0\u00a0assert (H[1]: c[1] / [empty_state](Imp.html#empty_state) \u21d3 st[1]);\n\u00a0\u00a0assert (H[2]: c[2] / [empty_state](Imp.html#empty_state) \u21d3 st[2]);\n\u00a0\u00a0try (subst;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [E_Seq](Imp.html#E_Seq) with (st' := ([t_update](Maps.html#t_update) [empty_state](Imp.html#empty_state) [X](Imp.html#X) 1));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [E_Ass](Imp.html#E_Ass); reflexivity).\n\u00a0\u00a0apply H in H[1].\n\n\u00a0\u00a0(*\u00a0Finally,\u00a0we\u00a0use\u00a0the\u00a0fact\u00a0that\u00a0evaluation\u00a0is\u00a0deterministic \u00a0\u00a0\u00a0\u00a0\u00a0to\u00a0obtain\u00a0a\u00a0contradiction.\u00a0*)\n\u00a0\u00a0assert (Hcontra: st[1] = st[2])\n\u00a0\u00a0\u00a0\u00a0by (apply ([ceval_deterministic](Imp.html#ceval_deterministic) c[2] [empty_state](Imp.html#empty_state)); assumption).\n\u00a0\u00a0assert (Hcontra': st[1] [Y](Imp.html#Y) = st[2] [Y](Imp.html#Y))\n\u00a0\u00a0\u00a0\u00a0by (rewrite Hcontra; reflexivity).\n\u00a0\u00a0subst. inversion Hcontra'. Qed.\n\n```", "```\nInductive var_not_used_in_aexp (X:id) : aexp \u2192 Prop :=\n\u00a0\u00a0| VNUNum: \u2200n, var_not_used_in_aexp X (ANum n)\n\u00a0\u00a0| VNUId: \u2200Y, X \u2260 Y \u2192 var_not_used_in_aexp X (AId Y)\n\u00a0\u00a0| VNUPlus: \u2200a[1] a[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X a[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X a[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X (APlus a[1] a[2])\n\u00a0\u00a0| VNUMinus: \u2200a[1] a[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X a[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X a[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X (AMinus a[1] a[2])\n\u00a0\u00a0| VNUMult: \u2200a[1] a[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X a[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X a[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var_not_used_in_aexp X (AMult a[1] a[2]).\n\nLemma aeval_weakening : \u2200i st a ni,\n\u00a0\u00a0var_not_used_in_aexp i a \u2192\n\u00a0\u00a0aeval (t_update st i ni) a = aeval st a.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nTheorem inequiv_exercise:\n\u00a0\u00a0\u00ac cequiv (WHILE BTrue DO SKIP END) SKIP.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Extended Exercise: Nondeterministic Imp\n\n    As we have seen (in theorem ceval_deterministic in the Imp\n    chapter), Imp's evaluation relation is deterministic.  However,\n    *non*-determinism is an important part of the definition of many\n    real programming languages. For example, in many imperative\n    languages (such as C and its relatives), the order in which\n    function arguments are evaluated is unspecified.  The program\n    fragment\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0HAVOC\u00a0Y;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Y\u00a0*\u00a02\n\n    the value of Y can be any number, while the value of Z is\n    twice that of Y (so Z is always even). Note that we are not\n    saying anything about the *probabilities* of the outcomes \u2014 just\n    that there are (infinitely) many different outcomes that can\n    possibly happen after executing this nondeterministic code.\n\n    In a sense, a variable on which we do HAVOC roughly corresponds\n    to an unitialized variable in a low-level language like C.  After\n    the HAVOC, the variable holds a fixed but arbitrary number.  Most\n    sources of nondeterminism in language definitions are there\n    precisely because programmers don't care which choice is made (and\n    so it is good to leave it open to the compiler to choose whichever\n    will run faster).\n\n    We call this new language *Himp* (``Imp extended with HAVOC'').\n\n```", "```\n\n    To formalize Himp, we first add a clause to the definition of\n    commands.\n\n```", "```\n\n#### Exercise: 2 stars (himp_ceval)\n\n    Now, we must extend the operational semantics. We have provided\n   a template for the ceval relation below, specifying the big-step\n   semantics. What rule(s) must be added to the definition of ceval\n   to formalize the behavior of the HAVOC command?\n\n```", "```\n\n    As a sanity check, the following claims should be provable for\n    your definition:\n\n```", "```\n\n    \u2610 \n\n    Finally, we repeat the definition of command equivalence from above:\n\n```", "```\n\n    Let's apply this definition to prove some nondeterministic\n    programs equivalent / inequivalent. \n\n#### Exercise: 3 stars (havoc_swap)\n\n    Are the following two programs equivalent?\n\n```", "```\n\n    If you think they are equivalent, prove it. If you think they are\n    not, prove that.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, optional (havoc_copy)\n\n    Are the following two programs equivalent?\n\n```", "```\n\n    If you think they are equivalent, then prove it. If you think they\n    are not, then prove that.  (Hint: You may find the assert tactic\n    useful.)\n\n```", "```\n\n    \u2610 \n\n    The definition of program equivalence we are using here has some\n    subtle consequences on programs that may loop forever.  What\n    cequiv says is that the set of possible *terminating* outcomes\n    of two equivalent programs is the same. However, in a language\n    with nondeterminism, like Himp, some programs always terminate,\n    some programs always diverge, and some programs can\n    nondeterministically terminate in some runs and diverge in\n    others. The final part of the following exercise illustrates this\n    phenomenon.\n\n#### Exercise: 4 stars, advanced (p1_p2_term)\n\n    Consider the following commands:\n\n```", "```\n\n    Intuitively, p[1] and p[2] have the same termination behavior:\n    either they loop forever, or they terminate in the same state they\n    started in.  We can capture the termination behavior of p[1] and\n    p[2] individually with these lemmas:\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, advanced (p1_p2_equiv)\n\n    Use these two lemmas to prove that p[1] and p[2] are actually\n    equivalent.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, advancedM (p3_p4_inequiv)\n\n    Prove that the following programs are *not* equivalent.  (Hint:\n    What should the value of Z be when p[3] terminates?  What about\n    p[4]?)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 5 stars, advanced, optional (p5_p6_equiv)\n\n    Prove that the following commands are equivalent.  (Hint: As\n    mentioned above, our definition of cequiv for Himp only takes\n    into account the sets of possible terminating configurations: two\n    programs are equivalent if and only if when given a same starting\n    state st, the set of possible terminating states is the same for\n    both programs. If p[5] terminates, what should the final state be?\n    Conversely, is it always possible to make p[5] terminate?)\n\n```", "```\n\n    \u2610\n\n```", "```\n\n# Additional Exercises\n\n#### Exercise: 4 stars, optional (for_while_equiv)\n\n    This exercise extends the optional add_for_loop exercise from\n    the [Imp](Imp.html) chapter, where you were asked to extend the language\n    of commands with C-style for loops.  Prove that the command:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1]\u00a0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0b\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[3]\u00a0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0END\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, optional (swap_noninterfering_assignments)\n\n    (Hint: You'll need functional_extensionality for this one.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, advanced, optional (capprox)\n\n    In this exercise we define an asymmetric variant of program\n    equivalence we call *program approximation*. We say that a\n    program c[1] *approximates* a program c[2] when, for each of\n    the initial states for which c[1] terminates, c[2] also terminates\n    and produces the same final state. Formally, program approximation\n    is defined as follows:\n\n```", "```\n\n    For example, the program c[1] = WHILE X \u2260 1 DO X ::= X - 1 END\n    approximates c[2] = X ::= 1, but c[2] does not approximate c[1]\n    since c[1] does not terminate when X = 0 but c[2] does.  If two\n    programs approximate each other in both directions, then they are\n    equivalent. \n\n    Find two programs c[3] and c[4] such that neither approximates\n    the other.\n\n```", "```\n\n    Find a program cmin that approximates every other program.\n\n```", "```\n\n    Finally, find a non-trivial property which is preserved by\n    program approximation (when going from left to right).\n\n```", "```\n\n    \u2610 \n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]