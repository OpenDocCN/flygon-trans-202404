- en: Module 0x4 | Web Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 0x4 | Web Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Send Get request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Net::HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Simple Shortened URL extractor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**urlextractor.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Ok, what if I gave you this shortened url(`http://short-url.link/f2a`)? try
    the above script and tell me what's going-on
  prefs: []
  type: TYPE_NORMAL
- en: Using Open-uri
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here another way to do the same thing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Send HTTP Post request with custom headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here the post body from a file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: More control on Post variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's to take the following form as a simple post form to mimic in our script
  prefs: []
  type: TYPE_NORMAL
- en: '| ![PostForm](webfu__post_form1.png) |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Figure 1.** Simple Post form |'
  prefs: []
  type: TYPE_TB
- en: 'Post form code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We need to send a Post request as the form figure 1 would do with control on
    each value and variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can use `body` method instead of `set_form_data` to avoid auto-encoding
    for any reason
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with Cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some times you need to deal with some actions after authentication. Ideally,
    it's all about cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: To Read cookies you need to get **set-cookie** from **response**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To Set cookies you need to set **Cookie** to **request**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: HTTP authentication (Basic, Digest, NTLM)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Digest authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Install net-http-digest_auth gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here is an [example](https://gist.github.com/KINGSABRI/a1df06eb48cbc52660577df6c7947ed5)
    to build it without external gem
  prefs: []
  type: TYPE_NORMAL
- en: NTLM authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Install ntlm gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note: ntlm gem works with http, imap, smtp protocols. [Read more](https://github.com/macks/ruby-ntlm).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: CGI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get info - from XSS/HTMLi exploitation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you exploit XSS or HTML injection you may need to receive the grepped data
    from exploited user to your external server. Here a simple example of CGI script
    take sent get request from fake login from that asks users to enter log-in with
    username and password then will store the data to `hacked_login.txt` text file
    and fix its permissions to assure that nobody can access that file from public.
  prefs: []
  type: TYPE_NORMAL
- en: Add the following to `/etc/apache2/sites-enabled/[SITE]` then restart the service
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, put the script in /var/www/[CGI FOLDER]. You can use it now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Web Shell^([1](#fn_1)) - command execution via GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: if you have a server that supports ruby CGI, you can use the following as backdoor
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now you can simply use a web browser, Netcat or WebShellConsole^([1](#fn_1))
    to execute your commands. ex. **Browser**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Netcat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**WebShellConsole**'
  prefs: []
  type: TYPE_NORMAL
- en: run wsc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Add Shell URL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now prompt your commands
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Mechanize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we're talking about dealing with web in ruby, we can't forget **Mechanize**
    gem, the most known library for dealing wit web.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Official description says**, the Mechanize library is used for automating
    interaction with websites. Mechanize automatically stores and sends cookies, follows
    redirects, and can follow links and submit forms. Form fields can be populated
    and submitted. Mechanize also keeps track of the sites that you have visited as
    a history.'
  prefs: []
  type: TYPE_NORMAL
- en: More about Mechanize gem
  prefs: []
  type: TYPE_NORMAL
- en: '[Getting Started With Mechanize](http://docs.seattlerb.org/mechanize/GUIDE_rdoc.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mechanize examples](http://docs.seattlerb.org/mechanize/EXAMPLES_rdoc.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RailsCasts | Mechanize tutorial](http://railscasts.com/episodes/191-mechanize)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since you know the hard way, you'll find Mechanize as simple as mouse clicks!
    give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: HTTP.rb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP (The Gem! a.k.a. http.rb) is an easy-to-use client library for making requests
    from Ruby. It uses a simple method chaining system for building requests, similar
    to Python's Requests.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, http.rb uses http_parser.rb, a fast HTTP parsing native extension
    based on the Node.js parser and a Java port thereof. This library isn't just yet
    another wrapper around Net::HTTP. It implements the HTTP protocol natively and
    outsources the parsing to native extensions.
  prefs: []
  type: TYPE_NORMAL
- en: More about http.rb gem
  prefs: []
  type: TYPE_NORMAL
- en: '[The Official repository](https://github.com/httprb/http)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The official wiki](https://github.com/httprb/http/wiki)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ยน. [WebShellConsole](https://github.com/KINGSABRI/WebShellConsole) is simple
    interactive console, interacts with simple web shells using HTTP GET rather than
    using browser. wsc will work with any shell use GET method. It takes care of all
    URL encoding too. [โฉ](#reffn_1 "Jump back to footnote [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[CGI Examples](http://www.java2s.com/Code/Ruby/CGI/CatalogCGI.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Injection Scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL Injection Scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic SQLi script as command line browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The is a very basic script take your given payload and send it to the vulnerable
    parameter and returns the response back to you. I'll use ([http://testphp.vulnweb.com/](http://testphp.vulnweb.com/))
    as it's legal to test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I've commented the line `puts response.body.gsub(/<.*?>/, '').strip` and added
    a custom regular expression to fix our target outputs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's to test it in action
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here a very basic and simple SQL-injection solid scanner, develop it as far
    as you can!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Try it on this URL ([http://testasp.vulnweb.com/showforum.asp?id=0](http://testasp.vulnweb.com/showforum.asp?id=0))
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Boolean-bases SQLi Exploit Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a Boolean-based SQLi exploit for [sqli-labs](https://github.com/Audi-1/sqli-labs)
    vulnerable application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Time-bases SQLi Exploit Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Time-based SQLi exploit for [sqli-labs](https://github.com/Audi-1/sqli-labs)
    vulnerable application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with database is a required knowledge in web testing and here we will
    go though most known databases and how to deal with it in ruby.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install sqlite3 gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You've have to have sqlite3 development libraries installed on your system
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Basic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Active Record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install ActiveRecord gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: MySQL database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Install MySQL adapter gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Login to mysql console and create database *rubyfu_db* and table *attackers*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The outputs look like following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's to connect to *rubyfu_db* database
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using the ActiveRecord library, available as the activerecord gem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ActiveRecord adapter namely *mysql*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing a connection to the database *rubyfu_db*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a class called *Attackers* following the conventions mentioned above
    (attacker)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You will observe that ActiveRecord examines the database tables themselves
    to find out which columns are available. This is how we were able to use accessor
    methods for participant.name without explicitly defining them: we defined them
    in the database, and ActiveRecord picked them up.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the item
  prefs: []
  type: TYPE_NORMAL
- en: by id
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Result
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or you can work it as object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to delete an item from the database, you can use the destroy (Deletes
    the record in the database) method of ActiveRecord::Base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So to write a complete script,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Oracle database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'in order to make [ruby-oci8](http://www.rubydoc.info/gems/ruby-oci8/file/docs/install-full-client.md)
    -which is the main dependency for oracle driver- works you''ve to do some extra
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download links for [Linux](http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html)
    | [Windows](http://www.oracle.com/technetwork/topics/winsoft-085727.html) | [Mac](http://www.oracle.com/technetwork/topics/intel-macsoft-096467.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: instantclient-basic-[OS].[Arch]-[VERSION].zip
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: instantclient-sqlplus-[OS].[Arch]-[VERSION].zip
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: instantclient-sdk-[OS].[Arch]-[VERSION].zip
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unzip downloaded files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Create system directories as root / sudo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The file structure should be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Move files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Setup environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Append oracle environment variables in to `~/.bashrc` Then add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Install Oracle adapter gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's to connect
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Install MSSQL adapter gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Extending Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up the Ruby environment for Burp Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download a stable version of JRuby from [JRuby Downloads](http://jruby.org/download)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the jar for Linux (JRuby x.x.x Complete .jar) or Executable for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the environment from **Burp Suite** >> **Extender** >> **Options** >>
    **Ruby Environment**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](webfu__burp_setenv1.png)'
  prefs: []
  type: TYPE_IMG
- en: Import the Burp Suite Extender Core API `IBurpExtender`
  prefs: []
  type: TYPE_NORMAL
- en: '**alert.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Load the plugin alert.rb
  prefs: []
  type: TYPE_NORMAL
- en: '![](webfu__burp-ext1.png)'
  prefs: []
  type: TYPE_IMG
- en: Check Alerts tab
  prefs: []
  type: TYPE_NORMAL
- en: '![](webfu__burp-ext2.png)'
  prefs: []
  type: TYPE_IMG
- en: Burp Suite Extension in Ruby template initiative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As Rubyfu project keeps groing, we've decided to develope our vesion of make
    a solid place for Ruby in the information security community. We've deceided to
    build a repository that makes building a Burp Suite extension in Ruby is very
    easy and understandable. [**Repository link**](https://github.com/KINGSABRI/BurpSuite_Extension_Ruby_Template)
  prefs: []
  type: TYPE_NORMAL
- en: Buby
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buby is a mashup of JRuby with the popular commercial web security testing tool
    Burp Suite from PortSwigger. Burp is driven from and tied to JRuby with a Java
    extension using the BurpExtender API. This extension aims to add Ruby scriptability
    to Burp Suite with an interface comparable to the Burp's pure Java extension interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resources**'
  prefs: []
  type: TYPE_NORMAL
- en: Burp Suite Extender API Documentations [ [link](https://portswigger.net/burp/extender/api/)
    ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step by step Ruby-based Burp Extension for JSON Encryption/Decryption [ [Part
    1](https://www.trustwave.com/Resources/SpiderLabs-Blog/JSON-Crypto-Helper-a-Ruby-based-Burp-Extension-for-JSON-Encryption/Decryption---Part-I/)
    | [Part 2](http://blog.spiderlabs.com/2015/01/json-crypto-helper-a-ruby-based-burp-extension-for-json-encryptiondecryption-part-ii.html)
    ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buby [ [website](http://human.versus.computer/buby/) | [rdoc](http://human.versus.computer/buby/rdoc/index.html)
    ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions written in Ruby [ [WhatThWAF](https://github.com/null--/what-the-waf)
    ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Burp suite Scripting with Buby [ [Link](http://www.gotohack.org/2011/05/cktricky-appsec-buby-script-basics-part.html)
    ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browser Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a hacker, sometimes you need to automate your client side tests (ex. XSS)
    and reduce the false positives that happen specially in XSS tests. The traditional
    automation depends on finding the sent payload been received in the response,
    but it doesn't mean the vulnerability get really exploited so you have to do it
    manually again and again.
  prefs: []
  type: TYPE_NORMAL
- en: Here we'll learn how to make ruby controls our browser in order to **emulate**
    the same attacks from browser and get the real results.
  prefs: []
  type: TYPE_NORMAL
- en: The most known APIs for this task are ***Selenium*** and ***Watir*** which support
    most know web browsers currently exist.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium Webdriver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**Selenium**](https://github.com/seleniumhq/selenium) is an umbrella project
    encapsulating a variety of tools and libraries enabling web browser automation.'
  prefs: []
  type: TYPE_NORMAL
- en: install selenium gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: GET Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that the actual keys to send depend on your OS, for example, Mac uses `COMMAND
    + t`, instead of `CONTROL + t`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: POST Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Let's test the page against XSS vulnerability. First I'll list what kind of
    action we need from browser
  prefs: []
  type: TYPE_NORMAL
- en: Open a browser window (Firefox)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to a URL (altoromutual.com)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform some operations (Send an XSS payload)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the payload is working(Popping-up) or it's a false positive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the succeed payloads on terminal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**selenium-xss.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Result
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Watir Webdriver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**Watir**](http://watirwebdriver.com/) is abbreviation for (Web Application
    Testing in Ruby). I believe that Watir is more elegant than Selenium but I like
    to know many ways to do the same thing, just in case.'
  prefs: []
  type: TYPE_NORMAL
- en: install watir gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: GET Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometime you''ll need to send XSS GET request from URL like `http://app/search?q=<script>alert</script>`.
    You''ll face a known error `Selenium::WebDriver::Error::UnhandledAlertError: Unexpected
    modal dialog` if the alert box popped up but it you do refresh page for the sent
    payload it''ll work so the fix for this issue is the following.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: POST Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Since Waiter is integrated with Selenium, you can use both to achieve one goal
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: For Some reason in some log-in cases, you may need to add a delay time between
    entering username and password then submit.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium, Watir Arbitrary POST request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here another scenario I've faced, I was against POST request without submit
    button, in another word, the test was against intercepted request generated from
    jQuery function, in my case was a drop menu. So The work round wad quite simple,
    Just create an HTML file contains POST form with the original parameters plus
    a **Submit button**(***just like creating CSRF exploit from a POST form***) then
    call that html file to the browser and deal with it as normal form. Let's to see
    an example here.
  prefs: []
  type: TYPE_NORMAL
- en: '**POST request**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**example.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**exploit.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with tabs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of scenarios I've faced is to exploit XSS a user profile fields and check
    the result in another page which present the public user's profile. Instead of
    revisiting the URLs again and again I open new tab and refresh the public user's
    profile page then return back to send the exploit and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**xss_tab.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Selenium official documentations](http://docs.seleniumhq.org/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Selenium Cheat Sheet](https://gist.github.com/kenrett/7553278)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Selenium webdriver vs Watir-webdriver in Ruby](http://watirmelon.com/2011/05/05/selenium-webdriver-vs-watir-webdriver-in-ruby/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing automate test scripts in Ruby](https://www.browserstack.com/automate/ruby)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Selenium WebDriver and Ruby](https://swdandruby.wordpress.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Selenium Guidebook - Commercial](https://seleniumguidebook.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Watir WebDriver](http://watirwebdriver.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Watir Cheat Sheet](https://github.com/watir/watir/wiki/Cheat-Sheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Services and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Services and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Services and APIs are getting popular and used in many known websites we
    use in daily basis. For that matter, I'd like to put some general definitions
    that may make it clear to deal with
  prefs: []
  type: TYPE_NORMAL
- en: Technical Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application programming interface (API) is a set of routines, data structures,
    object classes and/or protocols provided by libraries and/or operating system
    services in order to support the building of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Web Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Web service (also Web Service) is defined by the W3C as "a software system
    designed to support interoperable machine-to-machine interaction over a network"
  prefs: []
  type: TYPE_NORMAL
- en: Difference Between API and Web Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All Web services are APIs but all APIs are not Web services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web services might not perform all the operations that an API would perform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A Web service uses only three styles of use: SOAP, REST and XML-RPC for communication
    whereas API may use any style for communication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Web service always needs a network for its operation whereas an API doesn't
    need a network for its operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An API facilitates interfacing directly with an application whereas a Web service
    interacts with two machines over a network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web service is like advanced URLs and API is Programmed Interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: API contains classes and Interfaces just like a program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A web service is a form of API (Application Programming Interface).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An API is used by a computer programmer to establish a link between software
    applications. This interface can take several forms, a web service is just one
    of these.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are several types of web service. SOAP (Simple Object Access Protocol)
    is one of the most common. The API takes the form of a service description (WSDL)
    which is used to automatically generate the program code which makes the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Difference Between API And Web Service](http://microsoft-techies.blogspot.com/2014/03/difference-between-api-and-web-service.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Application programming interface](https://en.wikipedia.org/wiki/Application_programming_interface)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Web service](https://en.wikipedia.org/wiki/Web_service)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOAP - WSDL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, dealing with SOAP means dealing with XML messages and a
    WSDL file (also XML) that describes how to use a given SOAP API. Ruby has really
    elegant way to do so and let's to get our hand dirty with an exploit
  prefs: []
  type: TYPE_NORMAL
- en: Install wasabi, sabvon & httpclient gems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enumeration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Interaction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Hacking via SOAP vulnerabilities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a working exploit for Vtiger CRM SOAP from auth-bypass to shell upload
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: More about [Savon](http://savonrb.com/)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs have a variety of structures to interact with their peers.
  prefs: []
  type: TYPE_NORMAL
- en: '**StackExchange API**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**IPify API**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: WordPress API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby has a [standard library](http://ruby-doc.org/stdlib-2.2.3/libdoc/xmlrpc/rdoc/XMLRPC/Client.html)
    called `xmlrpc` which takes care of all xmlrpc stuff, you can even create an XML-RPC
    server using it. Let's to get some real word example
  prefs: []
  type: TYPE_NORMAL
- en: Looking for really known application that support XML-RPC then of course WordPress
    was the first attendee.
  prefs: []
  type: TYPE_NORMAL
- en: So what do we want to do?
  prefs: []
  type: TYPE_NORMAL
- en: Say hello to WordPress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all available methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all available users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all available post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new post!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve our created post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all comments on our created post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: and here is the new post ![](webfu__xmlrpc1.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [HOW TO PROGRAMATICALLY CONTROL WORDPRESS WITH RUBY USING XML-RPC](http://notes.jerzygangi.com/how-to-programatically-control-wordpress-with-ruby-using-xml-rpc/)'
  prefs: []
  type: TYPE_NORMAL
- en: More about [WordPress XML-RPC](http://notes.jerzygangi.com/how-to-programatically-control-wordpress-with-ruby-using-xml-rpc/)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Twitter API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with Twitter's API is really useful for information gathering, taxonomy
    and social engineering. However, you have to have some keys and tokens in-order
    to interact with Twitter's APIs. To do so, please refer to the official [Twitter
    development page](https://dev.twitter.com/oauth/overview).
  prefs: []
  type: TYPE_NORMAL
- en: Install Twitter API gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Basic Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**rubyfu-tweet.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '![](webfu__twitterAPI1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Your turn**, tweet to @Rubyfu using above example. Tweet your code and output
    to **@Rubyfu**.'
  prefs: []
  type: TYPE_NORMAL
- en: Building Stolen Credentials notification bot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're exploiting an XSS/HTML injection vulnerability and tricking users to enter
    there Username and Password. The idea is, We'll make a [CGI script](http://rubyfu.net/content/module_0x4__web_kung_fu/index.html#cgi)
    that takes that stolen credentials then tweet these credentials to us as notification
    or log system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Telegram API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Telegram API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know that Telegram is a messaging app identifies users by their mobile
    number. Fortunately, Telegram has its own API -*Ruby has a wrapper gem for* [*Telegram's
    Bot API*](https://core.telegram.org/bots/api) called [*telegram-bot-ruby*](https://github.com/atipugin/telegram-bot-ruby)
    - which allows you to Integrate with other services, create custom tools, build
    single- and multiplayer games, build social services, do virtually anything else;
    Do you smell anything evil here?
  prefs: []
  type: TYPE_NORMAL
- en: Install telegram-bot gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Basic usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As many APIs, you have to get a [token](https://core.telegram.org/bots#botfather)
    to deal with your bot. Here a basic usage
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Once your run it, go to your telegram and find the bot and start chat with `/start`,
    try to send `/rubyfu`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](rubyfubot.png)'
  prefs: []
  type: TYPE_IMG
- en: Inline bots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you got that evil smile from above example, you may thinking about interacting
    with your bots [inline](https://core.telegram.org/bots/inline) to call/@mention
    your bots and request more action from the bot(s).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '**Resources**'
  prefs: []
  type: TYPE_NORMAL
- en: A good topic about Quickly Create a Telegram Bot in Ruby can be found [here](http://www.sitepoint.com/quickly-create-a-telegram-bot-in-ruby/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more usage and documentation for the [gem](https://github.com/atipugin/telegram-bot-ruby)
    and the [API](https://core.telegram.org/bots), and you can show us your evil code,
    and you can pull it in Rubyfu!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bot Revolution. Know your API or die hard.](http://web.neurotiko.com/bots/2015/08/03/bots-know-your-api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby 2 JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby 2 JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoffeeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[CoffeeScript](http://coffeescript.org) is a programming language that transcompiles
    to JavaScript. It adds syntactic sugar inspired by Ruby, Python and Haskell in
    an effort to enhance JavaScript''s brevity and readability.'
  prefs: []
  type: TYPE_NORMAL
- en: Quick CoffeeScript Review
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here a quick how to if CoffeeScript in general
  prefs: []
  type: TYPE_NORMAL
- en: Install CoffeScript lib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For live conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ruby CoffeScript gem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ruby** CoffeeScript gem is a bridge to the official CoffeeScript compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Install CoffeeScript gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Convert CoffeeScript file to JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Opal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Opal is a Ruby to JavaScript source-to-source compiler. It also has an implementation
    of the Ruby corelib.
  prefs: []
  type: TYPE_NORMAL
- en: Install Opal gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Web Server and Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby as Web Server and Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can run Ruby as web server for any folder/file on any unused port
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '**HTTPS server**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '**Advanced HTTP Server**'
  prefs: []
  type: TYPE_NORMAL
- en: During working on [CVE-2016-4971(Wget)](https://github.com/KINGSABRI/CVE-in-Ruby/tree/master/CVE-2016-4971)
    exploit, more advanced & custom behavior needed. Here is a web server with a fake
    login form that saves the collected credentials to a text file. This comes in
    handy when you don't need to make customizations on apache config or you don't
    have enough privileges to do so. It require no knowledge for web frameworks like
    Rails or Senatra.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: You'll find credentials have been saved in 'credentials.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://ruby-doc.org/stdlib-2.0.0/libdoc/webrick/rdoc/WEBrick.html](http://ruby-doc.org/stdlib-2.0.0/libdoc/webrick/rdoc/WEBrick.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.igvita.com/2007/02/13/building-dynamic-webrick-servers-in-ruby/](https://www.igvita.com/2007/02/13/building-dynamic-webrick-servers-in-ruby/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://rubyit.wordpress.com/2011/07/25/basic-rest-server-with-webrick/](https://rubyit.wordpress.com/2011/07/25/basic-rest-server-with-webrick/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gist.github.com/Integralist/2862917](https://gist.github.com/Integralist/2862917)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transparent Web Proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Transparent Web Proxy with Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, it was great to know that building a proxy server is that easy. Now we
    need to Force authentication to connect to the proxy server
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable authentication for requests in WEBrick you will need a user database
    and an authenticator. To start, here''s a htpasswd database for use with a DigestAuth
    authenticator:'
  prefs: []
  type: TYPE_NORMAL
- en: The `:Realm` is used to provide different access to different groups across
    several resources on a server. Typically you'll need only one realm for a server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: If you do it right, you'll get an authentication pop-up in your browser just
    like below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](webfu__proxy2.png)'
  prefs: []
  type: TYPE_IMG
