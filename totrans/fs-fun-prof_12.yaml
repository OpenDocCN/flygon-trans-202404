- en: Choosing between collection functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集合函数之间进行选择
- en: Choosing between collection functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集合函数之间进行选择
- en: There's more to learning a new language than the language itself. In order to
    be productive, you need to memorize a big chunk of the standard library and be
    aware of most of the rest of it. For example, if you know C#, you can pick up
    Java-the-language quite quickly, but you won't really get up to speed until you
    are comfortable with the Java Class Library as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门新语言不仅仅是语言本身。为了提高生产力，你需要记住大量的标准库，并了解大部分其他内容。例如，如果你了解 C#，你可以很快掌握 Java-语言，但只有当你对
    Java 类库感到舒适时，你才能真正提高速度。
- en: Similarly, you can't really be effective in F# until you have some familiarity
    with all the F# functions that work with collections.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，在熟悉所有与集合相关的 F# 函数之前，你实际上无法有效地使用 F#。
- en: In C# there are only a few LINQ methods you need to know¹ (`Select`, `Where`,
    and so on). But in F#, there are currently almost 100 functions in the List module
    (and similar counts in the Seq and Array modules). That's a lot!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你只需要知道几个 LINQ 方法¹（`Select`、`Where`等）。但在 F# 中，目前列表模块中几乎有100个函数（序列和数组模块中的计数也相似）。这太多了！
- en: ¹ Yes, there are more, but you can get by with just a few. In F# it's more important
    to know them all.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 是的，还有更多，但你只需要掌握其中几个就可以了。在 F# 中，了解它们所有更为重要。
- en: If you are coming to F# from C#, then, the large number of list functions can
    be overwhelming.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从 C# 转到 F#，那么大量的列表函数可能会让你感到不知所措。
- en: So I have written this post to help guide you to the one you want. And for fun,
    I've done it in a "Choose Your Own Adventure" style!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我写了这篇帖子来帮助你找到你想要的。而且为了好玩，我用“选择你的冒险”风格来做了这件事！
- en: '![](cyoa_list_module.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](cyoa_list_module.jpg)'
- en: What collection do I want?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我想要哪种集合？
- en: 'First, a table with information about the different kinds of standard collections.
    There are five "native" F# ones: `list`, `seq`, `array`, `map` and `set`, and
    `ResizeArray` and `IDictionary` are also often used.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一张关于不同种类标准集合的信息表。有五种“本地”F#集合：`list`、`seq`、`array`、`map`和`set`，还经常使用`ResizeArray`和`IDictionary`。
- en: '|  | Immutable? | Notes |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  | 不可变？ | 备注 |'
- en: '| list | Yes | **Pros:**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '| list | 是 | **优点：**'
- en: Pattern matching available.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用模式匹配。
- en: Complex iteration available via recursion.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过递归可用的复杂迭代。
- en: Forward iteration is fast. Prepending is fast.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正向迭代速度快。前置速度快。
- en: '**Cons:**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**'
- en: Indexed access and other access styles are slow.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引访问和其他访问样式较慢。
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| seq | Yes | Alias for `IEnumerable`.**Pros:**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '| seq | 是 | `IEnumerable` 的别名。**优点：**'
- en: Lazy evaluation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性评估
- en: Memory efficient (only one element at a time loaded)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存高效（每次仅加载一个元素）
- en: Can represent an infinite sequence.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以表示无限序列。
- en: Interop with .NET libraries that use IEnumerable.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与使用 IEnumerable 的 .NET 库的互操作性。
- en: '**Cons:**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**'
- en: No pattern matching.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有模式匹配。
- en: Forward only iteration.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅正向迭代。
- en: Indexed access and other access styles are slow.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引访问和其他访问样式较慢。
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| array | No | Same as BCL `Array`.**Pros:**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '| array | 否 | 与 BCL 的 `Array` 相同。**优点：**'
- en: Fast random access
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速随机访问
- en: Memory efficient and cache locality, especially with structs.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存高效和缓存局部性，尤其是对于结构体。
- en: Interop with .NET libraries that use Array.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与使用 Array 的 .NET 库的互操作性。
- en: Support for 2D, 3D and 4D arrays
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 2D、3D 和 4D 数组
- en: '**Cons:**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**'
- en: Limited pattern matching.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配有限。
- en: Not [persistent](https://en.wikipedia.org/wiki/Persistent_data_structure).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是 [持久化](https://en.wikipedia.org/wiki/Persistent_data_structure)。
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| map | Yes | Immutable dictionary. Requires keys to implement `IComparable`.
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| map | 是 | 不可变字典。要求键实现 `IComparable`。 |'
- en: '| set | Yes | Immutable set. Requires elements to implement `IComparable`.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| set | 是 | 不可变集合。要求元素实现 `IComparable`。 |'
- en: '| ResizeArray | No | Alias for BCL `List`. Pros and cons similar to array,
    but resizable. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| ResizeArray | 否 | BCL `List` 的别名。优缺点与数组类似，但可调整大小。 |'
- en: '| IDictionary | Yes | For an alternate dictionary that does not requires elements
    to implement `IComparable`, you can use the BCL [IDictionary](https://msdn.microsoft.com/en-us/library/s4ys34ea.aspx).
    The constructor is [`dict`](https://msdn.microsoft.com/en-us/library/ee353774.aspx)
    in F#.Note that mutation methods such as `Add` are present, but will cause a runtime
    error if called. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| IDictionary | 是 | 对于不要求元素实现 `IComparable` 的替代字典，你可以使用 BCL 的 [IDictionary](https://msdn.microsoft.com/en-us/library/s4ys34ea.aspx)。构造函数是
    [`dict`](https://msdn.microsoft.com/en-us/library/ee353774.aspx)。请注意，诸如 `Add`
    等变异方法存在，但如果调用会导致运行时错误。 |'
- en: These are the main collection types that you will encounter in F#, and will
    be good enough for all common cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你在 F# 中会遇到的主要集合类型，对于所有常见情况来说已经足够好了。
- en: 'If you need other kinds of collections though, there are lots of choices:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要其他类型的集合，还有很多选择：
- en: You can use the collection classes in .NET, either the [traditional, mutable
    ones](https://msdn.microsoft.com/en-us/library/system.collections.generic) or
    the newer ones such as those in the [System.Collections.Immutable namespace](https://msdn.microsoft.com/en-us/library/system.collections.immutable.aspx).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 .NET 中的集合类，无论是[传统的、可变的](https://msdn.microsoft.com/en-us/library/system.collections.generic)，还是像[System.Collections.Immutable
    namespace](https://msdn.microsoft.com/en-us/library/system.collections.immutable.aspx)中的新类。
- en: 'Alternatively, you can use one of the F# collection libraries:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以使用 F# 集合库之一：
- en: '[**FSharpx.Collections**](https://fsprojects.github.io/FSharpx.Collections/),
    part of the FSharpx series of projects.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**FSharpx.Collections**](https://fsprojects.github.io/FSharpx.Collections/)，FSharpx
    系列项目的一部分。'
- en: '[**ExtCore**](https://github.com/jack-pappas/ExtCore/tree/master/ExtCore).
    Some of these are drop-in (almost) replacements for the Map and Set types in FSharp.Core
    which provide improved performance in specific scenarios (e.g., HashMap). Others
    provide unique functionality to help tackle specific coding tasks (e.g., LazyList
    and LruCache).'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**ExtCore**](https://github.com/jack-pappas/ExtCore/tree/master/ExtCore)。其中一些几乎可以替代
    FSharp.Core 中的 Map 和 Set 类型，在特定场景下提供了更好的性能（例如，HashMap）。其他提供了独特功能，帮助解决特定的编码任务（例如，LazyList
    和 LruCache）。'
- en: '[**Funq**](https://github.com/GregRos/Funq): high performance, immutable data
    structures for .NET.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**Funq**](https://github.com/GregRos/Funq)：高性能、不可变数据结构，适用于 .NET。'
- en: '[**Persistent**](https://persistent.codeplex.com/documentation): some efficient
    persistent (immutable) data structures.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**Persistent**](https://persistent.codeplex.com/documentation)：一些高效的持久（不可变）数据结构。'
- en: About the documentation
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于文档
- en: All functions are available for `list`, `seq` and `array` in F# v4 unless noted.
    The `Map` and `Set` modules have some of them as well, but I won't be discussing
    `map` and `set` here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数在 F# v4 中都适用于`list`、`seq`和`array`，除非另有说明。`Map`和`Set`模块也有一些函数，但我不会在这里讨论`map`和`set`。
- en: For the function signatures I will use `list` as the standard collection type.
    The signatures for the `seq` and `array` versions will be similar.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数签名，我将使用`list`作为标准集合类型。`seq`和`array`版本的签名将类似。
- en: Many of these functions are not yet documented on MSDN so I'm going to link
    directly to the source code on GitHub, which has the up-to-date comments. Click
    on the function name for the link.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的许多尚未在 MSDN 上记录，因此我将直接链接到 GitHub 上的源代码，其中有最新的注释。点击函数名称获取链接。
- en: Note on availability
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性说明
- en: The availability of these functions may depend on which version of F# you use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的可用性可能取决于你使用的 F# 版本。
- en: In F# version 3 (Visual Studio 2013), there was some degree of inconsistency
    between Lists, Arrays and Sequences.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 F# 版本 3（Visual Studio 2013）中，Lists、Arrays 和 Sequences 之间存在一定程度的不一致性。
- en: In F# version 4 (Visual Studio 2015), this inconsistency has been eliminated,
    and almost all functions are available for all three collection types.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 F# 版本 4（Visual Studio 2015）中，这种不一致性已经被消除，几乎所有函数都适用于这三种集合类型。
- en: If you want to know what changed between F# v3 and F# v4, please see [this chart](http://blogs.msdn.com/cfs-filesystemfile.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-39-71-metablogapi/3125.collectionAPI_5F00_254EA354.png)
    (from [here](http://blogs.msdn.com/b/fsharpteam/archive/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015.aspx)).
    The chart shows the new APIs in F# v4 (green), previously-existing APIs (blue),
    and intentional remaining gaps (white).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解 F# v3 和 F# v4 之间有什么变化，请查看[这个图表](http://blogs.msdn.com/cfs-filesystemfile.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-39-71-metablogapi/3125.collectionAPI_5F00_254EA354.png)（来自[这里](http://blogs.msdn.com/b/fsharpteam/archive/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015.aspx)）。该图表显示了
    F# v4 中的新 API（绿色）、先前存在的 API（蓝色）和有意保留的差距（白色）。
- en: Some of the functions documented below are not in this chart -- these are newer
    still! If you are using an older version of F#, you can simply reimplement them
    yourself using the code on GitHub.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面记录的一些函数不在这个图表中 -- 这些是更新的！如果你使用的是较旧版本的 F#，你��以简单地使用 GitHub 上的代码重新实现它们。
- en: With that disclaimer out of the way, you can start your adventure!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个免责声明，你就可以开始你的冒险了！
- en: '* * *'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Table of contents
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录
- en: '[1\. What kind of collection do you have?](#1)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1\. 你有什么样的集合？](#1)'
- en: '[2\. Creating a new collection](#2)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2\. 创建一个新的集合](#2)'
- en: '[3\. Creating a new empty or one-element collection](#3)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3\. 创建一个新的空集合或一个元素的集合](#3)'
- en: '[4\. Creating a new collection of known size](#4)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4\. 创建一个已知大小的新集合](#4)'
- en: '[5\. Creating a new collection of known size with each element having the same
    value](#5)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5\. 创建每个元素具有相同值的已知大小的新集合](#5)'
- en: '[6\. Creating a new collection of known size with each element having a different
    value](#6)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6\. 创建每个元素具有不同值的已知大小的新集合](#6)'
- en: '[7\. Creating a new infinite collection](#7)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7\. 创建一个新的无限集合](#7)'
- en: '[8\. Creating a new collection of indefinite size](#8)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8\. 创建一个大小不定的新集合](#8)'
- en: '[9\. Working with one list](#9)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9\. 处理一个列表](#9)'
- en: '[10\. Getting an element at a known position](#10)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10\. 获取已知位置的元素](#10)'
- en: '[11\. Getting an element by searching](#11)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11\. 通过搜索获取元素](#11)'
- en: '[12\. Getting a subset of elements from a collection](#12)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12\. 从集合中获取一部分元素](#12)'
- en: '[13\. Partitioning, chunking and grouping](#13)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13\. 分区、分块和分组](#13)'
- en: '[14\. Aggregating or summarizing a collection](#14)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14\. 对集合进行聚合或汇总](#14)'
- en: '[15\. Changing the order of the elements](#15)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15\. 改变元素的顺序](#15)'
- en: '[16\. Testing the elements of a collection](#16)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16\. 测试集合的元素](#16)'
- en: '[17\. Transforming each element to something different](#17)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[17\. 将每个元素转换为不同的内容](#17)'
- en: '[18\. Iterating over each element](#18)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[18\. 遍历每个元素](#18)'
- en: '[19\. Threading state through an iteration](#19)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[19\. 通过迭代传递状态](#19)'
- en: '[20\. Working with the index of each element](#20)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[20\. 处理每个元素的索引](#20)'
- en: '[21\. Transforming the whole collection to a different collection type](#21)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[21\. 将整个集合转换为不同的集合类型](#21)'
- en: '[22\. Changing the behavior of the collection as a whole](#22)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[22\. 更改整个集合的行为](#22)'
- en: '[23\. Working with two collections](#23)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[23\. 处理两个集合](#23)'
- en: '[24\. Working with three collections](#24)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[24\. 处理三个集合](#24)'
- en: '[25\. Working with more than three collections](#25)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[25\. 处理超过三个集合](#25)'
- en: '[26\. Combining and uncombining collections](#26)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[26\. 合并和分解集合](#26)'
- en: '[27\. Other array-only functions](#27)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[27\. 其他仅适用于数组的功能](#27)'
- en: '[28\. Using sequences with disposables](#28)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[28\. 使用可释放项的序列](#28)'
- en: '* * *'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1\. What kind of collection do you have?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 您有什么样的集合？
- en: What kind of collection do you have?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您有什么样的集合？
- en: If you don't have a collection, and want to create one, go to [section 2](#2).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您没有集合，并且想要创建一个，请转到[第 2 节](#2)。
- en: If you already have a collection that you want to work with, go to [section
    9](#9).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您已经有一个要处理的集合，请转到[第 9 节](#9)。
- en: If you have two collections that you want to work with, go to [section 23](#23).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您要处理两个集合，请转到[第 23 节](#23)。
- en: If you have three collections that you want to work with, go to [section 24](#24).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您要处理三个集合，请转到[第 24 节](#24)。
- en: If you have more than three collections that you want to work with, go to [section
    25](#25).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您要处理三个以上的集合，请转到[第 25 节](#25)。
- en: If you want to combine or uncombine collections, go to [section 26](#26).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要合并或分解集合，请转到[第 26 节](#26)。
- en: '* * *'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 2\. Creating a new collection
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 创建一个新的集合
- en: So you want to create a new collection. How do you want to create it?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么您想要创建一个新的集合。您想如何创建它？
- en: If the new collection will be empty or will have one element, go to [section
    3](#3).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果新集合将为空或将只有一个元素，请转到[第 3 节](#3)。
- en: If the new collection is a known size, go to [section 4](#4).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果新集合是已知大小，请转到[第 4 节](#4)。
- en: If the new collection is potentially infinite, go to [section 7](#7).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果新集合可能是无限的，请转到[第 7 节](#7)。
- en: If you don't know how big the collection will be, go to [section 8](#8).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不知道集合的大小， 请转到[第 8 节](#8)。
- en: '* * *'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 3\. Creating a new empty or one-element collection
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. 创建一个新的空集合或一个元素的集合
- en: 'If you want to create a new empty or one-element collection, use these functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要创建一个新的空集合或一个元素的集合，请使用这些功能：
- en: '[`empty : ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L142).
    Returns an empty list of the given type.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`empty : ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L142)。返回给定类型的空列表。'
- en: '[`singleton : value:''T -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L635).
    Returns a list that contains one item only.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`singleton : value:''T -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L635)。返回仅包含一个项目的列表。'
- en: If you know the size of the collection in advance, it is generally more efficient
    to use a different function. See [section 4](#4) below.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预先知道集合的大小，通常更有效的方法是使用不同的函数。参见下面的[第4节](#4)。
- en: Usage examples
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '* * *'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 4\. Creating a new collection of known size
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4\. 创建一个已知大小的新集合
- en: If all elements of the collection will have the same value, go to [section 5](#5).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果集合的所有元素将具有相同的值，请转到[第5节](#5)。
- en: If elements of the collection could be different, go to [section 6](#6).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果集合的元素可能不同，请转到[第6节](#6)。
- en: '* * *'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 5\. Creating a new collection of known size with each element having the same
    value
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5\. 创建一个已知大小的新集合，每个元素都具有相同的值
- en: 'If you want to create a new collection of known size with each element having
    the same value, you want to use `replicate`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个每个元素可能有不同值的已知大小的新集合，你应该使用`replicate`：
- en: '[`replicate : count:int -> initial:''T -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L602).
    Creates a collection by replicating the given initial value.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`replicate：count：int->initial：''T->''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L602)。
    通过复制给定的初始值来创建集合。'
- en: '(Array only) [`create : count:int -> value:''T -> ''T[]`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L125).
    Creates an array whose elements are all initially the supplied value.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （仅限数组）[`create：count：int->value：'T->'T []`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L125)。
    创建一个元素初始值都是提供的值的数组。
- en: '(Array only) [`zeroCreate : count:int -> ''T[]`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L467).
    Creates an array where the entries are initially the default value.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （仅限数组）[`zeroCreate：count：int->'T []`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L467)。
    创建一个初始值为默认值的数组。
- en: '`Array.create` is basically the same as `replicate` (although with a subtly
    different implementation!) but `replicate` was only implemented for `Array` in
    F# v4.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.create`基本上与`replicate`相同（尽管实现略有不同！），但`replicate`只在F# v4中为`Array`实现了。'
- en: Usage examples
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: '[PRE1]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that for `zeroCreate`, the target type must be known to the compiler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于`zeroCreate`，目标类型必须为编译器所知。
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 6\. Creating a new collection of known size with each element having a different
    value
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6\. 创建一个已知大小的新集合，每个元素都具有不同的值
- en: 'If you want to create a new collection of known size with each element having
    a potentially different value, you can choose one of three ways:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个每个元素可能有不同值的已知大小的新集合，你可以选择三种方式之一：
- en: '[`init : length:int -> initializer:(int -> ''T) -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L347).
    Creates a collection by calling the given generator on each index.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`init：length：int->initializer：（int->''T）->''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L347)。
    通过在每个索引上调用给定的生成器来创建集合。'
- en: For lists and arrays, you can also use the literal syntax such as `[1; 2; 3]`
    (lists) and `[|1; 2; 3|]` (arrays).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于列表和数组，你还可以使用文字语法，比如`[1; 2; 3]`（列表）和`[|1; 2; 3|]`（数组）。
- en: For lists and arrays and seqs, you can use the comprehension syntax `for ..
    in .. do .. yield`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于列表、数组和序列，你可以使用推导语法`for .. in .. do .. yield`。
- en: Usage examples
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: '[PRE2]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Literal syntax allows for an increment as well:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 字面语法也允许增量：
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The comprehension syntax is even more flexible because you can `yield` more
    than once:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 推导语法更加灵活，因为你可以`yield`不止一次：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'and it can also be used as a quick and dirty inline filter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用作快速而肮脏的内联过滤器：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Two other tricks:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个技巧：
- en: You can use `yield!` to return a list rather than a single value
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`yield!`来返回一个列表而不是单个值
- en: You can also use recursion
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用递归
- en: 'Here is an example of both tricks being used to count up to 10 by twos:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用这两个技巧来以两个为单位计数到10的示例：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '* * *'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 7\. Creating a new infinite collection
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7\. 创建一个新的无限集合
- en: If you want an infinite list, you have to use a seq rather than a list or array.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个无限列表，你必须使用序列而不是列表或数组。
- en: '[`initInfinite : initializer:(int -> ''T) -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L599).
    Generates a new sequence which, when iterated, will return successive elements
    by calling the given function.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`initInfinite : initializer:(int -> ''T) -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L599)。生成一个新序列，当迭代时，将通过调用给定函数返回连续的元素。'
- en: You can also use a seq comprehension with a recursive loop to generate an infinite
    sequence.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以使用带有递归循环的 seq 推导生成无限序列。
- en: Usage examples
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法示例
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '* * *'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 8\. Creating a new collection of indefinite size
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8\. 创建一个不定大小的新集合
- en: Sometimes you don't know how big the collection will be in advance. In this
    case you need a function that will keep adding elements until it gets a signal
    to stop. `unfold` is your friend here, and the "signal to stop" is whether you
    return a `None` (stop) or a `Some` (keep going).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你事先不知道集合的大小。在这种情况下，你需要一个函数，它会不断添加元素，直到收到停止的信号。在这里 `unfold` 是你的朋友，而 "停止的信号"
    是你返回 `None`（停止）还是 `Some`（继续）。
- en: '[`unfold : generator:(''State -> (''T * ''State) option) -> state:''State ->
    ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L846).
    Returns a collection that contains the elements generated by the given computation.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`unfold : generator:(''State -> (''T * ''State) option) -> state:''State ->
    ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L846)。返回包含给定计算生成的元素的集合。'
- en: Usage examples
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法示例
- en: 'This example reads from the console in a loop until an empty line is entered:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在循环中从控制台读取，直到输入空行为止：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`unfold` requires that a state be threaded through the generator. You can ignore
    it (as in the `ReadLine` example above), or you can use it to keep track of what
    you have done so far. For example, you can create a Fibonacci series generator
    using `unfold`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`unfold` 要求通过生成器传递状态。你可以忽略它（就像上面的 `ReadLine` 示例一样），或者你可以使用它来跟踪到目前为止你所做的事情。例如，你可以使用
    `unfold` 创建一个斐波那契数列生成器：'
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '* * *'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 9\. Working with one list
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9\. 处理一个列表
- en: If you are working with one list and...
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理一个列表，并且...
- en: If you want to get an element at a known position, go to [section 10](#10)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要获取已知位置的元素，请转到[第 10 节](#10)。
- en: If you want to get one element by searching, go to [section 11](#11)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要通过搜索获取一个元素，请转到[第 11 节](#11)。
- en: If you want to get a subset of the collection, go to [section 12](#12)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要获取集合的子集，请转到[第 12 节](#12)。
- en: If you want to partition, chunk, or group a collection into smaller collections,
    go to [section 13](#13)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将集合分割、划分或分组成更小的集合，请转到[第 13 节](#13)。
- en: If you want to aggregate or summarize the collection into a single value, go
    to [section 14](#14)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将集合聚合或汇总为单个值，请转到[第 14 节](#14)。
- en: If you want to change the order of the elements, go to [section 15](#15)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要改变元素的顺序，请转到[第 15 节](#15)。
- en: If you want to test the elements in the collection, go to [section 16](#16)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要测试集合中的元素，请转到[第 16 节](#16)。
- en: If you want to transform each element to something different, go to [section
    17](#17)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将每个元素转换为不同的东西，请转到[第 17 节](#17)。
- en: If you want to iterate over each element, go to [section 18](#18)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要遍历每个元素，请转到[第 18 节](#18)。
- en: If you want to thread state through an iteration, go to [section 19](#19)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要在迭代中传递状态，请转到[第 19 节](#19)。
- en: If you need to know the index of each element while you are iterating or mapping,
    go to [section 20](#20)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要在迭代或映射时知道每个元素的索引，请转到[第 20 节](#20)。
- en: If you want to transform the whole collection to a different collection type,
    go to [section 21](#21)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将整个集合转换为不同的集合类型，请转到[第 21 节](#21)。
- en: If you want to change the behaviour of the collection as a whole, go to [section
    22](#22)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要改变集合的整体行为，请转到[第 22 节](#22)。
- en: If you want to mutate the collection in place, go to [section 27](#27)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要就地改变集合，请转到[第 27 节](#27)。
- en: If you want to use a lazy collection with an IDisposable, go to [section 28](#28)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要使用带有 IDisposable 的惰性集合，请转到[第 28 节](#28)。
- en: '* * *'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 10\. Getting an element at a known position
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10\. 获取已知位置的元素
- en: 'The following functions get a element in the collection by position:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数按位置在集合中获取元素：
- en: '[`head : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L333).
    Returns the first element of the collection.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`head : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L333)。返回集合的第一个元素。'
- en: '[`last : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L398).
    Returns the last element of the collection.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`last : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L398).
    返回集合的最后一个元素。'
- en: '[`item : index:int -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L520).
    Indexes into the collection. The first element has index 0.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`item : index:int -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L520).
    索引到集合中。第一个元素的索引为0。'
- en: 'NOTE: Avoid using `nth` and `item` for lists and sequences. They are not designed
    for random access, and so they will be slow in general.'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：避免对列表和序列使用`nth`和`item`。它们不适用于随机访问，因此通常会很慢。
- en: '[`nth : list:''T list -> index:int -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L520).
    The older version of `item`. NOTE: Deprecated in v4 -- use `item` instead.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`nth : list:''T list -> index:int -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L520).
    `item`的旧版本。注意：在v4中已弃用--请使用`item`代替。'
- en: '(Array only) [`get : array:''T[] -> index:int -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L220).
    Yet another version of `item`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '（仅适用于数组）[`get : array:''T[] -> index:int -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L220).
    `item`的另一个版本。'
- en: '[`exactlyOne : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L165).
    Returns the only element of the collection.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`exactlyOne : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L165).
    返回集合的唯一元素。'
- en: But what if the collection is empty? Then `head` and `last` will fail with an
    exception (ArgumentException).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果集合为空怎么办？那么`head`和`last`将会因异常（ArgumentException）而失败。
- en: And if the index is not found in the collection? Then another exception again
    (ArgumentException for lists, IndexOutOfRangeException for arrays).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引在集合中找不到怎么办？那么又会出现另一个异常（对于列表是ArgumentException，对于数组是IndexOutOfRangeException）。
- en: 'I would therefore recommend that you avoid these functions in general and use
    the `tryXXX` equivalents below:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议您一般情况下避免使用这些函数，而使用下面的`tryXXX`等价函数：
- en: '[`tryHead : list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L775).
    Returns the first element of the collection, or None if the collection is empty.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tryHead : list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L775).
    返回集合的第一个元素，如果集合为空则返回None。'
- en: '[`tryLast : list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L411).
    Returns the last element of the collection, or None if the collection is empty.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tryLast : list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L411).
    返回集合的最后一个元素，如果集合为空则返回None。'
- en: '[`tryItem : index:int -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L827).
    Indexes into the collection, or None if the index is not valid.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tryItem : index:int -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L827).
    索引到集合中，如果索引无效则返回None。'
- en: Usage examples
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As noted, the `item` function should be avoided for lists. For example, if
    you want to process each item in a list, and you come from an imperative background,
    you might write a loop with something like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应避免使用`item`函数处理列表。例如，如果您想要处理列表中的每个元素，并且您来自命令式编程背景，您可能会写出类似以下循环的代码：
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Don''t do that! Use something like `map` instead. It''s both more concise and
    more efficient:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做！使用类似`map`的东西。它既更简洁又更高效：
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '* * *'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 11\. Getting an element by searching
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11\. 通过搜索获取元素
- en: 'You can search for an element or its index using `find` and `findIndex`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`find`和`findIndex`来搜索元素或其索引：
- en: '[`find : predicate:(''T -> bool) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L201).
    Returns the first element for which the given function returns true.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`find : predicate:(''T -> bool) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L201).
    返回给定函数返回true的第一个元素。'
- en: '[`findIndex : predicate:(''T -> bool) -> list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L222).
    Returns the index of the first element for which the given function returns true.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`findIndex : predicate:(''T -> bool) -> list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L222)。返回使给定函数返回
    true 的第一个元素的索引。'
- en: 'And you can also search backwards:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你也可以反向搜索：
- en: '[`findBack : predicate:(''T -> bool) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L211).
    Returns the last element for which the given function returns true.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`findBack : predicate:(''T -> bool) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L211)。返回使给定函数返回
    true 的最后一个元素。'
- en: '[`findIndexBack : predicate:(''T -> bool) -> list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L233).
    Returns the index of the last element for which the given function returns true.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`findIndexBack : predicate:(''T -> bool) -> list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L233)。返回使给定函数返回
    true 的最后一个元素的索引。'
- en: But what if the item cannot be found? Then these will fail with an exception
    (`KeyNotFoundException`).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果项目找不到呢？那么这些将会因为异常（`KeyNotFoundException`）而失败。
- en: 'I would therefore recommend that, as with `head` and `item`, you avoid these
    functions in general and use the `tryXXX` equivalents below:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议，与`head`和`item`一样，你一般应避免使用这些函数，而使用下面的`tryXXX`等价函数：
- en: '[`tryFind : predicate:(''T -> bool) -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L800).
    Returns the first element for which the given function returns true, or None if
    no such element exists.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tryFind : predicate:(''T -> bool) -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L800)。返回使给定函数返回
    true 的第一个元素，如果不存在则返回 None。'
- en: '[`tryFindBack : predicate:(''T -> bool) -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L809).
    Returns the last element for which the given function returns true, or None if
    no such element exists.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tryFindBack : predicate:(''T -> bool) -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L809)。返回最后一个使给定函数返回
    true 的元素，如果不存在则返回 None。'
- en: '[`tryFindIndex : predicate:(''T -> bool) -> list:''T list -> int option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L819).
    Returns the index of the first element for which the given function returns true,
    or None if no such element exists.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tryFindIndex : predicate:(''T -> bool) -> list:''T list -> int option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L819)。返回使给定函数返回
    true 的第一个元素的索引，如果不存在则返回 None。'
- en: '[`tryFindIndexBack : predicate:(''T -> bool) -> list:''T list -> int option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L837).
    Returns the index of the last element for which the given function returns true,
    or None if no such element exists.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tryFindIndexBack : predicate:(''T -> bool) -> list:''T list -> int option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L837)。返回最后一个使给定函数返回
    true 的元素的索引，如果不存在则返回 None。'
- en: If you are doing a `map` before a `find` you can often combine the two steps
    into a single one using `pick` (or better, `tryPick`). See below for a usage example.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`find`之前做了一个`map`，通常可以将这两个步骤合并成一个使用`pick`（或更好的是`tryPick`）。见下面的用法示例。
- en: '[`pick : chooser:(''T -> ''U option) -> list:''T list -> ''U`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L561).
    Applies the given function to successive elements, returning the first result
    where the chooser function returns Some.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`pick : chooser:(''T -> ''U option) -> list:''T list -> ''U`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L561)。将给定函数应用于连续的元素，返回
    chooser 函数返回 Some 的第一个结果。'
- en: '[`tryPick : chooser:(''T -> ''U option) -> list:''T list -> ''U option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L791).
    Applies the given function to successive elements, returning the first result
    where the chooser function returns Some, or None if no such element exists.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tryPick : chooser:(''T -> ''U option) -> list:''T list -> ''U option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L791)。对连续的元素应用给定的函数，返回选择器函数返回
    Some 的第一个结果，如果不存在这样的元素，则返回 None。'
- en: Usage examples
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法示例
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With `pick`, rather than returning a bool, you return an option:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pick`，而不是返回布尔值，你返回一个选项：
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Pick vs. Find
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择 vs. 查找
- en: That 'pick' function might seem unnecessary, but it is useful when dealing with
    functions that return options.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '''pick'' 函数可能看起来是不必要的，但在处理返回选项的函数时非常有用。'
- en: For example, say that there is a function `tryInt` that parses a string and
    returns `Some int` if the string is a valid int, otherwise `None`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有一个函数 `tryInt`，它解析一个字符串并在字符串是有效的 int 时返回 `Some int`，否则返回 `None`。
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And now say that we want to find the first valid int in a list. The crude way
    would be:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '现在假设我们想要在列表中找到第一个有效的 int。粗糙的方法是： '
- en: map the list using `tryInt`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tryInt` 映射列表
- en: find the first one that is a `Some` using `find`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `find` 找到第一个 `Some`。
- en: get the value from inside the option using `Option.get`
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Option.get` 从选项内获取值
- en: 'The code might look something like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能是这样的：
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But `pick` will do all these steps at once! So the code becomes much simpler:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `pick` 将一次完成所有这些步骤！所以代码变得更简单：
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you want to return many elements in the same way as `pick`, consider using
    `choose` (see [section 12](#12)).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以与 `pick` 相同的方式返回多个元素，请考虑使用 `choose`（见 [第 12 节](#12)）。
- en: '* * *'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 12\. Getting a subset of elements from a collection
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12\. 从集合中获取一部分元素
- en: The previous section was about getting one element. How can you get more than
    one element? Well you're in luck! There's lots of functions to choose from.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节是关于获取一个元素的。你怎样才能获取多个元素？好消息！有很多函数供选择。
- en: 'To extract elements from the front, use one of these:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要从前面提取元素，请使用以下之一：
- en: '[`take: count:int -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L746).
    Returns the first N elements of the collection.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`take: count:int -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L746)。返回集合的前
    N 个元素。'
- en: '[`takeWhile: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L756).
    Returns a collection that contains all elements of the original collection while
    the given predicate returns true, and then returns no further elements.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`takeWhile: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L756)。返回包含原始集合的所有元素的集合，当给定的谓词返回
    true 时，然后不再返回元素。'
- en: '[`truncate: count:int -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L782).
    Returns at most N elements in a new collection.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`truncate: count:int -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L782)。在新集合中返回最多
    N 个元素。'
- en: 'To extract elements from the rear, use one of these:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要从后面提取元素，请使用以下之一：
- en: '[`skip: count:int -> list: ''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L644).
    Returns the collection after removing the first N elements.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`skip: count:int -> list: ''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L644)。删除前
    N 个元素后返回集合。'
- en: '[`skipWhile: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L652).
    Bypasses elements in a collection while the given predicate returns true, and
    then returns the remaining elements of the collection.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`skipWhile: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L652)。在给定谓词返回
    true 的情况下跳过集合中的元素，然后返回集合的剩余元素。'
- en: '[`tail: list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L730).
    Returns the collection after removing the first element.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tail: list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L730)。删除第一个元素后返回集合。'
- en: 'To extract other subsets of elements, use one of these:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取其他元素子集，请使用以下之一：
- en: '[`filter: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L241).
    Returns a new collection containing only the elements of the collection for which
    the given function returns true.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`filter: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L241)。返回一个只包含给定函数返回true的集合元素的新集合。'
- en: '[`except: itemsToExclude:seq<''T> -> list:''T list -> ''T list when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L155).
    Returns a new collection with the distinct elements of the input collection which
    do not appear in the itemsToExclude sequence, using generic hash and equality
    comparisons to compare values.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`except: itemsToExclude:seq<''T> -> list:''T list -> ''T list when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L155)。返回一个新的集合，其中包含输入集合中不在itemsToExclude序列中出现的不同元素，使用通用哈希和相等比较来比较值。'
- en: '[`choose: chooser:(''T -> ''U option) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L55).
    Applies the given function to each element of the collection. Returns a collection
    comprised of the elements where the function returns Some.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`choose: chooser:(''T -> ''U option) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L55)。将给定函数应用于集合的每个元素。返回由函数返回Some的元素组成的集合。'
- en: '[`where: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L866).
    Returns a new collection containing only the elements of the collection for which
    the given predicate returns true. NOTE: "where" is a synonym for "filter".'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`where: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L866)。返回一个只包含给定谓词返回true的集合元素的新集合。注意："where"是"filter"的同义词。'
- en: '(Array only) `sub : ''T [] -> int -> int -> ''T []`. Creates an array that
    contains the supplied subrange, which is specified by starting index and length.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(仅适用于数组) `sub : ''T [] -> int -> int -> ''T []`。创建一个包含指定子范围的数组，该子范围由起始索引和长度指定。'
- en: 'You can also use slice syntax: `myArray.[2..5]`. See below for examples.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您���可以使用切片语法：`myArray.[2..5]`。请参见下面的示例。
- en: 'To reduce the list to distinct elements, use one of these:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要将列表减少为不同的元素，请使用以下之一：
- en: '[`distinct: list:''T list -> ''T list when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L107).
    Returns a collection that contains no duplicate entries according to generic hash
    and equality comparisons on the entries.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`distinct: list:''T list -> ''T list when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L107)。根据条目上的通用哈希和相等比较，返回一个不包含重复条目的集合。'
- en: '[`distinctBy: projection:(''T -> ''Key) -> list:''T list -> ''T list when ''Key
    : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L118).
    Returns a collection that contains no duplicate entries according to the generic
    hash and equality comparisons on the keys returned by the given key-generating
    function.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`distinctBy: projection:(''T -> ''Key) -> list:''T list -> ''T list when ''Key
    : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L118)。根据给定的生成键函数返回的键的通用哈希和相等比较，返回一个不包含重复条目的集合。'
- en: Usage examples
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'Taking elements from the front:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面取元素：
- en: '[PRE18]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Taking elements from the rear:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从后面取元素：
- en: '[PRE19]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To extract other subsets of elements:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取其他元素子集：
- en: '[PRE20]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To extract a slice:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取一个切片：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that slicing on lists can be slow, because they are not random access.
    Slicing on arrays is fast however.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在列表上进行切片可能会很慢，因为它们不是随机访问的。但在数组上进行切片是快速的。
- en: 'To extract the distinct elements:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取不同的元素：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Choose vs. Filter
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Choose vs. Filter
- en: As with `pick`, the `choose` function might seem awkward, but it is useful when
    dealing with functions that return options.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pick`一样，`choose`函数可能看起来很笨拙，但在处理返回选项的函数时很有用。
- en: In fact, `choose` is to `filter` as [`pick` is to `find`](#pick-vs-find), Rather
    than using a boolean filter, the signal is `Some` vs. `None`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`choose`就像[`pick`对`find`](#pick-vs-find)一样，而不是使用布尔过滤器，信号是`Some`与`None`。
- en: As before, say that there is a function `tryInt` that parses a string and returns
    `Some int` if the string is a valid int, otherwise `None`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，假设有一个函数`tryInt`，它解析一个字符串并在字符串是有效整数时返回`Some int`，否则返回`None`。
- en: '[PRE23]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now say that we want to find all the valid ints in a list. The crude way
    would be:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想在列表中找到所有有效的整数。粗糙的方法可能是：
- en: map the list using `tryInt`
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tryInt`映射列表
- en: filter to only include the ones that are `Some`
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤只包含`Some`的元素
- en: get the value from inside each option using `Option.get`
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Option.get`从每个选项内获取值
- en: 'The code might look something like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能如下所示：
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But `choose` will do all these steps at once! So the code becomes much simpler:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但`choose`会一次完成所有这些步骤！所以代码变得简单得多：
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you already have a list of options, you can filter and return the "Some"
    in one step by passing `id` into `choose`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个选项列表，可以通过将`id`传递给`choose`来一步过滤并返回“Some”：
- en: '[PRE26]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you want to return the first element in the same way as `choose`, consider
    using `pick` (see [section 11](#11)).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以与`choose`相同的方式返回第一个元素，请考虑使用`pick`（参见[第11节](#11)）。
- en: If you want to do a similar action as `choose` but for other wrapper types (such
    as a Success/Failure result), there is [a discussion here](elevated-world-5.html).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想执行类似于`choose`但适用于其他包装类型（如成功/失败结果）的操作，可以参考[这里的讨论](elevated-world-5.html)。
- en: '* * *'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 13\. Partitioning, chunking and grouping
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13\. 分区、分块和分组
- en: 'There are lots of different ways to split a collection! Have a look at the
    usage examples to see the differences:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法来拆分集合！查看用法示例以查看差异：
- en: '[`chunkBySize: chunkSize:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L63).
    Divides the input collection into chunks of size at most `chunkSize`.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`chunkBySize: chunkSize:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L63)。将输入集合分成大小最多为`chunkSize`的块。'
- en: '[`groupBy : projection:(''T -> ''Key) -> list:''T list -> (''Key * ''T list)
    list when ''Key : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L325).
    Applies a key-generating function to each element of a collection and yields a
    list of unique keys. Each unique key contains a list of all elements that match
    to this key.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`groupBy : projection:(''T -> ''Key) -> list:''T list -> (''Key * ''T list)
    list when ''Key : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L325)。对集合中的每个元素应用生成键的函数，并产生一组唯一键。每个唯一键包含与该键匹配的所有元素的列表。'
- en: '[`pairwise: list:''T list -> (''T * ''T) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L541).
    Returns a collection of each element in the input collection and its predecessor,
    with the exception of the first element which is only returned as the predecessor
    of the second element.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`pairwise: list:''T list -> (''T * ''T) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L541)。返回输入集合中每个元素及其前一个元素的集合，第一个元素除外，仅作为第二个元素的前身返回。'
- en: '(Except Seq) [`partition: predicate:(''T -> bool) -> list:''T list -> (''T
    list * ''T list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L551).
    Splits the collection into two collections, containing the elements for which
    the given predicate returns true and false respectively.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(除了Seq) [`partition: predicate:(''T -> bool) -> list:''T list -> (''T list
    * ''T list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L551)。将集合分成两个集合，一个包含给定谓词返回true的元素，另一个包含返回false的元素。'
- en: '(Except Seq) [`splitAt: index:int -> list:''T list -> (''T list * ''T list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L688).
    Splits a collection into two collections at the given index.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(除了Seq) [`splitAt: index:int -> list:''T list -> (''T list * ''T list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L688)。在给定索引处将集合分成两个集合。'
- en: '[`splitInto: count:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L137).
    Splits the input collection into at most count chunks.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`splitInto: count:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L137)。将输入集合分成最多count个块。'
- en: '[`windowed : windowSize:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L875).
    Returns a list of sliding windows containing elements drawn from the input collection.
    Each window is returned as a fresh collection. Unlike `pairwise` the windows are
    collections, not tuples.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`windowed : windowSize:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L875)。返回一个包含从输入集合中提取的元素的滑动窗口列表。每个窗口都作为一个新的集合返回。与`pairwise`不同，窗口是集合，而不是元组。'
- en: Usage examples
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法示例
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'All the functions other than `splitAt` and `pairwise` handle edge cases gracefully:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`splitAt`和`pairwise`之外的所有函数都优雅地处理边缘情况：
- en: '[PRE28]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '* * *'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 14\. Aggregating or summarizing a collection
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14\. 聚合或总结一个集合
- en: 'The most generic way to aggregate the elements in a collection is to use `reduce`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合集合中元素的最通用方式是使用`reduce`：
- en: '[`reduce : reduction:(''T -> ''T -> ''T) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L584).
    Apply a function to each element of the collection, threading an accumulator argument
    through the computation.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`reduce : reduction:(''T -> ''T -> ''T) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L584)。对集合中的每个元素应用一个函数，通过计算传递一个累加器参数。'
- en: '[`reduceBack : reduction:(''T -> ''T -> ''T) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L595).
    Applies a function to each element of the collection, starting from the end, threading
    an accumulator argument through the computation.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`reduceBack : reduction:(''T -> ''T -> ''T) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L595)。对集合中的每个元素应用一个函数，从末尾开始，通过计算传递一个累加器参数。'
- en: 'and there are specific versions of `reduce` for frequently used aggregations:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经常使用的聚合操作，有特定版本的`reduce`：
- en: '[`max : list:''T list -> ''T when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L482).
    Return the greatest of all elements of the collection, compared via Operators.max.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`max : list:''T list -> ''T when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L482)。返回集合中所有元素中的最大值，通过`Operators.max`比较。'
- en: '[`maxBy : projection:(''T -> ''U) -> list:''T list -> ''T when ''U : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L492).
    Returns the greatest of all elements of the collection, compared via Operators.max
    on the function result.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`maxBy : projection:(''T -> ''U) -> list:''T list -> ''T when ''U : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L492)。返回集合中所有元素中的最大值，通过函数结果上的`Operators.max`比较。'
- en: '[`min : list:''T list -> ''T when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L501).
    Returns the lowest of all elements of the collection, compared via Operators.min.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`min : list:''T list -> ''T when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L501)。返回集合中所有元素中的最小值，通过`Operators.min`比较。'
- en: '[`minBy : projection:(''T -> ''U) -> list:''T list -> ''T when ''U : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L511).
    Returns the lowest of all elements of the collection, compared via Operators.min
    on the function result.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`minBy : projection:(''T -> ''U) -> list:''T list -> ''T when ''U : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L511)。返回集合中所有元素中的最小值，通过函数结果上的`Operators.min`比较。'
- en: '[`sum : list:''T list -> ''T when ''T has static members (+) and Zero`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L711).
    Returns the sum of the elements in the collection.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sum : list:''T list -> ''T when ''T has static members (+) and Zero`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L711)。返回集合中元素的总和。'
- en: '[`sumBy : projection:(''T -> ''U) -> list:''T list -> ''U when ''U has static
    members (+) and Zero`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L720).
    Returns the sum of the results generated by applying the function to each element
    of the collection.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sumBy : projection:(''T -> ''U) -> list:''T list -> ''U when ''U has static
    members (+) and Zero`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L720)。返回通过将函数应用于集合中的每个元素生成的结果的总和。'
- en: '[`average : list:''T list -> ''T when ''T has static members (+) and Zero and
    DivideByInt`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L30).
    Returns the average of the elements in the collection. Note that a list of ints
    cannot be averaged -- they must be cast to floats or decimals.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`average : list:''T list -> ''T when ''T has static members (+) and Zero and
    DivideByInt`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L30)。返回集合中元素的平均值。请注意，整数列表无法计算平均值
    - 它们必须转换为浮点数或十进制数。'
- en: '[`averageBy : projection:(''T -> ''U) -> list:''T list -> ''U when ''U has
    static members (+) and Zero and DivideByInt`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L43).
    Returns the average of the results generated by applying the function to each
    element of the collection.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`averageBy : projection:(''T -> ''U) -> list:''T list -> ''U when ''U has
    static members (+) and Zero and DivideByInt`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L43)。返回将该函数应用于集合中每个元素所生成的结果的平均值。'
- en: 'Finally there are some counting functions:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些计数函数：
- en: '[`length: list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L404).
    Returns the length of the collection.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`length: list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L404)。返回集合的长度。'
- en: '[`countBy : projection:(''T -> ''Key) -> list:''T list -> (''Key * int) list
    when ''Key : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L129).
    Applies a key-generating function to each element and returns a collection yielding
    unique keys and their number of occurrences in the original collection.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`countBy : projection:(''T -> ''Key) -> list:''T list -> (''Key * int) list
    when ''Key : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L129)。对每个元素应用生成键的函数，并返回在原始集合中生成唯一键及其出现次数的集合。'
- en: Usage examples
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: '`reduce` is a variant of `fold` without an initial state -- see [section 19](#19)
    for more on `fold`. One way to think of it is just inserting a operator between
    each element.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`是没有初始状态的`fold`的变体 - 有关`fold`的更多信息，请参阅[第19节](#19)。一种思考方法是在每个元素之间插入一个操作符。'
- en: '[PRE29]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: is the same as
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与...相同
- en: '[PRE30]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s another example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个例子：
- en: '[PRE31]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Some ways of combining elements depend on the order of combining, and so there
    are two variants of "reduce":'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一些元素组合方式取决于组合顺序，因此有两个“reduce”的变体：
- en: '`reduce` moves forward through the list.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`向列表前进。'
- en: '`reduceBack`, not surprisingly, moves backwards through the list.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduceBack`，不出所料，向列表后退移动。'
- en: 'Here''s a demonstration of the difference. First `reduce`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是区别的演示。首先是`reduce`：
- en: '[PRE32]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the *same* combining function with `reduceBack` produces a different
    result! It looks like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*相同*的组合函数与`reduceBack`产生不同的结果！它看起来像这样：
- en: '[PRE33]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Again, see [section 19](#19) for a more detailed discussion of the related functions
    `fold` and `foldBack`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有关相关函数`fold`和`foldBack`的更详细讨论，请参阅[第19节](#19)。
- en: The other aggregation functions are much more straightforward.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 其他聚合函数要简单得多。
- en: '[PRE34]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Most of the aggregation functions do not like empty lists! You might consider
    using one of the `fold` functions to be safe -- see [section 19](#19).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数聚合函数不喜欢空列表！您可能考虑使用其中一个`fold`函数以确保安全 - 有关详细信息，请参阅[第19节](#19)。
- en: '[PRE35]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '* * *'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 15\. Changing the order of the elements
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15\. 改变元素的顺序
- en: 'You can change the order of the elements using reversing, sorting and permuting.
    All of the following return *new* collections:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用反转、排序和置换更改元素的顺序。所有以下操作都返回*新*的集合：
- en: '[`rev: list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L608).
    Returns a new collection with the elements in reverse order.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`rev: list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L608)。返回顺序相反的新集合。'
- en: '[`sort: list:''T list -> ''T list when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L678).
    Sorts the given collection using Operators.compare.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sort: list:''T list -> ''T list when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L678)。使用Operators.compare对给定的集合进行排序。'
- en: '[`sortDescending: list:''T list -> ''T list when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L705).
    Sorts the given collection in descending order using Operators.compare.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sortDescending: list:''T list -> ''T list when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2a41096eec8a/src/fsharp/FSharp.Core/list.fsi#L705)。使用
    Operators.compare 将给定集合按降序排序。'
- en: '[`sortBy: projection:(''T -> ''Key) -> list:''T list -> ''T list when ''Key
    : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L670).
    Sorts the given collection using keys given by the given projection. Keys are
    compared using Operators.compare.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sortBy: projection:(''T -> ''Key) -> list:''T list -> ''T list when ''Key
    : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L670)。使用给定投影的键对给定集合进行排序。键使用
    Operators.compare 进行比较。'
- en: '[`sortByDescending: projection:(''T -> ''Key) -> list:''T list -> ''T list
    when ''Key : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L697).
    Sorts the given collection in descending order using keys given by the given projection.
    Keys are compared using Operators.compare.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sortByDescending: projection:(''T -> ''Key) -> list:''T list -> ''T list
    when ''Key : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L697)。使用给定投影的键按降序对给定集合进行排序。键使用
    Operators.compare 进行比较。'
- en: '[`sortWith: comparer:(''T -> ''T -> int) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L661).
    Sorts the given collection using the given comparison function.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sortWith: comparer:(''T -> ''T -> int) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L661)。使用给定的比较函数对给定集合进行排序。'
- en: '[`permute : indexMap:(int -> int) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L570).
    Returns a collection with all elements permuted according to the specified permutation.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`permute : indexMap:(int -> int) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L570)。根据指定的排列返回具有所有元素的集合。'
- en: 'And there are also some array-only functions that sort in place:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些仅适用于数组的就地排序函数。
- en: '(Array only) [`sortInPlace: array:''T[] -> unit when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L874).
    Sorts the elements of an array by mutating the array in-place. Elements are compared
    using Operators.compare.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(仅适用于数组) [`sortInPlace: array:''T[] -> unit when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L874)。通过就地变异数组对数组的元素进行排序。元素使用
    Operators.compare 进行比较。'
- en: '(Array only) [`sortInPlaceBy: projection:(''T -> ''Key) -> array:''T[] -> unit
    when ''Key : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L858).
    Sorts the elements of an array by mutating the array in-place, using the given
    projection for the keys. Keys are compared using Operators.compare.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(仅适用于数组) [`sortInPlaceBy: projection:(''T -> ''Key) -> array:''T[] -> unit
    when ''Key : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L858)。通过就地变异数组，使用给定的投影作为键对数组的元素进行排序。键使用
    Operators.compare 进行比较。'
- en: '(Array only) [`sortInPlaceWith: comparer:(''T -> ''T -> int) -> array:''T[]
    -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L867).
    Sorts the elements of an array by mutating the array in-place, using the given
    comparison function as the order.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(仅适用于数组) [`sortInPlaceWith: comparer:(''T -> ''T -> int) -> array:''T[] ->
    unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L867)。通过就地变异数组，使用给定的比较函数作为顺序来对数组的元素进行排序。'
- en: Usage examples
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: '[PRE36]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '* * *'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 16\. Testing the elements of a collection
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16\. 测试集合的元素
- en: These set of functions all return true or false.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数集合都返回 true 或 false。
- en: '[`contains: value:''T -> source:''T list -> bool when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L97).
    Tests if the collection contains the specified element.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`contains: value:''T -> source:''T list -> bool when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L97)。测试集合是否包含指定的元素。'
- en: '[`exists: predicate:(''T -> bool) -> list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L176).
    Tests if any element of the collection satisfies the given predicate.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`exists: predicate:(''T -> bool) -> list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L176)。测试集合中是否有任何元素满足给定的条件。'
- en: '[`forall: predicate:(''T -> bool) -> list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L299).
    Tests if all elements of the collection satisfy the given predicate.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`forall: predicate:(''T -> bool) -> list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L299)。测试集合中的所有元素是否满足给定的条件。'
- en: '[`isEmpty: list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L353).
    Returns true if the collection contains no elements, false otherwise.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`isEmpty: list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L353)。如果集合不包含任何元素，则返回
    true，否则返回 false。'
- en: Usage examples
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法示例
- en: '[PRE37]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '* * *'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 17\. Transforming each element to something different
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17\. 将每个元素转换为不同的内容
- en: I sometimes like to think of functional programming as "transformation-oriented
    programming", and `map` (aka `Select` in LINQ) is one of the most fundamental
    ingredients for this approach. In fact, I have devoted a whole series to it [here](elevated-world.html).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我有时喜欢把函数式编程看作是 "转换导向编程"，而 `map`（在 LINQ 中也称为 `Select`）是这种方法中最基本的组成部分之一。事实上，我已经专门为它制作了一个完整的系列[这里](elevated-world.html)。
- en: '[`map: mapping:(''T -> ''U) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L419).
    Builds a new collection whose elements are the results of applying the given function
    to each of the elements of the collection.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`map: mapping:(''T -> ''U) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L419)。构建一个新的集合，其中的元素是将给定函数应用于集合中每个元素的结果。'
- en: Sometimes each element maps to a list, and you want to flatten out all the lists.
    For this case, use `collect` (aka `SelectMany` in LINQ).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有时每个元素都映射到一个列表，而你想要展平所有的列表。对于这种情况，使用 `collect`（在 LINQ 中也称为 `SelectMany`）。
- en: '[`collect: mapping:(''T -> ''U list) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L70).
    For each element of the list, applies the given function. Concatenates all the
    results and return the combined list.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`collect: mapping:(''T -> ''U list) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L70)。对列表的每个元素应用给定的函数。连接所有结果并返回组合列表。'
- en: 'Other transformation functions include:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 其他转换函数包括：
- en: '`choose` in [section 12](#12) is a map and option filter combined.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 12 节](#12) 中的 `choose` 是一个结合了映射和选项过滤的函数。'
- en: '(Seq only) [`cast: source:IEnumerable -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L599).
    Wraps a loosely-typed `System.Collections` sequence as a typed sequence.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '（仅 Seq）[`cast: source:IEnumerable -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L599)。将一个松散类型的
    `System.Collections` 序列包装成一个类型化的序列。'
- en: Usage examples
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法示例
- en: 'Here are some examples of using `map` in the conventional way, as a function
    that accepts a list and a mapping function and returns a new transformed list:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用 `map` 的传统方式的示例，作为一个接受列表和映射函数并返回一个新的转换列表的函数：
- en: '[PRE38]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can also think of `map` as a *function transformer*. It turns an element-to-element
    function into a list-to-list function.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以把 `map` 看作是一个 *函数转换器*。它将一个元素到元素的函数转换成一个列表到列表的函数。
- en: '[PRE39]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`collect` works to flatten lists. If you already have a list of lists, you
    can use `collect` with `id` to flatten them.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect` 用于展开列表。如果你已经有一个列表的列表，你可以使用 `collect` 和 `id` 将它们展平。'
- en: '[PRE40]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Seq.cast
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Seq.cast
- en: Finally, `Seq.cast` is useful when working with older parts of the BCL that
    have specialized collection classes rather than generics.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当使用旧版本的 BCL 时，`Seq.cast` 是很有用的，因为它具有专门的集合类而不是泛型。
- en: For example, the Regex library has this problem, and so the code below won't
    compile because `MatchCollection` is not an `IEnumerable<T>`
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Regex 库就有这个问题，所以下面的代码不会编译，因为 `MatchCollection` 不是一个 `IEnumerable<T>`。
- en: '[PRE41]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The fix is to cast `MatchCollection` to a `Seq<Match>` and then the code will
    work nicely:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是将 `MatchCollection` 转换为 `Seq<Match>`，然后代码将很好地工作：
- en: '[PRE42]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '* * *'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 18\. Iterating over each element
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18\. 遍历每个元素
- en: Normally, when processing a collection, we transform each element to a new value
    using `map`. But occasionally we need to process all the elements with a function
    which *doesn't* produce a useful value (a "unit function").
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在处理集合时，我们使用`map`将每个元素转换为新值。但偶尔我们需要使用一个*不*产生有用值（称为“单位函数”）的函数来处理所有元素。
- en: '[`iter: action:(''T -> unit) -> list:''T list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L367).
    Applies the given function to each element of the collection.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`iter：action:(''T -> unit) -> list:''T list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L367)。将给定的函数应用于集合的每个元素。'
- en: Alternatively, you can use a for-loop. The expression inside a for-loop *must*
    return `unit`.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以使用for循环。for循环中的表达式*必须*返回`unit`。
- en: Usage examples
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法示例
- en: 'The most common examples of unit functions are all about side-effects: printing
    to the console, updating a database, putting a message on a queue, etc. For the
    examples below, I will just use `printfn` as my unit function.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 单位函数的最常见示例都涉及副作用：向控制台打印、更新数据库、将消息放入队列等。对于下面的示例，我将使用`printfn`作为我的单位函数。
- en: '[PRE43]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As noted above, the expression inside an `iter` or for-loop must return unit.
    In the following examples, we try to add 1 to the element, and get a compiler
    error:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，在`iter`或for循环中的表达式必须返回`unit`。在以下示例中，我们尝试将1添加到元素中，然后得到编译器错误：
- en: '[PRE44]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you are sure that this is not a logic bug in your code, and you want to
    get rid of this error, you can pipe the results into `ignore`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确信这不是代码中的逻辑错误，并且想要消除此错误，可以将结果管道传递到`ignore`：
- en: '[PRE45]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '* * *'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 19\. Threading state through an iteration
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19\. 在迭代中传递状态
- en: The `fold` function is the most basic and powerful function in the collection
    arsenal. All other functions (other than generators like `unfold`) can be written
    in terms of it. See the examples below.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold`函数是集合库中最基本且功能最强大的函数。除了生成器（如`unfold`）之外，所有其他函数都可以用它来编写。请参阅下面的示例。'
- en: '[`fold<''T,''State> : folder:(''State -> ''T -> ''State) -> state:''State ->
    list:''T list -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L254).
    Applies a function to each element of the collection, threading an accumulator
    argument through the computation.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fold<''T,''State>：folder:(''State -> ''T -> ''State) -> state:''State ->
    list:''T list -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L254)。将函数应用于集合的每个元素，通过计算将累加器参数线程化。'
- en: '[`foldBack<''T,''State> : folder:(''T -> ''State -> ''State) -> list:''T list
    -> state:''State -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L276).
    Applies a function to each element of the collection, starting from the end, threading
    an accumulator argument through the computation. WARNING: Watch out for using
    `Seq.foldBack` on infinite lists! The runtime will laugh at you ha ha ha and then
    go very quiet.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`foldBack<''T,''State>：folder:(''T -> ''State -> ''State) -> list:''T list
    -> state:''State -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L276)。将函数应用于集合的每个元素，从末尾开始，通过计算将累加器参数线程化。警告：注意在无限列表上使用`Seq.foldBack`！运行时会嘲笑您哈哈哈，然后变得非常安静。'
- en: The `fold` function is often called "fold left" and `foldBack` is often called
    "fold right".
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold`函数通常称为“折叠左侧”，`foldBack`通常称为“折叠右侧”。'
- en: The `scan` function is like `fold` but returns the intermediate results and
    thus can be used to trace or monitor the iteration.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan`函数类似于`fold`，但返回中间结果，因此可以用于跟踪或监视迭代过程。'
- en: '[`scan<''T,''State> : folder:(''State -> ''T -> ''State) -> state:''State ->
    list:''T list -> ''State list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L619).
    Like `fold`, but returns both the intermediary and final results.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`scan<''T,''State>：folder:(''State -> ''T -> ''State) -> state:''State ->
    list:''T list -> ''State list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L619)。类似于`fold`，但返回中间和最终结果。'
- en: '[`scanBack<''T,''State> : folder:(''T -> ''State -> ''State) -> list:''T list
    -> state:''State -> ''State list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L627).
    Like `foldBack`, but returns both the intermediary and final results.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`scanBack<''T,''State>：folder:(''T -> ''State -> ''State) -> list:''T list
    -> state:''State -> ''State list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L627)。类似于`foldBack`，但返回中间和最终结果。'
- en: Just like the fold twins, `scan` is often called "scan left" and `scanBack`
    is often called "scan right".
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `fold` 的双胞胎一样，`scan` 常被称为“左扫描”，`scanBack` 常被称为“右扫描”。
- en: Finally, `mapFold` combines `map` and `fold` into one awesome superpower. More
    complicated than using `map` and `fold` separately but also more efficient.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`mapFold` 将 `map` 和 `fold` 结合成一个强大的超级能力。比分别使用 `map` 和 `fold` 更复杂，但也更有效。
- en: '[`mapFold<''T,''State,''Result> : mapping:(''State -> ''T -> ''Result * ''State)
    -> state:''State -> list:''T list -> ''Result list * ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L447).
    Combines map and fold. Builds a new collection whose elements are the results
    of applying the given function to each of the elements of the input collection.
    The function is also used to accumulate a final value.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`mapFold<''T,''State,''Result> : mapping:(''State -> ''T -> ''Result * ''State)
    -> state:''State -> list:''T list -> ''Result list * ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L447)。结合了
    map 和 fold。构建一个新集合，其元素是将给定函数应用于输入集合的每个元素的结果。该函数还用于累积最终值。'
- en: '[`mapFoldBack<''T,''State,''Result> : mapping:(''T -> ''State -> ''Result *
    ''State) -> list:''T list -> state:''State -> ''Result list * ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L456).
    Combines map and foldBack. Builds a new collection whose elements are the results
    of applying the given function to each of the elements of the input collection.
    The function is also used to accumulate a final value.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`mapFoldBack<''T,''State,''Result> : mapping:(''T -> ''State -> ''Result *
    ''State) -> list:''T list -> state:''State -> ''Result list * ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L456)。结合了
    map 和 foldBack。构建一个新集合，其元素是将给定函数应用于输入集合的每个元素的结果。该函数还用于累积最终值。'
- en: '`fold` examples'
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`fold` 示例'
- en: 'One way of thinking about `fold` is that it is like `reduce` but with an extra
    parameter for the initial state:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想 `fold` 就像是带有额外参数用于初始状态的 `reduce`：
- en: '[PRE46]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As with `reduce`, `fold` and `foldBack` can give very different answers.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `reduce` 类似，`fold` 和 `foldBack` 可以得到非常不同的答案。
- en: '[PRE47]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And here''s the `foldBack` version:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `foldBack` 版本：
- en: '[PRE48]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that `foldBack` has a different parameter order to `fold`: the list is
    second last, and the initial state is last, which means that piping is not as
    convenient.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `foldBack` 的参数顺序与 `fold` 不同：列表是倒数第二个参数，初始状态是最后一个参数，这意味着管道不够方便。
- en: Recursing vs iterating
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归与迭代
- en: It's easy to get confused between `fold` vs. `foldBack`. I find it helpful to
    think of `fold` as being about *iteration* while `foldBack` is about *recursion*.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易混淆 `fold` 和 `foldBack`。我发现将 `fold` 视为 *迭代*，将 `foldBack` 视为 *递归* 是有帮助的。
- en: Let's say we want to calculate the sum of a list. The iterative way would be
    to use a for-loop. You start with a (mutable) accumulator and thread it through
    each iteration, updating it as you go.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算列表的总和。迭代的方法是使用 for 循环。你从一个（可变的）累加器开始，并通过每次迭代将其传递，随着迭代的进行更新它。
- en: '[PRE49]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: On the other hand, the recursive approach says that if the list has a head and
    tail, calculate the sum of the tail (a smaller list) first, and then add the head
    to it.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，递归方法表示，如果列表有头和尾，首先计算尾部的总和（一个较小的列表），然后将头部加到其中。
- en: Each time the tail gets smaller and smaller until it is empty, at which point
    you're done.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 每次尾巴都会变得越来越小，直到为空，此时你完成了。
- en: '[PRE50]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Which approach is better?
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？
- en: For aggregation, the iterative way is (`fold`) often easiest to understand.
    But for things like constructing new lists, the recursive way is (`foldBack`)
    is easier to understand.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 对于聚合，迭代的方法（`fold`）通常最容易理解。但对于诸如构造新列表之类的事情，递归的方法（`foldBack`）更容易理解。
- en: 'For example, if we were going to going to create a function from scratch that
    turned each element into the corresponding string, we might write something like
    this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们要从头开始创建一个将每个元素转换为相应字符串的函数，我们可能会写成这样：
- en: '[PRE51]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using `foldBack` we can transfer that same logic "as is":'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `foldBack` 我们可以将相同的逻辑原封不动地转移过来：
- en: action for empty list = `[]`
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表的操作 = `[]`
- en: 'action for non-empty list = `head.ToString() :: state`'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '非空列表的操作 = `head.ToString() :: state`'
- en: 'Here is the resulting function:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的函数：
- en: '[PRE52]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: On the other hand, a big advantage of `fold` is that it is easier to use "inline"
    because it plays better with piping.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`fold` 的一个很大的优势是它更容易“内联”，因为它与管道更配合。
- en: Luckily, you can use `fold` (for list construction at least) just like `foldBack`
    as long as you reverse the list at the end.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，只要在最后反转列表，你就可以像使用`foldBack`一样使用`fold`（至少用于列表构造）。
- en: '[PRE53]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using `fold` to implement other functions
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`fold`来实现其他函数
- en: As I mentioned above, `fold` is the core function for operating on lists and
    can emulate most other functions, although perhaps not as efficiently as a custom
    implementation.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我上面提到的，`fold`是对列表进行操作的核心函数，可以模拟大多数其他函数，尽管可能不像自定义实现那样高效。
- en: 'For example, here is `map` implemented using `fold`:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是使用`fold`实现的`map`：
- en: '[PRE54]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And here is `filter` implemented using `fold`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`fold`实现的`filter`：
- en: '[PRE55]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: And of course, you can emulate the other functions in a similar way.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以以类似的方式模拟其他函数。
- en: '`scan` examples'
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`scan`示例'
- en: 'Earlier, I showed an example of the intermediate steps of `fold`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我展示了`fold`的中间步骤的一个示例：
- en: '[PRE56]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For that example, I had to manually calculate the intermediate states,
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那个示例，我不得不手动计算中间状态，
- en: Well, if I had used `scan`, I would have got those intermediate states for free!
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，如果我使用了`scan`，我就可以免费获得这些中间状态了！
- en: '[PRE57]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`scanBack` works the same way, but backwards of course:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`scanBack`的工作方式相同，但是反向的：'
- en: '[PRE58]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Just as with `foldBack` the parameter order for "scan right" is inverted compared
    with "scan left".
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`foldBack`一样，与“向左扫描”相比，“向右扫描”的参数顺序是倒置的。
- en: Truncating a string with `scan`
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`scan`截断字符串
- en: Here's an example where `scan` is useful. Say that you have a news site, and
    you need to make sure headlines fit into 50 chars.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`scan`有用的一个例子。假设你有一个新闻网站，你需要确保标题不超过50个字符。
- en: You could just truncate the string at 50, but that would look ugly. Instead
    you want to have the truncation end at a word boundary.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地在50个字符处截断字符串，但那看起来会很丑陋。相反，你希望截断在单词边界处结束。
- en: 'Here''s one way of doing it using `scan`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`scan`的一种方法：
- en: Split the headline into words.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标题拆分为单词。
- en: Use `scan` to concat the words back together, generating a list of fragments,
    each with an extra word added.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scan`将单词连接起来，生成一个片段列表，每个片段都多加了一个单词。
- en: Get the longest fragment under 50 chars.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取长度不超过50个字符的最长片段。
- en: '[PRE59]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that I'm using `Seq.scan` rather than `Array.scan`. This does a lazy scan
    and avoids having to create fragments that are not needed.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我使用的是`Seq.scan`而不是`Array.scan`。这会进行惰性扫描，并避免创建不需要的片段。
- en: 'Finally, here is the complete logic as a utility function:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是完整的逻辑作为一个实用函数：
- en: '[PRE60]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Yes, I know that there is a more efficient implementation than this, but I hope
    that this little example shows off the power of `scan`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道有比这更有效的实现方式，但我希望这个小例子展示了`scan`的威力。
- en: '`mapFold` examples'
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`mapFold`示例'
- en: The `mapFold` function can do a map and a fold in one step, which can be convenient
    on occasion.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapFold`函数可以一步完成映射和折叠，这在某些情况下可能很方便。'
- en: 'Here''s an example of combining an addition and a sum in one step using `mapFold`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`mapFold`一步完成加法和求和的示例：
- en: '[PRE61]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '* * *'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 20\. Working with the index of each element
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20\. 使用每个元素的索引
- en: Often, you need the index of the element as you do an iteration. You could use
    a mutable counter, but why not sit back and let the library do the work for you?
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，你在迭代过程中需要元素的索引。你可以使用可变计数器，但为什么不坐下来，让库为你完成这项工作呢？
- en: '[`mapi: mapping:(int -> ''T -> ''U) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L465).
    Like `map`, but with the integer index passed to the function as well. See [section
    17](#17) for more on `map`.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`mapi: mapping:(int -> ''T -> ''U) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L465)。类似于`map`，但同时将整数索引传递给函数。查看[第17节](#17)了解更多关于`map`的信息。'
- en: '[`iteri: action:(int -> ''T -> unit) -> list:''T list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L382).
    Like `iter`, but with the integer index passed to the function as well. See [section
    18](#18) for more on `iter`.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`iteri: action:(int -> ''T -> unit) -> list:''T list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L382)。类似于`iter`，但同时将整数索引传递给函数。查看[第18节](#18)了解更多关于`iter`的信息。'
- en: '[`indexed: list:''T list -> (int * ''T) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L340).
    Returns a new list whose elements are the corresponding elements of the input
    list paired with the index (from 0) of each element.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`indexed: list:''T list -> (int * ''T) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L340)。返回一个新列表，其元素是输入列表的相应元素与每个元素的索引（从
    0 开始）配对。'
- en: Usage examples
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: '[PRE62]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`indexed` generates a tuple with the index -- a shortcut for a specific use
    of `mapi`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexed` 生成一个带有索引的元组 -- 一个特定使用 `mapi` 的快捷方式：'
- en: '[PRE63]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '* * *'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 21\. Transforming the whole collection to a different collection type
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21\. 将整个集合转换为不同类型的集合
- en: You often need to convert from one kind of collection to another. These functions
    do this.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要将一种类型的集合转换为另一种类型。这些函数可以实现这一点。
- en: The `ofXXX` functions are used to convert from `XXX` to the module type. For
    example, `List.ofArray` will turn an array into a list.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`ofXXX` 函数用于从 `XXX` 转换为模块类型。例如，`List.ofArray` 将数组转换为列表。'
- en: '(Except Array) [`ofArray : array:''T[] -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L526).
    Builds a new collection from the given array.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(除数组外) [`ofArray : array:''T[] -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L526)。从给定数组构建一个新集合。'
- en: '(Except Seq) [`ofSeq: source:seq<''T> -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L532).
    Builds a new collection from the given enumerable object.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(除 Seq 外) [`ofSeq: source:seq<''T> -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L532)。从给定的可枚举对象构建一个新集合。'
- en: '(Except List) [`ofList: source:''T list -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L864).
    Builds a new collection from the given list.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(除列表外) [`ofList: source:''T list -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L864)。从给定列表构建一个新集合。'
- en: The `toXXX` are used to convert from the module type to the type `XXX`. For
    example, `List.toArray` will turn an list into an array.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`toXXX` 函数用于从模块类型转换为类型 `XXX`。例如，`List.toArray` 将列表转换为数组。'
- en: '(Except Array) [`toArray: list:''T list -> ''T[]`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L762).
    Builds an array from the given collection.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(除数组外) [`toArray: list:''T list -> ''T[]`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L762)。从给定集合构建一个数组。'
- en: '(Except Seq) [`toSeq: list:''T list -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L768).
    Views the given collection as a sequence.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(除 Seq 外) [`toSeq: list:''T list -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L768)。将给定的集合视为序列。'
- en: '(Except List) [`toList: source:seq<''T> -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L1189).
    Builds a list from the given collection.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(除列表外) [`toList: source:seq<''T> -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L1189)。从给定集合构建一个列表。'
- en: Usage examples
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: '[PRE64]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using sequences with disposables
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有可释放资源的序列
- en: One important use of these conversion functions is to convert a lazy enumeration
    (`seq`) to a fully evaluated collection such as `list`. This is particularly important
    when there is a disposable resource involved, such as file handle or database
    connection. If the sequence is not converted into a list you may encounter errors
    accessing the elements. See [section 28](#28) for more.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换函数的一个重要用途是将惰性枚举 (`seq`) 转换为完全评估的集合，如 `list`。当涉及到可释放资源时，比如文件句柄或数据库连接，这一点尤为重要。如果序列没有转换为列表，可能会在访问元素时遇到错误。更多信息请参见
    [第 28 节](#28)。
- en: '* * *'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 22\. Changing the behavior of the collection as a whole
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 22\. 改变整个集合的行为
- en: There are some special functions (for Seq only) that change the behavior of
    the collection as a whole.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊函数（仅适用于 Seq）可以改变整个集合的行为。
- en: '(Seq only) [`cache: source:seq<''T> -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L98).
    Returns a sequence that corresponds to a cached version of the input sequence.
    This result sequence will have the same elements as the input sequence. The result
    can be enumerated multiple times. The input sequence will be enumerated at most
    once and only as far as is necessary.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Seq only) [`readonly : source:seq<''T> -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L919).
    Builds a new sequence object that delegates to the given sequence object. This
    ensures the original sequence cannot be rediscovered and mutated by a type cast.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Seq only) [`delay : generator:(unit -> seq<''T>) -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L221).
    Returns a sequence that is built from the given delayed specification of a sequence.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache` example'
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of `cache` in use:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The result of iterating over the sequence twice is as you would expect:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: But if we cache the sequence...
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '... then each item is only printed once:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`readonly` example'
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of `readonly` being used to hide the underlying type of
    the sequence:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`delay` example'
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's an example of `delay`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If we run the code above, we find that just by creating `eagerList`, we print
    all the "Evaluating" messages. But creating `delayedSeq` does not trigger the
    list iteration.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Only when the sequence is iterated over does the list creation happen:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'An alternative to using delay is just to embed the list in a `seq` like this:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As with `delayedSeq`, the `makeNumbers` function will not be called until the
    sequence is iterated over.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 23\. Working with two lists
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have two lists, there are analogues of most of the common functions like
    map and fold.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[`map2: mapping:(''T1 -> ''T2 -> ''U) -> list1:''T1 list -> list2:''T2 list
    -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L428).
    Builds a new collection whose elements are the results of applying the given function
    to the corresponding elements of the two collections pairwise.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`mapi2: mapping:(int -> ''T1 -> ''T2 -> ''U) -> list1:''T1 list -> list2:''T2
    list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L473).
    Like `mapi`, but mapping corresponding elements from two lists of equal length.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`iter2: action:(''T1 -> ''T2 -> unit) -> list1:''T1 list -> list2:''T2 list
    -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L375).
    Applies the given function to two collections simultaneously. The collections
    must have identical size.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`iteri2: action:(int -> ''T1 -> ''T2 -> unit) -> list1:''T1 list -> list2:''T2
    list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L391).
    Like `iteri`, but mapping corresponding elements from two lists of equal length.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`iteri2: action:(int -> ''T1 -> ''T2 -> unit) -> list1:''T1 list -> list2:''T2
    list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L391)。类似于`iteri`，但是将两个等长列表中对应的元素进行映射。'
- en: '[`forall2: predicate:(''T1 -> ''T2 -> bool) -> list1:''T1 list -> list2:''T2
    list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L314).
    The predicate is applied to matching elements in the two collections up to the
    lesser of the two lengths of the collections. If any application returns false
    then the overall result is false, else true.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`forall2: predicate:(''T1 -> ''T2 -> bool) -> list1:''T1 list -> list2:''T2
    list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L314)。将谓词应用于两个集合中相匹配的元素，直到两个集合中较短的长度为止。如果任何应用返回false，则整体结果为false，否则为true。'
- en: '[`exists2: predicate:(''T1 -> ''T2 -> bool) -> list1:''T1 list -> list2:''T2
    list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L191).
    The predicate is applied to matching elements in the two collections up to the
    lesser of the two lengths of the collections. If any application returns true
    then the overall result is true, else false.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`exists2: predicate:(''T1 -> ''T2 -> bool) -> list1:''T1 list -> list2:''T2
    list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L191)。将谓词应用于两个集合中相匹配的元素，直到两个集合中较短的长度为止。如果任何应用返回true，则整体结果为true，否则为false。'
- en: '[`fold2<''T1,''T2,''State> : folder:(''State -> ''T1 -> ''T2 -> ''State) ->
    state:''State -> list1:''T1 list -> list2:''T2 list -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L266).
    Applies a function to corresponding elements of two collections, threading an
    accumulator argument through the computation.'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fold2<''T1,''T2,''State> : folder:(''State -> ''T1 -> ''T2 -> ''State) ->
    state:''State -> list1:''T1 list -> list2:''T2 list -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L266)。对两个集合的相应元素应用函数，通过计算传递一个累加器参数。'
- en: '[`foldBack2<''T1,''T2,''State> : folder:(''T1 -> ''T2 -> ''State -> ''State)
    -> list1:''T1 list -> list2:''T2 list -> state:''State -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L288).
    Applies a function to corresponding elements of two collections, threading an
    accumulator argument through the computation.'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`foldBack2<''T1,''T2,''State> : folder:(''T1 -> ''T2 -> ''State -> ''State)
    -> list1:''T1 list -> list2:''T2 list -> state:''State -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L288)。对两个集合的相应元素���用函数，通过计算传递一个累加器参数。'
- en: '[`compareWith: comparer:(''T -> ''T -> int) -> list1:''T list -> list2:''T
    list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L84).
    Compares two collections using the given comparison function, element by element.
    Returns the first non-zero result from the comparison function. If the end of
    a collection is reached it returns a -1 if the first collection is shorter and
    a 1 if the second collection is shorter.'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`compareWith: comparer:(''T -> ''T -> int) -> list1:''T list -> list2:''T
    list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L84)。使用给定的比较函数逐个元素比较两个集合。从比较函数中返回第一个非零结果。如果到达集合的末尾，则如果第一个集合较短则返回-1，如果第二个集合较短则返回1。'
- en: 'See also `append`, `concat`, and `zip` in [section 26: combining and uncombining
    collections](#26).'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另请参阅[第26节：合并和拆分集合](#26)中的`append`、`concat`和`zip`。
- en: Usage examples
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'These functions are straightforward to use:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使用起来很简单：
- en: '[PRE74]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Need a function that's not here?
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要的函数不在这里吗？
- en: 'By using `fold2` and `foldBack2` you can easily create your own functions.
    For example, some `filter2` functions can be defined like this:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`fold2`和`foldBack2`，你可以轻松创建自己的函数。例如，一些`filter2`函数可以这样定义：
- en: '[PRE75]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: See also [section 25](#25).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[第25节](#25)。
- en: '* * *'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 24\. Working with three lists
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24\. 使用三个列表
- en: If you have three lists, you only have one built-in function available. But
    see [section 25](#25) for an example of how you can build your own three-list
    functions.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三个列表，你只有一个内置函数可用。但是请参见[第25节](#25)中的一个示例，了解如何构建自己的三列表函数。
- en: '[`map3: mapping:(''T1 -> ''T2 -> ''T3 -> ''U) -> list1:''T1 list -> list2:''T2
    list -> list3:''T3 list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L438).
    Builds a new collection whose elements are the results of applying the given function
    to the corresponding elements of the three collections simultaneously.'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See also `append`, `concat`, and `zip3` in [section 26: combining and uncombining
    collections](#26).'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 25\. Working with more than three lists
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working with more than three lists, there are no built in functions
    for you.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: If this happens infrequently, then you could just collapse the lists into a
    single tuple using `zip2` and/or `zip3` in succession, and then process that tuple
    using `map`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively you can "lift" your function to the world of "zip lists" using
    applicatives.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If that seems like magic, see [this series](elevated-world.html#lift) for a
    explanation of what this code is doing.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 26\. Combining and uncombining collections
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, there are a number of functions that combine and uncombine collections.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[`append: list1:''T list -> list2:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L21).
    Returns a new collection that contains the elements of the first collection followed
    by elements of the second.'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@` is an infix version of `append` for lists.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`concat: lists:seq<''T list> -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L90).
    Builds a new collection whose elements are the results of applying the given function
    to the corresponding elements of the collections simultaneously.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`zip: list1:''T1 list -> list2:''T2 list -> (''T1 * ''T2) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L882).
    Combines two collections into a list of pairs. The two collections must have equal
    lengths.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`zip3: list1:''T1 list -> list2:''T2 list -> list3:''T3 list -> (''T1 * ''T2
    * ''T3) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L890).
    Combines three collections into a list of triples. The collections must have equal
    lengths.'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except Seq) [`unzip: list:(''T1 * ''T2) list -> (''T1 list * ''T2 list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L852).
    Splits a collection of pairs into two collections.'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except Seq) [`unzip3: list:(''T1 * ''T2 * ''T3) list -> (''T1 list * ''T2
    list * ''T3 list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L858).
    Splits a collection of triples into three collections.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These functions are straightforward to use:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that the `zip` functions require the lengths to be the same.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '* * *'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 27\. Other array-only functions
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are mutable, and therefore have some functions that are not applicable
    to lists and sequences.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: See the "sort in place" functions in [section 15](#15)
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.blit: source:''T[] -> sourceIndex:int -> target:''T[] -> targetIndex:int
    -> count:int -> unit`. Reads a range of elements from the first array and write
    them into the second.'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.copy: array:''T[] -> ''T[]`. Builds a new array that contains the elements
    of the given array.'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.fill: target:''T[] -> targetIndex:int -> count:int -> value:''T -> unit`.
    Fills a range of elements of the array with the given value.'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.set: array:''T[] -> index:int -> value:''T -> unit`. Sets an element
    of an array.'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these, all the other [BCL array functions](https://msdn.microsoft.com/en-us/library/system.array.aspx)
    are available as well.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I won't give examples. See the [MSDN documentation](https://msdn.microsoft.com/en-us/library/ee370273.aspx).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 28\. Using sequences with disposables
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important use of conversion functions like `List.ofSeq` is to convert a
    lazy enumeration (`seq`) to a fully evaluated collection such as `list`. This
    is particularly important when there is a disposable resource involved such as
    file handle or database connection. If the sequence is not converted into a list
    while the resource is available you may encounter errors accessing the elements
    later, after the resource has been disposed.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be an extended example, so let''s start with some helper functions
    that emulate a database and a UI:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'A naive implementation will cause the sequence to be evaluated *after* the
    connection is closed:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The output is below. You can see that the connection is closed and only then
    is the sequence evaluated.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'A better implementation will convert the sequence to a list while the connection
    is open, causing the sequence to be evaluated immediately:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The result is much better. All the records are loaded before the connection
    is disposed:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A third alternative is to embed the disposable in the sequence itself:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output shows that now the UI display is also done while the connection
    is open:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This may be a bad thing (longer time for the connection to stay open) or a good
    thing (minimal memory use), depending on the context.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 29\. The end of the adventure
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You made it to the end -- well done! Not really much of an adventure, though,
    was it? No dragons or anything. Nevertheless, I hope it was helpful.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
