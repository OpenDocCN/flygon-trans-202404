- en: Choosing between collection functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing between collection functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's more to learning a new language than the language itself. In order to
    be productive, you need to memorize a big chunk of the standard library and be
    aware of most of the rest of it. For example, if you know C#, you can pick up
    Java-the-language quite quickly, but you won't really get up to speed until you
    are comfortable with the Java Class Library as well.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can't really be effective in F# until you have some familiarity
    with all the F# functions that work with collections.
  prefs: []
  type: TYPE_NORMAL
- en: In C# there are only a few LINQ methods you need to know¹ (`Select`, `Where`,
    and so on). But in F#, there are currently almost 100 functions in the List module
    (and similar counts in the Seq and Array modules). That's a lot!
  prefs: []
  type: TYPE_NORMAL
- en: ¹ Yes, there are more, but you can get by with just a few. In F# it's more important
    to know them all.
  prefs: []
  type: TYPE_NORMAL
- en: If you are coming to F# from C#, then, the large number of list functions can
    be overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: So I have written this post to help guide you to the one you want. And for fun,
    I've done it in a "Choose Your Own Adventure" style!
  prefs: []
  type: TYPE_NORMAL
- en: '![](cyoa_list_module.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What collection do I want?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, a table with information about the different kinds of standard collections.
    There are five "native" F# ones: `list`, `seq`, `array`, `map` and `set`, and
    `ResizeArray` and `IDictionary` are also often used.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Immutable? | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| list | Yes | **Pros:**'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex iteration available via recursion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward iteration is fast. Prepending is fast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons:**'
  prefs: []
  type: TYPE_NORMAL
- en: Indexed access and other access styles are slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| seq | Yes | Alias for `IEnumerable`.**Pros:**'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory efficient (only one element at a time loaded)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can represent an infinite sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interop with .NET libraries that use IEnumerable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons:**'
  prefs: []
  type: TYPE_NORMAL
- en: No pattern matching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward only iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexed access and other access styles are slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| array | No | Same as BCL `Array`.**Pros:**'
  prefs: []
  type: TYPE_NORMAL
- en: Fast random access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory efficient and cache locality, especially with structs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interop with .NET libraries that use Array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for 2D, 3D and 4D arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons:**'
  prefs: []
  type: TYPE_NORMAL
- en: Limited pattern matching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not [persistent](https://en.wikipedia.org/wiki/Persistent_data_structure).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| map | Yes | Immutable dictionary. Requires keys to implement `IComparable`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| set | Yes | Immutable set. Requires elements to implement `IComparable`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ResizeArray | No | Alias for BCL `List`. Pros and cons similar to array,
    but resizable. |'
  prefs: []
  type: TYPE_TB
- en: '| IDictionary | Yes | For an alternate dictionary that does not requires elements
    to implement `IComparable`, you can use the BCL [IDictionary](https://msdn.microsoft.com/en-us/library/s4ys34ea.aspx).
    The constructor is [`dict`](https://msdn.microsoft.com/en-us/library/ee353774.aspx)
    in F#.Note that mutation methods such as `Add` are present, but will cause a runtime
    error if called. |'
  prefs: []
  type: TYPE_TB
- en: These are the main collection types that you will encounter in F#, and will
    be good enough for all common cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need other kinds of collections though, there are lots of choices:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the collection classes in .NET, either the [traditional, mutable
    ones](https://msdn.microsoft.com/en-us/library/system.collections.generic) or
    the newer ones such as those in the [System.Collections.Immutable namespace](https://msdn.microsoft.com/en-us/library/system.collections.immutable.aspx).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, you can use one of the F# collection libraries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**FSharpx.Collections**](https://fsprojects.github.io/FSharpx.Collections/),
    part of the FSharpx series of projects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**ExtCore**](https://github.com/jack-pappas/ExtCore/tree/master/ExtCore).
    Some of these are drop-in (almost) replacements for the Map and Set types in FSharp.Core
    which provide improved performance in specific scenarios (e.g., HashMap). Others
    provide unique functionality to help tackle specific coding tasks (e.g., LazyList
    and LruCache).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**Funq**](https://github.com/GregRos/Funq): high performance, immutable data
    structures for .NET.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**Persistent**](https://persistent.codeplex.com/documentation): some efficient
    persistent (immutable) data structures.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: About the documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All functions are available for `list`, `seq` and `array` in F# v4 unless noted.
    The `Map` and `Set` modules have some of them as well, but I won't be discussing
    `map` and `set` here.
  prefs: []
  type: TYPE_NORMAL
- en: For the function signatures I will use `list` as the standard collection type.
    The signatures for the `seq` and `array` versions will be similar.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these functions are not yet documented on MSDN so I'm going to link
    directly to the source code on GitHub, which has the up-to-date comments. Click
    on the function name for the link.
  prefs: []
  type: TYPE_NORMAL
- en: Note on availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The availability of these functions may depend on which version of F# you use.
  prefs: []
  type: TYPE_NORMAL
- en: In F# version 3 (Visual Studio 2013), there was some degree of inconsistency
    between Lists, Arrays and Sequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In F# version 4 (Visual Studio 2015), this inconsistency has been eliminated,
    and almost all functions are available for all three collection types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to know what changed between F# v3 and F# v4, please see [this chart](http://blogs.msdn.com/cfs-filesystemfile.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-39-71-metablogapi/3125.collectionAPI_5F00_254EA354.png)
    (from [here](http://blogs.msdn.com/b/fsharpteam/archive/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015.aspx)).
    The chart shows the new APIs in F# v4 (green), previously-existing APIs (blue),
    and intentional remaining gaps (white).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the functions documented below are not in this chart -- these are newer
    still! If you are using an older version of F#, you can simply reimplement them
    yourself using the code on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: With that disclaimer out of the way, you can start your adventure!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Table of contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1\. What kind of collection do you have?](#1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2\. Creating a new collection](#2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3\. Creating a new empty or one-element collection](#3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4\. Creating a new collection of known size](#4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5\. Creating a new collection of known size with each element having the same
    value](#5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6\. Creating a new collection of known size with each element having a different
    value](#6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7\. Creating a new infinite collection](#7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8\. Creating a new collection of indefinite size](#8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9\. Working with one list](#9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10\. Getting an element at a known position](#10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[11\. Getting an element by searching](#11)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[12\. Getting a subset of elements from a collection](#12)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13\. Partitioning, chunking and grouping](#13)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14\. Aggregating or summarizing a collection](#14)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[15\. Changing the order of the elements](#15)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16\. Testing the elements of a collection](#16)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[17\. Transforming each element to something different](#17)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18\. Iterating over each element](#18)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[19\. Threading state through an iteration](#19)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[20\. Working with the index of each element](#20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[21\. Transforming the whole collection to a different collection type](#21)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[22\. Changing the behavior of the collection as a whole](#22)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[23\. Working with two collections](#23)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[24\. Working with three collections](#24)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[25\. Working with more than three collections](#25)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[26\. Combining and uncombining collections](#26)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27\. Other array-only functions](#27)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[28\. Using sequences with disposables](#28)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. What kind of collection do you have?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What kind of collection do you have?
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a collection, and want to create one, go to [section 2](#2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you already have a collection that you want to work with, go to [section
    9](#9).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have two collections that you want to work with, go to [section 23](#23).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have three collections that you want to work with, go to [section 24](#24).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have more than three collections that you want to work with, go to [section
    25](#25).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to combine or uncombine collections, go to [section 26](#26).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Creating a new collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So you want to create a new collection. How do you want to create it?
  prefs: []
  type: TYPE_NORMAL
- en: If the new collection will be empty or will have one element, go to [section
    3](#3).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the new collection is a known size, go to [section 4](#4).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the new collection is potentially infinite, go to [section 7](#7).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't know how big the collection will be, go to [section 8](#8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Creating a new empty or one-element collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to create a new empty or one-element collection, use these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`empty : ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L142).
    Returns an empty list of the given type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`singleton : value:''T -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L635).
    Returns a list that contains one item only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you know the size of the collection in advance, it is generally more efficient
    to use a different function. See [section 4](#4) below.
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Creating a new collection of known size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all elements of the collection will have the same value, go to [section 5](#5).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If elements of the collection could be different, go to [section 6](#6).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Creating a new collection of known size with each element having the same
    value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to create a new collection of known size with each element having
    the same value, you want to use `replicate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`replicate : count:int -> initial:''T -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L602).
    Creates a collection by replicating the given initial value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Array only) [`create : count:int -> value:''T -> ''T[]`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L125).
    Creates an array whose elements are all initially the supplied value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Array only) [`zeroCreate : count:int -> ''T[]`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L467).
    Creates an array where the entries are initially the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.create` is basically the same as `replicate` (although with a subtly
    different implementation!) but `replicate` was only implemented for `Array` in
    F# v4.'
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that for `zeroCreate`, the target type must be known to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Creating a new collection of known size with each element having a different
    value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to create a new collection of known size with each element having
    a potentially different value, you can choose one of three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`init : length:int -> initializer:(int -> ''T) -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L347).
    Creates a collection by calling the given generator on each index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For lists and arrays, you can also use the literal syntax such as `[1; 2; 3]`
    (lists) and `[|1; 2; 3|]` (arrays).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For lists and arrays and seqs, you can use the comprehension syntax `for ..
    in .. do .. yield`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Literal syntax allows for an increment as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The comprehension syntax is even more flexible because you can `yield` more
    than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'and it can also be used as a quick and dirty inline filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Two other tricks:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `yield!` to return a list rather than a single value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of both tricks being used to count up to 10 by twos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Creating a new infinite collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want an infinite list, you have to use a seq rather than a list or array.
  prefs: []
  type: TYPE_NORMAL
- en: '[`initInfinite : initializer:(int -> ''T) -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L599).
    Generates a new sequence which, when iterated, will return successive elements
    by calling the given function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use a seq comprehension with a recursive loop to generate an infinite
    sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Creating a new collection of indefinite size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you don't know how big the collection will be in advance. In this
    case you need a function that will keep adding elements until it gets a signal
    to stop. `unfold` is your friend here, and the "signal to stop" is whether you
    return a `None` (stop) or a `Some` (keep going).
  prefs: []
  type: TYPE_NORMAL
- en: '[`unfold : generator:(''State -> (''T * ''State) option) -> state:''State ->
    ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L846).
    Returns a collection that contains the elements generated by the given computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example reads from the console in a loop until an empty line is entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`unfold` requires that a state be threaded through the generator. You can ignore
    it (as in the `ReadLine` example above), or you can use it to keep track of what
    you have done so far. For example, you can create a Fibonacci series generator
    using `unfold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Working with one list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working with one list and...
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get an element at a known position, go to [section 10](#10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to get one element by searching, go to [section 11](#11)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to get a subset of the collection, go to [section 12](#12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to partition, chunk, or group a collection into smaller collections,
    go to [section 13](#13)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to aggregate or summarize the collection into a single value, go
    to [section 14](#14)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to change the order of the elements, go to [section 15](#15)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to test the elements in the collection, go to [section 16](#16)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to transform each element to something different, go to [section
    17](#17)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to iterate over each element, go to [section 18](#18)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to thread state through an iteration, go to [section 19](#19)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to know the index of each element while you are iterating or mapping,
    go to [section 20](#20)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to transform the whole collection to a different collection type,
    go to [section 21](#21)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to change the behaviour of the collection as a whole, go to [section
    22](#22)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to mutate the collection in place, go to [section 27](#27)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to use a lazy collection with an IDisposable, go to [section 28](#28)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Getting an element at a known position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following functions get a element in the collection by position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`head : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L333).
    Returns the first element of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`last : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L398).
    Returns the last element of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`item : index:int -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L520).
    Indexes into the collection. The first element has index 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NOTE: Avoid using `nth` and `item` for lists and sequences. They are not designed
    for random access, and so they will be slow in general.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`nth : list:''T list -> index:int -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L520).
    The older version of `item`. NOTE: Deprecated in v4 -- use `item` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Array only) [`get : array:''T[] -> index:int -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L220).
    Yet another version of `item`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`exactlyOne : list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L165).
    Returns the only element of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what if the collection is empty? Then `head` and `last` will fail with an
    exception (ArgumentException).
  prefs: []
  type: TYPE_NORMAL
- en: And if the index is not found in the collection? Then another exception again
    (ArgumentException for lists, IndexOutOfRangeException for arrays).
  prefs: []
  type: TYPE_NORMAL
- en: 'I would therefore recommend that you avoid these functions in general and use
    the `tryXXX` equivalents below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`tryHead : list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L775).
    Returns the first element of the collection, or None if the collection is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tryLast : list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L411).
    Returns the last element of the collection, or None if the collection is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tryItem : index:int -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L827).
    Indexes into the collection, or None if the index is not valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted, the `item` function should be avoided for lists. For example, if
    you want to process each item in a list, and you come from an imperative background,
    you might write a loop with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t do that! Use something like `map` instead. It''s both more concise and
    more efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Getting an element by searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can search for an element or its index using `find` and `findIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`find : predicate:(''T -> bool) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L201).
    Returns the first element for which the given function returns true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`findIndex : predicate:(''T -> bool) -> list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L222).
    Returns the index of the first element for which the given function returns true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And you can also search backwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`findBack : predicate:(''T -> bool) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L211).
    Returns the last element for which the given function returns true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`findIndexBack : predicate:(''T -> bool) -> list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L233).
    Returns the index of the last element for which the given function returns true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what if the item cannot be found? Then these will fail with an exception
    (`KeyNotFoundException`).
  prefs: []
  type: TYPE_NORMAL
- en: 'I would therefore recommend that, as with `head` and `item`, you avoid these
    functions in general and use the `tryXXX` equivalents below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`tryFind : predicate:(''T -> bool) -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L800).
    Returns the first element for which the given function returns true, or None if
    no such element exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tryFindBack : predicate:(''T -> bool) -> list:''T list -> ''T option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L809).
    Returns the last element for which the given function returns true, or None if
    no such element exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tryFindIndex : predicate:(''T -> bool) -> list:''T list -> int option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L819).
    Returns the index of the first element for which the given function returns true,
    or None if no such element exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tryFindIndexBack : predicate:(''T -> bool) -> list:''T list -> int option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L837).
    Returns the index of the last element for which the given function returns true,
    or None if no such element exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are doing a `map` before a `find` you can often combine the two steps
    into a single one using `pick` (or better, `tryPick`). See below for a usage example.
  prefs: []
  type: TYPE_NORMAL
- en: '[`pick : chooser:(''T -> ''U option) -> list:''T list -> ''U`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L561).
    Applies the given function to successive elements, returning the first result
    where the chooser function returns Some.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tryPick : chooser:(''T -> ''U option) -> list:''T list -> ''U option`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L791).
    Applies the given function to successive elements, returning the first result
    where the chooser function returns Some, or None if no such element exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With `pick`, rather than returning a bool, you return an option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Pick vs. Find
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That 'pick' function might seem unnecessary, but it is useful when dealing with
    functions that return options.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say that there is a function `tryInt` that parses a string and
    returns `Some int` if the string is a valid int, otherwise `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And now say that we want to find the first valid int in a list. The crude way
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: map the list using `tryInt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: find the first one that is a `Some` using `find`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: get the value from inside the option using `Option.get`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But `pick` will do all these steps at once! So the code becomes much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you want to return many elements in the same way as `pick`, consider using
    `choose` (see [section 12](#12)).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Getting a subset of elements from a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous section was about getting one element. How can you get more than
    one element? Well you're in luck! There's lots of functions to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract elements from the front, use one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`take: count:int -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L746).
    Returns the first N elements of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`takeWhile: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L756).
    Returns a collection that contains all elements of the original collection while
    the given predicate returns true, and then returns no further elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`truncate: count:int -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L782).
    Returns at most N elements in a new collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To extract elements from the rear, use one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`skip: count:int -> list: ''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L644).
    Returns the collection after removing the first N elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`skipWhile: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L652).
    Bypasses elements in a collection while the given predicate returns true, and
    then returns the remaining elements of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tail: list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L730).
    Returns the collection after removing the first element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To extract other subsets of elements, use one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`filter: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L241).
    Returns a new collection containing only the elements of the collection for which
    the given function returns true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`except: itemsToExclude:seq<''T> -> list:''T list -> ''T list when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L155).
    Returns a new collection with the distinct elements of the input collection which
    do not appear in the itemsToExclude sequence, using generic hash and equality
    comparisons to compare values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`choose: chooser:(''T -> ''U option) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L55).
    Applies the given function to each element of the collection. Returns a collection
    comprised of the elements where the function returns Some.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`where: predicate:(''T -> bool) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L866).
    Returns a new collection containing only the elements of the collection for which
    the given predicate returns true. NOTE: "where" is a synonym for "filter".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Array only) `sub : ''T [] -> int -> int -> ''T []`. Creates an array that
    contains the supplied subrange, which is specified by starting index and length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also use slice syntax: `myArray.[2..5]`. See below for examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To reduce the list to distinct elements, use one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`distinct: list:''T list -> ''T list when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L107).
    Returns a collection that contains no duplicate entries according to generic hash
    and equality comparisons on the entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`distinctBy: projection:(''T -> ''Key) -> list:''T list -> ''T list when ''Key
    : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L118).
    Returns a collection that contains no duplicate entries according to the generic
    hash and equality comparisons on the keys returned by the given key-generating
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Taking elements from the front:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking elements from the rear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract other subsets of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that slicing on lists can be slow, because they are not random access.
    Slicing on arrays is fast however.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the distinct elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Choose vs. Filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with `pick`, the `choose` function might seem awkward, but it is useful when
    dealing with functions that return options.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, `choose` is to `filter` as [`pick` is to `find`](#pick-vs-find), Rather
    than using a boolean filter, the signal is `Some` vs. `None`.
  prefs: []
  type: TYPE_NORMAL
- en: As before, say that there is a function `tryInt` that parses a string and returns
    `Some int` if the string is a valid int, otherwise `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And now say that we want to find all the valid ints in a list. The crude way
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: map the list using `tryInt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: filter to only include the ones that are `Some`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: get the value from inside each option using `Option.get`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But `choose` will do all these steps at once! So the code becomes much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have a list of options, you can filter and return the "Some"
    in one step by passing `id` into `choose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you want to return the first element in the same way as `choose`, consider
    using `pick` (see [section 11](#11)).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to do a similar action as `choose` but for other wrapper types (such
    as a Success/Failure result), there is [a discussion here](elevated-world-5.html).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Partitioning, chunking and grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are lots of different ways to split a collection! Have a look at the
    usage examples to see the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`chunkBySize: chunkSize:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L63).
    Divides the input collection into chunks of size at most `chunkSize`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`groupBy : projection:(''T -> ''Key) -> list:''T list -> (''Key * ''T list)
    list when ''Key : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L325).
    Applies a key-generating function to each element of a collection and yields a
    list of unique keys. Each unique key contains a list of all elements that match
    to this key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`pairwise: list:''T list -> (''T * ''T) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L541).
    Returns a collection of each element in the input collection and its predecessor,
    with the exception of the first element which is only returned as the predecessor
    of the second element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except Seq) [`partition: predicate:(''T -> bool) -> list:''T list -> (''T
    list * ''T list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L551).
    Splits the collection into two collections, containing the elements for which
    the given predicate returns true and false respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except Seq) [`splitAt: index:int -> list:''T list -> (''T list * ''T list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L688).
    Splits a collection into two collections at the given index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`splitInto: count:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L137).
    Splits the input collection into at most count chunks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`windowed : windowSize:int -> list:''T list -> ''T list list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L875).
    Returns a list of sliding windows containing elements drawn from the input collection.
    Each window is returned as a fresh collection. Unlike `pairwise` the windows are
    collections, not tuples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'All the functions other than `splitAt` and `pairwise` handle edge cases gracefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Aggregating or summarizing a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most generic way to aggregate the elements in a collection is to use `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`reduce : reduction:(''T -> ''T -> ''T) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L584).
    Apply a function to each element of the collection, threading an accumulator argument
    through the computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`reduceBack : reduction:(''T -> ''T -> ''T) -> list:''T list -> ''T`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L595).
    Applies a function to each element of the collection, starting from the end, threading
    an accumulator argument through the computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'and there are specific versions of `reduce` for frequently used aggregations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`max : list:''T list -> ''T when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L482).
    Return the greatest of all elements of the collection, compared via Operators.max.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`maxBy : projection:(''T -> ''U) -> list:''T list -> ''T when ''U : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L492).
    Returns the greatest of all elements of the collection, compared via Operators.max
    on the function result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`min : list:''T list -> ''T when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L501).
    Returns the lowest of all elements of the collection, compared via Operators.min.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`minBy : projection:(''T -> ''U) -> list:''T list -> ''T when ''U : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L511).
    Returns the lowest of all elements of the collection, compared via Operators.min
    on the function result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sum : list:''T list -> ''T when ''T has static members (+) and Zero`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L711).
    Returns the sum of the elements in the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sumBy : projection:(''T -> ''U) -> list:''T list -> ''U when ''U has static
    members (+) and Zero`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L720).
    Returns the sum of the results generated by applying the function to each element
    of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`average : list:''T list -> ''T when ''T has static members (+) and Zero and
    DivideByInt`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L30).
    Returns the average of the elements in the collection. Note that a list of ints
    cannot be averaged -- they must be cast to floats or decimals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`averageBy : projection:(''T -> ''U) -> list:''T list -> ''U when ''U has
    static members (+) and Zero and DivideByInt`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L43).
    Returns the average of the results generated by applying the function to each
    element of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally there are some counting functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`length: list:''T list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L404).
    Returns the length of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`countBy : projection:(''T -> ''Key) -> list:''T list -> (''Key * int) list
    when ''Key : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L129).
    Applies a key-generating function to each element and returns a collection yielding
    unique keys and their number of occurrences in the original collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`reduce` is a variant of `fold` without an initial state -- see [section 19](#19)
    for more on `fold`. One way to think of it is just inserting a operator between
    each element.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: is the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Some ways of combining elements depend on the order of combining, and so there
    are two variants of "reduce":'
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce` moves forward through the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceBack`, not surprisingly, moves backwards through the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a demonstration of the difference. First `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the *same* combining function with `reduceBack` produces a different
    result! It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Again, see [section 19](#19) for a more detailed discussion of the related functions
    `fold` and `foldBack`.
  prefs: []
  type: TYPE_NORMAL
- en: The other aggregation functions are much more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Most of the aggregation functions do not like empty lists! You might consider
    using one of the `fold` functions to be safe -- see [section 19](#19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 15\. Changing the order of the elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can change the order of the elements using reversing, sorting and permuting.
    All of the following return *new* collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`rev: list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L608).
    Returns a new collection with the elements in reverse order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sort: list:''T list -> ''T list when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L678).
    Sorts the given collection using Operators.compare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sortDescending: list:''T list -> ''T list when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L705).
    Sorts the given collection in descending order using Operators.compare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sortBy: projection:(''T -> ''Key) -> list:''T list -> ''T list when ''Key
    : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L670).
    Sorts the given collection using keys given by the given projection. Keys are
    compared using Operators.compare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sortByDescending: projection:(''T -> ''Key) -> list:''T list -> ''T list
    when ''Key : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L697).
    Sorts the given collection in descending order using keys given by the given projection.
    Keys are compared using Operators.compare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sortWith: comparer:(''T -> ''T -> int) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L661).
    Sorts the given collection using the given comparison function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`permute : indexMap:(int -> int) -> list:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L570).
    Returns a collection with all elements permuted according to the specified permutation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And there are also some array-only functions that sort in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '(Array only) [`sortInPlace: array:''T[] -> unit when ''T : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L874).
    Sorts the elements of an array by mutating the array in-place. Elements are compared
    using Operators.compare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Array only) [`sortInPlaceBy: projection:(''T -> ''Key) -> array:''T[] -> unit
    when ''Key : comparison`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L858).
    Sorts the elements of an array by mutating the array in-place, using the given
    projection for the keys. Keys are compared using Operators.compare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Array only) [`sortInPlaceWith: comparer:(''T -> ''T -> int) -> array:''T[]
    -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/array.fsi#L867).
    Sorts the elements of an array by mutating the array in-place, using the given
    comparison function as the order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 16\. Testing the elements of a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These set of functions all return true or false.
  prefs: []
  type: TYPE_NORMAL
- en: '[`contains: value:''T -> source:''T list -> bool when ''T : equality`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L97).
    Tests if the collection contains the specified element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`exists: predicate:(''T -> bool) -> list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L176).
    Tests if any element of the collection satisfies the given predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`forall: predicate:(''T -> bool) -> list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L299).
    Tests if all elements of the collection satisfy the given predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`isEmpty: list:''T list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L353).
    Returns true if the collection contains no elements, false otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Transforming each element to something different
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I sometimes like to think of functional programming as "transformation-oriented
    programming", and `map` (aka `Select` in LINQ) is one of the most fundamental
    ingredients for this approach. In fact, I have devoted a whole series to it [here](elevated-world.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[`map: mapping:(''T -> ''U) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L419).
    Builds a new collection whose elements are the results of applying the given function
    to each of the elements of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes each element maps to a list, and you want to flatten out all the lists.
    For this case, use `collect` (aka `SelectMany` in LINQ).
  prefs: []
  type: TYPE_NORMAL
- en: '[`collect: mapping:(''T -> ''U list) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L70).
    For each element of the list, applies the given function. Concatenates all the
    results and return the combined list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other transformation functions include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`choose` in [section 12](#12) is a map and option filter combined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Seq only) [`cast: source:IEnumerable -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L599).
    Wraps a loosely-typed `System.Collections` sequence as a typed sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some examples of using `map` in the conventional way, as a function
    that accepts a list and a mapping function and returns a new transformed list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can also think of `map` as a *function transformer*. It turns an element-to-element
    function into a list-to-list function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`collect` works to flatten lists. If you already have a list of lists, you
    can use `collect` with `id` to flatten them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Seq.cast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, `Seq.cast` is useful when working with older parts of the BCL that
    have specialized collection classes rather than generics.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Regex library has this problem, and so the code below won't
    compile because `MatchCollection` is not an `IEnumerable<T>`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is to cast `MatchCollection` to a `Seq<Match>` and then the code will
    work nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 18\. Iterating over each element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, when processing a collection, we transform each element to a new value
    using `map`. But occasionally we need to process all the elements with a function
    which *doesn't* produce a useful value (a "unit function").
  prefs: []
  type: TYPE_NORMAL
- en: '[`iter: action:(''T -> unit) -> list:''T list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L367).
    Applies the given function to each element of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can use a for-loop. The expression inside a for-loop *must*
    return `unit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common examples of unit functions are all about side-effects: printing
    to the console, updating a database, putting a message on a queue, etc. For the
    examples below, I will just use `printfn` as my unit function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted above, the expression inside an `iter` or for-loop must return unit.
    In the following examples, we try to add 1 to the element, and get a compiler
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are sure that this is not a logic bug in your code, and you want to
    get rid of this error, you can pipe the results into `ignore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 19\. Threading state through an iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fold` function is the most basic and powerful function in the collection
    arsenal. All other functions (other than generators like `unfold`) can be written
    in terms of it. See the examples below.
  prefs: []
  type: TYPE_NORMAL
- en: '[`fold<''T,''State> : folder:(''State -> ''T -> ''State) -> state:''State ->
    list:''T list -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L254).
    Applies a function to each element of the collection, threading an accumulator
    argument through the computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`foldBack<''T,''State> : folder:(''T -> ''State -> ''State) -> list:''T list
    -> state:''State -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L276).
    Applies a function to each element of the collection, starting from the end, threading
    an accumulator argument through the computation. WARNING: Watch out for using
    `Seq.foldBack` on infinite lists! The runtime will laugh at you ha ha ha and then
    go very quiet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fold` function is often called "fold left" and `foldBack` is often called
    "fold right".
  prefs: []
  type: TYPE_NORMAL
- en: The `scan` function is like `fold` but returns the intermediate results and
    thus can be used to trace or monitor the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[`scan<''T,''State> : folder:(''State -> ''T -> ''State) -> state:''State ->
    list:''T list -> ''State list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L619).
    Like `fold`, but returns both the intermediary and final results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`scanBack<''T,''State> : folder:(''T -> ''State -> ''State) -> list:''T list
    -> state:''State -> ''State list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L627).
    Like `foldBack`, but returns both the intermediary and final results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like the fold twins, `scan` is often called "scan left" and `scanBack`
    is often called "scan right".
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `mapFold` combines `map` and `fold` into one awesome superpower. More
    complicated than using `map` and `fold` separately but also more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '[`mapFold<''T,''State,''Result> : mapping:(''State -> ''T -> ''Result * ''State)
    -> state:''State -> list:''T list -> ''Result list * ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L447).
    Combines map and fold. Builds a new collection whose elements are the results
    of applying the given function to each of the elements of the input collection.
    The function is also used to accumulate a final value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`mapFoldBack<''T,''State,''Result> : mapping:(''T -> ''State -> ''Result *
    ''State) -> list:''T list -> state:''State -> ''Result list * ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L456).
    Combines map and foldBack. Builds a new collection whose elements are the results
    of applying the given function to each of the elements of the input collection.
    The function is also used to accumulate a final value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fold` examples'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One way of thinking about `fold` is that it is like `reduce` but with an extra
    parameter for the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As with `reduce`, `fold` and `foldBack` can give very different answers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the `foldBack` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `foldBack` has a different parameter order to `fold`: the list is
    second last, and the initial state is last, which means that piping is not as
    convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursing vs iterating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's easy to get confused between `fold` vs. `foldBack`. I find it helpful to
    think of `fold` as being about *iteration* while `foldBack` is about *recursion*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want to calculate the sum of a list. The iterative way would be
    to use a for-loop. You start with a (mutable) accumulator and thread it through
    each iteration, updating it as you go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the recursive approach says that if the list has a head and
    tail, calculate the sum of the tail (a smaller list) first, and then add the head
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the tail gets smaller and smaller until it is empty, at which point
    you're done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Which approach is better?
  prefs: []
  type: TYPE_NORMAL
- en: For aggregation, the iterative way is (`fold`) often easiest to understand.
    But for things like constructing new lists, the recursive way is (`foldBack`)
    is easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we were going to going to create a function from scratch that
    turned each element into the corresponding string, we might write something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `foldBack` we can transfer that same logic "as is":'
  prefs: []
  type: TYPE_NORMAL
- en: action for empty list = `[]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'action for non-empty list = `head.ToString() :: state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the resulting function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, a big advantage of `fold` is that it is easier to use "inline"
    because it plays better with piping.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, you can use `fold` (for list construction at least) just like `foldBack`
    as long as you reverse the list at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Using `fold` to implement other functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned above, `fold` is the core function for operating on lists and
    can emulate most other functions, although perhaps not as efficiently as a custom
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is `map` implemented using `fold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is `filter` implemented using `fold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: And of course, you can emulate the other functions in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: '`scan` examples'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier, I showed an example of the intermediate steps of `fold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: For that example, I had to manually calculate the intermediate states,
  prefs: []
  type: TYPE_NORMAL
- en: Well, if I had used `scan`, I would have got those intermediate states for free!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`scanBack` works the same way, but backwards of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Just as with `foldBack` the parameter order for "scan right" is inverted compared
    with "scan left".
  prefs: []
  type: TYPE_NORMAL
- en: Truncating a string with `scan`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's an example where `scan` is useful. Say that you have a news site, and
    you need to make sure headlines fit into 50 chars.
  prefs: []
  type: TYPE_NORMAL
- en: You could just truncate the string at 50, but that would look ugly. Instead
    you want to have the truncation end at a word boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one way of doing it using `scan`:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the headline into words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `scan` to concat the words back together, generating a list of fragments,
    each with an extra word added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the longest fragment under 50 chars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that I'm using `Seq.scan` rather than `Array.scan`. This does a lazy scan
    and avoids having to create fragments that are not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the complete logic as a utility function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Yes, I know that there is a more efficient implementation than this, but I hope
    that this little example shows off the power of `scan`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mapFold` examples'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mapFold` function can do a map and a fold in one step, which can be convenient
    on occasion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of combining an addition and a sum in one step using `mapFold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 20\. Working with the index of each element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, you need the index of the element as you do an iteration. You could use
    a mutable counter, but why not sit back and let the library do the work for you?
  prefs: []
  type: TYPE_NORMAL
- en: '[`mapi: mapping:(int -> ''T -> ''U) -> list:''T list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L465).
    Like `map`, but with the integer index passed to the function as well. See [section
    17](#17) for more on `map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`iteri: action:(int -> ''T -> unit) -> list:''T list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L382).
    Like `iter`, but with the integer index passed to the function as well. See [section
    18](#18) for more on `iter`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`indexed: list:''T list -> (int * ''T) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L340).
    Returns a new list whose elements are the corresponding elements of the input
    list paired with the index (from 0) of each element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`indexed` generates a tuple with the index -- a shortcut for a specific use
    of `mapi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 21\. Transforming the whole collection to a different collection type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You often need to convert from one kind of collection to another. These functions
    do this.
  prefs: []
  type: TYPE_NORMAL
- en: The `ofXXX` functions are used to convert from `XXX` to the module type. For
    example, `List.ofArray` will turn an array into a list.
  prefs: []
  type: TYPE_NORMAL
- en: '(Except Array) [`ofArray : array:''T[] -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L526).
    Builds a new collection from the given array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except Seq) [`ofSeq: source:seq<''T> -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L532).
    Builds a new collection from the given enumerable object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except List) [`ofList: source:''T list -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L864).
    Builds a new collection from the given list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toXXX` are used to convert from the module type to the type `XXX`. For
    example, `List.toArray` will turn an list into an array.
  prefs: []
  type: TYPE_NORMAL
- en: '(Except Array) [`toArray: list:''T list -> ''T[]`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L762).
    Builds an array from the given collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except Seq) [`toSeq: list:''T list -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L768).
    Views the given collection as a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except List) [`toList: source:seq<''T> -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L1189).
    Builds a list from the given collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using sequences with disposables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important use of these conversion functions is to convert a lazy enumeration
    (`seq`) to a fully evaluated collection such as `list`. This is particularly important
    when there is a disposable resource involved, such as file handle or database
    connection. If the sequence is not converted into a list you may encounter errors
    accessing the elements. See [section 28](#28) for more.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 22\. Changing the behavior of the collection as a whole
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some special functions (for Seq only) that change the behavior of
    the collection as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: '(Seq only) [`cache: source:seq<''T> -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L98).
    Returns a sequence that corresponds to a cached version of the input sequence.
    This result sequence will have the same elements as the input sequence. The result
    can be enumerated multiple times. The input sequence will be enumerated at most
    once and only as far as is necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Seq only) [`readonly : source:seq<''T> -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L919).
    Builds a new sequence object that delegates to the given sequence object. This
    ensures the original sequence cannot be rediscovered and mutated by a type cast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Seq only) [`delay : generator:(unit -> seq<''T>) -> seq<''T>`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/seq.fsi#L221).
    Returns a sequence that is built from the given delayed specification of a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache` example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of `cache` in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of iterating over the sequence twice is as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: But if we cache the sequence...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '... then each item is only printed once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`readonly` example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of `readonly` being used to hide the underlying type of
    the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`delay` example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's an example of `delay`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If we run the code above, we find that just by creating `eagerList`, we print
    all the "Evaluating" messages. But creating `delayedSeq` does not trigger the
    list iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Only when the sequence is iterated over does the list creation happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative to using delay is just to embed the list in a `seq` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As with `delayedSeq`, the `makeNumbers` function will not be called until the
    sequence is iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 23\. Working with two lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have two lists, there are analogues of most of the common functions like
    map and fold.
  prefs: []
  type: TYPE_NORMAL
- en: '[`map2: mapping:(''T1 -> ''T2 -> ''U) -> list1:''T1 list -> list2:''T2 list
    -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L428).
    Builds a new collection whose elements are the results of applying the given function
    to the corresponding elements of the two collections pairwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`mapi2: mapping:(int -> ''T1 -> ''T2 -> ''U) -> list1:''T1 list -> list2:''T2
    list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L473).
    Like `mapi`, but mapping corresponding elements from two lists of equal length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`iter2: action:(''T1 -> ''T2 -> unit) -> list1:''T1 list -> list2:''T2 list
    -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L375).
    Applies the given function to two collections simultaneously. The collections
    must have identical size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`iteri2: action:(int -> ''T1 -> ''T2 -> unit) -> list1:''T1 list -> list2:''T2
    list -> unit`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L391).
    Like `iteri`, but mapping corresponding elements from two lists of equal length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`forall2: predicate:(''T1 -> ''T2 -> bool) -> list1:''T1 list -> list2:''T2
    list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L314).
    The predicate is applied to matching elements in the two collections up to the
    lesser of the two lengths of the collections. If any application returns false
    then the overall result is false, else true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`exists2: predicate:(''T1 -> ''T2 -> bool) -> list1:''T1 list -> list2:''T2
    list -> bool`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L191).
    The predicate is applied to matching elements in the two collections up to the
    lesser of the two lengths of the collections. If any application returns true
    then the overall result is true, else false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`fold2<''T1,''T2,''State> : folder:(''State -> ''T1 -> ''T2 -> ''State) ->
    state:''State -> list1:''T1 list -> list2:''T2 list -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L266).
    Applies a function to corresponding elements of two collections, threading an
    accumulator argument through the computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`foldBack2<''T1,''T2,''State> : folder:(''T1 -> ''T2 -> ''State -> ''State)
    -> list1:''T1 list -> list2:''T2 list -> state:''State -> ''State`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L288).
    Applies a function to corresponding elements of two collections, threading an
    accumulator argument through the computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`compareWith: comparer:(''T -> ''T -> int) -> list1:''T list -> list2:''T
    list -> int`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L84).
    Compares two collections using the given comparison function, element by element.
    Returns the first non-zero result from the comparison function. If the end of
    a collection is reached it returns a -1 if the first collection is shorter and
    a 1 if the second collection is shorter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See also `append`, `concat`, and `zip` in [section 26: combining and uncombining
    collections](#26).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These functions are straightforward to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Need a function that's not here?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using `fold2` and `foldBack2` you can easily create your own functions.
    For example, some `filter2` functions can be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: See also [section 25](#25).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 24\. Working with three lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have three lists, you only have one built-in function available. But
    see [section 25](#25) for an example of how you can build your own three-list
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[`map3: mapping:(''T1 -> ''T2 -> ''T3 -> ''U) -> list1:''T1 list -> list2:''T2
    list -> list3:''T3 list -> ''U list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L438).
    Builds a new collection whose elements are the results of applying the given function
    to the corresponding elements of the three collections simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See also `append`, `concat`, and `zip3` in [section 26: combining and uncombining
    collections](#26).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 25\. Working with more than three lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working with more than three lists, there are no built in functions
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: If this happens infrequently, then you could just collapse the lists into a
    single tuple using `zip2` and/or `zip3` in succession, and then process that tuple
    using `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively you can "lift" your function to the world of "zip lists" using
    applicatives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If that seems like magic, see [this series](elevated-world.html#lift) for a
    explanation of what this code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 26\. Combining and uncombining collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, there are a number of functions that combine and uncombine collections.
  prefs: []
  type: TYPE_NORMAL
- en: '[`append: list1:''T list -> list2:''T list -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L21).
    Returns a new collection that contains the elements of the first collection followed
    by elements of the second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@` is an infix version of `append` for lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`concat: lists:seq<''T list> -> ''T list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L90).
    Builds a new collection whose elements are the results of applying the given function
    to the corresponding elements of the collections simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`zip: list1:''T1 list -> list2:''T2 list -> (''T1 * ''T2) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L882).
    Combines two collections into a list of pairs. The two collections must have equal
    lengths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`zip3: list1:''T1 list -> list2:''T2 list -> list3:''T3 list -> (''T1 * ''T2
    * ''T3) list`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L890).
    Combines three collections into a list of triples. The collections must have equal
    lengths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except Seq) [`unzip: list:(''T1 * ''T2) list -> (''T1 list * ''T2 list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L852).
    Splits a collection of pairs into two collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Except Seq) [`unzip3: list:(''T1 * ''T2 * ''T3) list -> (''T1 list * ''T2
    list * ''T3 list)`](https://github.com/fsharp/fsharp/blob/4331dca3648598223204eed6bfad2b41096eec8a/src/fsharp/FSharp.Core/list.fsi#L858).
    Splits a collection of triples into three collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These functions are straightforward to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `zip` functions require the lengths to be the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 27\. Other array-only functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are mutable, and therefore have some functions that are not applicable
    to lists and sequences.
  prefs: []
  type: TYPE_NORMAL
- en: See the "sort in place" functions in [section 15](#15)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.blit: source:''T[] -> sourceIndex:int -> target:''T[] -> targetIndex:int
    -> count:int -> unit`. Reads a range of elements from the first array and write
    them into the second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.copy: array:''T[] -> ''T[]`. Builds a new array that contains the elements
    of the given array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.fill: target:''T[] -> targetIndex:int -> count:int -> value:''T -> unit`.
    Fills a range of elements of the array with the given value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.set: array:''T[] -> index:int -> value:''T -> unit`. Sets an element
    of an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these, all the other [BCL array functions](https://msdn.microsoft.com/en-us/library/system.array.aspx)
    are available as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I won't give examples. See the [MSDN documentation](https://msdn.microsoft.com/en-us/library/ee370273.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 28\. Using sequences with disposables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important use of conversion functions like `List.ofSeq` is to convert a
    lazy enumeration (`seq`) to a fully evaluated collection such as `list`. This
    is particularly important when there is a disposable resource involved such as
    file handle or database connection. If the sequence is not converted into a list
    while the resource is available you may encounter errors accessing the elements
    later, after the resource has been disposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be an extended example, so let''s start with some helper functions
    that emulate a database and a UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'A naive implementation will cause the sequence to be evaluated *after* the
    connection is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The output is below. You can see that the connection is closed and only then
    is the sequence evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'A better implementation will convert the sequence to a list while the connection
    is open, causing the sequence to be evaluated immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is much better. All the records are loaded before the connection
    is disposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A third alternative is to embed the disposable in the sequence itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that now the UI display is also done while the connection
    is open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This may be a bad thing (longer time for the connection to stay open) or a good
    thing (minimal memory use), depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 29\. The end of the adventure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You made it to the end -- well done! Not really much of an adventure, though,
    was it? No dragons or anything. Nevertheless, I hope it was helpful.
  prefs: []
  type: TYPE_NORMAL
