- en: 26Interpreting Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释函数
- en: '|     [26.1 Adding Functions to the Language](#%28part._adding-functions%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [26.1 向语言添加函数](#%28part._adding-functions%29) |'
- en: '|       [26.1.1 Defining Data Representations](#%28part._.Defining_.Data_.Representations%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|       [26.1.1 定义数据表示](#%28part._.Defining_.Data_.Representations%29) |'
- en: '|       [26.1.2 Growing the Interpreter](#%28part._.Growing_the_.Interpreter%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|       [26.1.2 增加解释器功能](#%28part._.Growing_the_.Interpreter%29) |'
- en: '|       [26.1.3 Substitution](#%28part._substitution-in-interp%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [26.1.3 替换](#%28part._substitution-in-interp%29) |'
- en: '|       [26.1.4 The Interpreter, Resumed](#%28part._fof-interp-resumed%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [26.1.4 解释器，续](#%28part._fof-interp-resumed%29) |'
- en: '|       [26.1.5 Oh Wait, There’s More!](#%28part._eager-lazy-subst%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [26.1.5 噢，等一下，还有更多！](#%28part._eager-lazy-subst%29) |'
- en: '|     [26.2 From Substitution to Environments](#%28part._subst-to-env%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|     [26.2 从替换到环境](#%28part._subst-to-env%29) |'
- en: '|       [26.2.1 Introducing the Environment](#%28part._.Introducing_the_.Environment%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [26.2.1 介绍环境](#%28part._.Introducing_the_.Environment%29) |'
- en: '|       [26.2.2 Interpreting with Environments](#%28part._.Interpreting_with_.Environments%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [26.2.2 使用环境解释](#%28part._.Interpreting_with_.Environments%29) |'
- en: '|       [26.2.3 Deferring Correctly](#%28part._.Deferring_.Correctly%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|       [26.2.3 正确推迟](#%28part._.Deferring_.Correctly%29) |'
- en: '|       [26.2.4 Scope](#%28part._.Scope%29) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [26.2.4 作用域](#%28part._.Scope%29) |'
- en: '|       [26.2.5 How Bad Is It?](#%28part._.How_.Bad_.Is_.It_%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|       [26.2.5 有多糟糕？](#%28part._.How_.Bad_.Is_.It_%29) |'
- en: '|       [26.2.6 The Top-Level Scope](#%28part._.The_.Top-.Level_.Scope%29)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|       [26.2.6 顶级范围](#%28part._.The_.Top-.Level_.Scope%29) |'
- en: '|       [26.2.7 Exposing the Environment](#%28part._.Exposing_the_.Environment%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|       [26.2.7 暴露环境](#%28part._.Exposing_the_.Environment%29) |'
- en: '|     [26.3 Functions Anywhere](#%28part._higher-order-functions%29) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|     [26.3 函数随处可见](#%28part._higher-order-functions%29) |'
- en: '|       [26.3.1 Functions as Expressions and Values](#%28part._.Functions_as_.Expressions_and_.Values%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|       [26.3.1 函数作为表达式和值](#%28part._.Functions_as_.Expressions_and_.Values%29)
    |'
- en: '|       [26.3.2 A Small Improvement](#%28part._.A_.Small_.Improvement%29) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|       [26.3.2 一个小改进](#%28part._.A_.Small_.Improvement%29) |'
- en: '|       [26.3.3 Nesting Functions](#%28part._.Nesting_.Functions%29) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|       [26.3.3 嵌套函数](#%28part._.Nesting_.Functions%29) |'
- en: '|       [26.3.4 Nested Functions and Substitution](#%28part._.Nested_.Functions_and_.Substitution%29)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|       [26.3.4 嵌套函数和替换](#%28part._.Nested_.Functions_and_.Substitution%29)
    |'
- en: '|       [26.3.5 Updating Values](#%28part._.Updating_.Values%29) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|       [26.3.5 更新值](#%28part._.Updating_.Values%29) |'
- en: '|       [26.3.6 Sugaring Over Anonymity](#%28part._let-desugar%29) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|       [26.3.6 糖化匿名](#%28part._let-desugar%29) |'
- en: '|     [26.4 Recursion and Non-Termination](#%28part._rec-non-term%29) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|     [26.4 递归和非终止](#%28part._rec-non-term%29) |'
- en: '|     [26.5 Functions and Predictability](#%28part._functions-and-predictability%29)
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|     [26.5 函数与可预测性](#%28part._functions-and-predictability%29) |'
- en: 26.1Adding Functions to the Language
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.1向语言添加函数
- en: Now that we have basic expressions and conditionals, let’s grow to have a complete
    programming languageby adding functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的表达式和条件，让我们通过添加函数来发展成一个完整的编程语言。
- en: 26.1.1Defining Data Representations
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.1定义数据表示
- en: 'Imagine we’re modeling a simple programming environment. The developer defines
    functions in a definitions window, and uses them in an interactions windowFor
    historic reasons, the interactions window is also called a REPL or “read-eval-print
    loop”. (which provides a prompt at which they can run expressions). For now, let’s
    assume all definitions go in the definitions window only (we’ll relax this soon:
    [Functions Anywhere](#%28part._higher-order-functions%29)), and all stand-alone
    expressions in the interactions window only. Thus, running a program simply loads
    definitions. Our interpreter will correspond to the interactions window prompt
    and assume it has been supplied with a set of definitions.A set of definitions
    suggests no ordering, which means, presumably, any definition can refer to any
    other. That’s what I intend here, but when you are designing your own language,
    be sure to think about this.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在模拟一个简单的编程环境。开发人员在定义窗口中定义函数，并在交互窗口中使用它们。出于历史原因，交互窗口也称为 REPL 或“读取-求值-打印循环”。（在此处提供一个提示，以便他们可以运行表达式）。目前，让我们假设所有定义都只放在定义窗口中（我们很快会放宽这一点：[函数随处可见](#%28part._higher-order-functions%29)），而所有独立表达式都只放在交互窗口中。因此，运行程序只需加载定义。我们的解释器将对应于交互窗口提示，并假设已提供一组定义。一组定义意味着没有顺序，这意味着，据推测，任何定义都可以引用任何其他定义。这是我在这里的意图，但是当你设计自己的语言时，请务必考虑这一点。
- en: 'To keep things simple, let’s just consider functions of one argument. Here
    are some Pyret examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，让我们只考虑一个参数的函数。以下是一些 Pyret 示例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Exercise
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When a function has multiple arguments, what simple but important criterion
    governs the names of those arguments?
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当一个函数有多个参数时，什么简单但重要的标准控制着这些参数的名称？
- en: 'What are the parts of a function definition? It has a name (above, double,
    quad, and const5), which we’ll represent as a string ("double", etc.); its formal
    parameter or argument has a name (e.g., x), which too we can model as a string
    ("x"); and it has a body. We’ll determine the body’s representation in stages,
    but let’s start to lay out a datatype for function definitions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的各个部分是什么？它有一个名字（如上所示，`double`，`quad` 和 `const5`），我们将其表示为一个字符串（"double"等）；它的形式参数或参数有一个名字（例如，`x`），我们也可以将其建模为一个字符串（"x"）；它还有一个主体。我们将逐步确定主体的表示方式，但让我们开始布置函数定义的数据类型：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What is the body? Clearly, it has the form of an arithmetic expression, and
    sometimes it can even be represented using the existing ArithC language: for instance,
    the body of const5 can be represented as numC(5). But representing the body of
    double requires something more: not just addition (which we have), but also “x”.
    You are probably used to calling this a variable, but we will not use that term
    for now. Instead, we will call it an identifier.We’ve discussed this terminological
    difference in [From Identifiers to Variables](State__Change__and_More_Equality.html#%28part._mutable-variables%29).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主体是什么？显然，它具有算术表达式的形式，有时甚至可以使用现有的 `ArithC` 语言来表示：例如，`const5` 的主体可以表示为 `numC(5)`。但是表示
    `double` 的主体需要更多：不仅仅是加法（我们已经有了），还有“x”。您可能习惯将其称为变量，但我们现在不会使用该术语。相反，我们将其称为标识符。我们已经在
    [从标识符到变量](State__Change__and_More_Equality.html#%28part._mutable-variables%29)
    中讨论过这个术语上的区别。
- en: Do Now!
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在做！
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Anything else?
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有其他的吗？
- en: 'Finally, let’s look at the body of quad. It has yet another new construct:
    a function application. Be very careful to distinguish between a function definition,
    which describes what the function is, and an application, which uses it. The argument
    (or actual parameter) in the inner application of double is x; the argument in
    the outer application is double(x). Thus, the argument can be any complex expression.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看 `quad` 的主体。它又有一个新的构造：函数应用。非常小心地区分函数定义（描述函数是什么）和应用（使用函数的地方）。在 `double`
    的内部应用中，参数（或实际参数）是 `x`；在外部应用中，参数是 `double(x)`。因此，参数可以是任何复杂表达式。
- en: Let’s commit all this to a crisp datatype. Clearly we’re extending what we had
    before (because we still want all of arithmetic). We’ll give a new name to our
    datatype to signify that it’s growing up:<datatype> ::=
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些都承诺成一个清晰的数据类型。显然，我们正在扩展之前的内容（因为我们仍然想要所有的算术）。我们将给我们的数据类型一个新的名字，以表示它正在成长：<datatype>
    ::=
- en: '|   data ExprC: |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|   data ExprC: |'
- en: '|     &#124; numC(n :: Number) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; numC(n :: Number) |'
- en: '|     &#124; plusC(l :: ExprC, r :: ExprC) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; plusC(l :: ExprC, r :: ExprC) |'
- en: '|     &#124; multC(l :: ExprC, r :: ExprC) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; multC(l :: ExprC, r :: ExprC) |'
- en: '|     &#124; trueC |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; trueC |'
- en: '|     &#124; falseC |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; falseC |'
- en: '|     &#124; ifC(c :: ExprC, t :: ExprC, e :: ExprC) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; ifC(c :: ExprC, t :: ExprC, e :: ExprC) |'
- en: '|     &#124; [<appC-dt>](#%28elem._app.C-dt%29) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; [<appC-dt>](#%28elem._app.C-dt%29) |'
- en: '|     &#124; [<idC-dt>](#%28elem._id.C-dt%29) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; [<idC-dt>](#%28elem._id.C-dt%29) |'
- en: '|   end |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: 'Identifiers are closely related to formal parameters. When we apply a function
    by giving it a value for its parameter, we are in effect asking it to replace
    all instances of that formal parameter in the body—<wbr>i.e., the identifiers
    with the same name as the formal parameter—<wbr>with that value.Observe that we
    are being coy about a few issues: what kind of “value” [REF] and when to replace
    [REF]. To simplify this process of search-and-replace, we might as well use the
    same datatype to represent both. We’ve already chosen strings to represent formal
    parameters, so:<idC-dt> ::='
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符与形式参数密切相关。当我们通过为其参数给出一个值来应用一个函数时，实际上我们要求它用该值替换主体中的所有该形式参数的实例——即，与形式参数相同名称的标识符——将其替换为该值。请注意，我们对一些问题保持含糊：
    “值” 是什么样的[REF] 以及何时替换[REF]。为了简化这个搜索和替换的过程，我们可能会使用相同的数据类型来表示两者。我们已经选择了字符串来表示形式参数，所以：<idC-dt>
    ::=
- en: '|   &#124; idC(s :: String) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; idC(s :: String) |'
- en: 'Finally, applications. They have two parts: the function’s name, and its argument.
    We’ve already agreed that the argument can be any full-fledged expression (including
    identifiers and other applications). As for the function name, it again makes
    sense to use the same datatype as we did when giving the function its name in
    a function definition. Thus:<appC-dt> ::='
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序。它们有两个部分：函数的名称和其参数。我们已经同意参数可以是任何完整的表达式（包括标识符和其他应用程序）。至于函数名，再次使用与在函数定义中给出函数名称时相同的数据类型是有意义的。因此：<appC-dt>
    ::=
- en: '|   &#124; appC(f :: String, a :: ExprC) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; appC(f :: String, a :: ExprC) |'
- en: 'identifying which function to apply, and providing its argument.Using these
    definitions, it’s instructive to write out the representations of the examples
    we defined above:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要应用的函数，并提供其参数。使用这些定义，编写上面定义的示例的表示是有益的：
- en: fdC("double", "x", plusC(idC("x"), idC("x")))
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fdC("double", "x", plusC(idC("x"), idC("x")))
- en: fdC("quad", "x", appC("double", appC("double", idC("x"))))
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fdC("quad", "x", appC("double", appC("double", idC("x"))))
- en: fdC("const5", "_", numC(5))
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fdC("const5", "_", numC(5))
- en: We also need to choose a representation for a set of function definitions. It’s
    convenient to represent these by a list.Look out! Did you notice that we spoke
    of a set of function definitions, but chose a list representation? That means
    we’re using an ordered collection of data to represent an unordered entity. At
    the very least, then, when testing, we should use any and all permutations of
    definitions to ensure we haven’t subtly built in a dependence on the order.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要选择一种表示一组函数定义的方法。用列表表示这些是方便的。注意！你注意到我们谈到了一组函数定义，但选择了列表表示吗？这意味着我们使用有序的数据集表示无序的实体。至少，在测试时，我们应该使用所有排列组合的定义来确保我们没有在微妙地构建依赖于顺序。
- en: Exercise
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend desugar with support for identifiers and applications.
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扩展 desugar 以支持标识符和应用程序。
- en: 26.1.2Growing the Interpreter
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.2扩展解释器
- en: Now we’re ready to tackle the interpreter proper. First, let’s remind ourselves
    of what it needs to consume. Previously, it consumed only an expression to evaluate.
    Now it also needs to take a list of function definitions:<fof-interp> ::=
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好处理解释器本身了。首先，让我们想想它需要消耗什么。以前，它只消耗要评估的表达式。现在，它还需要接受一个函数定义的列表：<fof-interp>
    ::=
- en: '|   fun interp(e :: ExprC, fds :: List<FunDefC>) -> Value: |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|   fun interp(e :: ExprC, fds :: List<FunDefC>) -> Value: |'
- en: '|     cases (ExprC) e: |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|     cases (ExprC) e: |'
- en: '|       [<fof-interp-body>](#%28elem._fof-interp-body%29) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|       [<fof-interp-body>](#%28elem._fof-interp-body%29) |'
- en: '|     end |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: Let’s revisit our [old interpreter](growing-lang.html#%28elem._ext-arith-cond-interp%29).
    In the case of numbers, clearly we still return the number as the answer. In the
    addition and multiplication case, we still need to recur (because the sub-expressions
    might be complex), but which set of function definitions do we use? Because the
    act of evaluating an expression neither adds nor removes function definitions,
    the set of definitions remains the same, and should just be passed along unchanged
    in the recursive calls. Similarly for conditionals.<fof-interp-body> ::=
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下我们的[旧解释器](growing-lang.html#%28elem._ext-arith-cond-interp%29)。对于数字情况，显然我们仍然将数字作为答案返回。在加法和乘法情况下，我们仍然需要递归（因为子表达式可能很复杂），但是我们使用哪一组函数定义呢？因为评估表达式的行为既不添加也不删除函数定义，所以定义的集合保持不变，应该在递归调用中以不变的方式传递。条件也类似。<fof-interp-body>
    ::=
- en: '|   &#124; numC(n) => numV(n) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; numC(n) => numV(n) |'
- en: '|   &#124; plusC(l, r) => arith-binop(lam(x, y): x + y end, l, r, fds) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; plusC(l, r) => arith-binop(lam(x, y): x + y end, l, r, fds) |'
- en: '|   &#124; multC(l, r) => arith-binop(lam(x, y): x * y end, l, r, fds) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; multC(l, r) => arith-binop(lam(x, y): x * y end, l, r, fds) |'
- en: '|   &#124; trueC => boolV(true) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; trueC => boolV(true) |'
- en: '|   &#124; falseC => boolV(false) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; falseC => boolV(false) |'
- en: '|   &#124; ifC(cnd, thn, els) => |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; ifC(cnd, thn, els) => |'
- en: '|     ic = interp(cnd, fds) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|     ic = interp(cnd, fds) |'
- en: '|     if is-boolV(ic): |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|     if is-boolV(ic): |'
- en: '|       if ic.b: |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|       if ic.b: |'
- en: '|         interp(thn, fds) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|         interp(thn, fds) |'
- en: '|       else: |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|       else: |'
- en: '|         interp(els, fds) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|         interp(els, fds) |'
- en: '|       end |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|       end |'
- en: '|     else: |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|     else: |'
- en: '|       raise(''not a boolean'') |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|       raise(''not a boolean'') |'
- en: '|     end |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   [<fof-interp-idC>](#%28elem._fof-interp-id.C%29) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|   [<fof-interp-idC>](#%28elem._fof-interp-id.C%29) |'
- en: '|   [<fof-interp-appC>](#%28elem._fof-interp-app.C%29) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|   [<fof-interp-appC>](#%28elem._fof-interp-app.C%29) |'
- en: Exercise
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify arith-binop to pass along fds unchanged in recursive calls.
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改 arith-binop 以在递归调用中保持 fds 不变。
- en: Now let’s tackle application. First we have to look up the function definition,
    for which we’ll assume we have a helper function of this type available:<get-fundef>
    ::=
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来解决应用的问题。首先，我们必须查找函数定义，我们假设有这样一个可用的帮助函数：<get-fundef> ::=
- en: '|   fun get-fundef(name :: String, fds :: List<FunDefC>) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|   fun get-fundef(name :: String, fds :: List<FunDefC>) |'
- en: '|       -> FunDefC: |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|       -> FunDefC: |'
- en: '|     [<get-fundef-body>](#%28elem._get-fundef-body%29) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|     [<get-fundef-body>](#%28elem._get-fundef-body%29) |'
- en: '|   end |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: Assuming we find a function of the given name, we need to evaluate its body.
    However, remember what we said about identifiers and parameters? We must “search-and-replace”,
    a process you have seen before in school algebra called substitution. This is
    sufficiently important that we should talk first about substitution before returning
    to the interpreter ([The Interpreter, Resumed](#%28part._fof-interp-resumed%29)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们找到了给定名称的函数，我们需要评估其主体。但是，请记住我们关于标识符和参数的说法？我们必须“搜索和替换”，这是你在学校代数中见过的一个过程，称为替换。这是非常重要的，我们应该先讨论替换，然后再返回解释器（[继续解释器](#%28part._fof-interp-resumed%29)）。
- en: 26.1.3Substitution
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.3替换
- en: Substitution is the act of replacing a name (in this case, that of the formal
    parameter) in an expression (in this case, the body of the function) with another
    expression (in this case, the actual parameter). Its header is:<subst> ::=
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 替换是用一个表达式（在这种情况下是实际参数）替换表达式中的一个名称（在这种情况下是形式参数的名称）的行为。它的标头是：<subst> ::=
- en: '|   fun subst(w :: ExprC, at :: String, in :: ExprC) -> ExprC: |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   fun subst(w :: ExprC, at :: String, in :: ExprC) -> ExprC: |'
- en: '|     [<subst-body>](#%28elem._subst-body%29) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|     [<subst-body>](#%28elem._subst-body%29) |'
- en: '|   end |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: The first argument is what we want to replace the name with; the second is at
    what name we want to perform substitution; and the third is in which expression
    we want to do it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们要用来替换名称的内容；第二个是我们要执行替换的名称；第三个是我们要在其中执行替换的表达式。
- en: Do Now!
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在做！
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose we want to substitute 3 for the identifier x in the bodies of the three
    example functions above. What should it produce?
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设我们要在上述三个示例函数的主体中用 3 替换标识符 x。它应该产生什么？
- en: 'In double, this should produce 3 + 3; in quad, it should produce double(double(3));
    and in const5, it should produce 5 (i.e., no substitution happens because there
    are no instances of x in the body).A common mistake is to assume that the result
    of substituting, e.g., 3 for x in double is fun double(x): 3 + 3 end. This is
    incorrect. We only substitute at the point when we apply the function, at which
    point the function’s invocation is replaced by its body. The header enables us
    to find the function and ascertain the name of its parameter; but only its body
    participates in evaluation. Examine the use of substitution in the interpreter
    to see how returning a function definition would result in a type error.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 double，应该产生 3 + 3；对于 quad，应该产生 double(double(3))；对于 const5，应该产生 5（即，主体中没有
    x 实例，因此不进行替换）。一个常见的错误是假设在 double 中用 3 替换 x 的结果是 fun double(x): 3 + 3 end。这是不正确的。我们只在应用函数时进行替换，在这时函数的调用被其主体所替换。标头使我们能够找到函数并确定其参数的名称；但只有其主体参与评估。检查解释器中替换的用法，看看返回函数定义如何导致类型错误。'
- en: These examples already tell us what to do in almost all the cases. Given a number,
    there’s nothing to substitute. If it’s an identifier, we have to to replace the
    identifier if it’s the one we’re trying to substitute, otherwise leave it alone.
    In the other cases, descend into the sub-expressions, performing substitution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例已经告诉我们在几乎所有情况下应该做什么。给定一个数字，没有什么需要替换的。如果是标识符，我们必须替换标识符（如果它是我们尝试替换的标识符），否则保持不变。在其他情况下，进入子表达式，执行替换。
- en: Before we turn this into code, there’s an important case to consider. Suppose
    the name we are substituting happens to be the name of a function. Then what should
    happen?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将其转换为代码之前，有一个重要的情况需要考虑。假设我们要替换的名称恰好是函数的名称。那么应该发生什么？
- en: Do Now!
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在做！
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What, indeed, should happen?
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 究竟应该发生什么？
- en: 'There are many ways to approach this question. One is from a design perspective:
    function names live in their own “world”, distinct from ordinary program identifiers.
    Some languages (such as C and Common Lisp, in slightly different ways) take this
    perspective, and partition identifiers into different namespaces depending on
    how they are used. In other languages, there is no such distinction; indeed, we
    will examine such languages soon ([Functions Anywhere](#%28part._higher-order-functions%29)).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以解决这个问题。一个是从设计的角度来看：函数名存在于它们自己的“世界”中，与普通程序标识符不同。一些语言（如C和Common Lisp，稍微有些不同）采用这种观点，并根据标识符的使用方式将其划分到不同的命名空间中。在其他语言中，没有这样的区别；事实上，我们很快就会研究这样的语言（[函数随处可见](#%28part._higher-order-functions%29)）。
- en: For now, we will take a pragmatic viewpoint. If we evaluate a function name,
    it would result in a number or Boolean. However, these cannot name functions.
    Therefore, it makes no sense to substitute in that position, and we should leave
    the function name unmolested irrespective of its relationship to the variable
    being substituted. (Thus, a function could have a parameter named x as well as
    refer to another function called x, and these would be kept distinct.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将采取实用主义的观点。如果我们评估一个函数名，它会得到一个数字或布尔值。然而，这些不能命名函数。因此，在那个位置进行替换是毫无意义的，无论它与要替换的变量的关系如何，我们都应该保持函数名不受影响。（因此，一个函数可以有一个名为x的参数，也可以引用另一个名为x的函数，这些将被区分开来。）
- en: Now we’ve made all our decisions, and we can provide the body:<subst-body> ::=
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做出了所有的决定，我们可以提供主体了：<subst-body> ::=
- en: '|   cases (ExprC) in: |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|   cases (ExprC) in: |'
- en: '|     &#124; numC(n) => in |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; numC(n) => in |'
- en: '|     &#124; plusC(l, r) => plusC(subst(w, at, l), subst(w, at, r)) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; plusC(l, r) => plusC(subst(w, at, l), subst(w, at, r)) |'
- en: '|     &#124; multC(l, r) => multC(subst(w, at, l), subst(w, at, r)) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; multC(l, r) => multC(subst(w, at, l), subst(w, at, r)) |'
- en: '|     &#124; trueC => trueC |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; trueC => trueC |'
- en: '|     &#124; falseC => falseC |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; falseC => falseC |'
- en: '|     &#124; ifC(cnd, thn, els) => |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; ifC(cnd, thn, els) => |'
- en: '|       ifC(subst(w, at, cnd), subst(w, at, thn), subst(w, at, els)) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|       ifC(subst(w, at, cnd), subst(w, at, thn), subst(w, at, els)) |'
- en: '|     &#124; appC(f, a) => appC(f, subst(w, at, a)) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; appC(f, a) => appC(f, subst(w, at, a)) |'
- en: '|     &#124; idC(s) => |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; idC(s) => |'
- en: '|       if s == at: |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|       if s == at: |'
- en: '|         w |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|         w |'
- en: '|       else: |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|       else: |'
- en: '|         in |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|         in |'
- en: '|       end |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|       end |'
- en: '|   end |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: Exercise
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that, whereas in the numC case the interpreter returned numV(n), substitution
    returns in (i.e., the original expression, equivalent at that point to writing
    numC(n)). Why?
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，与numC情况不同，解释器返回numV(n)，替换返回in（即，在那一点上等价于编写numC(n)的原始表达式）。为什么？
- en: 26.1.4The Interpreter, Resumed
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.4解释器，续
- en: Phew! Now that we’ve completed the definition of substitution (or so we think),
    let’s complete the interpreter. Substitution was a heavyweight step, but it also
    does much of the work involved in applying a function. It is tempting to write<fof-interp-appC/alt>
    ::=
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！现在我们已经完成了替换的定义（或者我们这样认为），让我们完成解释器吧。替换是一个繁重的步骤，但它也完成了应用函数所涉及的大部分工作。写出下面的代码是诱人的<fof-interp-appC/alt>
    ::=
- en: '|   &#124; appC(f, a) => |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; appC(f, a) => |'
- en: '|     fd = get-fundef(f, fds) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|     fd = get-fundef(f, fds) |'
- en: '|     subst(a, fd.arg, fd.body) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|     subst(a, fd.arg, fd.body) |'
- en: Tempting, but wrong.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 诱人，但是错误的。
- en: Do Now!
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在做！
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why?
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你明白了吗？
- en: Reason from the types. What does the interpreter return? Values. What does substitution
    return? Oh, that’s right, expressions! For instance, when we substituted in the
    body of double, we got back the representation of 5 + 5. This is not a valid answer
    for the interpreter. Instead, it must be reduced to an answer. That, of course,
    is precisely what the interpreter does:<fof-interp-appC> ::=
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据类型推理。解释器返回什么？值。替换返回什么？哦，对了，表达式！例如，当我们在double的主体中进行替换时，我们得到了5 + 5的表示。这对解释器来说不是一个有效的答案。相反，它必须被简化为一个答案。当然，这正是解释器所做的：<fof-interp-appC>
    ::=
- en: '|   &#124; appC(f, a) => |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; appC(f, a) => |'
- en: '|     fd = get-fundef(f, fds) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|     fd = get-fundef(f, fds) |'
- en: '|     interp(subst(a, fd.arg, fd.body), fds) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|     interp(subst(a, fd.arg, fd.body), fds) |'
- en: 'Okay, that leaves only one case: identifiers. What could possibly be complicated
    about them? They should be just about as simple as numbers! And yet we’ve put
    them off to the very end, suggesting something subtle or complex is afoot.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在只剩下一个情况了：标识符。它们可能有什么复杂的地方呢？它们应该和数字一样简单！然而，我们把它们留到了最后，这说明有什么微妙或复杂的事情正在发生。
- en: Do Now!
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在做！
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work through some examples to understand what the interpreter should do in the
    identifier case.
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过一些示例来理解解释器在标识符情况下应该做什么。
- en: 'Let’s suppose we had defined double as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经定义了double如下：
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we substitute 5 for x, this produces the expression 5 + y. So far so good,
    but what is left to substitute y? As a matter of fact, it should be clear from
    the very outset that this definition of double is erroneous. The identifier y
    is said to be free, an adjective that in this setting has negative connotations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将5替换为x时，这将产生表达式5 + y。到目前为止一切顺利，但剩下的是什么替换y？事实上，从一开始就应该清楚，这个double的定义是错误的。标识符y被称为自由的，这个形容词在这个设置中具有负面含义。
- en: In other words, the interpreter should never confront an identifier. All identifiers
    ought to be parameters that have already been substituted (known as bound identifiers—<wbr>here,
    a positive connotation) before the interpreter ever sees them. As a result, there
    is only one possible response given an identifier:<fof-interp-idC> ::=
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，解释器不应该遇到标识符。所有标识符在解释器看到它们之前都应该是已经被替换的参数（这称为绑定的标识符—<wbr>这里，是一个积极的内涵）。因此，对于标识符只有一个可能的响应：<fof-interp-idC>
    ::=
- en: '|   &#124; idC(s) => raise("unbound identifier") |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; idC(s) => raise("未绑定的标识符") |'
- en: And that’s it!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: Finally, to complete our interpreter, we should define get-fundef:<get-fundef-body>
    ::=
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成我们的解释器，我们应该定义get-fundef：<get-fundef-body> ::=
- en: '|   cases (List<FunDefC>) fds: |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|   cases (List<FunDefC>) fds: |'
- en: '|     &#124; empty => raise("couldn''t find function") |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; 空 => raise("找不到函数") |'
- en: '|     &#124; link(f, r) => |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; link(f, r) => |'
- en: '|       if f.name == name: |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|       if f.name == name: |'
- en: '|         f |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|         f |'
- en: '|       else: |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|       否则： |'
- en: '|         get-fundef(name, r) |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|         get-fundef(name, r) |'
- en: '|       end |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|       结束 |'
- en: '|   end |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|   结束 |'
- en: 26.1.5Oh Wait, There’s More!
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等等，还有更多！
- en: 'Earlier, we declared subst as:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们声明了subst如下：
- en: '[PRE3]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sticking to surface syntax for brevity, suppose we apply double to 1 + 2. This
    would substitute 1 + 2 for each x, resulting in the following expression—<wbr>(1
    + 2) + (1 + 2)—<wbr>for interpretation. Is this necessarily what we want?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，假设我们将double应用于1 + 2。这将使1 + 2替换每个x，从而产生以下表达式—<wbr>（1 + 2）+（1 + 2）—<wbr>用于解释。这一定是我们想要的吗？
- en: 'When you learned algebra in school, you may have been taught to do this differently:
    first reduce the argument to an answer (in this case, 3), then substitute the
    answer for the parameter. This notion of substitution might have the following
    type instead:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在学校学习代数时，你可能被教导以不同的方式进行操作：首先将参数减少为一个答案（在这种情况下为3），然后将答案替换为参数。这种替换概念可能具有以下类型：
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In fact, we don’t even have substitution quite right! The version of substitution
    we have doesn’t scale past this language due to a subtle problem known as “name
    capture”. Fixing substitution is complex, subtle, and an exciting intellectual
    endeavor, but it’s not the direction I want to go in here. We’ll instead sidestep
    this problem in this book. If you’re interested, however, read about the lambda
    calculus [CITE], which provides the tools for defining substitution correctly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们甚至没有正确地理解替换！由于一个称为“名称捕获”的微妙问题，我们所拥有的替换版本无法扩展到此语言之外。修复替换是一个复杂而微妙的过程，也是一项令人兴奋的智力努力，但这不是我想要在这里进行的方向。在本书中，我们将避开这个问题。然而，如果你感兴趣，可以阅读关于[引用]
    λ演算的内容，它提供了正确定义替换的工具。
- en: Exercise
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify your interpreter to substitute names with answers, not expressions.
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改你的解释器以将名称替换为答案，而不是表达式。
- en: We’ve actually stumbled on a profound distinction in programming languages.
    The act of evaluating arguments before substituting them in functions is called
    eager application, while that of deferring evaluation is called lazy—<wbr>and
    has some variations. For now, we will actually prefer the eager semantics, because
    this is what most mainstream languages adopt. Later [REF], we will return to talking
    about the lazy application semantics and its implications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在编程语言中遇到了一个深刻的区别。在将参数在函数中替换之前评估参数的行为称为急切应用，而推迟评估的行为称为懒惰，<wbr>并且有一些变种。目前，我们实际上更喜欢急切的语义，因为这是大多数主流语言采用的方式。稍后[引用]，我们将重新讨论懒惰应用语义及其含义。
- en: 26.2From Substitution to Environments
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从替换到环境
- en: Though we have a working definition of functions, you may feel a slight unease
    about it. When the interpreter sees an identifier, you might have had a sense
    that it needs to “look it up”. Not only did it not look up anything, we [defined
    its behavior to be an error](#%28elem._fof-interp-id.C%29)! While absolutely correct,
    this is also a little surprising. More importantly, we write interpreters to understand
    and explain languages, and this implementation might strike you as not doing that,
    because it doesn’t match our intuition.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经对函数有了一个可行的定义，你可能对此感到有些不安。当解释器看到一个标识符时，你可能感到它需要“查找”它。它不仅没有查找任何内容，而且我们[定义了它的行为是一个错误](#%28elem._fof-interp-id.C%29)！虽然绝对正确，但这也有点令人惊讶。更重要的是，我们编写解释器来理解和解释语言，而这种实现可能会让你觉得不太符合，因为它不符合我们的直觉。
- en: There’s another difficulty with using substitution, which is the number of times
    we traverse the source program. It would be nice to have to traverse only those
    parts of the program that are actually evaluated, and then, only when necessary.
    But substitution traverses everything—<wbr>unvisited branches of conditionals,
    for instance—<wbr>and forces the program to be traversed once for substitution
    and once again for interpretation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换存在另一个困难，那就是我们遍历源程序的次数。最好只需遍历实际上被评估的程序部分，而且只在必要时进行。但是替换会遍历一切——例如未访问的条件分支——并且强制程序进行替换一次，并再次进行解释。
- en: Exercise
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does substitution have implications for the time complexity of evaluation?
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 替换对评估的时间复杂度有什么影响吗？
- en: There’s yet another problem with substitution, which is that it is defined in
    terms of representations of the program source. Obviously, our interpreter has
    and needs access to the source, to interpret it. However, other implementations—<wbr>such
    as compilers—<wbr>have no need to store it for that purpose.Compilers might store
    versions of or information about the source for other reasons, such as reporting
    runtime errors, and JITs may need it to re-compile on demand. It would be nice
    to employ a mechanism that is more portable across implementation strategies.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 替换还存在另一个问题，那就是它是根据程序源代码的表示定义的。显然，我们的解释器有并且需要访问源代码来解释它。然而，其他实现——例如编译器——不需要为此目的存储它。编译器可能为其他原因存储源代码的版本或信息，例如报告运行时错误，而JIT可能需要它以便根据需要重新编译。使用一种更适用于各种实现策略的机制将是不错的。
- en: 26.2.1Introducing the Environment
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2.1引入环境
- en: The intuition that addresses the first concern is to have the interpreter “look
    up” an identifier in some sort of directory. The intuition that addresses the
    second concern is to defer the substitution. Fortunately, these converge nicely
    in a way that also addresses the third. The directory records the intent to substitute,
    without actually rewriting the program source; by recording the intent, rather
    than substituting immediately, we can defer substitution; and the resulting data
    structure, which is called an environment, avoids the need for source-to-source
    rewriting and maps nicely to low-level machine representations. Each name association
    in the environment is called a binding.This does not mean our study of substitution
    was useless; to the contrary, many tools that work over programs—<wbr>such as
    compilers and analyzers—<wbr>use substitution. Just not for the purpose of evaluating
    it at run-time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 解决第一个问题的直觉是让解释器在某种目录中“查找”标识符。解决第二个问题的直觉是延迟替换。幸运的是，这些直觉很好地融合在一起，也解决了第三个问题。目录记录了替换的意图，而不是立即重写程序源代码；通过记录意图，而不是立即替换，我们可以延迟替换；而由此产生的数据结构，称为环境，避免了源码重写的需要，并且很好地映射到底层机器表示。环境中的每个名称关联都称为绑定。这并不意味着我们对替换的研究是无用的；相反，许多在程序上运行的工具——例如编译器和分析器——都使用替换。只是不是为了在运行时进行评估。
- en: 'Observe carefully that what we are changing is the implementation strategy
    for the programming language, not the language itself. Therefore, none of our
    datatypes for representing programs should change, neither—<wbr>and this is the
    critical part—<wbr>should the answers that the interpreter provides. As a result,
    we should think of the previous interpreter as a “reference implementation” that
    the one we’re about to write should match. Indeed, we should create a generator
    that creates lots of tests, runs them through both interpreters, and makes sure
    their answers are the same: i.e., the previous implementation is an oracle ([Oracles
    for Testing](testing.html#%28part._test-oracle%29)). Ideally, we should prove
    that the two interpreters behave the same, which is a good topic for advanced
    study.One subtlety is in defining precisely what “the same” means, especially
    with regards to failure.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first define our environment data structure. An environment is a collection
    of names associated with...what?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A natural question to ask here might be what the environment maps names to.
    But a better, more fundamental, question is: How to determine the answer to the
    “natural” question?'
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember that our environment was created to defer substitutions. Therefore,
    the answer lies in substitution. We discussed earlier ([Oh Wait, There’s More!](#%28part._eager-lazy-subst%29))
    that we want substitution to map names to answers, corresponding to an eager function
    application strategy. Therefore, the environment should map names to answers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 26.2.2Interpreting with Environments
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we can tackle the interpreter. One case is easy, but we should revisit
    all the others:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: <fof-env-interp> ::=
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '|   fun interp(e :: ExprC, nv :: Environment, fds :: List<FunDefC>) -> Value:
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '|     cases (ExprC) e: |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '|       [<fof-env-interp-arith>](#%28elem._fof-env-interp-arith%29) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '|       [<fof-env-interp-cond>](#%28elem._fof-env-interp-cond%29) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '|       [<fof-env-interp-idC>](#%28elem._fof-env-interp-id.C%29) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '|       [<fof-env-interp-appC>](#%28elem._fof-env-interp-app.C%29) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '|     end |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: The arithmetic operations are easiest. Recall that before, the interpreter recurred
    without performing any new substitutions. As a result, there are no new deferred
    substitutions to perform either, which means the environment does not change:<fof-env-interp-arith>
    ::=
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; numC(n) => numV(n) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '|   &#124; plusC(l, r) => arith-binop(lam(x, y): x + y end, l, r, nv, fds)
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '|   &#124; multC(l, r) => arith-binop(lam(x, y): x * y end, l, r, nv, fds)
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: Conditionals are similarly straightforward:<fof-env-interp-cond> ::=
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; trueC => boolV(true) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '|   &#124; falseC => boolV(false) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '|   &#124; ifC(cnd, thn, els) => |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '|     ic = interp(cnd, nv, fds) |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '|     if is-boolV(ic): |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '|       if ic.b: |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '|         interp(thn, nv, fds) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '|       else: |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '|         interp(els, nv, fds) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '|       end |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '|     else: |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '|       raise(''not a boolean'') |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '|     end |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: 'Now let’s handle identifiers. Clearly, encountering an identifier is no longer
    an error: this was the very motivation for this change. Instead, we must look
    up its value in the directory:<fof-env-interp-idC> ::='
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; idC(s) => lookup(s, nv) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: Do Now!
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement [lookup](#%28elem._fof-env-interp-lookup%29).
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finally, application. Observe that in the substitution interpreter, the only
    case that caused new substitutions to occur was application. Therefore, this should
    be the case that constructs bindings. Let’s first extract the function definition,
    just as before:<fof-env-interp-appC> ::=
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; appC(f, a) => |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '|     fd = get-fundef(f, fds) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '|     [<fof-env-interp-appC-rest>](#%28elem._fof-env-interp-app.C-rest%29)
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: Previously, we substituted, then interpreted. Because we have no substitution
    step, we can proceed with interpretation, so long as we record the deferral of
    substitution. Let’s also evaluate the argument:<fof-env-interp-appC-rest> ::=
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '|   arg-val = interp(a, nv, fds) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '|   interp(fd.body, [<fof-env-interp-appC-rest-xtnd>](#%28elem._fof-env-interp-app.C-rest-xtnd%29),
    fds) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: That is, the set of function definitions remains unchanged; we’re interpreting
    the body of the function, as before; but we have to do it in an environment that
    binds the formal parameter. Let’s now define that binding process:<fof-env-interp-appC-rest-xtnd>
    ::=
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '|   xtnd-env(bind(fd.arg, arg-val), nv) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: But we’ll [return to this](#%28elem._fof-env-interp-app.C-rest-xtnd-2%29). The
    name being bound is the formal parameter (the same name that was substituted for,
    before). It is bound to the result of interpreting the argument (because we’ve
    decided on an eager application semantics). And finally, this extends the environment
    we already have. Type-checking this helps to make sure we got all the little pieces
    right.Once we have a definition for lookup, we’d have a full interpreter. So here’s
    one:<fof-env-interp-lookup> ::=
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '|   fun lookup(s :: String, nv :: Environment) -> Value: |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '|     cases (List) nv: |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '|       &#124; empty => raise("unbound identifier: " + s) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '|       &#124; link(f, r) => |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '|         if s == f.name: |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '|           f.value |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '|         else: |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '|           lookup(s, r) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '|         end |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '|     end |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: Observe that looking up a free identifier still produces an error, but it has
    moved from the interpreter—<wbr>which is by itself unable to determine whether
    or not an identifier is free—<wbr>to lookup, which determines this based on the
    content of the environment.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a full interpreter. You should of course test it make sure it works
    as you’d expect. Let’s first set up some support code for testing:<fof-env-interp-tests-setup>
    ::=
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '|   check: |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '|     f1 = fdC("double", "x", plusC(idC("x"), idC("x"))) |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '|     f2 = fdC("quad", "x", appC("double", appC("double", idC("x")))) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '|     f3 = fdC("const5", "_", numC(5)) |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '|     f4 = fdC("f4", "x", s2p2d("(if x 1 0)")) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '|     funs = [list: f1, f2, f3, f4] |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '|     fun i(e): interp(e, mt-env, funs) end |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '|     [<fof-env-interp-tests>](#%28elem._fof-env-interp-tests%29) |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: For instance, these tests pass:<fof-env-interp-tests> ::=
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '|   i(plusC(numC(5), appC("quad", numC(3)))) is numV(17) |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '|   i(multC(appC("const5", numC(3)), numC(4))) is numV(20) |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '|   i(plusC(numC(10), appC("const5", numC(10)))) is numV(10 + 5) |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '|   i(plusC(numC(10), appC("double", plusC(numC(1), numC(2))))) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '|   is numV(10 + 3 + 3) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '|   i(plusC(numC(10), appC("quad", plusC(numC(1), numC(2))))) |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '|   is numV(10 + 3 + 3 + 3 + 3) |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '|   [<fof-env-interp-another-test>](#%28elem._fof-env-interp-another-test%29)
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: So we’re done, right?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Spot the bug.
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 26.2.3Deferring Correctly
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s another test:raise is explained earlier: [Testing Erroneous Programs](testing.html#%28part._test-raises%29).<fof-env-interp-another-test>
    ::='
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '|   interp(appC("f1", numC(3)), mt-env, |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '|     [list: fdC("f1", "x", appC("f2", numC(4))), |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '|       fdC("f2", "y", plusC(idC("x"), idC("y")))]) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '|   raises "unbound identifier: x" |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: 'In our interpreter, this evaluates to numV(7). Should it?Translated into Pyret,
    this test corresponds to the following two definitions and expression:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What should this produce? f1(3) substitutes x with 3 in the body of f1, which
    then invokes f2(4). But notably, in f2, the identifier x is not bound! Sure enough,
    Pyret will produce an error.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In fact, so will our [substitution-based interpreter](#%28elem._fof-interp%29)!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does the substitution process result in an error? It’s because, when we
    replace the representation of x with the representation of 3 in the representation
    of f1, we do so in f1 only.This “the representation of” is getting a little annoying,
    isn’t it? Therefore, I’ll stop saying that, but do make sure you understand why
    I had to say it. It’s an important bit of pedantry. (Obviously: x is f1’s parameter;
    even if another function had a parameter named x, that’s a different x.) Thus,
    when we get to evaluating the body of f2, its x hasn’t been substituted, resulting
    in the error.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'What went wrong when we switched to environments? Watch carefully: this is
    subtle. We can focus on applications, because only they affect the environment.
    When we substituted the formal for the value of the actual, we did so by extending
    the current environment. In terms of our example, we asked the interpreter to
    substitute not only f2’s substitution in f2’s body, but also the current ones
    (those for the caller, f1), and indeed all past ones as well. That is, the environment
    only grows; it never shrinks.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Because we agreed that environments are only an alternate implementation strategy
    for substitution—<wbr>and in particular, that the language’s meaning should not
    change—<wbr>we have to alter the interpreter. Concretely, we should not ask it
    to carry around all past deferred substitution requests, but instead make it start
    afresh for every new function, just as the substitution-based interpreter does.
    This is an easy change:<fof-env-interp-appC-rest-xtnd-2> ::=
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '|   xtnd-env(bind(fd.arg, arg-val), mt-env) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: Now we have truly reproduced the behavior of the substitution interpreter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 26.2.4Scope
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The broken environment interpreter above implements what is known as dynamic
    scope. This means the environment accumulates bindings as the program executes.
    As a result, whether an identifier is even bound depends on the history of program
    execution. We should regard this unambiguously as a flaw of programming language
    design. It adversely affects all tools that read and process programs: compilers,
    IDEs, and humans.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, substitution—<wbr>and environments, done correctly—<wbr>give us
    lexical scope or static scope. “Lexical” in this context means “as determined
    from the source program”, while “static” in computer science means “without running
    the program”, so these are appealing to the same intuition. When we examine an
    identifier, we want to know two things: (1) Is it bound? (2) If so, where? By
    “where” we mean: if there are multiple bindings for the same name, which one governs
    this identifier? Put differently, which one’s substitution will give a value to
    this identifier? In general, these questions cannot be answered statically in
    a dynamically-scoped language: so your IDE, for instance, cannot overlay arrows
    to show you this information (the way an IDE like DrRacket does).A different way
    to think about it is that in a dynamically-scoped language, the answer to these
    questions is the same for all identifiers, and it simply refers to the dynamic
    environment. In other words, it provides no useful information. Thus, even though
    the rules of scope become more complex as the space of names becomes richer (e.g.,
    objects, threads, etc.), we should always strive to preserve the spirit of static
    scoping.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 26.2.5How Bad Is It?
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might look at our running example and wonder whether we’re creating a tempest
    in a teapot. In return, you should consider two situations:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: To understand the binding structure of your program, you may need to look at
    the whole program. No matter how much you’ve decomposed your program into small,
    understandable fragments, it doesn’t matter if you have a free identifier anywhere.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding the binding structure is not only a function of the size of the
    program but also of the complexity of its control flow. Imagine an interactive
    program with numerous callbacks; you’d have to track through every one of them,
    too, to know which binding governs an identifier.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Need a little more of a nudge? Let’s replace the expression of our example
    program with this one:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Suppose moon-visible is a function that evaluates to false on new-moon nights,
    and true at other times. Then, this program will evaluate to an answer except
    on new-moon nights, when it will fail with an unbound identifier error.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens on cloudy nights?
  id: totrans-301
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 26.2.6The Top-Level Scope
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Matters become more complex when we contemplate top-level definitions in many
    languages. For instance, some versions of Scheme (which is a paragon of lexical
    scoping) allow you to write this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '| (define y 1) |'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define (f x) (+ x y)) |'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'which seems to pretty clearly suggest where the y in the body of f will come
    from, except:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '| (define y 1) |'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define (f x) (+ x y)) |'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define y 2) |'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'is legal and (f 10) produces 12. Wait, you might think, always take the last
    one! But consider:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '| (define y 1) |'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define f (let ((z y)) (lambda (x) (+ x y z)))) |'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define y 2) |'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Here, z is bound to the first value of y whereas the inner y is bound to the
    second value.Most “scripting” languages exhibit similar problems. As a result,
    on the Web you will find enormous confusion about whether a certain language is
    statically- or dynamically-scoped, when in fact readers are comparing behavior
    inside functions (often static) against the top-level (usually dynamic). Beware!
    There is actually a valid explanation of this behavior in terms of lexical scope,
    but it can become convoluted, and perhaps a more sensible option is to prevent
    such redefinition. Pyret does precisely this, thereby offering the convenience
    of a top-level without its pain.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 26.2.7Exposing the Environment
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we were building the implementation for others to use, it would be wise
    and a courtesy for the exported interpreter to take only an expression and list
    of function definitions, and invoke our defined interp with the empty environment.
    This both spares users an implementation detail, and avoids the use of an interpreter
    with an incorrect environment. In some contexts, however, it can be useful to
    expose the environment parameter. For instance, the environment can represent
    a set of pre-defined bindings: e.g., if the language wishes to provide pi automatically
    bound to 3.2 (in [Indiana](https://en.wikipedia.org/wiki/Indiana_Pi_Bill)).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 26.3Functions Anywhere
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The introduction to the Scheme programming language definition establishes
    this design principle:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages should be designed not by piling feature on top of feature,
    but by removing the weaknesses and restrictions that make additional features
    appear necessary. [REF]
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As design principles go, this one is hard to argue with. (Some restrictions,
    of course, have good reason to exist ([Functions and Predictability](#%28part._functions-and-predictability%29)),
    but this principle forces us to argue for them, not admit them by default.) Let’s
    now apply this to functions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: One of the things we stayed coy about when introducing functions ([Adding Functions
    to the Language](#%28part._adding-functions%29)) is exactly where functions go.
    We suggested we’re following the model of an idealized programming environment,
    with definitions and their uses kept separate. But, inspired by the Scheme design
    principle, let’s examine how necessary that is.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Why can’t functions definitions be expressions? In our current arithmetic-centric
    language we face the uncomfortable question “What value does a function definition
    represent?”, to which we don’t really have a good answer. But a real programming
    language obviously computes more than numbers and Booleans, so we no longer need
    to confront the question in this form; indeed, the answer to the above can just
    as well be, “A function value”. Let’s see how that might work out.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'What can we do with functions as values? Clearly, functions are a distinct
    kind of value than a number, so we cannot, for instance, add them. But there is
    one evident thing we can do: apply them to arguments! Thus, we can allow function
    values to appear in the function position of an application. The behavior would,
    naturally, be to apply the function. We are therefore proposing a language where
    the following would be a valid program (where I’ve used brackets so we can easily
    identify the function, and made up a syntax for it):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '| (+ 2 ([deffun f x (* x 3)] 4)) |'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: This would evaluate to (+ 2 (* 4 3)), or 14. (Did you see that I just used substitution?)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 26.3.1Functions as Expressions and Values
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s first define the core language to include function definitions:<hof-named-dd>
    ::=
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '|   data ExprC: |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '|     &#124; numC(n :: Number) |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '|     &#124; plusC(l :: ExprC, r :: ExprC) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '|     &#124; multC(l :: ExprC, r :: ExprC) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '|     &#124; trueC |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '|     &#124; falseC |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '|     &#124; ifC(c :: ExprC, t :: ExprC, e :: ExprC) |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '|     &#124; idC(s :: String) |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '|     [<hof-named-dd-fdC/1>](#%28elem._hof-named-dd-fd.C%2F1%29) |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '|     [<hof-named-dd-appC>](#%28elem._hof-named-dd-app.C%29) |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: For now, we’ll simply copy function definitions into the expression language.
    We’re free to change this if necessary as we go along, but for now it at least
    allows us to reuse our existing test cases.<hof-named-dd-fdC/1> ::=
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; fdC(name :: String, arg :: String, body :: ExprC) |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: This enables us to now get rid of FunDef.We also need to determine what an application
    looks like. What goes in the function position of an application? We want to allow
    an entire function definition, not just its name. Because we’ve lumped function
    definitions in with all other expressions, we need the annotation to be ExprC,
    but we can add a refinement (see (part "annotation-refinement")) to make clear
    it has to be a function definition:<hof-named-dd-appC> ::=
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; appC(f :: ExprC%(is-fdC), a :: ExprC) |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: 'With this definition of application, we no longer have to look up functions
    by name, so the interpreter can get rid of the list of function definitions. If
    we need it we can restore it later, but for now let’s just explore what happens
    with function definitions are written at the point of application: so-called immediate
    functions. Thus our interpreter looks like this:<hof-named-interp/1> ::='
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '|   fun interp(e :: ExprC, nv :: Environment): |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '|     # removed return annotation of Value because fdC is not a Value! |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '|     cases (ExprC) e: |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '|       &#124; numC(n) => numV(n) |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '|       &#124; plusC(l, r) => arith-binop(lam(x, y): x + y end, l, r, nv) |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '|       &#124; multC(l, r) => arith-binop(lam(x, y): x * y end, l, r, nv) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '|       &#124; trueC => boolV(true) |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '|       &#124; falseC => boolV(false) |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '|       &#124; ifC(cnd, thn, els) => |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '|         ic = interp(cnd, nv) |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '|         if is-boolV(ic): |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '|           if ic.b: |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '|             interp(thn, nv) |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '|           else: |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '|             interp(els, nv) |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '|           end |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '|         else: |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '|           raise(''not a boolean'') |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '|         end |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '|       &#124; idC(s) => lookup(s, nv) |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '|       [<hof-named-interp-fun/1>](#%28elem._hof-named-interp-fun%2F1%29) |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '|       [<hof-named-interp-app/1>](#%28elem._hof-named-interp-app%2F1%29) |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: Do Now!
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that we’ve left out the return annotation on interp. Why do you think
    this is? Run some examples to figure it out.
  id: totrans-368
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We need to add a case to the interpreter for function definitions, and this
    is a good candidate:<hof-named-interp-fun/1> ::=
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; fdC(_, _, _) => e |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
- en: The interpreter now no longer returns just Values; now it also returns function
    definitions. We could update our definition of Value (and thus restore the annotation),
    but we’ll soon find that we need to think this through a little more than we have.When
    we need to evaluate an application, we can simply evaluate the function position
    to obtain a function definition, and the rest of the evaluation process can remain
    unchanged:<hof-named-interp-app/1> ::=
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; appC(f, a) => |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '|     fun-val = interp(f, nv) |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '|     arg-val = interp(a, nv) |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '|     interp(fun-val.body, xtnd-env(bind(fun-val.arg, arg-val), mt-env)) |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: 'With that, our former examples works just fine:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 26.3.2A Small Improvement
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is there any part of our interpreter definition that we never use?
  id: totrans-381
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Yes there is: the name field of a function definition is never used. This is
    because we no longer look up functions by name: we obtain their definition through
    evaluation. Therefore, a simpler definition suffices:<hof-fun/2> ::='
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; fdC(arg :: String, body :: ExprC) |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: Do Now!
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see what else you need to change?
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In addition to the test cases, you also need to alter the interpreter fragment
    that handles definitions:<hof-interp-fun/2> ::=
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; fdC(_, _) => e |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
- en: In other words, our functions are now anonymous.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 26.3.3Nesting Functions
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The body of a function definition is an arbitrary expression. A function definition
    is itself an expression. That means a function definition can contain a...function
    definition. For instance:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: which evaluates to
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Applying this to numC(4) results in
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We might try to apply this to a number—<wbr>which it should double—<wbr>but
    we run afoul of the refinement annotation on the function position of an application,
    which envisioned only immediate functions, not expressions that can evaluate to
    functions. Therefore, we should remove this restriction:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, however, we use a slightly different function definition:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which evaluates to
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we have a clear problem, because x is no longer bound, even though it clearly
    was in an outer scope. Indeed, if we apply it to any value, we get an error because
    of the unbound identifier.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 26.3.4Nested Functions and Substitution
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the last two examples with a substitution-based interpreter instead.
    If we evaluate the application
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'using substitution, the inner binding masks the outer one, so no substitutions
    should take place, giving the same result:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the other example—<wbr>
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: —<wbr>however, substitution would replace the outer identifier, resulting in
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So once again, if we take substitution as our definition of correctness, we
    see that our interpreter produces the wrong answer.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we’re again failing to faithfully capture what substitution
    would have done. A function value needs to remember the substitutions that have
    already been applied to it. Because we’re representing substitutions using an
    environment, a function value therefore needs to be bundled with an environment.
    This resulting data structure is called a closure.“Save the environment! Create
    a closure today!”—<wbr>Cormac Flanagan
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 26.3.5Updating Values
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In other words, a function can’t just evaluate to its body: it must evaluate
    to a closure:<hof-value> ::='
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '|   data Value: |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '|     &#124; numV(n :: Number) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '|     &#124; boolV(b :: Boolean) |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
- en: '|     &#124; closV(f :: ExprC%(is-fdC), e :: Environment) |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: The refinement annotation reflects that we are expecting a very specific kind
    of expression—<wbr>that representing a function definition—<wbr>in a closure.The
    interpreter now uses it.Look, we got our return value annotation back! Most cases
    are unchanged from before:<hof-interp> ::=
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '|   fun interp(e :: ExprC, nv :: Environment) -> Value: |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '|     cases (ExprC) e: |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '|       [<hof-named-interp/1>](#%28elem._hof-named-interp%2F1%29) |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '|       [<hof-interp-fdC>](#%28elem._hof-interp-fd.C%29) |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: '|       [<hof-interp-appC>](#%28elem._hof-interp-app.C%29) |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: '|     end |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
- en: 'There are just two interesting cases: closure construction and closure use.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out these two cases.
  id: totrans-433
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: When evaluating a function, we have to create a closure that records the environment
    at the time of function creation:“[Closures] are relegated to relative obscurity
    until Java makes them popular by not having them.”—<wbr>[James Iry](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)<hof-interp-fdC>
    ::=
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; fdC(_, _) => closV(e, nv) |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: This leaves function applications. Now the function position could be any expression,
    so we have to evaluate it first. That produces a value that we expect is an instance
    of closV. From it we can therefore extract the function’s body (.f.body) and argument
    name (.f.arg), and we evaluate the body in the environment taken from the closure
    (clos.e):<hof-interp-appC> ::=
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; appC(f, a) => |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: '|     clos = interp(f, nv) |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '|     arg-val = interp(a, nv) |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '|     interp(clos.f.body, xtnd-env(bind(clos.f.arg, arg-val), clos.e)) |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: Exercise
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that the argument to interp is clos.e rather than mt-env. Write a program
    that illustrates the difference.
  id: totrans-443
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This now computes the same answer we would have gotten through substitution.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we now switch back to using substitution, will we encounter any problems?
  id: totrans-447
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yes, we will. We’ve defined substitution to replace program text in other program
    text. Strictly speaking we can no longer do this, because Value terms cannot be
    contained inside ExprC ones. That is, substitution is predicated on the assumption
    that the type of answers is a form of syntax. It is actually possible to carry
    through a study of programming under this assumption, but we won’t take that path
    here.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 26.3.6Sugaring Over Anonymity
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s get back to the idea of naming functions, which has evident value
    for program understanding. Observe that we do have a way of naming things: by
    passing them to functions, where they acquire a local name (that of the formal
    parameter). Anywhere within that function’s body, we can refer to that entity
    using the formal parameter name.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can name a function definion using another...function definition.
    For instance, the Pyret code
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: could first be rewritten as the equivalent
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'which by substitution evaluates to (lam(x): x + x end)(10) or 20.Indeed, this
    pattern is a local naming mechanism, and virtually every language has it in some
    form or another. In languages like Lisp and ML variants, it is usually called
    let.Note that in different languages, let has different scope rules: in some cases
    it permits recursive definitions, and in others it doesn’t. For instance, in Racket:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '| (let ([double (lambda (x) (+ x x))]) |'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (double 10)) |'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'In Pyret, as in several other languages like Java, there is no explicitly named
    construct of this sort, but any definition block permits local definitions such
    as this:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s a more complex example, written in Racket to illustrate a point about
    scope:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (double x) (+ x x)) |'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define (quad x) (double (double x))) |'
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (quad 10) |'
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: This could be rewritten as
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '| (let ([double (lambda (x) (+ x x))]) |'
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (let ([quad (lambda (x) (double (double x)))]) |'
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (quad 10))) |'
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: which works just as we’d expect; but if we change the order, it no longer works—<wbr>
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '| (let ([quad (lambda (x) (double (double x)))]) |'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (let ([double (lambda (x) (+ x x))]) |'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (quad 10))) |'
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '—<wbr>because quad can’t “see” double. So we see that top-level binding is
    different from local binding: essentially, the top-level has “infinite scope”.
    This is the source of both its power and problems.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 26.4Recursion and Non-Termination
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully you can convince yourself that our pure expression languages—<wbr>with
    only arithmetic and conditionals—<wbr>could not create non-terminating programs.
    Why? Because [its interpreter](growing-lang.html#%28elem._ext-arith-cond-interp%29)
    is purely structural over a non-cyclic datatype. In contrast, even our [very first
    function interpreter](#%28elem._fof-interp%29) is generative, which therefore
    opens up the possibility that it can have non-terminating computation.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct a non-terminating program for that interpreter.
  id: totrans-477
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And, indeed, it can. Here’s a function definition:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'and we just need to get it started:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Exercise
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Precisely identify the generative recursion that enables this.
  id: totrans-484
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this work? Why is this an infinite loop?
  id: totrans-487
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What’s happening here is actually somewhat subtle. The initial call to interp
    results in the interpreter finding a function and interpreting its body, which
    results in another call to interp: which finds the function and interprets its
    body, which results...and so on. If for some reason Pyret did not support recursion
    (which, historically, some languages did not!), then this would not work. Indeed,
    there is still something we are leaving to Pyret:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this program truly run for “ever” (meaning, as long as the computer is
    functioning properly), or does it run out of stack space?
  id: totrans-491
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Okay, that was easy. Now let’s consider our [most recent interpreter](#%28elem._hof-interp%29).
    What can it do?
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this simple infinite loop in Pyret:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s convert it to use an anonymous function:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '| loop-forever = lam(): loop-forever() end |'
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| loop-forever() |'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Seems fine, right? Use the let desugaring above:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '| (lam(loop-forever): loop-forever() end)(lam(): loop-forever() end) |'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: And now, loop-forever on the last line isn’t bound!
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, Pyret’s = is clearly doing something more than just textual substitution:
    it is also “tying the loop” for recursive definitions.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can we try anything else that might succeed?
  id: totrans-504
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Actually, we can. Here it is. To make it more readable we’ll first give the
    important intermediate term a name (and then see that the name isn’t necessary):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Given this, we can then define:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Exercise
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this run forever? Consider using substitution to explain why.
  id: totrans-511
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that we could have written the whole thing without any names at all:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As the names above suggest, the function is conventionally called ω (little
    omega in Greek), and the bigger term Ω (capital omega). To understand how we could
    have arrived at this magical term, see [[EMPTY]](shrinking-the-language.html).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 26.5Functions and Predictability
  id: totrans-515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We began ([Adding Functions to the Language](#%28part._adding-functions%29))
    with a language where at all application points, we knew exactly which function
    was going to be invoked (because we knew its name, and the name referred to one
    of a fixed global set). These are known as first-order functions. In contrast,
    we later moved to a language ([Functions Anywhere](#%28part._higher-order-functions%29))
    with first-class functions: those that had the same status as any other value
    in the language.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: This transition gave us a great deal of new flexiblity. For instance, we saw
    ([Sugaring Over Anonymity](#%28part._let-desugar%29)) that some seemingly necessary
    language features could instead be implemented just as syntactic sugar; indeed,
    with true first-class functions, we can define all of computation ([[EMPTY]](shrinking-the-language.html)).
    So what’s not to like?
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'The subtle problem is that whenever we increase our expressive power, we correspondingly
    weaken our predictive power. In particular, when confronted with a particular
    function application in a program, the question is, can we tell precisely which
    function is going to be invoked at this point? With first-order functions, yes;
    with higher-order functions, this is undecidable. Having this predictive power
    has many important consequences: a compiler can choose to inline (almost) every
    function application; a programming environment can give substantial help about
    which function is being called at that point; a security analyzer can definitively
    rule out known bad functions, thereby reducing the number of useless alerts it
    generates. Of course, with higher-order functions, all these operations are still
    sometimes possible; but they are not always possible, and how possible they are
    depends on the structure of the program and the cleverness of tools.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With higher-order functions, why is determining the precise function at an application
    undecidable?
  id: totrans-521
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does the above reference to inlining say “almost”?
  id: totrans-524
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
