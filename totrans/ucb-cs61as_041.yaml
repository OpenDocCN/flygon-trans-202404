- en: Applied HOFs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** This section is a bit more dense than the rest of the lesson. If
    you struggle with this section, don''t worry—it''s more advanced than most of
    what we''ll expect you to know.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will explore two applied examples using the tools we have learned
    so far: `fixed-point` and `iterate`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed-point`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first try to express the calculation of **fixed points** of functions.
    A number `x` is called a fixed point of a function `f` if `x` satisfies the equation
    `f(x) = x`.
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm that finds a fixed point for some functions `f` is one where we
    start with an initial guess and apply `f` repeatedly, until successive values
    are very close.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this idea, we''ll make a procedure `fixed-point` that will keep applying
    a function until we find two successive values whose difference is less than some
    prescribed `tolerance`. Take a look at our definition of `fixed-point` below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can use this method to approximate the fixed point of the cosine
    function, starting with 1 as an initial approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate the power of abstracting functions with `fixed-point`, we will
    develop a method to calculate square roots with only 3 lines of Racket code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing the square root of some number `x` requires finding a `y` such that
    `y² = x`. Putting this equation into the equivalent form `y = x / y`, you can
    see that we are looking for a fixed point of the function `(lambda (y) (/ x y))`.
    In code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you happen to have an interpreter handy, though, you''ll find that this
    doesn''t work. To see why, look at the successive guesses of, say, `(sqrt 4)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It just keeps oscillating! If you think about it, it'll do that for any number
    we put in (except 0 or 1).
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of changing the guess by `1`, we'll adjust by a little less. To
    do that, we'll average the next guess with the current guess. That is, the next
    guess after `y` is `(1/2)(y + x/y)` instead of `x/y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of making such a sequence of guesses is simply the process of looking
    for a fixed point of `y = (1/2)(y + x/y)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this modification, the square-root procedure works. This approach of averaging
    successive approximations to a solution, a technique the SICP authors call `average
    damping`, often aids the convergence of fixed- point searches.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s continue our abstraction frenzy and abstract the average damping
    technique as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, a new `sqrt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Amazingly clear, eh?
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`y = (1/2)(y + x/y)` is a simple transformation of the equation `y = x / y`;
    to derive it, add `y` to both sides of the equation and divide by `2`.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have effectively derived Newton's method for calculating
    square roots. But... there are so many other ways! If you're intersted, here's
    a [cool link](http://en.wikipedia.org/wiki/Methods_of_computing_square_roots).
  prefs: []
  type: TYPE_NORMAL
- en: '`iterate`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now conclude this lesson with another higher order function.
  prefs: []
  type: TYPE_NORMAL
- en: This one will allow us to write `fixed-point` AND `largest-square` (from Lesson
    1).
  prefs: []
  type: TYPE_NORMAL
- en: How, you ask? Because they both fall under the general form of **iterative improvement**.
    That is, you start with a value and keep improving it until it is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice there are 3 things to abstract here:'
  prefs: []
  type: TYPE_NORMAL
- en: the starting value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the function to improve
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the function to test if it's good enough
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, with that, we know our parameters and what it should do, so let's write
    it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, I''ll express `largest-square` with `iterate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our abstraction frenzy (mostly) ends here, but be on your toes. Abstraction
    is what allows programmers to write complex but readable systems.
  prefs: []
  type: TYPE_NORMAL
- en: Never miss a good opportunity to abstract.
  prefs: []
  type: TYPE_NORMAL
