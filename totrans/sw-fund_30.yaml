- en: ReferencesTyping Mutable References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Lists.List.
  prefs: []
  type: TYPE_NORMAL
- en: Import ListNotations.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we study adding mutable references to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simply-typed lambda calculus with natural numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The basic operations on references are *allocation*,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*dereferencing*, and *assignment*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To allocate a reference, we use the ref operator, providing an initial value
    for the new cell. For example, ref 5 creates a new cell containing the value 5,
    and reduces to a reference to that cell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read the current value of this cell, we use the dereferencing operator !;
    for example, !(ref 5) reduces to 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change the value stored in a cell, we use the assignment operator. If r is
    a reference, r := 7 will store the value 7 in the cell referenced by r.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: T ::= Nat
  prefs: []
  type: TYPE_NORMAL
- en: '| Unit'
  prefs: []
  type: TYPE_NORMAL
- en: '| T → T'
  prefs: []
  type: TYPE_NORMAL
- en: '| Ref T'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Terms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides variables, abstractions, applications,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: natural-number-related terms, and unit, we need four more sorts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'of terms in order to handle mutable references:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Intuitively:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ref t (formally, tref t) allocates a new reference cell with the value t and
    reduces to the location of the newly allocated cell;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!t (formally, tderef t) reduces to the contents of the cell referenced by t;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: t[1] := t[2] (formally, tassign t[1] t[2]) assigns t[2] to the cell referenced
    by t[1]; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: l (formally, tloc l) is a reference to the cell at location l. We'll discuss
    locations later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In informal examples, we'll also freely use the extensions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the STLC developed in the [MoreStlc](MoreStlc.html) chapter; however, to
    keep
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the proofs small, we won't bother formalizing them again here.  (It
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: would be easy to do so, since there are no very interesting
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: interactions between those features and references.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Values and Substitution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides abstractions and numbers, we have two new types of values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the unit value, and locations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Extending substitution to handle the new syntax of terms is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: straightforward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Pragmatics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: r:=succ(!r); !r
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: (λx:Unit. !r) (r:=succ(!r)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: r:=succ(!r); r:=succ(!r); r:=succ(!r); r:=succ(!r); !r
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Definition tseq t[1] t[2] :=
  prefs: []
  type: TYPE_NORMAL
- en: tapp (tabs (Id "x") TUnit t[2]) t[1].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: let r = ref 5 in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let s = r in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: s := 82;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (!r)+1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: r := 5; r := !s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: r := !s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Shared State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, aliasing is also a large part of what makes references
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useful.  In particular, it allows us to set up "implicit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: communication channels" — shared state — between different parts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of a program.  For example, suppose we define a reference cell and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'two functions that manipulate its contents:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that, since their argument types are Unit, the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arguments to the abstractions in the definitions of incc and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: decc are not providing any useful information to the bodies of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: these functions (using the wildcard _ as the name of the bound
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable is a reminder of this).  Instead, their purpose of these
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: abstractions is to "slow down" the execution of the function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bodies.  Since function abstractions are values, the two lets are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: executed simply by binding these functions to the names incc and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: decc, rather than by actually incrementing or decrementing c.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Later, each caddll to one of these functions results in its body
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: being executed once and performing the appropriate mutation on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c.  Such functions are often called *thunks*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the context of these declarations, calling incc results in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: changes to c that can be observed by calling decc.  For
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example, if we replace the ... with (incc unit; incc unit; decc unit), the result
    of the whole program will be 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: newcounter =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: λ_:Unit.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let c = ref 0 in
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let incc = λ_:Unit. (c := succ (!c); !c) in
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let decc = λ_:Unit. (c := pred (!c); !c) in
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{i=incc, d=decc}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: let c1 = newcounter unit in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let c2 = newcounter unit in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Note that we've allocated two separate storage cells now!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let r1 = c1.i unit in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let r2 = c2.i unit in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: r2  // yields 1, not 2!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: References to Compound Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A reference cell need not contain just a number: the primitives'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we've defined above allow us to create references to values of any
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type, including functions.  For example, we can use references to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: functions to give an (inefficient) implementation of arrays
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of numbers, as follows.  Write NatArray for the type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ref (Nat→Nat).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Recall the equal function from the [MoreStlc](MoreStlc.html) chapter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To build a new array, we allocate a reference cell and fill
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it with a function that, when given an index, always returns 0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To look up an element of an array, we simply apply
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the function to the desired index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The interesting part of the encoding is the update function.  It
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: takes an array, an index, and a new value to be stored at that index, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: does its job by creating (and storing in the reference) a new function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that, when it is asked for the value at this very index, returns the new
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: value that was given to update, while on all other indices it passes the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lookup to the function that was previously stored in the reference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: References to values containing other references can also be very
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useful, allowing us to define data structures such as mutable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lists and trees.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, recommended (compact_update)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we defined update more compactly like this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: would it behave the same?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Garbage Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A last issue that we should mention before we move on with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: formalizing references is storage *de*-allocation.  We have not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: provided any primitives for freeing reference cells when they are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: no longer needed.  Instead, like many modern languages (including
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ML and Java) we rely on the run-time system to perform *garbage collection*,
    automatically identifying and reusing cells that can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: no longer be reached by the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is *not* just a question of taste in language design: it is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: extremely difficult to achieve type safety in the presence of an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: explicit deallocation operation.  One reason for this is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'familiar *dangling reference* problem: we allocate a cell holding'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a number, save a reference to it in some data structure, use it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for a while, then deallocate it and allocate a new cell holding a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: boolean, possibly reusing the same storage.  Now we can have two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: names for the same storage cell — one with type Ref Nat and the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: other with type Ref Bool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (type_safety_violation)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show how this can lead to a violation of type safety.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most subtle aspect of the treatment of references
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: appears when we consider how to formalize their operational
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: behavior.  One way to see why is to ask, "What should be the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*values* of type Ref T?"  The crucial observation that we need'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to take into account is that reduci a ref operator should
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*do* something — namely, allocate some storage — and the result'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the operation should be a reference to this storage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What, then, is a reference?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The run-time store in most programming-language implementations is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: essentially just a big array of bytes.  The run-time system keeps
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: track of which parts of this array are currently in use; when we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need to allocate a new reference cell, we allocate a large enough
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: segment from the free region of the store (4 bytes for integer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cells, 8 bytes for cells storing Floats, etc.), record somewhere
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that it is being used, and return the index (typically, a 32- or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 64-bit integer) of the start of the newly allocated region.  These
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: indices are references.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For present purposes, there is no need to be quite so concrete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can think of the store as an array of *values*, rather than an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: array of bytes, abstracting away from the different sizes of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: run-time representations of different values.  A reference, then,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is simply an index into the store.  (If we like, we can even
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: abstract away from the fact that these indices are numbers, but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for purposes of formalization in Coq it is convenient to use
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: numbers.)  We use the word *location* instead of *reference* or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*pointer* to emphasize this abstract quality.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Treating locations abstractly in this way will prevent us from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: modeling the *pointer arithmetic* found in low-level languages
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: such as C.  This limitation is intentional.  While pointer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arithmetic is occasionally very useful, especially for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: implementing low-level services such as garbage collectors, it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'cannot be tracked by most type systems: knowing that location n'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the store contains a float doesn't tell us anything useful
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about the type of location n+4.  In C, pointer arithmetic is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: notorious source of type-safety violations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Definition store := list tm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Definition store_lookup (n:nat) (st:store) :=
  prefs: []
  type: TYPE_NORMAL
- en: nth n st tunit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint replace {A:Type} (n:nat) (x:A) (l:list A) : list A :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil    ⇒ nil'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| O    ⇒ x :: t'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ h :: replace n'' x t'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma replace_nil : ∀A n (x:A),'
  prefs: []
  type: TYPE_NORMAL
- en: replace n x nil = nil.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: destruct n; auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma length_replace : ∀A n x (l:list A),'
  prefs: []
  type: TYPE_NORMAL
- en: length (replace n x l) = length l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros A n x l. generalize dependent n.
  prefs: []
  type: TYPE_NORMAL
- en: induction l; intros n.
  prefs: []
  type: TYPE_NORMAL
- en: destruct n...
  prefs: []
  type: TYPE_NORMAL
- en: destruct n...
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite IHl...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma lookup_replace_eq : ∀l t st,'
  prefs: []
  type: TYPE_NORMAL
- en: l < length st →
  prefs: []
  type: TYPE_NORMAL
- en: store_lookup l (replace l t st) = t.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros l t st.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [store_lookup](References.html#STLCRef.store_lookup).
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent l.
  prefs: []
  type: TYPE_NORMAL
- en: induction st as [|t' st']; intros l Hlen.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* st =  *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hlen.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* st = t'' :: st'' *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct l; simpl...
  prefs: []
  type: TYPE_NORMAL
- en: apply IHst'. simpl in Hlen. omega.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma lookup_replace_neq : ∀l[1] l[2] t st,'
  prefs: []
  type: TYPE_NORMAL
- en: l[1] ≠ l[2] →
  prefs: []
  type: TYPE_NORMAL
- en: store_lookup l[1] (replace l[2] t st) = store_lookup l[1] st.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold [store_lookup](References.html#STLCRef.store_lookup).
  prefs: []
  type: TYPE_NORMAL
- en: induction l[1] as [|l[1]']; intros l[2] t st Hneq.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l[1] = 0 *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct st.
  prefs: []
  type: TYPE_NORMAL
- en: + (* st =  *) rewrite [replace_nil](References.html#STLCRef.replace_nil)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* st = _ :: _ *) destruct l[2]... contradict Hneq...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l[1] = S l[1]'' *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct st as [|t[2] st[2]].
  prefs: []
  type: TYPE_NORMAL
- en: + (* st =  *) destruct l[2]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* st = t[2] :: st[2] *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct l[2]...
  prefs: []
  type: TYPE_NORMAL
- en: simpl; apply IHl1'...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "t1 '/' st1 '⇒' t2 '/' st2"
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st[1] at level 39, t[2] at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: Import ListNotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step : tm * store → tm * store → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_AppAbs : ∀x T t[12] v[2] st,'
  prefs: []
  type: TYPE_NORMAL
- en: value v[2] →
  prefs: []
  type: TYPE_NORMAL
- en: tapp (tabs x T t[12]) v[2] / st ⇒ [x:=v[2]]t[12] / st
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_App1 : ∀t[1] t[1]'' t[2] st st'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] / st ⇒ t[1]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tapp t[1] t[2] / st ⇒ tapp t[1]' t[2] / st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_App2 : ∀v[1] t[2] t[2]'' st st'','
  prefs: []
  type: TYPE_NORMAL
- en: value v[1] →
  prefs: []
  type: TYPE_NORMAL
- en: t[2] / st ⇒ t[2]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tapp v[1] t[2] / st ⇒ tapp v[1] t[2]'/ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_SuccNat : ∀n st,'
  prefs: []
  type: TYPE_NORMAL
- en: tsucc (tnat n) / st ⇒ tnat (S n) / st
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Succ : ∀t[1] t[1]'' st st'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] / st ⇒ t[1]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tsucc t[1] / st ⇒ tsucc t[1]' / st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_PredNat : ∀n st,'
  prefs: []
  type: TYPE_NORMAL
- en: tpred (tnat n) / st ⇒ tnat (pred n) / st
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Pred : ∀t[1] t[1]'' st st'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] / st ⇒ t[1]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tpred t[1] / st ⇒ tpred t[1]' / st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_MultNats : ∀n[1] n[2] st,'
  prefs: []
  type: TYPE_NORMAL
- en: tmult (tnat n[1]) (tnat n[2]) / st ⇒ tnat (mult n[1] n[2]) / st
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Mult1 : ∀t[1] t[2] t[1]'' st st'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] / st ⇒ t[1]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tmult t[1] t[2] / st ⇒ tmult t[1]' t[2] / st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Mult2 : ∀v[1] t[2] t[2]'' st st'','
  prefs: []
  type: TYPE_NORMAL
- en: value v[1] →
  prefs: []
  type: TYPE_NORMAL
- en: t[2] / st ⇒ t[2]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tmult v[1] t[2] / st ⇒ tmult v[1] t[2]' / st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_If[0] : ∀t[1] t[1]'' t[2] t[3] st st'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] / st ⇒ t[1]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tif0 t[1] t[2] t[3] / st ⇒ tif0 t[1]' t[2] t[3] / st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_If0_Zero : ∀t[2] t[3] st,'
  prefs: []
  type: TYPE_NORMAL
- en: tif0 (tnat 0) t[2] t[3] / st ⇒ t[2] / st
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_If0_Nonzero : ∀n t[2] t[3] st,'
  prefs: []
  type: TYPE_NORMAL
- en: tif0 (tnat (S n)) t[2] t[3] / st ⇒ t[3] / st
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_RefValue : ∀v[1] st,'
  prefs: []
  type: TYPE_NORMAL
- en: value v[1] →
  prefs: []
  type: TYPE_NORMAL
- en: tref v[1] / st ⇒ tloc (length st) / (st ++ v[1]::nil)
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Ref : ∀t[1] t[1]'' st st'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] / st ⇒ t[1]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tref t[1] /  st ⇒ tref t[1]' /  st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_DerefLoc : ∀st l,'
  prefs: []
  type: TYPE_NORMAL
- en: l < length st →
  prefs: []
  type: TYPE_NORMAL
- en: tderef (tloc l) / st ⇒ store_lookup l st / st
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Deref : ∀t[1] t[1]'' st st'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] / st ⇒ t[1]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tderef t[1] / st ⇒ tderef t[1]' / st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Assign : ∀v[2] l st,'
  prefs: []
  type: TYPE_NORMAL
- en: value v[2] →
  prefs: []
  type: TYPE_NORMAL
- en: l < length st →
  prefs: []
  type: TYPE_NORMAL
- en: tassign (tloc l) v[2] / st ⇒ tunit / replace l v[2] st
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Assign1 : ∀t[1] t[1]'' t[2] st st'','
  prefs: []
  type: TYPE_NORMAL
- en: t[1] / st ⇒ t[1]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tassign t[1] t[2] / st ⇒ tassign t[1]' t[2] / st'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Assign2 : ∀v[1] t[2] t[2]'' st st'','
  prefs: []
  type: TYPE_NORMAL
- en: value v[1] →
  prefs: []
  type: TYPE_NORMAL
- en: t[2] / st ⇒ t[2]' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: tassign v[1] t[2] / st ⇒ tassign v[1] t[2]' / st'
  prefs: []
  type: TYPE_NORMAL
- en: where "t1 '/' st1 '⇒' t2 '/' st2" := (step (t[1],st[1]) (t[2],st[2])).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Hint Constructors step.
  prefs: []
  type: TYPE_NORMAL
- en: Definition multistep := (multi step).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "t1 '/' st '⇒*' t2 '/' st'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (multistep (t[1],st) (t[2],st'))
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39, t[2] at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Definition context := partial_map ty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[\x:Nat. (!(loc 1)) x, λx:Nat. (!(loc 0)) x]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Definition store_ty := list ty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Definition store_Tlookup (n:nat) (ST:store_ty) :=
  prefs: []
  type: TYPE_NORMAL
- en: nth n ST TUnit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The Typing Relation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now formalize the typing relation for the STLC with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: references.  Here, again, are the rules we're adding to the base
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'STLC (with numbers and Unit):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: l < &#124;st&#124;< td="">
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_Loc)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gamma; ST ⊢ loc l : Ref (lookup l ST)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gamma; ST ⊢ t[1] : T[1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_Ref)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gamma; ST ⊢ ref t[1] : Ref T[1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gamma; ST ⊢ t[1] : Ref T[11]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_Deref)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gamma; ST ⊢ !t[1] : T[11]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gamma; ST ⊢ t[1] : Ref T[11]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gamma; ST ⊢ t[2] : T[11]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (T_Assign)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Gamma; ST ⊢ t[1] := t[2] : Unit
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Of course, these typing rules will accurately predict the results
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of reduction only if the concrete store used during reduction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: actually conforms to the store typing that we assume for purposes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of typechecking.  This proviso exactly parallels the situation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with free variables in the basic STLC: the substitution lemma'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'promises that, if Γ ⊢ t : T, then we can replace the free'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variables in t with values of the types listed in Γ to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: obtain a closed term of type T, which, by the type preservation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: theorem will reduce to a final result of type T if it yields
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: any result at all.  We will see below how to formalize an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: analogous intuition for stores and store typings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, for purposes of typechecking the terms that programmers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: actually write, we do not need to do anything tricky to guess what
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: store typing we should use.  Concrete locations arise only in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: terms that are the intermediate results of reduction; they are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not in the language that programmers write.  Thus, we can simply
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typecheck the programmer's terms with respect to the *empty* store
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typing.  As reduction proceeds and new locations are created, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: will always be able to see how to extend the store typing by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: looking at the type of the initial values being placed in newly
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: allocated cells; this intuition is formalized in the statement of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the type preservation theorem below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Well-Typed Stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have extended both the reduction relation (with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: initial and final stores) and the typing relation (with a store
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typing), we need to change the statement of preservation to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: include these parameters.  But clearly we cannot just add stores
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and store typings without saying anything about how they are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'related — i.e., this is wrong:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we typecheck with respect to some set of assumptions about the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: types of the values in the store and then reduce with respect to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a store that violates these assumptions, the result will be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: disaster.  We say that a store st is *well typed* with respect a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: store typing ST if the term at each location l in st has the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type at location l in ST.  Since only closed terms ever get
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: stored in locations (why?), it suffices to type them in the empty
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: context. The following definition of store_well_typed formalizes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Informally, we will write ST ⊢ st for store_well_typed ST st.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Intuitively, a store st is consistent with a store typing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ST if every value in the store has the type predicted by the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: store typing.  The only subtle point is the fact that, when
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typing the values in the store, we supply the very same store
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typing to the typing relation.  This allows us to type circular
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: stores like the one we saw above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (store_not_unique)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Can you find a store st, and two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: different store typings ST[1] and ST[2] such that both
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ST[1] ⊢ st and ST[2] ⊢ st?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can now state something closer to the desired preservation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'property:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This statement is fine for all of the reduction rules except
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the allocation rule ST_RefValue.  The problem is that this rule
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yields a store with a larger domain than the initial store, which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'falsifies the conclusion of the above statement: if st'' includes'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a binding for a fresh location l, then l cannot be in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: domain of ST, and it will not be the case that t' (which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitely mentions l) is typable under ST.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive extends : store_ty → store_ty → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| extends_nil  : ∀ST'','
  prefs: []
  type: TYPE_NORMAL
- en: extends ST' nil
  prefs: []
  type: TYPE_NORMAL
- en: '| extends_cons : ∀x ST'' ST,'
  prefs: []
  type: TYPE_NORMAL
- en: extends ST' ST →
  prefs: []
  type: TYPE_NORMAL
- en: extends (x::ST') (x::ST).
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors extends.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma extends_lookup : ∀l ST ST'','
  prefs: []
  type: TYPE_NORMAL
- en: l < length ST →
  prefs: []
  type: TYPE_NORMAL
- en: extends ST' ST →
  prefs: []
  type: TYPE_NORMAL
- en: store_Tlookup l ST' = store_Tlookup l ST.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros l ST ST' Hlen H.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent ST'. generalize dependent l.
  prefs: []
  type: TYPE_NORMAL
- en: induction ST as [|a ST[2]]; intros l Hlen ST' HST'.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* nil *) inversion Hlen.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* cons *) unfold [store_Tlookup](References.html#STLCRef.store_Tlookup)
    in *.'
  prefs: []
  type: TYPE_NORMAL
- en: destruct ST'.
  prefs: []
  type: TYPE_NORMAL
- en: + (* ST' = nil *) inversion HST'.
  prefs: []
  type: TYPE_NORMAL
- en: + (* ST' = a' :: ST'2 *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion HST'; subst.
  prefs: []
  type: TYPE_NORMAL
- en: destruct l as [|l'].
  prefs: []
  type: TYPE_NORMAL
- en: '* (* l = 0 *) auto.'
  prefs: []
  type: TYPE_NORMAL
- en: '* (* l = S l'' *) simpl. apply IHST2...'
  prefs: []
  type: TYPE_NORMAL
- en: simpl in Hlen; omega.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma length_extends : ∀l ST ST'','
  prefs: []
  type: TYPE_NORMAL
- en: l < length ST →
  prefs: []
  type: TYPE_NORMAL
- en: extends ST' ST →
  prefs: []
  type: TYPE_NORMAL
- en: l < length ST'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros. generalize dependent l. induction H[0]; intros l Hlen.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hlen.
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *.
  prefs: []
  type: TYPE_NORMAL
- en: destruct l; try omega.
  prefs: []
  type: TYPE_NORMAL
- en: apply [lt_n_S](http://coq.inria.fr/library/Coq.Arith.Lt.html#lt_n_S). apply
    IHextends. omega.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma extends_app : ∀ST T,'
  prefs: []
  type: TYPE_NORMAL
- en: extends (ST ++ T) ST.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction ST; intros T...
  prefs: []
  type: TYPE_NORMAL
- en: simpl...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma extends_refl : ∀ST,'
  prefs: []
  type: TYPE_NORMAL
- en: extends ST ST.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction ST; auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Definition preservation_theorem := ∀ST t t' T st st',
  prefs: []
  type: TYPE_NORMAL
- en: empty; ST ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: store_well_typed ST st →
  prefs: []
  type: TYPE_NORMAL
- en: t / st ⇒ t' / st' →
  prefs: []
  type: TYPE_NORMAL
- en: ∃ST',
  prefs: []
  type: TYPE_NORMAL
- en: (extends ST' ST ∧
  prefs: []
  type: TYPE_NORMAL
- en: empty; ST' ⊢ t' ∈ T ∧
  prefs: []
  type: TYPE_NORMAL
- en: store_well_typed ST' st').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Substitution Lemma
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need an easy extension of the standard substitution
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lemma, along with the same machinery about context invariance that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we used in the proof of the substitution lemma for the STLC.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Assignment Preserves Store Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we must show that replacing the contents of a cell in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: store with a new value of appropriate type does not change the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: overall type of the store.  (This is needed for the ST_Assign
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rule.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Weakening for Stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we need a lemma on store typings, stating that, if a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: store typing is extended with a new location, the extended one
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: still allows us to assign the same types to the same terms as the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: original.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (The lemma is called store_weakening because it resembles the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"weakening" lemmas found in proof theory, which show that adding a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new assumption to some logical theory does not decrease the set of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: provable theorems.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can use the store_weakening lemma to prove that if a store is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: well typed with respect to a store typing, then the store extended
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with a new term t will still be well typed with respect to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: store typing extended with t's type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Preservation!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've got everything set up right, the proof of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: preservation is actually quite straightforward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Begin with one technical lemma:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, at last, is the preservation theorem and proof:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars (preservation_informal)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a careful informal proof of the preservation theorem,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: concentrating on the T_App, T_Deref, T_Assign, and T_Ref
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem progress : ∀ST t T st,'
  prefs: []
  type: TYPE_NORMAL
- en: empty; ST ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: store_well_typed ST st →
  prefs: []
  type: TYPE_NORMAL
- en: (value t ∨ ∃t', ∃st', t / st ⇒ t' / st').
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros ST t T st Ht HST. remember (@[empty](Maps.html#empty) [ty](References.html#STLCRef.ty))
    as Γ.
  prefs: []
  type: TYPE_NORMAL
- en: induction Ht; subst; try solve_by_invert...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt1 as [Ht1p | Ht1p]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2 as [Ht2p | Ht2p]...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht2p as [t[2]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tapp](References.html#STLCRef.tapp) ([tabs](References.html#STLCRef.tabs)
    x T t) t[2]'). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tapp](References.html#STLCRef.tapp) t[1]' t[2]). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Succ *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt as [Ht1p | Ht1p]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p; subst; try solve [ inversion Ht ].
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[1] is a tnat *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tnat](References.html#STLCRef.tnat) ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S)
    n)). ∃st...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tsucc](References.html#STLCRef.tsucc) t[1]'). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Pred *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt as [Ht1p | Ht1p]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p; subst; try solve [inversion Ht ].
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[1] is a tnat *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tnat](References.html#STLCRef.tnat) ([pred](http://coq.inria.fr/library/Coq.Init.Peano.html#pred)
    n)). ∃st...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tpred](References.html#STLCRef.tpred) t[1]'). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Mult *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt1 as [Ht1p | Ht1p]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p; subst; try solve [inversion Ht[1]].
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2 as [Ht2p | Ht2p]...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] is a value *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht2p; subst; try solve [inversion Ht[2]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tnat](References.html#STLCRef.tnat) ([mult](http://coq.inria.fr/library/Coq.Init.Peano.html#mult)
    n n[0])). ∃st...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht2p as [t[2]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tmult](References.html#STLCRef.tmult) ([tnat](References.html#STLCRef.tnat)
    n) t[2]'). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tmult](References.html#STLCRef.tmult) t[1]' t[2]). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_If[0] *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt1 as [Ht1p | Ht1p]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p; subst; try solve [inversion Ht[1]].
  prefs: []
  type: TYPE_NORMAL
- en: destruct n.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* n = 0 *) ∃t[2]. ∃st...'
  prefs: []
  type: TYPE_NORMAL
- en: '* (* n = S n'' *) ∃t[3]. ∃st...'
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tif0](References.html#STLCRef.tif0) t[1]' t[2] t[3]). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Ref *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt as [Ht1p | Ht1p]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tref](References.html#STLCRef.tref) t[1]'). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Deref *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt as [Ht1p | Ht1p]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: eexists. eexists. apply [ST_DerefLoc](References.html#STLCRef.ST_DerefLoc)...
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht; subst. inversion HST; subst.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tderef](References.html#STLCRef.tderef) t[1]'). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Assign *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt1 as [Ht1p|Ht1p]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2 as [Ht2p|Ht2p]...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] is a value *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: eexists. eexists. apply [ST_Assign](References.html#STLCRef.ST_Assign)...
  prefs: []
  type: TYPE_NORMAL
- en: inversion HST; subst. inversion Ht[1]; subst.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H in H[5]...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht2p as [t[2]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tassign](References.html#STLCRef.tassign) t[1] t[2]'). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tassign](References.html#STLCRef.tassign) t[1]' t[2]). ∃st'...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: (λr:Ref (Unit -> Unit).
  prefs: []
  type: TYPE_NORMAL
- en: r := (λx:Unit.(!r) unit); (!r) unit)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (ref (λx:Unit.unit))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Module ExampleVariables.
  prefs: []
  type: TYPE_NORMAL
- en: Definition x := Id "x".
  prefs: []
  type: TYPE_NORMAL
- en: Definition y := Id "y".
  prefs: []
  type: TYPE_NORMAL
- en: Definition r := Id "r".
  prefs: []
  type: TYPE_NORMAL
- en: Definition s := Id "s".
  prefs: []
  type: TYPE_NORMAL
- en: End ExampleVariables.
  prefs: []
  type: TYPE_NORMAL
- en: Module RefsAndNontermination.
  prefs: []
  type: TYPE_NORMAL
- en: Import ExampleVariables.
  prefs: []
  type: TYPE_NORMAL
- en: Definition loop_fun :=
  prefs: []
  type: TYPE_NORMAL
- en: tabs x TUnit (tapp (tderef (tvar r)) tunit).
  prefs: []
  type: TYPE_NORMAL
- en: Definition loop :=
  prefs: []
  type: TYPE_NORMAL
- en: tapp
  prefs: []
  type: TYPE_NORMAL
- en: (tabs r (TRef (TArrow TUnit TUnit))
  prefs: []
  type: TYPE_NORMAL
- en: (tseq (tassign (tvar r) loop_fun)
  prefs: []
  type: TYPE_NORMAL
- en: (tapp (tderef (tvar r)) tunit)))
  prefs: []
  type: TYPE_NORMAL
- en: (tref (tabs x TUnit tunit)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma loop_typeable : ∃T, empty; nil ⊢ loop ∈ T.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: eexists. unfold [loop](References.html#STLCRef.RefsAndNontermination.loop).
    unfold [loop_fun](References.html#STLCRef.RefsAndNontermination.loop_fun).
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_App](References.html#STLCRef.RefsAndNontermination.T_App)...
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Abs](References.html#STLCRef.RefsAndNontermination.T_Abs)...
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_App](References.html#STLCRef.RefsAndNontermination.T_App)...
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Abs](References.html#STLCRef.RefsAndNontermination.T_Abs). eapply
    [T_App](References.html#STLCRef.RefsAndNontermination.T_App). eapply [T_Deref](References.html#STLCRef.RefsAndNontermination.T_Deref).
    eapply [T_Var](References.html#STLCRef.RefsAndNontermination.T_Var).
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). simpl. reflexivity.
    auto.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Assign](References.html#STLCRef.RefsAndNontermination.T_Assign).
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Var](References.html#STLCRef.RefsAndNontermination.T_Var). unfold
    [update](Maps.html#update), [t_update](Maps.html#t_update). simpl. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Abs](References.html#STLCRef.RefsAndNontermination.T_Abs).
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_App](References.html#STLCRef.RefsAndNontermination.T_App)...
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Deref](References.html#STLCRef.RefsAndNontermination.T_Deref). eapply
    [T_Var](References.html#STLCRef.RefsAndNontermination.T_Var). reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive step_closure {X:Type} (R: relation X) : X → X → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| sc_one  : ∀(x y : X),'
  prefs: []
  type: TYPE_NORMAL
- en: R x y → step_closure R x y
  prefs: []
  type: TYPE_NORMAL
- en: '| sc_step : ∀(x y z : X),'
  prefs: []
  type: TYPE_NORMAL
- en: R x y →
  prefs: []
  type: TYPE_NORMAL
- en: step_closure R y z →
  prefs: []
  type: TYPE_NORMAL
- en: step_closure R x z.
  prefs: []
  type: TYPE_NORMAL
- en: Definition multistep1 := (step_closure step).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "t1 '/' st '⇒+' t2 '/' st'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (multistep1 (t[1],st) (t[2],st'))
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39, t[2] at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Ltac print_goal := match goal with ⊢ ?x ⇒ idtac x end.
  prefs: []
  type: TYPE_NORMAL
- en: Ltac reduce :=
  prefs: []
  type: TYPE_NORMAL
- en: repeat (print_goal; eapply multi_step ;
  prefs: []
  type: TYPE_NORMAL
- en: '[ (eauto 10; fail) | (instantiate; compute)];'
  prefs: []
  type: TYPE_NORMAL
- en: try solve [apply multi_refl]).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma loop_steps_to_loop_fun :'
  prefs: []
  type: TYPE_NORMAL
- en: loop / nil ⇒*
  prefs: []
  type: TYPE_NORMAL
- en: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: unfold loop.
  prefs: []
  type: TYPE_NORMAL
- en: reduce.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma loop_fun_step_self :'
  prefs: []
  type: TYPE_NORMAL
- en: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil ⇒+
  prefs: []
  type: TYPE_NORMAL
- en: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold [loop_fun](References.html#STLCRef.RefsAndNontermination.loop_fun); simpl.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [sc_step](References.html#STLCRef.RefsAndNontermination.sc_step). apply
    [ST_App1](References.html#STLCRef.RefsAndNontermination.ST_App1)...
  prefs: []
  type: TYPE_NORMAL
- en: eapply [sc_one](References.html#STLCRef.RefsAndNontermination.sc_one). compute.
    apply [ST_AppAbs](References.html#STLCRef.RefsAndNontermination.ST_AppAbs)...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition factorial : tm'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma factorial_type : empty; nil ⊢ factorial ∈ (TArrow TNat TNat).'
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: (*  Lemma factorial_4 : exists st,   tapp factorial (tnat 4) / nil ==>* tnat 24 / st.
    Proof.   eexists. unfold factorial. reduce. Qed. *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Additional Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exercise: 5 stars, optional (garabage_collector)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Challenge problem: modify our formalization to include an account'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of garbage collection, and prove that it satisfies whatever nice
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: properties you can think to prove about it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
