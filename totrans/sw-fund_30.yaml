- en: ReferencesTyping Mutable References
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型 可变引用
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Import Coq.Arith.Arith.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要求导入 Coq.Arith.Arith。
- en: Require Import Coq.omega.Omega.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要求导入 Coq.omega.Omega。
- en: Require Import Coq.Lists.List.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要求导入 Coq.Lists.List。
- en: Import ListNotations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 ListNotations。
- en: Require Import Maps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要求导入 Maps。
- en: Require Import Smallstep.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要求导入 Smallstep。
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Syntax
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: In this chapter, we study adding mutable references to the
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们研究向
- en: simply-typed lambda calculus with natural numbers.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有自然数的简单类型 λ 演算。
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The basic operations on references are *allocation*,
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引用的基本操作是 *分配*，
- en: '*dereferencing*, and *assignment*.'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解引用* 和 *赋值*。'
- en: To allocate a reference, we use the ref operator, providing an initial value
    for the new cell. For example, ref 5 creates a new cell containing the value 5,
    and reduces to a reference to that cell.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要分配一个引用，我们使用 ref 运算符，提供新单元格的初始值。例如，ref 5 创建一个包含值 5 的新单元格，并简化为对该单元格的引用。
- en: To read the current value of this cell, we use the dereferencing operator !;
    for example, !(ref 5) reduces to 5.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要读取此单元格的当前值，我们使用解引用运算符！；例如，!(ref 5) 简化为 5。
- en: To change the value stored in a cell, we use the assignment operator. If r is
    a reference, r := 7 will store the value 7 in the cell referenced by r.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改存储在单元格中的值，我们使用赋值运算符。如果 r 是一个引用，r := 7 将在由 r 引用的单元格中存储值 7。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: T ::= Nat
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: T ::= 自然数
- en: '| Unit'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '| 单元'
- en: '| T → T'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '| T → T'
- en: '| Ref T'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '| 引用 T'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Terms
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 术语
- en: Besides variables, abstractions, applications,
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了变量、抽象、应用程序之外，
- en: natural-number-related terms, and unit, we need four more sorts
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与自然数相关的术语和单元，我们需要四种更多的排序
- en: 'of terms in order to handle mutable references:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了处理可变引用的术语：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Intuitively:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直观上：
- en: ref t (formally, tref t) allocates a new reference cell with the value t and
    reduces to the location of the newly allocated cell;
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref t（形式上，tref t）分配一个具有值 t 的新引用单元格，并简化为新分配单元格的位置；
- en: '!t (formally, tderef t) reduces to the contents of the cell referenced by t;'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '!t（形式上，tderef t）简化为由 t 引用的单元格的内容；'
- en: t[1] := t[2] (formally, tassign t[1] t[2]) assigns t[2] to the cell referenced
    by t[1]; and
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: t[1] := t[2]（形式上，tassign t[1] t[2]）将 t[2] 分配给由 t[1] 引用的单元格；以及
- en: l (formally, tloc l) is a reference to the cell at location l. We'll discuss
    locations later.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: l（形式上，tloc l）是指向位置 l 处单元格的引用。我们稍后会讨论位置。
- en: In informal examples, we'll also freely use the extensions
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在非正式示例中，我们还将自由使用扩展
- en: of the STLC developed in the [MoreStlc](MoreStlc.html) chapter; however, to
    keep
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 [MoreStlc](MoreStlc.html) 章节中开发的 STLC 的一部分；然而，为了保持
- en: the proofs small, we won't bother formalizing them again here.  (It
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明小，我们不会在这里再次正式化它们。（它
- en: would be easy to do so, since there are no very interesting
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做将很容易，因为没有非常有趣的
- en: interactions between those features and references.)
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些特��与引用之间的交互。）
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Values and Substitution
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值和替换
- en: 'Besides abstractions and numbers, we have two new types of values:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了抽象和数字，我们还有两种新类型的值：
- en: the unit value, and locations.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元值和位置。
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Extending substitution to handle the new syntax of terms is
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展替换以处理术语的新语法是
- en: straightforward.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直接。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Pragmatics
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用语
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: r:=succ(!r); !r
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: r:=succ(!r); !r
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (λx:Unit. !r) (r:=succ(!r)).
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (λx:Unit. !r) (r:=succ(!r)).
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: r:=succ(!r); r:=succ(!r); r:=succ(!r); r:=succ(!r); !r
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: r:=succ(!r); r:=succ(!r); r:=succ(!r); r:=succ(!r); !r
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Definition tseq t[1] t[2] :=
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 tseq t[1] t[2] :=
- en: tapp (tabs (Id "x") TUnit t[2]) t[1].
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: tapp (tabs (Id "x") TUnit t[2]) t[1].
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: let r = ref 5 in
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让 r = ref 5 然后
- en: let s = r in
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让 s = r 然后
- en: s := 82;
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: s := 82;
- en: (!r)+1
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (!r)+1
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: r := 5; r := !s
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: r := 5; r := !s
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: r := !s
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: r := !s
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Shared State
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享状态
- en: Of course, aliasing is also a large part of what makes references
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，别名也是使引用
- en: useful.  In particular, it allows us to set up "implicit
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有用。特别是，它允许我们建立“隐式
- en: communication channels" — shared state — between different parts
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通信通道" — 不同部分之间的共享状态 —
- en: of a program.  For example, suppose we define a reference cell and
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序的一个例子。例如，假设我们定义一个引用单元格和
- en: 'two functions that manipulate its contents:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个操作其内容的函数：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that, since their argument types are Unit, the
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，由于它们的参数类型为 Unit，因此
- en: arguments to the abstractions in the definitions of incc and
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为抽象定义中的抽象的参数
- en: decc are not providing any useful information to the bodies of
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: decc 不提供任何有用信息给
- en: these functions (using the wildcard _ as the name of the bound
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些函数（使用通配符 _ 作为绑定的名称
- en: variable is a reminder of this).  Instead, their purpose of these
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量是这些的目的的提醒）。相反，它们的目的是
- en: abstractions is to "slow down" the execution of the function
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 抽象是“减慢”函数执行的
- en: bodies.  Since function abstractions are values, the two lets are
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主体。由于函数抽象是值，两个 let 都是
- en: executed simply by binding these functions to the names incc and
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过简单地将这些函数绑定到名称incc和
- en: decc, rather than by actually incrementing or decrementing c.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: decc，而不是通过实际增加或减少c。
- en: Later, each caddll to one of these functions results in its body
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后来，对这些函数中的一个进行caddll将导致其主体
- en: being executed once and performing the appropriate mutation on
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被执行一次并对其进行适当的突变
- en: c.  Such functions are often called *thunks*.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c。这样的函数通常被称为*thunks*。
- en: In the context of these declarations, calling incc results in
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这些声明的上下文中，调用incc会导致
- en: changes to c that can be observed by calling decc.  For
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对c的更改可以通过调用decc观察到。对于
- en: example, if we replace the ... with (incc unit; incc unit; decc unit), the result
    of the whole program will be 1.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果我们用（incc unit; incc unit; decc unit）替换...，整个程序的结果将是1。
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: newcounter =
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: newcounter =
- en: λ_:Unit.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: λ_:Unit。
- en: let c = ref 0 in
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让c = ref 0 in
- en: let incc = λ_:Unit. (c := succ (!c); !c) in
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让incc = λ_:Unit。 (c := succ (!c); !c) in
- en: let decc = λ_:Unit. (c := pred (!c); !c) in
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让decc = λ_:Unit。 (c := pred (!c); !c) in
- en: '{i=incc, d=decc}'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{i=incc，d=decc}'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: let c1 = newcounter unit in
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让c1 = newcounter unit in
- en: let c2 = newcounter unit in
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让c2 = newcounter unit in
- en: // Note that we've allocated two separate storage cells now!
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: //请注意，我们现在已经分配了两个独立的存储单元！
- en: let r1 = c1.i unit in
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让r1 = c1.i unit in
- en: let r2 = c2.i unit in
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让r2 = c2.i unit in
- en: r2  // yields 1, not 2!
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: r2 //产生1，而不是2！
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: (* FILL IN HERE *)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (*在这里填写*)
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: References to Compound Types
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合类型的引用
- en: 'A reference cell need not contain just a number: the primitives'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引用单元不一定只包含一个数字：原语
- en: we've defined above allow us to create references to values of any
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们上面定义的允许我们创建任何值的引用
- en: type, including functions.  For example, we can use references to
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型，包括函数。例如，我们可以使用引用来
- en: functions to give an (inefficient) implementation of arrays
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数来给出数组的（低效的）实现
- en: of numbers, as follows.  Write NatArray for the type
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 的数字，如下所示。为类型编写NatArray
- en: Ref (Nat→Nat).
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ref（Nat→Nat）。
- en: 'Recall the equal function from the [MoreStlc](MoreStlc.html) chapter:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下[MoreStlc](MoreStlc.html)章节中的equal函数：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To build a new array, we allocate a reference cell and fill
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要构建一个新数组，我们分配一个引用单元并填充
- en: it with a function that, when given an index, always returns 0.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用一个函数替换它，当给定一个索引时，总是返回0。
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To look up an element of an array, we simply apply
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查找数组的元素，我们只需应用
- en: the function to the desired index.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数到所需的索引。
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The interesting part of the encoding is the update function.  It
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编码的有趣部分是更新函数。它
- en: takes an array, an index, and a new value to be stored at that index, and
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接受一个数组，一个索引和一个要存储在该索引处的新值，并
- en: does its job by creating (and storing in the reference) a new function
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过创建（并存储在引用中）一个新函数来完成其工作
- en: that, when it is asked for the value at this very index, returns the new
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当被要求在这个索引处的值时，返回新的
- en: value that was given to update, while on all other indices it passes the
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定给update的值，而在所有其他索引上传递
- en: lookup to the function that was previously stored in the reference.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查找到先前存储在引用中的函数。
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: References to values containing other references can also be very
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含其他引用的值的引用也可以非常
- en: useful, allowing us to define data structures such as mutable
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有用，允许我们定义可变的数据结构，如
- en: lists and trees.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表和树。
- en: 'Exercise: 2 stars, recommended (compact_update)'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星，推荐（compact_update）
- en: If we defined update more compactly like this
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们像这样更紧凑地定义更新
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: would it behave the same?
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它会表现得一样吗？
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ☐
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Garbage Collection
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: A last issue that we should mention before we move on with
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该提到的最后一个问题
- en: formalizing references is storage *de*-allocation.  We have not
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 形式化引用是存储*解*分配。我们还没有
- en: provided any primitives for freeing reference cells when they are
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在释放引用单元时是否提供了任何原语
- en: no longer needed.  Instead, like many modern languages (including
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不再需要。相反，像许多现代语言一样（包括
- en: ML and Java) we rely on the run-time system to perform *garbage collection*,
    automatically identifying and reusing cells that can
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ML和Java）我们依赖运行时系统执行*垃圾回收*，自动识别和重用可以
- en: no longer be reached by the program.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不再被程序访问。
- en: 'This is *not* just a question of taste in language design: it is'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不仅仅是语言设计上的品味问题：这是
- en: extremely difficult to achieve type safety in the presence of an
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在存在时实现类型安全非常困难
- en: explicit deallocation operation.  One reason for this is the
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显式的解除分配操作。这样做的一个原因是
- en: 'familiar *dangling reference* problem: we allocate a cell holding'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 熟悉的*悬空引用*问题：我们分配一个包含的单元
- en: a number, save a reference to it in some data structure, use it
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个数字，将其保存在某种数据结构中的引用中，使用它
- en: for a while, then deallocate it and allocate a new cell holding a
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一段时间，然后释放它并分配一个新的单元格来保存
- en: boolean, possibly reusing the same storage.  Now we can have two
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布尔值，可能重复使用相同的存储。 现在我们可以有两个
- en: names for the same storage cell — one with type Ref Nat and the
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相同存储单元的不同名称 —— 一个类型为 Ref Nat，另一个
- en: other with type Ref Bool.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他类型为 Ref Bool 的。
- en: 'Exercise: 1 star (type_safety_violation)'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星（类型安全性违规）
- en: Show how this can lead to a violation of type safety.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展示这如何导致类型安全性的违反。
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ☐
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Locations
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置
- en: The most subtle aspect of the treatment of references
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对引用处理的最微妙的方面
- en: appears when we consider how to formalize their operational
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们考虑如何形式化它们的操作时出现
- en: behavior.  One way to see why is to ask, "What should be the
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 行为。 看清楚的一种方法是问，“应该是什么
- en: '*values* of type Ref T?"  The crucial observation that we need'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*类型为 Ref T 的值？* 我们需要的关键观察'
- en: to take into account is that reduci a ref operator should
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要考虑的一点是 reduci a ref 运算符应该
- en: '*do* something — namely, allocate some storage — and the result'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*做* 一些事情 —— 即，分配一些存储 —— 结果'
- en: of the operation should be a reference to this storage.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作的结果应该是对此存储的引用。
- en: What, then, is a reference?
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么，什么是引用？
- en: The run-time store in most programming-language implementations is
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数编程语言实现中的运行时存储是
- en: essentially just a big array of bytes.  The run-time system keeps
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本质上只是一个大字节数组。 运行时系统保持
- en: track of which parts of this array are currently in use; when we
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跟踪这个数组的哪些部分当前正在使用；当我们
- en: need to allocate a new reference cell, we allocate a large enough
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要分配一个新的引用单元格，我们分配一个足够大的
- en: segment from the free region of the store (4 bytes for integer
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储的空闲区域中的段（4 字节用于整数
- en: cells, 8 bytes for cells storing Floats, etc.), record somewhere
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元格，8 字节用于存储 Floats 的单元格等），记录在某处
- en: that it is being used, and return the index (typically, a 32- or
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它正在被使用，并返回索引（通常是 32 位或
- en: 64-bit integer) of the start of the newly allocated region.  These
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 64位整数）指向新分配区域的起始位置。 这些
- en: indices are references.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 索引是引用。
- en: For present purposes, there is no need to be quite so concrete.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就目前而言，没有必要如此具体。
- en: We can think of the store as an array of *values*, rather than an
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将存储看作是一个 *值* 数组，而不是一个
- en: array of bytes, abstracting away from the different sizes of the
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字节数组，抽象出不同大小的
- en: run-time representations of different values.  A reference, then,
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同值的运行时表示。 那么，一个引用，
- en: is simply an index into the store.  (If we like, we can even
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只是一个索引到存储中。 （如果我们愿意，我们甚至可以
- en: abstract away from the fact that these indices are numbers, but
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 抽象化，使这些索引是数字，但
- en: for purposes of formalization in Coq it is convenient to use
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出于在 Coq 中形式化的目的，使用
- en: numbers.)  We use the word *location* instead of *reference* or
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字。）我们使用 *位置* 这个词，而不是 *引用* 或
- en: '*pointer* to emphasize this abstract quality.'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*指针* 来强调这种抽象特质。'
- en: Treating locations abstractly in this way will prevent us from
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式抽象地处理位置将防止我们
- en: modeling the *pointer arithmetic* found in low-level languages
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建模在低级语言中找到的 *指针算术*
- en: such as C.  This limitation is intentional.  While pointer
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如 C。 这种限制是有意的。 虽然指针
- en: arithmetic is occasionally very useful, especially for
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 算术偶尔非常有用，特别是对于
- en: implementing low-level services such as garbage collectors, it
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现低级服务，如垃圾收集器，它
- en: 'cannot be tracked by most type systems: knowing that location n'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数类型系统无法跟踪：知道位置 n
- en: in the store contains a float doesn't tell us anything useful
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储中包含浮点数并不告诉我们任何有用��信息
- en: about the type of location n+4.  In C, pointer arithmetic is a
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于位置 n+4 的类型。 在 C 中，指针算术是一个
- en: notorious source of type-safety violations.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型安全性违规的臭名昭著来源。
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Definition store := list tm.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 store := list tm。
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Definition store_lookup (n:nat) (st:store) :=
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 store_lookup (n:nat) (st:store) =
- en: nth n st tunit.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第 n 个 st tunit。
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Fixpoint replace {A:Type} (n:nat) (x:A) (l:list A) : list A :='
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint replace {A:Type} (n:nat) (x:A) (l:list A) : list A :='
- en: match l with
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l 与
- en: '| nil    ⇒ nil'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil    ⇒ nil'
- en: '| h :: t ⇒'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒'
- en: match n with
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 n 与
- en: '| O    ⇒ x :: t'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '| O    ⇒ x :: t'
- en: '| S n'' ⇒ h :: replace n'' x t'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '| S n'' ⇒ h :: replace n'' x t'
- en: end
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: end.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Lemma replace_nil : ∀A n (x:A),'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 replace_nil : ∀A n (x:A),'
- en: replace n x nil = nil.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: replace n x nil = nil.
- en: Proof.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: destruct n; auto.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: destruct n; auto.
- en: Qed.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma length_replace : ∀A n x (l:list A),'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 length_replace : ∀A n x (l:list A),'
- en: length (replace n x l) = length l.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 长度（用 n x l 替换）= 长度 l。
- en: Proof with auto.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with auto.
- en: intros A n x l. generalize dependent n.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: intros A n x l. generalize dependent n.
- en: induction l; intros n.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 l; intros n.
- en: destruct n...
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: destruct n...
- en: destruct n...
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: destruct n...
- en: simpl. rewrite IHl...
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: simpl. rewrite IHl...
- en: Qed.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma lookup_replace_eq : ∀l t st,'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 引理lookup_replace_eq：对于l、t和st，
- en: l < length st →
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当l小于st的长度时 →
- en: store_lookup l (replace l t st) = t.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: store_lookup l (replace l t st) = t.
- en: Proof with auto.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明与自动化相关。
- en: intros l t st.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 引入l、t和st。
- en: unfold [store_lookup](References.html#STLCRef.store_lookup).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 展开[store_lookup](References.html#STLCRef.store_lookup)。
- en: generalize dependent l.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 推广l。
- en: induction st as [|t' st']; intros l Hlen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '以st为基础进行归纳，当st为空或者为t'' :: st''时，引入l和Hlen。'
- en: '- (* st =  *)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* st =  *) '
- en: inversion Hlen.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对Hlen进行反演。
- en: '- (* st = t'' :: st'' *)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* st = t'' :: st'' *)'
- en: destruct l; simpl...
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对l进行分析; 简化...
- en: apply IHst'. simpl in Hlen. omega.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 应用IHst'。在Hlen中简化。omega。
- en: Qed.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证毕。
- en: 'Lemma lookup_replace_neq : ∀l[1] l[2] t st,'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 引理lookup_replace_neq：对于l[1]、l[2]、t和st，
- en: l[1] ≠ l[2] →
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: l[1] ≠ l[2] →
- en: store_lookup l[1] (replace l[2] t st) = store_lookup l[1] st.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: store_lookup l[1] (replace l[2] t st) = store_lookup l[1] st.
- en: Proof with auto.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明与自动化相关。
- en: unfold [store_lookup](References.html#STLCRef.store_lookup).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 展开[store_lookup](References.html#STLCRef.store_lookup)。
- en: induction l[1] as [|l[1]']; intros l[2] t st Hneq.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以l[1]为基础进行归纳，引入l[2]、t和st，Hneq表示不相等。
- en: '- (* l[1] = 0 *)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l[1] = 0 *)'
- en: destruct st.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对st进行分析。
- en: + (* st =  *) rewrite [replace_nil](References.html#STLCRef.replace_nil)...
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: + (* st =  *) 重写[replace_nil](References.html#STLCRef.replace_nil)...
- en: + (* st = _ :: _ *) destruct l[2]... contradict Hneq...
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '+ (* st = _ :: _ *) 对l[2]进行分析... 反驳Hneq...'
- en: '- (* l[1] = S l[1]'' *)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l[1] = S l[1]'' *)'
- en: destruct st as [|t[2] st[2]].
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对st进行分析，作为[t[2] st]的情况。
- en: + (* st =  *) destruct l[2]...
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: + (* st =  *) 对l[2]进行分析...
- en: + (* st = t[2] :: st[2] *)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '+ (* st = t[2] :: st[2] *)'
- en: destruct l[2]...
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对l[2]进行分析...
- en: simpl; apply IHl1'...
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 简化；应用IHl1'...
- en: Qed.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证毕。
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Reserved Notation "t1 '/' st1 '⇒' t2 '/' st2"
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 保留记号"t1 '/' st1 '⇒' t2 '/' st2"
- en: (at level 40, st[1] at level 39, t[2] at level 39).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: (在40级，st[1]在39级，t[2]在39级)。
- en: Import ListNotations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 导入ListNotations。
- en: 'Inductive step : tm * store → tm * store → Prop :='
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤的归纳定义：tm * store → tm * store → Prop :=
- en: '| ST_AppAbs : ∀x T t[12] v[2] st,'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_AppAbs : ∀x T t[12] v[2] st,'
- en: value v[2] →
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 值v[2] →
- en: tapp (tabs x T t[12]) v[2] / st ⇒ [x:=v[2]]t[12] / st
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: tapp (tabs x T t[12]) v[2] / st ⇒ [x:=v[2]]t[12] / st
- en: '| ST_App1 : ∀t[1] t[1]'' t[2] st st'','
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_App1 : ∀t[1] t[1]'' t[2] st st'','
- en: t[1] / st ⇒ t[1]' / st' →
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] / st ⇒ t[1]' / st' →
- en: tapp t[1] t[2] / st ⇒ tapp t[1]' t[2] / st'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: tapp t[1] t[2] / st ⇒ tapp t[1]' t[2] / st'
- en: '| ST_App2 : ∀v[1] t[2] t[2]'' st st'','
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_App2 : ∀v[1] t[2] t[2]'' st st'','
- en: value v[1] →
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 值v[1] →
- en: t[2] / st ⇒ t[2]' / st' →
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: t[2] / st ⇒ t[2]' / st' →
- en: tapp v[1] t[2] / st ⇒ tapp v[1] t[2]'/ st'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: tapp v[1] t[2] / st ⇒ tapp v[1] t[2]'/ st'
- en: '| ST_SuccNat : ∀n st,'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_SuccNat : ∀n st,'
- en: tsucc (tnat n) / st ⇒ tnat (S n) / st
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: tsucc (tnat n) / st ⇒ tnat (S n) / st
- en: '| ST_Succ : ∀t[1] t[1]'' st st'','
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Succ : ∀t[1] t[1]'' st st'','
- en: t[1] / st ⇒ t[1]' / st' →
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] / st ⇒ t[1]' / st' →
- en: tsucc t[1] / st ⇒ tsucc t[1]' / st'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: tsucc t[1] / st ⇒ tsucc t[1]' / st'
- en: '| ST_PredNat : ∀n st,'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_PredNat : ∀n st,'
- en: tpred (tnat n) / st ⇒ tnat (pred n) / st
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: tpred (tnat n) / st ⇒ tnat (pred n) / st
- en: '| ST_Pred : ∀t[1] t[1]'' st st'','
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Pred : ∀t[1] t[1]'' st st'','
- en: t[1] / st ⇒ t[1]' / st' →
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] / st ⇒ t[1]' / st' →
- en: tpred t[1] / st ⇒ tpred t[1]' / st'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: tpred t[1] / st ⇒ tpred t[1]' / st'
- en: '| ST_MultNats : ∀n[1] n[2] st,'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_MultNats : ∀n[1] n[2] st,'
- en: tmult (tnat n[1]) (tnat n[2]) / st ⇒ tnat (mult n[1] n[2]) / st
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: tmult (tnat n[1]) (tnat n[2]) / st ⇒ tnat (mult n[1] n[2]) / st
- en: '| ST_Mult1 : ∀t[1] t[2] t[1]'' st st'','
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Mult1 : ∀t[1] t[2] t[1]'' st st'','
- en: t[1] / st ⇒ t[1]' / st' →
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] / st ⇒ t[1]' / st' →
- en: tmult t[1] t[2] / st ⇒ tmult t[1]' t[2] / st'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: tmult t[1] t[2] / st ⇒ tmult t[1]' t[2] / st'
- en: '| ST_Mult2 : ∀v[1] t[2] t[2]'' st st'','
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Mult2 : ∀v[1] t[2] t[2]'' st st'','
- en: value v[1] →
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 值v[1] →
- en: t[2] / st ⇒ t[2]' / st' →
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: t[2] / st ⇒ t[2]' / st' →
- en: tmult v[1] t[2] / st ⇒ tmult v[1] t[2]' / st'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: tmult v[1] t[2] / st ⇒ tmult v[1] t[2]' / st'
- en: '| ST_If[0] : ∀t[1] t[1]'' t[2] t[3] st st'','
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_If[0] : ∀t[1] t[1]'' t[2] t[3] st st'','
- en: t[1] / st ⇒ t[1]' / st' →
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] / st ⇒ t[1]' / st' →
- en: tif0 t[1] t[2] t[3] / st ⇒ tif0 t[1]' t[2] t[3] / st'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: tif0 t[1] t[2] t[3] / st ⇒ tif0 t[1]' t[2] t[3] / st'
- en: '| ST_If0_Zero : ∀t[2] t[3] st,'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_If0_Zero : ∀t[2] t[3] st,'
- en: tif0 (tnat 0) t[2] t[3] / st ⇒ t[2] / st
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: tif0 (tnat 0) t[2] t[3] / st ⇒ t[2] / st
- en: '| ST_If0_Nonzero : ∀n t[2] t[3] st,'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_If0_Nonzero : ∀n t[2] t[3] st,'
- en: tif0 (tnat (S n)) t[2] t[3] / st ⇒ t[3] / st
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: tif0 (tnat (S n)) t[2] t[3] / st ⇒ t[3] / st
- en: '| ST_RefValue : ∀v[1] st,'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_RefValue : ∀v[1] st,'
- en: value v[1] →
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 值v[1] →
- en: tref v[1] / st ⇒ tloc (length st) / (st ++ v[1]::nil)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: tref v[1] / st ⇒ tloc (length st) / (st ++ v[1]::nil)
- en: '| ST_Ref : ∀t[1] t[1]'' st st'','
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Ref : ∀t[1] t[1]'' st st'','
- en: t[1] / st ⇒ t[1]' / st' →
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] / st ⇒ t[1]' / st' →
- en: tref t[1] /  st ⇒ tref t[1]' /  st'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: tref t[1] /  st ⇒ tref t[1]' /  st'
- en: '| ST_DerefLoc : ∀st l,'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_DerefLoc : ∀st l,'
- en: l < length st →
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当l小于st的长度时 →
- en: tderef (tloc l) / st ⇒ store_lookup l st / st
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: tderef (tloc l) / st ⇒ store_lookup l st / st
- en: '| ST_Deref : ∀t[1] t[1]'' st st'','
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Deref : ∀t[1] t[1]'' st st'','
- en: t[1] / st ⇒ t[1]' / st' →
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] / st ⇒ t[1]' / st' →
- en: tderef t[1] / st ⇒ tderef t[1]' / st'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: tderef t[1] / st ⇒ tderef t[1]' / st'
- en: '| ST_Assign : ∀v[2] l st,'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Assign : ∀v[2] l st,'
- en: value v[2] →
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 值v[2] →
- en: l < length st →
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: l < length st →
- en: tassign (tloc l) v[2] / st ⇒ tunit / replace l v[2] st
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: tassign (tloc l) v[2] / st ⇒ tunit / replace l v[2] st
- en: '| ST_Assign1 : ∀t[1] t[1]'' t[2] st st'','
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Assign1 : ∀t[1] t[1]'' t[2] st st'','
- en: t[1] / st ⇒ t[1]' / st' →
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] / st ⇒ t[1]' / st' →
- en: tassign t[1] t[2] / st ⇒ tassign t[1]' t[2] / st'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: tassign t[1] t[2] / st ⇒ tassign t[1]' t[2] / st'
- en: '| ST_Assign2 : ∀v[1] t[2] t[2]'' st st'','
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Assign2 : ∀v[1] t[2] t[2]'' st st'','
- en: value v[1] →
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 值v[1] →
- en: t[2] / st ⇒ t[2]' / st' →
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: t[2] / st ⇒ t[2]' / st' →
- en: tassign v[1] t[2] / st ⇒ tassign v[1] t[2]' / st'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: tassign v[1] t[2] / st ⇒ tassign v[1] t[2]' / st'
- en: where "t1 '/' st1 '⇒' t2 '/' st2" := (step (t[1],st[1]) (t[2],st[2])).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 其中“t1 '/' st1 '⇒' t2 '/' st2”:=（步骤（t[1]，st[1]）（t[2]，st[2])）。
- en: '[PRE37]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Hint Constructors step.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Hint Constructors step。
- en: Definition multistep := (multi step).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 multistep :=（多步骤）。
- en: Notation "t1 '/' st '⇒*' t2 '/' st'" :=
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "t1 '/' st '⇒*' t2 '/' st'" :=
- en: (multistep (t[1],st) (t[2],st'))
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: （multistep（t[1]，st）（t[2]，st'））
- en: (at level 40, st at level 39, t[2] at level 39).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: （在级别 40，st 在级别 39，t[2] 在级别 39）。
- en: '[PRE38]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Definition context := partial_map ty.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 定义上下文 := partial_map ty。
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[\x:Nat. (!(loc 1)) x, λx:Nat. (!(loc 0)) x]'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[\x:Nat。(!(loc 1)) x，λx:Nat。(!(loc 0)) x]'
- en: '[PRE40]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Definition store_ty := list ty.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 store_ty := list ty。
- en: '[PRE41]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Definition store_Tlookup (n:nat) (ST:store_ty) :=
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 store_Tlookup（n：nat）（ST：store_ty） :=
- en: nth n ST TUnit.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第 n 个 ST TUnit。
- en: '[PRE42]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Typing Relation
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型关系
- en: We can now formalize the typing relation for the STLC with
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以形式化带有的类型关系
- en: references.  Here, again, are the rules we're adding to the base
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引用。在这里，我们再次添加到基础的规则
- en: 'STLC (with numbers and Unit):'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: STLC（带有数字和 Unit）：
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: l < &#124;st&#124;< td="">
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: l < |st| < td="">
- en: '|'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (T_Loc)
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （T_Loc）
- en: '|'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gamma; ST ⊢ loc l : Ref (lookup l ST)
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gamma；ST ⊢ loc l：Ref（lookup l ST）
- en: '|'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gamma; ST ⊢ t[1] : T[1]
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gamma；ST ⊢ t[1]：T[1]
- en: '|'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (T_Ref)
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （T_Ref）
- en: '|'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gamma; ST ⊢ ref t[1] : Ref T[1]
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gamma；ST ⊢ ref t[1]：Ref T[1]
- en: '|'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gamma; ST ⊢ t[1] : Ref T[11]
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gamma；ST ⊢ t[1]：Ref T[11]
- en: '|'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (T_Deref)
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （T_Deref）
- en: '|'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gamma; ST ⊢ !t[1] : T[11]
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gamma；ST ⊢！t[1]：T[11]
- en: '|'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gamma; ST ⊢ t[1] : Ref T[11]
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gamma；ST ⊢ t[1]：Ref T[11]
- en: '|'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gamma; ST ⊢ t[2] : T[11]
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gamma；ST ⊢ t[2]：T[11]
- en: '|'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (T_Assign)
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （T_Assign）
- en: '|'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Gamma; ST ⊢ t[1] := t[2] : Unit
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Gamma；ST ⊢ t[1] := t[2] : Unit'
- en: '|'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Of course, these typing rules will accurately predict the results
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，这些类型规则将准确预测结果
- en: of reduction only if the concrete store used during reduction
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅当在减少过程中使用的具体存储
- en: actually conforms to the store typing that we assume for purposes
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上符合我们为了目的而假设的存储类型
- en: of typechecking.  This proviso exactly parallels the situation
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型检查。这个限定条件与情况完全相似
- en: 'with free variables in the basic STLC: the substitution lemma'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在基本 STLC 中具有自由变量的项：替换引理
- en: 'promises that, if Γ ⊢ t : T, then we can replace the free'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 承诺，如果 Γ ⊢ t：T，则我们可以替换自由的
- en: variables in t with values of the types listed in Γ to
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t 中的变量与Γ中列出的类型的值
- en: obtain a closed term of type T, which, by the type preservation
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获得一个类型为 T 的闭合项，这通过类型保留
- en: theorem will reduce to a final result of type T if it yields
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理将导致类型为 T 的最终结果，如果它产生
- en: any result at all.  We will see below how to formalize an
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何结果。我们将在下面看到如何形式化一个
- en: analogous intuition for stores and store typings.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对存储和存储类型的类似直觉。
- en: However, for purposes of typechecking the terms that programmers
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，为了对程序员编写的项进行类型检查
- en: actually write, we do not need to do anything tricky to guess what
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上写代码时，我们不需要做任何花哨的事情来猜测什么。
- en: store typing we should use.  Concrete locations arise only in
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该使用的存储类型。具体位置仅在
- en: terms that are the intermediate results of reduction; they are
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 减少的中间结果的项；它们是
- en: not in the language that programmers write.  Thus, we can simply
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不在程序员编写的语言中。因此，我们可以简单地
- en: typecheck the programmer's terms with respect to the *empty* store
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将程序员的项与*空*存储类型检查
- en: typing.  As reduction proceeds and new locations are created, we
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型。随着减少的进行和新位置的创建，我们
- en: will always be able to see how to extend the store typing by
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将始终能够看到如何通过扩展存储类型来扩展
- en: looking at the type of the initial values being placed in newly
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看放置在新创建的位置中的初始值的类型
- en: allocated cells; this intuition is formalized in the statement of
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分配的单元格；这种直觉在陈述中被形式化为
- en: the type preservation theorem below.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是类型保留定理。
- en: '[PRE44]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Well-Typed Stores
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好类型的存储
- en: Since we have extended both the reduction relation (with
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们已经扩展了减少关系（具有
- en: initial and final stores) and the typing relation (with a store
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始和最终存储）和类型关系（带有存储
- en: typing), we need to change the statement of preservation to
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入），我们需要改变保留的陈述为
- en: include these parameters.  But clearly we cannot just add stores
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包括这些参数。但很明显，我们不能简单地添加存储
- en: and store typings without saying anything about how they are
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和存储类型，而不说它们是如何的
- en: 'related — i.e., this is wrong:'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相关的 —— 即，这是错误的：
- en: '[PRE45]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we typecheck with respect to some set of assumptions about the
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们针对一些关于
- en: types of the values in the store and then reduce with respect to
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储中的值的类型，然后根据情况减少
- en: a store that violates these assumptions, the result will be
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 违反这些假设的存储，结果将是
- en: disaster.  We say that a store st is *well typed* with respect a
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 灾难。我们说存储 st 相对于
- en: store typing ST if the term at each location l in st has the
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储类型 ST 如果 st 中每个位置 l 处的项都有
- en: type at location l in ST.  Since only closed terms ever get
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 ST 中位置 l 处的类型。由于只有封闭项才能
- en: stored in locations (why?), it suffices to type them in the empty
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储在位置中（为什么？），只需在空的情况下对它们进行类型
- en: context. The following definition of store_well_typed formalizes
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上下文。以下 store_well_typed 的定义形式化
- en: this.
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个。
- en: '[PRE46]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Informally, we will write ST ⊢ st for store_well_typed ST st.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非正式地，我们将写成 ST ⊢ st 表示 store_well_typed ST st。
- en: Intuitively, a store st is consistent with a store typing
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直观地，存储 st 与存储类型一致
- en: ST if every value in the store has the type predicted by the
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果存储中的每个值都具有预测的类型，则 ST 是存储类型。
- en: store typing.  The only subtle point is the fact that, when
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储类型。唯一微妙的地方是，当
- en: typing the values in the store, we supply the very same store
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在存储中输入数值，我们提供相同的存储
- en: typing to the typing relation.  This allows us to type circular
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型到类型关系。这使我们能够对循环进行类型
- en: stores like the one we saw above.
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像我们上面看到的那样的存储。
- en: 'Exercise: 2 stars (store_not_unique)'
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星（store_not_unique）
- en: Can you find a store st, and two
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你能找到一个存储 st，和两个
- en: different store typings ST[1] and ST[2] such that both
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同的存储类型 ST[1] 和 ST[2]，使得两者都
- en: ST[1] ⊢ st and ST[2] ⊢ st?
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ST[1] ⊢ st 和 ST[2] ⊢ st？
- en: '[PRE47]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ☐
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: We can now state something closer to the desired preservation
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在���们可以陈述更接近所需的保留
- en: 'property:'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性：
- en: '[PRE48]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This statement is fine for all of the reduction rules except
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个陈述对于所有的规约规则都是可以的，除了
- en: the allocation rule ST_RefValue.  The problem is that this rule
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分配规则 ST_RefValue。问题在于这个规则
- en: yields a store with a larger domain than the initial store, which
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 产生一个具有比初始存储更大域的存储，
- en: 'falsifies the conclusion of the above statement: if st'' includes'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反驳上述陈述的结论：如果 st' 包含
- en: a binding for a fresh location l, then l cannot be in the
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为新位置 l 绑定，那么 l 不能在
- en: domain of ST, and it will not be the case that t' (which
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ST 的域，并且不会出现 t'（
- en: definitely mentions l) is typable under ST.
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确提到 l）在 ST 下是可类型化的。
- en: '[PRE49]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inductive extends : store_ty → store_ty → Prop :='
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳 extends : store_ty → store_ty → Prop :='
- en: '| extends_nil  : ∀ST'','
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '| extends_nil  : ∀ST''，'
- en: extends ST' nil
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 ST' 为 nil
- en: '| extends_cons : ∀x ST'' ST,'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '| extends_cons : ∀x ST'' ST，'
- en: extends ST' ST →
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: extends ST' ST →
- en: extends (x::ST') (x::ST).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: extends (x::ST') (x::ST)。
- en: Hint Constructors extends.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 构造 extends。
- en: '[PRE50]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lemma extends_lookup : ∀l ST ST'','
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 extends_lookup : ∀l ST ST'','
- en: l < length ST →
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: l < length ST →
- en: extends ST' ST →
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 ST' ST →
- en: store_Tlookup l ST' = store_Tlookup l ST.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: store_Tlookup l ST' = store_Tlookup l ST。
- en: Proof with auto.
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。自动。
- en: intros l ST ST' Hlen H.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: intros l ST ST' Hlen H。
- en: generalize dependent ST'. generalize dependent l.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 推广 ST'。推广 l。
- en: induction ST as [|a ST[2]]; intros l Hlen ST' HST'.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 对 ST 进行归纳，作为 [|a ST[2]]；intros l Hlen ST' HST'。
- en: '- (* nil *) inversion Hlen.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* nil *) 反转 Hlen。'
- en: '- (* cons *) unfold [store_Tlookup](References.html#STLCRef.store_Tlookup)
    in *.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* cons *) 在 * 中展开 [store_Tlookup](References.html#STLCRef.store_Tlookup)。'
- en: destruct ST'.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分 ST'。
- en: + (* ST' = nil *) inversion HST'.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: + (* ST' = nil *) 反转 HST'。
- en: + (* ST' = a' :: ST'2 *)
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: + (* ST' = a' :: ST'2 *)
- en: inversion HST'; subst.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 HST'; 替换。
- en: destruct l as [|l'].
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分 l 为 [|l']。
- en: '* (* l = 0 *) auto.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* l = 0 *) 自动。'
- en: '* (* l = S l'' *) simpl. apply IHST2...'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* l = S l'' *) 简化。应用 IHST2...'
- en: simpl in Hlen; omega.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 简化 Hlen; omega。
- en: Qed.
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE51]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Lemma length_extends : ∀l ST ST'','
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 length_extends : ∀l ST ST'','
- en: l < length ST →
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: l < length ST →
- en: extends ST' ST →
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 ST' ST →
- en: l < length ST'.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: l < length ST'。
- en: Proof with eauto.
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。使用 eauto。
- en: intros. generalize dependent l. induction H[0]; intros l Hlen.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: intros。推广 l。对 H[0] 进行归纳；intros l Hlen。
- en: inversion Hlen.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 Hlen。
- en: simpl in *.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。
- en: destruct l; try omega.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分 l；尝试 omega。
- en: apply [lt_n_S](http://coq.inria.fr/library/Coq.Arith.Lt.html#lt_n_S). apply
    IHextends. omega.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [lt_n_S](http://coq.inria.fr/library/Coq.Arith.Lt.html#lt_n_S)。应用 IHextends。omega。
- en: Qed.
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE52]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Lemma extends_app : ∀ST T,'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 extends_app : ∀ST T，'
- en: extends (ST ++ T) ST.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: extends (ST ++ T) ST。
- en: Proof with auto.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。自动。
- en: induction ST; intros T...
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 对 ST 进行归纳; intros T...
- en: simpl...
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 简化...
- en: Qed.
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: 'Lemma extends_refl : ∀ST,'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 extends_refl : ∀ST，'
- en: extends ST ST.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: extends ST ST。
- en: Proof.
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: induction ST; auto.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 对 ST 进行归纳; 自动。
- en: Qed.
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE53]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Definition preservation_theorem := ∀ST t t' T st st',
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 保留定理定义为 ∀ST t t' T st st'，
- en: empty; ST ⊢ t ∈ T →
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 空; ST ⊢ t ∈ T →
- en: store_well_typed ST st →
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: store_well_typed ST st →
- en: t / st ⇒ t' / st' →
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: t / st ⇒ t' / st' →
- en: ∃ST',
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: ∃ST'，
- en: (extends ST' ST ∧
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: （扩展 ST' ST ∧
- en: empty; ST' ⊢ t' ∈ T ∧
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 空; ST' ⊢ t' ∈ T ∧
- en: store_well_typed ST' st').
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: store_well_typed ST' st')。
- en: '[PRE54]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Substitution Lemma
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换引理
- en: First, we need an easy extension of the standard substitution
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们需要标准替换的简单扩展
- en: lemma, along with the same machinery about context invariance that
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引理，以及关于上下文不变性的相同机制
- en: we used in the proof of the substitution lemma for the STLC.
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在STLC的替换引理的证明中使用的
- en: '[PRE55]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Assignment Preserves Store Typing
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配保留存储类型
- en: Next, we must show that replacing the contents of a cell in the
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们必须证明替换单元格内容不会改变
- en: store with a new value of appropriate type does not change the
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用适当类型的新值替换存储器中的内容不会改变
- en: overall type of the store.  (This is needed for the ST_Assign
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储的整体类型。（这对于ST_Assign是必要的
- en: rule.)
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规则。）
- en: '[PRE56]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Weakening for Stores
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储弱化
- en: Finally, we need a lemma on store typings, stating that, if a
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们需要一个关于存储类型的引理，陈述如果
- en: store typing is extended with a new location, the extended one
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储类型扩展为一个新位置，扩展的位置
- en: still allows us to assign the same types to the same terms as the
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仍然允许我们为相同的术语分配相同的类型
- en: original.
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始的。
- en: (The lemma is called store_weakening because it resembles the
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （该引理称为store_weakening，因为它类似于
- en: '"weakening" lemmas found in proof theory, which show that adding a'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在证明理论中找到的“弱化”引理，显示添加一个
- en: new assumption to some logical theory does not decrease the set of
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对某个逻辑理论的新假设不会减少
- en: provable theorems.)
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可证明的定理。）
- en: '[PRE57]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can use the store_weakening lemma to prove that if a store is
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用store_weakening引理证明，如果一个存储器是
- en: well typed with respect to a store typing, then the store extended
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于存储类型的类型化，然后扩展存储
- en: with a new term t will still be well typed with respect to the
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用一个新术语t扩展后，仍然会根据
- en: store typing extended with t's type.
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储类型扩展为t的类型。
- en: '[PRE58]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Preservation!
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留！
- en: Now that we've got everything set up right, the proof of
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，保留的证明
- en: preservation is actually quite straightforward.
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实上是非常直接的。
- en: 'Begin with one technical lemma:'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从一个技术引理开始：
- en: '[PRE59]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And here, at last, is the preservation theorem and proof:'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在这里是保留定理和证明：
- en: '[PRE60]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Exercise: 3 stars (preservation_informal)'
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星（保留非正式）
- en: Write a careful informal proof of the preservation theorem,
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仔细写出保留定理的非正式证明，
- en: concentrating on the T_App, T_Deref, T_Assign, and T_Ref
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 集中在T_App、T_Deref、T_Assign和T_Ref
- en: cases.
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 情况。
- en: (* FILL IN HERE *)
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (* 在这里填写 *)
- en: ☐
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE61]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Theorem progress : ∀ST t T st,'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 定理进展：∀ST t T st，
- en: empty; ST ⊢ t ∈ T →
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 空; ST ⊢ t ∈ T →
- en: store_well_typed ST st →
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 存储类型良好 ST st →
- en: (value t ∨ ∃t', ∃st', t / st ⇒ t' / st').
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: （值t ∨ ∃t'，∃st'，t / st ⇒ t' / st'）。
- en: Proof with eauto.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros ST t T st Ht HST. remember (@[empty](Maps.html#empty) [ty](References.html#STLCRef.ty))
    as Γ.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: intros ST t T st Ht HST. remember (@[empty](Maps.html#empty) [ty](References.html#STLCRef.ty))
    as Γ。
- en: induction Ht; subst; try solve_by_invert...
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳Ht; subst; try solve_by_invert...
- en: '- (* T_App *)'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: right. destruct IHHt1 as [Ht1p | Ht1p]...
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: right. destruct IHHt1 as [Ht1p | Ht1p]...
- en: + (* t[1] is a value *)
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是值 *)
- en: inversion Ht1p; subst; try solve_by_invert.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Ht1p; subst; try solve_by_invert.
- en: destruct IHHt2 as [Ht2p | Ht2p]...
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt2 as [Ht2p | Ht2p]...
- en: '* (* t[2] steps *)'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 步骤 *)'
- en: inversion Ht2p as [t[2]' [st' Hstep]].
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Ht2p as [t[2]' [st' Hstep]]。
- en: ∃([tapp](References.html#STLCRef.tapp) ([tabs](References.html#STLCRef.tabs)
    x T t) t[2]'). ∃st'...
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tapp](References.html#STLCRef.tapp) ([tabs](References.html#STLCRef.tabs)
    x T t) t[2]'). ∃st'...
- en: + (* t[1] steps *)
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Ht1p as [t[1]' [st' Hstep]]。
- en: ∃([tapp](References.html#STLCRef.tapp) t[1]' t[2]). ∃st'...
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tapp](References.html#STLCRef.tapp) t[1]' t[2]). ∃st'...
- en: '- (* T_Succ *)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Succ *)'
- en: right. destruct IHHt as [Ht1p | Ht1p]...
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: right. destruct IHHt as [Ht1p | Ht1p]...
- en: + (* t[1] is a value *)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是值 *)
- en: inversion Ht1p; subst; try solve [ inversion Ht ].
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Ht1p; subst; try solve [ inversion Ht ]。
- en: '* (* t[1] is a tnat *)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[1] 是一个tnat *)'
- en: ∃([tnat](References.html#STLCRef.tnat) ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S)
    n)). ∃st...
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tnat](References.html#STLCRef.tnat) ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S)
    n)). ∃st...
- en: + (* t[1] steps *)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Ht1p as [t[1]' [st' Hstep]]。
- en: ∃([tsucc](References.html#STLCRef.tsucc) t[1]'). ∃st'...
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tsucc](References.html#STLCRef.tsucc) t[1]'). ∃st'...
- en: '- (* T_Pred *)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Pred *)'
- en: right. destruct IHHt as [Ht1p | Ht1p]...
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: right. destruct IHHt as [Ht1p | Ht1p]...
- en: + (* t[1] is a value *)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是值 *)
- en: inversion Ht1p; subst; try solve [inversion Ht ].
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Ht1p; subst; try solve [inversion Ht ]。
- en: '* (* t[1] is a tnat *)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[1] 是一个tnat *)'
- en: ∃([tnat](References.html#STLCRef.tnat) ([pred](http://coq.inria.fr/library/Coq.Init.Peano.html#pred)
    n)). ∃st...
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tnat](References.html#STLCRef.tnat) ([pred](http://coq.inria.fr/library/Coq.Init.Peano.html#pred)
    n)). ∃st...
- en: + (* t[1] steps *)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Ht1p as [t[1]' [st' Hstep]]。
- en: ∃([tpred](References.html#STLCRef.tpred) t[1]'). ∃st'...
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tpred](References.html#STLCRef.tpred) t[1]'). ∃st'...
- en: '- (* T_Mult *)'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Mult *)'
- en: right. destruct IHHt1 as [Ht1p | Ht1p]...
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: right. destruct IHHt1 as [Ht1p | Ht1p]...
- en: + (* t[1] is a value *)
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是值 *)
- en: inversion Ht1p; subst; try solve [inversion Ht[1]].
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: inversion Ht1p; subst; try solve [inversion Ht[1]]。
- en: destruct IHHt2 as [Ht2p | Ht2p]...
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt2 as [Ht2p | Ht2p]...
- en: '* (* t[2] is a value *)'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 是一个值 *)'
- en: inversion Ht2p; subst; try solve [inversion Ht[2]].
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht2p; 替换; 尝试解决 [inversion Ht[2]]。
- en: ∃([tnat](References.html#STLCRef.tnat) ([mult](http://coq.inria.fr/library/Coq.Init.Peano.html#mult)
    n n[0])). ∃st...
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tnat](https://example.org/STLCRef.tnat) ([mult](http://coq.inria.fr/library/Coq.Init.Peano.html#mult)
    n n[0])). ∃st...
- en: '* (* t[2] steps *)'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 步骤 *)'
- en: inversion Ht2p as [t[2]' [st' Hstep]].
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht2p 作为 [t[2]' [st' Hstep]]。
- en: ∃([tmult](References.html#STLCRef.tmult) ([tnat](References.html#STLCRef.tnat)
    n) t[2]'). ∃st'...
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tmult](https://example.org/STLCRef.tmult) ([tnat](https://example.org/STLCRef.tnat)
    n) t[2]'). ∃st'...
- en: + (* t[1] steps *)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht1p 作为 [t[1]' [st' Hstep]]。
- en: ∃([tmult](References.html#STLCRef.tmult) t[1]' t[2]). ∃st'...
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tmult](https://example.org/STLCRef.tmult) t[1]' t[2]). ∃st'...
- en: '- (* T_If[0] *)'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_If[0] *)'
- en: right. destruct IHHt1 as [Ht1p | Ht1p]...
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: right. 分解 IHHt1 为 [Ht1p | Ht1p]...
- en: + (* t[1] is a value *)
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是一个值 *)
- en: inversion Ht1p; subst; try solve [inversion Ht[1]].
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht1p; 替换; 尝试解决 [inversion Ht[1]]。
- en: destruct n.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 n。
- en: '* (* n = 0 *) ∃t[2]. ∃st...'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* n = 0 *) ∃t[2]. ∃st...'
- en: '* (* n = S n'' *) ∃t[3]. ∃st...'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* n = S n'' *) ∃t[3]. ∃st...'
- en: + (* t[1] steps *)
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht1p 作为 [t[1]' [st' Hstep]]。
- en: ∃([tif0](References.html#STLCRef.tif0) t[1]' t[2] t[3]). ∃st'...
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tif0](https://example.org/STLCRef.tif0) t[1]' t[2] t[3]). ∃st'...
- en: '- (* T_Ref *)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Ref *)'
- en: right. destruct IHHt as [Ht1p | Ht1p]...
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: right. 分解 IHHt1 为 [Ht1p | Ht1p]...
- en: + (* t[1] steps *)
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht1p 作为 [t[1]' [st' Hstep]]。
- en: ∃([tref](References.html#STLCRef.tref) t[1]'). ∃st'...
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tref](https://example.org/STLCRef.tref) t[1]'). ∃st'...
- en: '- (* T_Deref *)'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Deref *)'
- en: right. destruct IHHt as [Ht1p | Ht1p]...
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: right. 分解 IHHt1 为 [Ht1p | Ht1p]...
- en: + (* t[1] is a value *)
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是一个值 *)
- en: inversion Ht1p; subst; try solve_by_invert.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht1p; 替换; 尝试通过反演解决。
- en: eexists. eexists. apply [ST_DerefLoc](References.html#STLCRef.ST_DerefLoc)...
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 存在。存在。应用 [ST_DerefLoc](https://example.org/STLCRef.ST_DerefLoc)...
- en: inversion Ht; subst. inversion HST; subst.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht; 替换。反演 HST; 替换。
- en: rewrite ← H...
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← H...
- en: + (* t[1] steps *)
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht1p 作为 [t[1]' [st' Hstep]]。
- en: ∃([tderef](References.html#STLCRef.tderef) t[1]'). ∃st'...
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tderef](https://example.org/STLCRef.tderef) t[1]'). ∃st'...
- en: '- (* T_Assign *)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Assign *)'
- en: right. destruct IHHt1 as [Ht1p|Ht1p]...
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: right. 分解 IHHt1 为 [Ht1p|Ht1p]...
- en: + (* t[1] is a value *)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是一个值 *)
- en: destruct IHHt2 as [Ht2p|Ht2p]...
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 IHHt2 为 [Ht2p|Ht2p]...
- en: '* (* t[2] is a value *)'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 是一个值 *)'
- en: inversion Ht1p; subst; try solve_by_invert.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht1p; 替换; 尝试通过反演解决。
- en: eexists. eexists. apply [ST_Assign](References.html#STLCRef.ST_Assign)...
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 存在。存在。应用 [ST_Assign](https://example.org/STLCRef.ST_Assign)...
- en: inversion HST; subst. inversion Ht[1]; subst.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 替换 HST; 替换。反演 Ht[1]; 替换。
- en: rewrite H in H[5]...
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H 中重写 H[5]...
- en: '* (* t[2] steps *)'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 步骤 *)'
- en: inversion Ht2p as [t[2]' [st' Hstep]].
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht2p 作为 [t[2]' [st' Hstep]]。
- en: ∃([tassign](References.html#STLCRef.tassign) t[1] t[2]'). ∃st'...
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tassign](https://example.org/STLCRef.tassign) t[1] t[2]'). ∃st'...
- en: + (* t[1] steps *)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion Ht1p as [t[1]' [st' Hstep]].
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Ht1p 作为 [t[1]' [st' Hstep]]。
- en: ∃([tassign](References.html#STLCRef.tassign) t[1]' t[2]). ∃st'...
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tassign](https://example.org/STLCRef.tassign) t[1]' t[2]). ∃st'...
- en: Qed.
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE62]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: (λr:Ref (Unit -> Unit).
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: (λr:Ref (Unit -> Unit).
- en: r := (λx:Unit.(!r) unit); (!r) unit)
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: r := (λx:Unit.(!r) unit); (!r) unit)
- en: (ref (λx:Unit.unit))
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: (ref (λx:Unit.unit))
- en: '[PRE63]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Module ExampleVariables.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 示例变量。
- en: Definition x := Id "x".
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 x := Id "x"。
- en: Definition y := Id "y".
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 y := Id "y"。
- en: Definition r := Id "r".
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 r := Id "r"。
- en: Definition s := Id "s".
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 s := Id "s"。
- en: End ExampleVariables.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 示例变量。
- en: Module RefsAndNontermination.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 RefsAndNontermination。
- en: Import ExampleVariables.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 示例变量。
- en: Definition loop_fun :=
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 loop_fun :=
- en: tabs x TUnit (tapp (tderef (tvar r)) tunit).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: tabs x TUnit (tapp (tderef (tvar r)) tunit)。
- en: Definition loop :=
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 loop :=
- en: tapp
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: tapp
- en: (tabs r (TRef (TArrow TUnit TUnit))
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: (tabs r (TRef (TArrow TUnit TUnit))
- en: (tseq (tassign (tvar r) loop_fun)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: (tseq (tassign (tvar r) loop_fun)
- en: (tapp (tderef (tvar r)) tunit)))
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: (tapp (tderef (tvar r)) tunit)))
- en: (tref (tabs x TUnit tunit)).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: (tref (tabs x TUnit tunit))。
- en: '[PRE64]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Lemma loop_typeable : ∃T, empty; nil ⊢ loop ∈ T.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 loop_typeable : ∃T, empty; nil ⊢ loop ∈ T.'
- en: Proof with eauto.
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明与 eauto。
- en: eexists. unfold [loop](References.html#STLCRef.RefsAndNontermination.loop).
    unfold [loop_fun](References.html#STLCRef.RefsAndNontermination.loop_fun).
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 存在。展开 [loop](https://example.org/STLCRef.RefsAndNontermination.loop)。展开 [loop_fun](https://example.org/STLCRef.RefsAndNontermination.loop_fun)。
- en: eapply [T_App](References.html#STLCRef.RefsAndNontermination.T_App)...
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_App](https://example.org/STLCRef.RefsAndNontermination.T_App)...
- en: eapply [T_Abs](References.html#STLCRef.RefsAndNontermination.T_Abs)...
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_Abs](https://example.org/STLCRef.RefsAndNontermination.T_Abs)...
- en: eapply [T_App](References.html#STLCRef.RefsAndNontermination.T_App)...
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_App](https://example.org/STLCRef.RefsAndNontermination.T_App)...
- en: eapply [T_Abs](References.html#STLCRef.RefsAndNontermination.T_Abs). eapply
    [T_App](References.html#STLCRef.RefsAndNontermination.T_App). eapply [T_Deref](References.html#STLCRef.RefsAndNontermination.T_Deref).
    eapply [T_Var](References.html#STLCRef.RefsAndNontermination.T_Var).
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_Abs](References.html#STLCRef.RefsAndNontermination.T_Abs). eapply
    [T_App](References.html#STLCRef.RefsAndNontermination.T_App). eapply [T_Deref](References.html#STLCRef.RefsAndNonTermination.T_Deref).
    eapply [T_Var](References.html#STLCRef.RefsAndNonTermination.T_Var).
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). simpl. reflexivity.
    auto.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [update](Maps.html#update), [t_update](Maps.html#t_update). 简化。反射性。自动。
- en: eapply [T_Assign](References.html#STLCRef.RefsAndNontermination.T_Assign).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_Assign](References.html#STLCRef.RefsAndNontermination.T_Assign).
- en: eapply [T_Var](References.html#STLCRef.RefsAndNontermination.T_Var). unfold
    [update](Maps.html#update), [t_update](Maps.html#t_update). simpl. reflexivity.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_Var](References.html#STLCRef.RefsAndNontermination.T_Var). 展开 [update](Maps.html#update),
    [t_update](Maps.html#t_update). 简化。反射性。
- en: eapply [T_Abs](References.html#STLCRef.RefsAndNontermination.T_Abs).
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_Abs](References.html#STLCRef.RefsAndNontermination.T_Abs).
- en: eapply [T_App](References.html#STLCRef.RefsAndNontermination.T_App)...
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_App](References.html#STLCRef.RefsAndNontermination.T_App)...
- en: eapply [T_Deref](References.html#STLCRef.RefsAndNontermination.T_Deref). eapply
    [T_Var](References.html#STLCRef.RefsAndNontermination.T_Var). reflexivity.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_Deref](References.html#STLCRef.RefsAndNonTermination.T_Deref). eapply
    [T_Var](References.html#STLCRef.RefsAndNonTermination.T_Var). 反射性。
- en: Qed.
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE65]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Inductive step_closure {X:Type} (R: relation X) : X → X → Prop :='
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳步骤闭包 {X:Type} (R: relation X) : X → X → Prop :='
- en: '| sc_one  : ∀(x y : X),'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '| sc_one  : ∀(x y : X),'
- en: R x y → step_closure R x y
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: R x y → step_closure R x y
- en: '| sc_step : ∀(x y z : X),'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '| sc_step : ∀(x y z : X),'
- en: R x y →
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: R x y →
- en: step_closure R y z →
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤闭包 R y z →
- en: step_closure R x z.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤闭包 R x z。
- en: Definition multistep1 := (step_closure step).
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 multistep1 := (step_closure step).
- en: Notation "t1 '/' st '⇒+' t2 '/' st'" :=
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "t1 '/' st '⇒+' t2 '/' st'" :=
- en: (multistep1 (t[1],st) (t[2],st'))
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: (multistep1 (t[1],st) (t[2],st'))
- en: (at level 40, st at level 39, t[2] at level 39).
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: (at level 40, st at level 39, t[2] at level 39).
- en: '[PRE66]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Ltac print_goal := match goal with ⊢ ?x ⇒ idtac x end.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: Ltac print_goal := match goal with ⊢ ?x ⇒ idtac x end.
- en: Ltac reduce :=
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: Ltac reduce :=
- en: repeat (print_goal; eapply multi_step ;
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 重复（print_goal; eapply multi_step ;
- en: '[ (eauto 10; fail) | (instantiate; compute)];'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '[ (eauto 10; fail) | (instantiate; compute)];'
- en: try solve [apply multi_refl]).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解决 [apply multi_refl]).
- en: '[PRE67]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Lemma loop_steps_to_loop_fun :'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 loop_steps_to_loop_fun :'
- en: loop / nil ⇒*
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: loop / nil ⇒*
- en: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil。
- en: Proof.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 证明
- en: unfold loop.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 loop。
- en: reduce.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 减少。
- en: Qed.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE68]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Lemma loop_fun_step_self :'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 loop_fun_step_self :'
- en: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil ⇒+
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil ⇒+
- en: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: tapp (tderef (tloc 0)) tunit / cons ([r:=tloc 0]loop_fun) nil。
- en: Proof with eauto.
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明与 eauto。
- en: unfold [loop_fun](References.html#STLCRef.RefsAndNontermination.loop_fun); simpl.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [loop_fun](References.html#STLCRef.RefsAndNontermination.loop_fun); 简化。
- en: eapply [sc_step](References.html#STLCRef.RefsAndNontermination.sc_step). apply
    [ST_App1](References.html#STLCRef.RefsAndNontermination.ST_App1)...
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [sc_step](References.html#STLCRef.RefsAndNontermination.sc_step). apply
    [ST_App1](References.html#STLCRef.RefsAndNontermination.ST_App1)...
- en: eapply [sc_one](References.html#STLCRef.RefsAndNontermination.sc_one). compute.
    apply [ST_AppAbs](References.html#STLCRef.RefsAndNontermination.ST_AppAbs)...
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [sc_one](References.html#STLCRef.RefsAndNontermination.sc_one). compute.
    apply [ST_AppAbs](References.html#STLCRef.RefsAndNontermination.ST_AppAbs)...
- en: Qed.
  id: totrans-722
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE69]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Definition factorial : tm'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘定义：tm
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
- en: 'Lemma factorial_type : empty; nil ⊢ factorial ∈ (TArrow TNat TNat).'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 factorial_type : empty; nil ⊢ factorial ∈ (TArrow TNat TNat).'
- en: Proof with eauto.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 证明与 eauto。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: (* FILL IN HERE *) Admitted.
- en: '[PRE70]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: (*  Lemma factorial_4 : exists st,   tapp factorial (tnat 4) / nil ==>* tnat 24 / st.
    Proof.   eexists. unfold factorial. reduce. Qed. *)
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: (*  Lemma factorial_4 : exists st,   tapp factorial (tnat 4) / nil ==>* tnat 24 / st.
    Proof.   eexists. unfold factorial. reduce. Qed. *)
- en: '[PRE71]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Additional Exercises
  id: totrans-732
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加练习
- en: 'Exercise: 5 stars, optional (garabage_collector)'
  id: totrans-733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：5星，可选（垃圾回收器）
- en: 'Challenge problem: modify our formalization to include an account'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 挑战问题：修改我们的形式化以包括一个账户
- en: of garbage collection, and prove that it satisfies whatever nice
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 垃圾收集的定义，并证明它满足任何好的
- en: properties you can think to prove about it.
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以考虑证明的属性。
- en: ☐
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE72]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
