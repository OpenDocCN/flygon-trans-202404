- en: Virtual Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lecture Notes for CS 140
  prefs: []
  type: TYPE_NORMAL
- en: Spring 2014
  prefs: []
  type: TYPE_NORMAL
- en: John Ousterhout
  prefs: []
  type: TYPE_NORMAL
- en: 'Readings for this topic from *Operating Systems: Principles and Practice*:
    Chapter 8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can one memory be shared among several concurrent processes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single-tasking (no sharing):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highest memory holds OS.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Process is allocated memory starting at 0, up to the OS area.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples: early batch monitors where only one job ran at a time. It could corrupt
    the OS, which would be rebooted by an operator. Some early personal computers
    were similar.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Goals for sharing memory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multitasking: allow multiple processes to be memory-resident at once.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transparency: no process should need to be aware of the fact that memory is
    shared. Each must run regardless of the number and/or locations of processes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Isolation: processes mustn''t be able to corrupt each other.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiency (both of CPU and memory) shouldn't be degraded badly by sharing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Load-time relocation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highest memory holds OS.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: First process loaded at 0; others fill empty spaces.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a process is loaded, relocate it so that it can run in its allocated memory
    area, similar to linking:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Linker outputs relocation records in executable files
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to information in object files: indicates which locations contain memory
    addresses'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OS modifies addresses when it loads process (add base address)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the problems with this approach?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic Memory Relocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of relocating a program statically when it is loaded, add hardware (*memory
    management unit*) that changes addresses dynamically *during every memory reference*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each address generated by a process (called a *virtual address*) is translated
    in hardware to a *physical* address. This happens during every memory reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Results in two views of memory, called *address spaces*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual address space is what the program sees
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical address space is the actual allocation of memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Base and Bound Relocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two hardware registers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Base: physical address corresponding to virtual address 0.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bound: highest allowable virtual address.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On each memory reference, virtual address is compared to the bound register,
    then added to the base register to produce a physical address. A bound violation
    results in a trap to the operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each process appears to have a completely private memory whose size is determined
    by the bound register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes are isolated from each other and OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No address relocation is necessary when a process is loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each process has its own base and bound values, which are saved in the process
    control block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS runs with relocation turned off, so it can access all of memory (a bit in
    the processor status word controls relocation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must prevent users from turning off relocation or modifying the base and bound
    registers (another bit in PSW for user/kernel mode).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Problem: how does OS regain control once it has given it up?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Base & bound is cheap (only 2 hardware registers) and fast: the add and compare
    can be done in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's wrong with base and bound relocation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each process is split among several variable-size areas of memory, called segments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g. one segment for code, one segment for heap, one segment for stack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Segment table* holds the bases and bounds for all the segments of a process,
    plus protection bit for each segment: read-write versus read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory mapping procedure consists of table lookup + add + compare.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each memory reference must indicate a *segment number* and *offset*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top bits of address select segment, low bits the offset.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: PDP-10 with high and low segments selected by high-order address bit.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, segment can be selected implicitly by the instruction (e.g. code vs. data,
    stack vs. data, or 8086 prefixes).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advantage of segmentation: flexibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manage each segment separately:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Grow and shrink independently
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Swap to disk
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can share segments between processes (e.g., shared code).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can move segments to compact memory and eliminate fragmentation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What's wrong with segmentation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Divide virtual and physical memory into fixed-sized chunks called *pages*. The
    most common size is 4 Kbytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each process, a *page table* defines the base address of each of that process'
    pages along with read-only and "present" bits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page table stored in contiguous memory (with base register in hardware).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Translation process: page number always comes directly from the address. Since
    page size is a power of two, no comparison or addition is necessary. Just do table
    lookup and bit substitution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Easy to allocate: keep a free list of available pages and grab the first one.
    Easy to swap since everything is the same size, which is usually the same size
    as disk blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Problem: for modern machines, page tables can be very large:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider x86-64 addressing architecture: 64-bit addresses, 4096-byte pages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, each page table should fit in a page.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Most processes are small, so most page table entries are unused.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Even large processes use their address space sparsely (e.g., code at the bottom,
    stack at the top)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: multi-level page tables. Intel x86-64 addressing architecture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 64-bit virtual addresses, but only the lower 48 bits are actually used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '4 Kbyte pages: low-order 12 bits of virtual address hold off set within page.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 levels of page table, each indexed with 9 bits of virtual address.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each page table fits in one page (page table entries are 8 bytes).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can omit empty page tables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next problem: page tables are too large to load into fast memory in the relocation
    unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page tables kept in main memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Relocation unit holds base address for top-level page table
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With x86-64 architecture, must make 4 memory references to translate a virtual
    address!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Translation Lookaside Buffers (TLBs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solution to page translation overhead: create a small hardware cache of recent
    translations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each cache entry stores the page number portion of a virtual address (36 bits
    for x86-64) and the corresponding physical page number (40 bits for x86-64).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical TLB sizes: 64-2048 entries.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On each memory reference, compare the page number from the virtual address with
    the virtual page numbers in every TLB entry (in parallel).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a match, use the corresponding physical page number.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If no match, perform the full address translation and save the information in
    the TLB (replace one of the existing entries).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TLB "hit rates" typically 95% or more.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TLB complications:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When context switching, must invalidate all of the entries in the TLB (mappings
    will be different for the next process). Chip hardware does this automatically
    when the page table base register is changed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If virtual memory mappings change for the current process (e.g. page moved),
    must invalidate some TLB entries. Special hardware instruction for this.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous Topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does the operating system get information from user memory? E.g. I/O buffers,
    parameter blocks. Note that the user passes the OS a *virtual address*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some systems the OS just runs unmapped.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case it reads page the tables and translates user addresses in software.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Addresses that are contiguous in the virtual address space may not be contiguous
    physically. Thus I/O operations may have to be split up into multiple blocks.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Most newer systems include kernel and user memory in same virtual address space
    (but kernel memory not accessible in user mode). This makes life easier for the
    kernel, although it doesn't solve the I/O problem.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another issue with paging: *internal fragmentation*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can't allocate partial pages, so for small chunks of information only part of
    the page will be used
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: wasted space at the ends of some pages'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not much of a problem in today''s systems:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The objects (such as code or stack) tend to be much larger than a page.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Percentage wasted space from fragmentation is small.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if page sizes grow?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
