- en: 'Chapter 10: Generics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript supports a programming construct called *generics*. TypeScript generics
    allow you to write code that operates against broad swathes of classes and interfaces
    without giving up strong typing. You write your code to execute against *types*
    (classes and interfaces), as opposed specific, concrete classes. Once written,
    you access this generic code by providing a concrete type at runtime. Let's consider
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you are developing a game and storing and retrieving game information
    to/from a database. This means you have to implement the classic Create, Read,
    Update and Delete operations (CRUD) for the various objects in the game. Here''s
    some high level code that beings to implement the game and this logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code defines three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Game`: This is the game object itself, keeping track of overall game state,
    including a list of players and the currently active player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Player`: Represents a player in the game. Players also have some state information,
    although its different than a `Game`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameStateDBHelper`: A utility class that provides input/output operations
    and supports all four CRUD operations for the Game object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameStateDBHelper` defines four public methods, one for each of the CRUD operations.
    These each take commonsense input parameters and return commonsense results. Consider
    `LoadGame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`LoadGame` is passed a query (think "select * from Games..."). It parses the
    result and returns back a new `Game` object. Obviously, there''s a lot of hand
    waving going on in the example, but hopefully the concept is clear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The DB helper object makes it easy to execute the CRUD operations as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite the clarity and strong-typed goodness, this approach is nonetheless
    problematic. We already know we''ll want another database-backed entity - `Player`.
    If we simply follow the current approach, we end up creating a new helper function,
    `PlayerStateDBHelper`. It has to provide the same CRUD functions and each one
    shaped almost identically to GameState. "Shape" in this case means:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking up database connection information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing some common command that varies only in small details from one object
    to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning success/fail messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can mitigate most of that using TypeScript''s generic functionality. Here''s
    how it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Generics introduce some new syntax and leverage existing concepts (like interfaces)
    in new ways.
  prefs: []
  type: TYPE_NORMAL
- en: The code first defines a new interface, `DBBackedEntity`. This interface requires
    a single text field, "TableName". This obviously maps to a database table via
    its name.
  prefs: []
  type: TYPE_NORMAL
- en: It then creates two models for the Game and its Players respectively. Each of
    them implements the DBBackedEntity interface and assigns a database table name
    via the object's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DBHelper` class introduces the generics syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax, `<T extends DBBackedEntity>` effectively says, "The DB helper
    class works against any type (class) that implements the DBBackedEntity interface."
    When client code instantiates an instance of DBHelper, it will specify a value
    for that parameter, `T`. These two lines show how to pass a value for `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with generics, we supply type parameters via angle brackets: `DBHelper<GameState>`
    and `DBHelper<GamePlayer>`. TypeScript replaces the `T` parameter in the `DBHelper`
    class with `GameState` and `GamePlayer` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I wrote a lengthy blog post describing how to use generics to implement a binary
    search. You can read that here: [https://blog.hellojs.org/implement-binary-search-in-typescript-using-generics-with-useful-refactorings-a4bcda932d7](https://blog.hellojs.org/implement-binary-search-in-typescript-using-generics-with-useful-refactorings-a4bcda932d7).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of particular interest to React developers, this article describes how to use
    default values with generics: [https://blog.mariusschulz.com/2017/06/02/typescript-2-3-generic-parameter-defaults](https://blog.mariusschulz.com/2017/06/02/typescript-2-3-generic-parameter-defaults).
    Note that it''s written in the context of a React application but the feature
    is not tied to React.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter on generics brings the main body of of *Yet Another TypeScript
    Book* to a close. The next chapter suggests some additional reading and videos
    that you may find of interest
  prefs: []
  type: TYPE_NORMAL
