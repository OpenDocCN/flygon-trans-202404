- en: Subject
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subject
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Subject is a double nature. It has both the behaviour from an [Observer](observer.html)
    and an [Observable](observable-anatomy.html). Thus the following is possible:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Emitting values
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Subscribing to values
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To sum it up the following operations exist on it:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Acting as a proxy
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Subject` can act as a proxy, i.e receive values from another stream that
    the subscriber of the `Subject` can listen to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So essentially proxySubject `listens` to `source$`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: But it can also add its own contribution
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**GOTCHA**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Any `next()` that happens before a subscription is created is lost. There are
    other Subject types that can cater to this below.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Business case
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what's interesting about this? It can listen to some source when that data
    arrives as well as it has the ability to emit its own data and all arrives to
    the same subscriber. Ability to communicate between components in a bus like manner
    is the most obvious use case I can think of. Component 1 can place its value through
    `next()` and Component 2 can subscribe and conversely Component 2 can emit values
    in turn that Component 1 can subscribe to.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ReplaySubject
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'prototype:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Wow, what happened here, what happened to the first number?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: So a `.next()` that happens before the subscription is created, is normally
    lost. But in the case of a `ReplaySubject` we have a chance to save emitted values
    in the cache. Upon creation the cache has been decided to save two values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate how this works:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**GOTCHA**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: It matters both when the `.next()` operation happens, the size of the cache
    as well as when your subscription is created.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In the example above it was demonstrated how to use the constructor using `bufferSize`
    argument in the constructor. However there also exist a `windowSize` argument
    where you can specify how long the values should remain in the cache. Set it to
    `null` and it remains in the cache indefinite.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Business case
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's quite easy to imagine the business case here. You fetch some data and want
    the app to remember what was fetched latest, and what you fetched might only be
    relevant for a certain time and when enough time has passed you clear the cache.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: AsyncSubject
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Looking at this we expect 1,2 to be emitted right? WRONG.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Nothing will be emitted unless `complete()` happen
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`complete()` needs to happen regardless of the finishing operation before it
    succeeds or fails so'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Business case
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you care about preserving the last state just before the stream ends, be
    it a value or an error. So NOT last emitted state generally but last *before closing
    time*. With state I mean value or error.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: BehaviourSubject
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This Subject emits the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: the initial value
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the values emitted generally
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: last emitted value.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Business case
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is quite similar to `ReplaySubject`. There is a difference though, we can
    utilize a default / start value that we can show initially if it takes some time
    before the first values starts to arrive. We can inspect the latest emitted value
    and of course listen to everything that has been emitted. So think of `ReplaySubject`
    as more *long term memory* and `BehaviourSubject` as short term memory with default
    behaviour.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`ReplaySubject`非常相似。不过有一个区别，我们可以利用一个默认/初始值，在第一个值开始到达之前，我们可以首先显示它。我们可以检查最新发出的值，当然也可以监听所有已发出的内容。因此，将`ReplaySubject`视为更长期的记忆，而将`BehaviourSubject`视为具有默认行为的短期记忆。
