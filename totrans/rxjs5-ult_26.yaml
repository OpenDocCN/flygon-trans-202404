- en: Subject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Subject is a double nature. It has both the behaviour from an [Observer](observer.html)
    and an [Observable](observable-anatomy.html). Thus the following is possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Emitting values
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing to values
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum it up the following operations exist on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Acting as a proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Subject` can act as a proxy, i.e receive values from another stream that
    the subscriber of the `Subject` can listen to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So essentially proxySubject `listens` to `source$`
  prefs: []
  type: TYPE_NORMAL
- en: But it can also add its own contribution
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**GOTCHA**'
  prefs: []
  type: TYPE_NORMAL
- en: Any `next()` that happens before a subscription is created is lost. There are
    other Subject types that can cater to this below.
  prefs: []
  type: TYPE_NORMAL
- en: Business case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what's interesting about this? It can listen to some source when that data
    arrives as well as it has the ability to emit its own data and all arrives to
    the same subscriber. Ability to communicate between components in a bus like manner
    is the most obvious use case I can think of. Component 1 can place its value through
    `next()` and Component 2 can subscribe and conversely Component 2 can emit values
    in turn that Component 1 can subscribe to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ReplaySubject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Wow, what happened here, what happened to the first number?
  prefs: []
  type: TYPE_NORMAL
- en: So a `.next()` that happens before the subscription is created, is normally
    lost. But in the case of a `ReplaySubject` we have a chance to save emitted values
    in the cache. Upon creation the cache has been decided to save two values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**GOTCHA**'
  prefs: []
  type: TYPE_NORMAL
- en: It matters both when the `.next()` operation happens, the size of the cache
    as well as when your subscription is created.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above it was demonstrated how to use the constructor using `bufferSize`
    argument in the constructor. However there also exist a `windowSize` argument
    where you can specify how long the values should remain in the cache. Set it to
    `null` and it remains in the cache indefinite.
  prefs: []
  type: TYPE_NORMAL
- en: Business case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's quite easy to imagine the business case here. You fetch some data and want
    the app to remember what was fetched latest, and what you fetched might only be
    relevant for a certain time and when enough time has passed you clear the cache.
  prefs: []
  type: TYPE_NORMAL
- en: AsyncSubject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this we expect 1,2 to be emitted right? WRONG.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing will be emitted unless `complete()` happen
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`complete()` needs to happen regardless of the finishing operation before it
    succeeds or fails so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Business case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you care about preserving the last state just before the stream ends, be
    it a value or an error. So NOT last emitted state generally but last *before closing
    time*. With state I mean value or error.
  prefs: []
  type: TYPE_NORMAL
- en: BehaviourSubject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This Subject emits the following:'
  prefs: []
  type: TYPE_NORMAL
- en: the initial value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the values emitted generally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: last emitted value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Business case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is quite similar to `ReplaySubject`. There is a difference though, we can
    utilize a default / start value that we can show initially if it takes some time
    before the first values starts to arrive. We can inspect the latest emitted value
    and of course listen to everything that has been emitted. So think of `ReplaySubject`
    as more *long term memory* and `BehaviourSubject` as short term memory with default
    behaviour.
  prefs: []
  type: TYPE_NORMAL
