- en: Church NumeralsTuesday, February 14th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, it seems like it is impossible to do anything useful in this language,
    since all we have are functions and applications. We know how to write the identity
    function, but what about other values? For example, can you write code that evaluates
    to zero?
  prefs: []
  type: TYPE_NORMAL
- en: What’s zero? I only know how to write functions!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Turing Machine programmer: “What’s a function? — I only know how to write
    0s and 1s!”)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The first thing we therefore need is to be able to *encode* numbers as functions.
    For zero, we will use a function of two arguments that simply returns its second
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: or, more concisely
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first step in an encoding that is known as *Church Numerals*: an
    encoding of natural numbers as functions. The number zero is encoded as a function
    that takes in a function and a second value, and applies the function zero times
    on the argument (which is really what the above definition is doing). Following
    this view, the number one is going to be a function of two arguments, that applies
    the first on the second one time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'and note that `1` is just like the identity function (as long as you give it
    a function as its first input, but this is always the case in Schlac). The next
    number on the list is two — which applies the first argument on the second one
    twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go on doing this, but what we really want is a way to perform arbitrary
    arithmetic. The first requirement for that is an `add1` function that increments
    its input (an encoded natural number) by one. To do this, we write a function
    that expects an encoded number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'and this function is expected to return an encoded number, which is always
    a function of `f` and `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the body, we need to apply `f` on `x` n+1 times — but remember that
    `n` is a function that will do `n` applications of its first argument on its second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'and all we have left to do now is to apply `f` one more time, yielding this
    definition for `add1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this, we can define a few useful numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all nice theoretically, but how can we make sure that it is correct?
    Well, Schlac has a few additional special forms that translate Church numerals
    into Racket numbers. To try our definitions we use the `->nat` (read: to natural
    number):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now verify that the identity function is really the same as the number
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can even write a test case, since Schlac contains the `test` special form,
    but we have to be careful in that — first of all, we cannot test whether functions
    are equal (why?) so we must use `->nat`, but
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'will not work since `7` is undefined. To overcome this, Schlac has a `back-door`
    for primitive Racket values — just use a quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
