- en: Namespacing With Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namespacing With Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ namespaces allow you to group your functions, variables and classes into
    logical blocks and allow the compiler to disambiguate them from other functions,
    variables and classes that might otherwise have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Namespacing in C++ is completely optional which means some code may use nest
    namespaces while other code may be content to cover its entire codebase with a
    single namespace. Some code might even put its code into the global namespace.
    Other code might control the use of namespaces with macros.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent to a namespace in Rust is a module and serves a similar purpose.
    Unlike C++ though you get namespacing automatically from the structure of your
    files. Each file is a module in its own right.
  prefs: []
  type: TYPE_NORMAL
- en: So if we may have a file myapp.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Everything in myapp.rs is automatically a module called myapp. That means modules
    are implicit and you don't have to do anything except name your file something
    meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also just bring in the whole of the mod if you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or just the types and functions within it that you use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But if you want an explicit module you may also write it in the code. So perhaps
    myapp doesn't justify being a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Modules can be nested so a combination of implicit modules (from file names)
    and explicit modules can be used together.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting modules across files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespacing with modules is pretty easy, But sometimes you might have lots of
    files in a module and you don't want the outside world to see a single module
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases youâ€™re more likely to use the myapp/mod.rs form. In this instance
    the mod.rs file may pull
  prefs: []
  type: TYPE_NORMAL
- en: in subordinate files
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the module pulls in submodules `helpers` and `gui`. Neither
    is marked as `pub mod` so they are private to the module.
  prefs: []
  type: TYPE_NORMAL
- en: However the module also says `pub use helpers::Helper` which allows the outside
    to reference `myapp::Helper`. Thus a module can act as a gatekeeper to the things
    it references, keeping them private or selectively making parts public.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't mentioned the other module here `tests`. The attribute `#[cfg(test)]`
    indicates it is only pulled in when a unit test executable is being built. The
    `cfg` attribute is used for [conditional compliation](https://doc.rust-lang.org/book/conditional-compilation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules can be used once they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the use command is relative to the toplevel `main` or `lib` module.
    So if you declare a `mod helpers` at the top, then the corresponding `use helpers`
    will retrieve it. You can also use relative `use` commands with the `super` and
    `self` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: // TODOs
  prefs: []
  type: TYPE_NORMAL
- en: Module aliasing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: External crates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
