- en: CSE 331 Software Design and Implementation
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: CSE 331软件设计与实现
- en: Rep Invariants and Abstraction Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示不变性和抽象函数
- en: 'Contents:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内容：
- en: '[Introduction](#Introduction)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍](#Introduction)'
- en: '[Rep Invariants](#RepInvariants)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表示不变性](#RepInvariants)'
- en: '[Choosing the Rep Invariant](#ChoosingRepInvariant)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选择表示不变性](#ChoosingRepInvariant)'
- en: '[Checking the Rep Invariant at Run Time](#Checking)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[运行时检查表示不变性](#Checking)'
- en: '[What Not to Write in the Rep Invariant](#Not-in-rep-invariont)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[不要在表示不变性中写什么](#Not-in-rep-invariont)'
- en: '[Abstraction Functions](#AbstractionFunctions)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抽象函数](#AbstractionFunctions)'
- en: '[Where Are R and A Defined?](#WhereAreRAndADefined)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R和A在哪里定义？](#WhereAreRAndADefined)'
- en: '[AF(r)](#AF)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AF(r)](#AF)'
- en: '[Example 1: Card](#example1)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例1：卡片](#example1)'
- en: '[Example 2: Stack](#example2)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例2：栈](#example2)'
- en: '[The Representation Invariant](#together-rep-invariant)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表示不变性](#together-rep-invariant)'
- en: '[The Abstraction Function](#together-absraction-function)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抽象函数](#together-absraction-function)'
- en: '[Subclasses](#Subclasses)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[子类](#Subclasses)'
- en: '[General Hints on Readability](#GeneralHints)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于可读性的一般提示](#GeneralHints)'
- en: '* * *'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Introduction
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This handout describes how to document a class's implementation. It relies on
    you already understanding [Class and Method Specifications](specifications.html).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本手册描述了如何记录一个类的实现。它依赖于您已经理解了[类和方法规范](specifications.html)。
- en: As an example, we will use the same class, `Line` as from [Class and Method
    Specifications](specifications.html). Notice that we are now showing `Line`'s
    implementation because this handout covers documenting a class's implementation
    as opposed to its specification.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将使用与[类和方法规范](specifications.html)中相同的类`Line`。请注意，我们现在展示的是`Line`的实现，因为本手册涵盖了记录类的实现，而不是规范。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We begin with brief definitions of the concepts this document discusses:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本文讨论的概念的简要定义开始：
- en: '*Concrete Representation*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*具体表示*'
- en: How the abstract state of a class is represented within a Java object. For example,
    `line` uses four fields with type `int`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类的抽象状态如何在Java对象中表示。例如，`line`使用了四个类型为`int`的字段。
- en: '*Representation Invariant*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*表示不变性*'
- en: A condition that must be true over all valid concrete representations of a class.
    The representation invariant also defines the domain of the abstraction function.
    In this particular example, `Line` requires that it is never the case that `r.startX
    == r.endX && r.startY == r.endY`, which is a condition imposed by the abstract
    invariant in the specification. However, representation invariants are not limited
    to situations where the specification includes an abstract invariant. They apply
    whenever there are conditions that must be met for the representation to be well-formed
    or properly defined.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在类的所有有效具体表示上为真的条件。表示不变性还定义了抽象函数的域。在这个特定的例子中，`Line`要求`r.startX == r.endX &&
    r.startY == r.endY`永远不成立，这是规范中抽象不变性所施加的条件。然而，表示不变性不仅限于规范包含抽象不变性的情况。只要有必须满足的条件，使得表示形式是完整的或正确定义的，表示不变性就适用。
- en: '*Abstraction Function*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象函数*'
- en: 'A function from an object''s concrete representation to the abstract value
    it represents. The abstraction function for `Line` is trivial: A concrete `Line`
    instance, `r`, is mapped to a line, `l`, having `l.start-point` equal to `?r.xStart,
    r.yStart?` and `l.end-point` equal to `?r.xEnd, r.yEnd?`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象的具体表示到其表示的抽象值的函数。`Line`的抽象函数是微不足道的：一个具体的`Line`实例`r`被映射到一条线`l`，其`l.start-point`等于`?r.xStart,
    r.yStart?`，`l.end-point`等于`?r.xEnd, r.yEnd?`。
- en: Representation invariants and abstraction functions are internal documentation
    of a class's implementation details. A client should not need any of this information
    to properly use the class. This information is recorded to help with implementing,
    testing, debugging, modifying, and extending the class. Therefore, abstraction
    functions and representation invariants should not appear in a class's description
    or specification (Javadoc). Instead, the information should appear as internal
    comments in the class's body (usually using `//`).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不变性和抽象函数是类实现细节的内部文档。客户端不应该需要任何这些信息来正确使用类。这些信息记录下来是为了帮助实现、测试、调试、修改和扩展类。因此，抽象函数和表示不变性不应该出现在类的描述或规范（Javadoc）中。相反，这些信息应该出现在类体中的内部注释中（通常使用`//`）。
- en: This document starts by telling how to relate a class's concrete representation
    to what it abstractly represents through the use of [representation invariants](#RepInvariants)
    and [abstraction functions](#AbstractionFunctions). Then it provides two examples
    of these concepts and the concepts presented in [Class and Method Specifications](specifications.html).
    Finally, it ends with some [general hints](#GeneralHints) for writing understandable
    documentation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本文首先介绍了如何通过使用[表示不变式](#RepInvariants)和[抽象函数](#AbstractionFunctions)将类的具体表示与抽象表示相关联。然后提供了这些概念的两个示例以及[类和方法规范](specifications.html)中介绍的概念。最后，以一些[一般提示](#GeneralHints)结束，以便撰写易于理解的文档。
- en: Rep Invariants
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rep 不变式
- en: A rep invariant RI maps the concrete representation to a Boolean (true or false). 
    Formally,
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 rep 不变式 RI 将具体表示映射到布尔值（true 或 false）。形式上，
- en: 'RI: *R* ? *boolean*'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RI：*R* ? *boolean*
- en: where R is the set of rep values.  The rep invariant describes whether a rep
    value is a well-formed instance of the type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 R 是 rep 值的集合。rep 不变式描述了一个 rep 值是否是该类型的一个良好实例。
- en: 'The comment describing a rep invariant may explicitly emphasize the functional
    aspect of RI:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 rep 不变式的注释可能明确强调 RI 的功能方面：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'More commonly, however, we just drop the RI(r) detail and simply write the
    rep invariant as a predicate that must be true of `this`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更常见的是，我们只是放弃 RI(r) 的细节，简单地将 rep 不变式写成必须对 `this` 为真的谓词：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A rep invariant may mix concrete Java syntax (rep field references, method
    calls, `instanceof`, `!=`, `==`) with abstract mathematical syntax (sequence/set/tuple
    construction, for all, there exists, summation, `=`).   A rep invariant may also
    be simple English, of course, as long as it is unambiguous.  Here are some examples:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: rep 不变式可能会混合具体的 Java 语法（rep 字段引用、方法调用、`instanceof`、`!=`、`==`）和抽象的数学语法（序列/集合/元组构造、对于所有、存在、求和、`=`）。当然，rep
    不变式也可以是简单的英语，只要它是明确的。以下是一些例子：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the rep uses other ADTs, it may refer to them either by their spec fields
    or by their operations.  For example, suppose the `Trans` type has a spec field
    `amount` that is accessible by the operation `getAmount`.  Then the rep invariant
    for `Account` (which uses `Trans` objects) might look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 rep 使用其他 ADT，则可以通过其规范字段或操作来引用它们。例如，假设 `Trans` 类型具有可通过操作 `getAmount` 访问的规范字段
    `amount`。那么对于使用 `Trans` 对象的 `Account` 的 rep 不变式可能如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'or this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'or even this (since `transactions` is an instance of an ADT with a `get` operation):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至是这样（因为 `transactions` 是具有 `get` 操作的 ADT 的一个实例）：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All these are equivalent.  But it's important to keep in mind that `amount`
    in (1) above refers to a *spec field* in `Trans`, not to a concrete field.  Unless
    `Account` and `Trans` are cooperating very closely, it isn't appropriate for `Account`
    to break the abstraction barrier and refer to the rep fields of  `Trans` directly. 
    By contrast, it's perfectly normal for `Account`'s rep invariant to refer directly
    to `Account`'s rep fields.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是等价的。但是，重要的是要记住，在上述（1）中，`amount` 指的是 `Trans` 中的*规格字段*，而不是具体字段。除非 `Account`
    和 `Trans` 合作非常密切，否则让 `Account` 打破抽象屏障并直接引用 `Trans` 的 rep 字段是不合适的。相比之下，让 `Account`
    的 rep 不变式直接引用 `Account` 的 rep 字段是完全正常的。
- en: Choosing the Rep Invariant
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择 Rep 不变式
- en: 'Writing down a rep invariant is tremendously useful for testing, debugging,
    and writing correct code.  It''s essential for maintainers: programmers who come
    back to fix or enhance the code later.  The most common problem with rep invariants
    is *incompleteness* — leaving out something important.  (Leaving out the rep invariant
    entirely is probably the most common example of this problem!)  So here are some
    hints that will help you fill out your rep invariants.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 写下 rep 不变式对于测试、调试和编写正确代码非常有用。对于维护者来说至关重要：以后回来修复或增强代码的程序员。rep 不变式最常见的问题是*不完整*
    ——漏掉了一些重要内容。（完全忽略 rep 不变式可能是这个问题最常见的例子！）所以以下是一些提示，将帮助您填写您的 rep 不变式。
- en: '**Look for rep values on which the abstraction function has no meaning. **
    The abstraction function is often a *partial* function, meaning that it isn''t
    defined for some possible values of the representation *R*.  The rep invariant
    must exclude any such values.  Recall the `Card` example from above:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找抽象函数无意义的 rep 值。** 抽象函数通常是一个*部分*函数，意味着它对某些可能的表示 *R* 的值没有定义。rep 不变式必须排除任何这样的值。回顾上面的
    `Card` 示例：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, the abstraction function isn''t defined when the suit number,
    `index div 13`, is anything but 0, 1, 2, or 3.  So that rules out values of `index`
    less than 0 or greater than 51:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当花色编号`index div 13`不是0、1、2或3时，抽象函数未定义。因此，排除了小于0或大于51的`index`值：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure you don't restrict the rep invariant so much that the abstraction
    function no longer covers the entire abstract value space *A*!  If you do that,
    you'll no longer be implementing the abstract type, since some abstract values
    will be unrepresentable.  Here, a little thought convinces us that `index` still
    represents 52 cards, all distinct.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保不要限制表示不变量以至于抽象函数不再覆盖整个抽象值空间*A*！如果这样做，你将不再实现抽象类型，因为一些抽象值将无法表示。在这里，稍加思考就会使我们确信`index`仍然代表52张卡片，全部不同。
- en: '**Look for rep values on which your methods would produce the wrong abstract
    value. ** Consider a class `CharSet` that represents a set of characters using
    a mutable string:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找使你的方法产生错误抽象值的表示值。** 考虑一个表示使用可变字符串表示字符集的`CharSet`类：'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This implementation of the `remove` method works only if there are no duplicates
    in the string, because it only deletes the first occurrence of `c` that it finds. 
    Notice that the abstraction function is fully defined on *R* here — it doesn't
    care whether or not there are duplicate characters, because the set construction
    syntax implicitly ignores them.  But we need the rep invariant to ensure that
    `remove` always results in the correct abstract value, i.e. a set that does not
    contain `c.`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此`remove`方法的实现仅在字符串中没有重复字符时有效，因为它只删除找到的`c`的第一个出现。请注意，这里抽象函数在*R*上完全定义 - 它不关心是否有重复字符，因为集合构造语法隐式忽略它们。但是，我们需要表示不变量来确保`remove`始终产生正确的抽象值，即不包含`c`的集合。
- en: '**Look for constraints required by the data structures or algorithms you''ve
    chosen.** As examples, an array must be sorted in order to use binary search,
    a tree cannot have cycles, and two tree nodes cannot share the same child.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找数据结构或算法所需的约束条件。** 例如，数组必须排序才能使用二分查找，树不能有循环，两个树节点不能共享相同的子节点。'
- en: '**Look for fields that need to stay coordinated with each other.**  In a bank
    account, for example, the balance and the sum of the transaction amounts should
    always be in sync.  In a linked list, the `size` field always needs to reflect
    accurately the number of nodes in the list.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找需要保持协调的字段。** 例如，在银行账户中，余额和交易金额之和应始终保持同步。在链表中，`size`字段始终需要准确反映列表中的节点数。'
- en: '**Look for rep values that would cause your code to throw unexpected exceptions.**
    A conventional part of every rep invariant is a set of fields that shouldn''t
    be null, so you won''t have any `NullPointerException`s when you use them later:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找会导致代码抛出意外异常的表示值。** 每个表示不变量的传统部分都是一组不应为null的字段，这样在以后使用它们时就不会出现`NullPointerException`：'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Make sure your constructors and producers actually establish the rep invariant,
    though.  That means, if any of these fields are initialized from parameters, you
    have to check for null before you put them in the rep.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请确保你的构造函数和生成器确实建立了表示不变量。这意味着，如果这些字段中的任何一个是从参数初始化的，你必须在将它们放入表示之前检查是否为null。
- en: 'Some other exceptional conditions you should think about:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他需要考虑的异常情况：
- en: division by zero
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除零
- en: index out of range
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引超出范围
- en: class cast exception
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换异常
- en: '**Look for constraints imposed by the application domain (on abstract values).** 
    In a bank account, the balance should always be non-negative.  (Or even stronger:
    the partial sums of the transaction amounts must all be non-negative, to guarantee
    that the balance never went negative in the past.)  In chess, two bishops of the
    same color should not be on squares of the same color (unless a pawn has reached
    the end of the board and been promoted to a bishop).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找应用领域（对抽象值）强加的约束。** 在银行账户中，余额应始终为非负数。（甚至更强：交易金额的部分和必须始终为非负数，以确保余额过去从未为负数。）在国际象棋中，两个相同颜色的主教不应位于相同颜色的方格上（除非兵卒到达棋盘的尽头并晋升为主教）。'
- en: Assuming they refer only to properties of the abstract values (like spec fields),
    these kinds of constraints do not just apply to the rep.  They are in fact *abstract
    invariants*. Abstract invariants should be documented for the client of the data
    type, so put them in your class overview.  But when abstract invariants exist,
    they very often imply constraints that need to be included in the representation
    invariant.  If you omitted these from the rep invariant, then your type would
    represent abstract values that aren't well-formed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设它们仅涉及抽象值的属性（如规范字段），这些约束不仅适用于表示。实际上它们是*抽象不变量*。抽象不变量应该为数据类型的客户端记录，因此将它们放在类概述中。但是，当存在抽象不变量时，它们很常常暗示需要包含在表示不变性中的约束。如果从表示不变性中省略了这些内容，那么您的类型将表示不符合规范的抽象值。
- en: Checking the Rep Invariant at Run Time
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在运行时检查表示不变性
- en: Many rep invariants can be translated straightforwardly into code.  If that's
    the case, do it!  Having an executable rep invariant, and using it at run time,
    not only helps find bugs in the code quickly; it also checks for mistakes in the
    rep invariant.  Sometimes the rep invariant you've written is *too* strong, making
    assumptions that are unwarranted and unnecessary.  Actually testing the invariant
    against running code is a good sanity check.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多表示不变性可以直接转换为代码。如果是这种情况，请这样做！拥有可执行的表示不变性，并在运行时使用它，不仅有助于快速发现代码中的错误；它还检查表示不变性中的错误。有时，您编写的表示不变性*过于*严格，做出了不合理和不必要的假设。实际上，针对运行代码测试不变量是一个很好的健全检查。
- en: 'The rep invariant checker can be coded as a method `checkRep` of no arguments
    that throws an exception if the rep invariant is violated, preferably with a message
    indicating which constraint was broken.  (However, a specification never mentions
    the representation invariant; from a client''s point of view, the method never
    has any effects.) Here''s an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不变性检查器可以编码为一个没有参数的方法`checkRep`，如果违反了表示不变性，则抛出异常，最好附带指示哪个约束被破坏的消息。 （但是，规范从不提及表示不变性；从客户端的角度看，该方法从未产生任何效果。）以下是一个示例：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The best place to put `checkRep` in your class is right after your fields. 
    You can either write your rep invariant as a separate comment, or intersperse
    the constraints of your rep invariant as exception messages in `checkRep` (as
    was done above).  The latter approach is probably better, because it makes it
    more likely that the comment will be kept current with the code in `checkRep`.
    Any part of the rep invariant that you can't write as executable code, just leave
    as a comment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中放置`checkRep`的最佳位置就在字段之后。您可以将您的表示不变性写成一个单独的注释，或者将表示不变性的约束插入`checkRep`中作为异常消息（如上所做）。后一种方法可能更好，因为这样更有可能使注释与`checkRep`中的代码保持同步。无法编写为可执行代码的表示不变性的任何部分，只需留下注释。
- en: 'Assertions provide an even cleaner way to write `checkRep`, because they handle
    the test and exception for you.  Here are two ways to do it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 断言提供了一种更干净的编写`checkRep`的方式，因为它们为您处理了测试和异常。以下是两种方法：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Calls to `checkRep` should be placed at the start and end of every public method,
    and at the end of every constructor.  Put a call to `checkRep` at the end of observers,
    even if you think they don't change the representation (since you may be wrong). 
    Private methods generally don't call `checkRep`, because private methods may be
    designed to be called while the rep is in an intermediate state that doesn't satisfy
    the rep invariant.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对`checkRep`的调用应放置在每个公共方法的开头和结尾，以及每个构造函数的结尾。即使您认为观察者不会改变表示，也应在观察者的结尾调用`checkRep`（因为您可能是错误的）。通常私有方法不调用`checkRep`，因为私有方法可能被设计为在不满足表示不变性的中间状态下调用��
- en: If part of the rep invariant is very expensive to check, you may want to turn
    that part off in the release version.  Otherwise it makes sense to leave it in. 
    Be careful how you judge performance here.  Novices are often much too ready to
    worry about performance improvements that turn out to be negligible.  Before dropping
    a check, you should have some evidence that it's expensive, such as an analysis
    with a profiler showing that indeed the check is a hotspot, or a theoretical argument,
    for example that the check turns a constant time operation into a linear time
    one.  Checking fields against `null` is always a constant time operation; there's
    no reason to drop this check except in absolutely performance-critical code. 
    Summing all the transactions in an account is linear in the number of transactions,
    which you might not want to do for every method call in production code.  But
    even expensive `checkRep`s are usually justified during testing and debugging;
    they'll more than pay for themselves in reduced debugging time unless they make
    executions not complete in any reasonable amount of time (e.g., days or centuries).
    An easy way to enable/disable the `checkRep` invocation is to add a static boolean
    variable named `debug` to the class, and either check that variable within `checkRep`
    or write calls like `if (debug) checkRep();`. Then, you can disable all the debugging
    checks by just changing the variable's value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表示不变式的一部分非常昂贵，你可能希望在发布版本中关闭该部分。否则最好保留它。在这里要谨慎评估性能。新手往往过于担心性能改进，结果却微不足道。在放弃检查之前，你应该有一些证据表明它是昂贵的，比如使用分析工具显示该检查确实是一个热点，或者理论上的论证，例如该检查将一个常数时间操作变成一个线性时间操作。检查字段是否为
    `null` 总是一个常数时间操作；除非在绝对关键的性能代码中，否则没有理由放弃这个检查。对账户中所有交易进行求和与交易数量成正比，你可能不希望在生产代码中的每个方法调用中都这样做。但即使昂贵的
    `checkRep` 在测试和调试期间通常是合理的；它们将在减少调试时间方面超额回报，除非它们使执行在任何合理的时间内无法完成（例如，几天或几个世纪）。启用/禁用
    `checkRep` 调用的简单方法是向类添加一个名为 `debug` 的静态布尔变量，并在 `checkRep` 中检查该变量，或编写类似 `if (debug)
    checkRep();` 的调用。然后，你可以通过更改变量的值来禁用所有调试检查。
- en: 'The `checkRep` method can also be made public, so that unit tests can call
    it during testing. `checkRep` is normally private, since the representation is
    not part of the specification; clients aren''t supposed to be aware that there''s
    a rep under the covers that might be broken. (Horrors!) But it doesn''t expose
    the rep if you make it public. If your class is working properly, then from the
    client''s point of view, `checkRep` is just a no-op: it changes nothing and never
    throws an exception. If you make `checkRep` public, you should probably specify
    it that way, so that clients don''t bother calling it unless they''re paranoid:
    "This operation does nothing unless there''s a bug, in which case it (sometimes)
    throws an exception." Needless to say, don''t put the rep invariant itself in
    the spec for `checkRep`. That''s representation-dependent.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkRep` 方法也可以设为公共的，这样单元测试在测试时可以调用它。`checkRep` 通常是私有的，因为表示不是规范的一部分；客户端不应该知道底层可能存在破损的表示。
    （可怕！）但是如果将其设为公共的，它并不会暴露表示。如果你的类正常工作，那么从客户端的角度来看，`checkRep` 只是一个空操作：它不会改变任何东西，也不会抛出异常。如果将
    `checkRep` 设为公共的，你可能应该这样指定，以便客户端不会在不必要的情况下调用它： "此操作除非存在错误，否则不执行任何操作，并且（有时）会抛出异常。"
    不用说，不要将表示不变式本身放在 `checkRep` 的规范中。这是依赖于表示的。'
- en: What Not to Write in the Rep Invariant
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在表示不变式中写什么
- en: Your rep invariant does not have to mention facts that are impossible in the
    rep. You are allowed to rely on the guarantees of the ADTs in your concrete fields.
    For example, if one of your concrete fields is an `int`, your rep invariant shouldn't
    mention that its value is less than or equal to `Integer.MAX_VALUE` or that it
    is not `null`. Likewise, if one of your concrete fields is a set, your rep invariant
    needn't mention that it contains no duplicates.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你的表示不变式不必提及在表示中不可能的事实。你可以依赖于具体字段中 ADT 的保证。例如，如果你的一个具体字段是一个 `int`，那么你的表示不变式不应该提及其值小于或等于
    `Integer.MAX_VALUE` 或不为 `null`。同样，如果你的一个具体字段是一个集合，那么你的表示不变式不需要提及它不包含重复项。
- en: This is similar to the way that a method precondition does not need to mention
    properties that are guaranteed by the ADTs of the formal parameters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于方法前置条件不需要提及由形式参数的 ADT 保证的属性。
- en: The rep invariant should be expressible as a `checkRep` method. Don't write
    anything in the rep invariant that cannot be checked by just examining the concrete
    representation. Checking the rep invariant should not require any knowledge of
    what the representation means nor of what operations were performed to create
    the representation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不变性应该可以表达为`checkRep`方法。不要在表示不变性中写任何不能通过仅检查具体表示来检查的内容。检查表示不变性不应该需要任何关于表示意义或创建表示所执行的操作的知识。
- en: Abstraction Functions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象函数
- en: An abstraction function AF maps the concrete representation of an abstract data
    type to the abstract value that the ADT represents.  Formally,
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个抽象函数AF将抽象数据类型的具体表示映射到ADT表示的抽象值。形式上，
- en: 'AF: *R* ? *A*'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'AF: *R* ? *A*'
- en: 'where R is the set of rep (representation) values, and A is the set of abstract
    values.  You can think of an element in *R* as the Java object.  *A*, on the other
    hand, exists only in our imagination, and has no existence inside the computer. 
    For example, if this is the ADT:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其中R是rep（表示）值的集合，A是抽象值的集合。你可以将*R*中的元素看作Java对象。另一方面，*A*只存在于我们的想象中，在计算机内部并不存在。例如，如果这是ADT：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: then the rep space *R* is the set of `Complex` objects, and the abstract space
    *A* is the set of complex numbers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，表示空间*R*是`Complex`对象的集合，抽象空间*A*是复数的集合。
- en: Where Are R and A Defined?
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R和A在哪里定义？
- en: 'The rep space *R* is obvious: it''s defined by the fields you put in your class. 
    You can''t possibly implement an abstract data type without fields, so you''ll
    never forget this.  The abstract value space *A*, however, is not represented
    in code.  It should be documented in your class overview (see [Abstract State](specifications.html#AbstractValuesAndAbstractState)),
    because both clients and implementors want to know what abstract type the class
    represents:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表示空间*R*是显而易见的：它由你在类中放置的字段定义。你不可能实现一个抽象数据类型而没有字段，所以你永远不会忘记这一点。然而，抽象值空间*A*在代码中没有表示。它应该在你的类概述中记录（参见[抽象状态](specifications.html#AbstractValuesAndAbstractState)），因为客户端和实现者都想知道类代表什么抽象类型：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whether the type is mutable or immutable is a crucial property that should be
    mentioned in the class overview.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是可变的还是不可变的是一个关键属性，应该在类概述中提到。
- en: AF(r)
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AF(r)
- en: 'Technically, an abstraction function is a *function*.  This is why you may
    see it written using functional notation, AF(r):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，抽象函数是一个*函数*。这就是为什么你可能会看到它使用函数符号AF(r)写成这样的原因：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The *r* in AF(r) represents an element in the rep space.  In other words, it's
    a reference to a `Complex` object.  So we can refer to fields of the object *r*
    on the right-hand side of the abstraction function.  (Incidentally, *r* stands
    for *representation*.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: AF(r)中的*r*代表表示空间中的一个元素。换句话说，它是对`Complex`对象的引用。因此，我们可以在抽象函数的右侧引用对象*r*的字段。（顺便说一句，*r*代表*representation*。）
- en: 'The functional notation is essential when the abstraction function is recursive,
    since we need some way to refer to it on the right-hand side:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当抽象函数是递归的时，函数符号是必不可少的，因为我们需要一种方式在右侧引用它：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (The square brackets and colons are [sequence construction syntax](specifications.html#MAV).)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (方括号和冒号是[序列构造语法](specifications.html#MAV)。)
- en: 'However, usually the abstraction function isn''t recursively defined.  Then
    it''s more readable just to write the right-hand side.  We further assume that
    the rep object *r* represents `this`, and adopt the convention of dropping references
    to `this` when writing the abstraction function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常抽象函数并不是递归定义的。这时，只需写右侧更易读。我们进一步假设表示对象*r*代表`this`，并采用在写抽象函数时省略对`this`的引用的约定：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is simple and clear, but remember that it's just shorthand for AF(r).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单明了，但请记住这只是AF(r)的简写。
- en: 'For ADTs with trivial reps, the spec fields may correspond one-to-one with
    rep fields:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有平凡表示的ADT，规范字段可能与表示字段一一对应：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But this abstraction function is hardly worth writing down.  Here''s a more
    interesting rep for the same ADT:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个抽象函数几乎不值得写下来。这里有一个相同ADT的更有趣的表示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `x` and `y` are spec fields of the `Point` type.  It was convenient
    to define the point `end` in terms of its spec fields as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`x`和`y`是`Point`类型的规范字段。方便起见，也可以根据其规范字段定义点`end`。
- en: 'Let''s simplify this with some more shorthand.  We''ll drop the AF(r), as we
    did earlier.  We''ll assume that the rep value *r* and the abstract value *l*
    both represent `this` — just different aspects of `this` — and adopt the convention
    of dropping references to `this`.  The effect of all this shorthand is just a
    list of equations defining each spec field in terms of the concrete fields:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用更多的简写来简化这个过程。我们将放弃AF(r)，就像我们之前做的那样。我们假设rep值*r*和抽象值*l*都代表`this` — 只是`this`的不同方面
    — 并采用省略引用`this`的约定。所有这些简写的效果只是一个方程列表，用具体字段定义每个规范字段：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Keep in mind that on the left-hand side, `start` refers to a spec field; on
    the right-hand side, `start` refers to a concrete field.  (`x` and `y` *always*
    refer to spec fields here, because the rep of the `Point` type isn't visible to
    us.)  Isn't there a danger of confusion between the two `starts`?  Not really.
    We gave the spec field and the concrete field the same name for good reason —
    because they are equated by the abstraction function. Do we really have to say
    `start=start` explicitly in the abstraction function?  Probably not. If the spec
    field `start` and the rep field `start` weren't equated by the abstraction function,
    then we should have given them different names.  Remember that your goal in these
    kinds of specifications is not formal communication with a machine, but clear
    and unambiguous communication with other human beings (Not only the author(s)!).
      Names matter.   Sometimes abbreviations help, and sometimes they do not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在左侧，`start`指的是规范字段；在右侧，`start`指的是具体字段。（在这里，`x`和`y`总是指规范字段，因为`Point`类型的表示对我们不可见。）两个`start`之间是否存在混淆的危险？实际上并没有。我们以很好的原因给规范字段和具体字段相同的名称
    — 因为它们被抽象函数等同。我们真的需要在抽象函数中明确写出`start=start`吗？可能不需要。如果规范字段`start`和rep字段`start`不是由抽象函数等同的，那么我们应该给它们不同的名称。请记住，在这些规范中，您的目标不是与机器进行正式通信，而是与其他人进行清晰和明确的沟通（不仅仅是作者！）。名称很重要。有时缩写有帮助，有时没有。
- en: 'Here''s another example.  Suppose we want to represent a `Card` data type,
    in a poker game, using a single integer in a field `index`.  We might have two
    specification fields, `suit` and `value`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子。假设我们想要使用单个整数在一个`index`字段中表示扑克游戏中的`Card`数据类型。我们可能有两个规范字段，`suit`和`value`：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The abstraction function then describes how to peel apart the `index` field
    into a suit and a value:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后抽象函数描述如何将`index`字段分解为花色和值：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This abstraction function maps each representation object to a pair `(suit,value)`,
    but rather than writing it as a single function, we've specified it as two separate
    ones, one for each specification.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象函数将每个表示对象映射到一个`(suit,value)`对，但我们没有将其写成一个单独的函数，而是分别为每个规范指定了两个函数。
- en: '(Two incidental points: you may wonder why Ace is V(1) instead of V(0).  This
    was done to make the abstraction function more direct on the numbered cards, so
    that V(*i*) = *i* for 2 through 10.  But it may not be ideal; since King is V(0),
    we can''t compare cards by comparing the `index` field directly.  Second, this
    representation of `Card` is tightly coupled to the set of suits and the set of
    values.  If we expect those types to change in the future, e.g., adding or removing
    suits, then we would have to change the representation of `Card`.  For some applications,
    however, the compactness of the representation may be worth the disadvantages
    of greater coupling.)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: （两个次要的观点：您可能会想知道为什么Ace是V(1)而不是V(0)。这是为了使抽象函数在编号卡上更直接，以便V(*i*) = *i*对于2到10。但这可能不是理想的；因为King是V(0)，我们不能通过直接比较`index`字段来比较卡片。其次，这种对`Card`的表示与花色集和值集紧密耦合。如果我们预计这些类型在未来会发生变化，例如添加或删除花色，那么我们将不得不更改`Card`的表示。然而，对于某些应用程序，表示的紧凑性可能值得更大耦合的缺点。）
- en: 'Example 1: Card'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1：卡片
- en: Here's a complete example of a simple class with an abstraction function and
    a rep invariant, so you can see one way you might structure your code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有抽象函数和rep不变性的简单类的完整示例，这样您可以看到您可能如何构造您的代码的一种方式。
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `checkRep()` calls in all the observers are probably unnecessary in this
    case, since the class is simple, immutable, and clearly has no rep exposure. 
    They're included anyway to illustrate what you would want to do in a more complex
    class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有观察者中的`checkRep()`调用可能是不必要的，因为该类简单、不可变，并且明显没有暴露表示。它们仍然包含在内，以说明在更复杂的类中您可能想要做的事情。
- en: 'Example 2: Stack'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 2：堆栈
- en: Suppose we wanted to implement a Stack ADT with an array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用数组实现一个堆栈ADT。
- en: The Representation Invariant
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示不变
- en: 'Here are some possible representation invariants:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能的表示不变：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One can imagine a slight change if the RI was for a SortedStack:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 RI 是针对 SortedStack 的，则可以想象稍作修改：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, our RI is distinguishing limitations on the internal state of
    our ADT.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 RI 正是区分 ADT 内部状态限制的。
- en: '**The purpose of the RI: to define valid and invalid internal states for this
    ADT object** (a SortedStack should always be sorted and never contain a null value).
    The `checkRep()` method should mirror the RI.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: RI（Rep Invariant）的目的是定义此 ADT 对象的有效和无效内部状态（SortedStack 应始终排序且不包含空值）。`checkRep()`
    方法应该与 RI 保持一致。
- en: The Abstraction Function
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象函数
- en: Here are some example AFs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例 AF（Abstraction Functions）。
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that the signature and fields of both examples are identical, but each
    abstraction function suggests different implementations with dramatically different
    run-time performance. (If its unclear why the run-time performance is different,
    think about what needs to happen to the elements in each implementation's array
    when pushing and popping from the stack.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个示例的签名和字段是相同的，但是每个抽象函数都暗示了具有截然不同运行时性能的不同实现。（如果不清楚运行时性能为何不同，请考虑在推送和弹出堆栈时需要对每个实现的数组中的元素执行什么操作。）
- en: Subclasses
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类
- en: Abstraction functions and representation invariants are implementation-specific.
    Therefore, it does not make sense to inherit them from a superclass. When you
    write a subclass, you should define its abstraction function and representation
    invariant from scratch and write it out in full.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象函数和表示不变是特定于实现的。因此，从超类继承它们是没有意义的。当你编写子类时，应该从头开始定义其抽象函数和表示不变，并将其完整写出。
- en: General Hints on Readability
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于可读性的一般提示
- en: Remember that the reader of your specifications, abstraction functions, and
    rep invariants is most likely going to be a *human being,* not a program.   It
    might be a teammate trying to find a bug in the code; a maintainer charged with
    updating the software after you've left the company; or even yourself, six months
    (or days!) later, trying to remember how this program worked.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，阅读你的规范、抽象函数和表示不变的人很可能是*人类*，而不是程序。可能是一位队友试图找到代码中的错误；一个负责在你离开公司后更新软件的维护人员；甚至是你自己，六个月（或者几天！）后，试图记住这个程序是如何工作的。
- en: 'So formal syntactic correctness is actually *less* important than simplicity
    and clarity.  That doesn''t mean you should sacrifice semantic precision, or leave
    things ambiguous or undefined.  But it does mean that you should think twice about
    writing something like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正式的语法正确性实际上比简洁性和清晰性更不重要。这并不意味着你应该牺牲语义精确度，或者让事情变得模糊或未定义。但这确实意味着你应该三思而后再写像这样的东西：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A compiler might enjoy reading this (if the compiler were actually reading your
    abstraction function).  A human would stare at it and curse.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可能会喜欢阅读此内容（如果编译器实际上正在阅读您的抽象函数）。人类会盯着它看，然后诅咒。
- en: 'Here are some tips for making your abstraction functions and rep invariants
    more readable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使你的抽象函数和表示不变更可读的提示：
- en: 'Introduce new names where they''re useful:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有用处的地方引入新名称：
- en: '[PRE29]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use spec fields:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用规范字段：
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Provide examples:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供示例：
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Introduce new functions where they''re useful:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有用处的地方引入新函数：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use plain language wherever it''s unambiguous and clearer or more concise than
    formal syntax:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在明确且比正式语法更清晰或更简洁的地方使用通俗语言：
- en: '[PRE33]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Contrast this with the formal alternative:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与正式替代方案形成对比：
- en: '[PRE34]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
