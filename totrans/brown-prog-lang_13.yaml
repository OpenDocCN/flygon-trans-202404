- en: 13Functions as Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13函数作为数据
- en: '|     [13.1 A Little Calculus](#%28part._.A_.Little_.Calculus%29) |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [13.1 一点微积分](#%28part._.A_.Little_.Calculus%29) |'
- en: '|     [13.2 A Helpful Shorthand for Anonymous Functions](#%28part._lam-shorthand%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [13.2 匿名函数的一个有用简写](#%28part._lam-shorthand%29) |'
- en: '|     [13.3 Streams From Functions](#%28part._streams-from-funs%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [13.3 函数生成流](#%28part._streams-from-funs%29) |'
- en: '|     [13.4 Combining Forces: Streams of Derivatives](#%28part._d-dx-streams%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|     [13.4 合力：导数流](#%28part._d-dx-streams%29) |'
- en: It’s interesting to consider how expressive the little programming we’ve learned
    so far can be. To illustrate this, we’ll work through a few exercises of interesting
    concepts we can express using just functions as values. We’ll write two quite
    different things, then show how they converge nicely.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到到目前为止我们学到的少量编程可以有多具有表现力是很有趣的。为了说明这一点，我们将通过几个有趣的概念练习来展示，这些概念可以仅使用函数作为值来表达。我们将写两个非常不同的东西，然后展示它们如何很好地融合。
- en: 13.1A Little Calculus
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1一点微积分
- en: 'If you’ve studied the differential calculus, you’ve come across curious sytactic
    statements such as this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学过微分学，你可能遇到过这样的奇怪的句法陈述：
- en: \begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}
- en: 'Let’s unpack what this means: the \(d/dx\), the \(x^2\), and the \(2x\).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解开这句话的含义：\(d/dx\)，\(x^2\)和\(2x\)。
- en: 'First, let’s take on the two expressions; we’ll discuss one, and the discussion
    will cover the other as well. The correct response to “what does \(x^2\) mean?”
    is, of course, an error: it doesn’t mean anything, because \(x\) is an unbound
    identifier.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看这两个表达式；我们将讨论一个，而讨论也将涵盖另一个。对于“\(x^2\)是什么意思？”的正确回答当然是一个错误：它没有任何意义，因为\(x\)是一个未绑定的标识符。
- en: 'So what is it intended to mean? The intent, clearly, is to represent the function
    that squares its input, just as \(2x\) is meant to be the function that doubles
    its input. We have nicer ways of writing those:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它打算表示什么？显然，意图是代表将其输入平方的函数，就像\(2x\)意味着将其输入加倍的函数一样。我们有更好的写法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'and what we’re really trying to say is that the \(d/dx\) (whatever that is)
    of square is double.We’re assuming functions of arity one in the variable that
    is changing.So now let’s unpack \(d/dx\), starting with its type. As the above
    example illustrates, \(d/dx\) is really a function from functions to functions.
    That is, we can write its type as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们真正想说的是，平方的\(d/dx\)（不管那是什么）是双倍。我们假设在变化的变量中具有一元函数。现在让我们解开\(d/dx\)，从其类型开始。正如上面的例子所示，\(d/dx\)实际上是一个从函数到函数的函数。也就是说，我们可以将其类型写成如下形式：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (This type might explain why your calculus course never explained this operation
    this way—<wbr>though it’s not clear that obscuring its true meaning is any better
    for your understanding.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: （这种类型可能解释了为什么你的微积分课程从未以这种方式解释这个操作——尽管模糊其真正含义是否对你的理解更有益尚不清楚。）
- en: Let us now implement d-dx. We’ll implement numerical differentiation, though
    in principle we could also implement symbolic differentiation—<wbr>using rules
    you learned, e.g., given a polynomial, multiply by the exponent and reduce the
    exponent by one—<wbr>with a representation of expressions ([Representing Arithmetic](first-interp.html#%28part._dt-for-arith%29)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现d-dx。我们将实现数值微分，尽管原则上我们也可以实现符号微分——使用你学到的规则，例如，给定一个多项式，乘以指数并减少一个——使用表达式的表示（[表示算术](first-interp.html#%28part._dt-for-arith%29)）。
- en: 'In general, numeric differentiation of a function at a point yields the value
    of the derivative at that point. We have a handy formula for it: the derivative
    of \(f\) at \(x\) is'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，函数在某一点的数值微分产生该点处导数的值。我们有一个方便的公式：在\(x\)处的\(f\)的导数是
- en: \begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}
- en: 'as \(\epsilon\) goes to zero in the limit. For now we’ll give the infinitesimal
    a small but fixed value, and later [[Combining Forces: Streams of Derivatives](#%28part._d-dx-streams%29)]
    see how we can improve on this.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当\(\epsilon\)趋近于零时。现在我们将给予这个微小值一个小但固定的值，稍后[[合力：导数流](#%28part._d-dx-streams%29)]看看我们如何改进这一点。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s now try to translate the above formula into Pyret:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试将上述公式翻译成Pyret：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Do Now!
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在！
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the problem with the above definition?
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上述定义有什么问题？
- en: 'If you didn’t notice, Pyret will soon tell you: x isn’t bound. Indeed, what
    is x? It’s the point at which we’re trying to compute the numeric derivative.
    That is, d-dx needs to return not a number but a function (as the type indicates)
    that will consume this x:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sure enough, this definition now works. We can, for instance, test it as follows
    (note the use of num-floor to avoid numeric precision issues from making our tests
    appear to fail):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can return to the original example that launched this investigation:
    what the sloppy and mysterious notation of math is really trying to say is,'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: or, in the notation of [A Notation for Functions](predicting-growth.html#%28part._math-anon-functions%29),
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: \begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Pity math textbooks for not wanting to tell us the truth!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 13.2A Helpful Shorthand for Anonymous Functions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pyret offers a shorter syntax for writing anonymous functions. Though, stylistically,
    we generally avoid it so that our programs don’t become a jumble of special characters,
    sometimes it’s particularly convenient, as we will see below. This syntax is
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'where a is zero or more arguments and b is the body. For instance, we can write
    lam(x): x * x end as'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: where we can see the benefit of brevity. In particular, note that there is no
    need for end, because the braces take the place of showing where the expression
    begins and ends. Similarly, we could have written d-dx as
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: but many readers would say this makes the function harder to read, because the
    prominent lam makes clear that d-dx returns an (anonymous) function, whereas this
    syntax obscures it. Therefore, we will usually only use this shorthand syntax
    for “one-liners”.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 13.3Streams From Functions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'People typically think of a function as serving one purpose: to parameterize
    an expression. While that is both true and the most common use of a function,
    it does not justify having a function of no arguments, because that clearly parameterizes
    over nothing at all. Yet functions of no argument also have a use, because functions
    actually serve two purposes: to parameterize, and to suspend evaluation of the
    body until the function is applied. In fact, these two uses are orthogonal, in
    that one can employ one feature without the other. In [Sugaring Over Anonymity](Interpreting_Functions.html#%28part._let-desugar%29)
    we see one direction of this: parameterized functions that are used immediately,
    so that we employ only abstraction and not delay. Below, we will see the other:
    delay without abstraction.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the humble list. A list can be only finitely long. However,
    there are many lists (or sequences) in nature that have no natural upper bound:
    from mathematical objects (the sequence of natural numbers) to natural ones (the
    sequence of hits to a Web site). Rather than try to squeeze these unbounded lists
    into bounded ones, let’s look at how we might represent and program over these
    unbounded lists.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s write a program to compute the sequence of natural numbers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Do Now!
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this program have a problem?
  id: totrans-50
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While this represents our intent, it doesn’t work: running it—<wbr>e.g., nats-from(0)—<wbr>creates
    an infinite loop evaluating nats-from for every subsequent natural number. In
    other words, we want to write something very like the above, but that doesn’t
    recur until we want it to, i.e., on demand. In other words, we want the rest of
    the list to be lazy.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: This is where our insight into functions comes in. A function, as we have just
    noted, delays evaluation of its body until it is applied. Therefore, a function
    would, in principle, defer the invocation of nats-from(n + 1) until it’s needed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Except, this creates a type problem: the second argument to link needs to be
    a list, and cannot be a function. Indeed, because it must be a list, and every
    value that has been constructed must be finite, every list is finite and eventually
    terminates in empty. Therefore, we need a new data structure to represent the
    links in these lazy lists (also known as streams):<stream-type-def> ::='
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '|   data Stream<T>: |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '|     &#124; lz-link(h :: T, t :: ( -> Stream<T>)) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: 'where the annotation ( -> Stream<T>) means a function from no arguments (hence
    the lack of anything before ->), also known as a thunk. Note that the way we have
    defined streams they must be infinite, since we have provided no way to terminate
    them.Let’s construct the simplest example we can, a stream of constant values:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Pyret will actually complain about this definition. Note that the list equivalent
    of this also will not work:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'because ones is not defined at the point of definition, so when Pyret evaluates
    link(1, ones), it complains that ones is not defined. However, it is being overly
    conservative with our former definition: the use of ones is “under a lam”, and
    hence won’t be needed until after the definition of ones is done, at which point
    ones will be defined. We can indicate this to Pyret by using the keyword rec:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To understand more about recursive definitions, see [Recursive Functions](State__Change__and_More_Equality.html#%28part._rec-for-recursive%29).
    Note that in Pyret, every fun implicitly has a rec beneath it, which is why we
    can create recursive functions with aplomb.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Earlier we said that we can’t write
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we tried to write
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: instead? Does this work and, if so, what value is ones bound to? If it doesn’t
    work, does it fail to work for the same reason as the definition without the rec?
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Henceforth, we will use the shorthand [[A Helpful Shorthand for Anonymous Functions](#%28part._lam-shorthand%29)]
    instead. Therefore, we can rewrite the above definition as:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that {(): …} defines an anonymous function of no arguments. You can’t
    leave out the ()! If you do, Pyret will get confused about what your program means.Because
    functions are automatically recursive, when we write a function to create a stream,
    we don’t need to use rec. Consider this example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'with which we can define the natural numbers:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the definition of nats is not recursive itself—<wbr>the recursion
    is inside nats-from—<wbr>so we don’t need to use rec to define nats.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Earlier, we said that every list is finite and hence eventually terminates.
    How does this remark apply to streams, such as the definition of ones or nats
    above?
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The description of ones is still a finite one; it simply represents the potential
    for an infinite number of values. Note that:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: A similar reasoning doesn’t apply to lists because the rest of the list has
    already been constructed; in contrast, placing a function there creates the potential
    for a potentially unbounded amount of computation to still be forthcoming.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That said, even with streams, in any given computation, we will create only
    a finite prefix of the stream. However, we don’t have to prematurely decide how
    many; each client and use is welcome to extract less or more, as needed.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we’ve created multiple streams, but we still don’t have an easy way to
    “see” one. First we’ll define the traditional list-like selectors. Getting the
    first element works exactly as with lists:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In contrast, when trying to access the rest of the stream, all we get out of
    the data structure is a thunk. To access the actual rest, we need to force the
    thunk, which of course means applying it to no arguments:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is useful for examining individual values of the stream. It is also useful
    to extract a finite prefix of it (of a given size) as a (regular) list, which
    would be especially handy for testing. Let’s write that function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you pay close attention, you’ll find that this body is not defined by cases
    over the structure of the (stream) input—<wbr>instead, it’s defined by the cases
    of the definition of a natural number (zero or a successor). We’ll return to this
    below ([<lz-map2-def>](#%28elem._lz-map2-def%29)).Now that we have this, we can
    use it for testing. Note that usually we use our data to test our functions; here,
    we’re using this function to test our data:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The notation (_ + 1) defines a Pyret function of one argument that adds 1 to
    the given argument.Let’s define one more function: the equivalent of map over
    streams. For reasons that will soon become obvious, we’ll define a version that
    takes two lists and applies the first argument to them pointwise:<lz-map2-def>
    ::='
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '|   fun lz-map2<A, B, C>( |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '|       f :: (A, B -> C), |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '|       s1 :: Stream<A>, |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '|       s2 :: Stream<B>): |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '|     lz-link( |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '|       f(lz-first(s1), lz-first(s2)), |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '|       {(): lz-map2(f, lz-rest(s1), lz-rest(s2))}) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: 'Now we can see our earlier remark about the structure of the function driven
    home especially clearly. Whereas a traditional map over lists would have two cases,
    here we have only one case because the data definition ([<stream-type-def>](#%28elem._stream-type-def%29))
    has only one case! What is the consequence of this? In a traditional map, one
    case looks like the above, but the other case corresponds to the empty input,
    for which it produces the same output. Here, because the stream never terminates,
    mapping over it doesn’t either, and the structure of the function reflects this.This
    raises a much subtler problem: if the function’s body doesn’t have base- and inductive-cases,
    how can we perform an inductive proof over it? The short answer is we can’t: we
    must instead use [☛ coinduction](glossary.html#%28elem._glossary-coinduction%29).Why
    did I define lz-map2 instead of lz-map? Because it enables us to write the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: from which, of course, we can extract as many Fibonacci numbers as we want!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Exercise
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define the equivalent of map, filter, and fold for streams.
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Streams and, more generally, infinite data structures that unfold on demand
    are extremely valuable in programming. Consider, for instance, the possible moves
    in a game. In some games, this can be infinite; even if it is finite, for interesting
    games the combinatorics mean that the tree is too large to feasibly store in memory.
    Therefore, the programmer of the computer’s intelligence must unfold the game
    tree on demand. Programming it by using the encoding we have described above means
    the program describes the entire tree, lazily, and the tree unfolds automatically
    on demand, relieving the programmer of the burden of implementing such a strategy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In some languages, such as Haskell, lazy evaluation is built in by default.
    In such a language, there is no need to use thunks. However, lazy evaluation places
    other burdens on the language [REF].
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '13.4Combining Forces: Streams of Derivatives'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we defined d-dx, we set epsilon to an arbitrary, high value. We could instead
    think of epsilon as itself a stream that produces successively finer values; then,
    for instance, when the difference in the value of the derivative becomes small
    enough, we can decide we have a sufficient approximation to the derivative.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The first step is, therefore, to make epsilon some kind of parameter rather
    than a global constant. That leaves open what kind of parameter it should be (number
    or stream?) as well as when it should be supplied.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes most sense to consume this parameter after we have decided what function
    we want to differentiate and at what value we want its derivative; after all,
    the stream of epsilon values may depend on both. Thus, we get:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'with which we can return to our square example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that at this point we have simply redefined d-dx without any reference
    to streams: we have merely made a constant into a parameter.Now let’s define the
    stream of negative powers of ten:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: so that
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For concreteness, let’s pick an abscissa at which to compute the numeric derivative
    of square—<wbr>say 10:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了具体起见，让我们选择一个横坐标来计算平方的数值导数—比如说10：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Recall, from the types, that this is now a function of type (Number -> Number):
    given a value for epsilon, it computes the derivative using that value. We know,
    analytically, that the value of this derivative should be 20. We can now (lazily)
    map tenths to provide increasingly better approximations for epsilon and see what
    happens:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型中回想起，现在这是一个类型为(Number -> Number)的函数：给定一个epsilon的值，它使用该值计算导数。我们知道，从分析上来看，这个导数的值应该是20。我们现在可以（懒惰地）映射十分之一，以提供越来越好的epsilon近似值，并看看会发生什么：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Sure enough, the values we obtain are 20.1, 20.01, 20.001, and so on: progressively
    better numerical approximations to 20.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们得到的值是20.1、20.01、20.001等等：逐渐更好的对20的数值近似。
- en: Exercise
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the above program to take a tolerance, and draw as many values from the
    epsilon stream as necessary until the difference between successive approximations
    of the derivative fall within this tolerance.
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将上述程序扩展为接受一个容差，并绘制出从epsilon流中提取的值，直到连续近似值之间的差值落在此容差范围内为止。
