["```\n(: eval : TOY ENV -> VAL);; evaluates TOY expressions.(define (eval expr env)\u00a0 ;; convenient helper\u00a0 (: eval* : TOY -> VAL)\u00a0 (define (eval* expr) (eval expr env))\u00a0 (cases expr\u00a0 \u00a0 [(Num n)\u00a0  (RktV n)]\u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 [(Bind names exprs bound-body)\u00a0 \u00a0  (eval bound-body (extend names (map eval* exprs) env))]\u00a0 \u00a0 [(Fun names bound-body)\u00a0 \u00a0  (FunV names bound-body env)]\u00a0 \u00a0 [(Call fun-expr arg-exprs)\u00a0 \u00a0  (let ([fval (eval* fun-expr)]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [arg-vals (map eval* arg-exprs)])\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(PrimV proc) (proc arg-vals)]\u00a0 \u00a0 \u00a0 \u00a0  [(FunV names body fun-env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval body (extend names arg-vals fun-env))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"function call with a non-function: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]\u00a0 \u00a0 [(If cond-expr then-expr else-expr)\u00a0 \u00a0  (eval* (if (cases (eval* cond-expr)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [(RktV v) v] ; Racket value => use as boolean\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [else #t])\u00a0  ; other values are always true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 then-expr\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else-expr))]))\n```", "```\n(: eval : TOY -> ENV -> VAL) ;*** note the curried type;; evaluates TOY expressions.(define (eval expr)\u00a0 (lambda (env)\u00a0 \u00a0 ;; convenient helper\u00a0 \u00a0 (: eval* : TOY -> VAL)\u00a0 \u00a0 (define (eval* expr) ((eval expr) env))\u00a0 \u00a0 (cases expr\u00a0 \u00a0 \u00a0 [(Num n)\u00a0  (RktV n)]\u00a0 \u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 \u00a0 [(Bind names exprs bound-body)\u00a0 \u00a0 \u00a0  ((eval bound-body) (extend names (map eval* exprs) env))]\u00a0 \u00a0 \u00a0 [(Fun names bound-body)\u00a0 \u00a0 \u00a0  (FunV names bound-body env)]\u00a0 \u00a0 \u00a0 [(Call fun-expr arg-exprs)\u00a0 \u00a0 \u00a0  (let ([fval (eval* fun-expr)]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [arg-vals (map eval* arg-exprs)])\u00a0 \u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [(PrimV proc) (proc arg-vals)]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [(FunV names body fun-env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ((eval body) (extend names arg-vals fun-env))]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"function call with a non-function: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]\u00a0 \u00a0 \u00a0 [(If cond-expr then-expr else-expr)\u00a0 \u00a0 \u00a0  (eval* (if (cases (eval* cond-expr)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [(RktV v) v] ; Racket value => use as boolean\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [else #t])\u00a0  ; other values are always true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 then-expr\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else-expr))])))\n```", "```\n(: run : String -> Any);; evaluate a TOY program contained in a string(define (run str)\u00a0 (let ([result ((eval (parse str)) global-environment)])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(RktV v) v]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a bad value: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])))\n```", "```\n(: run : String -> Any);; evaluate a TOY program contained in a string(define (run str)\u00a0 (let* ([compiled (eval (parse str))]\u00a0 \u00a0 \u00a0 \u00a0  [result\u00a0  (compiled global-environment)])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(RktV v) v]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a bad value: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])))\n```", "```\n(: compile : TOY -> ENV -> VAL);; compiles TOY expressions to Racket functions.(define (compile expr)\u00a0 (lambda (env)\u00a0 \u00a0 (: compile* : TOY -> VAL)\u00a0 \u00a0 (define (compile* expr) ((compile expr) env))\u00a0 \u00a0 (cases expr\u00a0 \u00a0 \u00a0 [(Num n)\u00a0  (RktV n)]\u00a0 \u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 \u00a0 [(Bind names exprs bound-body)\u00a0 \u00a0 \u00a0  ((compile bound-body)\u00a0 \u00a0 \u00a0 \u00a0 (extend names (map compile* exprs) env))]\u00a0 \u00a0 \u00a0 [(Fun names bound-body)\u00a0 \u00a0 \u00a0  (FunV names bound-body env)]\u00a0 \u00a0 \u00a0 [(Call fun-expr arg-exprs)\u00a0 \u00a0 \u00a0  (let ([fval (compile* fun-expr)]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [arg-vals (map compile* arg-exprs)])\u00a0 \u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [(PrimV proc) (proc arg-vals)]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [(FunV names body fun-env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ((compile body) (extend names arg-vals fun-env))]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [else (error 'call ; this is *not* a compilation error\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"function call with a non-function: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]\u00a0 \u00a0 \u00a0 [(If cond-expr then-expr else-expr)\u00a0 \u00a0 \u00a0  (compile* (if (cases (compile* cond-expr)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [(RktV v) v] ; Racket value => use as boolean\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  [else #t])\u00a0  ; other values are always true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  then-expr\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  else-expr))])))(: run : String -> Any);; evaluate a TOY program contained in a string(define (run str)\u00a0 (let* ([compiled (compile (parse str))]\u00a0 \u00a0 \u00a0 \u00a0  [result\u00a0  (compiled global-environment)])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(RktV v) v]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a bad value: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])))\n```", "```\n#lang pl(: foo : Number Number -> Number)(define (foo x y)\u00a0 (* x y))(: bar : Number -> Number)(define (bar c)\u00a0 (: loop : Number Number -> Number)\u00a0 (define (loop n acc)\u00a0 \u00a0 (if (< 0 n)\u00a0 \u00a0 \u00a0 \u00a0 (loop (- n 1) (+ (foo c n) acc))\u00a0 \u00a0 \u00a0 \u00a0 acc))\u00a0 (loop 40000000 0))(time (bar 0))\n```", "```\n#lang pl(: foo : Number -> Number -> Number)(define (foo x)\u00a0 (lambda (y)\u00a0 \u00a0 (* x y)))(: bar : Number -> Number)(define (bar c)\u00a0 (: loop : Number Number -> Number)\u00a0 (define (loop n acc)\u00a0 \u00a0 (if (< 0 n)\u00a0 \u00a0 \u00a0 \u00a0 (loop (- n 1) (+ ((foo c) n) acc))\u00a0 \u00a0 \u00a0 \u00a0 acc))\u00a0 (loop 40000000 0))(time (bar 0))\n```", "```\n(: foo : Number -> Number -> Number)(define (foo x)\u00a0 (lambda (y)\u00a0 \u00a0 (cond [(= x 0) 0]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [(= x 1) y]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [(= x 2) (+ y y)] ; assume that this is faster\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [else (* x y)])))\n```", "```\n(: foo : Number -> Number -> Number)(define (foo x)\u00a0 (cond [(= x 0) (lambda (y) 0)]\u00a0 \u00a0 \u00a0 \u00a0 [(= x 1) (lambda (y) y)]\u00a0 \u00a0 \u00a0 \u00a0 [(= x 2) (lambda (y) (+ y y))]\u00a0 \u00a0 \u00a0 \u00a0 [else (lambda (y) (* x y))]))\n```", "```\n#lang pl(: foo : Number -> Number -> Number)(define (foo x)\u00a0 (cond [(= x 0) (lambda (y) 0)]\u00a0 \u00a0 \u00a0 \u00a0 [(= x 1) (lambda (y) y)]\u00a0 \u00a0 \u00a0 \u00a0 [(= x 2) (lambda (y) (+ y y))]\u00a0 \u00a0 \u00a0 \u00a0 [else (lambda (y) (* x y))]))(: bar : Number -> Number)(define (bar c)\u00a0 (define foo-c (foo c))\u00a0 (: loop : Number Number -> Number)\u00a0 (define (loop n acc)\u00a0 \u00a0 (if (< 0 n)\u00a0 \u00a0 \u00a0 \u00a0 (loop (- n 1) (+ (fooc n) acc))\u00a0 \u00a0 \u00a0 \u00a0 acc))\u00a0 (loop 40000000 0))(time (bar 0))\n```", "```\n(define (foo list)\u00a0 (map (lambda (n) (if ...something... E1 E2))\u00a0 \u00a0 \u00a0  list))-->(define (foo list)\u00a0 (map (if ...something...\u00a0 \u00a0 \u00a0 \u00a0  (lambda (n) E1)\u00a0 \u00a0 \u00a0 \u00a0  (lambda (n) E2))\u00a0 \u00a0 \u00a0  list))\n```"]