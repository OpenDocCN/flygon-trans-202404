- en: 'Chapter 5: Types in Depth'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex Types Using Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's Covered
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to start off this chapter by introducing TypeScript *interfaces*.
    This chapter examines interfaces in the context of JavaScript "data" objects and
    their fields/properties. As many of you know, interfaces play an over-sized role
    in many common design patterns (think SOLID^([1](#fn_1))). We will talk about
    interfaces in that context in Chapter 9\.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript provides other more advanced typing support that you may have come
    across in C# and Java. This chapter covers some of them, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '***A Note About Generics***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generics offer a very powerful data typing capability. They look and act a
    lot like generics in C# and are a very effective tool helping you adhere to the
    Don''t Repeat Yourself (DRY) principle. If you aren''t familiar with DRY, here''s
    one place you could start: [http://deviq.com/don-t-repeat-yourself/](http://deviq.com/don-t-repeat-yourself/)'
  prefs: []
  type: TYPE_NORMAL
- en: Although generics are part of the type system, the tend to go hand in hand with
    classes, so we'll hold off on describing them until chapter 10 after you've had
    a chance to read about and digest TypeScript classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enumerations: Attach a human-friendly label to a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unions: A variable can be a "number" or "string" or "MyBrandShinyNewObject"
    but not anything else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom types: Think classes but without a constructor. (If you don''t know
    about classes, don''t worry, you''ll learn a it about them in chapter 9).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces as Data Describers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declare a TypeScript interface like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That code defines a new interface called "myInterface". It's an empty interface,
    but nonetheless valid^([2](#fn_2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can now declare their type as being that interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Although there are some use cases for empty interfaces, you'll normally use
    them this way to describe complex objects. Let's consider a business scenario
    and implement a supporting data structure in plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your client owns a book store and you''re developing a simple app that lets
    your client''s customers view a listing of all available books. In JavaScript
    object terms, a "book" has these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genre (e.g. biography, history, sci-fi)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short Description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total Pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Condition (e.g. New, Great, OK, Not Great)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In pure JavaScript, we might model a book this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s simple enough. We have an object called "bookModel." The developer''s
    intent is pretty clear, although there''s actually plenty of room for improvement.
    If you want to re-use `bookModel` in pure JavaScript, you could clone it^([3](#fn_3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript, we can use interfaces to define a better shape and even self-document
    the model. Here is one way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want an actual book instance, we define it like this in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface shows three immediate advantages TypeScript provides over JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer's intent is much clearer. You can tell that TotalPages is meant
    to hold numeric values while the rest are meant to hold strings^([4](#fn_4)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot-on intellisense.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*It''s really a model*. It''s not a JavaScript variable masquerading as model.
    In fact, when you compile a TypeScript interface, it produces no JavaScript at
    all. Only the compiler knows about the interface. There is no run-time artifact.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s assume you agree that TypeScript conveys the the dev''s intent more
    clearly than the pure JS example^([5](#fn_5)). Here''s a short 40 second video
    showing VS Code intellisense at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/o_wxodLGT34](https://www.youtube.com/embed/o_wxodLGT34)'
  prefs: []
  type: TYPE_NORMAL
- en: '(Depending on you''re reading the book, that video may not appear. In that
    case, [click this link](https://www.youtube.com/watch?v=o_wxodLGT34&feature=youtu.be)
    or go directly to the YouTube video with this link: [https://youtu.be/o_wxodLGT34](https://youtu.be/o_wxodLGT34)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key takeaways from the video:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you define an interface, it becomes another candidate data type. Use it
    the same way as the built-in data types, such as string, boolean, number, etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you define a variable with an interface data type, you must usually include
    all of the interface fields. NOTE: As you''ll soon see, it''s possible to define
    optional interface components as well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's not enough to add all of the interface fields to the "aBook" variable.
    You must also add them with the correct type. In the video, I tried to assign
    a string value to "TotalPages" field but the IDE told me that was not allowed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactoring with Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interfaces give us even more meaningful information and it's particularly useful
    when we refactor our code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we need to change our book model. When we started, we didn't
    realize that many books have multiple authors. As a result, we need to refactor
    the model and make Author an array of strings, not just a scalar / single string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In pure JS, we don''t need to do anything special. We just start writing code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's a very simple change to make, but it's quite difficult to find all the
    places where you need to make the change. You mostly have to do a global search
    in your IDE to find instances of "Author" and refactor where you find them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/fNtcCTeMAhQ](https://www.youtube.com/embed/fNtcCTeMAhQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '(Depending on how you''re reading the book, you may not be able to see the
    video. In that case, [try clicking here](https://youtu.be/fNtcCTeMAhQ) or use
    the following URL in your favorite web browser: [https://youtu.be/fNtcCTeMAhQ](https://youtu.be/fNtcCTeMAhQ))'
  prefs: []
  type: TYPE_NORMAL
- en: When I changed Author from `string` to `string[]`, I invalidated every instance
    of every book model in the code. I can't run a successful build until I fix it.
    I still have a potentially tricky refactoring task on my hands - after all, I
    still need to fix every place in the code that references Author. However, the
    compiler won't let me miss any of those changes. That is powerful stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Objects and Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although `BookModel` is technically a complex object, it's not *very* complex.
    Let's spice things up and take another look at "Author." We've already refactored
    the model to account for multiple authors. Authors are normal people, just like
    the rest of us, and in the United States and elsewhere, they usually have both
    a first and last name. In addition, authors *love* feedback. To this end, we want
    the author's preferred email for feedback.
  prefs: []
  type: TYPE_NORMAL
- en: This next bit of code shows the new `AuthorModel` and refactors `BookModel`
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, TypeScript supports nested objects quite nicely.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using VSCode or Visual Studio, try copying in the above code. Hover
    your mouse over the Authors field in either Example 1 or Example 2 and then press
    F12\. This will bring you to the definition of the object. This is very handy
    when trying to understand the underlying definition of a given type/interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces - Mapping a REST Response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll wrap up the discussion on interfaces by reverse engineering a REST response.
    In this scenario, I''m making a call out to a SharePoint REST endpoint asking
    for a "user"^([6](#fn_6)). When I make the call, I get back a lot of information,
    starting with the HTTP wrapper around what I really want:'
  prefs: []
  type: TYPE_NORMAL
- en: '!["HTTP Wrapper"](RestInterface1.JPG "HTTP Wrapper")'
  prefs: []
  type: TYPE_IMG
- en: 'Figure: HTTP Wrapper'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP wrapper consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: config (complex object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data (complex object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: headers (complex object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: status (number)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: statusText (string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define an interface that matches that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example is a bit lazy - it''s not trying to model the data underlying
    `config` or `headers`. I''m waving my hands in their general direction by using
    "any." I certainly could model those objects but I''m going to focus on `data`
    instead. You''ll notice that "data" is missing from the interface. Lets link that
    in. But first we need to define an interface that models the data portion of the
    REST response. To start, I need to know what the REST response is giving me:'
  prefs: []
  type: TYPE_NORMAL
- en: '!["Data Portion of REST Response"](RestInterface2.JPG "Data Portion of REST
    Response")'
  prefs: []
  type: TYPE_IMG
- en: 'Figure: Data Portion of REST Response'
  prefs: []
  type: TYPE_NORMAL
- en: 'This interface maps things nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note the `odata.editLink` field in the response - if your object's name has
    otherwise invalid characters in it, you can still get and set its values when
    you reference it via its name this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to link them in. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `extends` keyword. I'm defining a new interface, `userProfileResponse`
    by *extending* the previously defined `httpResponse` interface. The new `userProfileResponse`
    interface contains all the fields and structure of both.
  prefs: []
  type: TYPE_NORMAL
- en: Here's another 40 second video that shows this visually.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/oK3MpqhrVOo](https://www.youtube.com/embed/oK3MpqhrVOo)'
  prefs: []
  type: TYPE_NORMAL
- en: '(Depending on how you''re reading the book, you may not see the video. In that
    case, try [clicking here](https://www.youtube.com/watch?v=oK3MpqhrVOo&feature=youtu.be)
    or go to YouTube directly in your web browser: [https://youtu.be/oK3MpqhrVOo](https://youtu.be/oK3MpqhrVOo).)'
  prefs: []
  type: TYPE_NORMAL
- en: The last dozen seconds of the video show you that the IDE understands the structure
    of the new `userProfileResponse` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript interfaces are a very useful feature of the language:'
  prefs: []
  type: TYPE_NORMAL
- en: They are very good at demonstrating the developer's intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDEs understand their structure and provide great intellisense support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are better at modeling content than pure JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to refactor one of your models, it's much more difficult to miss
    something since everywhere you use the interface breaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're not finished with interfaces - they also play a role with classes. That's
    where a significant amount of their pattern-implementation power comes from. Before
    we get to that, we'll cover off several other great typing features - enums, unions
    and custom types.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations and Union Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve covered primitive data types (numbers, boolean, etc.) and how
    you can model complex objects using these primitive types. You can, in fact, create
    deeply nested data models using interfaces themselves. TypeScript provides additional
    ways to describe data. We''ll look at two more of them: enumerations and unions.
    Note that TypeScript provides even more types such as intersection types, generics
    and type aliases. Some of these (e.g. intersections) cater to tools writers more
    than the casual audience I have in mind for this book. Generics, on the other
    hand, deserve their own chapter and work best with classes and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enumerations allow you to connect a string label to a numeric value. This is
    best shown via example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Use enumerations in your code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Many languages provide a similar enum syntax and if you've worked with one (like
    C# or Java) this all looks very familiar.
  prefs: []
  type: TYPE_NORMAL
- en: As with everywhere else in TypeScript, a good IDE supports enumerations with
    intellisense.
  prefs: []
  type: TYPE_NORMAL
- en: 'The snippet above example shows that you can match a text label with an arbitrary
    integer value. Sometimes, you don''t care about the value. You just want the convenience
    of a human-readable label to use in your code. In that case, you can define an
    initial value and the compiler will increment it for you behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Down, Left and Right are assigned the values 2, 3 and 4 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping labels, such as "FORBIDDEN" to a number value "403" constitutes the
    main use case for enums. Used this way, they allow you to express yourself more
    clearly in code. *You* may be fully aware that an http 403 is a "forbidden" message
    but other, newer developers may not.
  prefs: []
  type: TYPE_NORMAL
- en: Enums As Objects, Or Not
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike interfaces, the TypeScript compiler generates code for enums by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the TypeScript Code and the generated JS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the generated JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, TypeScript wraps the enum inside its own Immediately Invoked
    Function Expression (IIFE) and lives on as a code artifact. Most of the time,
    this isn''t useful. You can skip the code generation and instead declare the enum
    as `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer Const Enums
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You should normally prefer to use const enums. There are probably some good
    use cases for non-const enums but you almost certainly won't encounter them in
    your first weeks and months with the language, if at all. Const enums generate
    less code and that generated code is as easy to understand as the non-const generated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This is also in keeping with the broader "use const first" rule. If you can
    adopt that habit you'll be taking some early steps toward a more functional programming
    style and significantly reduce the risk of unanticipated side effects in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in more compact JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It even puts in some helpful comments describing the the meaning of "403" or
    "200" if you find yourself digging into the generated JS.
  prefs: []
  type: TYPE_NORMAL
- en: Union Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Union Types allow you to create a define a new entity that is comprised of
    multiple types or even values. Here''s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This bit of code defines a function, "move" that takes a single parameter, "inDirection."
    Intellisense ensures that you don't try to pass in an invalid direction, like
    "sideways." Here's a short video demonstrating that.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/lfAa1-b-sng](https://www.youtube.com/embed/lfAa1-b-sng)'
  prefs: []
  type: TYPE_NORMAL
- en: '(If you can''t see the video, try [clicking here](https://youtu.be/lfAa1-b-sng).
    Or, open your preferred web browser and go to it directly: [https://youtu.be/lfAa1-b-sng](https://youtu.be/lfAa1-b-sng))).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t a particularly great example since in cases like this, you would
    probably use an enumeration instead or split it out into five functions (moveLeft,
    moveRight, moveUp, moveDown and lower level "move" function). For a better use
    case, let''s consider legacy code. Let''s say you have built a library of JavaScript
    utility functions and you want to start using that library with a TypeScript project.
    Your library has a function, `calculateCollectionTotal`. This function takes in
    an array of objects and as long as they share a common field in common, "Total",
    it will add them all up and return the result. Here''s what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re converting this legacy code to TypeScript, The "correct" approach
    here is to refactor the code, starting with a look at your invoices, orders and
    picking slips objects. Find their common elements, define an interface or possibly
    an abstract base class^([7](#fn_7)). Restructure all the objects and update the
    overall code base. However, that''s a lot of work. Union types can help you right
    away without the need for so much refactoring. Here''s what it could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This bit of TypeScript does the same thing as its plain JS cousin. However,
    it adds in some type safety that your IDE's intellisense feature can use. It's
    also nicely self-documenting. With one look at the signature, it's plain to anyone
    that this function was designed to calculate totals on a specific set of objects
    and no other objects.
  prefs: []
  type: TYPE_NORMAL
- en: You'll read about a better way to accomplish this using generics but they would
    force you to make a bigger change to your code base.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following articles provide alternative and/or a deeper dive into the topics
    discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: This article plus video covers pretty much the same ground as I do with interfaces
    above, with but with a lot fewer words :). [http://tech.queryhome.com/153271/what-is-interface-in-typescript?utm_source=dlvr.it&utm_medium=twitter](http://tech.queryhome.com/153271/what-is-interface-in-typescript?utm_source=dlvr.it&utm_medium=twitter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A lengthy article that talks about using interfaces and unions to model data:
    [https://www.triplet.fi/blog/different-approaches-to-modeling-data-with-typescript/](https://www.triplet.fi/blog/different-approaches-to-modeling-data-with-typescript/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript 2.4 (which came out just as I was finished version 1.0 of this book)
    introduces string enums! You can read about them straight from Microsoft''s blog:
    [https://blogs.msdn.microsoft.com/typescript/2017/06/12/announcing-typescript-2-4-rc/](https://blogs.msdn.microsoft.com/typescript/2017/06/12/announcing-typescript-2-4-rc/).
    That blog is a very good source and you should keep an eye on it regularly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript provides more sophisticated support for enums. You are not limited
    to assigning integers and in fact, you can assign values that are computed at
    runtime. This is best explained by the TypeScript language handbook web site here:
    [https://www.typescriptlang.org/docs/handbook/enums.html](https://www.typescriptlang.org/docs/handbook/enums.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary and Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced interfaces for the first time in their capacity as data
    describers. Interfaces may be empty, they can describe a collection of primitive
    values (number, string, etc.). You can create one interface and extend it to another.
    They can represent nested objects, including deeply nested objects such as overly
    complex SharePoint JSON payloads.
  prefs: []
  type: TYPE_NORMAL
- en: You also read about enumerations and union types. Both of these help make programmer
    intent clear and help you avoid making mistakes in your code by ensuring that
    only certain types of values or objects can be passed into functions.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to pause from heady subjects and diverge into template strings next.
    It's a nice and simple subject before we get into classes.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¹. If you aren't familiar with this SOLID acronym, it's probably worth your
    time checking it out. [This scotch.io write-up is a good start](https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)
    ([https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design](https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)).
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '². Empty interfaces aren''t typically all that useful, but this article on
    binary searches in TypeScript provides one: [https://blog.hellojs.org/implement-binary-search-in-typescript-using-generics-with-useful-refactorings-a4bcda932d7](https://blog.hellojs.org/implement-binary-search-in-typescript-using-generics-with-useful-refactorings-a4bcda932d7).
    This one may be a little on the complex side given where we are in the book, but
    it''s worth coming back to once you finish. [↩](#reffn_2 "Jump back to footnote
    [2] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '³. There are a ridiculous number of ways to clone JavaScript objects. The approach
    I used in these examples comes from this clever blog post: [http://heyjavascript.com/4-creative-ways-to-clone-objects/](http://heyjavascript.com/4-creative-ways-to-clone-objects/)
    [↩](#reffn_3 "Jump back to footnote [3] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁴. It's pretty obvious that a property named "TotalPages" would be numeric.
    However, as this chapter progresses, you'll see how interface show developer intent
    when describing a less obvious properties. [↩](#reffn_4 "Jump back to footnote
    [4] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁵. If you don't agree, then I don't know what else I can tell you :). [↩](#reffn_5
    "Jump back to footnote [5] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁶. If you happen to know anything about SharePoint - I'm not retrieving an SPUser
    here, I'm retrieving an item from a custom list. [↩](#reffn_6 "Jump back to footnote
    [6] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁷. Abstract classes, along with interfaces, provide a solid basis for your SOLID
    programming efforts. The book covers abstract classes in chapter 9\. [↩](#reffn_7
    "Jump back to footnote [7] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
