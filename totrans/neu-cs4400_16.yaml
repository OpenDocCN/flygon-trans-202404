- en: Intro to Typed RacketTuesday, January 17th
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The plan:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Why Types?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Typed Racket?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Different about Typed Racket?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some Examples of Typed Racket for Course Programs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Who has used a (statically) typed language?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who has used a typed language that’s not Java?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed Racket will be both similar to and very different from anything you’ve
    seen before.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Why types?
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types help structure programs.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types provide enforced and mandatory documentation.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types help catch errors.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: –> They *will* help you. A *lot*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Structuring programs
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data definitions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Data-first
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure of your program is derived from the structure of your data.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have seen this in Fundamentals with the design recipe and with templates.
    In this class, we will see it extensively with type definitions and the (cases
    …) form. Types make this pervasive — we have to think about our data before our
    code.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A language for describing data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of having an informal language for describing types in contract lines,
    and a more formal description of predicates in a `define-type` form, we will have
    a single, unified language for both of these. Having such a language means that
    we get to be more precise and more expressive (since the typed language covers
    cases that you would otherwise dismiss with some hand waving, like “a function”).
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why Typed Racket?
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Racket is the language we all know, and it has the benefits that we discussed
    earlier. Mainly, it is an excellent language for experimenting with programming
    languages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Typed Racket allows us to take our Racket programs and typecheck them, so we
    get the benefits of a statically typed language.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types are an important programming language feature; Typed Racket will help
    us understand them.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Also: the development of Typed Racket is happening here in Northeastern, and
    will benefit from your feedback.]'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: How is Typed Racket different from Racket
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typed Racket will reject your program if there are type errors! This means that
    it does that at compile-time, *before* any code gets to run.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typed Racket files start like this:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'but we will use a variant of the Typed Racket language, which has a few additional
    constructs:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Typed Racket requires you to write the contracts on your functions.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Racket:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Typed Racket:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[In the real Typed Racket you can also have the type annotations appear inside
    the definition:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: but we will not use this form.]
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we’ve seen, Typed Racket uses types, not predicates, in `define-type`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: versus
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are other differences, but these will suffice for now.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: More interesting examples
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Typed Racket is designed to be a language that is friendly to the kind of programs
    that people write in Racket. For example, it has unions:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is not common in statically typed languages, which are usually limited
    to only *disjoint* unions. For example, in OCaml you’d write this definition:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And use it with an explicit constructor:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that in the Typed Racket case, the language keeps track of information
    that is gathered via predicates — which is why it knows that one `x` is a String,
    and the other is a Number.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed Racket has a concept of subtypes — which is also something that most statically
    typed languages lack. In fact, the fact that it has (arbitrary) unions means that
    it must have subtypes too, since a type is always a subtype of a union that contains
    this type.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another result of this feature is that there is an `Any` type that is the union
    of all other types. Note that you can always use this type since everything is
    in it — but it gives you the *least* information about a value. In other words,
    Typed Racket gives you a choice: *you* decide which type to use, one that is very
    restricted but has a lot of information about its values to a type that is very
    permissive but has almost no useful information. This is in contrast to other
    type system (HM systems) where there is always exactly one correct type.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate, consider the identity function:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You could use a type of `(: id : Integer -> Integer)` which is very restricted,
    but you know that the function always returns an integer value.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Or you can make it very permissive with a `(: id : Any -> Any)`, but then you
    know nothing about the result — in fact, `(+ 1 (id 2))` will throw a type error.
    It *does* return `2`, as expected, but the type checker doesn’t know the type
    of that `2`. If you wanted to use this type, you’d need to check that the result
    is a number, eg:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This means that for this particular function there is no good specific type
    that we can choose — but we can still create a polymorphic type:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: which allows any input type, and its output would be the same, preserving the
    same level of information that you had on its input.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another interesting thing to look at is the type of `error`: it’s a function
    that returns a type of `Nothing` — a type that is the same as an *empty* union:
    `(U)`. It’s a type that has no values in it — it fits `error` because it *is*
    a function that doesn’t return any value, in fact, it doesn’t return at all. In
    addition, it means that an `error` expression can be used anywhere you want because
    it is a subtype of anything at all.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `else` clause in a `cond` expression is almost always needed, for example:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: (and if you think that the type checker should know what this is doing, then
    how about
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: or
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: for the last test?)
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In some rare cases you will run into one limitation of Typed Racket: it is
    difficult (that is: a generic solution is not known at the moment) to do the right
    inference when polymorphic functions are passed around to higher-order functions.
    For example:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In such cases, we can use `inst` to *instantiate* a function with a polymorphic
    type to a given type — in this case, we can use it to make it treat `rest` as
    a function that is specific for numeric lists:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In other rare cases, Typed Racket will infer a type that is not suitable for
    us — there is another form, `ann`, that allows us to specify a certain type. Using
    this in the `call` example is more verbose:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在其他罕见情况下，Typed Racket会推断出一个对我们不合适的类型 — 还有另一种形式，`ann`，允许我们指定某种类型。在`call`示例中使用这个更冗长：
- en: '[PRE20]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, these are going to be rare and will be mentioned explicitly whenever
    they’re needed.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这些情况将会很少出现，并且在需要时会明确提到。
