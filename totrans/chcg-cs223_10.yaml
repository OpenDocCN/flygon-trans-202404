- en: Binomial Heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For simplicity, we'll continue to work with heaps of `Int`s. Our implementation
    ([`BinomialHeaps.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/BinomialHeaps.elm))
    exports the same type signatures as the previous implementations of min-heaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binomial Trees: Representation and Invariants'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Binomial trees* of rank `r` are defined inductively as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Node 0 n []` is a binomial tree of rank `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node r n ts` is a binomial tree of rank `r > 0` if `ts` is a list of `r` binomial
    trees with rank `r-1` through `0`, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binomial tree of rank `r` has *2^(`r`)* nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Linking
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A binomial tree of rank `r + 1` is formed by linking together two trees of rank
    `r`, making one the leftmost child of the other.
  prefs: []
  type: TYPE_NORMAL
- en: The `link` function below links two binomial trees, choosing to keep the smaller
    of the two elements at the root. Therefore, if `t1` and `t2` are both heap-ordered,
    then so is the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Binomial Heaps: Representation and Invariants'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A *binomial heap* is list of heap-ordered binomial trees, kept in strictly-increasing
    order of rank. A binomial heap containing *n* elements is represented using at
    most *O(log n)* binomial trees, analogous to the binary representation of *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Heap Interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `findMin` function searches for the smallest root among all of the binomial
    trees, taking *O(log n)* time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See Homework 3 for a way to implement `findMin` so that it runs in *O(1)* time,
    as for other heap implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inserting into a binomial heap requires pairwise `link`ing of `Trees` with equal
    rank. Think "sum" and "carry" bits as in arithmetic addition. This is analogous
    to arithmetic addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are *O(m)* recursive calls to `insertTree` (where *m* is the length of
    `ts`), each of which performs *O(1)* work (to `link` two trees). Thus, `insert`
    runs in *O(m) = O(log n)* time.
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To analyze the running time of `merge_`, let *m* be the total number of trees
    in both `ts1` and `ts2`. The first two cases run in *O(1)* time. Each recursive
    call to `merge_` decreases *m* by one (in the third and fourth cases) or two (in
    the fifth case). The cons operations in the third and fourth cases require *O(1)*
    work. In the fifth case, `link` requires *O(1)* time, `insertTree` requires *O(m)*
    time, and the recursive call to `merge_` requires *T(m-2)* time. There are *O(m)*
    recursive calls, each of which requires at most *O(m)* time. The result is a *O(m²)*
    running time, which is *O(log²(n))* where *n* is the total number of elements
    described in the two heaps being merged.
  prefs: []
  type: TYPE_NORMAL
- en: '[A more subtle analysis](http://stackoverflow.com/questions/11462626/should-melding-merging-of-binomial-heaps-be-done-in-one-pass-or-two),
    however, can be used to argue that the implementation of `merge_` runs in *O(log
    n)* time. The argument requires a more careful accounting of how many times `link`
    is called (which is the crux of both `insertTree` and `merge_`) based on the analogy
    between merging lists and adding two numbers in binary representation.'
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we will consider an alternative, one-pass definition (also
    drawn from [this post](http://stackoverflow.com/questions/11462626/should-melding-merging-of-binomial-heaps-be-done-in-one-pass-or-two))
    that is slightly easier to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let *T(m)* and *S(m)* be the running times of `merge''` and `merge_wc`, respectively,
    where *m* is an upper bound on the number of trees in both input lists combined.
    Consider each of the five cases of `merge''`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cases 1 and 2: *T(m)* = *O(1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cases 3 and 4: *T(m)* = *O(1)* + *T(m-1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case 5: *T(m)* = *O(1)* + *S(m-2)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider each of the six cases of `merge_wc`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cases 1 and 2: *S(m)* = *O(m)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case 3: *S(m)* = *O(1)* + *T(m)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cases 4, 5, and 6: *S(m)* = *O(1)* + *S(m-1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are at most *O(m)* mutually recursive calls between the two functions.
    The last call to `merge_wc` may take *O(m)* time, but all other calls take *O(1)*
    time. Thus, the worst-case running time for each of these two functions is *O(m)+O(m)
    = O(m)* time. That is, *O(log n)* time.
  prefs: []
  type: TYPE_NORMAL
- en: Deletion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finding (Revisited)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can reuse the `removeMinTree` helper function to reimplement `findMin`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Required
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Okasaki, Chapter 3.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
