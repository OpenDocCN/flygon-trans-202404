- en: Demand Paging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lecture Notes for CS 140
  prefs: []
  type: TYPE_NORMAL
- en: Spring 2014
  prefs: []
  type: TYPE_NORMAL
- en: John Ousterhout
  prefs: []
  type: TYPE_NORMAL
- en: 'Readings for this topic from *Operating Systems: Principles and Practice*:
    Chapter 9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Demand paging*: not all of a process''s virtual address space needs to be
    loaded in main memory at any given time. Each page can be either:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In memory (physical page frame)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On disk (*backing store*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Faults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens when a process references a page that is in the backing store?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For pages in the backing store, the present bit is cleared in the page table
    entries.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If present is not set, then a reference to the page causes a trap to the operating
    system.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These traps are called *page faults*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle a page fault, the operating system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finds a free page frame in memory
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads the page in from backing store to the page frame
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the page table entry, setting present
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resumes execution of the thread
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the OS figure out which page generated the fault?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'x86: hardware saves the virtual address that caused the fault (CR2 register)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On earlier machines OS got only address of faulting instruction, must simulate
    the instruction and try every address to find the one that generated the fault
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Restarting process execution after a page fault is tricky, since the fault may
    have occurred in the middle of an instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If instructions are idempotent, just restart the faulting instruction (hardware
    saves instruction address during page fault).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-idempotent instructions are more difficult to restart:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Without hardware support it may be impossible to resume a process safely after
    a page fault. Hardware must keep track of side effects:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Undo all side effects during a page fault?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Save info about side effects, use it to restart instruction "in the middle"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Fetching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the basic page fault mechanism is working, the OS has two scheduling decisions
    to make:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page fetching: when to bring pages into memory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page replacement: which pages to throw out of memory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overall goal: make physical memory look larger than it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Locality*: most programs spend most of their time using a small fraction of
    their code and data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in memory the information that is being used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep unused information on disk in *paging file* (also called backing store,
    or swap space)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideally: paging produces a memory system with the performance of main memory
    and the cost/capacity of disk!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most modern OSes use *demand fetching*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start process with no pages loaded, don't load a page into memory until it is
    referenced.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pages for a process divide into three groups:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read-only code pages: read from the executable file when needed.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initialized data pages: on first access, read from executable file. Once loaded,
    save to the paging file since contents may have changed.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uninitialized data pages: on first access, just clear memory to all zeros.
    When paging out, save to the paging file.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prefetching: try to predict when pages will be needed and load them ahead of
    time to avoid page faults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires predicting the future, so hard to do.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One approach: when taking a page fault, read many pages instead of just one
    (wins if program accesses memory sequentially).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Replacement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once all of memory is in use, will need to throw out one page each time there
    is a page fault.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Random: pick any page at random (works surprisingly well!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FIFO: throw out the page that has been in memory longest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MIN: The optimal algorithm requires us to predict the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Least Recently Used (LRU): use the past to predict the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing LRU: need hardware support to keep track of which pages have been
    used recently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perfect LRU?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a hardware register for each page, store system clock into that register
    on each memory reference.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To choose page for placement, scan through all pages to find the one with the
    oldest clock.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware costs prohibitive in the early days of paging; also, expensive to scan
    all pages during replacement.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No machines have actually implemented this.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Current computers settle for an approximation that is efficient. Just find an
    old page, not necessarily the oldest.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clock algorithm* (also called *second chance* algorithm): keep *reference
    bit* for each page frame, hardware sets the reference bit whenever a page is read
    or written. To choose page for placement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cycle through pages in order (circularly).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the next page has been referenced, then don't replace it; just clear the
    reference bit and continue to the next page.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the page has not been referenced since the last time we checked it, then
    replace that page.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dirty bit*: one bit for each page frame, set by hardware whenever the page
    is modified. If a dirty page is replaced, it must be written to disk before its
    page frame is reused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The clock algorithm typically gives additional preference to dirty pages. For
    example, if the reference bit for a page is clear, but the dirty bit is set, don't
    replace this page now, but clear the dirty bit and start writing the page to disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Free page pool: many systems keep a small list of clean pages that are available
    immediately for replacement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During replacement, take the page that has been in the free pool the longest,
    then run the replacement algorithm to add a new page to the free pool.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages in the free pool have their present bit off, so any references to those
    pages cause a page fault
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a page fault occurs for a page in the free pool, remove it from the free
    pool and put it back in service; much faster than reading from disk.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides an extra opportunity for recovery if we make a poor page replacement
    decision.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement page replacement when there are multiple processes running
    in the system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Global replacement*: all pages from all processes are lumped into a single
    replacement pool. Each process competes with all the other processes for page
    frames.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Per-process replacement*: each process has a separate pool of pages. A page
    fault in one process can only replace one of that process''s frames. This eliminates
    interference from other processes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unfortunately, per-process replacement creates a new scheduling dilemma: how
    many page frames to allocate to each process? If this decision is made incorrectly,
    it can result in inefficient memory usage.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Most systems use global replacement.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
