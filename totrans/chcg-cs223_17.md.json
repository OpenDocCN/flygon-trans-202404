["```\ntype Nat = Z | S Nat \n```", "```\nfromInt : Int -> Nat\nfromInt n =\n  if | n <= 0    -> Z\n     | otherwise -> S (fromInt (n-1)) \n```", "```\n> fromInt 0\nZ : Nat.Nat\n\n> fromInt 1\nS Z : Nat.Nat\n\n> fromInt 10\nS (S (S (S (S (S (S (S (S (S Z))))))))) : Nat.Nat\n\n> fromInt 10000\nRangeError: Maximum call stack size exceeded \n```", "```\nfromInt : Int -> Nat\nfromInt n =\n  let foo acc n =\n    if | n <= 0    -> Done acc\n       | otherwise -> Continue (\\_ -> foo (S acc) (n-1))\n  in trampoline (foo Z n)\n\ntoInt : Nat -> Int\ntoInt n =\n  let foo acc n = case n of\n    Z    -> Done acc\n    S n' -> Continue (\\_ -> foo (1 + acc) n')\n  in trampoline (foo 0 n) \n```", "```\n> fromInt 10000\nRangeError: Maximum call stack size exceeded \n```", "```\n> let _ = fromInt 10000 in ()\n() : () \n```", "```\nstrNat : Nat -> String\nstrNat n =\n  let foo acc n = case n of\n    Z    -> Done acc\n    S n' -> Continue (\\_ -> foo (\"S\" ++ acc) n')\n  in trampoline (foo \"Z\" n) \n```", "```\n> fromInt 10000 |> strNat\n\" ... SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSZ\" : String\n\n> fromInt 10000000 |> strNat\n\" ... SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSZ\" : String\n\n> fromInt 100000000 |> strNat\nFATAL ERROR: JS Allocation failed - process out of memory \n```", "```\nplus : Nat -> Nat -> Nat\nplus x y =\n  let foo acc n = case n of\n    Z    -> Done acc\n    S n' -> Continue (\\_ -> foo (S acc) n')\n  in trampoline (foo x y) \n```", "```\n> plus (fromInt 0) (fromInt 0) |> strNat\n\"Z\" : String\n\n> plus (fromInt 0) (fromInt 2) |> strNat\n\"SSZ\" : String\n\n> plus (fromInt 10) (fromInt 2) |> strNat\n\"SSSSSSSSSSSSZ\" : String\n\n> plus (fromInt 10) (fromInt 2) |> toInt\n12 : Int \n```", "```\neqNat : Nat -> Nat -> Bool\neqNat x y =\n  let foo x y = case (x, y) of\n    (Z, Z)       -> Done True\n    (S x', S y') -> Continue (\\() -> foo x' y')\n    _            -> Done False\n  in trampoline (foo x y) \n```", "```\n> eqNat (fromInt 0) (fromInt 0)\nTrue : Bool\n\n> eqNat (fromInt 0) (fromInt 2)\nFalse : Bool\n\n> eqNat (fromInt 10) (fromInt 2)\nFalse : Bool \n```", "```\n> eqNat (fromInt 10000) (fromInt 10000000)\nFalse : Bool\n\n> eqNat (fromInt 0) (fromInt 10000000)\nFalse : Bool \n```", "```\ntype Nat = Z | S (Thunk Nat)\n\ntype alias Thunk a = () -> a\n\nforce : Thunk a -> a\nforce thunk = thunk () \n```", "```\ndelay : a -> Thunk a\ndelay e = \\() -> e \n```", "```\nfromInt n =\n  if | n <= 0    -> Z\n     | otherwise -> S (\\_ -> fromInt (n-1)) \n```", "```\n> import Nat as N\n> import ThunkNat (..)\n\n> N.fromInt 10\nS (S (S (S (S (S (S (S (S (S Z))))))))) : Nat.Nat\n\n> fromInt 10\nS <function> : ThunkNat.Nat \n```", "```\ntoInt n =\n  let foo acc n = case n of\n    Z    -> Done acc\n    S n' -> Continue (\\_ -> foo (1 + acc) (force n'))\n  in trampoline (foo 0 n) \n```", "```\n> fromInt 100000000 |> toInt\n100000000 : Int \n```", "```\n> fromInt 100000000 |> toInt\n100000000 : Int \n```", "```\nstrNat n =\n  let foo acc n = case n of\n    Z    -> Done acc\n    S n' -> Continue (\\_ -> foo (\"S\" ++ acc) (force n'))\n  in trampoline (foo \"Z\" n) \n```", "```\n> fromInt 10000\nS <function> : ThunkNat.Nat\n\n> fromInt 10000 |> strNat\n\" ... SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSZ\" : String \n```", "```\neqNat x y =\n  let foo x y = case (x, y) of\n    (Z, Z)       -> Done True\n    (S x', S y') -> Continue (\\_ -> foo (force x') (force y'))\n    (_, _)       -> Done False\n  in trampoline (foo x y) \n```", "```\n> fromInt 0 `eqNat` fromInt 0\nTrue : Bool\n\n> fromInt 0 `eqNat` fromInt 2\nFalse : Bool\n\n> fromInt 10 `eqNat` fromInt 2\nFalse : Bool\n\n> fromInt 10000 `eqNat` fromInt 10000000\nFalse : Bool\n\n> fromInt 0 `eqNat` fromInt 10000000\nFalse : Bool \n```", "```\nplus x y = case y of\n  Z    -> x\n  S y' -> S (\\_ -> plus x (force y')) \n```", "```\n> fromInt 0 `eqNat` (fromInt 10000000 `plus` fromInt 10000000)\nFalse : Bool \n```", "```\n> fromInt 0 == fromInt 0\nTrue : Bool\n\n> fromInt 0 == fromInt 1\nFalse : Bool\n\n> fromInt 1 == fromInt 2\nError: Equality error: general function equality is undecidable,\nand therefore, unsupported \n```", "```\n> fromInt 1 == fromInt 1\nError: Equality error: general function equality is undecidable,\nand therefore, unsupported\n\n> let foo = fromInt 1 in foo == foo\nTrue : Bool \n```", "```\nlazy  : (_Tuple0 -> a) -> Lazy a\nforce : Lazy a -> a \n```", "```\ntype Nat = Z | S (Lazy Nat) \n```", "```\n> import LazyNat (..)\n\n> foo i = fromInt i `eqNat` fromInt i\n<function> : Int -> Bool\n\n> foo 100000\nTrue : Bool\n\n> foo 1000000\nTrue : Bool \n```", "```\n> slow = lazy (\\_ -> foo 1000000)\nLazy <function> : Lazy.Lazy Bool\n\n> force slow\nTrue : Bool\n\n> force slow   -- still slow... :-(\nTrue : Bool \n```", "```\n> force slow\nTrue : Bool\n\n> (force slow, force slow, force slow, force slow, force slow)\n(True,True,True,True,True) : ( Bool, Bool, Bool, Bool, Bool ) \n```", "```\ntype LazyList a\n  = Nil\n  | Cons (Lazy a) (LazyList a) \n```", "```\n> range 1 10\nCons (Lazy <function>)\n (Cons (Lazy <function>)\n  (Cons (Lazy <function>)\n   (Cons (Lazy <function>)\n    (Cons (Lazy <function>)\n     (Cons (Lazy <function>)\n      (Cons (Lazy <function>)\n       (Cons (Lazy <function>)\n        (Cons (Lazy <function>)\n         (Cons (Lazy <function>) Nil)))))))))\n    : NotSoLazyList.LazyList Int \n```", "```\ntype LazyList a\n  = Nil\n  | Cons a (Lazy (LazyList a)) \n```", "```\n> range 1 10\nCons 1 (Lazy <function>) : PrettyLazyList.LazyList Int \n```", "```\ntype alias LazyList a = Lazy (LazyListCell a)\n\ntype LazyListCell a\n  = Nil\n  | Cons a (LazyList a) \n```", "```\nrange : Int -> Int -> LazyList Int\nrange i j =\n  if | i > j     -> lazy (\\_ -> Nil)\n     | otherwise -> lazy (\\_ -> Cons i (range (i+1) j)) \n```", "```\ninfinite : Int -> LazyList Int\ninfinite i = lazy (\\_ -> Cons i (infinite (i+1))) \n```", "```\ntake : Int -> LazyList a -> LazyList a\ntake k l = case (k, force l) of\n  (0, _)         -> lazy (\\_ -> Nil)\n  (_, Nil)       -> lazy (\\_ -> Nil)\n  (_, Cons x xs) -> lazy (\\_ -> Cons x (take (k-1) xs)) \n```", "```\ntake k l =\n  if | k == 0    -> lazy (\\_ -> Nil)\n     | otherwise ->\n         case force l of\n           Nil       -> lazy (\\_ -> Nil)\n           Cons x xs -> lazy (\\_ -> Cons x (take (k-1) xs)) \n```", "```\n> infinite 1\nLazy <function> : Lazy.Lazy (LazyList.LazyListCell Int)\n\n> infinite 1 |> take 10\nLazy <function> : Lazy.Lazy (LazyList.LazyListCell Int)\n\n> infinite 1 |> take 10 |> toList\n[1,2,3,4,5,6,7,8,9,10] : List Int \n```", "```\ntoList : LazyList a -> List a\ntoList l =\n  let foo acc l = case force l of\n    Nil       -> Done acc\n    Cons x xs -> Continue (\\_ -> foo (x::acc) xs)\n  in\n  List.reverse <| trampoline <| foo [] l \n```", "```\ndrop : Int -> LazyList a -> LazyList a\ndrop k l =\n  let foo k l =\n    if | k == 0 -> Done l\n       | otherwise ->\n           case force l of\n             Nil       -> Done (lazy (\\_ -> Nil))\n             Cons _ xs -> Continue (\\_ -> foo (k-1) xs)\n  in trampoline (foo k l) \n```", "```\n> infinite 1 |> drop 10 |> take 10 |> toList\n[11,12,13,14,15,16,17,18,19,20] : List Int \n```", "```\nappend : LazyList a -> LazyList a -> LazyList a\nappend xs ys = case force xs of\n  Nil        -> ys\n  Cons x xs' -> lazy (\\_ -> Cons x (append xs' ys)) \n```", "```\nreverse : LazyList a -> LazyList a\nreverse l =\n  let foo acc xs = case force xs of\n    Nil        -> Done acc\n    Cons x xs' -> Continue (\\_ -> foo (lazy (\\_ -> Cons x acc)) xs')\n  in trampoline (foo (lazy (\\_ -> Nil)) l) \n```", "```\neq : LazyList a -> LazyList a -> Bool\neq x y =\n  let foo x y = case (force x, force y) of\n    (Cons x xs, Cons y ys) ->\n      Continue (\\_ -> if x == y then foo xs ys else Done False)\n    (Nil, Nil) -> Done True\n    _          -> Done False\n  in\n  trampoline (foo x y) \n```", "```\n> [] == [1..10000000]\nFalse : Bool\n\n> [] == [1..100000000]\nFATAL ERROR: JS Allocation failed - process out of memory\n\n> import LazyList (..)\n> import Lazy (..)\n\n> range 1 0 `eq` range 1 1000000\nFalse : Bool\n\n> range 1 0 `eq` range 1 10000000\nFalse : Bool\n\n> range 1 0 `eq` range 1 1000000000000000\nFalse : Bool\n\n> range 1 0 `eq` infinite 1\nFalse : Bool \n```"]