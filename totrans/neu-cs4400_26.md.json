["```\n<FLANG> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { + <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { - <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { * <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { / <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { with { <id> <FLANG> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | <id>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { fun { <id> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { call <FLANG> <FLANG> }\n```", "```\n(define-type FLANG\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 FLANG FLANG]\u00a0 [Sub\u00a0 FLANG FLANG]\u00a0 [Mul\u00a0 FLANG FLANG]\u00a0 [Div\u00a0 FLANG FLANG]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol FLANG FLANG]\u00a0 [Fun\u00a0 Symbol\u00a0 \u00a0 \u00a0  FLANG] ; No named-expression\u00a0 [Call FLANG FLANG])\n```", "```\n(: parse-sexpr : Sexpr -> FLANG);; parses s-expressions into FLANGs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'fun more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'fun (list (symbol: name)) body)\u00a0 \u00a0 \u00a0 \u00a0 (Fun name (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `fun' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list 'call fun arg)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Call (parse-sexpr fun) (parse-sexpr arg))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))\n```", "```\nN[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = N{+ E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {+ E1[v/x] E2[v/x]}{- E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {- E1[v/x] E2[v/x]}{* E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {* E1[v/x] E2[v/x]}{/ E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {/ E1[v/x] E2[v/x]}y[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = yx[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = v{with {y E1} E2}[v/x] = {with {y E1[v/x]} E2[v/x]}{with {x E1} E2}[v/x] = {with {x E1[v/x]} E2}{call E1 E2}[v/x]\u00a0 \u00a0  = {call E1[v/x] E2[v/x]}{fun {y} E}[v/x]\u00a0 \u00a0 \u00a0 = {fun {y} E[v/x]}{fun {x} E}[v/x]\u00a0 \u00a0 \u00a0 = {fun {x} E}\n```", "```\n(: subst : FLANG Symbol FLANG -> FLANG);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst named-expr from to)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]\u00a0 \u00a0 [(Call l r) (Call (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Fun bound-id bound-body)\u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0  expr\u00a0 \u00a0 \u00a0  (Fun bound-id (subst bound-body from to)))]))\n```", "```\n{fun {x} {+ x 1}}\n```", "```\n(Add (Num 1) (Num 2))\n```", "```\n(Num 3)\n```", "```\neval(N)\u00a0 \u00a0 \u00a0 \u00a0  = Neval({+ E1 E2}) = eval(E1) + eval(E2)eval({- E1 E2}) = eval(E1) - eval(E2)eval({* E1 E2}) = eval(E1) * eval(E2)eval({/ E1 E2}) = eval(E1) / eval(E2)eval(id)\u00a0 \u00a0 \u00a0 \u00a0 = error!eval({with {x E1} E2}) = eval(E2[eval(E1)/x])eval(FUN)\u00a0 \u00a0 \u00a0  = FUN ; assuming FUN is a function expressioneval({call E1 E2})\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = eval(Ef[eval(E2)/x])\u00a0  if eval(E1) = {fun {x} Ef}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = error!\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  otherwise\n```", "```\neval({call E1 E2})\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = eval({with {x E2} Ef}) if eval(E1) = {fun {x} Ef}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = error!\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  otherwise\n```", "```\neval({with {x E1} E2}) = eval({call {fun {x} E2} E1})\n```", "```\neval({+ E1 E2}) = N1 + N2\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if eval(E1), eval(E2) evaluate to numbers N1, N2\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 otherwise error!...\n```", "```\n(: eval : FLANG -> FLANG)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ;*** note return type;; evaluates FLANG expressions by reducing them to *expressions*(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  ;*** change here\u00a0 \u00a0 [(Add l r) (arith-op + (eval l) (eval r))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l) (eval r))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l) (eval r))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l) (eval r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval named-expr)))]\u00a0 \u00a0 \u00a0 \u00a0  ;*** no `(Num ...)'\u00a0 \u00a0 [(Id name) (error 'eval \"free identifier: ~s\" name)]\u00a0 \u00a0 [(Fun bound-id bound-body) expr]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  ;*** similar to `Num'\u00a0 \u00a0 [(Call (Fun bound-id bound-body) arg-expr) ;*** nested pattern\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  ;*** just like `with'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval arg-expr)))]\u00a0 \u00a0 [(Call something arg-expr)\u00a0 \u00a0  (error 'eval \"`call' expects a function, got: ~s\" something)]))\n```", "```\n\u00a0 \u00a0 ...\u00a0 \u00a0 [(Call (Fun bound-id bound-body) arg-expr)\u00a0 \u00a0  (eval (With bound-id arg-expr bound-body))]\u00a0 \u00a0 ...\n```", "```\n(: arith-op : (Number Number -> Number) FLANG FLANG -> FLANG);; gets a Racket numeric binary operator, and uses it within a FLANG;; `Num' wrapper (note the H.O type)(define (arith-op op expr1 expr2)\u00a0 (Num (op (Num->number expr1) (Num->number expr2))))\n```", "```\n(: Num->number : FLANG -> Number);; convert a FLANG number to a Racket one(define (Num->number e)\u00a0 (cases e\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [else (error 'arith-op \"expected a number, got: ~s\" e)]))\n```", "```\n(: run : String -> Number);; evaluate a FLANG program contained in a string(define (run str)\u00a0 (let ([result (eval (parse str))])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a non-number: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])))\n```", "```\n;; The Flang interpreter#lang pl#|The grammar:\u00a0 <FLANG> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { + <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { - <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { * <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { / <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { with { <id> <FLANG> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | <id>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { fun { <id> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { call <FLANG> <FLANG> }Evaluation rules:\u00a0 subst:\u00a0 \u00a0 N[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = N\u00a0 \u00a0 {+ E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {+ E1[v/x] E2[v/x]}\u00a0 \u00a0 {- E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {- E1[v/x] E2[v/x]}\u00a0 \u00a0 {* E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {* E1[v/x] E2[v/x]}\u00a0 \u00a0 {/ E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {/ E1[v/x] E2[v/x]}\u00a0 \u00a0 y[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = y\u00a0 \u00a0 x[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = v\u00a0 \u00a0 {with {y E1} E2}[v/x] = {with {y E1[v/x]} E2[v/x]} ; if y =/= x\u00a0 \u00a0 {with {x E1} E2}[v/x] = {with {x E1[v/x]} E2}\u00a0 \u00a0 {call E1 E2}[v/x]\u00a0 \u00a0  = {call E1[v/x] E2[v/x]}\u00a0 \u00a0 {fun {y} E}[v/x]\u00a0 \u00a0 \u00a0 = {fun {y} E[v/x]}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  ; if y =/= x\u00a0 \u00a0 {fun {x} E}[v/x]\u00a0 \u00a0 \u00a0 = {fun {x} E}\u00a0 eval:\u00a0 \u00a0 eval(N)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = N\u00a0 \u00a0 eval({+ E1 E2})\u00a0 \u00a0 = eval(E1) + eval(E2)\u00a0 \\ if both E1 and E2\u00a0 \u00a0 eval({- E1 E2})\u00a0 \u00a0 = eval(E1) - eval(E2)\u00a0  \\ evaluate to numbers\u00a0 \u00a0 eval({* E1 E2})\u00a0 \u00a0 = eval(E1) * eval(E2)\u00a0  / otherwise error!\u00a0 \u00a0 eval({/ E1 E2})\u00a0 \u00a0 = eval(E1) / eval(E2)\u00a0 /\u00a0 \u00a0 eval(id)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  = error!\u00a0 \u00a0 eval({with {x E1} E2}) = eval(E2[eval(E1)/x])\u00a0 \u00a0 eval(FUN)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = FUN ; assuming FUN is a function expression\u00a0 \u00a0 eval({call E1 E2}) = eval(Ef[eval(E2)/x])\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if eval(E1)={fun {x} Ef}, otherwise error!|#(define-type FLANG\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 FLANG FLANG]\u00a0 [Sub\u00a0 FLANG FLANG]\u00a0 [Mul\u00a0 FLANG FLANG]\u00a0 [Div\u00a0 FLANG FLANG]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol FLANG FLANG]\u00a0 [Fun\u00a0 Symbol FLANG]\u00a0 [Call FLANG FLANG])(: parse-sexpr : Sexpr -> FLANG);; parses s-expressions into FLANGs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'fun more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'fun (list (symbol: name)) body)\u00a0 \u00a0 \u00a0 \u00a0 (Fun name (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `fun' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list 'call fun arg)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Call (parse-sexpr fun) (parse-sexpr arg))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> FLANG);; parses a string containing a FLANG expression to a FLANG AST(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)))(: subst : FLANG Symbol FLANG -> FLANG);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst named-expr from to)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]\u00a0 \u00a0 [(Call l r) (Call (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Fun bound-id bound-body)\u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0  expr\u00a0 \u00a0 \u00a0  (Fun bound-id (subst bound-body from to)))]))(: Num->number : FLANG -> Number);; convert a FLANG number to a Racket one(define (Num->number e)\u00a0 (cases e\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [else (error 'arith-op \"expected a number, got: ~s\" e)]))(: arith-op : (Number Number -> Number) FLANG FLANG -> FLANG);; gets a Racket numeric binary operator, and uses it within a FLANG;; `Num' wrapper(define (arith-op op expr1 expr2)\u00a0 (Num (op (Num->number expr1) (Num->number expr2))))(: eval : FLANG -> FLANG);; evaluates FLANG expressions by reducing them to *expressions*(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (arith-op + (eval l) (eval r))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l) (eval r))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l) (eval r))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l) (eval r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval named-expr)))]\u00a0 \u00a0 [(Id name) (error 'eval \"free identifier: ~s\" name)]\u00a0 \u00a0 [(Fun bound-id bound-body) expr]\u00a0 \u00a0 [(Call (Fun bound-id bound-body) arg-expr)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval arg-expr)))]\u00a0 \u00a0 [(Call something arg-expr)\u00a0 \u00a0  (error 'eval \"`call' expects a function, got: ~s\" something)]))(: run : String -> Number);; evaluate a FLANG program contained in a string(define (run str)\u00a0 (let ([result (eval (parse str))])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a non-number: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])));; tests(test (run \"{call {fun {x} {+ x 1}} 4}\")\u00a0 \u00a0 \u00a0 => 5)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add3 1}}\")\u00a0 \u00a0 \u00a0 => 4)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {add1 {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add1 {call add3 x}}}}}\")\u00a0 \u00a0 \u00a0 => 7)\n```", "```\n(run \"{with {add {fun {x}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {fun {y}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {+ x y}}}}\u00a0 \u00a0 \u00a0  {call {call add 8} 9}}\")(run \"{with {identity {fun {x} x}}\u00a0 \u00a0 \u00a0 \u00a0 {with {foo {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call {call identity foo} 123}}}\")(run \"{call {call {fun {x} {call x 1}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {x} {fun {y} {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 123}\")\n```", "```\n(: eval : FLANG -> FLANG);; evaluates FLANG expressions by reducing them to *expressions*(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (arith-op + (eval l) (eval r))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l) (eval r))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l) (eval r))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l) (eval r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval named-expr)))]\u00a0 \u00a0 [(Id name) (error 'eval \"free identifier: ~s\" name)]\u00a0 \u00a0 [(Fun bound-id bound-body) expr]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  (let ([fval (eval fun-expr)])\u00a0 \u00a0 \u00a0  ;*** need to evaluate this!\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(Fun bound-id bound-body)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (eval arg-expr)))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"`call' expects a function, got: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]))\n```", "```\n[\u25b6](flang.rkt \"flang.rkt\");; The Flang interpreter#lang pl#|The grammar:\u00a0 <FLANG> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { + <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { - <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { * <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { / <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { with { <id> <FLANG> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | <id>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { fun { <id> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { call <FLANG> <FLANG> }Evaluation rules:\u00a0 subst:\u00a0 \u00a0 N[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = N\u00a0 \u00a0 {+ E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {+ E1[v/x] E2[v/x]}\u00a0 \u00a0 {- E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {- E1[v/x] E2[v/x]}\u00a0 \u00a0 {* E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {* E1[v/x] E2[v/x]}\u00a0 \u00a0 {/ E1 E2}[v/x]\u00a0 \u00a0 \u00a0 \u00a0 = {/ E1[v/x] E2[v/x]}\u00a0 \u00a0 y[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = y\u00a0 \u00a0 x[v/x]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = v\u00a0 \u00a0 {with {y E1} E2}[v/x] = {with {y E1[v/x]} E2[v/x]} ; if y =/= x\u00a0 \u00a0 {with {x E1} E2}[v/x] = {with {x E1[v/x]} E2}\u00a0 \u00a0 {call E1 E2}[v/x]\u00a0 \u00a0  = {call E1[v/x] E2[v/x]}\u00a0 \u00a0 {fun {y} E}[v/x]\u00a0 \u00a0 \u00a0 = {fun {y} E[v/x]}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  ; if y =/= x\u00a0 \u00a0 {fun {x} E}[v/x]\u00a0 \u00a0 \u00a0 = {fun {x} E}\u00a0 eval:\u00a0 \u00a0 eval(N)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = N\u00a0 \u00a0 eval({+ E1 E2})\u00a0 \u00a0 = eval(E1) + eval(E2)\u00a0 \\ if both E1 and E2\u00a0 \u00a0 eval({- E1 E2})\u00a0 \u00a0 = eval(E1) - eval(E2)\u00a0  \\ evaluate to numbers\u00a0 \u00a0 eval({* E1 E2})\u00a0 \u00a0 = eval(E1) * eval(E2)\u00a0  / otherwise error!\u00a0 \u00a0 eval({/ E1 E2})\u00a0 \u00a0 = eval(E1) / eval(E2)\u00a0 /\u00a0 \u00a0 eval(id)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  = error!\u00a0 \u00a0 eval({with {x E1} E2}) = eval(E2[eval(E1)/x])\u00a0 \u00a0 eval(FUN)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = FUN ; assuming FUN is a function expression\u00a0 \u00a0 eval({call E1 E2}) = eval(Ef[eval(E2)/x])\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if eval(E1)={fun {x} Ef}, otherwise error!|#(define-type FLANG\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 FLANG FLANG]\u00a0 [Sub\u00a0 FLANG FLANG]\u00a0 [Mul\u00a0 FLANG FLANG]\u00a0 [Div\u00a0 FLANG FLANG]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol FLANG FLANG]\u00a0 [Fun\u00a0 Symbol FLANG]\u00a0 [Call FLANG FLANG])(: parse-sexpr : Sexpr -> FLANG);; parses s-expressions into FLANGs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'fun more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'fun (list (symbol: name)) body)\u00a0 \u00a0 \u00a0 \u00a0 (Fun name (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `fun' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list 'call fun arg)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Call (parse-sexpr fun) (parse-sexpr arg))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> FLANG);; parses a string containing a FLANG expression to a FLANG AST(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)))(: subst : FLANG Symbol FLANG -> FLANG);; substitutes the second argument with the third argument in the;; first argument, as per the rules of substitution; the resulting;; expression contains no free instances of the second argument(define (subst expr from to)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (Add (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Sub l r) (Sub (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Mul l r) (Mul (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Div l r) (Div (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Id name) (if (eq? name from) to expr)]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (With bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst named-expr from to)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (subst bound-body from to)))]\u00a0 \u00a0 [(Call l r) (Call (subst l from to) (subst r from to))]\u00a0 \u00a0 [(Fun bound-id bound-body)\u00a0 \u00a0  (if (eq? bound-id from)\u00a0 \u00a0 \u00a0  expr\u00a0 \u00a0 \u00a0  (Fun bound-id (subst bound-body from to)))]))(: Num->number : FLANG -> Number);; convert a FLANG number to a Racket one(define (Num->number e)\u00a0 (cases e\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [else (error 'arith-op \"expected a number, got: ~s\" e)]))(: arith-op : (Number Number -> Number) FLANG FLANG -> FLANG);; gets a Racket numeric binary operator, and uses it within a FLANG;; `Num' wrapper(define (arith-op op expr1 expr2)\u00a0 (Num (op (Num->number expr1) (Num->number expr2))))(: eval : FLANG -> FLANG);; evaluates FLANG expressions by reducing them to *expressions*(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) expr]\u00a0 \u00a0 [(Add l r) (arith-op + (eval l) (eval r))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l) (eval r))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l) (eval r))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l) (eval r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval named-expr)))]\u00a0 \u00a0 [(Id name) (error 'eval \"free identifier: ~s\" name)]\u00a0 \u00a0 [(Fun bound-id bound-body) expr]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  (let ([fval (eval fun-expr)])\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(Fun bound-id bound-body)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (eval arg-expr)))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"`call' expects a function, got: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]))(: run : String -> Number);; evaluate a FLANG program contained in a string(define (run str)\u00a0 (let ([result (eval (parse str))])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a non-number: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])));; tests(test (run \"{call {fun {x} {+ x 1}} 4}\")\u00a0 \u00a0 \u00a0 => 5)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add3 1}}\")\u00a0 \u00a0 \u00a0 => 4)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {add1 {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add1 {call add3 x}}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{with {add {fun {x}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {fun {y}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {call {call add 8} 9}}\")\u00a0 \u00a0 \u00a0 => 17)(test (run \"{with {identity {fun {x} x}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {foo {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call {call identity foo} 123}}}\")\u00a0 \u00a0 \u00a0 => 124)(test (run \"{call {call {fun {x} {call x 1}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {x} {fun {y} {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 123}\")\u00a0 \u00a0 \u00a0 => 124)\n```"]