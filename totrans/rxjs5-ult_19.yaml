- en: Operators time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not an easy topic. There are many areas of application here, either
    you might want to synchronize responses from APIS or you might want to deal with
    other types of streams such as events like clicks or keyup in a UI.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of operators dealing with time in some way such as `delay`
    `debounce` `throttle` `interval` etc.
  prefs: []
  type: TYPE_NORMAL
- en: This is not an easy topic. There are many areas of application here, either
    you might want to synchronize responses from APIS or you might want to deal with
    other types of streams such as events like clicks or keyup in a UI.
  prefs: []
  type: TYPE_NORMAL
- en: interval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This operator is used to construct an Observable and essentially what it does
    is to pump values at regular interval, signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this one will generate values forever you tend to want to combine it
    with the `take()` operator that limits the amount of values to generate before
    calling it quits so that would look like :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Timer is an interesting one as it can act in several ways depending on how you
    call it. It's signature is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However only the initial args is mandatory so depending on the number of args
    used these are the different types that exist because of it.
  prefs: []
  type: TYPE_NORMAL
- en: '**one-off**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This becomes a one-ff as we don't define when the next value should happen.
  prefs: []
  type: TYPE_NORMAL
- en: '**with 2nd arg specified**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So this one is more flexible and keeps emitting values according to 2nd argument.
  prefs: []
  type: TYPE_NORMAL
- en: delay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`delay()` is an operator that delays every value being emitted Quite simply
    it works like this :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Business case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Delay can be used in a multitude of places but one such good case is when handling
    errors especially if we are dealing with `shaky connections` and want it to retry
    the whole stream after x miliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: Read more in chapter [Error handling](error-handling.html)
  prefs: []
  type: TYPE_NORMAL
- en: sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I usually think of this scenario as *talk to the hand*. What I mean by that
    is that events are only fired at specific points
  prefs: []
  type: TYPE_NORMAL
- en: Business case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So the ability to ignore events for x miliseconds is pretty useful. Imagine
    a save button being repeatedly pushed. Wouldn't it be nice to only act after x
    miliseconds and ignore the other pushes ?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code above does just that.
  prefs: []
  type: TYPE_NORMAL
- en: debounceTime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So `debounceTime()` is an operator that tells you: I will not emit the data
    all the time but at certain intervals.'
  prefs: []
  type: TYPE_NORMAL
- en: Business case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debounce is a known concept especially when you type keys on a keyboard. It's
    a way of saying we don't care about every keyup but once you stop typing for a
    while we should care. That, is how you would normally start an auto complete.
    Say your user hasn't typed for x miliseconds that probably means we should be
    doing an ajax call and retrieve a result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The following only outputs a value, from our input field, after you stopped
    typing for 500ms, then it's worth reporting about it, i.e emit a value.
  prefs: []
  type: TYPE_NORMAL
- en: throttleTime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: buffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This operator has the ability to record x number of emitted values before it
    outputs its values, this one comes with one or two input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So what does this mean? It means given we have for example a click of streams
    we can cut it into nice little pieces where every piece is equally long. Using
    the first version with one parameter we can give it a time argument, let''s say
    500 ms. So something emits values for 500ms then the values are emitted and another
    Observable is started, and the old one is abandoned. It''s much like using a stopwatch
    and record for 500 ms at a time. Example :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Marble diagram
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Business case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So whats the business case for this one? `double click`, it''s obviously easy
    to react on a `single click` but what if you only want to perform an action on
    a `double click` or `triple click`, how would you write code to handle that? You
    would probably start with something looking like this :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Look at the above as an attempt at pseudo code. The point is that you need to
    keep track of a bunch of variables of how much time has passed between clicks.
    This is not nice looking code, lacks elegance
  prefs: []
  type: TYPE_NORMAL
- en: Model in Rxjs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By now we know Rxjs is all about streams and modeling values over time. Clicks
    are no different, they happen over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We however care about the clicks when they appear close together in time, i.e
    as double or triple clicks like so :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: From the above stream you should be able to deduce that a `double click`, one
    `triple click` and one `single click` happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s say I do, then what? You want the stream to group itself nicely so
    it tells us about this, i.e it needs to emit these clicks as a group. `filter()`
    as an operator lets us do just that. If we define let''s say 300ms is a long enough
    time to collect events on, we can slice up our time from 0 to forever in chunks
    of 300 ms with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Read the code in the following way, the buffer stream, `clicks$` will emit its
    values every 300ms, 300 ms is decided by `scissor$` stream. So the `scissor$`
    stream is the scissor, if you will, that cuts up our click stream and voila we
    have an elegant `double click` approach. As you can see the above code captures
    all types of clicks but by uncommenting the `filter()` operation we get only `double
    clicks` and `triple clicks`.
  prefs: []
  type: TYPE_NORMAL
- en: '`filter()` operator can be used for other purposes as well like recording what
    happened in a UI over time and replay it for the user, only your imagination limits
    what it can be used for.'
  prefs: []
  type: TYPE_NORMAL
