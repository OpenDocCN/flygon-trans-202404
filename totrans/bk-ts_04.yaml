- en: 'Chapter 4: Putting the Type in TypeScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Putting the *Type* in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript''s name is no accident. It doesn''t mean "some type of scripting
    language."^([1](#fn_1)) TypeScript overlays static typing on top of plain JavaScript.
    This is best explained by example. Let''s start with some valid and admittedly
    ridiculous pure JS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above snippet^([2](#fn_2)) shows four variables and JavaScript infers their
    data type. This allows us to write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Pure JavaScript *also* lets us do things like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s valid script and in chrome, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nonsensical But Allowed Variable Assignments](ch04_nonsenseVars.JPG "Nonsensical
    But Allowed Variable Assignments")'
  prefs: []
  type: TYPE_IMG
- en: 'Figure: Nonsensical But Allowed Variable Assignments'
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of people really don''t care for this behavior^([3](#fn_3)). As I say,
    this is a contrived example. If you''re prone to writing code like this, you may
    not belong in the field. The real problem is that is very, very easy to introduce
    bugs in pure JS by accidentally mixing data types. TypeScript mitigates the problem.
    In TypeScript, you can specify the type of the variable when you define it. Let''s
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The above snippet explicitly shows TypeScript''s type system at work:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable xyzzy is a `string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"TheAnswer" is a `number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: hammerTime is a `Date`. Why is it a Date and not something else? Because TypeScript
    can infer its data type. The code initializes it to a Date object and hence, it
    can only be a date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last variable, `whoKnows`, also has a type, `any`. Variables of type any
    act just like pure JS variables. You can assign string values one moment, booleans
    the next and numbers after that.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to the trouble of defining types on your variables, your IDE will
    give you some great edit-time and compile-time support. Consider this short animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![short animation](ch04_strongTypingExampleVideo.gif "IDE Supporting Defined
    Types")'
  prefs: []
  type: TYPE_IMG
- en: 'Figure: IDE Supporting Defined Types'
  prefs: []
  type: TYPE_NORMAL
- en: '(If you can''t see the animation for some reason, [access this link via a web
    browser](https://pagalvin.gitbooks.io/yet-another-typescript-book/content/assets/video/ch04_strongTypingExampleVideo/ch04_strongTypingExampleVideo.gif)
    or type in this URL: [https://goo.gl/hEbWvq](https://goo.gl/hEbWvq)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re already a JS coder, this is a very simple way to get started with
    the language. Pick a few variables, associate some types with them and see what
    happens. A couple things will or may happen when you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Your IDE will get a lot smarter about your code. It will know variable types
    and prevent you from assigning strings to numbers and that sort of thing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may discover problems with your code right away. You may well have intended
    that a particular variable, `myNumber`, hold numbers. As JS coders know, it's
    quite easy to mistakenly assign strings, date, complex objects, to your "myNumber"
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many TypeScript developers start off this way because it's so simple to do.
    It's so simple, in fact, that they quickly move on to more interesting typings,
    including the ability to strongly type nested objects via `interfaces`. The next
    chapter introduces interfaces as data descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Light Bulb Time?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In late December of 2015, Eric Clemmons posted a widely read article on Medium
    entitled *JavaScript Fatigue*. [You can read it here.](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.3jytn61rs)
    If you haven't read it, it's probably worth your time^([4](#fn_4)). It does a
    good job of describing the ennui in which some JavaScript devs find themselves
    trapped at times. It's a difficult trap to avoid! There are so many frameworks,
    development tools, IDEs and other clever gidgety-gadgets, it can become ... fatiguing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](lightbulb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Many first-time TypeScripters shake off their skepticism and get a little rush
    of excitement from this most simple of TypeScript features. Merely add ": string"
    or ": number" to a variable and ...'
  prefs: []
  type: TYPE_NORMAL
- en: It's much more difficult to mistakenly make mismatching assignments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Intent becomes clear. Any decent IDE will tell you, at runtime, the data type
    of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is very valuable stuff. It is also very easy to harvest some value from
    it. All you need to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Take one of your JS files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy it with a .ts extension
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some typings (numbers, strings, booleans, etc.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're done!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the rest of your JS will work as normal. The most simple change to your
    code immediately provides significant benefit. This was my light bulb moment.
    It didn't end there for me and won't end there for you.
  prefs: []
  type: TYPE_NORMAL
- en: It's probably safe to say that if there's no light bulb going off for you right
    now, TypeScript may not be for you, at least not today. I invite you to continue
    reading anyway :).
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript provides three different ways to define a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var` keyword'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let` keyword'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const` keyword'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you declare a variable with the `var` keyword, it works exactly the same
    way it does in pure JavaScript. It follows the same scoping rules and as such,
    you need to concern yourself with unexpected hoisting effects and/or inadvertently
    polluting the global namespace. `const` and `let` simplify things by reducing
    this risk and associated complexity. Here's a bit of plain JavaScript code that
    implements a function, `getTempLabel()`. It's mean to take in numeric temperature
    in Celsius and return a text label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the plain JS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Take note of three things from this example: 1) The variable "result" isn''t
    actually decorated with `var` until it makes its 3rd appearance. 2) Through the
    magic of "hoisting," `result` is available throughout the function, not just in
    the else block where it''s defined. 3) This is also perfectly valid TypeScript,
    although there''s a much better way to implement the function. You''ll see that
    in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many programming languages dictate tighter scoping rules. Many people, the
    author included, consider the above example poorly done for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable isn't properly declared until well past its first use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code doesn't do a good job showing the developer's intent here. `result`
    could be used anywhere in the function on both the left hand side and right hand
    side of an expression, leading to unanticipated and difficult to track bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even experienced JS developers have a hard time with variable scope and hoisting.
    Why accept that headache lying down?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is similar code written in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, instead of using `var` to define the result variable, the code
    uses TypeScript''s `let`. Let defines variable characteristics the same way as
    var - you specify a name and optionally a data type. The difference is about variable
    scope. A variable defined with let is scoped to the block where it''s defined
    and is available to sub-blocks. It is never hoisted, as happens in pure JavaScript.
    Watch this short to see the effect of let and variable scope in a few different
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/tMkqzIqhCwo](https://www.youtube.com/embed/tMkqzIqhCwo)'
  prefs: []
  type: TYPE_NORMAL
- en: '(Depending on how you''re reading the book, the video may not appear. If not,
    access it by [clicking this link](https://youtu.be/tMkqzIqhCwo) or typing the
    following URL into your web browser: [https://youtu.be/tMkqzIqhCwo](https://youtu.be/tMkqzIqhCwo))'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript Best Practice - *Let*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a rule, prefer "let" over var. This will tend to reduce the risk of unanticipated
    side effects in your code through JavaScript's hoisting mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Const Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript provides another method for defining variables - `const`. A const
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Must be initialized when declared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: May never be changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`const` brings a little subtlety to the table, especially when it comes to
    object property values. Consider this bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code defines three `any` variables^([5](#fn_5)) and you can tell that it's
    mean to hold a kind of "person" record, holding a first and last name. It initializes
    `Paul` and `Kelly` to similarly structured objects.
  prefs: []
  type: TYPE_NORMAL
- en: It then tries to create a constant `Aidan` variable without assigning an initial
    value. This is not allowed. It won't compile and your IDE should highlight this
    as an error.
  prefs: []
  type: TYPE_NORMAL
- en: The Kelly PersonName const variable *is* defined. However, it's seeded with
    "TBD" values. Later, the code changes Kelly's firstName property. This is valid^([6](#fn_6)).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the Paul variable cannot be changed after it's initialized. The final
    "Paul = null" assignment is also invalid. Const variables may never be in the
    left hand side of an assignment once they are declared and initialized.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript Best Practice - *Let*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a rule, prefer `const` over `let`. This recommendation largely derives from
    functional programming principles. The more you minimize mutations in your code,
    the fewer side effects you'll experience^([7](#fn_7)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking this and let into consideration, we can summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer const in all cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When const won't meet your needs, prefer let over var.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you absolutely need var, use that. However, the use of var in TypeScript
    strongly indicates a logic problem and an opportunity to simply the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript Let, Const and Transpilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the end of the day, JavaScript doesn''t know anything about const or let.
    They always compile down to plain old var statements. Here''s the transpiled version
    of the getTemperature function from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript enforces variable scope and const initialization / assignment rules
    at compile-time. A good IDE will do it as you write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider reading the following articles that compliment this chapter''s content:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pretty good conversation on stackexchange that plumbs the depths of `let`
    vs `var` vs `const`: [https://softwareengineering.stackexchange.com/questions/278652/how-much-should-i-be-using-let-vs-const-in-es6](https://softwareengineering.stackexchange.com/questions/278652/how-much-should-i-be-using-let-vs-const-in-es6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good overview of var/let/const as well as describing a few primitive data
    types: [http://www.brainbell.com/typescript/data-types-let-var-cons.html](http://www.brainbell.com/typescript/data-types-let-var-cons.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another good overview article by Ayo Alfonso contrasting JavaScript with TypeScript:
    [https://hackernoon.com/typescript-vs-javascript-b568bc4a4e58](https://hackernoon.com/typescript-vs-javascript-b568bc4a4e58)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that TypeScript is a statically typed langauge
    that introduces a couple of new ways to manage variable scope and immutability.
    You saw some of the practical effects that derive from these features and have
    been armed with a bit of advice on how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter digs into this topic with more gusto and introduces interfaces,
    a most useful and powerful language element. It also covers enumerations, union
    types and more! Take a deep breath and then turn the virtual page.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¹. Although that would be truly glorious. [↩](#reffn_1 "Jump back to footnote
    [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '². Three of these variables remind me of my youth and for history''s sake,
    here are some links for you to follow if you don''t know them already: [42](https://en.wikipedia.org%2Fwiki%2F42_%28number%29%23The_Hitchhiker.27s_Guide_to_the_Galaxy),
    [xyzzy](https://en.wikipedia.org/wiki/Colossal_Cave_Adventure) (which you can
    play on the Amazon Echo, believe it or not(!)) and [Hammertime](http://ew.com/article/2010/01/08/20-years-ago-mc-hammers-u-cant-touch-this/).
    [↩](#reffn_2 "Jump back to footnote [2] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '³. To be fair, plenty of people are perfectly OK with it. For example, Jeff
    Walker asserts that: [↩](#reffn_3 "Jump back to footnote [3] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TypeScript enhances JavaScript with types, classes and interfaces. Some people
    think that is the problem with JavaScript. It’s not. The problem with JavaScript
    is not that it is a dynamically typed prototype based object-oriented language
    without classes. That is actually JavaScript’s strength."
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I don't know JW and I don't mean to imply that this one quote pulled from one
    article he wrote stands for everything he believes :). That quote does, however,
    do a good job articulating a certain school of thought vis-à-vis JavaScript's
    dynamic nature. Many people like it. Those people probably aren't using TypeScript
    much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eric Elliot takes a deeper dive into the subject: [https://medium.com/javascript-scene/you-might-not-need-typescript-or-static-types-aa7cb670a77b#.5aideomvb](https://medium.com/javascript-scene/you-might-not-need-typescript-or-static-types-aa7cb670a77b#.5aideomvb).
    This is also worth reading.'
  prefs: []
  type: TYPE_NORMAL
- en: ⁴. It's also, a little ironically, a decent listing of interesting tools and
    frameworks out there and hence, another good reason to read the article. That
    is, of course, it doesn't tire you out. To be safe, finish reading this book first.
    [↩](#reffn_4 "Jump back to footnote [4] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '⁵. Recall that the default data type is "any" for TypeScript variables. You
    should avoid this, especially if you''re starting off with a fresh new project.
    You can disallow "implicit" any variables through a compiler configuration setting.
    Read about that here: [https://basarat.gitbooks.io/typescript/docs/options/noImplicitAny.html](https://basarat.gitbooks.io/typescript/docs/options/noImplicitAny.html).
    [↩](#reffn_5 "Jump back to footnote [5] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁶. Admittedly, this is a minor source of cognitive dissonance. Since the variable
    is itself a `const`, why allow us to change the variable's properties as well?
    It is what it is and turns out to be helpful at the end of the day. So, live with
    it we must. [↩](#reffn_6 "Jump back to footnote [6] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '⁷. I have found that functional programming, like TypeScript, is a joy unto
    itself. I have written about that joy here: [https://hackernoon.com/unexpected-joy-from-functional-programming-ed9d3adca77a](https://hackernoon.com/unexpected-joy-from-functional-programming-ed9d3adca77a).
    [↩](#reffn_7 "Jump back to footnote [7] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
