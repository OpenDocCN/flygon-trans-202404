["```\nnamespace Example\n\n// declare a module \nmodule Person = \n\n    type T = {First:string; Last:string}\n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // method that works on the type\n    let fullName {First=first; Last=last} = \n        first + \" \" + last \n```", "```\nnamespace Example\n\n// declare the type outside the module\ntype PersonType = {First:string; Last:string}\n\n// declare a module for functions that work on the type\nmodule Person = \n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // method that works on the type\n    let fullName {First=first; Last=last} = \n        first + \" \" + last \n```", "```\n// =========================\n// File: DomainTypes.fs\n// =========================\nnamespace Example\n\n// \"types-only\" module\n[<AutoOpen>]\nmodule DomainTypes = \n\n    type Person = {First:string; Last:string}\n\n    type OtherDomainType = ...\n\n    type ThirdDomainType = ... \n```", "```\n// =========================\n// File: Person.fs\n// =========================\nnamespace Example\n\n// declare a module for functions that work on the type\nmodule Person = \n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // method that works on the type\n    let fullName {First=first; Last=last} = \n        first + \" \" + last \n```", "```\nlet f (p:Person) = p.First \n```", "```\nlet g () = Person.create \"Alice\" \"Smith\" \n```", "```\ntype Location = {name: string; workers: Employee list}\n\ntype Employee = {name: string; worksAt: Location} \n```", "```\n/// ===========================================\n/// Common types and functions shared across multiple projects\n/// ===========================================\nmodule CommonLibrary = \n\n    // the two-track type\n    type Result<'TSuccess,'TFailure> = \n        | Success of 'TSuccess\n        | Failure of 'TFailure\n\n    // convert a single value into a two-track result\n    let succeed x = \n        Success x\n\n    // convert a single value into a two-track result\n    let fail x = \n        Failure x\n\n    // appy either a success function or failure function\n    let either successFunc failureFunc twoTrackInput =\n        match twoTrackInput with\n        | Success s -> successFunc s\n        | Failure f -> failureFunc f\n\n    // convert a switch function into a two-track function\n    let bind f = \n        either f fail\n\n    // pipe a two-track value into a switch function \n    let (>>=) x f = \n        bind f x\n\n    // compose two switches into another switch\n    let (>=>) s1 s2 = \n        s1 >> bind s2\n\n    // convert a one-track function into a switch\n    let switch f = \n        f >> succeed\n\n    // convert a one-track function into a two-track function\n    let map f = \n        either (f >> succeed) fail\n\n    // convert a dead-end function into a one-track function\n    let tee f x = \n        f x; x \n\n    // convert a one-track function into a switch with exception handling\n    let tryCatch f exnHandler x =\n        try\n            f x |> succeed\n        with\n        | ex -> exnHandler ex |> fail\n\n    // convert two one-track functions into a two-track function\n    let doubleMap successFunc failureFunc =\n        either (successFunc >> succeed) (failureFunc >> fail)\n\n    // add two switches in parallel\n    let plus addSuccess addFailure switch1 switch2 x = \n        match (switch1 x),(switch2 x) with\n        | Success s1,Success s2 -> Success (addSuccess s1 s2)\n        | Failure f1,Success _  -> Failure f1\n        | Success _ ,Failure f2 -> Failure f2\n        | Failure f1,Failure f2 -> Failure (addFailure f1 f2)\n\n/// ===========================================\n/// Global types for this project\n/// ===========================================\nmodule DomainTypes = \n\n    open CommonLibrary \n\n    /// The DTO for the request\n    type Request = {name:string; email:string}\n\n    // Many more types coming soon!\n\n/// ===========================================\n/// Logging functions\n/// ===========================================\nmodule Logger = \n\n    open CommonLibrary \n    open DomainTypes\n\n    let log twoTrackInput = \n        let success x = printfn \"DEBUG. Success so far: %A\" x; x\n        let failure x = printfn \"ERROR. %A\" x; x\n        doubleMap success failure twoTrackInput \n\n/// ===========================================\n/// Validation functions\n/// ===========================================\nmodule Validation = \n\n    open CommonLibrary \n    open DomainTypes\n\n    let validate1 input =\n       if input.name = \"\" then Failure \"Name must not be blank\"\n       else Success input\n\n    let validate2 input =\n       if input.name.Length > 50 then Failure \"Name must not be longer than 50 chars\"\n       else Success input\n\n    let validate3 input =\n       if input.email = \"\" then Failure \"Email must not be blank\"\n       else Success input\n\n    // create a \"plus\" function for validation functions\n    let (&&&) v1 v2 = \n        let addSuccess r1 r2 = r1 // return first\n        let addFailure s1 s2 = s1 + \"; \" + s2  // concat\n        plus addSuccess addFailure v1 v2 \n\n    let combinedValidation = \n        validate1 \n        &&& validate2 \n        &&& validate3 \n\n    let canonicalizeEmail input =\n       { input with email = input.email.Trim().ToLower() }\n\n/// ===========================================\n/// Database functions\n/// ===========================================\nmodule CustomerRepository = \n\n    open CommonLibrary \n    open DomainTypes\n\n    let updateDatabase input =\n       ()   // dummy dead-end function for now\n\n    // new function to handle exceptions\n    let updateDatebaseStep = \n        tryCatch (tee updateDatabase) (fun ex -> ex.Message)\n\n/// ===========================================\n/// All the use cases or services in one place\n/// ===========================================\nmodule UseCases = \n\n    open CommonLibrary\n    open DomainTypes\n\n    let handleUpdateRequest = \n        Validation.combinedValidation \n        >> map Validation.canonicalizeEmail\n        >> bind CustomerRepository.updateDatebaseStep\n        >> Logger.log \n```"]