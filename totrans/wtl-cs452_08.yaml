- en: Lecture 8 - Create, Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pubilc Service Annoucements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due date for assignment 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Victoria Day holiday
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the Hardware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: busy-wait io
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: low memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the kernel entry?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn off interrupts in the ICU
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should be unnecessary, but what if the previous kernel turned them on?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Later you will initialize the ICU differently.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare the Kernel Data Structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Where is the kernel's stack pointer, right now? What does the stack look like?
  prefs: []
  type: TYPE_NORMAL
- en: Do you want it there? Would you rather have it somewhere else?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is your last chance to change it. (If you decide to change it you might
    want to keep what you are replacing around. Why?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel data structures
  prefs: []
  type: TYPE_NORMAL
- en: an array of empty ready queues
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a poimter to the TD of the active task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: an array of TDs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a free list of pointers to free TDs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the Memory to be Used by Tasks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: task memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the First User Task
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Can run with interrupts turned off for now (belt and braces) but will need to
    be turned on later.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder. The place where the kernel starts executing has the global name main,
    which cannot be re-used.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In creating a task you have to do two things
  prefs: []
  type: TYPE_NORMAL
- en: Get and initialize resources needed by the task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TD
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the task look as if it had just entered the kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it's ready to execute when it's scheduled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Things you need to do
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Allocate resources
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Get an unused TD and unused memory for its stack
  prefs: []
  type: TYPE_NORMAL
- en: actually a form of constant time memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize resources
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Mostly filling in fields in the TD. Here are the ones that ought to be in the
    TD.
  prefs: []
  type: TYPE_NORMAL
- en: task id
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: priority
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: stack pointer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: parent tid
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the active task
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: READY
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: install in the ready queues
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: pointers in the TD
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This looks like six words, which could be squeezed into fewer. (There will be
    more later.)
  prefs: []
  type: TYPE_NORMAL
- en: If you are thinking about the cache, how can you make the array of task descriptors
    so that they are cache-aligned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are the ones that could be in the TD, or could be on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: SPSR
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: link register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: return value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the stack
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: exactly as if the task had just done a kernel entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: look carefully at what your kernel exit code will do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end stack pointer must correspond to stack contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I initialize the stack pointer to the top of allocated memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: my stacks grow down
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: then change it as I push stuff onto the stack
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: imitating the context switch code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's something I always do.
  prefs: []
  type: TYPE_NORMAL
- en: Put distinctive values into registers to start off with, like 00000000, 11111111,
    22222222, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes solving pointer misalignment problems easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The Create Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You also need a `int Create( int priority, void (*code) ( ) )` function to call
    from user tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Although it's no more than a wrapper there are a few problems to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On entry the arguments are somewhere, usually r0 & r1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to put them where the kernel can find them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: gcc's function extry code immediately puts them on the stack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In assembly you can find them using the frame pointer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumping into the kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the return value from the kernel and returning it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You find it where the kernel put it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: gcc's function exit code expects it to be indexed off the frame pointer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: from where it does into r0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Other Primitives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These primitives exist mostly so that we, which includes you, can ensure that
    task creation and scheduling are working when there is not much else implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '`Tid MyTid( )`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Self-explanatory
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't block, but does reschedule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A question, to which there is a correct answer, or more specifically, a correct
    (answer, reason) pair.
  prefs: []
  type: TYPE_NORMAL
- en: Should the Tid be stored in user space?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tid MyParentTid( )`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Self-explanatory
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't block, but does reschedule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where is the parent Tid, and how does the kernel find it?
  prefs: []
  type: TYPE_NORMAL
- en: '`void Pass( )`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Doesn''t block: task calling `Pass( )` remains ready to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: Does reschedule.
  prefs: []
  type: TYPE_NORMAL
- en: When is `Pass( )` a `NOP`?
  prefs: []
  type: TYPE_NORMAL
- en: '`void Exit( )`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Calling task is removed from all queues, but its resources are not reclaimed
    or reused.
  prefs: []
  type: TYPE_NORMAL
- en: That is, the task goes into a zombie state, in which it cannot be active or
    ready, but continues to own all its resources.
  prefs: []
  type: TYPE_NORMAL
- en: How Should Execution Terminate?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nicely.
  prefs: []
  type: TYPE_NORMAL
- en: When there are no tasks left on the ready queues, it goes back to RedBoot.
  prefs: []
  type: TYPE_NORMAL
- en: This behaviour changes when hardware interrupts are implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bill Cowan''s lecture notes for CS452 in s12](index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s Spring 2012 CS452 page](../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s CS452 page](../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s teaching page](../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s home page](../../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
