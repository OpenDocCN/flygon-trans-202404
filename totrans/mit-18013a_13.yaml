- en: 'Chapter 12: Applications of Differentiation: Direct Use of Linear Approximation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We consider using the linear approximation as an approximation method, and using
    it by iteration to determine inverse functions to the accuracy of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 12.1  [Estimating a Function Value Using the Linear Approximation](section01.html)
  prefs: []
  type: TYPE_NORMAL
- en: 12.2  [Determining an Inverse Function Accurately by Iterating the Linear Approximation](section02.html)
  prefs: []
  type: TYPE_NORMAL
- en: 12.3  [Spreadsheet Implementation of this Procedure](section03.html)
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 Estimating a Function Value Using the Linear Approximation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we have a function f that we find difficult to evaluate, but we know
    a few things about it. We want to make use of what we know as much as possible
    to approximate its value at argument x knowing its value at some argument x[0].
  prefs: []
  type: TYPE_NORMAL
- en: Suppose for example we want to evaluate the cube root of 28.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the� cube root of 27 is 3.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest thing we can do is to make the "constant approximation", and approximate
    the cube root of 28 by 3, as if the cube root function were a constant.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we can try, if we want to do better, is to apply the linear approximation
  prefs: []
  type: TYPE_NORMAL
- en: f[1](x) = f(x[0]) + (x-x[0])f '(x[0])
  prefs: []
  type: TYPE_NORMAL
- en: in our case we have ![](../Images/9cac12b02730143b7a4fa66f63620f56.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: The linear approximation, ![](../Images/71f75c9bc6c0b843096ddebf33453015.jpg)
    to the cube root of 28 is then ![](../Images/26f05d5553d5b239f37fa318a9430c10.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Given any function f for which we know f(x[0]) and� f '(x[0]) we can immediately
    evaluate this approximation. Using it involves pretending that the graph of the
    function f were its tangent line at x[0], rather than whatever it is.
  prefs: []
  type: TYPE_NORMAL
- en: We can judge how good this approximation is by considering the second derivative
    of f.
  prefs: []
  type: TYPE_NORMAL
- en: Note that f " is negative in the range between 27 and 28, which means that the
    first derivative decreases in that interval. On the tangent line at 27 it stays
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: This implies that� the tangent line linear approximation at 27 overestimates
    the change in f over this interval and therefore we know
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7bad0a65970f981b8b21790298da50b5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can also observe that f 's third derivative is positive in the interval in
    question, so that the quadratic approximation, by the same argument underestimates
    the change in the second derivative and in all lower derivatives as well, so it
    is a lower bound to f(28), and we get
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/087ccbbf9ae5ac0bfe0dbba76e514d6e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Numerically, to six decimal places we get 3.03658 < f(28) < 3.03704; in fact
    we have f(28) = 3.03659 to this accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: The cube root function considered here is the **inverse function** to one we
    know how to calculate directly, namely the cube. **We can use the linear approximation
    to compute any such inverse function to the accuracy that our machine will allow,**
    as we shall see next.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Determining an Inverse Function Accurately by Iterating the Linear Approximation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How?**'
  prefs: []
  type: TYPE_NORMAL
- en: Given a pair of numbers, (x[0], f(x[0])) the linear approximation, fLx[0] to
    f defined at x[0], allows us to compute fLx[0](x) as an approximation to f(x).
  prefs: []
  type: TYPE_NORMAL
- en: If we know the inverse function to f, we can compute f ^(-1)(fLx[0](x)) and
    that gives us a new pair of numbers, (f ^(-1)(fLx[0](x)), fLx[0](x)) that we can
    call (x[1], f(x[1])) and repeat (or iterate) this operation to produce x[2], then
    x[3], ... , until it converges.
  prefs: []
  type: TYPE_NORMAL
- en: 'This in the old days was so horribly boring a procedure that it could not be
    inflicted on students. Now it is duck soup for a spreadsheet, and can be set up
    and computed in a matter of minutes for all the inverse functions we encounter:
    which are the roots (x^(1/j)), the (natural) logarithm, arcsin and arctan.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What has to be done?**'
  prefs: []
  type: TYPE_NORMAL
- en: The linear approximation fLx[j] defined at x[j] evaluated at x is given by
  prefs: []
  type: TYPE_NORMAL
- en: '**fLx[j](x) = f(x[j]) + f ''(x[j]) (x - x[j])**'
  prefs: []
  type: TYPE_NORMAL
- en: setting this up, setting
  prefs: []
  type: TYPE_NORMAL
- en: '**x[j+1] = f ^(-1) (fLx[j](x))**'
  prefs: []
  type: TYPE_NORMAL
- en: and iterating is all that need be done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**12.1 Set up a general root finding spreadsheet so that you can input x and
    j and it will spit out the j-th root of x by using this method where the machine
    only computes integer powers. (Clues on how to do this are in the next section.)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**12.2 Set up a spreadsheet to find ln x using the ability of the machine to
    compute exp x.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**12.3 Do the same for the inverse functions to the sine and tangent. These
    are generally written as something like arcsine and arctangent or asin or atan
    or something in between.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**12.4 Can this method fail? If so how?**'
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Spreadsheet Implementation of this Procedure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**How can you do such things?** First put x and j in fixed locations X and
    Y.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then set up the following columns on the spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f(x[j]):**'
  prefs: []
  type: TYPE_NORMAL
- en: In the first column enter the successive values of f(x[j]) starting with the
    first, known value.
  prefs: []
  type: TYPE_NORMAL
- en: For roots you can start with x[0]� = f(x[0]) = 1.
  prefs: []
  type: TYPE_NORMAL
- en: Compute later values f(x[j]) by using the linear approximation tangent line
    at x[j-1] evaluated at argument x, fLx[j-1](x) or f(x[j-1]) + f '(x[j-1]) (x-x[j-1]).
    (x[j-1] is the entry in the second column in the previous row.)
  prefs: []
  type: TYPE_NORMAL
- en: '**x[j]:**'
  prefs: []
  type: TYPE_NORMAL
- en: In the second column apply the inverse function, f ^(-1) to the value in the
    first column.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have entered your instructions for f(x[1]) and x[1], you can copy these
    down a hundred rows, and you are done.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if f is a root, x^(1/m)?
  prefs: []
  type: TYPE_NORMAL
- en: In general we have
  prefs: []
  type: TYPE_NORMAL
- en: '**f(x[j]) = fLx[j-1](x) = f(x[j-1]) + (x - x[j-1])f ''(x[j-1])**'
  prefs: []
  type: TYPE_NORMAL
- en: �For j-th root,� ![](../Images/c2394e979ecaeb208412b738fde18eb7.jpg) so that
    this formula reduces to
  prefs: []
  type: TYPE_NORMAL
- en: '**![](../Images/a9b395b296e9be92aa38e95785ece242.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: And that is all you need enter. The rest is copying down.
  prefs: []
  type: TYPE_NORMAL
