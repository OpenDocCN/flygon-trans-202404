- en: Higher-order functions and function literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a function that computes the sum of the integers from \(a\) to \(b\)
    ([higher1.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/40-lambda/higher1.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is code to compute the sum of the cubes of the integers from \(a\)
    to \(b\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that sumInt and sumCubes are nearly identical—they only differ in the
    expression that is added to s in every iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: These two functions are special cases of computing the expression
  prefs: []
  type: TYPE_NORMAL
- en: \[ \sum_{i=a}^b f(i) \]for different choices of the function \(f\).
  prefs: []
  type: TYPE_NORMAL
- en: If mathematics has a notation for this kind of common expression, then so should
    computer science. We should be able to write a function sum that takes the function \(f\)
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, we can do this as follows: ([higher2.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/40-lambda/higher2.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the types of the three parameters: a and b are integers, but f has a more
    interesting type: (Int) -> Int. This type denotes a function from integers to
    integers. In general, the notation (A, B, ...) -> R denotes a function that takes
    arguments of types A, B, etc., and returns a result of type R.'
  prefs: []
  type: TYPE_NORMAL
- en: To call the function sum, we need to provide an argument value for the parameter f.
    Modern programming languages like Kotlin (and Scala, Swift, Java since Java 8,
    and C++ since C++11) make it possible to define a function without having to give
    it a name. This is called a function literal, an anonymous function, or a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that for other basic objects, we define "nameless" objects all the time:
    We do not need to name every string or every integer. For instance, we don''t
    have to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The value of an object written directly in the program is called a literal.
    For instance, writing 1234 is an integer literal, writing "CS109" is a string
    literal.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for function literals consists of braces containing the parameters,
    a right arrow, and some code to compute the result. For example, the function
    that raises an integer to its cube is written as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A function literal that computes the sum of two integers looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect of executing a function literal is to create a function object (without
    giving it a name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A function object exists on the heap, like every other object. We can assign
    a name to it, or store a reference to it in a collection or in another object.
    And, since it is a function object, we can call it like a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we create a function object and immediately call it with an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we assign a name to the function object and use that to call it with different
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we store several function objects in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Coming back to our function sum, we can now use it to compute the sum of integers
    and the sum of cubes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, in this case the compiler can determine the type of the arguments
    in the function literal automatically. The compiler knows that the last argument
    of sum is a function of type (Int) -> Int, and so it knows that the type of any
    function literal written as an argument should be of this type. Therefore we can
    omit the type in the function literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the tangle of closing parentheses at the end is a bit confusing,
    and so Kotlin has a nice convention: If the last argument in a function call is
    a function literal, we can write it after the closing parenthesis of the function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, another convention often simplifies the code: When a function literal
    has only one parameter, then we can omit the parameter and the right-arrow, and
    use the magic name it inside the function literal as the parameter: ([higher3.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/40-lambda/higher3.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions like sum are called higher-order functions because they take another
    function object as an argument: A higher-order function is a "meta-function" that
    works on other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher-order functions allow us to naturally express ideas where a function
    is part of the input to a problem, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: print a table of function values for a given function (see [table.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/40-lambda/table.kts))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: integrating a function numerically (see [table.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/40-lambda/integrate.kts))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: finding a fixed point of a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
