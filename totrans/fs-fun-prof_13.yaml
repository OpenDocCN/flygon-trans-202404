- en: The "Object-oriented programming in F#" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As has been stressed many times before, F# is fundamentally a functional language
    at heart, yet the OO features have been nicely integrated and do not have a "tacked-on"
    feeling. As a result, it is quite viable to use F# just as an OO language, as
    an alternative to C#, say.
  prefs: []
  type: TYPE_NORMAL
- en: In this series, we'll look at how F# supports object-oriented classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[Object-oriented programming in F#: Introduction](object-oriented-intro.html).
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classes](classes.html). .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Inheritance and abstract classes](inheritance.html). .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Interfaces](interfaces.html). .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Object expressions](object-expressions.html). .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Object-oriented programming in F#: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object-oriented programming in F#: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series, we'll look at how F# supports object-oriented classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Should you use object-oriented features at all?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As has been stressed many times before, F# is fundamentally a functional language
    at heart, yet the OO features have been nicely integrated and do not have a "tacked-on"
    feeling. As a result, it is quite viable to use F# just as an OO language, as
    an alternative to C#, say.
  prefs: []
  type: TYPE_NORMAL
- en: Whether to use the OO style or the functional style is, of course, up to you.
    Here are some arguments for and against.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reasons in favor of using OO features:'
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to do a direct port from C# without refactoring. (For more
    on this, there is a [entire series on how to port from C# to F#](porting-from-csharp.html).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to use F# primarily as an OO language, as an alternative to C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to integrate with other .NET languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reasons against using OO features:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are a beginner coming from an imperative language, classes can be a crutch
    that hinder your understanding of functional programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes do not have the convenient "out of the box" features that the "pure"
    F# data types have, such as built-in equality and comparison, pretty printing,
    etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and methods do not play well with the type inference system and higher
    order functions (see [discussion here](type-extensions.html#downsides-of-methods)),
    so using them heavily means that you are making it harder to benefit from the
    most powerful parts of F#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, the best approach is a hybrid one, primarily using pure F# types
    and functions to benefit from type inference, but occasionally using interfaces
    and classes when polymorphism is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the object-oriented features of F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do decide to use the object-oriented features of F#, the following series
    of posts should cover everything you need to know to be productive with classes
    and methods in F#.
  prefs: []
  type: TYPE_NORMAL
- en: First up, how to create classes!
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post and the next will cover the basics of creating and using classes and
    methods in F#.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like all other data types in F#, class definitions start with the `type`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The thing that distinguishes them from other types is that classes always have
    some parameters passed in when they are created -- the constructor -- and so there
    are *always parentheses after the class name*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, unlike other types, classes *must* have functions attached to them as
    members. This post will explain how you do this for classes, but for a general
    discussion of attaching functions to other types see [the post on type extensions](type-extensions.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, if we want to have a class called `CustomerName` that requires
    three parameters to construct it, it would be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare this with the C# equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that in the F# version, the primary constructor is embedded into
    the class declaration itself --- it is not a separate method. That is, the class
    declaration has the same parameters as the constructor, and the parameters automatically
    become immutable private fields that store the original values that were passed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in the above example, because we declared the `CustomerName` class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: therefore `firstName`, `middleInitial`, and `lastName` automatically became
    immutable private fields.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying types in the constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might not have noticed, but the `CustomerName` class defined above does
    not constrain the parameters to be strings, unlike the C# version. In general,
    type inference from usage will probably force the values to be strings, but if
    you do need to specify the types explicitly, you can do so in the usual way with
    a colon followed by the type name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a version of the class with explicit types in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'One little quirk about F# is that if you ever need to pass a tuple as a parameter
    to a constructor, you will have to annotate it explicitly, because the call to
    the constructor will look identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Class members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example class above has three read-only instance properties. In F#, both
    properties and methods use the `member` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the example above, you see the word "`this`" in front of each member
    name. This is a "self-identifier" that can be used to refer to the current instance
    of the class. Every non-static member must have a self-identifier, even it is
    not used (as in the properties above). There is no requirement to use a particular
    word, just as long as it is consistent. You could use "this" or "self" or "me"
    or any other word that commonly indicates a self reference.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding class signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a class is compiled (or when you over hover the definition in the editor),
    you see the "class signature" for the class. For example, for the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'the corresponding signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The class signature contains the signatures for all the constructors, methods
    and properties in the class. It is worth understanding what these signatures mean,
    because, just as with functions, you can understand what the class does by looking
    at them. It is also important because you will need to write these signatures
    when creating abstract methods and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Method signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Method signatures such as are very similar to the [signatures for standalone
    functions](how-types-work-with-functions.html), except that the parameter names
    are part of the signature itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in this case, the method signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And for comparison, the corresponding signature for a standalone function would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Constructor signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constructor signatures are always called `new`, but other than that, they look
    like a method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor signatures always take tuple values as their only parameter. In
    this case the tuple type is `int * string`, as you would expect. The return type
    is the class itself, again as you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we can compare the constructor signature with a similar standalone function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Property signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, property signatures such as `member Two : int` are very similar to
    the signatures for standalone simple values, except that no explicit value is
    given.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Private fields and functions using "let" bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the class declaration, you can optionally have a set of "let" bindings,
    typically used for defining private fields and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some sample code to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example above, there are three let bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`privateValue` is set to the initial seed plus 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutableValue` is set to 42'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `privateAddToSeed` function uses the initial seed plus a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because they are let bindings, they are automatically private, so to access
    them externally, there must be a public member to act as a wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `seed` value passed into the constructor is also available as
    a private field, just like the let-bound values.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable constructor parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, you want a parameter passed to the constructor to be mutable. You
    cannot specify this in the parameter itself, so the standard technique is to create
    a mutable let-bound value and assign it from the parameter, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases, like this, it is quite common to give the mutable value the same
    name as the parameter itself, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Additional constructor behavior with "do" blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `CustomerName` example earlier, the constructor just allowed some values
    to be passed in but didn't do anything else. However, in some cases, you might
    need to execute some code as part of the constructor. This is done using `do`
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The "do" code can also call any let-bound functions defined before it, as shown
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the instance via "this" in a do block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the differences between the "do" and "let" bindings is that the "do"
    bindings can access the instance while "let" bindings cannot. This is because
    "let" bindings are actually evaluated before the constructor itself (similar to
    field initializers in C#), so the instance in a sense does not exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to call members of the instance from a "do" block, you need some
    way to refer to the instance itself. This is again done using a "self-identifier",
    but this time it is attached to the class declaration itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In general though, it is not best practice to call members from constructors
    unless you have to (e.g. calling a virtual method). Better to call private let-bound
    functions, and if necessary, have the public members call those same private functions.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method definition is very like a function definition, except that it has the
    `member` keyword and the self-identifier instead of just the `let` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can see that, just like normal functions, methods can have parameters, call
    other methods, and be parameterless (or to be precise, take a [unit parameter](how-types-work-with-functions.html#parameterless-functions))
  prefs: []
  type: TYPE_NORMAL
- en: Tuple form vs. curried form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike normal functions, methods with more than one parameter can be defined
    in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The curried form, where parameters are separated with spaces, and partial application
    is supported. (Why "curried"? See the [explanation of currying](currying.html).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tuple form, where all the parameters as passed in at the same time, comma-separated,
    in a single tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The curried approach is more functional, and the tuple approach is more object-oriented.
    Here is an example class with a method for each approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So which approach should you use?
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of tuple form are:'
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with other .NET code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports named parameters and optional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports method overloads (multiple methods with the same name that differ only
    in their function signature)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the disadvantages of tuple form are:'
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't support partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't work well with higher order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't work well with type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more detailed discussion on tuple form vs. curried form see the post on
    [type extensions](type-extensions.html#tuple-form).
  prefs: []
  type: TYPE_NORMAL
- en: Let- bound functions in conjunction with class methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common pattern is to create let-bound functions that do all the heavy lifting,
    and then have the public methods call these internal functions directly. This
    has the benefit that the type inference works much better with functional-style
    code than with methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For more details on how to do this, see [this discussion](type-extensions.html#attaching-existing-functions).
  prefs: []
  type: TYPE_NORMAL
- en: Recursive methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike normal let-bound functions, methods that are recursive do not need the
    special `rec` keyword. Here''s the boringly familiar Fibonacci function as a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Type annotation for methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, the types for a method''s parameters and return value can normally
    be inferred by the compiler, but if you need to specify them, you do so in the
    same way that you would for a standard function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Properties can be divided into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable properties, where there is a "get" but no "set".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable properties, where there is a "get" and also a (possibly private) "set".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write-only properties, where there is a "set" but no "get". These are so unusual
    that I won't discuss them here, but the MSDN documentation describes the syntax
    if you ever need it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax for immutable and mutable properties is slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: For immutable properties, the syntax is simple. There is a "get" member that
    is similar to a standard "let" value binding. The expression on the right-hand
    side of the binding can be any standard expression, typically a combination of
    the constructor parameters, private let-bound fields, and private functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For mutable properties however, the syntax is more complicated. You need to
    provide two functions, one to get and one to set. This is done by using the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To make the set function private, use the keywords `private set` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting in VS2012, F# supports automatic properties, which remove the requirement
    to create a separate backing store for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an immutable auto property, use the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a mutable auto property, use the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this syntax there is a new keyword `val` and the self-identifier
    has gone.
  prefs: []
  type: TYPE_NORMAL
- en: Complete property example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s a complete example that demonstrates all the property types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Properties vs. parameterless methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point you might be confused by the difference between properties and
    parameterless methods. They look identical at first glance, but there is a subtle
    difference -- "parameterless" methods are not really parameterless; they always
    have a unit parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of the difference in both definition and usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can also tell the difference by looking at the signature of the class definition
  prefs: []
  type: TYPE_NORMAL
- en: 'The class definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The method has signature `MyFunc : unit -> int` and the property has signature
    `MyProp : int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very similar to what the signatures would be if the function and property
    were declared standalone, outside of any class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The signatures for these would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: which is almost exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unclear on the difference and why the unit parameter is needed for
    the function, please read the [discussion of parameterless methods](how-types-work-with-functions.html#parameterless-functions).
  prefs: []
  type: TYPE_NORMAL
- en: Secondary constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the primary constructor embedded in its declaration, a class
    can have additional constructors. These are indicated by the `new` keyword and
    must call the primary constructor as their last expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Static members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as in C#, classes can have static members, and this is indicated with the
    `static` keyword. The `static` modifier comes before the member keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Members which are static cannot have a self-identifier such as "this" because
    there is no instance for them to refer to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Static constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no direct equivalent of a static constructor in F#, but you can create
    static let-bound values and static do-blocks that are executed when the class
    is first used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Accessibility of members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can control the accessibility of a member with the standard .NET keywords
    `public`, `private` and `internal`. The accessibility modifiers come after the
    `member` keyword and before the member name.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C#, all class members are public by default, not private. This includes
    both properties and methods. However, non-members (e.g. let declarations) are
    private and cannot be made public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For properties, if the set and get have different accessibilities, you can tag
    each part with a separate accessibility modifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In practice, the "public get, private set" combination that is so common in
    C# is not generally needed in F#, because immutable properties can be defined
    more elegantly, as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: defining classes for use by other .NET code'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are defining classes that need to interop with other .NET code, do not
    define them inside a module! Define them in a namespace instead, outside of any
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that F# modules are exposed as static classes, and any
    F# classes defined inside a module are then defined as nested classes within the
    static class, which can mess up your interop. For example, some unit test runners
    don't like static classes.
  prefs: []
  type: TYPE_NORMAL
- en: F# classes which are defined outside a module are generated as normal top-level
    .NET classes, which is probably what you want. But remember that (as discussed
    in a [previous post](organizing-functions.html)) if you don't declare a namespace
    specifically, your class will be placed in an automatically generated module,
    and will be nested without your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of two F# classes, one defined outside a module and one
    defined inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s how the same code might look in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Constructing and using a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have defined the class, how do we go about using it?
  prefs: []
  type: TYPE_NORMAL
- en: One way to create an instance of a class is straightfoward and just like C#
    -- use the `new` keyword and pass in the arguments to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in F#, the constructor is considered to be just another function,
    so you can normally eliminate the `new` and call the constructor function on its
    own, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the case when you are creating a class that implements `IDisposible`, you
    will get a compiler warning if you do not use `new`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This can be a useful reminder to use the `use` keyword instead of the `let`
    keyword for disposables. See [the post on `use`](let-use-do.html#use) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods and properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And once you have an instance, you can "dot into" the instance and use any methods
    and properties in the standard way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We have seen many examples of member usage in the above discussion, and there's
    not too much to say about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that, as discussed above, tuple-style methods and curried-style methods
    can be called in distinct ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance and abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance and abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a follow-on from the [previous post on classes](classes.html). This
    post will focus on inheritance in F#, and how to define and use abstract classes
    and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To declare that a class inherits from another class, use the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `inherit` keyword signals that `DerivedClass` inherits from `BaseClass`.
    In addition, some `BaseClass` constructor must be called at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: It might be useful to compare F# with C# at this point. Here is some C# code
    for a very simple pair of classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the inheritance declaration `class MyDerivedClass: MyBaseClass` is
    distinct from the constructor which calls `base(param1)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here is the F# version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Unlike C#, the inheritance part of the declaration, `inherit BaseClass(param1)`,
    contains both the class to inherit from *and* its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract and virtual methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obviously, part of the point of inheritance is to be able to have abstract methods,
    virtual methods, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Defining abstract methods in the base class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C#, an abstract method is indicated by the `abstract` keyword plus the method
    signature. In F#, it is the same concept, except that the way that function signatures
    are written in F# is quite different from C#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'So to define an abstract method, we use the signature syntax, along with the
    `abstract member` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the equals sign has been replaced with a colon. This is what you
    would expect, as the equals sign is used for binding values, while the colon is
    used for type annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you try to compile the code above, you will get an error! The compiler
    will complain that there is no implementation for the method. To fix this, you
    need to:'
  prefs: []
  type: TYPE_NORMAL
- en: provide a default implementation of the method, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tell the compiler that the class as whole is also abstract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at both of these alternatives shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Defining abstract properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract immutable property is defined in a similar way. The signature is
    just like that of a simple value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the abstract property is read/write, you add the get/set keywords.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Default implementations (but no virtual methods)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To provide a default implementation of an abstract method in the base class,
    use the `default` keyword instead of the `member` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the default method is defined in the usual way, except for
    the use of `default` instead of `member`.
  prefs: []
  type: TYPE_NORMAL
- en: One major difference between F# and C# is that in C# you can combine the abstract
    definition and the default implementation into a single method, using the `virtual`
    keyword. In F#, you cannot. You must declare the abstract method and the default
    implementation separately. The `abstract member` has the signature, and the `default`
    has the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If at least one abstract method does *not* have a default implementation, then
    the entire class is abstract, and you must indicate this by annotating it with
    the `AbstractClass` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If this is done, then the compiler will no longer complain about a missing implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods in subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To override an abstract method or property in a subclass, use the `override`
    keyword instead of the `member` keyword. Other than that change, the overridden
    method is defined in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: And to call a base method, use the `base` keyword, just as in C#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Summary of abstract methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Abstract methods are basically straightforward and similar to C#. There are
    only two areas that might be tricky if you are used to C#:'
  prefs: []
  type: TYPE_NORMAL
- en: You must understand how function signatures work and what their syntax is! For
    a detailed discussion see the [post on function signatures](function-signatures.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no all-in-one virtual method. You must define the abstract method and
    the default implementation separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are available and fully supported in F#, but there are number of
    important ways in which their usage differs from what you might be used to in
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining an interface is similar to defining an abstract class. So similar,
    in fact, that you might easily get them confused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the definition for the equivalent abstract base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: So what's the difference? As usual, all abstract members are defined by signatures
    only. The only difference seems to be the lack of the `[<AbstractClass>]` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: But in the earlier discussion on abstract methods, we stressed that the `[<AbstractClass>]`
    attribute was required; the compiler would complain that the methods have no implementation
    otherwise. So how does the interface definition get away with it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is trivial, but subtle. *The interface has no constructor*. That
    is, it does not have any parentheses after the interface name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Removing the parens will convert a class definition into an interface!
  prefs: []
  type: TYPE_NORMAL
- en: Explicit and implicit interface implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes time to implement an interface in a class, F# is quite different
    from C#. In C#, you can add a list of interfaces to the class definition and implement
    the interfaces implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Not so in F#. In F#, all interfaces must be *explicitly* implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In an explicit interface implementation, the interface members can only be accessed
    through an interface instance (e.g. by casting the class to the interface type).
    The interface members are not visible as part of the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: C# has support for both explicit and implicit interface implementations, but
    almost always, the implicit approach is used, and many programmers are not even
    aware of [explicit interfaces in C#](http://msdn.microsoft.com/en-us/library/ms173157.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces in F#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, how do you implement an interface in F#? You cannot just "inherit" from
    it, as you would an abstract base class. You have to provide an explicit implementation
    for each interface member using the syntax `interface XXX with`, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The above code shows how the class `MyAddingService` explicitly implements the
    `IAddingService` and the `IDisposable` interfaces. After the required `interface
    XXX with` section, the members are implemented in the normal way.
  prefs: []
  type: TYPE_NORMAL
- en: (As an aside, note again that `MyAddingService()` has a constructor, while `IAddingService`
    does not.)
  prefs: []
  type: TYPE_NORMAL
- en: Using interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now let''s try to use the adding service interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately, we run into an error. It appears that the instance does not implement
    the `Add` method at all. Of course, what this really means is that we must cast
    it to the interface first using the `:>` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This might seem incredibly awkward, but in practice it is not a problem as in
    most cases the casting is done implicitly for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you will typically be passing an instance to a function that specifies
    an interface parameter. In this case, the casting is done automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the special case of `IDisposable`, the `use` keyword will also automatically
    cast the instance as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Object expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So as we saw in the [previous post](interfaces.html), implementing interfaces
    in F# is a bit more awkward than in C#. But F# has a trick up its sleeve, called
    "object expressions".
  prefs: []
  type: TYPE_NORMAL
- en: With object expressions, you can implement an interface on-the-fly, without
    having to create a class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces with object expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Object expressions are most commonly used to implement interfaces. To do this,
    you use the syntax `new MyInterface with ...`, and the wrap the whole thing in
    curly braces (one of the few uses for them in F#!)
  prefs: []
  type: TYPE_NORMAL
- en: Here is some example code that creates a number of objects, each of which implements
    `IDisposable`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If you execute this code, you will see the output below. You can see that `Dispose()`
    is indeed being called when the objects go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We can take the same approach with the `IAddingService` and create one on the
    fly as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Object expressions are extremely convenient, and can greatly reduce the number
    of classes you need to create if you are interacting with an interface heavy library.
  prefs: []
  type: TYPE_NORMAL
