- en: IndPropInductively Defined Propositions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export Logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '------  (ev_0)'
  prefs: []
  type: TYPE_NORMAL
- en: ev 0
  prefs: []
  type: TYPE_NORMAL
- en: '------ (ev_SS)'
  prefs: []
  type: TYPE_NORMAL
- en: ev 2
  prefs: []
  type: TYPE_NORMAL
- en: '------ (ev_SS)'
  prefs: []
  type: TYPE_NORMAL
- en: ev 4
  prefs: []
  type: TYPE_NORMAL
- en: Why call this a "tree" (rather than a "stack", for example)?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because, in general, inference rules can have multiple premises.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will see examples of this below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Putting all of this together, we can translate the definition of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evenness into a formal Coq definition using an Inductive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: declaration, where each constructor corresponds to an inference
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'rule:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This definition is different in one crucial respect from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'previous uses of Inductive: its result is not a Type, but'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rather a function from nat to Prop — that is, a property of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: numbers.  Note that we've already seen other inductive definitions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that result in functions, such as list, whose type is Type → Type.  What is
    new here is that, because the nat argument of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ev appears *unnamed*, to the *right* of the colon, it is allowed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'to take different values in the types of different constructors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0 in the type of ev_0 and S (S n) in the type of ev_SS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In contrast, the definition of list names the X parameter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*globally*, to the *left* of the colon, forcing the result of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nil and cons to be the same (list X).  Had we tried to bring
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'nat to the left in defining ev, we would have seen an error:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ("Parameter" here is Coq jargon for an argument on the left of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: colon in an Inductive definition; "index" is used to refer to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arguments on the right of the colon.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can think of the definition of ev as defining a Coq property
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ev : nat → Prop, together with theorems ev_0 : ev 0 and'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ev_SS : ∀ n, ev n → ev (S (S n)).  Such "constructor'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: theorems" have the same status as proven theorems.  In particular,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we can use Coq's apply tactic with the rule names to prove ev
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for particular numbers...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '... or we can use function application syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can also prove theorems that have hypotheses involving ev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, we can show that any number multiplied by 2 is even:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (ev_double)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ev_minus2 : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: ev n → ev (pred (pred n)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n E.
  prefs: []
  type: TYPE_NORMAL
- en: inversion E as [| n' E'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E = ev_0 *) simpl. apply ev_0.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E = ev_SS n'' E'' *) simpl. apply E''. Qed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ev_minus2'' : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: ev n → ev (pred (pred n)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n E.
  prefs: []
  type: TYPE_NORMAL
- en: destruct E as [| n' E'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E = ev_0 *) simpl. apply ev_0.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E = ev_SS n'' E'' *) simpl. apply E''. Qed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem evSS_ev : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: ev (S (S n)) → ev n.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n E.
  prefs: []
  type: TYPE_NORMAL
- en: destruct E as [| n' E'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E = ev_0. *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* We must prove that n is even from no assumptions! *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem evSS_ev : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: ev (S (S n)) → ev n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n E.
  prefs: []
  type: TYPE_NORMAL
- en: inversion E as [| n' E'].
  prefs: []
  type: TYPE_NORMAL
- en: (* We are in the E = ev_SS n' E' case now. *)
  prefs: []
  type: TYPE_NORMAL
- en: apply E'.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem one_not_even : ¬ ev 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros H. inversion H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem SSSSev__even : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: ev (S (S (S (S n)))) → ev n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem even5_nonsense :'
  prefs: []
  type: TYPE_NORMAL
- en: ev 5 → 2 + 2 = 9.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma ev_even_firsttry : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: ev n → ∃k, n = double k.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: intros n E. inversion E as [| n' E'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E = ev_0 *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃0\. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E = ev_SS n'' E'' *) simpl.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: ∃k', n' = double k',
  prefs: []
  type: TYPE_NORMAL
- en: which is the same as the original statement, but with n' instead
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of n.  Indeed, it is not difficult to convince Coq that this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intermediate result suffices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Induction on Evidence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If this looks familiar, it is no coincidence: We''ve encountered'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: similar problems in the [Induction](Induction.html) chapter, when trying to
    use
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: case analysis to prove results that required induction.  And once
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: again the solution is... induction!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The behavior of induction on evidence is the same as its
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'behavior on data: It causes Coq to generate one subgoal for each'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructor that could have used to build that evidence, while
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: providing an induction hypotheses for each recursive occurrence of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the property in question.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try our current lemma again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that Coq produced an IH that corresponds to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E', the single recursive occurrence of ev in its own
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition.  Since E' mentions n', the induction hypothesis
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: talks about n', as opposed to n or some other number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The equivalence between the second and third definitions of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evenness now follows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we will see in later chapters, induction on evidence is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: recurring technique across many areas, and in particular when
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: formalizing the semantics of programming languages, where many
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: properties of interest are defined inductively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The following exercises provide simple examples of this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: technique, to help you familiarize yourself with it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (ev_sum)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 stars, advanced, optional (ev_alternate)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In general, there may be multiple ways of defining a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: property inductively.  For example, here's a (slightly contrived)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'alternative definition for ev:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Prove that this definition is logically equivalent to the old
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: one.  (You may want to look at the previous theorem when you get
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to the induction step.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced, recommended (ev_ev__ev)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finding the appropriate thing to do induction on is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'bit tricky here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (ev_plus_plus)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This exercise just requires applying existing lemmas.  No
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction or even case analysis is needed, though some of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rewriting may be tedious.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Module Playground.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive le : nat → nat → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| le_n : ∀n, le n n'
  prefs: []
  type: TYPE_NORMAL
- en: '| le_S : ∀n m, (le n m) → (le n (S m)).'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "m ≤ n" := (le m n).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem test_le[1] :'
  prefs: []
  type: TYPE_NORMAL
- en: 3 ≤ 3.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: apply le_n. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem test_le[2] :'
  prefs: []
  type: TYPE_NORMAL
- en: 3 ≤ 6.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: apply le_S. apply le_S. apply le_S. apply le_n. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem test_le[3] :'
  prefs: []
  type: TYPE_NORMAL
- en: (2 ≤ 1) → 2 + 2 = 5.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: intros H. inversion H. inversion H[2]. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: End Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Definition lt (n m:nat) := le (S n) m.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "m < n" := (lt m n).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive square_of : nat → nat → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| sq : ∀n:nat, square_of n (n * n).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive next_nat : nat → nat → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| nn : ∀n:nat, next_nat n (S n).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive next_even : nat → nat → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ne_1 : ∀n, ev (S n) → next_even n (S n)'
  prefs: []
  type: TYPE_NORMAL
- en: '| ne_2 : ∀n, ev (S (S n)) → next_even n (S (S n)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma le_trans : ∀m n o, m ≤ n → n ≤ o → m ≤ o.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem O_le_n : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: 0 ≤ n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem n_le_m__Sn_le_Sm : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: n ≤ m → S n ≤ S m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem Sn_le_Sm__n_le_m : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: S n ≤ S m → n ≤ m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem le_plus_l : ∀a b,'
  prefs: []
  type: TYPE_NORMAL
- en: a ≤ a + b.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem plus_lt : ∀n[1] n[2] m,'
  prefs: []
  type: TYPE_NORMAL
- en: n[1] + n[2] < m →
  prefs: []
  type: TYPE_NORMAL
- en: n[1] < m ∧ n[2] < m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: unfold lt.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem lt_S : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: n < m →
  prefs: []
  type: TYPE_NORMAL
- en: n < S m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem leb_complete : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: leb n m = true → n ≤ m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem leb_correct : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: n ≤ m →
  prefs: []
  type: TYPE_NORMAL
- en: leb n m = true.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem leb_true_trans : ∀n m o,'
  prefs: []
  type: TYPE_NORMAL
- en: leb n m = true → leb m o = true → leb n o = true.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem leb_iff : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: leb n m = true ↔ n ≤ m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Module R.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive R : nat → nat → nat → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| c[1] : R 0 0 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| c[2] : ∀m n o, R m n o → R (S m) n (S o)'
  prefs: []
  type: TYPE_NORMAL
- en: '| c[3] : ∀m n o, R m n o → R m (S n) (S o)'
  prefs: []
  type: TYPE_NORMAL
- en: '| c[4] : ∀m n o, R (S m) (S n) (S (S o)) → R m n o'
  prefs: []
  type: TYPE_NORMAL
- en: '| c[5] : ∀m n o, R m n o → R n m o.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition fR : nat → nat → nat'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem R_equiv_fR : ∀m n o, R m n o ↔ fR m n = o.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: End R.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[1;2;3]'
  prefs: []
  type: TYPE_NORMAL
- en: is a subsequence of each of the lists
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[1;2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1;3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[5;6;2;1;7;3;8].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an inductive proposition subseq on list nat that captures what it means
    to be a subsequence. (Hint: You''ll need three cases.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prove subseq_refl that subsequence is reflexive, that is, any list is a subsequence
    of itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prove subseq_app that for any lists l[1], l[2], and l[3], if l[1] is a subsequence
    of l[2], then l[1] is also a subsequence of l[2] ++ l[3].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Optional, harder) Prove subseq_trans that subsequence is transitive — that
    is, if l[1] is a subsequence of l[2] and l[2] is a subsequence of l[3], then l[1]
    is a subsequence of l[3]. Hint: choose your induction carefully!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optionalM (R_provability2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we give Coq the following definition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Case Study: Regular Expressions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ev property provides a simple example for illustrating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inductive definitions and the basic techniques for reasoning about
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: them, but it is not terribly exciting — after all, it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equivalent to the two non-inductive of evenness that we had
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: already seen, and does not seem to offer any concrete benefit over
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: them.  To give a better sense of the power of inductive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions, we now show how to use them to model a classic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'concept in computer science: *regular expressions*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Regular expressions are a simple language for describing strings,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this definition is *polymorphic*: Regular'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions in reg_exp T describe strings with characters drawn
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from T — that is, lists of elements of T.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (We depart slightly from standard practice in that we do not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: require the type T to be finite.  This results in a somewhat
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: different theory of regular expressions, but the difference is not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: significant for our purposes.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We connect regular expressions and strings via the following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rules, which define when a regular expression *matches* some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'string:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The expression EmptySet does not match any string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression EmptyStr matches the empty string [].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression Char x matches the one-character string [x].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If re[1] matches s[1], and re[2] matches s[2], then App re[1] re[2] matches
    s[1] ++ s[2].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If at least one of re[1] and re[2] matches s, then Union re[1] re[2] matches
    s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if we can write some string s as the concatenation of a sequence of
    strings s = s_1 ++ ... ++ s_k, and the expression re matches each one of the strings
    s_i, then Star re matches s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a special case, the sequence of strings may be empty, so Star re always matches
    the empty string [] no matter what re is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can easily translate this informal definition into an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inductive one as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Again, for readability, we can also display this definition using
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inference-rule notation.  At the same time, let's introduce a more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: readable infix notation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (MEmpty)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[] =~ EmptyStr'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (MChar)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[x] =~ Char x'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s[1] =~ re[1]    s[2] =~ re[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (MApp)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s[1] ++ s[2] =~ App re[1] re[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s[1] =~ re[1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (MUnionL)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s[1] =~ Union re[1] re[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s[2] =~ re[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (MUnionR)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s[2] =~ Union re[1] re[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (MStar0)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[] =~ Star re'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s[1] =~ re    s[2] =~ Star re
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (MStarApp)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s[1] ++ s[2] =~ Star re
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that these rules are not *quite* the same as the informal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ones that we gave at the beginning of the section.  First, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: don't need to include a rule explicitly stating that no string
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: matches EmptySet; we just don't happen to include any rule that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: would have the effect of some string matching EmptySet.  (Indeed,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the syntax of inductive definitions doesn't even *allow* us to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: give such a "negative rule.")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Second, the informal rules for Union and Star correspond
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'to two constructors each: MUnionL / MUnionR, and MStar0 /'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MStarApp.  The result is logically equivalent to the original
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rules but more convenient to use in Coq, since the recursive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: occurrences of exp_match are given as direct arguments to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors, making it easier to perform induction on evidence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (The exp_match_ex[1] and exp_match_ex[2] exercises below ask you
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to prove that the constructors given in the inductive declaration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and the ones that would arise from a more literal transcription of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the informal rules are indeed equivalent.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's illustrate these rules with a few examples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: (Notice how the last example applies MApp to the strings [1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and [2] directly.  Since the goal mentions [1; 2] instead of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1] ++ [2], Coq wouldn''t be able to figure out how to split the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: string on its own.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using inversion, we can also show that certain strings do *not*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'match a regular expression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can define helper functions to help write down regular
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions. The reg_exp_of_list function constructs a regular
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expression that matches exactly the list that it receives as an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'argument:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We can also prove general facts about exp_match.  For instance,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the following lemma shows that every string s that matches re
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: also matches Star re.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: (Note the use of app_nil_r to change the goal of the theorem to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: exactly the same shape expected by MStarApp.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (exp_match_ex[1])'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following lemmas show that the informal matching rules given
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: at the beginning of the chapter can be obtained from the formal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inductive definition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The next lemma is stated in terms of the fold function from the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Poly](Poly.html) chapter: If ss : list (list T) represents a sequence of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: strings s[1], ..., sn, then fold app ss [] is the result of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: concatenating them all together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 stars (reg_exp_of_list)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove that reg_exp_of_list satisfies the following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'specification:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since the definition of exp_match has a recursive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: structure, we might expect that proofs involving regular
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions will often require induction on evidence.  For
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example, suppose that we wanted to prove the following intuitive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: If a regular expression re matches some string s, then'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all elements of s must occur somewhere in re.  To state this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: theorem, we first define a function re_chars that lists all
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'characters that occur in a regular expression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then phrase our theorem as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Something interesting happens in the MStarApp case.  We obtain
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*two* induction hypotheses: One that applies when x occurs in'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: s[1] (which matches re), and a second one that applies when x
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: occurs in s[2] (which matches Star re).  This is a good
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: illustration of why we need induction on evidence for exp_match,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'as opposed to re: The latter would only provide an induction'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypothesis for strings that match re, which would not allow us
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to reason about the case In x s[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 4 stars (re_not_empty)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a recursive function re_not_empty that tests whether a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: regular expression matches some string. Prove that your function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The remember Tactic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One potentially confusing feature of the induction tactic is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that it happily lets you try to set up an induction over a term
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that isn't sufficiently general.  The effect of this is to lose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: information (much as destruct can do), and leave you unable to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'complete the proof.  Here''s an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Just doing an inversion on H[1] won't get us very far in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: recursive cases. (Try it!). So we need induction. Here is a naive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'first attempt:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: But now, although we get seven cases (as we would expect from the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition of exp_match), we have lost a very important bit of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'information from H[1]: the fact that s[1] matched something of the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: form Star re.  This means that we have to give proofs for *all*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: seven constructors of this definition, even though all but two of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: them (MStar0 and MStarApp) are contradictory.  We can still
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get the proof to go through for a few constructors, such as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MEmpty...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '... but most cases get stuck.  For MChar, for instance, we'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: must show that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '- (* MChar. Stuck... *)'
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma star_app: ∀T (s[1] s[2] : list T) (re re'' : reg_exp T),'
  prefs: []
  type: TYPE_NORMAL
- en: s[1] =~ re' →
  prefs: []
  type: TYPE_NORMAL
- en: re' = Star re →
  prefs: []
  type: TYPE_NORMAL
- en: s[2] =~ Star re →
  prefs: []
  type: TYPE_NORMAL
- en: s[1] ++ s[2] =~ Star re.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma star_app: ∀T (s[1] s[2] : list T) (re : reg_exp T),'
  prefs: []
  type: TYPE_NORMAL
- en: s[1] =~ Star re →
  prefs: []
  type: TYPE_NORMAL
- en: s[2] =~ Star re →
  prefs: []
  type: TYPE_NORMAL
- en: s[1] ++ s[2] =~ Star re.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros T s[1] s[2] re H[1].
  prefs: []
  type: TYPE_NORMAL
- en: remember (Star re) as re'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: generalize dependent s[2].
  prefs: []
  type: TYPE_NORMAL
- en: induction H[1]
  prefs: []
  type: TYPE_NORMAL
- en: as [|x'|s[1] re[1] s[2]' re[2] Hmatch1 IH[1] Hmatch2 IH[2]
  prefs: []
  type: TYPE_NORMAL
- en: '|s[1] re[1] re[2] Hmatch IH|re[1] s[2]'' re[2] Hmatch IH'
  prefs: []
  type: TYPE_NORMAL
- en: '|re''''|s[1] s[2]'' re'''' Hmatch1 IH[1] Hmatch2 IH[2]].'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '- (* MEmpty *)  inversion Heqre''.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* MChar *)   inversion Heqre''.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* MApp *)    inversion Heqre''.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* MUnionL *) inversion Heqre''.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* MUnionR *) inversion Heqre''.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '- (* MStar0 *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqre'. intros s H. apply H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* MStarApp *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqre'. rewrite H[0] in IH[2], Hmatch1.
  prefs: []
  type: TYPE_NORMAL
- en: intros s[2] H[1]. rewrite ← app_assoc.
  prefs: []
  type: TYPE_NORMAL
- en: apply MStarApp.
  prefs: []
  type: TYPE_NORMAL
- en: + apply Hmatch1.
  prefs: []
  type: TYPE_NORMAL
- en: + apply IH[2].
  prefs: []
  type: TYPE_NORMAL
- en: '* reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '* apply H[1].'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma MStar'''' : ∀T (s : list T) (re : reg_exp T),'
  prefs: []
  type: TYPE_NORMAL
- en: s =~ Star re →
  prefs: []
  type: TYPE_NORMAL
- en: '∃ss : list (list T),'
  prefs: []
  type: TYPE_NORMAL
- en: s = fold app ss []
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ∀s', In s' ss → s' =~ re.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Module Pumping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint pumping_constant {T} (re : reg_exp T) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match re with
  prefs: []
  type: TYPE_NORMAL
- en: '| EmptySet ⇒ 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| EmptyStr ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| Char _ ⇒ 2'
  prefs: []
  type: TYPE_NORMAL
- en: '| App re[1] re[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: pumping_constant re[1] + pumping_constant re[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| Union re[1] re[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: pumping_constant re[1] + pumping_constant re[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| Star _ ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint napp {T} (n : nat) (l : list T) : list T :='
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ []'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ l ++ napp n'' l'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma napp_plus: ∀T (n m : nat) (l : list T),'
  prefs: []
  type: TYPE_NORMAL
- en: napp (n + m) l = napp n l ++ napp m l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros T n m l.
  prefs: []
  type: TYPE_NORMAL
- en: induction n as [|n IHn].
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- simpl. rewrite IHn, app_assoc. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma pumping : ∀T (re : reg_exp T) s,'
  prefs: []
  type: TYPE_NORMAL
- en: s =~ re →
  prefs: []
  type: TYPE_NORMAL
- en: pumping_constant re ≤ length s →
  prefs: []
  type: TYPE_NORMAL
- en: ∃s[1] s[2] s[3],
  prefs: []
  type: TYPE_NORMAL
- en: s = s[1] ++ s[2] ++ s[3] ∧
  prefs: []
  type: TYPE_NORMAL
- en: s[2] ≠ [] ∧
  prefs: []
  type: TYPE_NORMAL
- en: ∀m, s[1] ++ napp m s[2] ++ s[3] =~ re.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros T re s Hmatch.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hmatch
  prefs: []
  type: TYPE_NORMAL
- en: as [ | x | s[1] re[1] s[2] re[2] Hmatch1 IH[1] Hmatch2 IH[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| s[1] re[1] re[2] Hmatch IH | re[1] s[2] re[2] Hmatch IH'
  prefs: []
  type: TYPE_NORMAL
- en: '| re | s[1] s[2] re Hmatch1 IH[1] Hmatch2 IH[2] ].'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* MEmpty *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. omega.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: End Pumping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Case Study: Improving Reflection'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen in the [Logic](Logic.html) chapter that we often need to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relate boolean computations to statements in Prop.  But
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: performing this conversion in the way we did it there can result
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in tedious proof scripts.  Consider the proof of the following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'theorem:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In the first branch after destruct, we explicitly apply
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the beq_nat_true_iff lemma to the equation generated by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: destructing beq_nat n m, to convert the assumption beq_nat n m = true into the
    assumption n = m; then we had to rewrite
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using this assumption to complete the case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can streamline this by defining an inductive proposition that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yields a better case-analysis principle for beq_nat n m.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Instead of generating an equation such as beq_nat n m = true,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which is generally not directly useful, this principle gives us
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'right away the assumption we really need: n = m.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We'll actually define something a bit more general, which can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'used with arbitrary properties (and not just equalities):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Before explaining this, let''s rearrange it a little: Since the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: types of both ReflectT and ReflectF begin with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ∀ (P:Prop), we can make the definition a bit more readable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and easier to work with by making P a parameter of the whole
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inductive declaration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The reflect property takes two arguments: a proposition'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P and a boolean b.  Intuitively, it states that the property
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'P is *reflected* in (i.e., equivalent to) the boolean b: P'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: holds if and only if b = true.  To see this, notice that, by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition, the only way we can produce evidence that reflect P true holds is
    by showing that P is true and using the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ReflectT constructor.  If we invert this statement, this means
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that it should be possible to extract evidence for P from a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof of reflect P true.  Conversely, the only way to show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reflect P false is by combining evidence for ¬ P with the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ReflectF constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is easy to formalize this intuition and show that the two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'statements are indeed equivalent:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, recommended (reflect_iff)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The advantage of reflect over the normal "if and only if"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: connective is that, by destructing a hypothesis or lemma of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: form reflect P b, we can perform case analysis on b while at
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the same time generating appropriate hypothesis in the two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: branches (P in the first subgoal and ¬ P in the second).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The new proof of filter_not_empty_In now goes as follows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice how the calls to destruct and apply are combined into a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: single call to destruct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (To see this clearly, look at the two proofs of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: filter_not_empty_In with Coq and observe the differences in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof state at the beginning of the first case of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: destruct.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, recommended (beq_natP_practice)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use beq_natP as above to prove the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This technique gives us only a small gain in convenience for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the proofs we've seen here, but using reflect consistently often
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: leads to noticeably shorter and clearer scripts as proofs get
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: larger.  We'll see many more examples in later chapters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The use of the reflect property was popularized by *SSReflect*,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a Coq library that has been used to formalize important results in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mathematics, including as the 4-color theorem and the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Feit-Thompson theorem.  The name SSReflect stands for *small-scale reflection*,
    i.e., the pervasive use of reflection to simplify
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: small proof steps with boolean computations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive nostutter {X:Type} : list X → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Example test_nostutter_1: nostutter [3;1;4;1;5;6].'
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: (*    Proof. repeat constructor; apply beq_nat_false_iff; auto.   Qed. *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_nostutter_2:  nostutter (@nil nat).'
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: (*    Proof. repeat constructor; apply beq_nat_false_iff; auto.   Qed. *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_nostutter_3:  nostutter [5].'
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: (*    Proof. repeat constructor; apply beq_nat_false; auto. Qed. *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_nostutter_4:      not (nostutter [3;1;1;4]).'
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: (*    Proof. intro.   repeat match goal with     h: nostutter _ |- _ => inversion h; clear h; subst
      end.   contradiction H[1]; auto. Qed. *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[1;4;6;2;3]'
  prefs: []
  type: TYPE_NORMAL
- en: is an in-order merge of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[4;3].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose we have a set X, a function test: X→bool, and a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: list l of type list X.  Suppose further that l is an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in-order merge of two lists, l[1] and l[2], such that every item
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in l[1] satisfies test and no item in l[2] satisfies test.  Then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: filter test l = l[1].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Translate this specification into a Coq theorem and prove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it.  (You'll need to begin by defining what it means for one list
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to be a merge of two others.  Do this with an inductive relation,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not a Fixpoint.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 5 stars, advanced, optional (filter_challenge_2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A different way to characterize the behavior of filter goes like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'this: Among all subsequences of l with the property that test'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evaluates to true on all their members, filter test l is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: longest.  Formalize this claim and prove it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 stars, optional (palindromes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A palindrome is a sequence that reads the same backwards as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: forwards.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define an inductive proposition pal on list X that captures what it means to
    be a palindrome. (Hint: You''ll need three cases. Your definition should be based
    on the structure of the list; just having a single constructor like'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Prove (pal_app_rev) that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Prove (pal_rev that)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 5 stars, optional (palindrome_converse)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Again, the converse direction is significantly more difficult, due
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to the lack of evidence.  Using your definition of pal from the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: previous exercise, prove that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: (* Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=    match l with    |  => False
       | x' :: l' => x' = x \/ In A x l'    end *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma in_split : ∀(X:Type) (x:X) (l:list X),'
  prefs: []
  type: TYPE_NORMAL
- en: In x l →
  prefs: []
  type: TYPE_NORMAL
- en: '∃l[1] l[2], l = l[1] ++ x :: l[2].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive repeats {X:Type} : list X → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem pigeonhole_principle: ∀(X:Type) (l[1]  l[2]:list X),'
  prefs: []
  type: TYPE_NORMAL
- en: excluded_middle →
  prefs: []
  type: TYPE_NORMAL
- en: (∀x, In x l[1] → In x l[2]) →
  prefs: []
  type: TYPE_NORMAL
- en: length l[2] < length l[1] →
  prefs: []
  type: TYPE_NORMAL
- en: repeats l[1].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros X l[1]. induction l[1] as [|x l[1]' IHl1'].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
