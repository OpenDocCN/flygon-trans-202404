- en: IndPropInductively Defined Propositions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IndPropInductively Defined Propositions
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Export Logic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要导出逻辑。
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '------  (ev_0)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '------  (ev_0)'
- en: ev 0
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ev 0
- en: '------ (ev_SS)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '------ (ev_SS)'
- en: ev 2
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ev 2
- en: '------ (ev_SS)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '------ (ev_SS)'
- en: ev 4
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ev 4
- en: Why call this a "tree" (rather than a "stack", for example)?
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么称之为“树”（而不是“栈”，例如）？
- en: Because, in general, inference rules can have multiple premises.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为一般来说，推断规则可以有多个前提。
- en: We will see examples of this below.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在下面看到示例。
- en: Putting all of this together, we can translate the definition of
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们可以将 ev 的定义翻译为
- en: evenness into a formal Coq definition using an Inductive
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用归纳定义将偶数性（evenness）形式化为 Coq 定义。
- en: declaration, where each constructor corresponds to an inference
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明，其中每个构造函数对应于一个推断
- en: 'rule:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规则：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This definition is different in one crucial respect from
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个定义在一个关键方面与之不同
- en: 'previous uses of Inductive: its result is not a Type, but'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Inductive 的先前用法：其结果不是一个 Type，而是
- en: rather a function from nat to Prop — that is, a property of
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而是 nat 到 Prop 的函数 —— 也就是，一个属性
- en: numbers.  Note that we've already seen other inductive definitions
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字。请注意，我们已经看到其他归纳定义
- en: that result in functions, such as list, whose type is Type → Type.  What is
    new here is that, because the nat argument of
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导致函数的结果，例如 list，其类型为 Type → Type。这里的新内容是，因为
- en: ev appears *unnamed*, to the *right* of the colon, it is allowed
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ev 出现为*未命名*，在冒号的*右侧*，允许
- en: 'to take different values in the types of different constructors:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在不同构造函数的类型中取不同的值：
- en: 0 in the type of ev_0 and S (S n) in the type of ev_SS.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ev_0 的类型中为 0，ev_SS 的类型中为 S (S n)。
- en: In contrast, the definition of list names the X parameter
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相比之下，list 的定义将 X 参数命名为
- en: '*globally*, to the *left* of the colon, forcing the result of'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*全局*，在冒号的*左侧*，强制结果为'
- en: nil and cons to be the same (list X).  Had we tried to bring
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nil 和 cons 被视为相同（list X）。如果我们尝试将
- en: 'nat to the left in defining ev, we would have seen an error:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在定义 ev 时将 nat 放在左侧，我们会看到一个错误：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ("Parameter" here is Coq jargon for an argument on the left of the
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （这里的“参数”是 Coq 术语，表示冒号左侧的参数
- en: colon in an Inductive definition; "index" is used to refer to
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在归纳定义中使用冒号；“index”用于引用
- en: arguments on the right of the colon.)
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 冒号右侧的参数。）
- en: We can think of the definition of ev as defining a Coq property
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将 ev 的定义看作是在 Coq 中定义一个属性
- en: 'ev : nat → Prop, together with theorems ev_0 : ev 0 and'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ev：nat → Prop，连同定理 ev_0：ev 0 和
- en: 'ev_SS : ∀ n, ev n → ev (S (S n)).  Such "constructor'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ev_SS：∀ n，ev n → ev (S (S n))。这样的“构造函���
- en: theorems" have the same status as proven theorems.  In particular,
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理”与已证明的定理具有相同的地位。特别是，
- en: we can use Coq's apply tactic with the rule names to prove ev
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用 Coq 的 apply 策略与规则名称来证明 ev
- en: for particular numbers...
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于特定的数字...
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '... or we can use function application syntax:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '... 或者我们可以使用函数应用语法：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can also prove theorems that have hypotheses involving ev.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以证明具有涉及 ev 的假设的定理。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'More generally, we can show that any number multiplied by 2 is even:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更一般地，我们可以证明任何数乘以 2 都是偶数：
- en: 'Exercise: 1 star (ev_double)'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星（ev_double）
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ☐
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Theorem ev_minus2 : ∀n,'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 ev_minus2：∀n，
- en: ev n → ev (pred (pred n)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ev n → ev (pred (pred n))。
- en: Proof.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n E.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n E。
- en: inversion E as [| n' E'].
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 E 为 [| n' E']。
- en: '- (* E = ev_0 *) simpl. apply ev_0.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E = ev_0 *) 简化。应用 ev_0。'
- en: '- (* E = ev_SS n'' E'' *) simpl. apply E''. Qed.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E = ev_SS n'' E'' *) 简化。应用 E''。完成。'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Theorem ev_minus2'' : ∀n,'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 ev_minus2'：∀n，
- en: ev n → ev (pred (pred n)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ev n → ev (pred (pred n))。
- en: Proof.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n E.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n E。
- en: destruct E as [| n' E'].
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将 E 解构为 [| n' E']。
- en: '- (* E = ev_0 *) simpl. apply ev_0.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E = ev_0 *) 简化。应用 ev_0。'
- en: '- (* E = ev_SS n'' E'' *) simpl. apply E''. Qed.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E = ev_SS n'' E'' *) 简化。应用 E''。完成。'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Theorem evSS_ev : ∀n,'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 evSS_ev：∀n，
- en: ev (S (S n)) → ev n.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ev (S (S n)) → ev n。
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Proof.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n E.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n E。
- en: destruct E as [| n' E'].
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将 E 解构为 [| n' E']。
- en: '- (* E = ev_0. *)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E = ev_0。*)'
- en: (* We must prove that n is even from no assumptions! *)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (* 我们必须证明没有任何假设的情况下 n 是偶数！*)
- en: Abort.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Theorem evSS_ev : ∀n,'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 evSS_ev：∀n，
- en: ev (S (S n)) → ev n.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ev (S (S n)) → ev n。
- en: Proof.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n E.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n E。
- en: inversion E as [| n' E'].
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 E 为 [| n' E']。
- en: (* We are in the E = ev_SS n' E' case now. *)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (* 我们现在处于 E = ev_SS n' E' 情况下。*)
- en: apply E'.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E'。
- en: Qed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Theorem one_not_even : ¬ ev 1.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 one_not_even：¬ ev 1。
- en: Proof.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros H. inversion H. Qed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 H。反演 H。完成。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Theorem SSSSev__even : ∀n,'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 SSSSev__even：∀n，
- en: ev (S (S (S (S n)))) → ev n.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ev (S (S (S (S n)))) → ev n。
- en: Proof.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容 *) 已承认。
- en: 'Theorem even5_nonsense :'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 even5_nonsense：
- en: ev 5 → 2 + 2 = 9.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ev 5 → 2 + 2 = 9。
- en: Proof.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容 *) 已承认。
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lemma ev_even_firsttry : ∀n,'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 ev_even_firsttry：∀n，
- en: ev n → ∃k, n = double k.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ev n → ∃k，n = double k。
- en: Proof.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* WORKED IN CLASS *)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在课堂上运行 *)
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: intros n E. inversion E as [| n' E'].
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: intros n E. inversion E as [| n' E'].
- en: '- (* E = ev_0 *)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E = ev_0 *)'
- en: ∃0\. reflexivity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ∃0\. reflexivity.
- en: '- (* E = ev_SS n'' E'' *) simpl.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E = ev_SS n'' E'' *) simpl.'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ∃k', n' = double k',
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ∃k', n' = double k',
- en: which is the same as the original statement, but with n' instead
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: which is the same as the original statement, but with n' instead
- en: of n.  Indeed, it is not difficult to convince Coq that this
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: of n.  Indeed, it is not difficult to convince Coq that this
- en: intermediate result suffices.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: intermediate result suffices.
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Induction on Evidence
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Induction on Evidence
- en: 'If this looks familiar, it is no coincidence: We''ve encountered'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'If this looks familiar, it is no coincidence: We''ve encountered'
- en: similar problems in the [Induction](Induction.html) chapter, when trying to
    use
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: similar problems in the [Induction](Induction.html) chapter, when trying to
    use
- en: case analysis to prove results that required induction.  And once
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: case analysis to prove results that required induction.  And once
- en: again the solution is... induction!
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: again the solution is... induction!
- en: The behavior of induction on evidence is the same as its
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: The behavior of induction on evidence is the same as its
- en: 'behavior on data: It causes Coq to generate one subgoal for each'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: behavior on  It causes Coq to generate one subgoal for each
- en: constructor that could have used to build that evidence, while
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: constructor that could have used to build that evidence, while
- en: providing an induction hypotheses for each recursive occurrence of
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: providing an induction hypotheses for each recursive occurrence of
- en: the property in question.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: the property in question.
- en: 'Let''s try our current lemma again:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Let''s try our current lemma again:'
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we can see that Coq produced an IH that corresponds to
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Here, we can see that Coq produced an IH that corresponds to
- en: E', the single recursive occurrence of ev in its own
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E', the single recursive occurrence of ev in its own
- en: definition.  Since E' mentions n', the induction hypothesis
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: definition.  Since E' mentions n', the induction hypothesis
- en: talks about n', as opposed to n or some other number.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: talks about n', as opposed to n or some other number.
- en: The equivalence between the second and third definitions of
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: The equivalence between the second and third definitions of
- en: evenness now follows.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: evenness now follows.
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we will see in later chapters, induction on evidence is a
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: As we will see in later chapters, induction on evidence is a
- en: recurring technique across many areas, and in particular when
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: recurring technique across many areas, and in particular when
- en: formalizing the semantics of programming languages, where many
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: formalizing the semantics of programming languages, where many
- en: properties of interest are defined inductively.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: properties of interest are defined inductively.
- en: The following exercises provide simple examples of this
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: The following exercises provide simple examples of this
- en: technique, to help you familiarize yourself with it.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: technique, to help you familiarize yourself with it.
- en: 'Exercise: 2 stars (ev_sum)'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'Exercise: 2 stars (ev_sum)'
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ☐
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 4 stars, advanced, optional (ev_alternate)'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'Exercise: 4 stars, advanced, optional (ev_alternate)'
- en: In general, there may be multiple ways of defining a
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: In general, there may be multiple ways of defining a
- en: property inductively.  For example, here's a (slightly contrived)
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: property inductively.  For example, here's a (slightly contrived)
- en: 'alternative definition for ev:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'alternative definition for ev:'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Prove that this definition is logically equivalent to the old
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Prove that this definition is logically equivalent to the old
- en: one.  (You may want to look at the previous theorem when you get
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: one.  (You may want to look at the previous theorem when you get
- en: to the induction step.)
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: to the induction step.)
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ☐
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, advanced, recommended (ev_ev__ev)'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'Exercise: 3 stars, advanced, recommended (ev_ev__ev)'
- en: Finding the appropriate thing to do induction on is a
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Finding the appropriate thing to do induction on is a
- en: 'bit tricky here:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'bit tricky here:'
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ☐
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, optional (ev_plus_plus)'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'Exercise: 3 stars, optional (ev_plus_plus)'
- en: This exercise just requires applying existing lemmas.  No
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: This exercise just requires applying existing lemmas.  No
- en: induction or even case analysis is needed, though some of the
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: induction or even case analysis is needed, though some of the
- en: rewriting may be tedious.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: rewriting may be tedious.
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ☐
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Module Playground.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Module Playground.
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inductive le : nat → nat → Prop :='
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive le : nat → nat → Prop :='
- en: '| le_n : ∀n, le n n'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '| le_n : ∀n, le n n'
- en: '| le_S : ∀n m, (le n m) → (le n (S m)).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '| le_S : ∀n m, (le n m) → (le n (S m)).'
- en: Notation "m ≤ n" := (le m n).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "m ≤ n" := (le m n).
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Theorem test_le[1] :'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'Theorem test_le[1] :'
- en: 3 ≤ 3.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 3 ≤ 3.
- en: Proof.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Proof.
- en: (* WORKED IN CLASS *)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (* WORKED IN CLASS *)
- en: apply le_n. Qed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: apply le_n. Qed.
- en: 'Theorem test_le[2] :'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'Theorem test_le[2] :'
- en: 3 ≤ 6.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 3 ≤ 6.
- en: Proof.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Proof.
- en: (* WORKED IN CLASS *)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: (* WORKED IN CLASS *)
- en: apply le_S. apply le_S. apply le_S. apply le_n. Qed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: apply le_S. apply le_S. apply le_S. apply le_n. Qed.
- en: 'Theorem test_le[3] :'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'Theorem test_le[3] :'
- en: (2 ≤ 1) → 2 + 2 = 5.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: (2 ≤ 1) → 2 + 2 = 5.
- en: Proof.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Proof.
- en: (* WORKED IN CLASS *)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (* WORKED IN CLASS *)
- en: intros H. inversion H. inversion H[2]. Qed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: intros H. inversion H. inversion H[2]. Qed.
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: End Playground.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: End Playground.
- en: Definition lt (n m:nat) := le (S n) m.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Definition lt (n m:nat) := le (S n) m.
- en: Notation "m < n" := (lt m n).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "m < n" := (lt m n).
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inductive square_of : nat → nat → Prop :='
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive square_of : nat → nat → Prop :='
- en: '| sq : ∀n:nat, square_of n (n * n).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '| sq : ∀n:nat, square_of n (n * n).'
- en: 'Inductive next_nat : nat → nat → Prop :='
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive next_nat : nat → nat → Prop :='
- en: '| nn : ∀n:nat, next_nat n (S n).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '| nn : ∀n:nat, next_nat n (S n).'
- en: 'Inductive next_even : nat → nat → Prop :='
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive next_even : nat → nat → Prop :='
- en: '| ne_1 : ∀n, ev (S n) → next_even n (S n)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '| ne_1 : ∀n, ev (S n) → next_even n (S n)'
- en: '| ne_2 : ∀n, ev (S (S n)) → next_even n (S (S n)).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '| ne_2 : ∀n, ev (S (S n)) → next_even n (S (S n)).'
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (* FILL IN HERE *)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*)
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: (* FILL IN HERE *)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*)
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lemma le_trans : ∀m n o, m ≤ n → n ≤ o → m ≤ o.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 le_trans : ∀m n o，m ≤ n → n ≤ o → m ≤ o。'
- en: Proof.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: 'Theorem O_le_n : ∀n,'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 O_le_n : ∀n，'
- en: 0 ≤ n.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 0 ≤ n。
- en: Proof.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: 'Theorem n_le_m__Sn_le_Sm : ∀n m,'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 n_le_m__Sn_le_Sm : ∀n m，'
- en: n ≤ m → S n ≤ S m.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: n ≤ m → S n ≤ S m。
- en: Proof.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: 'Theorem Sn_le_Sm__n_le_m : ∀n m,'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 Sn_le_Sm__n_le_m : ∀n m，'
- en: S n ≤ S m → n ≤ m.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: S n ≤ S m → n ≤ m。
- en: Proof.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: 'Theorem le_plus_l : ∀a b,'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 le_plus_l : ∀a b，'
- en: a ≤ a + b.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: a ≤ a + b。
- en: Proof.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: 'Theorem plus_lt : ∀n[1] n[2] m,'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 plus_lt : ∀n[1] n[2] m，'
- en: n[1] + n[2] < m →
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: n[1] + n[2] < m →
- en: n[1] < m ∧ n[2] < m.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: n[1] < m ∧ n[2] < m。
- en: Proof.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: unfold lt.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 lt.
- en: (* FILL IN HERE *) Admitted.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: 'Theorem lt_S : ∀n m,'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 lt_S : ∀n m，'
- en: n < m →
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: n < m →
- en: n < S m.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: n < S m。
- en: Proof.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: 'Theorem leb_complete : ∀n m,'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 leb_complete : ∀n m，'
- en: leb n m = true → n ≤ m.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: leb n m = true → n ≤ m。
- en: Proof.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Theorem leb_correct : ∀n m,'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 leb_correct : ∀n m，'
- en: n ≤ m →
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: n ≤ m →
- en: leb n m = true.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: leb n m = true。
- en: Proof.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Theorem leb_true_trans : ∀n m o,'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 leb_true_trans : ∀n m o，'
- en: leb n m = true → leb m o = true → leb n o = true.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: leb n m = true → leb m o = true → leb n o = true。
- en: Proof.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Theorem leb_iff : ∀n m,'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 leb_iff : ∀n m，'
- en: leb n m = true ↔ n ≤ m.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: leb n m = true ↔ n ≤ m。
- en: Proof.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Module R.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 R。
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inductive R : nat → nat → nat → Prop :='
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义 R：nat → nat → nat → Prop :=
- en: '| c[1] : R 0 0 0'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '| c[1] : R 0 0 0'
- en: '| c[2] : ∀m n o, R m n o → R (S m) n (S o)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '| c[2] : ∀m n o, R m n o → R (S m) n (S o)'
- en: '| c[3] : ∀m n o, R m n o → R m (S n) (S o)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '| c[3] : ∀m n o, R m n o → R m (S n) (S o)'
- en: '| c[4] : ∀m n o, R (S m) (S n) (S (S o)) → R m n o'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '| c[4] : ∀m n o, R (S m) (S n) (S (S o)) → R m n o'
- en: '| c[5] : ∀m n o, R m n o → R n m o.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '| c[5] : ∀m n o, R m n o → R n m o。'
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Definition fR : nat → nat → nat'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 fR : nat → nat → nat'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ." 替换这一行*）已证明。
- en: 'Theorem R_equiv_fR : ∀m n o, R m n o ↔ fR m n = o.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 R_equiv_fR : ∀m n o, R m n o ↔ fR m n = o。'
- en: Proof.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已证明。
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: End R.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 R。
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[1;2;3]'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[1;2;3]'
- en: is a subsequence of each of the lists
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是每个列表的子序列
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[1;2]'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[1;2]'
- en: '[1;3]'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[1;3]'
- en: '[5;6;2;1;7;3;8].'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[5;6;2;1;7;3;8].'
- en: 'Define an inductive proposition subseq on list nat that captures what it means
    to be a subsequence. (Hint: You''ll need three cases.)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个关于自然数列表的归纳命题 subseq，捕捉什么是子序列的含义。（提示：你需要三种情况。）
- en: Prove subseq_refl that subsequence is reflexive, that is, any list is a subsequence
    of itself.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明 subseq_refl，即子序列是自反的，即任何列表都是其自身的子序列。
- en: Prove subseq_app that for any lists l[1], l[2], and l[3], if l[1] is a subsequence
    of l[2], then l[1] is also a subsequence of l[2] ++ l[3].
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明 subseq_app，对于任意列表 l[1]、l[2] 和 l[3]，如果 l[1] 是 l[2] 的子序列，则 l[1] 也是 l[2] ++
    l[3] 的子序列。
- en: '(Optional, harder) Prove subseq_trans that subsequence is transitive — that
    is, if l[1] is a subsequence of l[2] and l[2] is a subsequence of l[3], then l[1]
    is a subsequence of l[3]. Hint: choose your induction carefully!'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选，更难）证明 subseq_trans，即子序列是传递的 — 即，如果 l[1] 是 l[2] 的子序列，而 l[2] 是 l[3] 的子序列，则
    l[1] 是 l[3] 的子序列。提示：谨慎选择你的归纳方式！
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ☐
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars, optionalM (R_provability2)'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星，可选M（R_provability2）
- en: 'Suppose we give Coq the following definition:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们给 Coq 下面的定义：
- en: '[PRE44]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Case Study: Regular Expressions'
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：正则表达式
- en: The ev property provides a simple example for illustrating
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ev 属性提供了一个简单的例子来说明
- en: inductive definitions and the basic techniques for reasoning about
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 归纳定义和关于推理的基本技术
- en: them, but it is not terribly exciting — after all, it is
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但这并不是非常令人兴奋 — 毕竟，它是
- en: equivalent to the two non-inductive of evenness that we had
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等同于我们之前有的两种非归纳的偶数性质
- en: already seen, and does not seem to offer any concrete benefit over
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已经看到，并且似乎没有提供任何具体的好处
- en: them.  To give a better sense of the power of inductive
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 他们。为了更好地展示归纳的力量
- en: definitions, we now show how to use them to model a classic
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义，我们现在展示如何使用它们来建模一个经典的
- en: 'concept in computer science: *regular expressions*.'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算机科学中的概念：*正则表达式*。
- en: Regular expressions are a simple language for describing strings,
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正则表达式是一种描述字符串的简单语言，
- en: 'defined as follows:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下定义：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that this definition is *polymorphic*: Regular'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这个定义是*多态的*：正则
- en: expressions in reg_exp T describe strings with characters drawn
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: reg_exp T 中的表达式描述了由字符组成的字符串
- en: from T — that is, lists of elements of T.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从T中 - 即T元素的列表。
- en: (We depart slightly from standard practice in that we do not
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （我们略微偏离标准做法，因为我们不这样做
- en: require the type T to be finite.  This results in a somewhat
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要T类型是有限的。 这导致了一种
- en: different theory of regular expressions, but the difference is not
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正则表达式的不同理论，但区别并不大
- en: significant for our purposes.)
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的目的很重要。）
- en: We connect regular expressions and strings via the following
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过以下方式连接正则表达式和字符串
- en: rules, which define when a regular expression *matches* some
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了正则表达式何时与某些
- en: 'string:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字符串：
- en: The expression EmptySet does not match any string.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式EmptySet不匹配任何字符串。
- en: The expression EmptyStr matches the empty string [].
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式EmptyStr匹配空字符串[]。
- en: The expression Char x matches the one-character string [x].
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式Char x匹配一个字符的字符串[x]。
- en: If re[1] matches s[1], and re[2] matches s[2], then App re[1] re[2] matches
    s[1] ++ s[2].
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果re[1]匹配s[1]，并且re[2]匹配s[2]，那么App re[1] re[2]匹配s[1] ++ s[2]。
- en: If at least one of re[1] and re[2] matches s, then Union re[1] re[2] matches
    s.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果re[1]和re[2]中至少有一个与s匹配，则Union re[1] re[2]与s匹配。
- en: Finally, if we can write some string s as the concatenation of a sequence of
    strings s = s_1 ++ ... ++ s_k, and the expression re matches each one of the strings
    s_i, then Star re matches s.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果我们可以将某个字符串s写成一系列字符串s = s_1 ++ ... ++ s_k的连接，并且表达式re匹配每个字符串s_i，则Star re匹配s。
- en: As a special case, the sequence of strings may be empty, so Star re always matches
    the empty string [] no matter what re is.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一种特殊情况，字符串序列可能为空，因此无论re是什么，Star re始终匹配空字符串[]。
- en: We can easily translate this informal definition into an
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以很容易地将这个非正式定义转换为一个
- en: 'Inductive one as follows:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过以下方式归纳一个：
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Again, for readability, we can also display this definition using
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，为了可读性，我们还可以使用
- en: inference-rule notation.  At the same time, let's introduce a more
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 推理规则符号。 与此同时，让我们引入一个更多
- en: readable infix notation.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可读的中缀表示法。
- en: '[PRE47]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (MEmpty)
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （MEmpty）
- en: '|'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[] =~ EmptyStr'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[] =~ EmptyStr'
- en: '|'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (MChar)
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (MChar)
- en: '|'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[x] =~ Char x'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[x] =~ Char x'
- en: '|'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: s[1] =~ re[1]    s[2] =~ re[2]
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[1] =~ re[1]    s[2] =~ re[2]
- en: '|'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (MApp)
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （MApp）
- en: '|'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: s[1] ++ s[2] =~ App re[1] re[2]
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[1] ++ s[2] =~ App re[1] re[2]
- en: '|'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: s[1] =~ re[1]
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[1] =~ re[1]
- en: '|'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (MUnionL)
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （MUnionL）
- en: '|'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: s[1] =~ Union re[1] re[2]
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[1] =~ Union re[1] re[2]
- en: '|'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: s[2] =~ re[2]
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[2] =~ re[2]
- en: '|'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (MUnionR)
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （MUnionR）
- en: '|'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: s[2] =~ Union re[1] re[2]
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[2] =~ Union re[1] re[2]
- en: '|'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (MStar0)
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （MStar0）
- en: '|'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[] =~ Star re'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[] =~ Star re'
- en: '|'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: s[1] =~ re    s[2] =~ Star re
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[1] =~ re    s[2] =~ Star re
- en: '|'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (MStarApp)
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （MStarApp）
- en: '|'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: s[1] ++ s[2] =~ Star re
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[1] ++ s[2] =~ Star re
- en: '|'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Notice that these rules are not *quite* the same as the informal
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这些规则与非正式规则并不完全相同
- en: ones that we gave at the beginning of the section.  First, we
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在本节开头给出的那些。首先，
- en: don't need to include a rule explicitly stating that no string
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不需要显式包括一个规则声明没有字符串
- en: matches EmptySet; we just don't happen to include any rule that
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 匹配EmptySet; 我们只是碰巧没有包括任何规则
- en: would have the effect of some string matching EmptySet.  (Indeed,
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 会导致某些字符串匹配EmptySet。（实际上，
- en: the syntax of inductive definitions doesn't even *allow* us to
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不允许我们的归纳定义的语法
- en: give such a "negative rule.")
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给出这样的“负规则”。）
- en: Second, the informal rules for Union and Star correspond
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其次，Union和Star的非正式规则对应
- en: 'to two constructors each: MUnionL / MUnionR, and MStar0 /'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于每个两个构造函数：MUnionL / MUnionR，和MStar0 /
- en: MStarApp.  The result is logically equivalent to the original
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MStarApp。 结果在逻辑上等价于原始
- en: rules but more convenient to use in Coq, since the recursive
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规则但在Coq中更方便使用，因为递归
- en: occurrences of exp_match are given as direct arguments to the
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出现exp_match的情况被直接作为参数提供给
- en: constructors, making it easier to perform induction on evidence.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数，使得在证据上执行归纳更容易。
- en: (The exp_match_ex[1] and exp_match_ex[2] exercises below ask you
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （下面的exp_match_ex[1]和exp_match_ex[2]练习要求您
- en: to prove that the constructors given in the inductive declaration
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要证明在归纳声明中给出的构造函数
- en: and the ones that would arise from a more literal transcription of
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及从更直接的转录中产生的那些
- en: the informal rules are indeed equivalent.)
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非正式规则确实是等价的。）
- en: Let's illustrate these rules with a few examples.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们用一些例子来说明这些规则。
- en: '[PRE48]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: (Notice how the last example applies MApp to the strings [1]
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （注意最后一个例子如何应用MApp到字符串[1]
- en: and [2] directly.  Since the goal mentions [1; 2] instead of
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和[2]直接。 由于目标提到了[1; 2]而不是
- en: '[1] ++ [2], Coq wouldn''t be able to figure out how to split the'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[1] ++ [2]，Coq将无法确定如何拆分'
- en: string on its own.)
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字符串本身。）
- en: Using inversion, we can also show that certain strings do *not*
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用反演，我们还可以展示某些字符串*不*
- en: 'match a regular expression:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 匹配一个正则表达式：
- en: '[PRE49]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can define helper functions to help write down regular
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以定义辅助函数来帮助编写正则
- en: expressions. The reg_exp_of_list function constructs a regular
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达式中获得。reg_exp_of_list函数构造一个正则
- en: expression that matches exactly the list that it receives as an
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与其接收的列表完全匹配的表达式
- en: 'argument:'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数：
- en: '[PRE50]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can also prove general facts about exp_match.  For instance,
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以证明关于exp_match的一般事实。例如，
- en: the following lemma shows that every string s that matches re
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下引理表明，每个与re匹配的字符串s
- en: also matches Star re.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也与Star re匹配。
- en: '[PRE51]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: (Note the use of app_nil_r to change the goal of the theorem to
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （注意使用app_nil_r将定理的目标更改为
- en: exactly the same shape expected by MStarApp.)
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与MStarApp预期的形状完全相同。）
- en: 'Exercise: 3 stars (exp_match_ex[1])'
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星（exp_match_ex[1]）
- en: The following lemmas show that the informal matching rules given
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下引理表明，给出的非正式匹配规则
- en: at the beginning of the chapter can be obtained from the formal
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 章节开头可以从正式
- en: inductive definition.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 归纳定义。
- en: '[PRE52]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The next lemma is stated in terms of the fold function from the
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个引理是根据来自
- en: '[Poly](Poly.html) chapter: If ss : list (list T) represents a sequence of'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Poly](Poly.html)章节：如果ss：list（list T）表示一个序列'
- en: strings s[1], ..., sn, then fold app ss [] is the result of
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字符串s[1]，...，sn，然后折叠app ss []的结果是
- en: concatenating them all together.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将它们全部连接在一起。
- en: '[PRE53]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ☐
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 4 stars (reg_exp_of_list)'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：4星（reg_exp_of_list）
- en: Prove that reg_exp_of_list satisfies the following
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明reg_exp_of_list满足以下
- en: 'specification:'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规范：
- en: '[PRE54]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ☐
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: Since the definition of exp_match has a recursive
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于exp_match的定义具有递归
- en: structure, we might expect that proofs involving regular
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结构，我们可能期望涉及正则的证明
- en: expressions will often require induction on evidence.  For
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达式通常需要对证据进行归纳。对于
- en: example, suppose that we wanted to prove the following intuitive
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设我们想要证明以下直观的
- en: 'result: If a regular expression re matches some string s, then'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果：如果正则表达式re匹配某个字符串s，则
- en: all elements of s must occur somewhere in re.  To state this
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: s的所有元素必须在re中的某处出现。为了陈述这一点
- en: theorem, we first define a function re_chars that lists all
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理，我们首先定义一个列出所有
- en: 'characters that occur in a regular expression:'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出现在正则表达式中的字符：
- en: '[PRE55]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can then phrase our theorem as follows:'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们可以将我们的定理表述如下：
- en: '[PRE56]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Something interesting happens in the MStarApp case.  We obtain
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在MStarApp情况下会发生一些有趣的事情。我们获得
- en: '*two* induction hypotheses: One that applies when x occurs in'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*两个*归纳假设：一个适用于x出现在'
- en: s[1] (which matches re), and a second one that applies when x
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: s[1]（与re匹配），第二个适用于x
- en: occurs in s[2] (which matches Star re).  This is a good
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出现在s[2]中（与Star re匹配）。这是一个很好的
- en: illustration of why we need induction on evidence for exp_match,
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 说明为什么我们需要对exp_match的证据进行归纳
- en: 'as opposed to re: The latter would only provide an induction'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与re相反：后者只会提供归纳
- en: hypothesis for strings that match re, which would not allow us
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与re匹配的字符串的假设，这将不允许我们
- en: to reason about the case In x s[2].
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 推理In x s[2]的情况
- en: '[PRE57]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Exercise: 4 stars (re_not_empty)'
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：4星（re_not_empty）
- en: Write a recursive function re_not_empty that tests whether a
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个测试re_not_empty的递归函数，测试是否
- en: regular expression matches some string. Prove that your function
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正则表达式匹配某个字符串。证明你的函数
- en: is correct.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是正确的。
- en: '[PRE58]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ☐
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: The remember Tactic
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记住策略
- en: One potentially confusing feature of the induction tactic is
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 归纳策略中一个可能令人困惑的特点是
- en: that it happily lets you try to set up an induction over a term
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它很高兴地让你尝试设置一个关于术语的归纳
- en: that isn't sufficiently general.  The effect of this is to lose
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这并不够通用。这样做的效果是失去
- en: information (much as destruct can do), and leave you unable to
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息（就像destruct可以做的那样），让你无法
- en: 'complete the proof.  Here''s an example:'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成证明。这里有一个例子：
- en: '[PRE59]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Just doing an inversion on H[1] won't get us very far in the
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅仅对H[1]进行反演并不能让我们走得很远
- en: recursive cases. (Try it!). So we need induction. Here is a naive
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 递归情况。（试试看！）。所以我们需要归纳。这是一个天真的
- en: 'first attempt:'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一次尝试：
- en: '[PRE60]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: But now, although we get seven cases (as we would expect from the
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但现在，尽管我们得到了七种情况（正如我们从中期望的那样
- en: definition of exp_match), we have lost a very important bit of
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: exp_match的定义），我们失去了一个非常重要的部分
- en: 'information from H[1]: the fact that s[1] matched something of the'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从H[1]中获取信息：s[1]匹配了s中的某个内容的事实
- en: form Star re.  This means that we have to give proofs for *all*
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 形式Star re。这意味着我们必须为*所有*
- en: seven constructors of this definition, even though all but two of
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个定义的七个构造，尽管除了两个之外的所有构造
- en: them (MStar0 and MStarApp) are contradictory.  We can still
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们（MStar0 和 MStarApp）是矛盾的。我们仍然可以
- en: get the proof to go through for a few constructors, such as
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使证明通过一些构造函数，例如
- en: MEmpty...
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MEmpty...
- en: '[PRE61]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '... but most cases get stuck.  For MChar, for instance, we'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...但大多数情况都卡住了。例如，对于 MChar，我们'
- en: must show that
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须展示
- en: '[PRE62]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '- (* MChar. Stuck... *)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MChar。卡住了... *）'
- en: Abort.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 中止。
- en: '[PRE63]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Lemma star_app: ∀T (s[1] s[2] : list T) (re re'' : reg_exp T),'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma star_app: ∀T（s[1] s[2]：列表 T）（re re''：reg_exp T），'
- en: s[1] =~ re' →
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: s[1] =~ re' →
- en: re' = Star re →
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: re' = 星星 re →
- en: s[2] =~ Star re →
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: s[2] =~ 星星 re →
- en: s[1] ++ s[2] =~ Star re.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: s[1] ++ s[2] =~ 星星 re。
- en: '[PRE64]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Abort.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 中止。
- en: 'Lemma star_app: ∀T (s[1] s[2] : list T) (re : reg_exp T),'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma star_app: ∀T（s[1] s[2]：列表 T）（re：reg_exp T），'
- en: s[1] =~ Star re →
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: s[1] =~ 星星 re →
- en: s[2] =~ Star re →
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: s[2] =~ 星星 re →
- en: s[1] ++ s[2] =~ Star re.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: s[1] ++ s[2] =~ 星星 re。
- en: Proof.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。
- en: intros T s[1] s[2] re H[1].
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: intros T s[1] s[2] re H[1]。
- en: remember (Star re) as re'.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 记住（星星 re）作为 re'。
- en: '[PRE65]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: generalize dependent s[2].
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化依赖于 s[2]。
- en: induction H[1]
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 对 H[1] 进行归纳
- en: as [|x'|s[1] re[1] s[2]' re[2] Hmatch1 IH[1] Hmatch2 IH[2]
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如[ | x' | s[1] re[1] s[2]' re[2] Hmatch1 IH[1] Hmatch2 IH[2]
- en: '|s[1] re[1] re[2] Hmatch IH|re[1] s[2]'' re[2] Hmatch IH'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '|s[1] re[1] re[2] Hmatch IH|re[1] s[2]'' re[2] Hmatch IH'
- en: '|re''''|s[1] s[2]'' re'''' Hmatch1 IH[1] Hmatch2 IH[2]].'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '|re''''|s[1] s[2]'' re'''' Hmatch1 IH[1] Hmatch2 IH[2]]。'
- en: '[PRE66]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '- (* MEmpty *)  inversion Heqre''.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MEmpty *）反演 Heqre''。'
- en: '- (* MChar *)   inversion Heqre''.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MChar *）反演 Heqre''。'
- en: '- (* MApp *)    inversion Heqre''.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MApp *）反演 Heqre''。'
- en: '- (* MUnionL *) inversion Heqre''.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MUnionL *）反演 Heqre''。'
- en: '- (* MUnionR *) inversion Heqre''.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MUnionR *）反演 Heqre''。'
- en: '[PRE67]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '- (* MStar0 *)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MStar0 *）'
- en: inversion Heqre'. intros s H. apply H.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Heqre'。intros s H。应用 H。
- en: '- (* MStarApp *)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MStarApp *）'
- en: inversion Heqre'. rewrite H[0] in IH[2], Hmatch1.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Heqre'。在 IH[2]，Hmatch1 中重写 H[0]。
- en: intros s[2] H[1]. rewrite ← app_assoc.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: intros s[2] H[1]。重写 ← app_assoc。
- en: apply MStarApp.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 MStarApp。
- en: + apply Hmatch1.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 Hmatch1。
- en: + apply IH[2].
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 IH[2]。
- en: '* reflexivity.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '* 一致性。'
- en: '* apply H[1].'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '* 应用 H[1]。'
- en: Qed.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE68]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Lemma MStar'''' : ∀T (s : list T) (re : reg_exp T),'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: Lemma MStar''：∀T（s：列表 T）（re：reg_exp T），
- en: s =~ Star re →
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: s =~ 星星 re →
- en: '∃ss : list (list T),'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: ∃ss：列表（列表 T），
- en: s = fold app ss []
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: s = 折叠 app ss []。
- en: ∧ ∀s', In s' ss → s' =~ re.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: ∧ ∀s'，In s' ss → s' =~ re。
- en: Proof.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: （* 填写这里 *）已承认。
- en: '[PRE69]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Module Pumping.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 模块泵。
- en: 'Fixpoint pumping_constant {T} (re : reg_exp T) : nat :='
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 固定泵定数 {T}（re：reg_exp T）：自然数 :=
- en: match re with
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 re 与
- en: '| EmptySet ⇒ 0'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '| EmptySet ⇒ 0'
- en: '| EmptyStr ⇒ 1'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '| EmptyStr ⇒ 1'
- en: '| Char _ ⇒ 2'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '| 字符 _ ⇒ 2'
- en: '| App re[1] re[2] ⇒'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '| App re[1] re[2] ⇒'
- en: pumping_constant re[1] + pumping_constant re[2]
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 泵定数 re[1] + 泵定数 re[2]
- en: '| Union re[1] re[2] ⇒'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '| 联合 re[1] re[2] ⇒'
- en: pumping_constant re[1] + pumping_constant re[2]
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 泵定数 re[1] + 泵定数 re[2]
- en: '| Star _ ⇒ 1'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星星 _ ⇒ 1'
- en: end.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE70]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Fixpoint napp {T} (n : nat) (l : list T) : list T :='
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 固定点 napp {T}（n：自然数）（l：列表 T）：列表 T :=
- en: match n with
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 n 与
- en: '| 0 ⇒ []'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 ⇒ []'
- en: '| S n'' ⇒ l ++ napp n'' l'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '| S n'' ⇒ l ++ napp n'' l'
- en: end.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Lemma napp_plus: ∀T (n m : nat) (l : list T),'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma napp_plus: ∀T（n m：自然数）（l：列表 T），'
- en: napp (n + m) l = napp n l ++ napp m l.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: napp（n + m）l = napp n l ++ napp m l。
- en: Proof.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。
- en: intros T n m l.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: intros T n m l。
- en: induction n as [|n IHn].
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 对 n 进行归纳作为 [|n IHn]。
- en: '- reflexivity.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '- 一致性。'
- en: '- simpl. rewrite IHn, app_assoc. reflexivity.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '- 简化。重写 IHn，app_assoc。一致性。'
- en: Qed.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE71]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Lemma pumping : ∀T (re : reg_exp T) s,'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: Lemma pumping：∀T（re：reg_exp T）s，
- en: s =~ re →
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: s =~ re →
- en: pumping_constant re ≤ length s →
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 泵定数 re ≤ s 的长度 →
- en: ∃s[1] s[2] s[3],
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ∃s[1] s[2] s[3]，
- en: s = s[1] ++ s[2] ++ s[3] ∧
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: s = s[1] ++ s[2] ++ s[3] ∧
- en: s[2] ≠ [] ∧
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: s[2] ≠ [] ∧
- en: ∀m, s[1] ++ napp m s[2] ++ s[3] =~ re.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ∀m，s[1] ++ napp m s[2] ++ s[3] =~ re。
- en: '[PRE72]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Require Import Coq.omega.Omega.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.omega.Omega。
- en: Proof.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。
- en: intros T re s Hmatch.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: intros T re s Hmatch。
- en: induction Hmatch
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Hmatch 进行归纳
- en: as [ | x | s[1] re[1] s[2] re[2] Hmatch1 IH[1] Hmatch2 IH[2]
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如[ | x | s[1] re[1] s[2] re[2] Hmatch1 IH[1] Hmatch2 IH[2]
- en: '| s[1] re[1] re[2] Hmatch IH | re[1] s[2] re[2] Hmatch IH'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '| s[1] re[1] re[2] Hmatch IH | re[1] s[2] re[2] Hmatch IH'
- en: '| re | s[1] s[2] re Hmatch1 IH[1] Hmatch2 IH[2] ].'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '| re | s[1] s[2] re Hmatch1 IH[1] Hmatch2 IH[2] ]。'
- en: '- (* MEmpty *)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* MEmpty *）'
- en: simpl. omega.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。omega。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: （* 填写这里 *）已承认。
- en: End Pumping.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 结束泵。
- en: '[PRE73]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Case Study: Improving Reflection'
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：改进反射
- en: We've seen in the [Logic](Logic.html) chapter that we often need to
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 [Logic](Logic.html) 章节中看到，我们经常需要
- en: relate boolean computations to statements in Prop.  But
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将布尔计算与 Prop 中的语句相关联。但
- en: performing this conversion in the way we did it there can result
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行这种转换的方式可能导致
- en: in tedious proof scripts.  Consider the proof of the following
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在繁琐的证明脚本中。考虑以下证明的证明
- en: 'theorem:'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理：
- en: '[PRE74]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the first branch after destruct, we explicitly apply
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 destruct 后的第一个分支中，我们明确应用
- en: the beq_nat_true_iff lemma to the equation generated by
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由 beq_nat_true_iff 引理生成的方程式到
- en: destructing beq_nat n m, to convert the assumption beq_nat n m = true into the
    assumption n = m; then we had to rewrite
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解构 beq_nat n m，将假设 beq_nat n m = true 转换为假设 n = m；然后我们必须重写
- en: using this assumption to complete the case.
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个假设来完成这种情况。
- en: We can streamline this by defining an inductive proposition that
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个归纳命题来简化这个过程
- en: yields a better case-analysis principle for beq_nat n m.
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为 beq_nat n m 提供更好的案例分析原则。
- en: Instead of generating an equation such as beq_nat n m = true,
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是生成一个等式如 beq_nat n m = true，
- en: which is generally not directly useful, this principle gives us
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这通常不直接有用，这个原则给了我们
- en: 'right away the assumption we really need: n = m.'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们真正需要的假设：n = m。
- en: We'll actually define something a bit more general, which can be
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上我们会定义一些更一般的东西，可以
- en: 'used with arbitrary properties (and not just equalities):'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于任意属性（而不仅仅是相等）：
- en: '[PRE75]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Before explaining this, let''s rearrange it a little: Since the'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在解释这个之前，让我们稍微重新排列一下：由于
- en: types of both ReflectT and ReflectF begin with
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ReflectT 和 ReflectF 类型的开始都是
- en: ∀ (P:Prop), we can make the definition a bit more readable
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ∀ (P:Prop)，我们可以使定义更易读一些
- en: and easier to work with by making P a parameter of the whole
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使 P 成为整个参数的一部分更容易处理
- en: Inductive declaration.
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 归纳声明。
- en: '[PRE76]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The reflect property takes two arguments: a proposition'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反射属性接受两个参数：一个命题
- en: P and a boolean b.  Intuitively, it states that the property
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P 和一个布尔值 b。直觉上，它陈述了属性
- en: 'P is *reflected* in (i.e., equivalent to) the boolean b: P'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P 在（即等价于）布尔值 b 中*反映*：P
- en: holds if and only if b = true.  To see this, notice that, by
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当且仅当 b = true 时成立。要看到这一点，请注意，通过
- en: definition, the only way we can produce evidence that reflect P true holds is
    by showing that P is true and using the
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义，我们能够产生证据表明 reflect P true 成立的唯一方法是通过显示 P 为真并使用
- en: ReflectT constructor.  If we invert this statement, this means
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ReflectT 构造函数。如果我们反转这个陈述，这意味着
- en: that it should be possible to extract evidence for P from a
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该能够从一个中提取证据证明 P
- en: proof of reflect P true.  Conversely, the only way to show
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: reflect P true 的证明。反之，显示的唯一方法
- en: reflect P false is by combining evidence for ¬ P with the
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反映 P false 是通过将证据组合为 ¬ P 与
- en: ReflectF constructor.
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ReflectF 构造函数。
- en: It is easy to formalize this intuition and show that the two
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很容易形式化这种直觉并展示这两个
- en: 'statements are indeed equivalent:'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 陈述确实是等价的：
- en: '[PRE77]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Exercise: 2 stars, recommended (reflect_iff)'
  id: totrans-618
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星，推荐（reflect_iff）
- en: '[PRE78]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ☐
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: The advantage of reflect over the normal "if and only if"
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Reflect 相对于正常的“当且仅当”的优势
- en: connective is that, by destructing a hypothesis or lemma of the
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接词是，通过析构一个假设或引理
- en: form reflect P b, we can perform case analysis on b while at
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 形式 reflect P b，我们可以对 b 进行案例分析��时
- en: the same time generating appropriate hypothesis in the two
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时在两个中生成适当的假设
- en: branches (P in the first subgoal and ¬ P in the second).
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分支（第一个子目标中的 P 和第二个子目标中的 ¬ P）。
- en: '[PRE79]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The new proof of filter_not_empty_In now goes as follows.
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: filter_not_empty_In 的新证明现在如下。
- en: Notice how the calls to destruct and apply are combined into a
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意将析构和应用的调用组合成一个
- en: single call to destruct.
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单次调用析构。
- en: (To see this clearly, look at the two proofs of
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （要清楚地看到这一点，请看两个证明
- en: filter_not_empty_In with Coq and observe the differences in
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Coq 中的 filter_not_empty_In 并观察
- en: proof state at the beginning of the first case of the
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明状态在第一个案例的开始处
- en: destruct.)
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 析构。）
- en: '[PRE80]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Exercise: 3 stars, recommended (beq_natP_practice)'
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，推荐（beq_natP_practice）
- en: 'Use beq_natP as above to prove the following:'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 beq_natP 如上所述来证明以下内容：
- en: '[PRE81]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ☐
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: This technique gives us only a small gain in convenience for
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术只为我们带来了一点方便，用于
- en: the proofs we've seen here, but using reflect consistently often
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里看到的证明，但是一致使用 reflect 经常
- en: leads to noticeably shorter and clearer scripts as proofs get
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导致明显更短更清晰的脚本，随着证明的进行
- en: larger.  We'll see many more examples in later chapters.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更大。我们将在后面的章节中看到更多例子。
- en: The use of the reflect property was popularized by *SSReflect*,
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反射属性的使用被*SSReflect*所推广，
- en: a Coq library that has been used to formalize important results in
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个 Coq 库已被用来形式化重要结果
- en: mathematics, including as the 4-color theorem and the
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数学，包括四色定理和
- en: Feit-Thompson theorem.  The name SSReflect stands for *small-scale reflection*,
    i.e., the pervasive use of reflection to simplify
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 菲特-汤普森定理。SSReflect 的名称代表*小规模反射*，即，广泛使用反射来简化
- en: small proof steps with boolean computations.
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过布尔计算进行小的证明步骤。
- en: '[PRE82]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Inductive nostutter {X:Type} : list X → Prop :='
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳无重复 {X:Type}：列表 X → 命题 :=
- en: (* FILL IN HERE *)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *)
- en: .
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: '[PRE83]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Example test_nostutter_1: nostutter [3;1;4;1;5;6].'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_nostutter_1: nostutter [3;1;4;1;5;6]。'
- en: (* FILL IN HERE *) Admitted.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: (*    Proof. repeat constructor; apply beq_nat_false_iff; auto.   Qed. *)
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: (*    证明。重复构造函数；应用 beq_nat_false_iff；自动。   完成。*)
- en: 'Example test_nostutter_2:  nostutter (@nil nat).'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_nostutter_2:  nostutter (@nil nat)。'
- en: (* FILL IN HERE *) Admitted.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*) 已承认。
- en: (*    Proof. repeat constructor; apply beq_nat_false_iff; auto.   Qed. *)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: (*    证明。重复构造; 应用beq_nat_false_iff; 自动。Qed。*)
- en: 'Example test_nostutter_3:  nostutter [5].'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_nostutter_3:  nostutter [5]。'
- en: (* FILL IN HERE *) Admitted.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*) 已承认。
- en: (*    Proof. repeat constructor; apply beq_nat_false; auto. Qed. *)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: (*    证明。重复构造; 应用beq_nat_false; 自动。Qed。*)
- en: 'Example test_nostutter_4:      not (nostutter [3;1;1;4]).'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_nostutter_4:      不是 (nostutter [3;1;1;4])。'
- en: (* FILL IN HERE *) Admitted.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*) 已承认。
- en: (*    Proof. intro.   repeat match goal with     h: nostutter _ |- _ => inversion h; clear h; subst
      end.   contradiction H[1]; auto. Qed. *)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '(*    证明。介绍。 重复匹配目标  h: nostutter _ |- _ => 反转 h; 清除 h; 替换  结束。 反驳 H[1]; 自动。Qed。*)'
- en: '[PRE84]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[1;4;6;2;3]'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '[1;4;6;2;3]'
- en: is an in-order merge of
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是一个顺序合并的
- en: '[PRE85]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[4;3].'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '[4;3]。'
- en: 'Now, suppose we have a set X, a function test: X→bool, and a'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个集合X，一个函数test：X→bool，和一个
- en: list l of type list X.  Suppose further that l is an
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型为list X的列表l。进一步假设l是一个
- en: in-order merge of two lists, l[1] and l[2], such that every item
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对两个列表l[1]和l[2]进行顺序合并，使得每个项目
- en: in l[1] satisfies test and no item in l[2] satisfies test.  Then
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在l[1]中满足测试且在l[2]中没有项目满足测试。然后
- en: filter test l = l[1].
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: filter test l = l[1]。
- en: Translate this specification into a Coq theorem and prove
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此规范转化为一个Coq定理并证明
- en: it.  (You'll need to begin by defining what it means for one list
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它。（你需要开始定义一个列表的含义
- en: to be a merge of two others.  Do this with an inductive relation,
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被另外两个合并。用一个归纳关系来做到这一点，
- en: not a Fixpoint.)
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不是一个Fixpoint。）
- en: '[PRE86]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ☐
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 5 stars, advanced, optional (filter_challenge_2)'
  id: totrans-681
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：5星，高级，可选（filter_challenge_2）
- en: A different way to characterize the behavior of filter goes like
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种描述filter行为的方式是
- en: 'this: Among all subsequences of l with the property that test'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个：在所有具有测试属性的l子序列中
- en: evaluates to true on all their members, filter test l is the
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对它们的所有成员求值为true，filter test l是
- en: longest.  Formalize this claim and prove it.
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最长。形式化这个声明并证明它。
- en: '[PRE87]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ☐
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 4 stars, optional (palindromes)'
  id: totrans-688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：4星，可选（palindromes）
- en: A palindrome is a sequence that reads the same backwards as
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回文是一个反向读取相同的序列
- en: forwards.
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向前。
- en: 'Define an inductive proposition pal on list X that captures what it means to
    be a palindrome. (Hint: You''ll need three cases. Your definition should be based
    on the structure of the list; just having a single constructor like'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个关于列表X的归纳命题pal，捕捉回文的含义。（提示：你需要三种情况。你的定义应基于列表的结构；不仅仅是一个单一的构造函数，就像
- en: '[PRE88]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Prove (pal_app_rev) that
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明（pal_app_rev）
- en: '[PRE89]'
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Prove (pal_rev that)
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明（pal_rev）
- en: '[PRE90]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ☐
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 5 stars, optional (palindrome_converse)'
  id: totrans-699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：5星，可选（palindrome_converse）
- en: Again, the converse direction is significantly more difficult, due
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，由于
- en: to the lack of evidence.  Using your definition of pal from the
  id: totrans-701
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缺乏证据。使用你从中定义的pal
- en: previous exercise, prove that
  id: totrans-702
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个练习，证明
- en: '[PRE92]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: (* FILL IN HERE *)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*)
- en: '[PRE93]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: (* Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=    match l with    |  => False
       | x' :: l' => x' = x \/ In A x l'    end *)
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: (* Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=    match l with    |  => False
       | x' :: l' => x' = x \/ In A x l'    end *)
- en: '[PRE94]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: (* FILL IN HERE *)
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*)
- en: '[PRE95]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: (* FILL IN HERE *)
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*)
- en: '[PRE96]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: (* FILL IN HERE *)
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*)
- en: '[PRE97]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Lemma in_split : ∀(X:Type) (x:X) (l:list X),'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 in_split: ∀(X:Type) (x:X) (l:list X)，'
- en: In x l →
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在x l中→
- en: '∃l[1] l[2], l = l[1] ++ x :: l[2].'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '∃l[1] l[2]，l = l[1] ++ x :: l[2]。'
- en: Proof.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*) 已承认。
- en: '[PRE98]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Inductive repeats {X:Type} : list X → Prop :='
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳重复{X:Type}：列表X的重复。
- en: (* FILL IN HERE *)
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*)
- en: .
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: '[PRE99]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Theorem pigeonhole_principle: ∀(X:Type) (l[1]  l[2]:list X),'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 鸽巢原理：∀(X:Type) (l[1]  l[2]:list X)，
- en: excluded_middle →
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 排除中间→
- en: (∀x, In x l[1] → In x l[2]) →
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: (∀x, In x l[1] → In x l[2]) →
- en: length l[2] < length l[1] →
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 长度l[2] < 长度l[1] →
- en: repeats l[1].
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 重复l[1]。
- en: Proof.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros X l[1]. induction l[1] as [|x l[1]' IHl1'].
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: intros X l[1]。对l[1]进行归纳，如同 [|x l[1]' IHl1']。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*) 已承认。
- en: '[PRE100]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
