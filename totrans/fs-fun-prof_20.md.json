["```\n/// An alias for a float\ntype Distance = float\n\n/// Use a unit of measure to make it clear that the angle is in degrees, not radians\ntype [<Measure>] Degrees\n\n/// An alias for a float of Degrees\ntype Angle = float<Degrees>\n\n/// Enumeration of available pen states\ntype PenState = Up | Down\n\n/// Enumeration of available pen colors\ntype PenColor = Black | Red | Blue \n```", "```\n/// A structure to store the (x,y) coordinates\ntype Position = {x:float; y:float} \n```", "```\n// round a float to two places to make it easier to read\nlet round2 (flt:float) = Math.Round(flt,2)\n\n/// calculate a new position from the current position given an angle and a distance\nlet calcNewPosition (distance:Distance) (angle:Angle) currentPos = \n    // Convert degrees to radians with 180.0 degrees = 1 pi radian\n    let angleInRads = angle * (Math.PI/180.0) * 1.0<1/Degrees> \n    // current pos\n    let x0 = currentPos.x\n    let y0 = currentPos.y\n    // new pos\n    let x1 = x0 + (distance * cos angleInRads)\n    let y1 = y0 + (distance * sin angleInRads)\n    // return a new Position\n    {x=round2 x1; y=round2 y1} \n```", "```\n/// Default initial state\nlet initialPosition,initialColor,initialPenState = \n    {x=0.0; y=0.0}, Black, Down \n```", "```\nlet dummyDrawLine log oldPos newPos color =\n    // for now just log it\n    log (sprintf \"...Draw line from (%0.1f,%0.1f) to (%0.1f,%0.1f) using %A\" oldPos.x oldPos.y newPos.x newPos.y color) \n```", "```\ntype Turtle(log) =\n\n    let mutable currentPosition = initialPosition \n    let mutable currentAngle = 0.0<Degrees>\n    let mutable currentColor = initialColor\n    let mutable currentPenState = initialPenState\n\n    member this.Move(distance) =\n        log (sprintf \"Move %0.1f\" distance)\n        // calculate new position \n        let newPosition = calcNewPosition distance currentAngle currentPosition \n        // draw line if needed\n        if currentPenState = Down then\n            dummyDrawLine log currentPosition newPosition currentColor\n        // update the state\n        currentPosition <- newPosition\n\n    member this.Turn(angle) =\n        log (sprintf \"Turn %0.1f\" angle)\n        // calculate new angle\n        let newAngle = (currentAngle + angle) % 360.0<Degrees>\n        // update the state\n        currentAngle <- newAngle \n\n    member this.PenUp() =\n        log \"Pen up\" \n        currentPenState <- Up\n\n    member this.PenDown() =\n        log \"Pen down\" \n        currentPenState <- Down\n\n    member this.SetColor(color) =\n        log (sprintf \"SetColor %A\" color)\n        currentColor <- color \n```", "```\n/// Function to log a message\nlet log message =\n    printfn \"%s\" message \n\nlet drawTriangle() = \n    let turtle = Turtle(log)\n    turtle.Move 100.0 \n    turtle.Turn 120.0<Degrees>\n    turtle.Move 100.0 \n    turtle.Turn 120.0<Degrees>\n    turtle.Move 100.0\n    turtle.Turn 120.0<Degrees>\n    // back home at (0,0) with angle 0 \n```", "```\nMove 100.0\n...Draw line from (0.0,0.0) to (100.0,0.0) using Black\nTurn 120.0\nMove 100.0\n...Draw line from (100.0,0.0) to (50.0,86.6) using Black\nTurn 120.0\nMove 100.0\n...Draw line from (50.0,86.6) to (0.0,0.0) using Black\nTurn 120.0 \n```", "```\nlet drawPolygon n = \n    let angle = 180.0 - (360.0/float n) \n    let angleDegrees = angle * 1.0<Degrees>\n    let turtle = Turtle(log)\n\n    // define a function that draws one side\n    let drawOneSide() = \n        turtle.Move 100.0 \n        turtle.Turn angleDegrees \n\n    // repeat for all sides\n    for i in [1..n] do\n        drawOneSide() \n```", "```\nmodule Turtle = \n\n    type TurtleState = {\n        position : Position\n        angle : float<Degrees>\n        color : PenColor\n        penState : PenState\n    }\n\n    let initialTurtleState = {\n        position = initialPosition\n        angle = 0.0<Degrees>\n        color = initialColor\n        penState = initialPenState\n    } \n```", "```\nmodule Turtle = \n\n    // [state type snipped]\n\n    let move log distance state =\n        log (sprintf \"Move %0.1f\" distance)\n        // calculate new position \n        let newPosition = calcNewPosition distance state.angle state.position \n        // draw line if needed\n        if state.penState = Down then\n            dummyDrawLine log state.position newPosition state.color\n        // update the state\n        {state with position = newPosition}\n\n    let turn log angle state =\n        log (sprintf \"Turn %0.1f\" angle)\n        // calculate new angle\n        let newAngle = (state.angle + angle) % 360.0<Degrees>\n        // update the state\n        {state with angle = newAngle}\n\n    let penUp log state =\n        log \"Pen up\" \n        {state with penState = Up}\n\n    let penDown log state =\n        log \"Pen down\" \n        {state with penState = Down}\n\n    let setColor log color state =\n        log (sprintf \"SetColor %A\" color)\n        {state with color = color} \n```", "```\n/// Function to log a message\nlet log message =\n    printfn \"%s\" message \n\n// versions with log baked in (via partial application)\nlet move = Turtle.move log\nlet turn = Turtle.turn log\nlet penDown = Turtle.penDown log\nlet penUp = Turtle.penUp log\nlet setColor = Turtle.setColor log \n```", "```\nlet drawTriangle() = \n    Turtle.initialTurtleState\n    |> move 100.0 \n    |> turn 120.0<Degrees>\n    |> move 100.0 \n    |> turn 120.0<Degrees>\n    |> move 100.0 \n    |> turn 120.0<Degrees>\n    // back home at (0,0) with angle 0 \n```", "```\nlet drawPolygon n = \n    let angle = 180.0 - (360.0/float n) \n    let angleDegrees = angle * 1.0<Degrees>\n\n    // define a function that draws one side\n    let oneSide state sideNumber = \n        state\n        |> move 100.0 \n        |> turn angleDegrees \n\n    // repeat for all sides\n    [1..n] \n    |> List.fold oneSide Turtle.initialTurtleState \n```", "```\nexception TurtleApiException of string \n```", "```\n// convert the distance parameter to a float, or throw an exception\nlet validateDistance distanceStr =\n    try\n        float distanceStr \n    with\n    | ex -> \n        let msg = sprintf \"Invalid distance '%s' [%s]\" distanceStr  ex.Message\n        raise (TurtleApiException msg)\n\n// convert the angle parameter to a float<Degrees>, or throw an exception\nlet validateAngle angleStr =\n    try\n        (float angleStr) * 1.0<Degrees> \n    with\n    | ex -> \n        let msg = sprintf \"Invalid angle '%s' [%s]\" angleStr ex.Message\n        raise (TurtleApiException msg)\n\n// convert the color parameter to a PenColor, or throw an exception\nlet validateColor colorStr =\n    match colorStr with\n    | \"Black\" -> Black\n    | \"Blue\" -> Blue\n    | \"Red\" -> Red\n    | _ -> \n        let msg = sprintf \"Color '%s' is not recognized\" colorStr\n        raise (TurtleApiException msg) \n```", "```\ntype TurtleApi() =\n\n    let turtle = Turtle(log)\n\n    member this.Exec (commandStr:string) = \n        let tokens = commandStr.Split(' ') |> List.ofArray |> List.map trimString\n        match tokens with\n        | [ \"Move\"; distanceStr ] -> \n            let distance = validateDistance distanceStr \n            turtle.Move distance \n        | [ \"Turn\"; angleStr ] -> \n            let angle = validateAngle angleStr\n            turtle.Turn angle  \n        | [ \"Pen\"; \"Up\" ] -> \n            turtle.PenUp()\n        | [ \"Pen\"; \"Down\" ] -> \n            turtle.PenDown()\n        | [ \"SetColor\"; colorStr ] -> \n            let color = validateColor colorStr \n            turtle.SetColor color\n        | _ -> \n            let msg = sprintf \"Instruction '%s' is not recognized\" commandStr\n            raise (TurtleApiException msg) \n```", "```\nlet drawPolygon n = \n    let angle = 180.0 - (360.0/float n) \n    let api = TurtleApi()\n\n    // define a function that draws one side\n    let drawOneSide() = \n        api.Exec \"Move 100.0\"\n        api.Exec (sprintf \"Turn %f\" angle)\n\n    // repeat for all sides\n    for i in [1..n] do\n        drawOneSide() \n```", "```\nlet triggerError() = \n    let api = TurtleApi()\n    api.Exec \"Move bad\" \n```", "```\nException of type 'TurtleApiException' was thrown. \n```", "```\ntype TurtleApi() =\n\n    let mutable state = initialTurtleState\n\n    /// Update the mutable state value\n    let updateState newState =\n        state <- newState \n```", "```\nlet validateDistance distanceStr =\n    try\n        Success (float distanceStr)\n    with\n    | ex -> \n        Failure (InvalidDistance distanceStr) \n```", "```\ntype ErrorMessage = \n    | InvalidDistance of string\n    | InvalidAngle of string\n    | InvalidColor of string\n    | InvalidCommand of string \n```", "```\n// lift current state to Result\nlet stateR = returnR state\n\n// get the distance as a Result\nlet distanceR = validateDistance distanceStr \n\n// call \"move\" lifted to the world of Results\nlift2R move distanceR stateR \n```", "```\n/// Execute the command string, and return a Result\n/// Exec : commandStr:string -> Result<unit,ErrorMessage>\nmember this.Exec (commandStr:string) = \n    let tokens = commandStr.Split(' ') |> List.ofArray |> List.map trimString\n\n    // lift current state to Result\n    let stateR = returnR state\n\n    // calculate the new state\n    let newStateR = \n        match tokens with\n        | [ \"Move\"; distanceStr ] -> \n            // get the distance as a Result\n            let distanceR = validateDistance distanceStr \n\n            // call \"move\" lifted to the world of Results\n            lift2R move distanceR stateR\n\n        | [ \"Turn\"; angleStr ] -> \n            let angleR = validateAngle angleStr \n            lift2R turn angleR stateR\n\n        | [ \"Pen\"; \"Up\" ] -> \n            returnR (penUp state)\n\n        | [ \"Pen\"; \"Down\" ] -> \n            returnR (penDown state)\n\n        | [ \"SetColor\"; colorStr ] -> \n            let colorR = validateColor colorStr\n            lift2R setColor colorR stateR\n\n        | _ -> \n            Failure (InvalidCommand commandStr)\n\n    // Lift `updateState` into the world of Results and \n    // call it with the new state.\n    mapR updateState newStateR\n\n    // Return the final result (output of updateState) \n```", "```\nlet drawTriangle() = \n    let api = TurtleApi()\n    result {\n        do! api.Exec \"Move 100\"\n        do! api.Exec \"Turn 120\"\n        do! api.Exec \"Move 100\"\n        do! api.Exec \"Turn 120\"\n        do! api.Exec \"Move 100\"\n        do! api.Exec \"Turn 120\"\n        } \n```", "```\nlet drawPolygon n = \n    let angle = 180.0 - (360.0/float n) \n    let api = TurtleApi()\n\n    // define a function that draws one side\n    let drawOneSide() = result {\n        do! api.Exec \"Move 100.0\"\n        do! api.Exec (sprintf \"Turn %f\" angle)\n        }\n\n    // repeat for all sides\n    result {\n        for i in [1..n] do\n            do! drawOneSide() \n    } \n```", "```\ntype TurtleCommand = \n    | Move of Distance \n    | Turn of Angle\n    | PenUp\n    | PenDown\n    | SetColor of PenColor \n```", "```\ntype TurtleAgent() =\n\n    /// Function to log a message\n    let log message =\n        printfn \"%s\" message \n\n    // logged versions \n    let move = Turtle.move log\n    let turn = Turtle.turn log\n    let penDown = Turtle.penDown log\n    let penUp = Turtle.penUp log\n    let setColor = Turtle.setColor log\n\n    let mailboxProc = MailboxProcessor.Start(fun inbox ->\n        let rec loop turtleState = async { \n            // read a command message from teh queue\n            let! command = inbox.Receive()\n            // create a new state from handling the message\n            let newState = \n                match command with\n                | Move distance ->\n                    move distance turtleState\n                | Turn angle ->\n                    turn angle turtleState\n                | PenUp ->\n                    penUp turtleState\n                | PenDown ->\n                    penDown turtleState\n                | SetColor color ->\n                    setColor color turtleState\n            return! loop newState  \n            }\n        loop Turtle.initialTurtleState )\n\n    // expose the queue externally\n    member this.Post(command) = \n        mailboxProc.Post command \n```", "```\nlet stateR = returnR state\nlet distanceR = validateDistance distanceStr \nlift2R move distanceR stateR \n```", "```\nresult {\n    let! distance = validateDistance distanceStr \n    move distance state\n    } \n```", "```\nresult {\n    let! distance = validateDistance distanceStr \n    let command = Move distance \n    turtleAgent.Post command\n    } \n```", "```\nmember this.Exec (commandStr:string) = \n    let tokens = commandStr.Split(' ') |> List.ofArray |> List.map trimString\n\n    // calculate the new state\n    let result = \n        match tokens with\n        | [ \"Move\"; distanceStr ] -> result {\n            let! distance = validateDistance distanceStr \n            let command = Move distance \n            turtleAgent.Post command\n            } \n\n        | [ \"Turn\"; angleStr ] -> result {\n            let! angle = validateAngle angleStr \n            let command = Turn angle\n            turtleAgent.Post command\n            }\n\n        | [ \"Pen\"; \"Up\" ] -> result {\n            let command = PenUp\n            turtleAgent.Post command\n            }\n\n        | [ \"Pen\"; \"Down\" ] -> result { \n            let command = PenDown\n            turtleAgent.Post command\n            }\n\n        | [ \"SetColor\"; colorStr ] -> result { \n            let! color = validateColor colorStr\n            let command = SetColor color\n            turtleAgent.Post command\n            }\n\n        | _ -> \n            Failure (InvalidCommand commandStr)\n\n    // return any errors\n    result \n```", "```\ntype ITurtle =\n    abstract Move : Distance -> unit\n    abstract Turn : Angle -> unit\n    abstract PenUp : unit -> unit\n    abstract PenDown : unit -> unit\n    abstract SetColor : PenColor -> unit \n```", "```\ntype TurtleApi(turtle: ITurtle) =\n\n    // other code\n\n    member this.Exec (commandStr:string) = \n        let tokens = commandStr.Split(' ') |> List.ofArray |> List.map trimString\n        match tokens with\n        | [ \"Move\"; distanceStr ] -> \n            let distance = validateDistance distanceStr \n            turtle.Move distance \n        | [ \"Turn\"; angleStr ] -> \n            let angle = validateAngle angleStr\n            turtle.Turn angle  \n        // etc \n```", "```\nlet normalSize() = \n    let log = printfn \"%s\"\n    let turtle = Turtle(log)\n\n    // return an interface wrapped around the Turtle\n    {new ITurtle with\n        member this.Move dist = turtle.Move dist\n        member this.Turn angle = turtle.Turn angle\n        member this.PenUp() = turtle.PenUp()\n        member this.PenDown() = turtle.PenDown()\n        member this.SetColor color = turtle.SetColor color\n    } \n```", "```\nlet halfSize() = \n    let normalSize = normalSize() \n\n    // return a decorated interface \n    {new ITurtle with\n        member this.Move dist = normalSize.Move (dist/2.0)   // halved!!\n        member this.Turn angle = normalSize.Turn angle\n        member this.PenUp() = normalSize.PenUp()\n        member this.PenDown() = normalSize.PenDown()\n        member this.SetColor color = normalSize.SetColor color\n    } \n```", "```\nlet drawTriangle(api:TurtleApi) = \n    api.Exec \"Move 100\"\n    api.Exec \"Turn 120\"\n    api.Exec \"Move 100\"\n    api.Exec \"Turn 120\"\n    api.Exec \"Move 100\"\n    api.Exec \"Turn 120\" \n```", "```\nlet iTurtle = normalSize()   // an ITurtle type\nlet api = TurtleApi(iTurtle)\ndrawTriangle(api) \n```", "```\nMove 100.0\n...Draw line from (0.0,0.0) to (100.0,0.0) using Black\nTurn 120.0\nMove 100.0\n...Draw line from (100.0,0.0) to (50.0,86.6) using Black\nTurn 120.0\nMove 100.0\n...Draw line from (50.0,86.6) to (0.0,0.0) using Black\nTurn 120.0 \n```", "```\nlet iTurtle = halfSize()\nlet api = TurtleApi(iTurtle)\ndrawTriangle(api) \n```", "```\nMove 50.0\n...Draw line from (0.0,0.0) to (50.0,0.0) using Black\nTurn 120.0\nMove 50.0\n...Draw line from (50.0,0.0) to (25.0,43.3) using Black\nTurn 120.0\nMove 50.0\n...Draw line from (25.0,43.3) to (0.0,0.0) using Black\nTurn 120.0 \n```", "```\ntype TurtleFunctions = {\n    move : Distance -> TurtleState -> TurtleState\n    turn : Angle -> TurtleState -> TurtleState\n    penUp : TurtleState -> TurtleState\n    penDown : TurtleState -> TurtleState\n    setColor : PenColor -> TurtleState -> TurtleState\n    } \n```", "```\ntype TurtleApi(turtleFunctions: TurtleFunctions) =\n\n    let mutable state = initialTurtleState \n```", "```\nmember this.Exec (commandStr:string) = \n    let tokens = commandStr.Split(' ') |> List.ofArray |> List.map trimString\n\n    // return Success of unit, or Failure\n    match tokens with\n    | [ \"Move\"; distanceStr ] -> result {\n        let! distance = validateDistance distanceStr \n        let newState = turtleFunctions.move distance state\n        updateState newState\n        }\n    | [ \"Turn\"; angleStr ] -> result {\n        let! angle = validateAngle angleStr \n        let newState = turtleFunctions.turn angle state\n        updateState newState\n        }\n    // etc \n```", "```\nlet normalSize() = \n    let log = printfn \"%s\"\n    // return a record of functions\n    {\n        move = Turtle.move log \n        turn = Turtle.turn log \n        penUp = Turtle.penUp log\n        penDown = Turtle.penDown log\n        setColor = Turtle.setColor log \n    } \n```", "```\nlet halfSize() = \n    let normalSize = normalSize() \n    // return a reduced turtle\n    { normalSize with\n        move = fun dist -> normalSize.move (dist/2.0) \n    } \n```", "```\nlet turtleFns = normalSize()  // a TurtleFunctions type\nlet api = TurtleApi(turtleFns)\ndrawTriangle(api) \n```", "```\nmember this.Exec move turn penUp penDown setColor (commandStr:string) = \n    ... \n```", "```\nmember this.Exec move turn penUp penDown setColor (commandStr:string) = \n    ...\n\n    // return Success of unit, or Failure\n    match tokens with\n    | [ \"Move\"; distanceStr ] -> result {\n        let! distance = validateDistance distanceStr \n        let newState = move distance state   // use `move` function that was passed in\n        updateState newState\n        }\n    | [ \"Turn\"; angleStr ] -> result {\n        let! angle = validateAngle angleStr   \n        let newState = turn angle state   // use `turn` function that was passed in\n        updateState newState\n        }\n    ... \n```", "```\nlet log = printfn \"%s\"\nlet move = Turtle.move log \nlet turn = Turtle.turn log \nlet penUp = Turtle.penUp log\nlet penDown = Turtle.penDown log\nlet setColor = Turtle.setColor log \n\nlet normalSize() = \n    let api = TurtleApi() \n    // partially apply the functions\n    api.Exec move turn penUp penDown setColor \n    // the return value is a function: \n    //     string -> Result<unit,ErrorMessage> \n\nlet halfSize() = \n    let moveHalf dist = move (dist/2.0)  \n    let api = TurtleApi() \n    // partially apply the functions\n    api.Exec moveHalf turn penUp penDown setColor \n    // the return value is a function: \n    //     string -> Result<unit,ErrorMessage> \n```", "```\n// the API type is just a function\ntype ApiFunction = string -> Result<unit,ErrorMessage>\n\nlet drawTriangle(api:ApiFunction) = \n    result {\n        do! api \"Move 100\"\n        do! api \"Turn 120\"\n        do! api \"Move 100\"\n        do! api \"Turn 120\"\n        do! api \"Move 100\"\n        do! api \"Turn 120\"\n        } \n```", "```\nlet apiFn = normalSize()  // string -> Result<unit,ErrorMessage>\ndrawTriangle(apiFn) \n\nlet apiFn = halfSize()\ndrawTriangle(apiFn) \n```", "```\nlet mockApi s = \n    printfn \"[MockAPI] %s\" s\n    Success ()\n\ndrawTriangle(mockApi) \n```", "```\ntype TurtleCommand = \n    | Move of Distance \n    | Turn of Angle\n    | PenUp\n    | PenDown\n    | SetColor of PenColor \n```", "```\nmember this.Exec turtleFn (commandStr:string) = \n    ...\n\n    // return Success of unit, or Failure\n    match tokens with\n    | [ \"Move\"; distanceStr ] -> result {\n        let! distance = validateDistance distanceStr \n        let command =  Move distance      // create a Command object\n        let newState = turtleFn command state\n        updateState newState\n        }\n    | [ \"Turn\"; angleStr ] -> result {\n        let! angle = validateAngle angleStr \n        let command =  Turn angle      // create a Command object\n        let newState = turtleFn command state\n        updateState newState\n        }\n    ... \n```", "```\nlet log = printfn \"%s\"\nlet move = Turtle.move log \nlet turn = Turtle.turn log \nlet penUp = Turtle.penUp log\nlet penDown = Turtle.penDown log\nlet setColor = Turtle.setColor log \n\nlet normalSize() = \n    let turtleFn = function\n        | Move dist -> move dist \n        | Turn angle -> turn angle\n        | PenUp -> penUp \n        | PenDown -> penDown \n        | SetColor color -> setColor color\n\n    // partially apply the function to the API\n    let api = TurtleApi() \n    api.Exec turtleFn \n    // the return value is a function: \n    //     string -> Result<unit,ErrorMessage> \n\nlet halfSize() = \n    let turtleFn = function\n        | Move dist -> move (dist/2.0)  \n        | Turn angle -> turn angle\n        | PenUp -> penUp \n        | PenDown -> penDown \n        | SetColor color -> setColor color\n\n    // partially apply the function to the API\n    let api = TurtleApi() \n    api.Exec turtleFn \n    // the return value is a function: \n    //     string -> Result<unit,ErrorMessage> \n```", "```\nlet api = normalSize()\ndrawTriangle(api) \n\nlet api = halfSize()\ndrawTriangle(api) \n```", "```\nTurtleState -> 'a * TurtleState \n```", "```\ntype TurtleStateComputation<'a> = \n    TurtleStateComputation of (Turtle.TurtleState -> 'a * Turtle.TurtleState) \n```", "```\nlet runT turtle state = \n    // pattern match against the turtle\n    // to extract the inner function\n    let (TurtleStateComputation innerFn) = turtle \n    // run the inner function with the passed in state\n    innerFn state \n```", "```\n// define a computation expression builder\ntype TurtleBuilder() =\n    member this.Return(x) = returnT x\n    member this.Bind(x,f) = bindT f x\n\n// create an instance of the computation expression builder\nlet turtle = TurtleBuilder() \n```", "```\nlet move dist = \n    toUnitComputation (Turtle.move log dist)\n// val move : Distance -> TurtleStateComputation<unit>\n\nlet turn angle = \n    toUnitComputation (Turtle.turn log angle)\n// val turn : Angle -> TurtleStateComputation<unit>\n\nlet penDown = \n    toUnitComputation (Turtle.penDown log)\n// val penDown : TurtleStateComputation<unit>\n\nlet penUp = \n    toUnitComputation (Turtle.penUp log)\n// val penUp : TurtleStateComputation<unit>\n\nlet setColor color = \n    toUnitComputation (Turtle.setColor log color)\n// val setColor : PenColor -> TurtleStateComputation<unit> \n```", "```\nlet drawTriangle() = \n    // define a set of instructions \n    let t = turtle {\n        do! move 100.0 \n        do! turn 120.0<Degrees>\n        do! move 100.0 \n        do! turn 120.0<Degrees>\n        do! move 100.0 \n        do! turn 120.0<Degrees>\n        } \n\n    // finally, run them using the initial state as input\n    runT t initialTurtleState \n```", "```\nlet oneSide = turtle {\n    do! move 100.0 \n    do! turn angleDegrees \n    } \n```", "```\n// chain two turtle operations in sequence\nlet chain f g  = turtle {\n    do! f\n    do! g\n    } \n\n// create a list of operations, one for each side\nlet sides = List.replicate n oneSide\n\n// chain all the sides into one operation\nlet all = sides |> List.reduce chain \n```", "```\nlet drawPolygon n = \n    let angle = 180.0 - (360.0/float n) \n    let angleDegrees = angle * 1.0<Degrees>\n\n    // define a function that draws one side\n    let oneSide = turtle {\n        do! move 100.0 \n        do! turn angleDegrees \n        }\n\n    // chain two turtle operations in sequence\n    let chain f g  = turtle {\n        do! f\n        do! g\n        } \n\n    // create a list of operations, one for each side\n    let sides = List.replicate n oneSide\n\n    // chain all the sides into one operation\n    let all = sides |> List.reduce chain \n\n    // finally, run them using the initial state\n    runT all initialTurtleState \n```", "```\ntype TurtleCommand = \n    | Move of Distance \n    | Turn of Angle\n    | PenUp\n    | PenDown\n    | SetColor of PenColor \n```", "```\n/// Apply a command to the turtle state and return the new state \nlet applyCommand state command =\n    match command with\n    | Move distance ->\n        move distance state\n    | Turn angle ->\n        turn angle state\n    | PenUp ->\n        penUp state\n    | PenDown ->\n        penDown state\n    | SetColor color ->\n        setColor color state \n```", "```\n/// Run list of commands in one go\nlet run aListOfCommands = \n    aListOfCommands \n    |> List.fold applyCommand Turtle.initialTurtleState \n```", "```\nlet drawTriangle() = \n    // create the list of commands\n    let commands = [\n        Move 100.0 \n        Turn 120.0<Degrees>\n        Move 100.0 \n        Turn 120.0<Degrees>\n        Move 100.0 \n        Turn 120.0<Degrees>\n        ]\n    // run them\n    run commands \n```", "```\nlet drawPolygon n = \n    let angle = 180.0 - (360.0/float n) \n    let angleDegrees = angle * 1.0<Degrees>\n\n    // define a function that draws one side\n    let drawOneSide sideNumber = [\n        Move 100.0\n        Turn angleDegrees\n        ]\n\n    // repeat for all sides\n    let commands = \n        [1..n] |> List.collect drawOneSide\n\n    // run the commands\n    run commands \n```", "```\ntype TurtleId = System.Guid\n\n/// A desired action on a turtle\ntype TurtleCommandAction = \n    | Move of Distance \n    | Turn of Angle\n    | PenUp \n    | PenDown \n    | SetColor of PenColor\n\n/// A command representing a desired action addressed to a specific turtle\ntype TurtleCommand = {\n    turtleId : TurtleId\n    action : TurtleCommandAction \n    } \n```", "```\n/// An event representing a state change that happened\ntype StateChangedEvent = \n    | Moved of Distance \n    | Turned of Angle\n    | PenWentUp \n    | PenWentDown \n    | ColorChanged of PenColor\n\n/// An event representing a move that happened\n/// This can be easily translated into a line-drawing activity on a canvas\ntype MovedEvent = {\n    startPos : Position \n    endPos : Position \n    penColor : PenColor option\n    }\n\n/// A union of all possible events\ntype TurtleEvent = \n    | StateChangedEvent of StateChangedEvent\n    | MovedEvent of MovedEvent \n```", "```\n/// Apply an event to the current state and return the new state of the turtle\nlet applyEvent log oldState event =\n    match event with\n    | Moved distance ->\n        Turtle.move log distance oldState \n    | Turned angle ->\n        Turtle.turn log angle oldState \n    | PenWentUp ->\n        Turtle.penUp log oldState \n    | PenWentDown ->\n        Turtle.penDown log oldState \n    | ColorChanged color ->\n        Turtle.setColor log color oldState \n```", "```\n// Determine what events to generate, based on the command and the state.\nlet eventsFromCommand log command stateBeforeCommand =\n\n    // --------------------------\n    // create the StateChangedEvent from the TurtleCommand\n    let stateChangedEvent = \n        match command.action with\n        | Move dist -> Moved dist\n        | Turn angle -> Turned angle\n        | PenUp -> PenWentUp \n        | PenDown -> PenWentDown \n        | SetColor color -> ColorChanged color\n\n    // --------------------------\n    // calculate the current state from the new event\n    let stateAfterCommand = \n        applyEvent log stateBeforeCommand stateChangedEvent\n\n    // --------------------------\n    // create the MovedEvent \n    let startPos = stateBeforeCommand.position \n    let endPos = stateAfterCommand.position \n    let penColor = \n        if stateBeforeCommand.penState=Down then\n            Some stateBeforeCommand.color\n        else\n            None                        \n\n    let movedEvent = {\n        startPos = startPos \n        endPos = endPos \n        penColor = penColor\n        }\n\n    // --------------------------\n    // return the list of events\n    if startPos <> endPos then\n        // if the turtle has moved, return both the stateChangedEvent and the movedEvent \n        // lifted into the common TurtleEvent type\n        [ StateChangedEvent stateChangedEvent; MovedEvent movedEvent]                \n    else\n        // if the turtle has not moved, return just the stateChangedEvent \n        [ StateChangedEvent stateChangedEvent] \n```", "```\n/// The type representing a function that gets the StateChangedEvents for a turtle id\n/// The oldest events are first\ntype GetStateChangedEventsForId =\n     TurtleId -> StateChangedEvent list\n\n/// The type representing a function that saves a TurtleEvent \ntype SaveTurtleEvent = \n    TurtleId -> TurtleEvent -> unit\n\n/// main function : process a command\nlet commandHandler \n    (log:string -> unit) \n    (getEvents:GetStateChangedEventsForId) \n    (saveEvent:SaveTurtleEvent) \n    (command:TurtleCommand) =\n\n    /// First load all the events from the event store\n    let eventHistory = \n        getEvents command.turtleId\n\n    /// Then, recreate the state before the command\n    let stateBeforeCommand = \n        let nolog = ignore // no logging when recreating state\n        eventHistory \n        |> List.fold (applyEvent nolog) Turtle.initialTurtleState\n\n    /// Construct the events from the command and the stateBeforeCommand\n    /// Do use the supplied logger for this bit\n    let events = eventsFromCommand log command stateBeforeCommand \n\n    // store the events in the event store\n    events |> List.iter (saveEvent command.turtleId) \n```", "```\n// Command versions of standard actions \nlet turtleId = System.Guid.NewGuid()\nlet move dist = {turtleId=turtleId; action=Move dist} \nlet turn angle = {turtleId=turtleId; action=Turn angle} \nlet penDown = {turtleId=turtleId; action=PenDown} \nlet penUp = {turtleId=turtleId; action=PenUp} \nlet setColor color = {turtleId=turtleId; action=SetColor color} \n```", "```\nlet drawTriangle() = \n    let handler = makeCommandHandler()\n    handler (move 100.0)\n    handler (turn 120.0<Degrees>)\n    handler (move 100.0)\n    handler (turn 120.0<Degrees>)\n    handler (move 100.0)\n    handler (turn 120.0<Degrees>) \n```", "```\n// filter to choose only TurtleEvents\nlet turtleFilter ev = \n    match box ev with\n    | :? TurtleEvent as tev -> Some tev\n    | _ -> None\n\n// filter to choose only MovedEvents from TurtleEvents\nlet moveFilter = function \n    | MovedEvent ev -> Some ev\n    | _ -> None\n\n// filter to choose only StateChangedEvent from TurtleEvents\nlet stateChangedEventFilter = function \n    | StateChangedEvent ev -> Some ev\n    | _ -> None \n```", "```\n/// Physically move the turtle\nlet physicalTurtleProcessor (eventStream:IObservable<Guid*obj>) =\n\n    // the function that handles the input from the observable\n    let subscriberFn (ev:MovedEvent) =\n        let colorText = \n            match ev.penColor with\n            | Some color -> sprintf \"line of color %A\" color\n            | None -> \"no line\"\n        printfn \"[turtle  ]: Moved from (%0.2f,%0.2f) to (%0.2f,%0.2f) with %s\" \n            ev.startPos.x ev.startPos.y ev.endPos.x ev.endPos.y colorText \n\n    // start with all events\n    eventStream\n    // filter the stream on just TurtleEvents\n    |> Observable.choose (function (id,ev) -> turtleFilter ev)\n    // filter on just MovedEvents\n    |> Observable.choose moveFilter\n    // handle these\n    |> Observable.subscribe subscriberFn \n```", "```\n/// Draw lines on a graphics device\nlet graphicsProcessor (eventStream:IObservable<Guid*obj>) =\n\n    // the function that handles the input from the observable\n    let subscriberFn (ev:MovedEvent) =\n        match ev.penColor with\n        | Some color -> \n            printfn \"[graphics]: Draw line from (%0.2f,%0.2f) to (%0.2f,%0.2f) with color %A\" \n                ev.startPos.x ev.startPos.y ev.endPos.x ev.endPos.y color\n        | None -> \n            ()  // do nothing\n\n    // start with all events\n    eventStream\n    // filter the stream on just TurtleEvents\n    |> Observable.choose (function (id,ev) -> turtleFilter ev)\n    // filter on just MovedEvents\n    |> Observable.choose moveFilter\n    // handle these\n    |> Observable.subscribe subscriberFn \n```", "```\n/// Listen for \"moved\" events and aggregate them to keep\n/// track of the total ink used\nlet inkUsedProcessor (eventStream:IObservable<Guid*obj>) =\n\n    // Accumulate the total distance moved so far when a new event happens\n    let accumulate distanceSoFar (ev:StateChangedEvent) =\n        match ev with\n        | Moved dist -> \n            distanceSoFar + dist \n        | _ -> \n            distanceSoFar \n\n    // the function that handles the input from the observable\n    let subscriberFn distanceSoFar  =\n        printfn \"[ink used]: %0.2f\" distanceSoFar  \n\n    // start with all events\n    eventStream\n    // filter the stream on just TurtleEvents\n    |> Observable.choose (function (id,ev) -> turtleFilter ev)\n    // filter on just StateChangedEvent\n    |> Observable.choose stateChangedEventFilter\n    // accumulate total distance\n    |> Observable.scan accumulate 0.0\n    // handle these\n    |> Observable.subscribe subscriberFn \n```", "```\nlet drawTriangle() = \n    // clear older events\n    eventStore.Clear turtleId   \n\n    // create an event stream from an IEvent\n    let eventStream = eventStore.SaveEvent :> IObservable<Guid*obj>\n\n    // register the processors\n    use physicalTurtleProcessor = EventProcessors.physicalTurtleProcessor eventStream \n    use graphicsProcessor = EventProcessors.graphicsProcessor eventStream \n    use inkUsedProcessor = EventProcessors.inkUsedProcessor eventStream \n\n    let handler = makeCommandHandler\n    handler (move 100.0)\n    handler (turn 120.0<Degrees>)\n    handler (move 100.0)\n    handler (turn 120.0<Degrees>)\n    handler (move 100.0)\n    handler (turn 120.0<Degrees>) \n```", "```\n[ink used]: 100.00\n[turtle  ]: Moved from (0.00,0.00) to (100.00,0.00) with line of color Black\n[graphics]: Draw line from (0.00,0.00) to (100.00,0.00) with color Black\n[ink used]: 100.00\n[ink used]: 200.00\n[turtle  ]: Moved from (100.00,0.00) to (50.00,86.60) with line of color Black\n[graphics]: Draw line from (100.00,0.00) to (50.00,86.60) with color Black\n[ink used]: 200.00\n[ink used]: 300.00\n[turtle  ]: Moved from (50.00,86.60) to (0.00,0.00) with line of color Black\n[graphics]: Draw line from (50.00,86.60) to (0.00,0.00) with color Black\n[ink used]: 300.00 \n```", "```\n/// Listen for \"moved\" events and aggregate them to keep\n/// track of the total distance moved\n/// NEW! No duplicate events! \nlet inkUsedProcessor (eventStream:IObservable<Guid*obj>) =\n\n    // Accumulate the total distance moved so far when a new event happens\n    let accumulate (prevDist,currDist) (ev:StateChangedEvent) =\n        let newDist =\n            match ev with\n            | Moved dist -> \n                currDist + dist\n            | _ -> \n                currDist\n        (currDist, newDist)\n\n    // convert unchanged events to None so they can be filtered out with \"choose\"\n    let changedDistanceOnly (currDist, newDist) =\n        if currDist <> newDist then \n            Some newDist \n        else \n            None\n\n    // the function that handles the input from the observable\n    let subscriberFn distanceSoFar  =\n        printfn \"[ink used]: %0.2f\" distanceSoFar  \n\n    // start with all events\n    eventStream\n    // filter the stream on just TurtleEvents\n    |> Observable.choose (function (id,ev) -> turtleFilter ev)\n    // filter on just StateChangedEvent\n    |> Observable.choose stateChangedEventFilter\n    // NEW! accumulate total distance as pairs\n    |> Observable.scan accumulate (0.0,0.0)   \n    // NEW! filter out when distance has not changed\n    |> Observable.choose changedDistanceOnly\n    // handle these\n    |> Observable.subscribe subscriberFn \n```", "```\n[ink used]: 100.00\n[turtle  ]: Moved from (0.00,0.00) to (100.00,0.00) with line of color Black\n[graphics]: Draw line from (0.00,0.00) to (100.00,0.00) with color Black\n[ink used]: 200.00\n[turtle  ]: Moved from (100.00,0.00) to (50.00,86.60) with line of color Black\n[graphics]: Draw line from (100.00,0.00) to (50.00,86.60) with color Black\n[ink used]: 300.00\n[turtle  ]: Moved from (50.00,86.60) to (0.00,0.00) with line of color Black\n[graphics]: Draw line from (50.00,86.60) to (0.00,0.00) with color Black \n```", "```\ntype MoveResponse = \n    | MoveOk \n    | HitABarrier\n\ntype SetColorResponse = \n    | ColorOk\n    | OutOfInk \n```", "```\n// if the position is outside the square (0,0,100,100) \n// then constrain the position and return HitABarrier\nlet checkPosition position =\n    let isOutOfBounds p = \n        p > 100.0 || p < 0.0\n    let bringInsideBounds p = \n        max (min p 100.0) 0.0\n\n    if isOutOfBounds position.x || isOutOfBounds position.y then\n        let newPos = {\n            x = bringInsideBounds position.x \n            y = bringInsideBounds position.y }\n        HitABarrier,newPos\n    else\n        MoveOk,position \n```", "```\nlet move log distance state =\n    let newPosition = ...\n\n    // adjust the new position if out of bounds\n    let moveResult, newPosition = checkPosition newPosition \n\n    ... \n```", "```\nlet move log distance state =\n    log (sprintf \"Move %0.1f\" distance)\n    // calculate new position \n    let newPosition = calcNewPosition distance state.angle state.position \n    // adjust the new position if out of bounds\n    let moveResult, newPosition = checkPosition newPosition \n    // draw line if needed\n    if state.penState = Down then\n        dummyDrawLine log state.position newPosition state.color\n    // return the new state and the Move result\n    let newState = {state with position = newPosition}\n    (moveResult,newState) \n```", "```\nlet setColor log color state =\n    let colorResult = \n        if color = Red then OutOfInk else ColorOk\n    log (sprintf \"SetColor %A\" color)\n    // return the new state and the SetColor result\n    let newState = {state with color = color}\n    (colorResult,newState) \n```", "```\nlet drawShape() = \n    // define a set of instructions \n    let t = turtle {\n        do! move 60.0   \n        // error FS0001: \n        // This expression was expected to have type\n        //    Turtle.MoveResponse \n        // but here has type\n        //     unit \n        do! move 60.0 \n        } \n    // etc \n```", "```\nlet drawShapeWithoutResponding() = \n    // define a set of instructions \n    let t = turtle {\n        let! response = move 60.0 \n        let! response = move 60.0 \n        let! response = move 60.0 \n        return ()\n        } \n\n    // finally, run the monad using the initial state\n    runT t initialTurtleState \n```", "```\nMove 60.0\n...Draw line from (0.0,0.0) to (60.0,0.0) using Black\nMove 60.0\n...Draw line from (60.0,0.0) to (100.0,0.0) using Black\nMove 60.0\n...Draw line from (100.0,0.0) to (100.0,0.0) using Black \n```", "```\nlet handleMoveResponse moveResponse = turtle {\n    match moveResponse with\n    | Turtle.MoveOk -> \n        () // do nothing\n    | Turtle.HitABarrier ->\n        // turn 90 before trying again\n        printfn \"Oops -- hit a barrier -- turning\"\n        do! turn 90.0<Degrees>\n    } \n```", "```\nval handleMoveResponse : MoveResponse -> TurtleStateComputation<unit> \n```", "```\nlet drawShape() = \n    // define a set of instructions \n    let t = turtle {\n        let! response = move 60.0 \n        do! handleMoveResponse response \n\n        let! response = move 60.0 \n        do! handleMoveResponse response \n\n        let! response = move 60.0 \n        do! handleMoveResponse response \n        } \n\n    // finally, run the monad using the initial state\n    runT t initialTurtleState \n```", "```\nMove 60.0\n...Draw line from (0.0,0.0) to (60.0,0.0) using Black\nMove 60.0\n...Draw line from (60.0,0.0) to (100.0,0.0) using Black\nOops -- hit a barrier -- turning\nTurn 90.0\nMove 60.0\n...Draw line from (100.0,0.0) to (100.0,60.0) using Black \n```", "```\n// we send this to the turtle...\ntype TurtleCommand = \n    | Move of Distance \n    | Turn of Angle\n    | PenUp\n    | PenDown\n    | SetColor of PenColor\n\n// ... and the turtle replies with one of these\ntype TurtleResponse = \n    | Moved of MoveResponse\n    | Turned \n    | PenWentUp\n    | PenWentDown\n    | ColorSet of SetColorResponse \n```", "```\nMove command => pair of (Move command parameters), (function MoveResponse -> something)\nTurn command => pair of (Turn command parameters), (function unit -> something)\netc \n```", "```\ntype TurtleProgram = \n    //         (input params)  (response)\n    | Move     of Distance   * (MoveResponse -> TurtleProgram)\n    | Turn     of Angle      * (unit -> TurtleProgram)\n    | PenUp    of (* none *)   (unit -> TurtleProgram)\n    | PenDown  of (* none *)   (unit -> TurtleProgram)\n    | SetColor of PenColor   * (SetColorResponse -> TurtleProgram) \n```", "```\ntype TurtleProgram = \n    //         (input params)  (response)\n    | Stop\n    | Move     of Distance   * (MoveResponse -> TurtleProgram)\n    | Turn     of Angle      * (unit -> TurtleProgram)\n    | PenUp    of (* none *)   (unit -> TurtleProgram)\n    | PenDown  of (* none *)   (unit -> TurtleProgram)\n    | SetColor of PenColor   * (SetColorResponse -> TurtleProgram) \n```", "```\nlet drawTriangle = \n    Move (100.0, fun response -> \n    Turn (120.0<Degrees>, fun () -> \n    Move (100.0, fun response -> \n    Turn (120.0<Degrees>, fun () -> \n    Move (100.0, fun response -> \n    Turn (120.0<Degrees>, fun () -> \n    Stop)))))) \n```", "```\nlet rec interpretAsTurtle state program =\n    ...\n    match program  with\n    | Move (dist,next) ->\n        let result,newState = Turtle.move log dist state \n        let nextProgram = next result  // compute the next step\n        interpretAsTurtle newState nextProgram \n    ... \n```", "```\nlet rec interpretAsTurtle state program =\n    let log = printfn \"%s\"\n\n    match program  with\n    | Stop -> \n        state\n    | Move (dist,next) ->\n        let result,newState = Turtle.move log dist state \n        let nextProgram = next result  // compute the next step \n        interpretAsTurtle newState nextProgram \n    | Turn (angle,next) ->\n        let newState = Turtle.turn log angle state \n        let nextProgram = next()       // compute the next step\n        interpretAsTurtle newState nextProgram \n    | PenUp next ->\n        let newState = Turtle.penUp log state \n        let nextProgram = next()\n        interpretAsTurtle newState nextProgram \n    | PenDown next -> \n        let newState = Turtle.penDown log state \n        let nextProgram = next()\n        interpretAsTurtle newState nextProgram \n    | SetColor (color,next) ->\n        let result,newState = Turtle.setColor log color state \n        let nextProgram = next result\n        interpretAsTurtle newState nextProgram \n```", "```\nlet program = drawTriangle\nlet interpret = interpretAsTurtle   // choose an interpreter \nlet initialState = Turtle.initialTurtleState\ninterpret initialState program |> ignore \n```", "```\nMove 100.0\n...Draw line from (0.0,0.0) to (100.0,0.0) using Black\nTurn 120.0\nMove 100.0\n...Draw line from (100.0,0.0) to (50.0,86.6) using Black\nTurn 120.0\nMove 100.0\n...Draw line from (50.0,86.6) to (0.0,0.0) using Black\nTurn 120.0 \n```", "```\nlet rec interpretAsDistance distanceSoFar program =\n    let recurse = interpretAsDistance \n    let log = printfn \"%s\"\n\n    match program with\n    | Stop -> \n        distanceSoFar\n    | Move (dist,next) ->\n        let newDistanceSoFar = distanceSoFar + dist\n        let result = Turtle.MoveOk   // hard-code result\n        let nextProgram = next result \n        recurse newDistanceSoFar nextProgram \n    | Turn (angle,next) ->\n        // no change in distanceSoFar\n        let nextProgram = next()\n        recurse distanceSoFar nextProgram \n    | PenUp next ->\n        // no change in distanceSoFar\n        let nextProgram = next()\n        recurse distanceSoFar nextProgram \n    | PenDown next -> \n        // no change in distanceSoFar\n        let nextProgram = next()\n        recurse distanceSoFar nextProgram \n    | SetColor (color,next) ->\n        // no change in distanceSoFar\n        let result = Turtle.ColorOk   // hard-code result\n        let nextProgram = next result\n        recurse distanceSoFar nextProgram \n```", "```\nlet program = drawTriangle           // same program \nlet interpret = interpretAsDistance  // choose an interpreter \nlet initialState = 0.0\ninterpret initialState program |> printfn \"Total distance moved is %0.1f\" \n```", "```\nTotal distance moved is 300.0 \n```", "```\ntype TurtleProgram<'a> = \n    | Stop     of 'a\n    | Move     of Distance * (MoveResponse -> TurtleProgram<'a>)\n    | Turn     of Angle    * (unit -> TurtleProgram<'a>)\n    | PenUp    of            (unit -> TurtleProgram<'a>)\n    | PenDown  of            (unit -> TurtleProgram<'a>)\n    | SetColor of PenColor * (SetColorResponse -> TurtleProgram<'a>) \n```", "```\nlet returnT x = \n    Stop x \n```", "```\nlet rec bindT f inst  = \n    match inst with\n    | Stop x -> \n        f x\n    | Move(dist,next) -> \n        (*\n        Move(dist,fun moveResponse -> (bindT f)(next moveResponse)) \n        *)\n        // \"next >> bindT f\" is a shorter version of function response\n        Move(dist,next >> bindT f) \n    | Turn(angle,next) -> \n        Turn(angle,next >> bindT f)  \n    | PenUp(next) -> \n        PenUp(next >> bindT f)\n    | PenDown(next) -> \n        PenDown(next >> bindT f)\n    | SetColor(color,next) -> \n        SetColor(color,next >> bindT f) \n```", "```\n// define a computation expression builder\ntype TurtleProgramBuilder() =\n    member this.Return(x) = returnT x\n    member this.Bind(x,f) = bindT f x\n    member this.Zero(x) = returnT ()\n\n// create an instance of the computation expression builder\nlet turtleProgram = TurtleProgramBuilder() \n```", "```\n// helper functions\nlet stop = fun x -> Stop x\nlet move dist  = Move (dist, stop)\nlet turn angle  = Turn (angle, stop)\nlet penUp  = PenUp stop \nlet penDown  = PenDown stop \nlet setColor color = SetColor (color,stop)\n\nlet handleMoveResponse log moveResponse = turtleProgram {\n    match moveResponse with\n    | Turtle.MoveOk -> \n        ()\n    | Turtle.HitABarrier ->\n        // turn 90 before trying again\n        log \"Oops -- hit a barrier -- turning\"\n        let! x = turn 90.0<Degrees>\n        ()\n    }\n\n// example\nlet drawTwoLines log = turtleProgram {\n    let! response = move 60.0\n    do! handleMoveResponse log response \n    let! response = move 60.0\n    do! handleMoveResponse log response \n    } \n```", "```\nlet log = printfn \"%s\"\nlet program = drawTwoLines log \nlet interpret = interpretAsTurtle \nlet initialState = Turtle.initialTurtleState\ninterpret initialState program |> ignore \n```", "```\nMove 60.0\n...Draw line from (0.0,0.0) to (60.0,0.0) using Black\nMove 60.0\n...Draw line from (60.0,0.0) to (100.0,0.0) using Black\nOops -- hit a barrier -- turning\nTurn 90.0 \n```", "```\n/// Create a type to represent each instruction\ntype TurtleInstruction<'next> = \n    | Move     of Distance * (MoveResponse -> 'next)\n    | Turn     of Angle    * 'next\n    | PenUp    of            'next\n    | PenDown  of            'next\n    | SetColor of PenColor * (SetColorResponse -> 'next)\n\n/// Create a type to represent the Turtle Program\ntype TurtleProgram<'a> = \n    | Stop of 'a\n    | KeepGoing of TurtleInstruction<TurtleProgram<'a>> \n```", "```\nlet mapInstr f inst  = \n    match inst with\n    | Move(dist,next) ->      Move(dist,next >> f) \n    | Turn(angle,next) ->     Turn(angle,f next)  \n    | PenUp(next) ->          PenUp(f next)\n    | PenDown(next) ->        PenDown(f next)\n    | SetColor(color,next) -> SetColor(color,next >> f) \n```", "```\nlet rec interpretAsTurtle log state program =\n    let recurse = interpretAsTurtle log \n\n    match program with\n    | Stop a -> \n        state\n    | KeepGoing (Move (dist,next)) ->\n        let result,newState = Turtle.move log dist state \n        let nextProgram = next result // compute next program\n        recurse newState nextProgram \n    | KeepGoing (Turn (angle,next)) ->\n        let newState = Turtle.turn log angle state \n        let nextProgram = next        // use next program directly\n        recurse newState nextProgram \n```", "```\n// helper functions\nlet stop = Stop()\nlet move dist  = KeepGoing (Move (dist, Stop))    // \"Stop\" is a function\nlet turn angle  = KeepGoing (Turn (angle, stop))  // \"stop\" is a value\nlet penUp  = KeepGoing (PenUp stop)\nlet penDown  = KeepGoing (PenDown stop)\nlet setColor color = KeepGoing (SetColor (color,Stop))\n\nlet handleMoveResponse log moveResponse = turtleProgram {\n    ... // as before\n\n// example\nlet drawTwoLines log = turtleProgram {\n    let! response = move 60.0\n    do! handleMoveResponse log response \n    let! response = move 60.0\n    do! handleMoveResponse log response \n    } \n```", "```\nmodule AdtTurtle = \n\n    /// A private structure representing the turtle \n    type Turtle = private {\n        position : Position\n        angle : float<Degrees>\n        color : PenColor\n        penState : PenState\n    }\n\n    /// Functions for manipulating a turtle\n    /// \"RequireQualifiedAccess\" means the module name *must* \n    ///    be used (just like List module)\n    /// \"ModuleSuffix\" is needed so the that module can \n    ///    have the same name as the state type \n    [<RequireQualifiedAccess>]\n    [<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\n    module Turtle = \n```", "```\ntype TurtleState = { ... }\ntype turtle = TurtleState \n\nmodule Turtle =\n    let something (t:turtle) = t \n```", "```\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Turtle =\n\n    /// return a new turtle with the specified color\n    let make(initialColor) = {\n        position = initialPosition\n        angle = 0.0<Degrees>\n        color = initialColor\n        penState = initialPenState\n    } \n```", "```\nlet initialTurtle = {\n    position = initialPosition\n    angle = 0.0<Degrees>\n    color = initialColor\n    penState = initialPenState\n}\n// Compiler error FS1093: \n//    The union cases or fields of the type 'Turtle'\n//    are not accessible from this code location \n```", "```\nlet turtle = Turtle.make(Red)\nprintfn \"%A\" turtle.position\n// Compiler error FS1093: \n//    The union cases or fields of the type 'Turtle'\n//    are not accessible from this code location \n```", "```\n// versions with log baked in (via partial application)\nlet move = Turtle.move log\nlet turn = Turtle.turn log\n// etc\n\nlet drawTriangle() =\n    Turtle.make(Red)\n    |> move 100.0 \n    |> turn 120.0<Degrees>\n    |> move 100.0 \n    |> turn 120.0<Degrees>\n    |> move 100.0 \n    |> turn 120.0<Degrees> \n```", "```\ntype MoveResponse = \n    | MoveOk \n    | HitABarrier\n\ntype SetColorResponse = \n    | ColorOk\n    | OutOfInk\n\ntype TurtleFunctions = {\n    move     : MoveFn option\n    turn     : TurnFn\n    penUp    : PenUpDownFn \n    penDown  : PenUpDownFn \n    setBlack : SetColorFn  option\n    setBlue  : SetColorFn  option\n    setRed   : SetColorFn  option\n    }\nand MoveFn =      Distance -> (MoveResponse * TurtleFunctions)\nand TurnFn =      Angle    -> TurtleFunctions\nand PenUpDownFn = unit     -> TurtleFunctions\nand SetColorFn =  unit     -> (SetColorResponse * TurtleFunctions) \n```", "```\nval move : \n    Log -> Distance -> TurtleState -> (MoveResponse * TurtleState) \n```", "```\nval move : \n    Distance -> (MoveResponse * TurtleFunctions) \n```", "```\ntype Log = string -> unit\n\ntype private TurtleState = {\n    position : Position\n    angle : float<Degrees>\n    color : PenColor\n    penState : PenState\n\n    canMove : bool                // new!\n    availableInk: Set<PenColor>   // new!\n    logger : Log                  // new!\n} \n```", "```\n/// Function is private! Only accessible to the client via the TurtleFunctions record\nlet private move log distance state =\n\n    log (sprintf \"Move %0.1f\" distance)\n    // calculate new position \n    let newPosition = calcNewPosition distance state.angle state.position \n    // adjust the new position if out of bounds\n    let moveResult, newPosition = checkPosition newPosition \n    // draw line if needed\n    if state.penState = Down then\n        dummyDrawLine log state.position newPosition state.color\n\n    // return the new state and the Move result\n    let newState = {\n        state with \n         position = newPosition\n         canMove = (moveResult <> HitABarrier)   // NEW! \n        }\n    (moveResult,newState) \n```", "```\nlet private turn log angle state =\n    log (sprintf \"Turn %0.1f\" angle)\n    // calculate new angle\n    let newAngle = (state.angle + angle) % 360.0<Degrees>\n    // NEW!! assume you can always move after turning\n    let canMove = true\n    // update the state\n    {state with angle = newAngle; canMove = canMove} \n```", "```\nlet private setColor log color state =\n    let colorResult = \n        if color = Red then OutOfInk else ColorOk\n    log (sprintf \"SetColor %A\" color)\n\n    // NEW! remove color ink from available inks\n    let newAvailableInk = state.availableInk |> Set.remove color\n\n    // return the new state and the SetColor result\n    let newState = {state with color = color; availableInk = newAvailableInk}\n    (colorResult,newState) \n```", "```\n/// Create the TurtleFunctions structure associated with a TurtleState\nlet rec private createTurtleFunctions state =\n    let ctf = createTurtleFunctions  // alias\n\n    // create the move function,\n    // if the turtle can't move, return None\n    let move = \n        // the inner function\n        let f dist = \n            let resp, newState = move state.logger dist state\n            (resp, ctf newState)\n\n        // return Some of the inner function\n        // if the turtle can move, or None\n        if state.canMove then\n            Some f\n        else\n            None\n\n    // create the turn function\n    let turn angle = \n        let newState = turn state.logger angle state\n        ctf newState\n\n    // create the pen state functions\n    let penDown() = \n        let newState = penDown state.logger state\n        ctf newState\n\n    let penUp() = \n        let newState = penUp state.logger state\n        ctf newState\n\n    // create the set color functions\n    let setColor color = \n        // the inner function\n        let f() = \n            let resp, newState = setColor state.logger color state\n            (resp, ctf newState)\n\n        // return Some of the inner function \n        // if that color is available, or None\n        if state.availableInk |> Set.contains color then\n            Some f\n        else\n            None\n\n    let setBlack = setColor Black\n    let setBlue = setColor Blue\n    let setRed = setColor Red\n\n    // return the structure\n    {\n    move     = move\n    turn     = turn\n    penUp    = penUp \n    penDown  = penDown \n    setBlack = setBlack\n    setBlue  = setBlue  \n    setRed   = setRed   \n    } \n```", "```\nlet turn angle = \n    let newState = turn state.logger angle state\n    ctf newState \n```", "```\n// create the move function,\n// if the turtle can't move, return None\nlet move = \n    // the inner function\n    let f dist = \n        let resp, newState = move state.logger dist state\n        (resp, ctf newState)\n\n    // return Some of the inner function\n    // if the turtle can move, or None\n    if state.canMove then\n        Some f\n    else\n        None \n```", "```\nlet setColor color = \n    // the inner function\n    let f() = \n        let resp, newState = setColor state.logger color state\n        (resp, ctf newState)\n\n    // return Some of the inner function \n    // if that color is available, or None\n    if state.availableInk |> Set.contains color then\n        Some f\n    else\n        None \n```", "```\n// return the structure\n{\nmove     = move\nturn     = turn\npenUp    = penUp \npenDown  = penDown \nsetBlack = setBlack\nsetBlue  = setBlue  \nsetRed   = setRed   \n} \n```", "```\n/// Return the initial turtle.\n/// This is the ONLY public function!\nlet make(initialColor, log) = \n    let state = {\n        position = initialPosition\n        angle = 0.0<Degrees>\n        color = initialColor\n        penState = initialPenState\n        canMove = true\n        availableInk = [Black; Blue; Red] |> Set.ofList\n        logger = log\n    }                \n    createTurtleFunctions state \n```", "```\nlet testBoundary() =\n    let turtleFns = Turtle.make(Red,log)\n    match turtleFns.move with\n    | None -> \n        log \"Error: Can't do move 1\"\n    | Some moveFn -> \n        ... \n```", "```\nlet testBoundary() =\n    let turtleFns = Turtle.make(Red,log)\n    match turtleFns.move with\n    | None -> \n        log \"Error: Can't do move 1\"\n    | Some moveFn -> \n        let (moveResp,turtleFns) = moveFn 60.0 \n        match turtleFns.move with\n        | None -> \n            log \"Error: Can't do move 2\"\n        | Some moveFn -> \n            ... \n```", "```\nlet testBoundary() =\n    let turtleFns = Turtle.make(Red,log)\n    match turtleFns.move with\n    | None -> \n        log \"Error: Can't do move 1\"\n    | Some moveFn -> \n        let (moveResp,turtleFns) = moveFn 60.0 \n        match turtleFns.move with\n        | None -> \n            log \"Error: Can't do move 2\"\n        | Some moveFn -> \n            let (moveResp,turtleFns) = moveFn 60.0 \n            match turtleFns.move with\n            | None -> \n                log \"Error: Can't do move 3\"\n            | Some moveFn -> \n                log \"Success\" \n```", "```\nMove 60.0\n...Draw line from (0.0,0.0) to (60.0,0.0) using Red\nMove 60.0\n...Draw line from (60.0,0.0) to (100.0,0.0) using Red\nError: Can't do move 3 \n```", "```\ntype MaybeBuilder() =         \n    member this.Return(x) = Some x\n    member this.Bind(x,f) = Option.bind f x\n    member this.Zero() = Some()\nlet maybe = MaybeBuilder() \n```", "```\n/// A function that logs and returns Some(),\n/// for use in the \"maybe\" workflow\nlet logO message =\n    printfn \"%s\" message\n    Some () \n```", "```\nlet testInk() =\n    maybe {\n    // create a turtle\n    let turtleFns = Turtle.make(Black,log)\n\n    // attempt to get the \"setRed\" function\n    let! setRedFn = turtleFns.setRed \n\n    // if so, use it\n    let (resp,turtleFns) = setRedFn() \n\n    // attempt to get the \"move\" function\n    let! moveFn = turtleFns.move \n\n    // if so, move a distance of 60 with the red ink\n    let (resp,turtleFns) = moveFn 60.0 \n\n    // check if the \"setRed\" function is still available\n    do! match turtleFns.setRed with\n        | None -> \n            logO \"Error: Can no longer use Red ink\"\n        | Some _ -> \n            logO \"Success: Can still use Red ink\"\n\n    // check if the \"setBlue\" function is still available\n    do! match turtleFns.setBlue with\n        | None -> \n            logO \"Error: Can no longer use Blue ink\"\n        | Some _ -> \n            logO \"Success: Can still use Blue ink\"\n\n    } |> ignore \n```", "```\nSetColor Red\nMove 60.0\n...Draw line from (0.0,0.0) to (60.0,0.0) using Red\nError: Can no longer use Red ink\nSuccess: Can still use Blue ink \n```"]