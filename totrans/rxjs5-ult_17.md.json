["```\nRx.Observable.combineLatest([ source_1, ...  source_n]) \n```", "```\nlet source1 = Rx.Observable.interval(100)\n.map( val => \"source1 \" + val ).take(5);\n\nlet source2 = Rx.Observable.interval(50)\n.map( val => \"source2 \" + val ).take(2);\n\nlet stream$ = Rx.Observable.combineLatest(\n    source1,\n    source2\n);\n\nstream$.subscribe(data => console.log(data));\n\n// emits source1: 0, source2 : 0 |  source1 : 0, source2 : 1 | source1 : 1, source2 : 1, etc \n```", "```\nRx.Observable([ source_1,... sournce_n ]) \n```", "```\nlet source1 = Rx.Observable.interval(100)\n.map( val => \"source1 \" + val ).take(5);\n\nlet source2 = Rx.Observable.interval(50)\n.map( val => \"source2 \" + val ).take(2);\n\nlet stream$ = Rx.Observable.concat(\n    source1, \n    source2\n);\n\nstream$.subscribe( data => console.log('Concat ' + data));\n\n// source1 : 0, source1 : 1, source1 : 2, source1 : 3, source1 : 4\n// source2 : 0, source2 : 1 \n```", "```\nlet merged$ = Rx.Observable.merge(\n    Rx.Observable.of(1).delay(500),\n    Rx.Observable.of(3,2,5)\n)\n\nlet observer = {\n    next : data => console.log(data)\n}\n\nmerged$.subscribe(observer); \n```", "```\nlet stream$ = Rx.Observable.zip(\n    Promise.resolve(1),\n    Rx.Observable.of(2,3,4),\n    Rx.Observable.of(7)\n);\n\nstream$.subscribe(observer); \n```", "```\nlet stream$ = Rx.Observable.zip(\n    Rx.Observable.of(1,5),\n    Rx.Observable.of(2,3,4),\n    Rx.Observable.of(7,9)\n);\n\nstream$.subscribe(observer); \n```"]