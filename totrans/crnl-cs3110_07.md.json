["```\n# type answer = Yes | No | Maybe;;\n*type answer = Yes | No | Maybe*\n# let x : answer = Yes;;\n*val x : answer = Yes*\n\n```", "```\ntype eitherPoint = TwoD of float * float\n                 | ThreeD of float * float * float\n\n```", "```\nlet lastTwoComponents (p : eitherPoint) : float * float =\n    match p with\n      TwoD (x, y) -> (x, y)\n    | ThreeD (x, y, z) -> (y, z)\n\n```", "```\ntype intlist = Nil | Cons of (int * intlist)\n\n```", "```\nlet list1 = Nil                     (* the empty list: [] *)\nlet list2 = Cons (1, Nil)           (* the list containing just 1: [1] *)\nlet list3 = Cons (2, Cons (1, Nil)) (* the list [2; 1] *)\nlet list4 = Cons (2, list2)         (* also the list [2; 1] *)\n(* the list [1; 2; 3; 4; 5] *)\nlet list5 = Cons (1, Cons (2, Cons (3, Cons (4, Cons (5, Nil)))))\n(* the list [6; 7; 8; 9; 10] *)\nlet list6 = Cons (6, Cons (7, Cons (8, Cons (9, Cons (10, Nil)))))\n\n```", "```\n(* An intlist is either Nil or Cons of an int and a (shorter) intlist *)\ntype intlist = Nil | Cons of int * intlist\n\n(* Returns the length of lst *)\nlet rec length (lst : intlist) : int =\n  match lst with\n  | Nil -> 0\n  | Cons (h, t) -> length t + 1\n\n(* is the list empty? *)\nlet is_empty (lst : intlist) : bool =\n  match lst with\n  | Nil -> true\n  | Cons _ -> false\n\n(* Notice that the match expressions for lists all have the same\n * form -- a case for the empty list (Nil) and a case for a Cons.\n * Also notice that for most functions, the Cons case involves a\n * recursive function call. *)\n\n(* Return the sum of the elements in the list *)\nlet rec sum (lst : intlist) : int =\n  match lst with\n  | Nil -> 0\n  | Cons (i, t) -> i + sum t\n\n(* Create a string representation of a list *)\nlet rec to_string (lst : intlist) : string =\n  match lst with\n  | Nil -> \"\"\n  | Cons (i, Nil) -> string_of_int i\n  | Cons (i, Cons (j, t)) ->\n      string_of_int i ^ \",\" ^ to_string (Cons (j, t))\n\n(* Return the head (first element) of the list *)\nlet head (lst : intlist) : int =\n  match lst with\n  | Nil -> failwith \"empty list\"\n  | Cons (i, t) -> i\n\n(* Return the tail (rest of the list after the head) *)\nlet tail (lst : intlist) : intlist =\n  match lst with\n  | Nil -> failwith \"empty list\"\n  | Cons (i, t) -> t\n\n(* Return the last element of the list (if any) *)\nlet rec last (lst : intlist) : int =\n  match lst with\n  | Nil -> failwith \"empty list\"\n  | Cons (i, Nil) -> i\n  | Cons (i, t) -> last t\n\n(* Return the nth element of the list (starting from 0) *)\nlet rec nth (lst : intlist) (n : int) : int =\n  match lst with\n  | Nil -> failwith \"index out of bounds\"\n  | Cons (i, t) ->\n      if n = 0 then i\n      else nth t (n - 1)\n\n(* Append two lists:  append [1; 2; 3] [4; 5; 6] = [1; 2; 3; 4; 5; 6] *)\nlet rec append (l1 : intlist) (l2 : intlist) : intlist =\n  match l1 with\n  | Nil -> l2\n  | Cons (i, t) -> Cons (i, append t l2)\n\n(* Reverse a list:  reverse [1; 2; 3] = [3; 2; 1].\n * First reverse the tail of the list \n * (e.g., compute reverse [2; 3] = [3; 2]), then\n * append the singleton list [1] to the end to yield [3; 2; 1].\n * This is not the most efficient method. *)\nlet rec reverse (lst : intlist) : intlist =\n  match lst with\n  | Nil -> Nil\n  | Cons (h, t) -> append (reverse t) (Cons (h , Nil))\n\n(******************************\n * Examples\n ******************************)\n\n(* Here is a way to perform a function on each element\n * of a list.  We apply the function recursively.\n *)\n\nlet inc (x : int) : int = x + 1\nlet square (x : int) : int = x * x\n\n(* Given [i1; i2; ...; in], return [i1+1; i2+1; ...; in+n] *)\nlet rec addone_to_all (lst : intlist) : intlist = \n  match lst with\n  | Nil -> Nil\n  | Cons (h, t) -> Cons (inc h, addone_to_all t)\n\n(* Given [i1; i2; ...; in], return [i1*i1; i2*i2; ...; in*in] *)\nlet rec square_all (lst : intlist) : intlist = \n  match lst with\n  | Nil -> Nil\n  | Cons (h, t) -> Cons (square h, square_all t)\n\n(* Here is a more general method. *)\n\n(* Given a function f and [i1; ...; in], return [f i1; ...; f in].\n * Notice how we factored out the common parts of addone_to_all\n * and square_all. *)\nlet rec do_function_to_all (f : int -> int) (lst : intlist) : intlist =\n  match lst with\n  | Nil -> Nil\n  | Cons (h, t) -> Cons (f h, do_function_to_all f t)\n\nlet addone_to_all (lst : intlist) : intlist =\n  do_function_to_all inc lst\n\nlet square_all (lst : intlist) : intlist =\n  do_function_to_all square lst\n\n(* Even better: use anonymous functions. *)\n\nlet addone_to_all (lst : intlist) : intlist =\n  do_function_to_all (fun x -> x + 1) lst\n\nlet square_all (lst : intlist) : intlist =\n  do_function_to_all (fun x -> x * x) lst\n\n(* Equivalently, we can partially evaluate by applying \n * do_function_to_all just to the first argument. *)\n\nlet addone_to_all : intlist -> intlist =\n  do_function_to_all (fun x -> x + 1)\n\nlet square_all : intlist -> intlist =\n  do_function_to_all (fun x -> x * x)\n\n(* Say we want to compute the sum and product of integers\n * in a list. *)\n\n(* Explicit versions *)\nlet rec sum (lst : intlist) : int =\n  match lst with\n  | Nil -> 0\n  | Cons (i, t) -> i + sum t\n\nlet rec product (lst : intlist) : int =\n  match lst with\n  | Nil -> 1\n  | Cons (h, t) -> h * product t\n\n(* Better: use a general function collapse that takes an\n * operation and an identity element for that operation.\n *)\n\n(* Given f, b, and [i1; i2; ...; in], return f(i1, f(i2, ..., f (in, b))).\n * Again, we factored out the common parts of sum and product. *)\nlet rec collapse (f : int -> int -> int) (b : int) (lst : intlist) : int =\n  match lst with\n  | Nil -> b\n  | Cons (h, t) -> f h (collapse f b t)\n\n(* Now we can define sum and product in terms of collapse *)\nlet sum (lst : intlist) : int =\n  let add (i1 : int) (i2 : int) : int = i1 + i2 in\n  collapse add 0 lst\n\nlet product (lst : intlist) : int =\n  let mul (i1 : int) (i2 : int) : int = i1 * i2 in\n  collapse mul 1 lst\n\n(* Here, we use anonymous functions instead of defining add and mul.\n * After all, what's the point of giving those functions names if all\n * we're going to do is pass them to collapse? *)\nlet sum (lst : intlist) : int =\n  collapse (fun i1 i2 -> i1 + i2) 0 lst\n\nlet product (lst : intlist) : int =\n  collapse (fun i1 i2 -> i1 * i2) 1 lst\n\n(* Trees of integers *)\n\ntype inttree = Empty | Node of node\nand node = { value : int; left : inttree; right : inttree }\n\n(* Return true if the tree contains x. *)\nlet rec search (t : inttree) (x : int) : bool =\n  match t with\n  | Empty -> false\n  | Node {value=v; left=l; right=r} ->\n\tv = x || search l x || search r x\n\nlet tree1 =\n  Node {value=2; left=Node {value=1; left=Empty; right=Empty};\n                 right=Node {value=3; left=Empty; right=Empty}}\n\nlet z = search tree1 3\n\n```", "```\ntype inttree = Empty | Node of node\nand node = { value : int; left : inttree; right : inttree }\n\n```", "```\n  2\n / \\        Node {value=2; left=Node {value=1; left=Empty; right=Empty};\n1   3                      right=Node {value=3; left=Empty; right=Empty}}\n\n```", "```\n(* Return true if the tree contains x. *)\nlet rec search ((t: inttree), (x:int)): bool =\n  match t with\n      Empty -> false\n    | Node {value=v; left=l; right=r} ->\n\tv = x || search (l, x) || search (r, x)\n\n```", "```\ntype nat = Zero | Next of nat\n\n```", "```\nlet zero = Zero\nand one = Next Zero\nand two = Next (Next Zero)\nlet three = Next two\nlet four = Next three\n\n```", "```\nfour;;\n*- : nat = Next (Next (Next (Next Zero)))*\n\n```", "```\npublic interface nat { }\npublic class Zero implements nat {}\npublic class Next implements nat {\n  nat v;\n  Next(nat v) { v = this.v; }\n}\n\nnat zero = new Zero();\nnat one = new Next(new Zero());\nnat two = new Next(new Next(new Zero()));\nnat three = new Next(two);\nnat four = new Next(three);\n\n```", "```\nlet isZero (n : nat) : bool =\n  match n with\n    Zero -> true\n  | Next m -> false\n\n```", "```\nlet pred (n : nat) : nat =\n  match n with\n    Zero -> failwith \"Zero has no predecessor\"\n  | Next m -> m\n\n```", "```\nlet rec add (n1 : nat) (n2 : nat) : nat =\n  match n1 with\n    Zero -> n2\n  | Next m -> add m (Next n2)\n\n```", "```\nadd four four;;\n*- : nat = Next (Next (Next (Next (Next (Next (Next (Next Zero)))))))* \n```", "```\nlet rec toInt (n : nat) : int =\n  match n with\n    Zero -> 0\n  | Next n -> 1 + toInt n\n\n```", "```\nlet rec toNat (i : int) : nat =\n  if i < 0 then failwith \"toNat on negative number\"\n  else if i = 0 then Zero\n  else Next (toNat (i - 1))\n\n```", "```\nlet rec even (n : nat) : bool =\n  match n with\n    Zero -> true\n  | Next n -> odd n\nand odd (n : nat) : bool =\n  match n with\n    Zero -> false\n  | Next n -> even n\n\n```", "```\nlet rec mul (n1 : nat) (n2 : nat) : nat =\n  match n1 with\n    Zero -> Zero\n  | Next m -> add n2 (mul m n2)\n\n```", "```\ntoInt (mul (toNat 5) (toNat 20));;\n*- : int = 100*\n\n```", "```\n(* Returns the nth element of lst *)\nlet rec nth lst n =\n  match (lst, n) with\n    (h :: t, 0) -> h\n  | (h :: t, _) -> nth (t, n - 1)\n  | ([], _) -> failwith \"nth applied to empty list\"\n\n```", "```\ntype sign = Pos | Neg\ntype integer = { sign : sign; mag : nat }\n\n```", "```\nlet zero   = {sign=Pos; mag=Zero}\nlet zero'  = {sign=Neg; mag=Zero}\nlet one    = {sign=Pos; mag=Next Zero}\nlet negOne = {sign=Neg; mag=Next Zero}\n\n```", "```\nlet inc (i : integer) : integer =\n  match i with\n    {sign = _; mag = Zero} -> {sign = Pos; mag = Next Zero}\n  | {sign = Pos; mag = n} -> {sign = Pos; mag = Next n}\n  | {sign = Neg; mag = Next n} -> {sign = Neg; mag = n}\n\n```", "```\nlet swapInt ((x : int), (y : int)) : int * int = (y, x)\nand swapReal ((x : float), (y : float)) : float * float = (y, x)\nand swapString ((x : string), (y : string)) : string * string = (y, x)\n\n```", "```\nlet swapIntReal ((x : int), (y : float)) : float * int = (y, x)\nand swapRealInt ((x : float), (y : int)) : int * float = (y, x)\n\n```", "```\n# let swap ((x : 'a), (y : 'b)) : 'b * 'a = (y, x);;\n*val swap : 'a * 'b -> 'b * 'a = <fun>*\n\n```", "```\nswap (1, 2)         (* (int * int) -> (int * int) *)\nswap (3.14, 2.17)   (* (float * float) -> (float * float) *)\nswap (\"foo\", \"bar\") (* (string * string) -> (string * string) *)\nswap (\"foo\", 3.14)  (* (string * float) -> (float * string) *)\n\n```", "```\n# let swap (x, y) = (y, x);;\n*val swap : 'a * 'b -> 'b * 'a = <fun>*\n\n```", "```\n# let appendToString ((x : 'a), (s : string), (convert : 'a -> string)) : string =\n    (convert x) ^ \" \" ^ s;;\n*val appendToString : 'a * string * ('a -> string) -> string = <fun>*\n# appendToString (3110, \"class\", string_of_int);;\n*- : string = \"3110 class\"*\n# appendToString (\"ten\", \"twelve\", fun (s : string) -> s ^ \" past\");;\n*- : string = \"ten past twelve\"*\n\n```", "```\ntype intList = Nil | Cons of (int * intList)\n```", "```\ntype 'a list_ = Nil | Cons of ('a * 'a list_)\n```", "```\nlet il : int list_ = Cons (1, Cons (2, Cons (3, Nil)))  (* [1; 2; 3] *)\nlet fl : float list_ = Cons (3.14, Cons (2.17, Nil))    (* [3.14; 2.17] *)\nlet sl : string list_ = Cons (\"foo\", Cons (\"bar\", Nil)) (* [\"foo\"; \"bar\"] *)\nlet sil : (string * int) list_ =\n  Cons ((\"foo\", 1), Cons ((\"bar\", 2), Nil))  (* [(\"foo\", 1); (\"bar\", 2)] *)\n\n```", "```\nclass List<T> {\n    T head;\n    List <T> tail;\n    ...\n}\n\n```", "```\n(* polymorphic lists *)\n\ntype 'a list_ = Nil | Cons of 'a * 'a list_\n\n(* is the list empty? *)\nlet is_empty (lst : 'a list_) : bool = \n  match lst with\n  | Nil-> true\n  | _ -> false\n\n(* length of the list *)\nlet rec length (lst : 'a list_) : int = \n  match lst with\n  | Nil-> 0\n  | Cons (_, rest) -> 1 + length rest\n\n(* append [a; b; c] [d; e; f] = [a; b; c; d; e; f] *)\nlet rec append (x : 'a list_) (y : 'a list_) : 'a list_ = \n  match x with\n  | Nil-> y\n  | Cons (h, t) -> Cons (h, append t y)\n\n(* [1; 2; 3] *)\nlet il = Cons (1, Cons (2, Cons (3, Nil)))\nlet il2 = append il il\nlet il4 = append il2 il2\nlet il8 = append il4 il4\n(* [\"a\"; \"b\"; \"c\"] *)\nlet sl = Cons (\"a\", Cons (\"b\", Cons (\"c\", Nil)))\nlet sl2 = append sl sl\nlet sl4 = append sl2 sl2\n\n(* reverse the list:  reverse [1; 2; 3; 4] = [4; 3; 2; 1] *)\nlet rec reverse (x : 'a list_) : 'a list_ = \n  match x with\n  | Nil-> Nil\n  | Cons (h, t) -> append (reverse t) (Cons (h, Nil))\n\nlet il4r = reverse il4\nlet sl4r = reverse sl4\n\n(* apply the function f to each element of x\n * map f [a; b; c] = [f a; f b; f c] *)\nlet rec map (f : 'a -> 'b) (x : 'a list_) : 'b list_ = \n  match x with\n  | Nil-> Nil\n  | Cons (h, t) -> Cons (f h, map f t)\n\nlet mil4 = map string_of_int il4\n\n(* insert sep between each element of x: \n * separate s [a; b; c; d] = [a; s; b; s; c; s; d] *)\nlet rec separate (sep : 'a) (x : 'a list_) : 'a list_ = \n  match x with\n  | Nil-> Nil\n  | Cons (h, Nil) -> x\n  | Cons (h, t) -> Cons (h, Cons (sep, separate sep t))\n\nlet s0il4 = separate 0 il4\n\n```", "```\ntype 'a tree = Leaf | Node of ('a tree) * 'a * ('a tree)\n\n```", "```\ntype 'a tree = Leaf | Node of 'a node\nand 'a node = {left: 'a tree; value: 'a; right: 'a tree}\n\n```", "```\ntype ('a, 'b) pair = {first: 'a; second: 'b};;\nlet x = {first=2; second=\"hello\"};;\n*val x: (int, string) pair = {first = 2; second = \"hello\"}*\n\n```", "```\ntype id = string\ntype baseType = Int | Real | String | Bool | Char\ntype mlType = Base of baseType | Arrow of mlType * mlType\n              | Product of mlType list | Record of (id * mlType) list\n              | DatatypeName of id\n\n```", "```\nArrow (Product (Cons (Base Int, Cons (Base Bool, Nil))),\n       Record (Cons ((\"name\", Base String), Nil)))\n\n```"]