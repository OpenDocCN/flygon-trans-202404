["```\neval({with {x E1} E2}) = eval(E2[eval(E1)/x])\n```", "```\neval({with {x E1} E2}) = eval(E2[E1/x])\n```", "```\n(: eval : FLANG -> Number);; evaluates FLANG expressions by reducing them to numbers(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 ...\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval (subst bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bound-id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Num (eval named-expr))))]\u00a0 \u00a0 ...))\n```", "```\n(: eval : FLANG -> Number);; evaluates FLANG expressions by reducing them to numbers(define (eval expr)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [(Add l r) (+ (eval l) (eval r))]\u00a0 \u00a0 ...))\n```", "```\nFLANG eval(FLANG expr) {\u00a0 if (is_Num(expr))\u00a0 \u00a0 return num_of_Num(expr);\u00a0 else if (is_Add(expr))\u00a0 \u00a0 return eval(lhs_of_Add(expr)) + eval(rhs_of_Add(expr));\u00a0 else if ...\u00a0 ...}\n```", "```\n(define-type VAL = (U Number (VAL -> VAL)))\n```", "```\n(: eval : FLANG ENV -> VAL);; evaluates FLANG expressions by reducing them to values(define (eval expr env)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ;*** return the actual number\u00a0 \u00a0 [(Add l r) (+ (eval l env) (eval r env))]\u00a0 \u00a0 [(Sub l r) (- (eval l env) (eval r env))]\u00a0 \u00a0 [(Mul l r) (* (eval l env) (eval r env))]\u00a0 \u00a0 [(Div l r) (/ (eval l env) (eval r env))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Extend bound-id (eval named-expr env) env))]\u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 [(Fun bound-id bound-body)\u00a0 \u00a0  (lambda ([arg-val : VAL]) ;*** return the racket function\u00a0 \u00a0 \u00a0  ;; note that this requires input type specifications since\u00a0 \u00a0 \u00a0  ;; typed racket can't guess the right one\u00a0 \u00a0 \u00a0  (eval bound-body (Extend bound-id arg-val env)))]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  ((eval fun-expr env)\u00a0 \u00a0 \u00a0 ;*** trivial like the arithmetics!\u00a0 \u00a0 \u00a0 (eval arg-expr env))]))\n```", "```\n\u00a0 (: evalN : FLANG -> Number)\u00a0 (define (evalN e)\u00a0 \u00a0 (let ([n (eval e env)])\u00a0 \u00a0 \u00a0 (if (number? n)\u00a0 \u00a0 \u00a0 \u00a0 n\u00a0 \u00a0 \u00a0 \u00a0 (error 'eval \"got a non-number: ~s\" n))))\u00a0 (: evalF : FLANG -> (VAL -> VAL))\u00a0 (define (evalF e)\u00a0 \u00a0 (let ([f (eval e env)])\u00a0 \u00a0 \u00a0 (if (function? f)\u00a0 \u00a0 \u00a0 \u00a0 f\u00a0 \u00a0 \u00a0 \u00a0 (error 'eval \"got a non-function: ~s\" f))))\n```", "```\n#lang pl(define-type FLANG\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 FLANG FLANG]\u00a0 [Sub\u00a0 FLANG FLANG]\u00a0 [Mul\u00a0 FLANG FLANG]\u00a0 [Div\u00a0 FLANG FLANG]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol FLANG FLANG]\u00a0 [Fun\u00a0 Symbol FLANG]\u00a0 [Call FLANG FLANG])(: parse-sexpr : Sexpr -> FLANG);; parses s-expressions into FLANGs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'fun more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'fun (list (symbol: name)) body)\u00a0 \u00a0 \u00a0 \u00a0 (Fun name (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `fun' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list 'call fun arg)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Call (parse-sexpr fun) (parse-sexpr arg))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> FLANG);; parses a string containing a FLANG expression to a FLANG AST(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)));; Types for environments, values, and a lookup function;; Values are plain Racket values, no new VAL wrapper;;; (but note that this is a recursive definition)(define-type VAL = (U Number (VAL -> VAL)));; Define a type for functional environments(define-type ENV = (Symbol -> VAL))(: EmptyEnv : -> ENV)(define (EmptyEnv)\u00a0 (lambda (id) (error 'lookup \"no binding for ~s\" id)))(: Extend : Symbol VAL ENV -> ENV);; extend a given environment cache with a new binding(define (Extend id val rest-env)\u00a0 (lambda (name)\u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 val\u00a0 \u00a0 \u00a0 (rest-env name))))(: lookup : Symbol ENV -> VAL);; lookup a symbol in an environment, return its value or throw an;; error if it isn't bound(define (lookup name env)\u00a0 (env name))(: eval : FLANG ENV -> VAL);; evaluates FLANG expressions by reducing them to values(define (eval expr env)\u00a0 (: evalN : FLANG -> Number)\u00a0 (define (evalN e)\u00a0 \u00a0 (let ([n (eval e env)])\u00a0 \u00a0 \u00a0 (if (number? n)\u00a0 \u00a0 \u00a0 \u00a0 n\u00a0 \u00a0 \u00a0 \u00a0 (error 'eval \"got a non-number: ~s\" n))))\u00a0 (: evalF : FLANG -> (VAL -> VAL))\u00a0 (define (evalF e)\u00a0 \u00a0 (let ([f (eval e env)])\u00a0 \u00a0 \u00a0 (if (function? f)\u00a0 \u00a0 \u00a0 \u00a0 f\u00a0 \u00a0 \u00a0 \u00a0 (error 'eval \"got a non-function: ~s\" f))))\u00a0 (cases expr\u00a0 \u00a0 [(Num n) n]\u00a0 \u00a0 [(Add l r) (+ (evalN l) (evalN r))]\u00a0 \u00a0 [(Sub l r) (- (evalN l) (evalN r))]\u00a0 \u00a0 [(Mul l r) (* (evalN l) (evalN r))]\u00a0 \u00a0 [(Div l r) (/ (evalN l) (evalN r))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Extend bound-id (eval named-expr env) env))]\u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 [(Fun bound-id bound-body)\u00a0 \u00a0  (lambda ([arg-val : VAL])\u00a0 \u00a0 \u00a0  (eval bound-body (Extend bound-id arg-val env)))]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  ((evalF fun-expr)\u00a0 \u00a0 \u00a0 (eval arg-expr env))]))(: run : String -> VAL) ; no need to convert VALs to numbers;; evaluate a FLANG program contained in a string(define (run str)\u00a0 (eval (parse str) (EmptyEnv)));; tests(test (run \"{call {fun {x} {+ x 1}} 4}\")\u00a0 \u00a0 \u00a0 => 5)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add3 1}}\")\u00a0 \u00a0 \u00a0 => 4)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {add1 {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add1 {call add3 x}}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{with {identity {fun {x} x}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {foo {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call {call identity foo} 123}}}\")\u00a0 \u00a0 \u00a0 => 124)(test (run \"{with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {f {fun {y} {+ x y}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 5}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call f 4}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{call {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {y} {+ x y}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 4}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{call {call {fun {x} {call x 1}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {x} {fun {y} {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 123}\")\u00a0 \u00a0 \u00a0 => 124)\n```"]