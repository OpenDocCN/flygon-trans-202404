- en: Source Layout and Other General Points
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source Layout and Other General Points
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Header files
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C/ C++
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C and C++ code tends to be split over two general kinds of file:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The Header file (.h, .hpp) contains class definitions, external function signatures,
    macros, templates, inline functions. Sometimes inline functions get stored in
    their own file. The standard template library C++ headers do not have a file extension.
    Some 3rd party libraries like Qt may sometimes omit the extension.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Source file (.c, .cc, .cpp) contains the implementation of classes and anything
    private. Sometimes C++ will use tricks such as forward class references and Pimpl
    patterns to keep complex or dependent code out of the header file.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasionally you may also see files with a .inl, or .ipp extension which are
    headers with a lot of inline templates or functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Compilers are only interested in source files and what they `#include` so what's
    really happening in most C/C++ code is that a preprocessor concatenates various
    header files to the front of the source file according to the `#` directives within
    it and the resulting file is fed to a compiler.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Splitting definition and implementation across multiple files can be a nuisance
    since it means that changes to a single class can require modifications to multiple
    files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust does not have header files. Every struct, implementation and macro resides
    in a file ending in .rs. Code is made public or not by structuring .rs files into
    modules and exposing functions via the `pub` keyword.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Ordering is less important too. It is possible to forward reference structs
    or functions, or even `use` the very same module that a piece of code is a part
    of. The only time that ordering matters is for macro definitions. A macro must
    be defined before a module that uses it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Rust files reference non-dependent modules with the `use` keyword and pull-in
    dependent modules with the `mod` keyword.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C / C++
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C does not use namespaces. Libraries tend to prefix their functions and structs
    with a qualifying name of some sort.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: C++ *does* have namespaces but their use is optional and varies from one piece
    of code to the next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust has modules which are like `#include` and namespaces rolled into one
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: One major convenience definition and implementation are one and the same. Implementing
    a function brings it into existence. Any other module that chooses to "use" it
    simply says so and the compiler will ensure it compiles properly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: See Namespacing with modules TODO ref
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: File name conventions
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++ filenames typically end in:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: .h, .hpp, .inl for headers or inline code
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .c, .cpp, .cc for source code
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from the extension (which may kick off the compiler expecting C or C++)
    there is next to no expected arrangement or naming convention for files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: You can compile a file called deeply/nested/Timbuktu.cpp which defines 20 classes
    and 30 interfaces if you like and the name does not matter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Rust files are snake_case and end in .rs. The filename DOES matter because the
    name is the module name that scopes whatever is in it. There are also some special
    files called main.rs, lib.rs and mod.rs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: So if you name your file foo.rs, then everything inside is scoped foo::* when
    externally referenced.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Unicode support
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Unicode in C++ has always been a pain. Neither C nor C++ had support for
    it at all, and various solutions have appeared over time. Recent implementations
    of the standards of C and C++ provide string literal types for UTF encodings,
    but prior to that it was strictly ascii or wide characters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some general guidelines for Unicode in C / C++:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Source code is normally only safe to use characters 0-127 although some compilers
    may have parameters that allow makefiles to specify other encodings.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ has char and wchar_t types for 8-bit and 32-bit or possibly 16-bit wide
    strings. Part of the problem with wchar_t was the width was immediately subverted.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Char type implies no encoding. It normally means ASCII but could also mean UTF-8,
    Latin1, or in fact any form of encoding that predates Unicode. Basically it is
    up to the program to understand the meaning.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A "wide" wchar_t is NOT UTF-32\. It might be, or it might be UTF-16 on some
    platforms (e.g Windows). This messed up definition makes operations such as slicing
    strings dangerous due to the risk of cutting through a control point.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if I want to read Unicode arguments from the command-line such as file
    paths - what encoding are they in? The main() method passes them as char*. Windows
    has a wmain() that takes wchar_t*. What am I supposed to do?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows favours wide (UTF-16) character strings for its APIs although it has
    ASCII versions too. The ASCII versions are not UTF-8\. Compiled code has #define
    UNICODE to support multiple languages.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux tends to favour UTF-8 encoded char strings. Most languages, toolkits and
    tools assume UTF-8\. The exception is Qt which has chosen to use UTF-16 internally.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C-lib has acquired various wide versions of its strdup, strcmp, strcpy etc.
    It also acquired wide versions of functions for opening files on disk and so forth.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ lib has acquired std::string / std::wstring classes. C++ has acquired explicit
    UTF-16 and UTF-32 versions of these classes.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C11 and C++11 introduce explicit string literals for various UTF widths.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limited conversion capabilities between wide / narrow in C++. Some operating
    systems have incomplete conversion capabilities.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3rd party conversion libraries like ICU4C are commonly used. Libraries like
    boost, Qt use libicu for converting between encodings
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding Unicode into C source involves using escape codes or hex values
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust simplifies things a lot by benefit of hindsight.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Source code is UTF-8 encoded.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments, characters and string literals can contain Unicode characters without
    escaping.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The native char type is 4 bytes wide – as wide as a Unicode characters.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The native str & String types are internally UTF-8 to save space but may be
    iterated by char or by byte according to what the function is doing.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地的`str`和`String`类型在内部是UTF-8编码的，以节省空间，但根据函数的操作，可以按字符或按字节进行迭代。
- en: Since source code is UTF-8 encoded you may embed strings straight into the source.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于源代码是UTF-8编码的，你可以直接将字符串嵌入到源代码中。
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
