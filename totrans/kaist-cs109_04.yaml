- en: Number representations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have another look at my Collatz code. Remember that the conjecture was
    that the Collatz sequence always ends at one. We test this with some larger numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And at this point the program seems to go into an infinite loop!
  prefs: []
  type: TYPE_NORMAL
- en: 'But that means that we do not reach the number one—did we manage to find a
    counter example to the Collatz conjecture? Let''s try to find the starting value
    that leads to the infinite sequence. Here is a new function to do that ([collatz4.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/07-collatz/collatz4.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that starting with 113383 leads to an infinite sequence! Let''s print
    out the first numbers in this sequence. I add a print statement to collatzBounded
    ([collatz5.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/07-collatz/collatz5.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s that? Why are there negative numbers? The last positive number is 827370449,
    so let''s see what happens to that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Oops! Is our definition of the next function wrong?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: No, it seems that Kotlin's arithmetic is broken!
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that you have to be careful with Int integer objects. Int integers
    have 32 bits, and therefore the largest possible Int value is \(2^{31} - 1\).
    You can also find this maximum value as Int.MAX_VALUE. But \(3 \cdot 827370449\)
    is larger than this. We can check this by computing the value using long arithmetic.
    A Long is an integer with 64 bits. You can convert an integer to a Long using
    the toLong() method, or simply write an L after a literal integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How numbers are represented
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Integers are represented using a fixed number of bits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Long | 64 bits |'
  prefs: []
  type: TYPE_TB
- en: '| Int | 32 bits |'
  prefs: []
  type: TYPE_TB
- en: '| Short | 16 bits |'
  prefs: []
  type: TYPE_TB
- en: '| Byte | 8 bits |'
  prefs: []
  type: TYPE_TB
- en: 'Arithmetic on these types is performed by the hardware using registers of fixed
    length. For instance, imagine we had a type of integer with four bits, and we
    perform some additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since the register has only four bits, the overflow that happens when you add \(9
    + 7\) cannot be represented, and the result is not \(10000 = 16\) but \(0000 =
    0\).
  prefs: []
  type: TYPE_NORMAL
- en: In other words, integer addition and subtraction is really addition and subtraction
    modulo \(2^{k}\), where \(k\) is the number of bits. For our four-bit data type,
    additions are modulo 16, and therefore \(9 + 7 = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is actually convenient, because it allows us to use negative numbers without
    any extra hardware: For instance, since \(-1 \equiv 15\) (modulo 16), we can subtract
    one by adding \(15\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Of course the problem is how to determine what number the output represents.
    When the result is \(1111\), does that mean \(15\) or \(-1\)?
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard convention is to say that the number is negative when the first
    bit is one. In other words, \(1000 ... 1111\) are \(-8\) to \(-1\), and \(0000
    ... 0111\) are \(0\) to \(7\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is convenient, because it's very easy to test if a number is negative,
    but it's just a convention. Some programming languages (like C and C++) also have
    unsigned integers, where \(0000 ... 1111\) mean \(0\) to \(15\). In principle,
    we could also say that \(1100 ... 1111\) mean \(-4\) to \(-1\), and \(0000 ...
    1011\) mean \(0\) to \(11\).
  prefs: []
  type: TYPE_NORMAL
- en: In our example above, we performed the multplication \(3 * 827370449 = 2482111347\).
    In binary, this is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first bit of the result is \(1\), and therefore it is considered negative.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about number representations [here](http://www.swarthmore.edu/NatSci/echeeve1/Ref/BinaryMath/NumSys.html).
  prefs: []
  type: TYPE_NORMAL
