- en: How Recursion Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breaking Down Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how recursion can magically find the factorial of any number. We''ve
    replicated the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`factorial` returns `1` when `n` is `0`, otherwise it returns the product of
    `n` and the factorial of `n - 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every recursive procedure uses conditionals, and will need two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base case:** This case ends the recursion. Any input to a recursive procedure
    will eventually reach the base case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursive case:** This case reduces the size of the problem. The recursive
    case will always try to make the problem smaller until it reaches the base case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be more than one base case or recursive case in a recursive procedure,
    but there must be at least one of each in order for any procedure to be correct
    and recursive.
  prefs: []
  type: TYPE_NORMAL
- en: There is one base case and one recursive case in our `factorial` procedure.
    Can you identify them?
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The case in which `n` is `0` is the *base case* of `factorial`. Consider this
    alternate definition of `factorial`, which has no base case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with this alternate definition?
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case in which we call `factorial` within itself is the *recursive
    case*. Notice that the recursive call solves a smaller problem (i.e., `(factorial
    (- n 1))`) than the one we were originally given. Consider this alternate definition
    of `factorial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What's wrong with this alternate definition?
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following statements must hold for every recursive procedure you
    write? Choose all that apply.
  prefs: []
  type: TYPE_NORMAL
- en: Leap of Faith
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you may still be wondering how a function can be defined in terms
    of itself. If you use `factorial` in the middle of defining `factorial`, shouldn't
    you get an error saying that `factorial` isn't defined yet? In order to make it
    work, you have to believe that it works. This is, in a sense, a *leap of faith*.
  prefs: []
  type: TYPE_NORMAL
- en: The leap of faith is actually a technique for writing recursive procedures.
    We must imagine that the procedure you are writing already works for any problem
    smaller than the one you are currently tackling. Thus, while you are thinking
    about how to compute `(factorial 5)`, imagine that `(factorial 4)` has already
    been solved. This will keep your own thoughts from getting stuck in an infinite
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Back in Lesson 0-2, we stated an important property of defining procedures,
    where the procedure body is not evaluated when it is definted. This is the technical
    reason why recursion can work. Thus, `define` is a special form that does not
    evaluate its arguments and keeps the procedure body from being evaluated. The
    body is only evaluated when you call the procedure outside of the definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of these expressions cause an error in Racket? Select all that apply.
  prefs: []
  type: TYPE_NORMAL
- en: Enter each expression into the Racket interpreter and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '`factorial` Revisited'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at the definition of `factorial` again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we would like to evaluate `(factorial 6)`, then we reach the else case of
    the `if` statement and reduce the problem to `(* 6 (factorial 5))`. To simplify
    this further, we''ll need to evaluate `(factorial 5)`. Thus, we get `(* 5 (factorial
    4))`. If we substitute this into the original expression, we get `(* 6 (* 5 (factorial
    4)))`. A few more recursive calls later, we''ll get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What should we do with `(factorial 0)`? This is the base case, and we should
    just return `1`. Thus, we get this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simply a series of nested multiplication expressions, which we can
    simplify easily, from inside out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In Racket, there is a very useful procedure called `trace`, which takes a procedure
    as an argument and returns the process of the procedure when the procedure is
    invoked.
  prefs: []
  type: TYPE_NORMAL
- en: In your Racket interpreter, type `(trace factorial)` after defining the `factorial`
    procedure, then call `(factorial 6)`. What do you see? If you no longer want to
    trace the procedure, simply type `(untrace factorial)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Fibonacci Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider computing the sequence of Fibonacci numbers, in which each number
    is the sum of the preceding two:'
  prefs: []
  type: TYPE_NORMAL
- en: \begin{align} 0, 1, 1, 2, 3, 5, 8, 13, 21 \end{align}
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the Fibonacci numbers can be defined by the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: \begin{align} Fib(n) = \begin{cases} 0, & \text{if n = 0} \\ 1, & \text{if n
    = 1} \\ Fib(n - 1) + Fib(n - 2), & \text{otherwise} \end{cases} \end{align}
  prefs: []
  type: TYPE_NORMAL
- en: 'We can immediately translate this definition into a recursive procedure for
    computing Fibonacci numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Consider what happens when we call `(fib 2)`. The procedure makes two recursive
    calls `(fib 1)` and `(fib 0)`, which return `1` and `0` respectively. These numbers
    are added together, and the procedure returns `1`.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering if it's really necessary to have two separate base cases.
    Consider what would happen if we left out the base case for when `n` is `1`. `(fib
    1)` would call `(+ (fib 0) (fib -1))`. `(fib 0)` would return `0`, but `(fib -1)`
    would never reach a base case, and the procedure would loop indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Pig Latin'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be familiar with Pig Latin, which is a language game where words in
    English are altered according to a simple set of rules: take the first consonant
    (or consonant cluster) of an English word and move it to the end of the word and
    append "ay" to the word. For example, "pig" yields "igpay", "trash" yields "ashtray",
    and "object" yields "objectay".'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write Pig Latin in Racket using recursion and helper procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, `member?` is a Racket primitive procedure that takes two arguments,
    a letter and a word and returns true if the letter is in the word.
  prefs: []
  type: TYPE_NORMAL
- en: Pig Latin is done when a vowel is found, so the base case is when `pl-done?`
    returns true, and it just concatenates "ay" at the end of the word. Otherwise,
    in the recursive case, it calls itself with the concatenation of the `butfirst`
    of the word and the first of word. Think about what happens if the word contains
    no vowels.
  prefs: []
  type: TYPE_NORMAL
- en: Use your Racket interpreter to try out this implementation of `pigl`. Don't
    forget to take advantage of the `trace` procedure!
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: `sum-sent`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we have a sentence of numbers, such as the one below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We want to define a procedure called `sum-sent` that can find the sum of all
    the numbers in `sent`, but we also want `sum-sent` to be able to find the sum
    of *any* sentence of numbers. Since the output depends on the size of the input
    sentence, we will have to use recursion!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the leap of faith. Imagine that `sum-sent` already knows how to
    calculate the sentence containing all but the first number, e.g, `''(2 3 4 5)`.
    To find this, we would simply call `(sum-sent (bf sent))`, and we should have
    faith that it will give us the correct sum. Given that, we know that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we generalize this for any sentence of numbers, this gives us our recursive
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we stop here and define `sum-sent` as follows?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re missing the base case! To solve this problem, we must add a case that
    will handle the empty sentence. The predicate `empty?` can be used to check for
    the empty sentence. Here is the completed version of `sum-sent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a sentence of negative numbers, `'(-1 -3 -4 -6)`. What will
    Racket output? Run through this example using the code for `sum-sent` above without
    typing it into the interpeter. Then, use the interpreter to check your work.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to try out more examples with `sum-sent` in the Racket interpreter.
    If the recursion is confusing, try looking at what `trace` outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Test Your Understanding: `count-ums`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you teach a class, people will get distracted if you say "um" too many
    times. Write a procedure called `count-ums` that takes in a sentence of words
    as its arguments and counts the number of times "um" appears in that sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Write `count-ums` recursively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint #1:** What should happen when the sentence is empty?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint #2:** What should happen when the first word of the sentence is "um"?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint #3:** What should happen when the first word of the sentence is NOT
    "um"?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding: `countdown`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a procedure called `countdown` that takes in a number and works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
