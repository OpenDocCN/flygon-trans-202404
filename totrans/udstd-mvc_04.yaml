- en: Advanced MVC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 MVC
- en: Advanced MVC
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 MVC
- en: Until [](GLOSSARY.html) now, the [](GLOSSARY.html) main [](GLOSSARY.html) focus
    [](GLOSSARY.html) was [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html)
    basic [](GLOSSARY.html) patterns [](GLOSSARY.html) of [](GLOSSARY.html) MVC. In
    [](GLOSSARY.html) this [](GLOSSARY.html) chapter, we [](GLOSSARY.html) will [](GLOSSARY.html)
    observe [](GLOSSARY.html) the [](GLOSSARY.html) broader [](GLOSSARY.html) picture
    [](GLOSSARY.html) of [](GLOSSARY.html) a [](GLOSSARY.html) MVC [](GLOSSARY.html)
    application [](GLOSSARY.html) and [](GLOSSARY.html) how [](GLOSSARY.html) the
    [](GLOSSARY.html) patterns [](GLOSSARY.html) interact with [](GLOSSARY.html) the
    [](GLOSSARY.html) real [](GLOSSARY.html) world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，主要关注于 MVC 的基本模式。在本章中，我们将观察 MVC 应用程序的更广泛图景，以及这些模式如何与现实世界互动。
- en: '[Model persistence](model_persistence.html)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模型持久性](model_persistence.html)'
- en: '[MVC Testing](mvc_testing.html)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MVC 测试](mvc_testing.html)'
- en: '[Notification Granularity](notification_granularity.md)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通知粒度](notification_granularity.md)'
- en: '[Event Driven programming](event_driven_programming.html)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[事件驱动编程](event_driven_programming.html)'
- en: '[Thrashing prevention](trashing_prevention.html)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抖动预防](trashing_prevention.html)'
- en: '[Validation](validation.html)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[验证](validation.html)'
- en: '[Lapsed listener problem](lapsed_listener_problem.html)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[过期的监听器问题](lapsed_listener_problem.html)'
- en: '[Publisher Subscriber](publisher_subscriber.html)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[发布者-订阅者](publisher_subscriber.html)'
- en: '[Model Distribution](model_distribution.html)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模型分布](model_distribution.html)'
- en: '[Multithreading](multithreading.html)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[多线程](multithreading.html)'
- en: '[Notification looping prevention](28_notification_looping_prevention.html):
    Prevent [](GLOSSARY.html) recursive [](GLOSSARY.html) notification [](GLOSSARY.html)
    events [](GLOSSARY.html) to [](GLOSSARY.html) propagate.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通知循环预防](28_notification_looping_prevention.html)：防止递归通知事件传播。'
- en: '[Delayed Model](40_delayed_model.html): Neutralizes [](GLOSSARY.html) fast
    [](GLOSSARY.html) notifications [](GLOSSARY.html) through [](GLOSSARY.html) a
    [](GLOSSARY.html) timeout.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[延迟模型](40_delayed_model.html)：通过超时中和快速通知。'
- en: '[Throttling](41_throttling.html): Neutralizes [](GLOSSARY.html) fast [](GLOSSARY.html)
    notifications, but [](GLOSSARY.html) issue [](GLOSSARY.html) a [](GLOSSARY.html)
    change [](GLOSSARY.html) immediately.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[节流](41_throttling.html)：中和快速通知，但立即发出变更。'
- en: Model persistence
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型持久性
- en: Model persistence
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型持久性
- en: Domain [](GLOSSARY.html) Model [](GLOSSARY.html) objects
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型对象
- en: 'In [](GLOSSARY.html) some [](GLOSSARY.html) cases, the [](GLOSSARY.html) model
    [](GLOSSARY.html) or [](GLOSSARY.html) part [](GLOSSARY.html) of [](GLOSSARY.html)
    the [](GLOSSARY.html) model [](GLOSSARY.html) must [](GLOSSARY.html) be [](GLOSSARY.html)
    made [](GLOSSARY.html) persistent (for example, to [](GLOSSARY.html) disk, or
    [](GLOSSARY.html) to [](GLOSSARY.html) a [](GLOSSARY.html) database) to [](GLOSSARY.html)
    be [](GLOSSARY.html) restored [](GLOSSARY.html) at [](GLOSSARY.html) a [](GLOSSARY.html)
    later [](GLOSSARY.html) stage. Persistency [](GLOSSARY.html) layer: sometimes
    [](GLOSSARY.html) it [](GLOSSARY.html) is [](GLOSSARY.html) considered [](GLOSSARY.html)
    part [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html) Model, but [](GLOSSARY.html)
    not [](GLOSSARY.html) necessarily'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，模型或模型的部分必须持久化（例如，到磁盘，或到数据库）以便在以后恢复。持久性层：有时被视为模型的一部分，但不一定
- en: Which [](GLOSSARY.html) component [](GLOSSARY.html) should [](GLOSSARY.html)
    be responsible [](GLOSSARY.html) for [](GLOSSARY.html) the [](GLOSSARY.html) persistence?
    The [](GLOSSARY.html) most [](GLOSSARY.html) natural [](GLOSSARY.html) strategy
    [](GLOSSARY.html) is [](GLOSSARY.html) to [](GLOSSARY.html) let [](GLOSSARY.html)
    the [](GLOSSARY.html) model know [](GLOSSARY.html) how [](GLOSSARY.html) to [](GLOSSARY.html)
    store [](GLOSSARY.html) and [](GLOSSARY.html) retrieve [](GLOSSARY.html) itself
    [](GLOSSARY.html) from [](GLOSSARY.html) disk [](GLOSSARY.html) or [](GLOSSARY.html)
    database. This [](GLOSSARY.html) is [](GLOSSARY.html) a [](GLOSSARY.html) popular
    solution [](GLOSSARY.html) and [](GLOSSARY.html) goes [](GLOSSARY.html) by [](GLOSSARY.html)
    the [](GLOSSARY.html) name [](GLOSSARY.html) of "ActiveRecord". It [](GLOSSARY.html)
    is [](GLOSSARY.html) simple [](GLOSSARY.html) to [](GLOSSARY.html) use [](GLOSSARY.html)
    and understand, relatively [](GLOSSARY.html) flexible [](GLOSSARY.html) and [](GLOSSARY.html)
    intuitive, but [](GLOSSARY.html) it's [](GLOSSARY.html) not [](GLOSSARY.html)
    without [](GLOSSARY.html) limitation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个[GLOSSARY.html](https://wiki.example.org/GLOSSARY.html)组件应负责持久性？最自然的策略是让模型知道如何将自己存储和检索到磁盘或数据库中。这是一种流行的解决方案，被称为“ActiveRecord”。它使用起来简单易懂，相对灵活直观，但并非没有限制。
- en: 'The [](GLOSSARY.html) first, and [](GLOSSARY.html) biggest [](GLOSSARY.html)
    limitation [](GLOSSARY.html) is [](GLOSSARY.html) that [](GLOSSARY.html) it [](GLOSSARY.html)
    favors [](GLOSSARY.html) strong [](GLOSSARY.html) coupling [](GLOSSARY.html) between
    [](GLOSSARY.html) the model [](GLOSSARY.html) and [](GLOSSARY.html) the [](GLOSSARY.html)
    IO [](GLOSSARY.html) strategy: abandoning [](GLOSSARY.html) the [](GLOSSARY.html)
    local [](GLOSSARY.html) disk [](GLOSSARY.html) storage [](GLOSSARY.html) in [](GLOSSARY.html)
    favor [](GLOSSARY.html) of [](GLOSSARY.html) a remote [](GLOSSARY.html) database
    [](GLOSSARY.html) will [](GLOSSARY.html) force [](GLOSSARY.html) us [](GLOSSARY.html)
    to [](GLOSSARY.html) reimplement [](GLOSSARY.html) the [](GLOSSARY.html) IO [](GLOSSARY.html)
    strategy [](GLOSSARY.html) of [](GLOSSARY.html) all [](GLOSSARY.html) the [](GLOSSARY.html)
    model objects;'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，也是最大的限制是它偏爱模型和IO策略之间的强耦合：放弃本地磁盘存储，转而使用远程数据库将迫使我们重新实现所有模型对象的IO策略；
- en: A [](GLOSSARY.html) second [](GLOSSARY.html) problem [](GLOSSARY.html) is [](GLOSSARY.html)
    that [](GLOSSARY.html) Model [](GLOSSARY.html) objects [](GLOSSARY.html) lifetime
    [](GLOSSARY.html) is [](GLOSSARY.html) related [](GLOSSARY.html) to [](GLOSSARY.html)
    the [](GLOSSARY.html) storage backend. This [](GLOSSARY.html) makes [](GLOSSARY.html)
    testing [](GLOSSARY.html) the [](GLOSSARY.html) Model [](GLOSSARY.html) much [](GLOSSARY.html)
    harder, because [](GLOSSARY.html) the [](GLOSSARY.html) storage [](GLOSSARY.html)
    backend must [](GLOSSARY.html) be [](GLOSSARY.html) fully [](GLOSSARY.html) functional,
    or [](GLOSSARY.html) mocked;
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是模型对象的生命周期与存储后端相关联。这使得测试模型变得更加困难，因为存储后端必须完全功能，或者模拟。
- en: The [](GLOSSARY.html) final [](GLOSSARY.html) problem [](GLOSSARY.html) of [](GLOSSARY.html)
    this [](GLOSSARY.html) approach [](GLOSSARY.html) is [](GLOSSARY.html) that, if
    [](GLOSSARY.html) the [](GLOSSARY.html) Model [](GLOSSARY.html) is [](GLOSSARY.html)
    fully [](GLOSSARY.html) in [](GLOSSARY.html) control [](GLOSSARY.html) of its
    [](GLOSSARY.html) persistence [](GLOSSARY.html) strategy, the [](GLOSSARY.html)
    client [](GLOSSARY.html) code [](GLOSSARY.html) cannot [](GLOSSARY.html) decide
    [](GLOSSARY.html) differently, for example, if [](GLOSSARY.html) it [](GLOSSARY.html)
    wants [](GLOSSARY.html) to store [](GLOSSARY.html) the [](GLOSSARY.html) model
    [](GLOSSARY.html) object [](GLOSSARY.html) somewhere [](GLOSSARY.html) else.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的最终问题是，如果模型完全控制其持久性策略，客户端代码无法做出不同的决定，例如，如果它希望将模型对象存储在其他地方。
- en: 'An [](GLOSSARY.html) alternative [](GLOSSARY.html) strategy [](GLOSSARY.html)
    is [](GLOSSARY.html) to [](GLOSSARY.html) delegate [](GLOSSARY.html) persistence
    [](GLOSSARY.html) to [](GLOSSARY.html) the [](GLOSSARY.html) Controller. The controller
    [](GLOSSARY.html) holds [](GLOSSARY.html) a [](GLOSSARY.html) reference [](GLOSSARY.html)
    to [](GLOSSARY.html) the [](GLOSSARY.html) model, and [](GLOSSARY.html) to [](GLOSSARY.html)
    a [](GLOSSARY.html) Storage [](GLOSSARY.html) subsystem. In response [](GLOSSARY.html)
    to [](GLOSSARY.html) proper [](GLOSSARY.html) trigger [](GLOSSARY.html) events,
    the [](GLOSSARY.html) controller [](GLOSSARY.html) can [](GLOSSARY.html) pick
    [](GLOSSARY.html) the [](GLOSSARY.html) relevant [](GLOSSARY.html) model objects
    [](GLOSSARY.html) and [](GLOSSARY.html) push [](GLOSSARY.html) them [](GLOSSARY.html)
    to [](GLOSSARY.html) the [](GLOSSARY.html) storage [](GLOSSARY.html) subsystem.
    This [](GLOSSARY.html) strategy [](GLOSSARY.html) has [](GLOSSARY.html) a [](GLOSSARY.html)
    few advantages: the [](GLOSSARY.html) model [](GLOSSARY.html) objects [](GLOSSARY.html)
    are [](GLOSSARY.html) lighter [](GLOSSARY.html) and [](GLOSSARY.html) know [](GLOSSARY.html)
    nothing [](GLOSSARY.html) of [](GLOSSARY.html) storage strategies, which [](GLOSSARY.html)
    can [](GLOSSARY.html) now [](GLOSSARY.html) be [](GLOSSARY.html) changed [](GLOSSARY.html)
    freely [](GLOSSARY.html) by [](GLOSSARY.html) using [](GLOSSARY.html) a [](GLOSSARY.html)
    different [](GLOSSARY.html) Storage service, potentially [](GLOSSARY.html) to
    [](GLOSSARY.html) a [](GLOSSARY.html) mock [](GLOSSARY.html) object [](GLOSSARY.html)
    during [](GLOSSARY.html) testing. The [](GLOSSARY.html) main [](GLOSSARY.html)
    disadvantage [](GLOSSARY.html) is that [](GLOSSARY.html) the [](GLOSSARY.html)
    additional [](GLOSSARY.html) flexibility [](GLOSSARY.html) requires [](GLOSSARY.html)
    more [](GLOSSARY.html) a [](GLOSSARY.html) complicated [](GLOSSARY.html) interaction.
    The storage [](GLOSSARY.html) can [](GLOSSARY.html) also [](GLOSSARY.html) be
    [](GLOSSARY.html) in [](GLOSSARY.html) charge [](GLOSSARY.html) of [](GLOSSARY.html)
    additional [](GLOSSARY.html) tasks, such [](GLOSSARY.html) as [](GLOSSARY.html)
    search [](GLOSSARY.html) and [](GLOSSARY.html) filtering of [](GLOSSARY.html)
    model [](GLOSSARY.html) objects, or [](GLOSSARY.html) creation (factory) of [](GLOSSARY.html)
    new [](GLOSSARY.html) objects, which [](GLOSSARY.html) the [](GLOSSARY.html) storage
    inserts [](GLOSSARY.html) into [](GLOSSARY.html) the [](GLOSSARY.html) database
    [](GLOSSARY.html) and [](GLOSSARY.html) hands [](GLOSSARY.html) out [](GLOSSARY.html)
    to [](GLOSSARY.html) the [](GLOSSARY.html) controller.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是将持久性委托给控制器。控制器持有对模型的引用，以及对存储子系统的引用。作为对适当触发事件的响应，控制器可以选择相关的模型对象，并将它们推送到存储子系统。这种策略有一些优点：模型对象更轻量，并且对存储策略一无所知，现在可以通过使用不同的存储服务自由更改，可能在测试期间使用模拟对象。主要缺点是额外的灵活性需要更复杂的交互。存储还可以负责其他任务，如搜索和过滤模型对象，或创建（工厂）新对象，存储将其插入数据库并交给控制器。
- en: When [](GLOSSARY.html) it [](GLOSSARY.html) comes [](GLOSSARY.html) to [](GLOSSARY.html)
    data [](GLOSSARY.html) formats, there [](GLOSSARY.html) are [](GLOSSARY.html)
    many [](GLOSSARY.html) options, from [](GLOSSARY.html) the [](GLOSSARY.html) very
    [](GLOSSARY.html) simple [](GLOSSARY.html) CSV to [](GLOSSARY.html) the [](GLOSSARY.html)
    more [](GLOSSARY.html) complex [](GLOSSARY.html) like [](GLOSSARY.html) databases.
    A [](GLOSSARY.html) simple [](GLOSSARY.html) choice [](GLOSSARY.html) can [](GLOSSARY.html)
    be [](GLOSSARY.html) a [](GLOSSARY.html) nosql [](GLOSSARY.html) database, or
    a [](GLOSSARY.html) tinysql. Regardless [](GLOSSARY.html) of [](GLOSSARY.html)
    your [](GLOSSARY.html) choice, it's [](GLOSSARY.html) important [](GLOSSARY.html)
    you [](GLOSSARY.html) version [](GLOSSARY.html) your [](GLOSSARY.html) objects.
    The [](GLOSSARY.html) object [](GLOSSARY.html) is [](GLOSSARY.html) generally
    [](GLOSSARY.html) serialized [](GLOSSARY.html) in [](GLOSSARY.html) a [](GLOSSARY.html)
    stream [](GLOSSARY.html) of [](GLOSSARY.html) bytes [](GLOSSARY.html) and [](GLOSSARY.html)
    written [](GLOSSARY.html) to [](GLOSSARY.html) disk. Recovery [](GLOSSARY.html)
    implies [](GLOSSARY.html) de-serialization [](GLOSSARY.html) of [](GLOSSARY.html)
    the [](GLOSSARY.html) byte [](GLOSSARY.html) string, and [](GLOSSARY.html) reconstruction
    [](GLOSSARY.html) of the [](GLOSSARY.html) object [](GLOSSARY.html) last [](GLOSSARY.html)
    state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到数据格式时，有许多选择，从非常简单的 CSV 到更复杂的数据库。一个简单的选择可以是 nosql 数据库，或者是 tinysql。无论你选择什么，重要的是对你的对象进行版本控制。对象通常被序列化为一系列字节流并写入磁盘。恢复意味着对字节字符串进行反序列化，并重建对象的最后状态。
- en: ORM [](GLOSSARY.html) models
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 模型
- en: The [](GLOSSARY.html) model [](GLOSSARY.html) can [](GLOSSARY.html) be [](GLOSSARY.html)
    distributed [](GLOSSARY.html) over [](GLOSSARY.html) a [](GLOSSARY.html) network
    [](GLOSSARY.html) and [](GLOSSARY.html) accessed [](GLOSSARY.html) through [](GLOSSARY.html)
    proxy [](GLOSSARY.html) classes with [](GLOSSARY.html) none [](GLOSSARY.html)
    or [](GLOSSARY.html) minor [](GLOSSARY.html) changes [](GLOSSARY.html) to [](GLOSSARY.html)
    the [](GLOSSARY.html) remaining [](GLOSSARY.html) protagonists.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以分布在网络上，并通过代理类访问，对剩余的主体没有或只有轻微的更改。
- en: 'Persistency [](GLOSSARY.html) layer: aimed [](GLOSSARY.html) exclusively [](GLOSSARY.html)
    at [](GLOSSARY.html) services [](GLOSSARY.html) for [](GLOSSARY.html) persistence
    [](GLOSSARY.html) of [](GLOSSARY.html) models (so [](GLOSSARY.html) that [](GLOSSARY.html)
    they [](GLOSSARY.html) don''t [](GLOSSARY.html) contain [](GLOSSARY.html) this
    [](GLOSSARY.html) logic [](GLOSSARY.html) themselves)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性层：专门针对模型的持久性服务（以便它们不包含这个逻辑本身）
- en: MVC Testing
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 测试
- en: MVC Testing
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC 测试
- en: Detail [](GLOSSARY.html) the [](GLOSSARY.html) challenges [](GLOSSARY.html)
    of [](GLOSSARY.html) asynchronous [](GLOSSARY.html) component [](GLOSSARY.html)
    in [](GLOSSARY.html) testing
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 详细说明异步组件在测试中的挑战
- en: A [](GLOSSARY.html) major [](GLOSSARY.html) problem [](GLOSSARY.html) resulting
    [](GLOSSARY.html) from [](GLOSSARY.html) a [](GLOSSARY.html) complex [](GLOSSARY.html)
    View [](GLOSSARY.html) is [](GLOSSARY.html) the [](GLOSSARY.html) difficulty [](GLOSSARY.html)
    of [](GLOSSARY.html) testing. Visual [](GLOSSARY.html) components [](GLOSSARY.html)
    tend [](GLOSSARY.html) to [](GLOSSARY.html) be [](GLOSSARY.html) more [](GLOSSARY.html)
    complex [](GLOSSARY.html) to [](GLOSSARY.html) test, because [](GLOSSARY.html)
    they [](GLOSSARY.html) require simulation [](GLOSSARY.html) of [](GLOSSARY.html)
    User [](GLOSSARY.html) interaction. Toolkits [](GLOSSARY.html) provide [](GLOSSARY.html)
    techniques [](GLOSSARY.html) to [](GLOSSARY.html) create [](GLOSSARY.html) events
    programmatically, but [](GLOSSARY.html) their [](GLOSSARY.html) handling [](GLOSSARY.html)
    depends [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html) event [](GLOSSARY.html)
    loop [](GLOSSARY.html) being [](GLOSSARY.html) executed. The [](GLOSSARY.html)
    blocking [](GLOSSARY.html) nature [](GLOSSARY.html) of [](GLOSSARY.html) its [](GLOSSARY.html)
    execution [](GLOSSARY.html) makes [](GLOSSARY.html) it [](GLOSSARY.html) impractical
    [](GLOSSARY.html) in [](GLOSSARY.html) a [](GLOSSARY.html) test [](GLOSSARY.html)
    setting.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于复杂视图带来的一个主要问题是测试的困难。视觉组件往往更难测试，因为它们需要模拟用户交互。工具包提供了以编程方式创建事件的技术，但它们的处理取决于事件循环的执行。其执行的阻塞性质使得在测试环境中变得不切实际。
- en: Testing [](GLOSSARY.html) a [](GLOSSARY.html) GUI [](GLOSSARY.html) application
    [](GLOSSARY.html) is [](GLOSSARY.html) generally [](GLOSSARY.html) complex, due
    [](GLOSSARY.html) to [](GLOSSARY.html) the [](GLOSSARY.html) large [](GLOSSARY.html)
    number [](GLOSSARY.html) of [](GLOSSARY.html) interactions that [](GLOSSARY.html)
    the [](GLOSSARY.html) user [](GLOSSARY.html) may [](GLOSSARY.html) potentially
    [](GLOSSARY.html) choose [](GLOSSARY.html) to [](GLOSSARY.html) perform. Manual
    [](GLOSSARY.html) testing [](GLOSSARY.html) is [](GLOSSARY.html) tedious [](GLOSSARY.html)
    and [](GLOSSARY.html) error-prone, and [](GLOSSARY.html) simulating [](GLOSSARY.html)
    user [](GLOSSARY.html) events [](GLOSSARY.html) can [](GLOSSARY.html) open [](GLOSSARY.html)
    problems [](GLOSSARY.html) relative [](GLOSSARY.html) to [](GLOSSARY.html) their
    [](GLOSSARY.html) intrinsic [](GLOSSARY.html) asynchronous [](GLOSSARY.html) nature,
    and [](GLOSSARY.html) the [](GLOSSARY.html) visual [](GLOSSARY.html) nature [](GLOSSARY.html)
    of [](GLOSSARY.html) the [](GLOSSARY.html) result.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 测试GUI应用程序通常是复杂的，因为用户可能选择执行的交互数量很大。手动测试是繁琐且容易出错的，模拟用户事件可能会引发与其固有的异步性质以及结果的视觉性质相关的问题。
- en: A [](GLOSSARY.html) sensible [](GLOSSARY.html) approach [](GLOSSARY.html) is
    [](GLOSSARY.html) to [](GLOSSARY.html) leverage [](GLOSSARY.html) the [](GLOSSARY.html)
    MVC [](GLOSSARY.html) structure [](GLOSSARY.html) to [](GLOSSARY.html) attack
    [](GLOSSARY.html) the [](GLOSSARY.html) testing [](GLOSSARY.html) problem [](GLOSSARY.html)
    in a [](GLOSSARY.html) programmatic, and [](GLOSSARY.html) possibly [](GLOSSARY.html)
    synchronous [](GLOSSARY.html) way.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一种明智的方法是利用MVC结构来解决程序中的测试问题，可能是以编程方式，也可能是同步方式。
- en: 'In [](GLOSSARY.html) general, you [](GLOSSARY.html) should [](GLOSSARY.html)
    be [](GLOSSARY.html) able [](GLOSSARY.html) to [](GLOSSARY.html) test [](GLOSSARY.html)
    or [](GLOSSARY.html) even [](GLOSSARY.html) use [](GLOSSARY.html) the [](GLOSSARY.html)
    model independently [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html)
    controller [](GLOSSARY.html) and [](GLOSSARY.html) views. In [](GLOSSARY.html)
    fact, the [](GLOSSARY.html) model [](GLOSSARY.html) should be [](GLOSSARY.html)
    able [](GLOSSARY.html) to [](GLOSSARY.html) work [](GLOSSARY.html) without [](GLOSSARY.html)
    any [](GLOSSARY.html) controllers [](GLOSSARY.html) or [](GLOSSARY.html) views
    [](GLOSSARY.html) implemented [](GLOSSARY.html) at [](GLOSSARY.html) all. It''s
    [](GLOSSARY.html) a [](GLOSSARY.html) completely [](GLOSSARY.html) separated [](GLOSSARY.html)
    layer [](GLOSSARY.html) with [](GLOSSARY.html) no [](GLOSSARY.html) dependencies
    [](GLOSSARY.html) toward [](GLOSSARY.html) GUI representation, widgets, or [](GLOSSARY.html)
    strategies [](GLOSSARY.html) to [](GLOSSARY.html) apply [](GLOSSARY.html) the
    [](GLOSSARY.html) changes. If [](GLOSSARY.html) this is [](GLOSSARY.html) not
    [](GLOSSARY.html) the [](GLOSSARY.html) case, then [](GLOSSARY.html) you [](GLOSSARY.html)
    have [](GLOSSARY.html) a [](GLOSSARY.html) code [](GLOSSARY.html) smell [](GLOSSARY.html)
    that [](GLOSSARY.html) needs [](GLOSSARY.html) refactoring. There [](GLOSSARY.html)
    are [](GLOSSARY.html) however [](GLOSSARY.html) exceptions [](GLOSSARY.html) to
    [](GLOSSARY.html) this [](GLOSSARY.html) rule [7]. For [](GLOSSARY.html) example,
    suppose your [](GLOSSARY.html) model [](GLOSSARY.html) is [](GLOSSARY.html) representing
    [](GLOSSARY.html) the [](GLOSSARY.html) state [](GLOSSARY.html) of [](GLOSSARY.html)
    a [](GLOSSARY.html) drawing [](GLOSSARY.html) program. The [](GLOSSARY.html) shapes
    that [](GLOSSARY.html) are [](GLOSSARY.html) inserted [](GLOSSARY.html) in [](GLOSSARY.html)
    the [](GLOSSARY.html) model [](GLOSSARY.html) are [](GLOSSARY.html) actual [](GLOSSARY.html)
    Shape [](GLOSSARY.html) objects [](GLOSSARY.html) that [](GLOSSARY.html) are graphical
    [](GLOSSARY.html) in [](GLOSSARY.html) nature, and [](GLOSSARY.html) it [](GLOSSARY.html)
    would [](GLOSSARY.html) make [](GLOSSARY.html) sense [](GLOSSARY.html) to [](GLOSSARY.html)
    assign [](GLOSSARY.html) to [](GLOSSARY.html) these objects [](GLOSSARY.html)
    the [](GLOSSARY.html) responsibility [](GLOSSARY.html) of [](GLOSSARY.html) drawing
    [](GLOSSARY.html) themselves [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html)
    view. This [](GLOSSARY.html) is practical, but [](GLOSSARY.html) it [](GLOSSARY.html)
    can [](GLOSSARY.html) backfire: it [](GLOSSARY.html) requires [](GLOSSARY.html)
    the [](GLOSSARY.html) objects [](GLOSSARY.html) to [](GLOSSARY.html) know [](GLOSSARY.html)
    about the [](GLOSSARY.html) specific [](GLOSSARY.html) view''s [](GLOSSARY.html)
    details [](GLOSSARY.html) about [](GLOSSARY.html) how [](GLOSSARY.html) to [](GLOSSARY.html)
    draw [](GLOSSARY.html) itself [](GLOSSARY.html) onto [](GLOSSARY.html) it, meaning
    that [](GLOSSARY.html) a [](GLOSSARY.html) different [](GLOSSARY.html) view [](GLOSSARY.html)
    might [](GLOSSARY.html) not [](GLOSSARY.html) be [](GLOSSARY.html) compatible.
    Assigning representation [](GLOSSARY.html) responsibilities [](GLOSSARY.html)
    to [](GLOSSARY.html) model [](GLOSSARY.html) objects [](GLOSSARY.html) is [](GLOSSARY.html)
    a [](GLOSSARY.html) rare [](GLOSSARY.html) occurrence that [](GLOSSARY.html) can
    [](GLOSSARY.html) always [](GLOSSARY.html) be [](GLOSSARY.html) worked [](GLOSSARY.html)
    around, for [](GLOSSARY.html) example [](GLOSSARY.html) separating [](GLOSSARY.html)
    the mathematical [](GLOSSARY.html) description [](GLOSSARY.html) of [](GLOSSARY.html)
    the [](GLOSSARY.html) Shape (e.g. the [](GLOSSARY.html) corners [](GLOSSARY.html)
    of [](GLOSSARY.html) a rectangle) from [](GLOSSARY.html) the [](GLOSSARY.html)
    drawing [](GLOSSARY.html) logic (e.g. the [](GLOSSARY.html) actual [](GLOSSARY.html)
    graphic [](GLOSSARY.html) calls [](GLOSSARY.html) that draw [](GLOSSARY.html)
    the [](GLOSSARY.html) rectangle [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html)
    screen) and [](GLOSSARY.html) move [](GLOSSARY.html) this [](GLOSSARY.html) drawing
    [](GLOSSARY.html) logic [](GLOSSARY.html) in [](GLOSSARY.html) a Renderer [](GLOSSARY.html)
    class.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您应该能够独立测试或甚至使用模型，而不依赖于控制器和视图。实际上，模型应该能够在没有任何控制器或视图的情况下工作。这是一个完全独立的层，没有任何依赖于
    GUI 表示、小部件或应用更改的策略。如果不是这种情况，那么您有需要重构的代码异味。然而，这个规则也有例外情况。例如，假设您的模型代表绘图程序的状态。插入模型的形状是实际的图形形状对象，它们是图形化的，将责任分配给这些对象在视图上绘制自己是有意义的。这是实用的，但可能会适得其反：它要求对象了解如何在特定视图上绘制自己的细节，这意味着不同的视图可能不兼容。将表示责任分配给模型对象是一种罕见的情况，总是可以解决，例如将形状的数学描述（例如矩形的角）与绘图逻辑（例如在屏幕上绘制矩形的实际图形调用）分开，并将这种绘图逻辑移动到一个渲染器类中。
- en: A [](GLOSSARY.html) view [](GLOSSARY.html) that [](GLOSSARY.html) acts [](GLOSSARY.html)
    on [](GLOSSARY.html) a [](GLOSSARY.html) widget [](GLOSSARY.html) knowing [](GLOSSARY.html)
    nothing [](GLOSSARY.html) about [](GLOSSARY.html) the [](GLOSSARY.html) model.
    View “adapter”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[视图适配器](GLOSSARY.html)，在不了解模型的情况下对小部件进行操作。
- en: 'Mock [](GLOSSARY.html) view: it [](GLOSSARY.html) attaches [](GLOSSARY.html)
    to [](GLOSSARY.html) the [](GLOSSARY.html) model [](GLOSSARY.html) like [](GLOSSARY.html)
    a [](GLOSSARY.html) normal [](GLOSSARY.html) view, but [](GLOSSARY.html) has [](GLOSSARY.html)
    no [](GLOSSARY.html) GUI and [](GLOSSARY.html) can [](GLOSSARY.html) be [](GLOSSARY.html)
    probed. Fixture [](GLOSSARY.html) model: a [](GLOSSARY.html) model [](GLOSSARY.html)
    with [](GLOSSARY.html) well [](GLOSSARY.html) defined, well [](GLOSSARY.html)
    known [](GLOSSARY.html) data [](GLOSSARY.html) that [](GLOSSARY.html) can [](GLOSSARY.html)
    be [](GLOSSARY.html) attached to [](GLOSSARY.html) the [](GLOSSARY.html) view.
    The [](GLOSSARY.html) view [](GLOSSARY.html) should [](GLOSSARY.html) draw [](GLOSSARY.html)
    exactly [](GLOSSARY.html) what [](GLOSSARY.html) we [](GLOSSARY.html) know [](GLOSSARY.html)
    from [](GLOSSARY.html) the [](GLOSSARY.html) fixture [](GLOSSARY.html) model.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟视图：它像普通视图一样附加到模型，但没有GUI，可以被探测。装置模型：具有定义良好、已知数据的模型，可以附加到视图上。视图应该准确绘制我们从装置模型中知道的东西。
- en: Microsoft [](GLOSSARY.html) Visual [](GLOSSARY.html) Testing Sending [](GLOSSARY.html)
    events [](GLOSSARY.html) with [](GLOSSARY.html) xtest, or [](GLOSSARY.html) with
    [](GLOSSARY.html) the [](GLOSSARY.html) widget [](GLOSSARY.html) level [](GLOSSARY.html)
    interface. Sporadics [](GLOSSARY.html) due [](GLOSSARY.html) to [](GLOSSARY.html)
    change [](GLOSSARY.html) in [](GLOSSARY.html) layout, running [](GLOSSARY.html)
    the [](GLOSSARY.html) screensaver.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft[视觉测试发送](GLOSSARY.html)事件，使用xtest，或使用小部件级接口。由于布局变化而不定期出现的问题，运行屏幕保护程序。
- en: asynchronous [](GLOSSARY.html) tests [](GLOSSARY.html) tend [](GLOSSARY.html)
    to [](GLOSSARY.html) be [](GLOSSARY.html) slow (you [](GLOSSARY.html) need [](GLOSSARY.html)
    to [](GLOSSARY.html) perform [](GLOSSARY.html) an [](GLOSSARY.html) action, then
    wait [](GLOSSARY.html) for [](GLOSSARY.html) the [](GLOSSARY.html) result [](GLOSSARY.html)
    that [](GLOSSARY.html) may [](GLOSSARY.html) come [](GLOSSARY.html) and [](GLOSSARY.html)
    sporadically [](GLOSSARY.html) broken, because of [](GLOSSARY.html) race [](GLOSSARY.html)
    conditions. Favor [](GLOSSARY.html) synchronous [](GLOSSARY.html) testing, restrict
    [](GLOSSARY.html) asynchronous.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 异步测试往往很慢（您需要执行一个动作，然后等待可能会出现的结果，而且由于竞争条件的存在，结果可能会不定期地中断）。偏爱同步测试，限制异步。
- en: Test [](GLOSSARY.html) of [](GLOSSARY.html) components [](GLOSSARY.html) that
    [](GLOSSARY.html) are [](GLOSSARY.html) hard [](GLOSSARY.html) to [](GLOSSARY.html)
    test [](GLOSSARY.html) should [](GLOSSARY.html) be [](GLOSSARY.html) minimal,
    and [](GLOSSARY.html) the [](GLOSSARY.html) behavior of [](GLOSSARY.html) these
    [](GLOSSARY.html) components [](GLOSSARY.html) should [](GLOSSARY.html) be [](GLOSSARY.html)
    minimal [](GLOSSARY.html) as [](GLOSSARY.html) well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 难以测试的组件的测试应该是最小的，这些组件的行为也应该是最小的。
- en: You [](GLOSSARY.html) can [](GLOSSARY.html) perform [](GLOSSARY.html) tests
    [](GLOSSARY.html) of [](GLOSSARY.html) graphical [](GLOSSARY.html) components
    [](GLOSSARY.html) by [](GLOSSARY.html) pushing [](GLOSSARY.html) events [](GLOSSARY.html)
    into [](GLOSSARY.html) the GUI [](GLOSSARY.html) toolkit [](GLOSSARY.html) event
    [](GLOSSARY.html) queue, but [](GLOSSARY.html) again, they [](GLOSSARY.html) tend
    [](GLOSSARY.html) to [](GLOSSARY.html) be [](GLOSSARY.html) brittle [](GLOSSARY.html)
    and [](GLOSSARY.html) asynchronous.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将事件推送到 GUI 工具包事件队列来测试图形组件，但它们往往很脆弱和异步。
- en: Watir, WatiN, Selenium
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Watir, WatiN, Selenium
- en: Event Driven programming
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动编程
- en: Interaction with the event loop
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与事件循环的交互
- en: 'Until [](GLOSSARY.html) now, very [](GLOSSARY.html) limited [](GLOSSARY.html)
    mention [](GLOSSARY.html) was [](GLOSSARY.html) made [](GLOSSARY.html) about [](GLOSSARY.html)
    the [](GLOSSARY.html) event [](GLOSSARY.html) dispatch [](GLOSSARY.html) mechanism
    and [](GLOSSARY.html) the [](GLOSSARY.html) event [](GLOSSARY.html) loop: we [](GLOSSARY.html)
    remained [](GLOSSARY.html) oblivious [](GLOSSARY.html) of [](GLOSSARY.html) how
    [](GLOSSARY.html) UI [](GLOSSARY.html) events [](GLOSSARY.html) were [](GLOSSARY.html)
    delivered [](GLOSSARY.html) to [](GLOSSARY.html) the View/Controller. In [](GLOSSARY.html)
    the [](GLOSSARY.html) following [](GLOSSARY.html) pages [](GLOSSARY.html) we [](GLOSSARY.html)
    will [](GLOSSARY.html) examine [](GLOSSARY.html) how [](GLOSSARY.html) events
    [](GLOSSARY.html) are [](GLOSSARY.html) dispatched and [](GLOSSARY.html) how [](GLOSSARY.html)
    crucial [](GLOSSARY.html) is [](GLOSSARY.html) a [](GLOSSARY.html) proper [](GLOSSARY.html)
    coexistence [](GLOSSARY.html) between [](GLOSSARY.html) the [](GLOSSARY.html)
    dispatch [](GLOSSARY.html) mechanism [](GLOSSARY.html) and [](GLOSSARY.html) MVC.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，关于事件分发机制和事件循环的提及非常有限：我们对 UI 事件如何传递到视图/控制器一直一无所知。在接下来的页面中，我们将研究事件是如何分发的，以及分发机制与
    MVC 之间的正确协同作用有多重要。
- en: 'In [](GLOSSARY.html) the [](GLOSSARY.html) most [](GLOSSARY.html) simple [](GLOSSARY.html)
    terms, an [](GLOSSARY.html) event-driven [](GLOSSARY.html) UI [](GLOSSARY.html)
    program [](GLOSSARY.html) is [](GLOSSARY.html) built [](GLOSSARY.html) on [](GLOSSARY.html)
    top [](GLOSSARY.html) of [](GLOSSARY.html) an *event loop*. This [](GLOSSARY.html)
    infinite [](GLOSSARY.html) loop [](GLOSSARY.html) generally [](GLOSSARY.html)
    performs [](GLOSSARY.html) these [](GLOSSARY.html) operations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用最简单的术语来说，基于事件驱动的 UI 程序是建立在事件循环之上的。这个无限循环通常执行以下操作：
- en: awaits [](GLOSSARY.html) for [](GLOSSARY.html) low [](GLOSSARY.html) level [](GLOSSARY.html)
    events, like [](GLOSSARY.html) a [](GLOSSARY.html) mouse [](GLOSSARY.html) click,
    a [](GLOSSARY.html) key [](GLOSSARY.html) press, or [](GLOSSARY.html) a [](GLOSSARY.html)
    request [](GLOSSARY.html) to [](GLOSSARY.html) show [](GLOSSARY.html) from [](GLOSSARY.html)
    the [](GLOSSARY.html) windowing [](GLOSSARY.html) system.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待低级事件，比如鼠标点击、按键按下，或者来自窗口系统的显示请求。
- en: puts [](GLOSSARY.html) these [](GLOSSARY.html) events [](GLOSSARY.html) in [](GLOSSARY.html)
    a [](GLOSSARY.html) queue
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些事件放入队列中
- en: fully [](GLOSSARY.html) consumes [](GLOSSARY.html) the [](GLOSSARY.html) queue
    [](GLOSSARY.html) and [](GLOSSARY.html) dispatches [](GLOSSARY.html) the [](GLOSSARY.html)
    events [](GLOSSARY.html) to [](GLOSSARY.html) the [](GLOSSARY.html) appropriate
    handler (e.g. a [](GLOSSARY.html) method [](GLOSSARY.html) on [](GLOSSARY.html)
    the [](GLOSSARY.html) widget [](GLOSSARY.html) currently [](GLOSSARY.html) in
    [](GLOSSARY.html) focus). In [](GLOSSARY.html) this [](GLOSSARY.html) phase [](GLOSSARY.html)
    the [](GLOSSARY.html) thread [](GLOSSARY.html) will [](GLOSSARY.html) traverse,
    among [](GLOSSARY.html) other [](GLOSSARY.html) things, your [](GLOSSARY.html)
    MVC.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全[](GLOSSARY.html)消耗[](GLOSSARY.html)队列，并将[](GLOSSARY.html)事件分派给适当的处理程序（例如，当前焦点在[](GLOSSARY.html)小部件上的方法）。在这个阶段，线程将遍历，除其他事项外，您的MVC。
- en: Return [](GLOSSARY.html) to [](GLOSSARY.html) 1.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回1。
- en: This [](GLOSSARY.html) loop [](GLOSSARY.html) is [](GLOSSARY.html) executed
    [](GLOSSARY.html) by [](GLOSSARY.html) the [](GLOSSARY.html) main [](GLOSSARY.html)
    thread [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html) program, which
    [](GLOSSARY.html) then
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环由程序的主线程执行，然后
- en: executes [](GLOSSARY.html) during [](GLOSSARY.html) a [](GLOSSARY.html) single
    [](GLOSSARY.html) iteration [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html)
    event [](GLOSSARY.html) loop [](GLOSSARY.html) can [](GLOSSARY.html) be [](GLOSSARY.html)
    extremely [](GLOSSARY.html) complex, and [](GLOSSARY.html) traverse the [](GLOSSARY.html)
    complex [](GLOSSARY.html) notification [](GLOSSARY.html) network [](GLOSSARY.html)
    of [](GLOSSARY.html) your [](GLOSSARY.html) MVC [](GLOSSARY.html) application.
    The [](GLOSSARY.html) event [](GLOSSARY.html) handler [](GLOSSARY.html) is, for
    [](GLOSSARY.html) all [](GLOSSARY.html) purposes, atomic. When [](GLOSSARY.html)
    it [](GLOSSARY.html) starts, it [](GLOSSARY.html) is [](GLOSSARY.html) the [](GLOSSARY.html)
    only [](GLOSSARY.html) part [](GLOSSARY.html) of [](GLOSSARY.html) your [](GLOSSARY.html)
    code [](GLOSSARY.html) that [](GLOSSARY.html) will [](GLOSSARY.html) be [](GLOSSARY.html)
    executed, and [](GLOSSARY.html) will [](GLOSSARY.html) run [](GLOSSARY.html) to
    [](GLOSSARY.html) completion with [](GLOSSARY.html) no [](GLOSSARY.html) chance
    [](GLOSSARY.html) for [](GLOSSARY.html) interruption. It [](GLOSSARY.html) is
    [](GLOSSARY.html) therefore [](GLOSSARY.html) critical, for [](GLOSSARY.html)
    the [](GLOSSARY.html) application [](GLOSSARY.html) to [](GLOSSARY.html) be [](GLOSSARY.html)
    responsive [](GLOSSARY.html) to [](GLOSSARY.html) subsequent [](GLOSSARY.html)
    events [](GLOSSARY.html) waiting in [](GLOSSARY.html) the [](GLOSSARY.html) next
    [](GLOSSARY.html) iteration [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html)
    loop, that [](GLOSSARY.html) an [](GLOSSARY.html) event [](GLOSSARY.html) is [](GLOSSARY.html)
    fully [](GLOSSARY.html) handled [](GLOSSARY.html) within [](GLOSSARY.html) 200
    [](GLOSSARY.html) milliseconds.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件循环的单次迭代期间执行可能非常复杂，并遍历您的MVC应用程序的复杂通知网络。事件处理程序在所有情况下都是原子的。当它开始时，它是您代码中唯一会被执行的部分，并且将完全运行而不会被中断的机会。因此，对于应用程序能够响应等待在循环的下一个迭代中的后续事件至关重要，事件在200毫秒内完全处理。
- en: The [](GLOSSARY.html) consequence [](GLOSSARY.html) of [](GLOSSARY.html) this
    [](GLOSSARY.html) requirement [](GLOSSARY.html) is [](GLOSSARY.html) that [](GLOSSARY.html)
    anything [](GLOSSARY.html) in [](GLOSSARY.html) your [](GLOSSARY.html) MVC [](GLOSSARY.html)
    code [](GLOSSARY.html) that [](GLOSSARY.html) blocks [](GLOSSARY.html) the executing
    [](GLOSSARY.html) thread [](GLOSSARY.html) will [](GLOSSARY.html) prevent [](GLOSSARY.html)
    the [](GLOSSARY.html) event [](GLOSSARY.html) loop [](GLOSSARY.html) to [](GLOSSARY.html)
    roll, and [](GLOSSARY.html) will [](GLOSSARY.html) slow [](GLOSSARY.html) down
    [](GLOSSARY.html) or freeze [](GLOSSARY.html) your [](GLOSSARY.html) application,
    offering [](GLOSSARY.html) a [](GLOSSARY.html) suboptimal [](GLOSSARY.html) user
    [](GLOSSARY.html) experience.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这一要求的后果是，您的MVC代码中任何阻塞执行线程的内容都将阻止事件循环的运行，并将减慢或冻结您的应用程序，提供次优的用户体验。
- en: 'Examples [](GLOSSARY.html) of [](GLOSSARY.html) situations [](GLOSSARY.html)
    where [](GLOSSARY.html) the [](GLOSSARY.html) above [](GLOSSARY.html) may [](GLOSSARY.html)
    occur [](GLOSSARY.html) are [](GLOSSARY.html) the [](GLOSSARY.html) following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 发生上述情况的示例包括以下情况：
- en: initiating [](GLOSSARY.html) a [](GLOSSARY.html) network [](GLOSSARY.html) connection
    (which [](GLOSSARY.html) may [](GLOSSARY.html) block [](GLOSSARY.html) until [](GLOSSARY.html)
    a [](GLOSSARY.html) timeout [](GLOSSARY.html) is [](GLOSSARY.html) reached)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化网络连接（可能会阻塞直到达到超时）。
- en: waiting [](GLOSSARY.html) for [](GLOSSARY.html) a [](GLOSSARY.html) state [](GLOSSARY.html)
    machine [](GLOSSARY.html) to [](GLOSSARY.html) switch [](GLOSSARY.html) state
    (e.g. become [](GLOSSARY.html) idle)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待状态机切换状态（例如变为空闲）。
- en: a [](GLOSSARY.html) long [](GLOSSARY.html) running [](GLOSSARY.html) computation
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间运行的计算。
- en: reading [](GLOSSARY.html) or [](GLOSSARY.html) writing [](GLOSSARY.html) a [](GLOSSARY.html)
    large [](GLOSSARY.html) file [](GLOSSARY.html) either [](GLOSSARY.html) from [](GLOSSARY.html)
    the [](GLOSSARY.html) disk [](GLOSSARY.html) or [](GLOSSARY.html) from [](GLOSSARY.html)
    a [](GLOSSARY.html) network [](GLOSSARY.html) connection
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘或网络连接读取或写入大文件。
- en: running [](GLOSSARY.html) an [](GLOSSARY.html) external [](GLOSSARY.html) process
    [](GLOSSARY.html) that [](GLOSSARY.html) must [](GLOSSARY.html) be [](GLOSSARY.html)
    controlled, or [](GLOSSARY.html) whose [](GLOSSARY.html) stdout [](GLOSSARY.html)
    must [](GLOSSARY.html) be [](GLOSSARY.html) parsed.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行[](GLOSSARY.html)必须受控制的外部进程，或者必须解析其stdout的进程。
- en: You [](GLOSSARY.html) can [](GLOSSARY.html) see [](GLOSSARY.html) the [](GLOSSARY.html)
    event [](GLOSSARY.html) loop [](GLOSSARY.html) as [](GLOSSARY.html) a [](GLOSSARY.html)
    cooperative [](GLOSSARY.html) multitasking [](GLOSSARY.html) system. A [](GLOSSARY.html)
    cooperative [](GLOSSARY.html) multitasking system [](GLOSSARY.html) is [](GLOSSARY.html)
    a [](GLOSSARY.html) system [](GLOSSARY.html) allowing [](GLOSSARY.html) multiple
    [](GLOSSARY.html) tasks [](GLOSSARY.html) to [](GLOSSARY.html) run, provided [](GLOSSARY.html)
    that [](GLOSSARY.html) each [](GLOSSARY.html) task [](GLOSSARY.html) relinquish
    [](GLOSSARY.html) control when [](GLOSSARY.html) done, giving [](GLOSSARY.html)
    other [](GLOSSARY.html) tasks [](GLOSSARY.html) the [](GLOSSARY.html) chance [](GLOSSARY.html)
    to [](GLOSSARY.html) run.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将事件循环视为协作式多任务系统。协作式多任务系统是一种允许多个任务运行的系统，只要每个任务在完成时放弃控制，让其他任务有机会运行。
- en: 'To [](GLOSSARY.html) keep [](GLOSSARY.html) interface [](GLOSSARY.html) responsiveness,
    you [](GLOSSARY.html) must [](GLOSSARY.html) create [](GLOSSARY.html) a [](GLOSSARY.html)
    secondary [](GLOSSARY.html) thread [](GLOSSARY.html) of [](GLOSSARY.html) execution
    in [](GLOSSARY.html) your [](GLOSSARY.html) program, when [](GLOSSARY.html) the
    [](GLOSSARY.html) event [](GLOSSARY.html) handler [](GLOSSARY.html) expects [](GLOSSARY.html)
    to [](GLOSSARY.html) wait. The [](GLOSSARY.html) main [](GLOSSARY.html) thread
    [](GLOSSARY.html) spawns the [](GLOSSARY.html) secondary [](GLOSSARY.html) thread.
    The [](GLOSSARY.html) secondary [](GLOSSARY.html) thread [](GLOSSARY.html) executes
    [](GLOSSARY.html) the [](GLOSSARY.html) long [](GLOSSARY.html) running task, while
    [](GLOSSARY.html) the [](GLOSSARY.html) main [](GLOSSARY.html) thread [](GLOSSARY.html)
    can [](GLOSSARY.html) return [](GLOSSARY.html) to [](GLOSSARY.html) the [](GLOSSARY.html)
    event [](GLOSSARY.html) queue [](GLOSSARY.html) and [](GLOSSARY.html) keep [](GLOSSARY.html)
    processing events. This [](GLOSSARY.html) solution [](GLOSSARY.html) now [](GLOSSARY.html)
    faces [](GLOSSARY.html) the [](GLOSSARY.html) following [](GLOSSARY.html) difficulties:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为保持界面的响应性，当事件处理程序需要等待时，必须在程序中创建一个辅助执行线程。主线程生成辅助线程。辅助线程执行长时间运行的任务，而主线程可以返回到事件队列并继续处理事件。这种解决方案现在面临以下困难：
- en: the [](GLOSSARY.html) secondary [](GLOSSARY.html) thread [](GLOSSARY.html) must
    [](GLOSSARY.html) notify [](GLOSSARY.html) its [](GLOSSARY.html) completion [](GLOSSARY.html)
    to [](GLOSSARY.html) the [](GLOSSARY.html) main [](GLOSSARY.html) thread, either
    [](GLOSSARY.html) successfully or [](GLOSSARY.html) with [](GLOSSARY.html) an
    [](GLOSSARY.html) error [](GLOSSARY.html) condition.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助线程必须向主线程通知其完成情况，无论是成功还是出现错误条件。
- en: the [](GLOSSARY.html) secondary [](GLOSSARY.html) thread [](GLOSSARY.html) must
    [](GLOSSARY.html) interact [](GLOSSARY.html) nicely [](GLOSSARY.html) with [](GLOSSARY.html)
    the [](GLOSSARY.html) main [](GLOSSARY.html) thread. Both [](GLOSSARY.html) threads
    [](GLOSSARY.html) could [](GLOSSARY.html) access the [](GLOSSARY.html) same [](GLOSSARY.html)
    shared [](GLOSSARY.html) state, for [](GLOSSARY.html) which [](GLOSSARY.html)
    synchronization [](GLOSSARY.html) is [](GLOSSARY.html) needed
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助线程必须与主线程良好交互。两个线程可以访问相同的共享状态，因此需要同步。
- en: as [](GLOSSARY.html) a [](GLOSSARY.html) corollary [](GLOSSARY.html) of [](GLOSSARY.html)
    the [](GLOSSARY.html) above, the [](GLOSSARY.html) secondary [](GLOSSARY.html)
    thread [](GLOSSARY.html) should [](GLOSSARY.html) not [](GLOSSARY.html) call [](GLOSSARY.html)
    the [](GLOSSARY.html) event [](GLOSSARY.html) loop [](GLOSSARY.html) or any [](GLOSSARY.html)
    part [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html) code [](GLOSSARY.html)
    the [](GLOSSARY.html) main [](GLOSSARY.html) thread [](GLOSSARY.html) is [](GLOSSARY.html)
    fundamentally [](GLOSSARY.html) responsible [](GLOSSARY.html) for (such [](GLOSSARY.html)
    as [](GLOSSARY.html) UI [](GLOSSARY.html) handling) because [](GLOSSARY.html)
    it [](GLOSSARY.html) is [](GLOSSARY.html) probably [](GLOSSARY.html) not [](GLOSSARY.html)
    designed [](GLOSSARY.html) to [](GLOSSARY.html) be [](GLOSSARY.html) thread [](GLOSSARY.html)
    safe.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为上述的推论，次要线程不应调用事件循环或主线程基本负责的任何代码（例如UI处理），因为它可能不是线程安全的设计。
- en: the [](GLOSSARY.html) secondary [](GLOSSARY.html) thread [](GLOSSARY.html) could
    [](GLOSSARY.html) potentially [](GLOSSARY.html) trigger [](GLOSSARY.html) notifications
    [](GLOSSARY.html) through [](GLOSSARY.html) MVC (for [](GLOSSARY.html) example,
    by modifying [](GLOSSARY.html) a [](GLOSSARY.html) model [](GLOSSARY.html) state).
    The [](GLOSSARY.html) notification [](GLOSSARY.html) will [](GLOSSARY.html) propagate
    [](GLOSSARY.html) to [](GLOSSARY.html) View [](GLOSSARY.html) and [](GLOSSARY.html)
    Controller [](GLOSSARY.html) classes, which [](GLOSSARY.html) may [](GLOSSARY.html)
    involve [](GLOSSARY.html) UI, which [](GLOSSARY.html) again [](GLOSSARY.html)
    is [](GLOSSARY.html) not [](GLOSSARY.html) designed [](GLOSSARY.html) for [](GLOSSARY.html)
    being [](GLOSSARY.html) used [](GLOSSARY.html) by [](GLOSSARY.html) a [](GLOSSARY.html)
    secondary [](GLOSSARY.html) thread.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要线程可能会通过MVC（例如，通过修改模型状态）触发通知。通知将传播到View和Controller类，这可能涉及UI，而UI又不是为次要线程设计的。
- en: As [](GLOSSARY.html) you [](GLOSSARY.html) can [](GLOSSARY.html) see, handling
    [](GLOSSARY.html) multithreading [](GLOSSARY.html) in [](GLOSSARY.html) an [](GLOSSARY.html)
    event [](GLOSSARY.html) driven [](GLOSSARY.html) system [](GLOSSARY.html) is [](GLOSSARY.html)
    not [](GLOSSARY.html) trivial.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[词汇表](https://wiki.example.org/glossary.html)所示，处理事件驱动系统中的多线程并不是一件简单的事情。
- en: An [](GLOSSARY.html) alternative [](GLOSSARY.html) approach [](GLOSSARY.html)
    to [](GLOSSARY.html) what [](GLOSSARY.html) presented [](GLOSSARY.html) above
    [](GLOSSARY.html) is [](GLOSSARY.html) suspended [](GLOSSARY.html) execution.
    The [](GLOSSARY.html) concept [](GLOSSARY.html) requires [](GLOSSARY.html) the
    [](GLOSSARY.html) language [](GLOSSARY.html) to [](GLOSSARY.html) support [](GLOSSARY.html)
    suspending [](GLOSSARY.html) a [](GLOSSARY.html) routine [](GLOSSARY.html) execution
    [](GLOSSARY.html) and relinquish [](GLOSSARY.html) control [](GLOSSARY.html) back
    [](GLOSSARY.html) to [](GLOSSARY.html) the [](GLOSSARY.html) caller. When [](GLOSSARY.html)
    the [](GLOSSARY.html) suspended [](GLOSSARY.html) routine [](GLOSSARY.html) is
    [](GLOSSARY.html) reinstated, it [](GLOSSARY.html) will [](GLOSSARY.html) continue
    [](GLOSSARY.html) from [](GLOSSARY.html) where [](GLOSSARY.html) it [](GLOSSARY.html)
    left.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述所述的替代方法是挂起执行。该概念要求语言支持挂起例程的执行并将控制权交还给调用者。当恢复挂起的例程时，它将从离开的地方继续执行。
- en: Suspended [](GLOSSARY.html) execution [](GLOSSARY.html) allows [](GLOSSARY.html)
    a [](GLOSSARY.html) handler [](GLOSSARY.html) to [](GLOSSARY.html) relinquish
    [](GLOSSARY.html) control [](GLOSSARY.html) back [](GLOSSARY.html) to [](GLOSSARY.html)
    the [](GLOSSARY.html) event [](GLOSSARY.html) loop, allow [](GLOSSARY.html) for
    [](GLOSSARY.html) other [](GLOSSARY.html) events [](GLOSSARY.html) to [](GLOSSARY.html)
    be [](GLOSSARY.html) processed, and [](GLOSSARY.html) restart [](GLOSSARY.html)
    where [](GLOSSARY.html) it [](GLOSSARY.html) was. This [](GLOSSARY.html) approach
    [](GLOSSARY.html) has [](GLOSSARY.html) the [](GLOSSARY.html) following drawbacks
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停执行允许处理程序将控制权交还给事件循环，允许其他事件被处理，并在原地重新启动。这种方法有以下缺点
- en: it [](GLOSSARY.html) requires [](GLOSSARY.html) language [](GLOSSARY.html) support
    (e.g. yield [](GLOSSARY.html) keyword [](GLOSSARY.html) in [](GLOSSARY.html) python)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要语言支持（例如python中的yield关键字）。
- en: event [](GLOSSARY.html) handlers [](GLOSSARY.html) are [](GLOSSARY.html) no
    [](GLOSSARY.html) longer [](GLOSSARY.html) atomic. Processing [](GLOSSARY.html)
    other [](GLOSSARY.html) events [](GLOSSARY.html) might [](GLOSSARY.html) imply
    [](GLOSSARY.html) that [](GLOSSARY.html) the [](GLOSSARY.html) restarting handler
    [](GLOSSARY.html) is [](GLOSSARY.html) now [](GLOSSARY.html) handling [](GLOSSARY.html)
    a [](GLOSSARY.html) state [](GLOSSARY.html) that [](GLOSSARY.html) may [](GLOSSARY.html)
    no [](GLOSSARY.html) longer [](GLOSSARY.html) be [](GLOSSARY.html) consistent.
    A [](GLOSSARY.html) point [](GLOSSARY.html) of [](GLOSSARY.html) yield [](GLOSSARY.html)
    can [](GLOSSARY.html) be [](GLOSSARY.html) seen [](GLOSSARY.html) as a [](GLOSSARY.html)
    point [](GLOSSARY.html) where [](GLOSSARY.html) any [](GLOSSARY.html) code [](GLOSSARY.html)
    can [](GLOSSARY.html) be [](GLOSSARY.html) arbitrarily [](GLOSSARY.html) executed.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理程序[](GLOSSARY.html)不再是原子的。处理其他事件可能意味着重新启动处理程序现在正在处理可能不再一致的状态。可以将yield点视为任何代码可以任意执行的点。
- en: Does [](GLOSSARY.html) not [](GLOSSARY.html) solve [](GLOSSARY.html) for [](GLOSSARY.html)
    blocking [](GLOSSARY.html) calls, but [](GLOSSARY.html) may [](GLOSSARY.html)
    allow [](GLOSSARY.html) for [](GLOSSARY.html) event [](GLOSSARY.html) processing
    [](GLOSSARY.html) if [](GLOSSARY.html) the [](GLOSSARY.html) suspendable [](GLOSSARY.html)
    task can [](GLOSSARY.html) be [](GLOSSARY.html) broken [](GLOSSARY.html) down
    [](GLOSSARY.html) into [](GLOSSARY.html) chunks, where [](GLOSSARY.html) one [](GLOSSARY.html)
    can [](GLOSSARY.html) periodically [](GLOSSARY.html) relinquish [](GLOSSARY.html)
    control (e.g. a [](GLOSSARY.html) loop).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能解决阻塞调用，但如果可暂停任务可以分解成块，其中一个可以定期放弃控制（例如循环），则可能允许事件处理。
- en: This [](GLOSSARY.html) approach [](GLOSSARY.html) is [](GLOSSARY.html) equivalent
    [](GLOSSARY.html) to [](GLOSSARY.html) calling [](GLOSSARY.html) the [](GLOSSARY.html)
    processEvents [](GLOSSARY.html) manually [](GLOSSARY.html) at [](GLOSSARY.html)
    the [](GLOSSARY.html) point [](GLOSSARY.html) of [](GLOSSARY.html) yield.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当于在yield点手动调用processEvents。
- en: For [](GLOSSARY.html) the [](GLOSSARY.html) blocking [](GLOSSARY.html) calls,
    the [](GLOSSARY.html) ideal [](GLOSSARY.html) solution [](GLOSSARY.html) would
    [](GLOSSARY.html) be [](GLOSSARY.html) to [](GLOSSARY.html) have [](GLOSSARY.html)
    a [](GLOSSARY.html) routine [](GLOSSARY.html) that [](GLOSSARY.html) acts [](GLOSSARY.html)
    as [](GLOSSARY.html) non-blocking and [](GLOSSARY.html) notifies [](GLOSSARY.html)
    back [](GLOSSARY.html) when [](GLOSSARY.html) completed. This [](GLOSSARY.html)
    is [](GLOSSARY.html) the [](GLOSSARY.html) case [](GLOSSARY.html) of [](GLOSSARY.html)
    a [](GLOSSARY.html) callback, a [](GLOSSARY.html) routine [](GLOSSARY.html) that
    [](GLOSSARY.html) gets [](GLOSSARY.html) called when [](GLOSSARY.html) the [](GLOSSARY.html)
    secondary [](GLOSSARY.html) thread [](GLOSSARY.html) has [](GLOSSARY.html) completed
    [](GLOSSARY.html) its [](GLOSSARY.html) task. The [](GLOSSARY.html) most [](GLOSSARY.html)
    common [](GLOSSARY.html) problem [](GLOSSARY.html) of [](GLOSSARY.html) this [](GLOSSARY.html)
    approach [](GLOSSARY.html) is that [](GLOSSARY.html) the [](GLOSSARY.html) callback
    [](GLOSSARY.html) will [](GLOSSARY.html) be [](GLOSSARY.html) executed [](GLOSSARY.html)
    in [](GLOSSARY.html) the [](GLOSSARY.html) secondary [](GLOSSARY.html) thread
    [](GLOSSARY.html) as [](GLOSSARY.html) well, so [](GLOSSARY.html) in [](GLOSSARY.html)
    general [](GLOSSARY.html) it [](GLOSSARY.html) cannot [](GLOSSARY.html) perform
    any [](GLOSSARY.html) action [](GLOSSARY.html) that [](GLOSSARY.html) may [](GLOSSARY.html)
    conflict [](GLOSSARY.html) with [](GLOSSARY.html) the [](GLOSSARY.html) main [](GLOSSARY.html)
    thread. The [](GLOSSARY.html) recommended [](GLOSSARY.html) course [](GLOSSARY.html)
    of [](GLOSSARY.html) action [](GLOSSARY.html) is [](GLOSSARY.html) that the [](GLOSSARY.html)
    secondary [](GLOSSARY.html) thread, now [](GLOSSARY.html) running [](GLOSSARY.html)
    the [](GLOSSARY.html) callback, notifies [](GLOSSARY.html) the [](GLOSSARY.html)
    main [](GLOSSARY.html) thread [](GLOSSARY.html) through [](GLOSSARY.html) an [](GLOSSARY.html)
    event. Event [](GLOSSARY.html) queues [](GLOSSARY.html) implementations [](GLOSSARY.html)
    are [](GLOSSARY.html) generally [](GLOSSARY.html) aware [](GLOSSARY.html) of [](GLOSSARY.html)
    this [](GLOSSARY.html) need [](GLOSSARY.html) and [](GLOSSARY.html) are [](GLOSSARY.html)
    therefore [](GLOSSARY.html) thread [](GLOSSARY.html) safe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[GLOSSARY.html]阻塞[GLOSSARY.html]调用，理想的解决方案将是有一个充当非阻塞并在完成时通知的例程。这是回调的情况，一个在次要线程完成任务时被调用的例程。这种方法最常见的问题是回调也将在次要线程中执行，因此通常无法执行可能与主线程冲突的任何操作。建议的行动方向是，现在运行回调的次要线程通过事件通知主线程。事件队列实现通常意识到这种需求，因此是线程安全。
- en: '* * *'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: MVC [](GLOSSARY.html) was [](GLOSSARY.html) considered [](GLOSSARY.html) as
    [](GLOSSARY.html) an [](GLOSSARY.html) independent [](GLOSSARY.html) design [](GLOSSARY.html)
    approach [](GLOSSARY.html) without [](GLOSSARY.html) much [](GLOSSARY.html) consideration
    of [](GLOSSARY.html) the [](GLOSSARY.html) event [](GLOSSARY.html) system. Strictly
    [](GLOSSARY.html) speaking, MVC [](GLOSSARY.html) does [](GLOSSARY.html) not [](GLOSSARY.html)
    require [](GLOSSARY.html) an [](GLOSSARY.html) event [](GLOSSARY.html) loop, but
    [](GLOSSARY.html) its [](GLOSSARY.html) usefulness would [](GLOSSARY.html) be
    [](GLOSSARY.html) severely [](GLOSSARY.html) limited.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MVC被认为是一种独立的设计方法，没有太多考虑事件系统。严格来说，MVC不需要事件循环，但其有用性将受到严重限制。
- en: Explain [](GLOSSARY.html) how [](GLOSSARY.html) MVC [](GLOSSARY.html) naturally
    [](GLOSSARY.html) ends [](GLOSSARY.html) up [](GLOSSARY.html) with [](GLOSSARY.html)
    an [](GLOSSARY.html) event [](GLOSSARY.html) driven [](GLOSSARY.html) model. Explain
    [](GLOSSARY.html) the [](GLOSSARY.html) complexity [](GLOSSARY.html) of [](GLOSSARY.html)
    debugging (e.g. backtraces [](GLOSSARY.html) all [](GLOSSARY.html) coming [](GLOSSARY.html)
    from [](GLOSSARY.html) the [](GLOSSARY.html) event loop)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 解释[MVC](GLOSSARY.html)如何自然地以事件驱动模型结束。解释调试的复杂性（例如，所有回溯都来自事件循环）
- en: Behavior [](GLOSSARY.html) is [](GLOSSARY.html) no [](GLOSSARY.html) longer
    [](GLOSSARY.html) characterized [](GLOSSARY.html) by [](GLOSSARY.html) code [](GLOSSARY.html)
    alone. Emergent [](GLOSSARY.html) behavior [](GLOSSARY.html) arises [](GLOSSARY.html)
    from the [](GLOSSARY.html) potentially [](GLOSSARY.html) asynchronous [](GLOSSARY.html)
    interaction [](GLOSSARY.html) among [](GLOSSARY.html) objects, communicating [](GLOSSARY.html)
    through events. The [](GLOSSARY.html) communication [](GLOSSARY.html) network
    [](GLOSSARY.html) being [](GLOSSARY.html) mutable. This [](GLOSSARY.html) results
    [](GLOSSARY.html) in [](GLOSSARY.html) extremely complex, hard [](GLOSSARY.html)
    to [](GLOSSARY.html) understand, hard [](GLOSSARY.html) to [](GLOSSARY.html) debug
    [](GLOSSARY.html) designs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 行为不再仅仅由代码表征。新兴行为源于对象之间潜在的异步交互，通过事件进行通信。通信网络是可变的。这导致设计变得极其复杂，难以理解，难以调试。
- en: 'solve [](GLOSSARY.html) this? One [](GLOSSARY.html) solution [](GLOSSARY.html)
    is [](GLOSSARY.html) to [](GLOSSARY.html) spawn [](GLOSSARY.html) another [](GLOSSARY.html)
    thread, and [](GLOSSARY.html) let [](GLOSSARY.html) this [](GLOSSARY.html) other
    [](GLOSSARY.html) thread do [](GLOSSARY.html) the [](GLOSSARY.html) heavy, long
    [](GLOSSARY.html) running [](GLOSSARY.html) work, while [](GLOSSARY.html) the
    [](GLOSSARY.html) main [](GLOSSARY.html) thread [](GLOSSARY.html) goes [](GLOSSARY.html)
    back [](GLOSSARY.html) to [](GLOSSARY.html) the [](GLOSSARY.html) event loop [](GLOSSARY.html)
    and [](GLOSSARY.html) keeps [](GLOSSARY.html) processing [](GLOSSARY.html) events.
    But [](GLOSSARY.html) multithread [](GLOSSARY.html) programming [](GLOSSARY.html)
    is [](GLOSSARY.html) hard, and event [](GLOSSARY.html) driven [](GLOSSARY.html)
    multithread [](GLOSSARY.html) programming [](GLOSSARY.html) even [](GLOSSARY.html)
    more [](GLOSSARY.html) so. So [](GLOSSARY.html) ideally, you [](GLOSSARY.html)
    would [](GLOSSARY.html) prefer [](GLOSSARY.html) to [](GLOSSARY.html) have [](GLOSSARY.html)
    a [](GLOSSARY.html) single [](GLOSSARY.html) thread, but [](GLOSSARY.html) when
    [](GLOSSARY.html) it [](GLOSSARY.html) encounters something [](GLOSSARY.html)
    that [](GLOSSARY.html) is [](GLOSSARY.html) long [](GLOSSARY.html) running, you
    [](GLOSSARY.html) use [](GLOSSARY.html) a [](GLOSSARY.html) trick [](GLOSSARY.html)
    to [](GLOSSARY.html) suspend [](GLOSSARY.html) the [](GLOSSARY.html) execution
    [](GLOSSARY.html) point, and [](GLOSSARY.html) resume [](GLOSSARY.html) it [](GLOSSARY.html)
    later, when [](GLOSSARY.html) the [](GLOSSARY.html) long [](GLOSSARY.html) running
    [](GLOSSARY.html) task [](GLOSSARY.html) is [](GLOSSARY.html) completed, or [](GLOSSARY.html)
    maybe [](GLOSSARY.html) you [](GLOSSARY.html) want to [](GLOSSARY.html) do [](GLOSSARY.html)
    it [](GLOSSARY.html) in [](GLOSSARY.html) steps, each [](GLOSSARY.html) one [](GLOSSARY.html)
    short, but [](GLOSSARY.html) taken [](GLOSSARY.html) together [](GLOSSARY.html)
    they [](GLOSSARY.html) run [](GLOSSARY.html) for [](GLOSSARY.html) a [](GLOSSARY.html)
    long [](GLOSSARY.html) time. the [](GLOSSARY.html) yield [](GLOSSARY.html) keyword,
    and [](GLOSSARY.html) therefore [](GLOSSARY.html) generators, happen [](GLOSSARY.html)
    to [](GLOSSARY.html) provide [](GLOSSARY.html) this [](GLOSSARY.html) exact service:
    suspend [](GLOSSARY.html) something [](GLOSSARY.html) and [](GLOSSARY.html) resume
    [](GLOSSARY.html) it [](GLOSSARY.html) later [](GLOSSARY.html) from [](GLOSSARY.html)
    where [](GLOSSARY.html) you [](GLOSSARY.html) left [](GLOSSARY.html) it. When
    you [](GLOSSARY.html) reach [](GLOSSARY.html) the [](GLOSSARY.html) yield, the
    [](GLOSSARY.html) main [](GLOSSARY.html) thread [](GLOSSARY.html) can [](GLOSSARY.html)
    now [](GLOSSARY.html) go [](GLOSSARY.html) back [](GLOSSARY.html) to [](GLOSSARY.html)
    the [](GLOSSARY.html) event [](GLOSSARY.html) loop, and keep [](GLOSSARY.html)
    processing [](GLOSSARY.html) events. Somehow, where [](GLOSSARY.html) the [](GLOSSARY.html)
    execution [](GLOSSARY.html) was [](GLOSSARY.html) suspended [](GLOSSARY.html)
    to [](GLOSSARY.html) wait [](GLOSSARY.html) for a [](GLOSSARY.html) long [](GLOSSARY.html)
    running [](GLOSSARY.html) thing [](GLOSSARY.html) there [](GLOSSARY.html) will
    [](GLOSSARY.html) be [](GLOSSARY.html) some [](GLOSSARY.html) magic [](GLOSSARY.html)
    so [](GLOSSARY.html) that [](GLOSSARY.html) when [](GLOSSARY.html) the [](GLOSSARY.html)
    long [](GLOSSARY.html) running thing [](GLOSSARY.html) is [](GLOSSARY.html) done,
    the [](GLOSSARY.html) thread [](GLOSSARY.html) will [](GLOSSARY.html) know [](GLOSSARY.html)
    about [](GLOSSARY.html) it [](GLOSSARY.html) and [](GLOSSARY.html) go [](GLOSSARY.html)
    back [](GLOSSARY.html) to [](GLOSSARY.html) where [](GLOSSARY.html) it [](GLOSSARY.html)
    was suspended. This [](GLOSSARY.html) can [](GLOSSARY.html) be [](GLOSSARY.html)
    achieved [](GLOSSARY.html) either [](GLOSSARY.html) by [](GLOSSARY.html) a [](GLOSSARY.html)
    secondary [](GLOSSARY.html) thread, or [](GLOSSARY.html) by [](GLOSSARY.html)
    the [](GLOSSARY.html) main thread [](GLOSSARY.html) itself: when [](GLOSSARY.html)
    it [](GLOSSARY.html) runs [](GLOSSARY.html) out [](GLOSSARY.html) of [](GLOSSARY.html)
    events [](GLOSSARY.html) to [](GLOSSARY.html) process, it [](GLOSSARY.html) works
    [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html) long running [](GLOSSARY.html)
    task, maybe [](GLOSSARY.html) to [](GLOSSARY.html) be [](GLOSSARY.html) suspended
    [](GLOSSARY.html) again [](GLOSSARY.html) a [](GLOSSARY.html) little [](GLOSSARY.html)
    later. What [](GLOSSARY.html) you [](GLOSSARY.html) see [](GLOSSARY.html) is [](GLOSSARY.html)
    what is [](GLOSSARY.html) known [](GLOSSARY.html) as [](GLOSSARY.html) collaborative
    (or [](GLOSSARY.html) cooperative) multitasking. The [](GLOSSARY.html) event [](GLOSSARY.html)
    loop [](GLOSSARY.html) is basically [](GLOSSARY.html) a "kernel", and [](GLOSSARY.html)
    yield [](GLOSSARY.html) points [](GLOSSARY.html) are [](GLOSSARY.html) equivalent
    [](GLOSSARY.html) to "system [](GLOSSARY.html) calls" into the "kernel". At [](GLOSSARY.html)
    this [](GLOSSARY.html) yield [](GLOSSARY.html) points, the [](GLOSSARY.html) control
    [](GLOSSARY.html) is [](GLOSSARY.html) returned [](GLOSSARY.html) to [](GLOSSARY.html)
    the [](GLOSSARY.html) kernel, which [](GLOSSARY.html) is [](GLOSSARY.html) now
    [](GLOSSARY.html) free [](GLOSSARY.html) to [](GLOSSARY.html) run [](GLOSSARY.html)
    something [](GLOSSARY.html) else, interleaving [](GLOSSARY.html) all [](GLOSSARY.html)
    the [](GLOSSARY.html) handling [](GLOSSARY.html) and keeping [](GLOSSARY.html)
    the [](GLOSSARY.html) event [](GLOSSARY.html) processing [](GLOSSARY.html) alive,
    instead [](GLOSSARY.html) of [](GLOSSARY.html) being [](GLOSSARY.html) stuck [](GLOSSARY.html)
    at [](GLOSSARY.html) one [](GLOSSARY.html) particular handler. Note [](GLOSSARY.html)
    that [](GLOSSARY.html) this [](GLOSSARY.html) mechanism [](GLOSSARY.html) requires
    [](GLOSSARY.html) collaboration: the [](GLOSSARY.html) individual handlers [](GLOSSARY.html)
    must [](GLOSSARY.html) yield [](GLOSSARY.html) to [](GLOSSARY.html) inform [](GLOSSARY.html)
    the "kernel" "I''m [](GLOSSARY.html) not [](GLOSSARY.html) done [](GLOSSARY.html)
    here [](GLOSSARY.html) yet, but [](GLOSSARY.html) give someone [](GLOSSARY.html)
    else [](GLOSSARY.html) a [](GLOSSARY.html) chance [](GLOSSARY.html) to [](GLOSSARY.html)
    keep [](GLOSSARY.html) going". This [](GLOSSARY.html) compares [](GLOSSARY.html)
    with [](GLOSSARY.html) preemptive multitasking [](GLOSSARY.html) where [](GLOSSARY.html)
    the [](GLOSSARY.html) kernel [](GLOSSARY.html) is [](GLOSSARY.html) the [](GLOSSARY.html)
    one [](GLOSSARY.html) saying: "that''s [](GLOSSARY.html) it, you [](GLOSSARY.html)
    had [](GLOSSARY.html) enough fun, let''s [](GLOSSARY.html) someone [](GLOSSARY.html)
    else [](GLOSSARY.html) go [](GLOSSARY.html) now", which [](GLOSSARY.html) is [](GLOSSARY.html)
    what [](GLOSSARY.html) modern [](GLOSSARY.html) real [](GLOSSARY.html) kernels
    [](GLOSSARY.html) do. So asyncio [](GLOSSARY.html) is [](GLOSSARY.html) a [](GLOSSARY.html)
    form [](GLOSSARY.html) of [](GLOSSARY.html) event [](GLOSSARY.html) loop [](GLOSSARY.html)
    and [](GLOSSARY.html) collaborative [](GLOSSARY.html) multitasking [](GLOSSARY.html)
    to [](GLOSSARY.html) allow [](GLOSSARY.html) event driven [](GLOSSARY.html) programming
    [](GLOSSARY.html) without [](GLOSSARY.html) either [](GLOSSARY.html) having [](GLOSSARY.html)
    an [](GLOSSARY.html) unresponsive [](GLOSSARY.html) application [](GLOSSARY.html)
    or [](GLOSSARY.html) having to [](GLOSSARY.html) deal [](GLOSSARY.html) with [](GLOSSARY.html)
    multiple [](GLOSSARY.html) threads, callbacks [](GLOSSARY.html) and [](GLOSSARY.html)
    all [](GLOSSARY.html) the [](GLOSSARY.html) horror [](GLOSSARY.html) that [](GLOSSARY.html)
    arises [](GLOSSARY.html) from [](GLOSSARY.html) it in [](GLOSSARY.html) an [](GLOSSARY.html)
    event [](GLOSSARY.html) driven [](GLOSSARY.html) environment.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题？一个解决方案是生成另一个线程，并让这个其他线程执行繁重、长时间运行的工作，而主线程则返回到事件循环并继续处理事件。但多线程编程很困难，而基于事件驱动的多线程编程更是如此。因此，理想情况下，你会更倾向于只有一个线程，但当它遇到长时间运行的任务时，你可以使用一个技巧来暂停执行点，并稍后恢复它，当长时间运行的任务完成时，或者也许你想分步进行，每一步都很短，但合在一起运行了很长时间。yield关键字，因此生成器，恰好提供了这种精确的服务：暂停某事并稍后从你离开的地方恢复它。当你达到yield时，主线程现在可以返回到事件循环，并继续处理事件。在某种程度上，当执行被暂停等待长时间运行的事物时，会有一些魔法，以便当长时间运行的事物完成时，线程会知道并返回到被暂停的地方。这可以通过一个辅助线程或主线程本身来实现：当它没有要处理的事件时，它会处理长时间运行的任务，也许稍后再次暂停一会。你看到的就是所谓的协作（或合作）多任务处理。事件循环基本上是一个“内核”，而yield点相当于对“内核”进行“系统调用”。在这些yield点，控制权被返回给内核，现在内核可以自由运行其他东西，交错处理所有处理并保持事件处理活动，而不是被困在一个特定的处理程序中。请注意，这种机制需要协作：各个处理程序必须让出控制权以通知“内核”“我还没有完成这里的工作，但让别人有机会继续”。这与抢占式多任务处理相比，后者是内核在说：“就这样了，你玩够了，让别人接着去吧”，这就是现代真实内核所做的。因此，asyncio是一种事件循环和协作多任务处理的形式，允许事件驱动的编程，而无需应用程序无响应或处理多个线程、回调和所有由此产生的恐怖在事件驱动环境中处理。
- en: Thrashing prevention
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免抖动
- en: 'To [](GLOSSARY.html) prevent [](GLOSSARY.html) trashing [](GLOSSARY.html) with
    [](GLOSSARY.html) many [](GLOSSARY.html) notifications, there [](GLOSSARY.html)
    are [](GLOSSARY.html) three [](GLOSSARY.html) strategies:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与许多通知一起出现抖动，有三种策略：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Validation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: Validation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: Who [](GLOSSARY.html) performs [](GLOSSARY.html) validation? View? Controller?
    Model? Consistency [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html)
    data [](GLOSSARY.html) inside [](GLOSSARY.html) the [](GLOSSARY.html) model? Depending
    [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html) application, the
    [](GLOSSARY.html) model [](GLOSSARY.html) can [](GLOSSARY.html) host [](GLOSSARY.html)
    invalid [](GLOSSARY.html) data (that [](GLOSSARY.html) is, invalid [](GLOSSARY.html)
    for [](GLOSSARY.html) the [](GLOSSARY.html) application)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 谁执行验证？视图？控制器？模型？模型内部数据的一致性？根据应用程序的不同，模型可以容纳无效数据（即对应用程序无效的数据）。
- en: Lapsed listener problem
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过期的监听器问题
- en: Lapsed Listener Problem
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过期的监听器问题
- en: A [](GLOSSARY.html) notification [](GLOSSARY.html) system [](GLOSSARY.html)
    introduces [](GLOSSARY.html) a [](GLOSSARY.html) potential [](GLOSSARY.html) for
    [](GLOSSARY.html) memory [](GLOSSARY.html) leaks [](GLOSSARY.html) known [](GLOSSARY.html)
    as "Lapsed [](GLOSSARY.html) listener [](GLOSSARY.html) problem". It [](GLOSSARY.html)
    occurs [](GLOSSARY.html) when [](GLOSSARY.html) a [](GLOSSARY.html) listener [](GLOSSARY.html)
    registers [](GLOSSARY.html) to [](GLOSSARY.html) a notifier, then [](GLOSSARY.html)
    goes [](GLOSSARY.html) out [](GLOSSARY.html) of [](GLOSSARY.html) scope [](GLOSSARY.html)
    without [](GLOSSARY.html) unsubscribing. The [](GLOSSARY.html) listener is [](GLOSSARY.html)
    never [](GLOSSARY.html) garbage [](GLOSSARY.html) collected [](GLOSSARY.html)
    due [](GLOSSARY.html) to [](GLOSSARY.html) the [](GLOSSARY.html) permanence [](GLOSSARY.html)
    of [](GLOSSARY.html) the [](GLOSSARY.html) notification connection. It [](GLOSSARY.html)
    is [](GLOSSARY.html) technically [](GLOSSARY.html) still [](GLOSSARY.html) receiving
    [](GLOSSARY.html) notifications, which [](GLOSSARY.html) may [](GLOSSARY.html)
    introduce additional [](GLOSSARY.html) problems [](GLOSSARY.html) if [](GLOSSARY.html)
    these [](GLOSSARY.html) notifications [](GLOSSARY.html) are [](GLOSSARY.html)
    expensive [](GLOSSARY.html) to [](GLOSSARY.html) honor. In [](GLOSSARY.html) languages
    [](GLOSSARY.html) without [](GLOSSARY.html) GC, if [](GLOSSARY.html) the [](GLOSSARY.html)
    listener [](GLOSSARY.html) is [](GLOSSARY.html) deleted, the [](GLOSSARY.html)
    notifier [](GLOSSARY.html) can [](GLOSSARY.html) now [](GLOSSARY.html) hold [](GLOSSARY.html)
    a reference [](GLOSSARY.html) to [](GLOSSARY.html) freed [](GLOSSARY.html) memory,
    potentially [](GLOSSARY.html) resulting [](GLOSSARY.html) in [](GLOSSARY.html)
    a [](GLOSSARY.html) crash.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通知系统引入了一个潜在的内存泄漏问题，称为“过期监听器问题”。当监听器注册到通知器，然后在不取消订阅的情况下超出范围时，就会发生这种情况。由于通知连接的永久性，监听器永远不会被垃圾回收。从技术上讲，它仍在接收通知，如果这些通知很昂贵，则可能会引入额外的问题。在没有垃圾回收的语言中，如果删除了监听器，则通知器现在可能会持有对已释放内存的引用，可能导致崩溃。
- en: There [](GLOSSARY.html) are [](GLOSSARY.html) various [](GLOSSARY.html) options
    [](GLOSSARY.html) to [](GLOSSARY.html) solve [](GLOSSARY.html) this [](GLOSSARY.html)
    problem. The [](GLOSSARY.html) first [](GLOSSARY.html) is [](GLOSSARY.html) to
    [](GLOSSARY.html) make [](GLOSSARY.html) sure the [](GLOSSARY.html) listener [](GLOSSARY.html)
    is [](GLOSSARY.html) correctly [](GLOSSARY.html) unregistered [](GLOSSARY.html)
    before [](GLOSSARY.html) going [](GLOSSARY.html) out [](GLOSSARY.html) of [](GLOSSARY.html)
    scope [](GLOSSARY.html) or [](GLOSSARY.html) released.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种选项来解决这个问题。第一种是确保监听器在超出范围或释放之前正确注销。
- en: The [](GLOSSARY.html) second [](GLOSSARY.html) option [](GLOSSARY.html) is [](GLOSSARY.html)
    to [](GLOSSARY.html) have [](GLOSSARY.html) a [](GLOSSARY.html) notification [](GLOSSARY.html)
    system [](GLOSSARY.html) using [](GLOSSARY.html) weak [](GLOSSARY.html) references.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用弱引用来建立通知系统。
- en: problem [](GLOSSARY.html) can [](GLOSSARY.html) exist [](GLOSSARY.html) also
    [](GLOSSARY.html) with [](GLOSSARY.html) callbacks [](GLOSSARY.html) that [](GLOSSARY.html)
    are [](GLOSSARY.html) closures, or [](GLOSSARY.html) when [](GLOSSARY.html) exceptions
    [](GLOSSARY.html) are stored.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 问题也可能存在于闭包回调或存储异常的情况下。
- en: Publisher Subscriber
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者订阅者
- en: Event bus / PubSub
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件总线/发布订阅
- en: Full [](GLOSSARY.html) decoupling [](GLOSSARY.html) between [](GLOSSARY.html)
    publishers [](GLOSSARY.html) and [](GLOSSARY.html) subscribers. Publishers [](GLOSSARY.html)
    don't [](GLOSSARY.html) know [](GLOSSARY.html) about [](GLOSSARY.html) subscribers,
    and [](GLOSSARY.html) vice-versa. Messages [](GLOSSARY.html) are [](GLOSSARY.html)
    sender [](GLOSSARY.html) to [](GLOSSARY.html) receiver. The [](GLOSSARY.html)
    receiver [](GLOSSARY.html) cannot "reply" to [](GLOSSARY.html) the [](GLOSSARY.html)
    sender.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者和订阅者之间完全解耦。发布者不知道订阅者，反之亦然。消息是从发送者发送到接收者。接收者无法“回复”给发送者。
- en: Example, wxpython [](GLOSSARY.html) provides [](GLOSSARY.html) a [](GLOSSARY.html)
    nice [](GLOSSARY.html) example [](GLOSSARY.html) of [](GLOSSARY.html) pubsub [](GLOSSARY.html)
    model
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，wxpython提供了发布订阅模型的一个很好的例子。
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Objects [](GLOSSARY.html) that [](GLOSSARY.html) are [](GLOSSARY.html) interested
    [](GLOSSARY.html) in [](GLOSSARY.html) the [](GLOSSARY.html) notification [](GLOSSARY.html)
    can [](GLOSSARY.html) now [](GLOSSARY.html) subscribe [](GLOSSARY.html) to [](GLOSSARY.html)
    the qualified [](GLOSSARY.html) notification [](GLOSSARY.html) as [](GLOSSARY.html)
    follows. The handler [](GLOSSARY.html) will [](GLOSSARY.html) receive [](GLOSSARY.html)
    a [](GLOSSARY.html) message, qualified [](GLOSSARY.html) with [](GLOSSARY.html)
    the [](GLOSSARY.html) appropriate [](GLOSSARY.html) information
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对通知感兴趣的对象，现在可以订阅符合条件的通知如下。处理程序将收到一条带有适当信息的消息。
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: NSNotificationCenter [](GLOSSARY.html) is [](GLOSSARY.html) a [](GLOSSARY.html)
    pubsub.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: NSNotificationCenter是一个发布订阅模式。
- en: decoupling [](GLOSSARY.html) makes [](GLOSSARY.html) compile [](GLOSSARY.html)
    time [](GLOSSARY.html) checks [](GLOSSARY.html) useless.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦使得编译时检查变得无用。
- en: delivery [](GLOSSARY.html) network [](GLOSSARY.html) can [](GLOSSARY.html) become
    [](GLOSSARY.html) complicated. Incorrect [](GLOSSARY.html) setup [](GLOSSARY.html)
    can [](GLOSSARY.html) lead [](GLOSSARY.html) to [](GLOSSARY.html) unintended [](GLOSSARY.html)
    listeners [](GLOSSARY.html) to [](GLOSSARY.html) receive messages [](GLOSSARY.html)
    they [](GLOSSARY.html) are [](GLOSSARY.html) not [](GLOSSARY.html) supposed [](GLOSSARY.html)
    to [](GLOSSARY.html) receive. the [](GLOSSARY.html) application [](GLOSSARY.html)
    flow [](GLOSSARY.html) is [](GLOSSARY.html) hard [](GLOSSARY.html) to [](GLOSSARY.html)
    understand [](GLOSSARY.html) and [](GLOSSARY.html) debug.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付网络可能变得复杂。不正确的设置可能导致意外的监听器接收他们不应该接收的消息。应用程序流程难以理解和调试。
- en: from [](GLOSSARY.html) the [](GLOSSARY.html) code [](GLOSSARY.html) alone, it's
    [](GLOSSARY.html) hard [](GLOSSARY.html) to [](GLOSSARY.html) spot [](GLOSSARY.html)
    the [](GLOSSARY.html) dependency [](GLOSSARY.html) between [](GLOSSARY.html) a
    [](GLOSSARY.html) publisher [](GLOSSARY.html) and [](GLOSSARY.html) a [](GLOSSARY.html)
    subscriber, in [](GLOSSARY.html) particularly [](GLOSSARY.html) when [](GLOSSARY.html)
    the [](GLOSSARY.html) message [](GLOSSARY.html) is [](GLOSSARY.html) emitted [](GLOSSARY.html)
    and [](GLOSSARY.html) delivered.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅从代码中，很难发现发布者和订阅者之间的依赖关系，特别是当消息被发出和传递时。
- en: delivery [](GLOSSARY.html) can [](GLOSSARY.html) be [](GLOSSARY.html) synchronous
    [](GLOSSARY.html) or [](GLOSSARY.html) asynchronous, but [](GLOSSARY.html) even
    [](GLOSSARY.html) when [](GLOSSARY.html) synchronous, it's [](GLOSSARY.html) not
    [](GLOSSARY.html) possible to [](GLOSSARY.html) rely [](GLOSSARY.html) on [](GLOSSARY.html)
    delivery [](GLOSSARY.html) order.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付可以是同步的或异步的，但即使是同步的，也不能依赖交付顺序。
- en: message [](GLOSSARY.html) source [](GLOSSARY.html) may [](GLOSSARY.html) not
    [](GLOSSARY.html) be [](GLOSSARY.html) available [](GLOSSARY.html) to [](GLOSSARY.html)
    the [](GLOSSARY.html) receiver.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息源可能对接收者不可用。
- en: use [](GLOSSARY.html) of [](GLOSSARY.html) topics [](GLOSSARY.html) to [](GLOSSARY.html)
    group [](GLOSSARY.html) message [](GLOSSARY.html) types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主题将消息类型分组。
- en: Model Distribution
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型分布
- en: Model Distribution
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型分布
- en: sharding?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 分片？
- en: Multithreading
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: Multithreading
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: Problem [](GLOSSARY.html) with [](GLOSSARY.html) multiple [](GLOSSARY.html)
    threads. Sending [](GLOSSARY.html) notifications [](GLOSSARY.html) that [](GLOSSARY.html)
    are [](GLOSSARY.html) delivered [](GLOSSARY.html) as [](GLOSSARY.html) the [](GLOSSARY.html)
    same [](GLOSSARY.html) thread. Describe [](GLOSSARY.html) how [](GLOSSARY.html)
    Qt [](GLOSSARY.html) manages [](GLOSSARY.html) to [](GLOSSARY.html) handle [](GLOSSARY.html)
    delivery [](GLOSSARY.html) through [](GLOSSARY.html) the [](GLOSSARY.html) event
    [](GLOSSARY.html) loop if [](GLOSSARY.html) two [](GLOSSARY.html) objects [](GLOSSARY.html)
    have [](GLOSSARY.html) different [](GLOSSARY.html) thread [](GLOSSARY.html) affinity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程问题。发送作为同一线程传递的通知。描述Qt如何通过事件循环处理交付，如果两个对象具有不同的线程亲和性。
- en: Do [](GLOSSARY.html) not [](GLOSSARY.html) spawn [](GLOSSARY.html) threads.
    makes [](GLOSSARY.html) things [](GLOSSARY.html) harder [](GLOSSARY.html) to [](GLOSSARY.html)
    handle. use [](GLOSSARY.html) a [](GLOSSARY.html) thread [](GLOSSARY.html) pool.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不要生成线程。这样会使事情更难处理。使用线程池。
- en: Models [](GLOSSARY.html) should [](GLOSSARY.html) be [](GLOSSARY.html) synchronous,
    so [](GLOSSARY.html) you [](GLOSSARY.html) can [](GLOSSARY.html) decide [](GLOSSARY.html)
    which [](GLOSSARY.html) threading [](GLOSSARY.html) strategy to [](GLOSSARY.html)
    use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模型应该是同步的，这样你可以决定使用哪种线程策略。
- en: Have [](GLOSSARY.html) futures.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有未来。
- en: 'Separate [](GLOSSARY.html) threads [](GLOSSARY.html) can [](GLOSSARY.html)
    act [](GLOSSARY.html) independently, produced [](GLOSSARY.html) by [](GLOSSARY.html)
    code [](GLOSSARY.html) running [](GLOSSARY.html) in [](GLOSSARY.html) the [](GLOSSARY.html)
    main (event [](GLOSSARY.html) loop) thread. The [](GLOSSARY.html) problem [](GLOSSARY.html)
    is [](GLOSSARY.html) that [](GLOSSARY.html) any [](GLOSSARY.html) change [](GLOSSARY.html)
    they [](GLOSSARY.html) can [](GLOSSARY.html) do [](GLOSSARY.html) can [](GLOSSARY.html)
    propagate through [](GLOSSARY.html) the [](GLOSSARY.html) network, and [](GLOSSARY.html)
    touch [](GLOSSARY.html) parts [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html)
    code [](GLOSSARY.html) that [](GLOSSARY.html) is [](GLOSSARY.html) currently [](GLOSSARY.html)
    handled [](GLOSSARY.html) by [](GLOSSARY.html) the main [](GLOSSARY.html) thread.
    As [](GLOSSARY.html) a [](GLOSSARY.html) result, the [](GLOSSARY.html) generally
    [](GLOSSARY.html) better [](GLOSSARY.html) way [](GLOSSARY.html) of [](GLOSSARY.html)
    handling [](GLOSSARY.html) this [](GLOSSARY.html) situation [](GLOSSARY.html)
    is that [](GLOSSARY.html) secondary [](GLOSSARY.html) threads [](GLOSSARY.html)
    communicate [](GLOSSARY.html) with [](GLOSSARY.html) the [](GLOSSARY.html) main
    [](GLOSSARY.html) thread [](GLOSSARY.html) in [](GLOSSARY.html) two [](GLOSSARY.html)
    ways:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的[](GLOSSARY.html)线程[](GLOSSARY.html)可以[](GLOSSARY.html)独立运行，由在主（事件[](GLOSSARY.html)循环）线程中运行的代码产生。问题在于，它们所做的任何更改都可能通过网络传播，并触及当前由主线程处理的代码的部分。因此，处理这种情况的一般更好的方式是，次要线程以两种方式与主线程通信：
- en: setting [](GLOSSARY.html) state (using [](GLOSSARY.html) locks [](GLOSSARY.html)
    for [](GLOSSARY.html) synchronization)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置状态（使用锁进行同步）
- en: posting [](GLOSSARY.html) events [](GLOSSARY.html) into [](GLOSSARY.html) the
    [](GLOSSARY.html) event [](GLOSSARY.html) loop, so [](GLOSSARY.html) that [](GLOSSARY.html)
    the [](GLOSSARY.html) main [](GLOSSARY.html) thread [](GLOSSARY.html) can [](GLOSSARY.html)
    handle [](GLOSSARY.html) them.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件发布到事件循环中，以便主线程可以处理它们。
- en: 'Once [](GLOSSARY.html) an [](GLOSSARY.html) event [](GLOSSARY.html) is [](GLOSSARY.html)
    triggered, the [](GLOSSARY.html) application [](GLOSSARY.html) has [](GLOSSARY.html)
    around [](GLOSSARY.html) 1/60th [](GLOSSARY.html) of [](GLOSSARY.html) a [](GLOSSARY.html)
    second [](GLOSSARY.html) to [](GLOSSARY.html) return control [](GLOSSARY.html)
    to [](GLOSSARY.html) the [](GLOSSARY.html) event [](GLOSSARY.html) loop, meaning
    [](GLOSSARY.html) that [](GLOSSARY.html) the [](GLOSSARY.html) object/notification
    [](GLOSSARY.html) network [](GLOSSARY.html) traversal must [](GLOSSARY.html) be
    [](GLOSSARY.html) over [](GLOSSARY.html) quickly. If [](GLOSSARY.html) any [](GLOSSARY.html)
    event [](GLOSSARY.html) triggers [](GLOSSARY.html) something [](GLOSSARY.html)
    that [](GLOSSARY.html) can [](GLOSSARY.html) potentially [](GLOSSARY.html) last
    [](GLOSSARY.html) for [](GLOSSARY.html) more than [](GLOSSARY.html) the [](GLOSSARY.html)
    mentioned [](GLOSSARY.html) amount [](GLOSSARY.html) of [](GLOSSARY.html) time,
    it [](GLOSSARY.html) must [](GLOSSARY.html) be [](GLOSSARY.html) executed [](GLOSSARY.html)
    in [](GLOSSARY.html) a [](GLOSSARY.html) separate [](GLOSSARY.html) thread, or
    [](GLOSSARY.html) the interface [](GLOSSARY.html) responsiveness [](GLOSSARY.html)
    will [](GLOSSARY.html) suffer. Having [](GLOSSARY.html) a [](GLOSSARY.html) separate
    [](GLOSSARY.html) thread [](GLOSSARY.html) carries [](GLOSSARY.html) its [](GLOSSARY.html)
    additional [](GLOSSARY.html) quirks: can''t [](GLOSSARY.html) normally [](GLOSSARY.html)
    touch [](GLOSSARY.html) ui [](GLOSSARY.html) code, must [](GLOSSARY.html) be [](GLOSSARY.html)
    synchronized.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发事件，应用程序大约有1/60秒的时间将控制权返回给事件循环，这意味着对象/通知网络遍历必须迅速完成。如果任何事件触发了可能持续超过提到的时间的事情，它必须在一个单独的线程中执行，否则界面响应性将受到影响。拥有一个单独的线程带来了额外的怪癖：通常不能触及UI代码，必须同步。
- en: FIXME [](GLOSSARY.html) do [](GLOSSARY.html) comparison [](GLOSSARY.html) with
    [](GLOSSARY.html) asynchronous [](GLOSSARY.html) single [](GLOSSARY.html) threaded
    [](GLOSSARY.html) programming. Put [](GLOSSARY.html) a [](GLOSSARY.html) useful
    [](GLOSSARY.html) picture
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[FIXME](GLOSSARY.html) 与异步单线程编程进行比较。放置一个有用的图片'
- en: Notification looping prevention
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知循环预防
- en: Notification looping prevention
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知循环预防
- en: Notification [](GLOSSARY.html) messages [](GLOSSARY.html) from [](GLOSSARY.html)
    the [](GLOSSARY.html) Model [](GLOSSARY.html) can [](GLOSSARY.html) become [](GLOSSARY.html)
    problematic [](GLOSSARY.html) for [](GLOSSARY.html) a [](GLOSSARY.html) series
    [](GLOSSARY.html) of reason
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 模型中的通知消息可能因为一系列原因变得棘手
- en: the [](GLOSSARY.html) Views [](GLOSSARY.html) get [](GLOSSARY.html) informed
    [](GLOSSARY.html) that [](GLOSSARY.html) changes [](GLOSSARY.html) occurred, but
    [](GLOSSARY.html) it's [](GLOSSARY.html) in [](GLOSSARY.html) a [](GLOSSARY.html)
    part [](GLOSSARY.html) of [](GLOSSARY.html) the data [](GLOSSARY.html) model [](GLOSSARY.html)
    that [](GLOSSARY.html) is [](GLOSSARY.html) not [](GLOSSARY.html) represented
    [](GLOSSARY.html) by [](GLOSSARY.html) a [](GLOSSARY.html) specific [](GLOSSARY.html)
    View. Views [](GLOSSARY.html) must [](GLOSSARY.html) go [](GLOSSARY.html) through
    [](GLOSSARY.html) a refresh [](GLOSSARY.html) cycle [](GLOSSARY.html) even [](GLOSSARY.html)
    if [](GLOSSARY.html) no [](GLOSSARY.html) data [](GLOSSARY.html) has [](GLOSSARY.html)
    changed [](GLOSSARY.html) for [](GLOSSARY.html) them
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图被通知发生了更改，但这是数据模型的一部分，没有由特定视图表示。即使对于它们没有数据更改，视图也必须经历刷新周期。
- en: A [](GLOSSARY.html) sequence [](GLOSSARY.html) of [](GLOSSARY.html) changes
    [](GLOSSARY.html) is [](GLOSSARY.html) performed [](GLOSSARY.html) on [](GLOSSARY.html)
    the [](GLOSSARY.html) Model, forcing [](GLOSSARY.html) a [](GLOSSARY.html) refresh
    [](GLOSSARY.html) of [](GLOSSARY.html) all [](GLOSSARY.html) the Views [](GLOSSARY.html)
    at [](GLOSSARY.html) each [](GLOSSARY.html) change, while [](GLOSSARY.html) a
    [](GLOSSARY.html) single [](GLOSSARY.html) refresh [](GLOSSARY.html) at [](GLOSSARY.html)
    the [](GLOSSARY.html) end [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html)
    sequence [](GLOSSARY.html) would suffice.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型上执行一系列更改，强制每次更改时刷新所有视图，而在序列结束时进行单次刷新就足够了。
- en: The [](GLOSSARY.html) update-change [](GLOSSARY.html) cycle [](GLOSSARY.html)
    lead [](GLOSSARY.html) to [](GLOSSARY.html) an [](GLOSSARY.html) infinite [](GLOSSARY.html)
    loop
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新-更改循环导致无限循环
- en: 'Consider [](GLOSSARY.html) the [](GLOSSARY.html) following [](GLOSSARY.html)
    case [](GLOSSARY.html) of [](GLOSSARY.html) a [](GLOSSARY.html) SpinBox [](GLOSSARY.html)
    containing [](GLOSSARY.html) the [](GLOSSARY.html) value [](GLOSSARY.html) 3,
    and [](GLOSSARY.html) the [](GLOSSARY.html) associated [](GLOSSARY.html) Model
    [](GLOSSARY.html) value [](GLOSSARY.html) currently [](GLOSSARY.html) set [](GLOSSARY.html)
    to [](GLOSSARY.html) 3 [](GLOSSARY.html) as [](GLOSSARY.html) well. When [](GLOSSARY.html)
    the [](GLOSSARY.html) user [](GLOSSARY.html) interacts [](GLOSSARY.html) with
    [](GLOSSARY.html) the [](GLOSSARY.html) SpinBox, clicking [](GLOSSARY.html) the
    [](GLOSSARY.html) up [](GLOSSARY.html) arrow, the [](GLOSSARY.html) following
    [](GLOSSARY.html) sequence [](GLOSSARY.html) of [](GLOSSARY.html) events [](GLOSSARY.html)
    occurs:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含值3的SpinBox的情况，关联的模型值当前也设置为3。当用户与SpinBox交互时，点击上箭头，发生以下事件序列：
- en: a [](GLOSSARY.html) valueChanged() signal [](GLOSSARY.html) is [](GLOSSARY.html)
    issued [](GLOSSARY.html) by [](GLOSSARY.html) the [](GLOSSARY.html) SpinBox [](GLOSSARY.html)
    with [](GLOSSARY.html) the [](GLOSSARY.html) new [](GLOSSARY.html) value, 4\.
    We [](GLOSSARY.html) assume [](GLOSSARY.html) the [](GLOSSARY.html) SpinBox [](GLOSSARY.html)
    keeps [](GLOSSARY.html) showing [](GLOSSARY.html) the [](GLOSSARY.html) old [](GLOSSARY.html)
    value, as [](GLOSSARY.html) it [](GLOSSARY.html) represents [](GLOSSARY.html)
    the [](GLOSSARY.html) Model, which [](GLOSSARY.html) at [](GLOSSARY.html) the
    [](GLOSSARY.html) moment [](GLOSSARY.html) contains [](GLOSSARY.html) 3\.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [](GLOSSARY.html) Controller.setValue(4) method [](GLOSSARY.html) is [](GLOSSARY.html)
    called, which [](GLOSSARY.html) in [](GLOSSARY.html) turn [](GLOSSARY.html) calls
    [](GLOSSARY.html) Model.setValue(4).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [](GLOSSARY.html) Model [](GLOSSARY.html) stores [](GLOSSARY.html) the [](GLOSSARY.html)
    new [](GLOSSARY.html) value [](GLOSSARY.html) 4, then [](GLOSSARY.html) issue
    [](GLOSSARY.html) a [](GLOSSARY.html) _notifyListeners [](GLOSSARY.html) to [](GLOSSARY.html)
    inform [](GLOSSARY.html) all [](GLOSSARY.html) the [](GLOSSARY.html) connected
    [](GLOSSARY.html) views, including [](GLOSSARY.html) the [](GLOSSARY.html) SpinBox.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [](GLOSSARY.html) SpinBox [](GLOSSARY.html) receives [](GLOSSARY.html) the
    [](GLOSSARY.html) notify(), which [](GLOSSARY.html) now [](GLOSSARY.html) fetches
    [](GLOSSARY.html) the [](GLOSSARY.html) new [](GLOSSARY.html) value [](GLOSSARY.html)
    from [](GLOSSARY.html) the [](GLOSSARY.html) Model [](GLOSSARY.html) and [](GLOSSARY.html)
    sets [](GLOSSARY.html) the [](GLOSSARY.html) new [](GLOSSARY.html) value [](GLOSSARY.html)
    using [](GLOSSARY.html) QSpinBox.setValue(4)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [](GLOSSARY.html) SpinBox [](GLOSSARY.html) is [](GLOSSARY.html) still [](GLOSSARY.html)
    containing [](GLOSSARY.html) the [](GLOSSARY.html) value [](GLOSSARY.html) 3\.
    QSpinBox.setValue(4) triggers [](GLOSSARY.html) valueChanged() again.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Controller.setValue [](GLOSSARY.html) is [](GLOSSARY.html) called [](GLOSSARY.html)
    again, reproducing [](GLOSSARY.html) the [](GLOSSARY.html) situation [](GLOSSARY.html)
    at [](GLOSSARY.html) point [](GLOSSARY.html) 2.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With [](GLOSSARY.html) this [](GLOSSARY.html) scenario, the [](GLOSSARY.html)
    application [](GLOSSARY.html) is [](GLOSSARY.html) potentially [](GLOSSARY.html)
    entering [](GLOSSARY.html) a [](GLOSSARY.html) notification loop. A [](GLOSSARY.html)
    prevention [](GLOSSARY.html) strategy [](GLOSSARY.html) is [](GLOSSARY.html) to
    [](GLOSSARY.html) have [](GLOSSARY.html) the [](GLOSSARY.html) Model [](GLOSSARY.html)
    notify [](GLOSSARY.html) the [](GLOSSARY.html) listeners [](GLOSSARY.html) only
    [](GLOSSARY.html) if the [](GLOSSARY.html) new [](GLOSSARY.html) value [](GLOSSARY.html)
    differs [](GLOSSARY.html) from [](GLOSSARY.html) the [](GLOSSARY.html) currently
    [](GLOSSARY.html) stored [](GLOSSARY.html) one. This [](GLOSSARY.html) solution
    [](GLOSSARY.html) will terminate [](GLOSSARY.html) at [](GLOSSARY.html) point
    [](GLOSSARY.html) 3, technically [](GLOSSARY.html) performing [](GLOSSARY.html)
    useless [](GLOSSARY.html) Controller.setValue [](GLOSSARY.html) and Model.setValue
    [](GLOSSARY.html) calls. A [](GLOSSARY.html) tempting [](GLOSSARY.html) alternative
    [](GLOSSARY.html) solution [](GLOSSARY.html) is [](GLOSSARY.html) to [](GLOSSARY.html)
    have [](GLOSSARY.html) the [](GLOSSARY.html) SpinBox increment [](GLOSSARY.html)
    its [](GLOSSARY.html) visualized [](GLOSSARY.html) value [](GLOSSARY.html) independently
    [](GLOSSARY.html) from [](GLOSSARY.html) the [](GLOSSARY.html) Model, thus [](GLOSSARY.html)
    having [](GLOSSARY.html) the View [](GLOSSARY.html) autonomous [](GLOSSARY.html)
    in [](GLOSSARY.html) its [](GLOSSARY.html) visualized [](GLOSSARY.html) state.
    With [](GLOSSARY.html) this [](GLOSSARY.html) approach, after [](GLOSSARY.html)
    step [](GLOSSARY.html) 1 [](GLOSSARY.html) the SpinBox [](GLOSSARY.html) will
    [](GLOSSARY.html) show [](GLOSSARY.html) the [](GLOSSARY.html) number [](GLOSSARY.html)
    4\. The [](GLOSSARY.html) chain [](GLOSSARY.html) of [](GLOSSARY.html) events
    [](GLOSSARY.html) will [](GLOSSARY.html) unfold [](GLOSSARY.html) exactly [](GLOSSARY.html)
    in [](GLOSSARY.html) the same [](GLOSSARY.html) way [](GLOSSARY.html) until [](GLOSSARY.html)
    step [](GLOSSARY.html) 4\. The [](GLOSSARY.html) SpinBox [](GLOSSARY.html) will
    [](GLOSSARY.html) now [](GLOSSARY.html) observe [](GLOSSARY.html) that [](GLOSSARY.html)
    the [](GLOSSARY.html) new [](GLOSSARY.html) value [](GLOSSARY.html) in [](GLOSSARY.html)
    the Model [](GLOSSARY.html) is [](GLOSSARY.html) the [](GLOSSARY.html) same [](GLOSSARY.html)
    as [](GLOSSARY.html) the [](GLOSSARY.html) one [](GLOSSARY.html) it [](GLOSSARY.html)
    is [](GLOSSARY.html) currently [](GLOSSARY.html) displaying, terminating [](GLOSSARY.html)
    the [](GLOSSARY.html) chain by [](GLOSSARY.html) not [](GLOSSARY.html) triggering
    [](GLOSSARY.html) a [](GLOSSARY.html) valueChanged(). Depending [](GLOSSARY.html)
    on [](GLOSSARY.html) the [](GLOSSARY.html) toolkit [](GLOSSARY.html) used, graphical
    Views [](GLOSSARY.html) may [](GLOSSARY.html) or [](GLOSSARY.html) may [](GLOSSARY.html)
    not [](GLOSSARY.html) behave [](GLOSSARY.html) as [](GLOSSARY.html) described,
    but [](GLOSSARY.html) the [](GLOSSARY.html) fundamental [](GLOSSARY.html) issue
    [](GLOSSARY.html) with [](GLOSSARY.html) this approach [](GLOSSARY.html) is [](GLOSSARY.html)
    that [](GLOSSARY.html) the [](GLOSSARY.html) View [](GLOSSARY.html) is [](GLOSSARY.html)
    assuming [](GLOSSARY.html) to [](GLOSSARY.html) know [](GLOSSARY.html) the [](GLOSSARY.html)
    next [](GLOSSARY.html) value, and [](GLOSSARY.html) setting [](GLOSSARY.html)
    it accordingly, without [](GLOSSARY.html) involving [](GLOSSARY.html) any [](GLOSSARY.html)
    logic [](GLOSSARY.html) from [](GLOSSARY.html) the [](GLOSSARY.html) Controller
    [](GLOSSARY.html) or [](GLOSSARY.html) Model. The Model [](GLOSSARY.html) could,
    for [](GLOSSARY.html) example, consider [](GLOSSARY.html) the [](GLOSSARY.html)
    new [](GLOSSARY.html) value [](GLOSSARY.html) 4 [](GLOSSARY.html) to [](GLOSSARY.html)
    be [](GLOSSARY.html) invalid [](GLOSSARY.html) and [](GLOSSARY.html) set [](GLOSSARY.html)
    itself to [](GLOSSARY.html) the [](GLOSSARY.html) next [](GLOSSARY.html) valid
    [](GLOSSARY.html) one, for [](GLOSSARY.html) example [](GLOSSARY.html) 27\. This
    [](GLOSSARY.html) will [](GLOSSARY.html) force [](GLOSSARY.html) the [](GLOSSARY.html)
    View [](GLOSSARY.html) to [](GLOSSARY.html) update [](GLOSSARY.html) its graphical
    [](GLOSSARY.html) representation [](GLOSSARY.html) again.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Another [](GLOSSARY.html) strategy [](GLOSSARY.html) is [](GLOSSARY.html) to
    [](GLOSSARY.html) prevent [](GLOSSARY.html) the [](GLOSSARY.html) View [](GLOSSARY.html)
    from [](GLOSSARY.html) updating [](GLOSSARY.html) itself [](GLOSSARY.html) twice
    [](GLOSSARY.html) within [](GLOSSARY.html) the same [](GLOSSARY.html) cycle [](GLOSSARY.html)
    of [](GLOSSARY.html) events. A [](GLOSSARY.html) possible [](GLOSSARY.html) implementation
    [](GLOSSARY.html) of [](GLOSSARY.html) this [](GLOSSARY.html) strategy [](GLOSSARY.html)
    is [](GLOSSARY.html) to [](GLOSSARY.html) hold [](GLOSSARY.html) a flag [](GLOSSARY.html)
    updating [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html) View. The
    [](GLOSSARY.html) flag [](GLOSSARY.html) is [](GLOSSARY.html) set [](GLOSSARY.html)
    to [](GLOSSARY.html) True [](GLOSSARY.html) at [](GLOSSARY.html) step [](GLOSSARY.html)
    1\. The [](GLOSSARY.html) chain [](GLOSSARY.html) of events [](GLOSSARY.html)
    develops [](GLOSSARY.html) in [](GLOSSARY.html) the [](GLOSSARY.html) same [](GLOSSARY.html)
    way [](GLOSSARY.html) until [](GLOSSARY.html) step [](GLOSSARY.html) 5, where
    [](GLOSSARY.html) the [](GLOSSARY.html) setValue [](GLOSSARY.html) operation [](GLOSSARY.html)
    will check [](GLOSSARY.html) for [](GLOSSARY.html) the [](GLOSSARY.html) flag.
    If [](GLOSSARY.html) true, it [](GLOSSARY.html) will [](GLOSSARY.html) only [](GLOSSARY.html)
    update [](GLOSSARY.html) the [](GLOSSARY.html) graphical [](GLOSSARY.html) aspect
    [](GLOSSARY.html) of [](GLOSSARY.html) the widget, and [](GLOSSARY.html) skip
    [](GLOSSARY.html) the [](GLOSSARY.html) triggering [](GLOSSARY.html) of [](GLOSSARY.html)
    the [](GLOSSARY.html) second [](GLOSSARY.html) valueChanged() signal. Another
    strategy [](GLOSSARY.html) is [](GLOSSARY.html) to [](GLOSSARY.html) have [](GLOSSARY.html)
    a [](GLOSSARY.html) View [](GLOSSARY.html) that [](GLOSSARY.html) does [](GLOSSARY.html)
    not [](GLOSSARY.html) triggers [](GLOSSARY.html) valueChanged [](GLOSSARY.html)
    under [](GLOSSARY.html) certain conditions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Shut [](GLOSSARY.html) down [](GLOSSARY.html) the [](GLOSSARY.html) Model [](GLOSSARY.html)
    notification [](GLOSSARY.html) system? not [](GLOSSARY.html) a [](GLOSSARY.html)
    good [](GLOSSARY.html) idea. other [](GLOSSARY.html) parties [](GLOSSARY.html)
    will not [](GLOSSARY.html) receive [](GLOSSARY.html) events. Another [](GLOSSARY.html)
    alternative [](GLOSSARY.html) is [](GLOSSARY.html) to [](GLOSSARY.html) detach
    [](GLOSSARY.html) the [](GLOSSARY.html) View [](GLOSSARY.html) from [](GLOSSARY.html)
    the notification. It [](GLOSSARY.html) will [](GLOSSARY.html) not [](GLOSSARY.html)
    receive [](GLOSSARY.html) update [](GLOSSARY.html) notifications [](GLOSSARY.html)
    from [](GLOSSARY.html) the [](GLOSSARY.html) model, just [](GLOSSARY.html) set
    the [](GLOSSARY.html) value. It [](GLOSSARY.html) won't [](GLOSSARY.html) see
    [](GLOSSARY.html) changes [](GLOSSARY.html) in [](GLOSSARY.html) the [](GLOSSARY.html)
    model [](GLOSSARY.html) that [](GLOSSARY.html) originate [](GLOSSARY.html) from
    [](GLOSSARY.html) outside though.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: To [](GLOSSARY.html) prevent [](GLOSSARY.html) notification [](GLOSSARY.html)
    trashing, one [](GLOSSARY.html) can [](GLOSSARY.html) rely [](GLOSSARY.html) on
    [](GLOSSARY.html) transaction, to turn [](GLOSSARY.html) off [](GLOSSARY.html)
    notifications [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html) model,
    perform [](GLOSSARY.html) a [](GLOSSARY.html) set [](GLOSSARY.html) of [](GLOSSARY.html)
    changes, then triggering [](GLOSSARY.html) the [](GLOSSARY.html) notification
    [](GLOSSARY.html) by [](GLOSSARY.html) closing [](GLOSSARY.html) the [](GLOSSARY.html)
    transaction. When multiple [](GLOSSARY.html) independent [](GLOSSARY.html) modifications
    [](GLOSSARY.html) must [](GLOSSARY.html) be [](GLOSSARY.html) performed [](GLOSSARY.html)
    on [](GLOSSARY.html) the [](GLOSSARY.html) model [](GLOSSARY.html) in sequence,
    it [](GLOSSARY.html) pays [](GLOSSARY.html) off [](GLOSSARY.html) to [](GLOSSARY.html)
    have [](GLOSSARY.html) a [](GLOSSARY.html) method [](GLOSSARY.html) to [](GLOSSARY.html)
    disable [](GLOSSARY.html) and [](GLOSSARY.html) enable notifications. Without
    [](GLOSSARY.html) this [](GLOSSARY.html) technique, every [](GLOSSARY.html) individual
    [](GLOSSARY.html) change [](GLOSSARY.html) would trigger [](GLOSSARY.html) an
    [](GLOSSARY.html) update [](GLOSSARY.html) and [](GLOSSARY.html) force [](GLOSSARY.html)
    a [](GLOSSARY.html) refresh [](GLOSSARY.html) of [](GLOSSARY.html) the [](GLOSSARY.html)
    connected [](GLOSSARY.html) views, potentially [](GLOSSARY.html) ruining [](GLOSSARY.html)
    performance [](GLOSSARY.html) and [](GLOSSARY.html) exposing [](GLOSSARY.html)
    the [](GLOSSARY.html) user [](GLOSSARY.html) to [](GLOSSARY.html) progressive
    changes [](GLOSSARY.html) through [](GLOSSARY.html) the [](GLOSSARY.html) interface
    [](GLOSSARY.html) as [](GLOSSARY.html) each [](GLOSSARY.html) change [](GLOSSARY.html)
    is [](GLOSSARY.html) applied. By disabling [](GLOSSARY.html) the [](GLOSSARY.html)
    notifications, performing [](GLOSSARY.html) the [](GLOSSARY.html) changes, and
    [](GLOSSARY.html) re-enabling the [](GLOSSARY.html) notifications, a [](GLOSSARY.html)
    single [](GLOSSARY.html) update [](GLOSSARY.html) will [](GLOSSARY.html) be [](GLOSSARY.html)
    triggered. model [](GLOSSARY.html) packing multiple [](GLOSSARY.html) changes
    [](GLOSSARY.html) to [](GLOSSARY.html) deliver [](GLOSSARY.html) a [](GLOSSARY.html)
    single [](GLOSSARY.html) refresh [](GLOSSARY.html) to [](GLOSSARY.html) the [](GLOSSARY.html)
    view [](GLOSSARY.html) controller disabling [](GLOSSARY.html) notifications [](GLOSSARY.html)
    of [](GLOSSARY.html) the [](GLOSSARY.html) model.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'FIXME: Another [](GLOSSARY.html) example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: a [](GLOSSARY.html) view [](GLOSSARY.html) has [](GLOSSARY.html) two [](GLOSSARY.html)
    methods, one [](GLOSSARY.html) that [](GLOSSARY.html) stores [](GLOSSARY.html)
    stuff [](GLOSSARY.html) on [](GLOSSARY.html) the [](GLOSSARY.html) model [](GLOSSARY.html)
    from [](GLOSSARY.html) the [](GLOSSARY.html) widget content, and [](GLOSSARY.html)
    another [](GLOSSARY.html) one [](GLOSSARY.html) that [](GLOSSARY.html) takes [](GLOSSARY.html)
    data [](GLOSSARY.html) from [](GLOSSARY.html) the [](GLOSSARY.html) model [](GLOSSARY.html)
    and [](GLOSSARY.html) stores [](GLOSSARY.html) it [](GLOSSARY.html) in the [](GLOSSARY.html)
    widgets. If [](GLOSSARY.html) the [](GLOSSARY.html) widget.setValue(model.value)
    triggers [](GLOSSARY.html) a [](GLOSSARY.html) notification [](GLOSSARY.html)
    and [](GLOSSARY.html) a [](GLOSSARY.html) request [](GLOSSARY.html) for [](GLOSSARY.html)
    syncing (as [](GLOSSARY.html) normally [](GLOSSARY.html) happens [](GLOSSARY.html)
    when [](GLOSSARY.html) the [](GLOSSARY.html) user [](GLOSSARY.html) writes [](GLOSSARY.html)
    a [](GLOSSARY.html) value), we [](GLOSSARY.html) need [](GLOSSARY.html) to [](GLOSSARY.html)
    disable notification [](GLOSSARY.html) when [](GLOSSARY.html) the [](GLOSSARY.html)
    modelToWidget() method [](GLOSSARY.html) is [](GLOSSARY.html) called, otherwise
    [](GLOSSARY.html) it [](GLOSSARY.html) will [](GLOSSARY.html) trigger notifications
    [](GLOSSARY.html) into [](GLOSSARY.html) the [](GLOSSARY.html) model, potentially
    [](GLOSSARY.html) calling [](GLOSSARY.html) modelToWidget() again.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We [](GLOSSARY.html) normally [](GLOSSARY.html) skip [](GLOSSARY.html) this
    [](GLOSSARY.html) with [](GLOSSARY.html) a [](GLOSSARY.html) flag [](GLOSSARY.html)
    in [](GLOSSARY.html) the modelToWidget() method [](GLOSSARY.html) that [](GLOSSARY.html)
    prevents [](GLOSSARY.html) recursion by [](GLOSSARY.html) bailing [](GLOSSARY.html)
    out [](GLOSSARY.html) if [](GLOSSARY.html) set [](GLOSSARY.html) to [](GLOSSARY.html)
    true, and [](GLOSSARY.html) it's [](GLOSSARY.html) set [](GLOSSARY.html) to [](GLOSSARY.html)
    true [](GLOSSARY.html) immediately, or [](GLOSSARY.html) disabling [](GLOSSARY.html)
    notification for [](GLOSSARY.html) the [](GLOSSARY.html) widget [](GLOSSARY.html)
    to [](GLOSSARY.html) synchronize. Make [](GLOSSARY.html) a [](GLOSSARY.html) code
    [](GLOSSARY.html) example [](GLOSSARY.html) for [](GLOSSARY.html) this
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Delayed Model
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delayed Model
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FIXME: Asynchronous. Move [](GLOSSARY.html) this [](GLOSSARY.html) one [](GLOSSARY.html)
    to [](GLOSSARY.html) advanced [](GLOSSARY.html) patterns.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every [](GLOSSARY.html) time [](GLOSSARY.html) a [](GLOSSARY.html) Model [](GLOSSARY.html)
    changes, the [](GLOSSARY.html) View [](GLOSSARY.html) must [](GLOSSARY.html) refresh
    [](GLOSSARY.html) against [](GLOSSARY.html) the [](GLOSSARY.html) new [](GLOSSARY.html)
    data. This [](GLOSSARY.html) step [](GLOSSARY.html) can [](GLOSSARY.html) be [](GLOSSARY.html)
    time [](GLOSSARY.html) consuming. If [](GLOSSARY.html) the [](GLOSSARY.html) Model
    [](GLOSSARY.html) is [](GLOSSARY.html) going [](GLOSSARY.html) through [](GLOSSARY.html)
    a [](GLOSSARY.html) lot [](GLOSSARY.html) of [](GLOSSARY.html) changes in [](GLOSSARY.html)
    a [](GLOSSARY.html) very [](GLOSSARY.html) short [](GLOSSARY.html) amount [](GLOSSARY.html)
    of [](GLOSSARY.html) time, shorter [](GLOSSARY.html) than [](GLOSSARY.html) the
    [](GLOSSARY.html) time [](GLOSSARY.html) needed [](GLOSSARY.html) to [](GLOSSARY.html)
    refresh [](GLOSSARY.html) the [](GLOSSARY.html) View, we [](GLOSSARY.html) might
    [](GLOSSARY.html) not [](GLOSSARY.html) want [](GLOSSARY.html) the [](GLOSSARY.html)
    View [](GLOSSARY.html) to [](GLOSSARY.html) follow [](GLOSSARY.html) through.
    This [](GLOSSARY.html) mechanism [](GLOSSARY.html) is [](GLOSSARY.html) known
    [](GLOSSARY.html) as "debouncing".
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We [](GLOSSARY.html) can [](GLOSSARY.html) neutralize [](GLOSSARY.html) these
    [](GLOSSARY.html) fast [](GLOSSARY.html) changes [](GLOSSARY.html) in [](GLOSSARY.html)
    the [](GLOSSARY.html) Model [](GLOSSARY.html) either [](GLOSSARY.html) View-side
    [](GLOSSARY.html) or [](GLOSSARY.html) Model-side.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Design
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [](GLOSSARY.html) Model [](GLOSSARY.html) holds [](GLOSSARY.html) a [](GLOSSARY.html)
    timer. Every [](GLOSSARY.html) time [](GLOSSARY.html) a [](GLOSSARY.html) change
    [](GLOSSARY.html) is [](GLOSSARY.html) performed [](GLOSSARY.html) on [](GLOSSARY.html)
    the [](GLOSSARY.html) Model [](GLOSSARY.html) and [](GLOSSARY.html) the [](GLOSSARY.html)
    Timer [](GLOSSARY.html) is [](GLOSSARY.html) not [](GLOSSARY.html) running, the
    [](GLOSSARY.html) Timer [](GLOSSARY.html) is [](GLOSSARY.html) started. No [](GLOSSARY.html)
    notification [](GLOSSARY.html) is [](GLOSSARY.html) issued [](GLOSSARY.html) to
    [](GLOSSARY.html) the [](GLOSSARY.html) View [](GLOSSARY.html) until [](GLOSSARY.html)
    the [](GLOSSARY.html) Timer [](GLOSSARY.html) runs [](GLOSSARY.html) out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/delayed_model/delayed_model.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Being [](GLOSSARY.html) the [](GLOSSARY.html) timer [](GLOSSARY.html) asynchronous,
    particular [](GLOSSARY.html) care [](GLOSSARY.html) must [](GLOSSARY.html) be
    [](GLOSSARY.html) taken [](GLOSSARY.html) to [](GLOSSARY.html) guarantee [](GLOSSARY.html)
    that [](GLOSSARY.html) the [](GLOSSARY.html) event [](GLOSSARY.html) is [](GLOSSARY.html)
    not [](GLOSSARY.html) delivered [](GLOSSARY.html) when [](GLOSSARY.html) the [](GLOSSARY.html)
    Model [](GLOSSARY.html) is [](GLOSSARY.html) undergoing [](GLOSSARY.html) another
    [](GLOSSARY.html) change.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In [](GLOSSARY.html) both [](GLOSSARY.html) cases, if [](GLOSSARY.html) the
    [](GLOSSARY.html) new [](GLOSSARY.html) change [](GLOSSARY.html) overlaps [](GLOSSARY.html)
    with [](GLOSSARY.html) the [](GLOSSARY.html) previous [](GLOSSARY.html) one, the
    [](GLOSSARY.html) old [](GLOSSARY.html) change can [](GLOSSARY.html) be [](GLOSSARY.html)
    discarded (as [](GLOSSARY.html) it [](GLOSSARY.html) will [](GLOSSARY.html) never
    [](GLOSSARY.html) get [](GLOSSARY.html) to [](GLOSSARY.html) appear [](GLOSSARY.html)
    on [](GLOSSARY.html) the [](GLOSSARY.html) view). Otherwise, the [](GLOSSARY.html)
    two [](GLOSSARY.html) changes [](GLOSSARY.html) can [](GLOSSARY.html) be [](GLOSSARY.html)
    combined if [](GLOSSARY.html) the [](GLOSSARY.html) notification [](GLOSSARY.html)
    is [](GLOSSARY.html) qualified. If [](GLOSSARY.html) it's [](GLOSSARY.html) not
    [](GLOSSARY.html) qualified, then [](GLOSSARY.html) when [](GLOSSARY.html) the
    [](GLOSSARY.html) View [](GLOSSARY.html) is [](GLOSSARY.html) finally [](GLOSSARY.html)
    notified at [](GLOSSARY.html) the [](GLOSSARY.html) end [](GLOSSARY.html) of [](GLOSSARY.html)
    the [](GLOSSARY.html) timer, it [](GLOSSARY.html) will [](GLOSSARY.html) get [](GLOSSARY.html)
    the [](GLOSSARY.html) current [](GLOSSARY.html) state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Throttling
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throttling
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar [](GLOSSARY.html) to [](GLOSSARY.html) debouncing, but [](GLOSSARY.html)
    the [](GLOSSARY.html) notification [](GLOSSARY.html) is [](GLOSSARY.html) issued
    [](GLOSSARY.html) immediately, and [](GLOSSARY.html) then not [](GLOSSARY.html)
    anymore [](GLOSSARY.html) until [](GLOSSARY.html) the [](GLOSSARY.html) timer
    [](GLOSSARY.html) expires. At [](GLOSSARY.html) the [](GLOSSARY.html) end [](GLOSSARY.html)
    of [](GLOSSARY.html) the [](GLOSSARY.html) timer, however, a [](GLOSSARY.html)
    check [](GLOSSARY.html) must [](GLOSSARY.html) be [](GLOSSARY.html) performed
    [](GLOSSARY.html) if [](GLOSSARY.html) the [](GLOSSARY.html) current [](GLOSSARY.html)
    value [](GLOSSARY.html) is [](GLOSSARY.html) different [](GLOSSARY.html) from
    [](GLOSSARY.html) the value [](GLOSSARY.html) issued [](GLOSSARY.html) at [](GLOSSARY.html)
    the [](GLOSSARY.html) first [](GLOSSARY.html) notification. If [](GLOSSARY.html)
    different, a [](GLOSSARY.html) new [](GLOSSARY.html) final [](GLOSSARY.html) notification
    [](GLOSSARY.html) must [](GLOSSARY.html) be [](GLOSSARY.html) issued, otherwise
    [](GLOSSARY.html) the [](GLOSSARY.html) View [](GLOSSARY.html) would [](GLOSSARY.html)
    sit [](GLOSSARY.html) desynchronized [](GLOSSARY.html) from [](GLOSSARY.html)
    the [](GLOSSARY.html) Model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
