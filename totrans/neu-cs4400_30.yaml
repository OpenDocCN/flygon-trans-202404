- en: Using Higher-Order & Anonymous FunctionsTuesday, January 31st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say that we have a function for estimating derivatives of a function at a specific
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And say that we want to try out various functions given some `plot` function
    that draws graphs of numeric functions, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `plot` expects a single `(Number -> Number)` function —
    if we want to try it with a derivative, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But this will get very tedious very fast — it is much simpler to use an anonymous
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: we can even verify that our derivative is correct by comparing a known function
    to its derivative
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But it’s still not completely natural to do these things — you need to explicitly
    combine functions, which is not too convenient. Instead of doing this, we can
    write H.O. functions that will work with functional inputs and outputs. For example,
    we can write a function to subtract functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and the same for the derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can try the same in a much easier way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'More than that — our `fderiv` could be created from `deriv` automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Same principle with `fsub`: we can write a function that converts a binary
    arithmetical function into a function that operates on unary numeric function.
    But to make things more readable we can define new types for unary and binary
    numeric functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do this with anything — developing a rich library of functions and functionals
    (functions over functions) is extremely easy… Here’s a pretty extensive yet very
    short library of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is written in the “untyped dialect” of the class language, but it should
    be easy now to add the types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Side-note: “Point-Free” combinatorsTuesday, January 31st'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forming functions without using `lambda` (or an implicit `lambda` using a `define`
    syntactic sugar) is called *point-free style*. It’s especially popular in Haskell,
    where it is easier to form functions this way because of implicit currying and
    a large number of higher level function combinators. If used too much, it can
    easily lead to obfuscated code.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this is similar to run-time code generation, but not really. The only
    thing that `fderiv` does is take a function and store it somewhere in the returned
    function, then when that function receives a number, it uses the stored function
    and send it to deriv with the number. We could simply write deriv as what `fderiv`
    is — which is the *real* derivative function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'but again, this is not faster or slower than the plain `deriv`. However, there
    are some situations where we can do some of the computation on the first-stage
    argument, saving work from the second stage. Here is a cooked-to-exaggeration
    example — we want a function that receives two inputs `x`, `y` and returns `fib(x)*y`,
    but we must use a stupid `fib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The function we want is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we currify it as usual (or just use `currify`), we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And try this several times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But in the definition of `bogus`, notice that `(fib x)` does not depend on
    `y` — so we can rewrite it a little differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'and trying the above again is much faster now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
