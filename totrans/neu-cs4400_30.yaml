- en: Using Higher-Order & Anonymous FunctionsTuesday, January 31st
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say that we have a function for estimating derivatives of a function at a specific
    point:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And say that we want to try out various functions given some `plot` function
    that draws graphs of numeric functions, for example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The problem is that `plot` expects a single `(Number -> Number)` function —
    if we want to try it with a derivative, we can do this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But this will get very tedious very fast — it is much simpler to use an anonymous
    function:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: we can even verify that our derivative is correct by comparing a known function
    to its derivative
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But it’s still not completely natural to do these things — you need to explicitly
    combine functions, which is not too convenient. Instead of doing this, we can
    write H.O. functions that will work with functional inputs and outputs. For example,
    we can write a function to subtract functions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'and the same for the derivative:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can try the same in a much easier way:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'More than that — our `fderiv` could be created from `deriv` automatically:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Same principle with `fsub`: we can write a function that converts a binary
    arithmetical function into a function that operates on unary numeric function.
    But to make things more readable we can define new types for unary and binary
    numeric functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can do this with anything — developing a rich library of functions and functionals
    (functions over functions) is extremely easy… Here’s a pretty extensive yet very
    short library of functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is written in the “untyped dialect” of the class language, but it should
    be easy now to add the types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Side-note: “Point-Free” combinatorsTuesday, January 31st'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forming functions without using `lambda` (or an implicit `lambda` using a `define`
    syntactic sugar) is called *point-free style*. It’s especially popular in Haskell,
    where it is easier to form functions this way because of implicit currying and
    a large number of higher level function combinators. If used too much, it can
    easily lead to obfuscated code.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this is similar to run-time code generation, but not really. The only
    thing that `fderiv` does is take a function and store it somewhere in the returned
    function, then when that function receives a number, it uses the stored function
    and send it to deriv with the number. We could simply write deriv as what `fderiv`
    is — which is the *real* derivative function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'but again, this is not faster or slower than the plain `deriv`. However, there
    are some situations where we can do some of the computation on the first-stage
    argument, saving work from the second stage. Here is a cooked-to-exaggeration
    example — we want a function that receives two inputs `x`, `y` and returns `fib(x)*y`,
    but we must use a stupid `fib`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function we want is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we currify it as usual (or just use `currify`), we get:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And try this several times:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But in the definition of `bogus`, notice that `(fib x)` does not depend on
    `y` — so we can rewrite it a little differently:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and trying the above again is much faster now:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次尝试上述方法会快得多：
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
