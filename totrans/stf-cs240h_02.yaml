- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen a few functions that "return" any type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return type can be arbitrary because function doesn't actually return
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions throw *language-level* exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use exceptions directly, import [`Control.Exception`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html)
    as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Older `Prelude`s have an old, less general version of `catch` you should avoid
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (`hiding` keyword prevents import of specific symbols)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Control.Exception`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html)
    gives you access to the following symbols:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Simple example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Need `DeriveDataTypeable` language pragma (later lecture)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler`''s type cannot be inferred (use constructor or type signature)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor pattern `e@(SomeException _)` catches all exceptions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions in pure code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previous example wrapped `catcher` around an IO action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can `throw` exceptions in pure code, yet `catch` them only in `IO`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is because evaluation order depends on implementation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Which error is thrown by `(error "one") + (error "two")`?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be non-deterministic, which is [okay](http://research.microsoft.com/en-us/um/people/simonpj/papers/imprecise-exn.htm)
    if `catch` is restricted to the `IO` Monad
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In `IO`, use `throwIO` (not `throw`) to make exception sequencing precise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generally, use `throw` only where you can't use `throwIO`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pure exceptions quite useful for errors & unimplemented code, E.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exceptions and laziness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the following function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What happens if you do this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exceptions and laziness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the following function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What happens if you do this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exceptions and laziness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the following function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What happens if you do this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`catch` only catches exceptions when thunks actually evaluated!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions and laziness continued
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Evaluating a list does not evaluate the head or tail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just evaluates the constructor (i.e., `(:)` or `[]`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise: Force evaluation of every element of a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write `seq`-like function with the following signature, that evaluates every
    element of list before evaluating second argument
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note, there is a function [`deepseq`](http://hackage.haskell.org/package/deepseq-1.3.0.2/docs/Control-DeepSeq.html#v:deepseq)
    in library of same name that does this for many common data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few more exception functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`try` returns `Right a` normally, `Left e` if an exception occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`finally` and `onException` run an clean-up action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Result of cleanup action (`b`) is discarded
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catchJust` catches only exceptions matching a predicate on value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Monadic exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Language-level exceptions can be cumbersome for non-`IO` actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-determinism is annoying
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Often want to detect error without assuming the `IO` monad
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many monads built on top of `IO` also can't catch exceptions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Often it is better to implement error handling in the Monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall the `Maybe` Monad, where can use `Nothing` to indicate failure
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note `fail` method called when bind pattern matches fail in `do` block
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Haskell threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell implements user-level threads in [`Control.Concurrent`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads are lightweight (in both time and space)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use threads where in other languages would use cheaper constructs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime emulates blocking OS calls in terms of non-blocking ones
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread-switch can happen any time GC could be invoked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forkIO` call creates a new thread:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A few other very useful thread functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: timeout'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute `IO` action, or abort after # of µsec'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`System.Timeout`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Timeout.html)
    has a slightly better version of this function'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[`MVar`s](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-MVar.html)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`MVar`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-MVar.html)
    type lets threads communicate via shared variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `MVar t` is a mutable variable of type `t` that is either *full* or *empty*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If an `MVar` is full, `takeMVar` makes it empty and returns former contents
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If an `MVar` is empty, `putMVar` fills it with a value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking an empty `MVar` or putting a full one puts thread to sleep until `MVar`
    becomes available
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only one thread awakened at a time if several blocked on same `MVar`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also non-blocking versions of `MVar` calls
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: pingpong benchmark'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Sidenote: benchmarking'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bryan has a kick-ass benchmarking library [criterion](http://hackage.haskell.org/package/criterion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: ~3.8 msec for 20,000 thread switches = ~190 nsec/switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GHC also has *two* versions of the haskell runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, all Haskell threads run in a single OS thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link with `-threaded` to allow OS threads (`pthread_create`) as well
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forkOS` call creates Haskell thread *bound* to a new OS thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, when linked with `-threaded`, initial thread is bound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whoa... what happened? `-threaded` 30 times slower?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Bound vs. unbound threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without `-threaded`, all Haskell threads run in one OS thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread switch is basically just a procedure call, i.e. super-fast
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-threaded` introduces multiple OS-level threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some Haskell threads are *bound* to a particular OS thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unbound* Haskell threads share (and migrate between) OS threads'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unbound` haskell threads have same performance as w/o `-threaded`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial thread bound, so we were actually benchmarking Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can wrap parent thread in `forkIO` to make it unbound
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But library has better function [`runInUnboundThread`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:runInUnboundThread)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What good are OS threads?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an unbound thread blocks, can block whole program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix runtime tries to avoid blocking syscalls, but can't avoid blocking for
    things like file system IO and paging
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Also relevant to foreign function interface (FFI)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GHC allows to kinds of calls into C code, `safe` and `unsafe`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With `-threaded`, GHC ensures `safe` FFI calls run in separate OS thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsafe` FFI calls from unbound threads can block other threads'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: FFI functions may expect to be called from same thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., foreign code using `pthread_getspecific` can get confused if called from
    a migrated unbound thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: May want to override scheduler and run on particular CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g., see [`forkOn`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:forkOn)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some handy `MVar` utility functions for updating a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: E.g., "`modifyMVar x (\n -> return (n+1, n))`" like "`x++`" in C
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you implement `modifyMVar`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Anyone see a problem? (Hint: remember `throwTo`, `killThread`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some handy `MVar` utility functions for updating a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: E.g., "`modifyMVar x (\n -> return (n+1, n))`" like "`x++`" in C
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you implement `modifyMVar`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What if another thread calls `killThread` on the current thread while current
    thread between `takeMVar` and `onException`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout` and `wrap` functions from a few slides ago have same problem'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`mask`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#v:mask)
    function can sidestep such race conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a funny type signature--uses an extension called `RankNTypes`. For now,
    ignore "`forall a.`"--just makes function more flexible
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mask $ \f -> b` runs action `b` with asynchronous exceptions *masked*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function `f` allows exceptions to be *unmasked* again for an action
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions are also unmasked if thread sleeps (e.g., in `takeMVar`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Fixing `modifyMVar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Masking exceptions (continued)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`forkIO` preserves the current mask state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can use the `unmask` function in child thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: fixed `wrap` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note we don't call `unmask` in parent thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop` will sleep on `takeMVar`, which implicitly unmasks'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmask while sleeping is generally what you want, but can avoid with [uninterruptibleMask](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#v:uninterruptibleMask)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`bracket`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#v:bracket)
    function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mask` is tricky, but library function [`bracket`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#v:bracket)
    simplifies use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: process file without leaking handle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: fix `parent` function from our `timeout` example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with `MVar`s
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MVar`s work just fine as a mutex:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note anyone can unlock a `Mutex` if it is locked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you throw assertion failure if caller doesn't hold lock?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternate `Mutex`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use *full* `MVar` rather than empty to mean lock held
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Store `ThreadId` of lock owner in `MVar`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you implement a condition variable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many uses of condition variables don't work with async exceptions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's not worrying about `mask` for this question...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Condition variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Key idea: putting `MVar`s inside `MVar`s is very powerful'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`Control.Concurrent.Chan`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-Chan.html)
    provides unbounded *channels*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented as two `MVar`s -- for read and and write end of `Stream`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](../Images/8055b0591ad69832c238495ef6b072c6.svg)'
  prefs: []
  type: TYPE_IMG
- en: Channel implementation [simplified]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: High-level Stream (TCP & Unix-domain) socket support in [`Network`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise: Network-enabled rock-paper-scissors. Define:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This accepts connection, plays single game, exits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start with last week''s code: `wget` [`cs240h.stanford.edu/rock2.hs`](http://cs240h.stanford.edu/rock2.hs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Build a program `netrock` that plays two users against one another and exits
    after one game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start here: `wget` [`cs240h.stanford.edu/netrock.hs`](http://cs240h.stanford.edu/netrock.hs),
    implement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You may find it useful to define and use:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'If your OS is missing `nc`: `wget` [`cs240h.stanford.edu/netcat.hs`](http://cs240h.stanford.edu/netcat.hs)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also have low-level BSD socket support in [`Network.Socket`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`getAddrInfo`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#v:getAddrInfo)
    looks up hostnames just like [[RFC3493]](http://tools.ietf.org/html/rfc3493) (returns
    `[`[`AddrInfo`](http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#t:AddrInfo)`]`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: Get `SockAddr` for talking to web server:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: netcat'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
