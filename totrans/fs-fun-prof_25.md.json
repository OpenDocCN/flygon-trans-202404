["```\ntype Label = string \n```", "```\ntype VitalForce = {units:int} \n```", "```\nlet getVitalForce vitalForce = \n   let oneUnit = {units = 1}\n   let remaining = {units = vitalForce.units-1}  // decrement\n   oneUnit, remaining  // return both \n```", "```\ntype DeadLeftLeg = DeadLeftLeg of Label \n```", "```\ntype LiveLeftLeg = LiveLeftLeg of Label * VitalForce \n```", "```\ntype MakeLiveLeftLeg = \n    DeadLeftLeg * VitalForce -> LiveLeftLeg * VitalForce \n```", "```\nlet makeLiveLeftLeg (deadLeftLeg,vitalForce) = \n    // get the label from the dead leg using pattern matching\n    let (DeadLeftLeg label) = deadLeftLeg\n    // get one unit of vital force\n    let oneUnit, remainingVitalForce = getVitalForce vitalForce \n    // create a live leg from the label and vital force\n    let liveLeftLeg = LiveLeftLeg (label,oneUnit)\n    // return the leg and the remaining vital force\n    liveLeftLeg, remainingVitalForce \n```", "```\ntype MakeLiveLeftLeg = \n    DeadLeftLeg -> VitalForce -> LiveLeftLeg * VitalForce \n\nlet makeLiveLeftLeg deadLeftLeg vitalForce = \n    let (DeadLeftLeg label) = deadLeftLeg\n    let oneUnit, remainingVitalForce = getVitalForce vitalForce \n    let liveLeftLeg = LiveLeftLeg (label,oneUnit)\n    liveLeftLeg, remainingVitalForce \n```", "```\ntype MakeLiveLeftLeg = \n    DeadLeftLeg -> (VitalForce -> LiveLeftLeg * VitalForce)\n\nlet makeLiveLeftLeg deadLeftLeg = \n    // create an inner intermediate function\n    let becomeAlive vitalForce = \n        let (DeadLeftLeg label) = deadLeftLeg\n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveLeftLeg = LiveLeftLeg (label,oneUnit)\n        liveLeftLeg, remainingVitalForce    \n    // return it\n    becomeAlive \n```", "```\nlet add x y = \n    x + y \n```", "```\nlet add x = \n    fun y -> x + y \n```", "```\nlet add x = \n    let addX y = x + y\n    addX // return the function \n```", "```\ntype M<'LiveBodyPart> = \n    VitalForce -> 'LiveBodyPart * VitalForce \n```", "```\nlet makeLiveLeftLeg deadLeftLeg :M<LiveLeftLeg> = \n    let becomeAlive vitalForce = \n        let (DeadLeftLeg label) = deadLeftLeg\n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveLeftLeg = LiveLeftLeg (label,oneUnit)\n        liveLeftLeg, remainingVitalForce    \n    becomeAlive \n```", "```\ntype M<'LiveBodyPart> = \n    M of (VitalForce -> 'LiveBodyPart * VitalForce) \n```", "```\nlet makeLiveLeftLegM deadLeftLeg  = \n    let becomeAlive vitalForce = \n        let (DeadLeftLeg label) = deadLeftLeg\n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveLeftLeg = LiveLeftLeg (label,oneUnit)\n        liveLeftLeg, remainingVitalForce    \n    // changed! \n    M becomeAlive // wrap the function in a single case union \n```", "```\nval makeLiveLeftLegM : DeadLeftLeg -> M<LiveLeftLeg> \n```", "```\nDeadPart -> M<LivePart> \n```", "```\nlet deadLeftLeg = DeadLeftLeg \"Boris\"\nlet leftLegM = makeLiveLeftLegM deadLeftLeg \n```", "```\nlet vf = {units = 10} \n```", "```\nlet (M innerFn) = leftLegM \n```", "```\nlet liveLeftLeg, remainingAfterLeftLeg = innerFn vf \n```", "```\nval liveLeftLeg : LiveLeftLeg = \n   LiveLeftLeg (\"Boris\",{units = 1;})\nval remainingAfterLeftLeg : VitalForce = \n   {units = 9;} \n```", "```\nlet runM (M f) vitalForce = f vitalForce \n```", "```\nlet liveLeftLeg, remainingAfterLeftLeg = runM leftLegM vf \n```", "```\ntype DeadLeftBrokenArm = DeadLeftBrokenArm of Label \n\n// A live version of the broken arm.\ntype LiveLeftBrokenArm = LiveLeftBrokenArm of Label * VitalForce\n\n// A live version of a heathly arm, with no dead version available\ntype LiveLeftArm = LiveLeftArm of Label * VitalForce\n\n// An operation that can turn a broken left arm into a heathly left arm\ntype HealBrokenArm = LiveLeftBrokenArm -> LiveLeftArm \n```", "```\n// implementation of HealBrokenArm\nlet healBrokenArm (LiveLeftBrokenArm (label,vf)) = LiveLeftArm (label,vf)\n\n/// convert a M<LiveLeftBrokenArm> into a M<LiveLeftArm>\nlet makeHealedLeftArm brokenArmM = \n\n    // create a new inner function that takes a vitalForce parameter\n    let healWhileAlive vitalForce = \n        // run the incoming brokenArmM with the vitalForce \n        // to get a broken arm\n        let brokenArm,remainingVitalForce = runM brokenArmM vitalForce \n\n        // heal the broken arm\n        let healedArm = healBrokenArm brokenArm\n\n        // return the healed arm and the remaining VitalForce\n        healedArm, remainingVitalForce\n\n    // wrap the inner function and return it\n    M healWhileAlive \n```", "```\nval makeHealedLeftArm : M<LiveLeftBrokenArm> -> M<LiveLeftArm> \n```", "```\nlet makeGenericTransform f brokenArmM = \n\n    // create a new inner function that takes a vitalForce parameter\n    let healWhileAlive vitalForce = \n        let brokenArm,remainingVitalForce = runM brokenArmM vitalForce \n\n        // heal the broken arm using passed in f\n        let healedArm = f brokenArm\n        healedArm, remainingVitalForce\n\n    M healWhileAlive \n```", "```\nval makeGenericTransform : f:('a -> 'b) -> M<'a> -> M<'b> \n```", "```\nlet mapM f bodyPartM = \n    let transformWhileAlive vitalForce = \n        let bodyPart,remainingVitalForce = runM bodyPartM vitalForce \n        let updatedBodyPart = f bodyPart\n        updatedBodyPart, remainingVitalForce\n    M transformWhileAlive \n```", "```\nlet healBrokenArmM = mapM healBrokenArm \n```", "```\n// map works with options\nlet healBrokenArmO = Option.map healBrokenArm\n// LiveLeftBrokenArm option -> LiveLeftArm option\n\n// map works with lists\nlet healBrokenArmL = List.map healBrokenArm\n// LiveLeftBrokenArm list -> LiveLeftArm list \n```", "```\nlet isEven x = (x%2 = 0)   // int -> bool\n// map it\nlet isEvenM = mapM isEven  // M<int> -> M<bool>\n\nlet isEmpty x = (String.length x)=0  // string -> bool\n// map it\nlet isEmptyM = mapM isEmpty          // M<string> -> M<bool> \n```", "```\nlet makeLiveLeftBrokenArm deadLeftBrokenArm = \n    let (DeadLeftBrokenArm label) = deadLeftBrokenArm\n    let becomeAlive vitalForce = \n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveLeftBrokenArm = LiveLeftBrokenArm (label,oneUnit)\n        liveLeftBrokenArm, remainingVitalForce    \n    M becomeAlive\n\n/// create a dead Left Broken Arm\nlet deadLeftBrokenArm = DeadLeftBrokenArm \"Victor\"\n\n/// create a M<BrokenLeftArm> from the dead one\nlet leftBrokenArmM = makeLiveLeftBrokenArm deadLeftBrokenArm \n```", "```\nlet leftArmM = leftBrokenArmM |> mapM healBrokenArm \n```", "```\nlet vf = {units = 10}\n\nlet liveLeftArm, remainingAfterLeftArm = runM leftArmM vf \n```", "```\nval liveLeftArm : LiveLeftArm = \n    LiveLeftArm (\"Victor\",{units = 1;})\nval remainingAfterLeftArm : \n    VitalForce = {units = 9;} \n```", "```\ntype DeadRightLowerArm = DeadRightLowerArm of Label \ntype DeadRightUpperArm = DeadRightUpperArm of Label \n```", "```\ntype LiveRightLowerArm = LiveRightLowerArm of Label * VitalForce\ntype LiveRightUpperArm = LiveRightUpperArm of Label * VitalForce \n```", "```\n// define the whole arm\ntype LiveRightArm = {\n    lowerArm : LiveRightLowerArm\n    upperArm : LiveRightUpperArm\n    }\n\n// surgery to combine the two arm parts\nlet armSurgery lowerArm upperArm =\n    {lowerArm=lowerArm; upperArm=upperArm} \n```", "```\n/// convert a M<LiveRightLowerArm> and  M<LiveRightUpperArm> into a M<LiveRightArm>\nlet makeArmSurgeryM_v1 lowerArmM upperArmM =\n\n    // create a new inner function that takes a vitalForce parameter\n    let becomeAlive vitalForce = \n        // run the incoming lowerArmM with the vitalForce \n        // to get the lower arm\n        let liveLowerArm,remainingVitalForce = runM lowerArmM vitalForce \n\n        // run the incoming upperArmM with the remainingVitalForce \n        // to get the upper arm\n        let liveUpperArm,remainingVitalForce2 = runM upperArmM remainingVitalForce \n\n        // do the surgery to create a liveRightArm\n        let liveRightArm = armSurgery liveLowerArm liveUpperArm\n\n        // return the whole arm and the SECOND remaining VitalForce\n        liveRightArm, remainingVitalForce2  \n\n    // wrap the inner function and return it\n    M becomeAlive \n```", "```\nM<LiveRightLowerArm> -> M<LiveRightUpperArm> -> M<LiveRightArm> \n```", "```\nlet map2M f m1 m2 =\n    let becomeAlive vitalForce = \n        let v1,remainingVitalForce = runM m1 vitalForce \n        let v2,remainingVitalForce2 = runM m2 remainingVitalForce  \n        let v3 = f v1 v2\n        v3, remainingVitalForce2    \n    M becomeAlive \n```", "```\nf:('a -> 'b -> 'c) -> M<'a> -> M<'b> -> M<'c> \n```", "```\nlet makeLiveRightLowerArm (DeadRightLowerArm label) = \n    let becomeAlive vitalForce = \n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveRightLowerArm = LiveRightLowerArm (label,oneUnit)\n        liveRightLowerArm, remainingVitalForce    \n    M becomeAlive\n\nlet makeLiveRightUpperArm (DeadRightUpperArm label) = \n    let becomeAlive vitalForce = \n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveRightUpperArm = LiveRightUpperArm (label,oneUnit)\n        liveRightUpperArm, remainingVitalForce    \n    M becomeAlive \n```", "```\nlet deadRightLowerArm = DeadRightLowerArm \"Tom\"\nlet lowerRightArmM = makeLiveRightLowerArm deadRightLowerArm \n\nlet deadRightUpperArm = DeadRightUpperArm \"Jerry\"\nlet upperRightArmM = makeLiveRightUpperArm deadRightUpperArm \n```", "```\nlet armSurgeryM  = map2M armSurgery \nlet rightArmM = armSurgeryM lowerRightArmM upperRightArmM \n```", "```\nlet vf = {units = 10}\n\nlet liveRightArm, remainingFromRightArm = runM rightArmM vf \n```", "```\nval liveRightArm : LiveRightArm =\n    {lowerArm = LiveRightLowerArm (\"Tom\",{units = 1;});\n     upperArm = LiveRightUpperArm (\"Jerry\",{units = 1;});}\n\nval remainingFromRightArm : VitalForce = \n    {units = 8;} \n```", "```\ntype DeadBrain = DeadBrain of Label \ntype Skull = Skull of Label \n```", "```\ntype LiveBrain = LiveBrain of Label * VitalForce\n\ntype LiveHead = {\n    brain : LiveBrain\n    skull : Skull // not live\n    } \n```", "```\nlet headSurgery brain skull =\n    {brain=brain; skull=skull} \n```", "```\nlet wrapSkullInM skull = \n    let becomeAlive vitalForce = \n        skull, vitalForce \n    M becomeAlive \n```", "```\nval wrapSkullInM : 'a -> M<'a> \n```", "```\nlet returnM x = \n    let becomeAlive vitalForce = \n        x, vitalForce \n    M becomeAlive \n```", "```\nlet makeLiveBrain (DeadBrain label) = \n    let becomeAlive vitalForce = \n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveBrain = LiveBrain (label,oneUnit)\n        liveBrain, remainingVitalForce    \n    M becomeAlive \n```", "```\nlet deadBrain = DeadBrain \"Abby Normal\"\nlet skull = Skull \"Yorick\" \n```", "```\nlet liveBrainM = makeLiveBrain deadBrain\nlet skullM = returnM skull \n```", "```\nlet headSurgeryM = map2M headSurgery\nlet headM = headSurgeryM liveBrainM skullM \n```", "```\nlet vf = {units = 10}\n\nlet liveHead, remainingFromHead = runM headM vf \n```", "```\nval liveHead : LiveHead = \n    {brain = LiveBrain (\"Abby normal\",{units = 1;});\n    skull = Skull \"Yorick\";}\n\nval remainingFromHead : VitalForce = \n    {units = 9;} \n```", "```\ntype DeadHeart = DeadHeart of Label \ntype LiveHeart = LiveHeart of Label * VitalForce \n```", "```\ntype BeatingHeart = BeatingHeart of LiveHeart * VitalForce \n```", "```\nlet makeLiveHeart (DeadHeart label) = \n    let becomeAlive vitalForce = \n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveHeart = LiveHeart (label,oneUnit)\n        liveHeart, remainingVitalForce    \n    M becomeAlive \n```", "```\nlet makeBeatingHeart liveHeart = \n\n    let becomeAlive vitalForce = \n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let beatingHeart = BeatingHeart (liveHeart, oneUnit)\n        beatingHeart, remainingVitalForce    \n    M becomeAlive \n```", "```\nval makeLiveHeart : DeadHeart -> M<LiveHeart>\nval makeBeatingHeart : LiveHeart -> M<BeatingHeart> \n```", "```\nlet makeBeatingHeartFromLiveHeartM liveHeartM = \n\n    let becomeAlive vitalForce = \n        // extract the liveHeart from liveHeartM \n        let liveHeart, remainingVitalForce = runM liveHeartM vitalForce \n\n        // use the liveHeart to create a beatingHeartM\n        let beatingHeartM = makeBeatingHeart liveHeart\n\n        // what goes here?\n\n        // return a beatingHeart and remaining vital force \n        beatingHeart, remainingVitalForce    \n\n    M becomeAlive \n```", "```\nlet makeBeatingHeartFromLiveHeartM liveHeartM = \n\n    let becomeAlive vitalForce = \n        // extract the liveHeart from liveHeartM \n        let liveHeart, remainingVitalForce = runM liveHeartM vitalForce \n\n        // use the liveHeart to create a beatingHeartM\n        let beatingHeartM = makeBeatingHeart liveHeart\n\n        // run beatingHeartM to get a beatingHeart\n        let beatingHeart, remainingVitalForce2 = runM beatingHeartM remainingVitalForce \n\n        // return a beatingHeart and remaining vital force \n        beatingHeart, remainingVitalForce2    \n\n    // wrap the inner function and return it \n    M becomeAlive \n```", "```\nM<LiveHeart> -> M<BeatingHeart> \n```", "```\nlet bindM f bodyPartM = \n    let becomeAlive vitalForce = \n        let bodyPart, remainingVitalForce = runM bodyPartM vitalForce \n        let newBodyPartM = f bodyPart \n        let newBodyPart, remainingVitalForce2 = runM newBodyPartM remainingVitalForce \n        newBodyPart, remainingVitalForce2    \n    M becomeAlive \n```", "```\nf:('a -> M<'b>) -> M<'a> -> M<'b> \n```", "```\nlet bindM f bodyPartM = \n    let becomeAlive vitalForce = \n        let bodyPart, remainingVitalForce = runM bodyPartM vitalForce \n        runM (f bodyPart) remainingVitalForce \n    M becomeAlive \n```", "```\n// create a dead heart\nlet deadHeart = DeadHeart \"Anne\"\n\n// create a live heart generator (M<LiveHeart>)\nlet liveHeartM = makeLiveHeart deadHeart\n\n// create a beating heart generator (M<BeatingHeart>)\n// from liveHeartM and the makeBeatingHeart function\nlet beatingHeartM = bindM makeBeatingHeart liveHeartM \n```", "```\nlet beatingHeartM = \n   DeadHeart \"Anne\"\n   |> makeLiveHeart \n   |> bindM makeBeatingHeart \n```", "```\nlet beatingHeartM =\n    DeadHeart \"Anne\" \n    |> makeLiveHeart \n    |> bindM makeBeatingHeart \n```", "```\nlet vf = {units = 10}\n\nlet beatingHeart, remainingFromHeart = runM beatingHeartM vf \n```", "```\nval beatingHeart : BeatingHeart = \n    BeatingHeart (LiveHeart (\"Anne\",{units = 1;}),{units = 1;})\n\nval remainingFromHeart : VitalForce = \n    {units = 8;} \n```", "```\ntype LiveBody = {\n    leftLeg: LiveLeftLeg\n    rightLeg : LiveLeftLeg\n    leftArm : LiveLeftArm\n    rightArm : LiveRightArm\n    head : LiveHead\n    heart : BeatingHeart\n    } \n```", "```\nlet map3M f m1 m2 m3 =\n    let becomeAlive vitalForce = \n        let v1,remainingVitalForce = runM m1 vitalForce \n        let v2,remainingVitalForce2 = runM m2 remainingVitalForce  \n        let v3,remainingVitalForce3 = runM m3 remainingVitalForce2  \n        let v4 = f v1 v2 v3\n        v4, remainingVitalForce3    \n    M becomeAlive \n```", "```\nval createBody : \n    leftLeg:LiveLeftLeg ->\n    rightLeg:LiveLeftLeg ->\n    leftArm:LiveLeftArm ->\n    rightArm:LiveRightArm ->\n    head:LiveHead -> \n    beatingHeart:BeatingHeart -> \n    LiveBody \n```", "```\nval createBody : \n    leftLeg:LiveLeftLeg -> (five param function) \n```", "```\n(six param function) apply (first parameter) returns (five param function) \n```", "```\n rightLeg:LiveLeftLeg ->\n    leftArm:LiveLeftArm ->\n    rightArm:LiveRightArm ->\n    head:LiveHead -> \n    beatingHeart:BeatingHeart -> \n    LiveBody \n```", "```\n rightLeg:LiveLeftLeg -> (four parameter function) \n```", "```\n(five param function) apply (first parameter) returns (four param function) \n```", "```\n leftArm:LiveLeftArm ->\n    rightArm:LiveRightArm ->\n    head:LiveHead -> \n    beatingHeart:BeatingHeart -> \n    LiveBody \n```", "```\n// normal version\n(six param function) apply (first parameter) returns (five param function)\n\n// M-world version\nM<six param function> applyM M<first parameter> returns M<five param function> \n```", "```\n// normal version\n(five param function) apply (first parameter) returns (four param function)\n\n// M-world version\nM<five param function> applyM M<first parameter> returns M<four param function> \n```", "```\nlet applyM mf mx =\n    let becomeAlive vitalForce = \n        let f,remainingVitalForce = runM mf vitalForce \n        let x,remainingVitalForce2 = runM mx remainingVitalForce  \n        let y = f x\n        y, remainingVitalForce2    \n    M becomeAlive \n```", "```\nlet createBody leftLeg rightLeg leftArm rightArm head beatingHeart =\n    {\n    leftLeg = leftLeg\n    rightLeg = rightLeg\n    leftArm = leftArm\n    rightArm = rightArm\n    head = head\n    heart = beatingHeart \n    } \n```", "```\nlet rightLegM = leftLegM \n```", "```\n// move createBody to M-world -- a six parameter function wrapped in an M\nlet fSixParamM = returnM createBody           \n\n// apply first M-param to get a five parameter function wrapped in an M\nlet fFiveParamM = applyM fSixParamM leftLegM   \n\n// apply second M-param to get a four parameter function wrapped in an M\nlet fFourParamM = applyM fFiveParamM rightLegM \n\n// etc\nlet fThreeParamM = applyM fFourParamM leftArmM\nlet fTwoParamM = applyM fThreeParamM rightArmM\nlet fOneParamM = applyM fTwoParamM headM \n\n// after last application, the result is a M<LiveBody>\nlet bodyM = applyM fOneParamM beatingHeartM \n```", "```\nlet (<*>) = applyM \n```", "```\nlet bodyM = \n    returnM createBody \n    <*> leftLegM\n    <*> rightLegM\n    <*> leftArmM\n    <*> rightArmM\n    <*> headM \n    <*> beatingHeartM \n```", "```\nlet (<!>) = mapM \n```", "```\nlet bodyM = \n    createBody \n    <!> leftLegM\n    <*> rightLegM\n    <*> leftArmM\n    <*> rightArmM\n    <*> headM \n    <*> beatingHeartM \n```", "```\nlet vf = {units = 10}\n\nlet liveBody, remainingFromBody = runM bodyM vf \n```", "```\nval liveBody : LiveBody =\n  {leftLeg = LiveLeftLeg (\"Boris\",{units = 1;});\n   rightLeg = LiveLeftLeg (\"Boris\",{units = 1;});\n   leftArm = LiveLeftArm (\"Victor\",{units = 1;});\n   rightArm = {lowerArm = LiveRightLowerArm (\"Tom\",{units = 1;});\n               upperArm = LiveRightUpperArm (\"Jerry\",{units = 1;});};\n   head = {brain = LiveBrain (\"Abby Normal\",{units = 1;});\n           skull = Skull \"Yorick\";};\n   heart = BeatingHeart (LiveHeart (\"Anne\",{units = 1;}),{units = 1;});}\n\nval remainingFromBody : VitalForce = {units = 2;} \n```", "```\ntype M<'a> = M of (VitalForce -> 'a * VitalForce) \n```", "```\nval mapM : f:('a -> 'b) -> M<'a> -> M<'b> \n```", "```\nval map2M : f:('a -> 'b -> 'c) -> M<'a> -> M<'b> -> M<'c> \n```", "```\nval returnM : 'a -> M<'a> \n```", "```\nval monadicFunction : 'a -> M<'b> \n```", "```\nval makeLiveLeftLeg : DeadLeftLeg -> M<LiveLeftLeg>\nval makeLiveRightLowerArm : DeadRightLowerArm -> M<LiveRightLowerArm>\nval makeLiveHeart : DeadHeart -> M<LiveHeart>\nval makeBeatingHeart : LiveHeart -> M<BeatingHeart>\n// and also\nval returnM : 'a -> M<'a> \n```", "```\nval bindM : f:('a -> M<'b>) -> M<'a> -> M<'b> \n```", "```\nval applyM : M<('a -> 'b)> -> M<'a> -> M<'b> \n```", "```\nlet makeLiveLeftLegM deadLeftLeg  = \n    let becomeAlive vitalForce = \n        let (DeadLeftLeg label) = deadLeftLeg\n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveLeftLeg = LiveLeftLeg (label,oneUnit)\n        liveLeftLeg, remainingVitalForce    \n    M becomeAlive  // wrap the function in a single case union \n```", "```\ntype MonsterBuilder()=\n    member this.Return(x) = returnM x\n    member this.Bind(xM,f) = bindM f xM \n```", "```\nlet monster = new MonsterBuilder() \n```", "```\nmonster {\n    let! x = xM  // unwrap an M<X> into an X and bind to \"x\"\n    return y     // wrap a Y and return an M<Y>\n    } \n```", "```\nlet mapM f xM = \n    monster {\n        let! x = xM  // unwrap the M<X>\n        return f x   // return M of (f x)\n        } \n```", "```\nval mapM : f:('a -> 'b) -> M<'a> -> M<'b> \n```", "```\nlet map2M f xM yM = \n    monster {\n        let! x = xM  // unwrap M<X>\n        let! y = yM  // unwrap M<Y>\n        return f x y // return M of (f x y)\n        } \n```", "```\nval map2M : f:('a -> 'b -> 'c) -> M<'a> -> M<'b> -> M<'c> \n```", "```\nlet applyM fM xM = \n    monster {\n        let! f = fM  // unwrap M<F>\n        let! x = xM  // unwrap M<X>\n        return f x   // return M of (f x)\n        } \n```", "```\nval applyM : M<('a -> 'b)> -> M<'a> -> M<'b> \n```", "```\n// extract a unit of vital force from the context \nlet oneUnit, remainingVitalForce = getVitalForce vitalForce \n\n// do something\n\n// return value and remaining vital force \nliveBodyPart, remainingVitalForce \n```", "```\nlet getM = \n    let doSomethingWhileLive vitalForce = \n        // what here ??\n        what to return??, vitalForce \n    M doSomethingWhileLive \n```", "```\nlet getM = \n    let doSomethingWhileLive vitalForce = \n        // return the current vital force in the first element of the tuple\n        vitalForce, vitalForce \n    M doSomethingWhileLive \n```", "```\nmonster {\n    let! vitalForce = getM\n    // do something with vital force\n    } \n```", "```\nlet putM newVitalForce  = \n    let doSomethingWhileLive vitalForce = \n        what here ??\n    M doSomethingWhileLive \n```", "```\nlet putM newVitalForce  = \n    let doSomethingWhileLive vitalForce = \n        // return nothing in the first element of the tuple\n        // return the newVitalForce in the second element of the tuple\n        (), newVitalForce\n    M doSomethingWhileLive \n```", "```\nlet useUpOneUnitM = \n    monster {\n        let! vitalForce = getM\n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        do! putM remainingVitalForce \n        return oneUnit\n        } \n```", "```\nlet makeLiveLeftLegM deadLeftLeg  = \n    let becomeAlive vitalForce = \n        let (DeadLeftLeg label) = deadLeftLeg\n        let oneUnit, remainingVitalForce = getVitalForce vitalForce \n        let liveLeftLeg = LiveLeftLeg (label,oneUnit)\n        liveLeftLeg, remainingVitalForce    \n    M becomeAlive  // wrap the function in a single case union \n```", "```\nlet makeLiveLeftLegM deadLeftLeg = \n    monster {\n        let (DeadLeftLeg label) = deadLeftLeg\n        let! oneUnit = useUpOneUnitM\n        return LiveLeftLeg (label,oneUnit)\n        } \n```", "```\nlet makeLiveRightLowerArm (DeadRightLowerArm label) = \n    monster {\n        let! oneUnit = useUpOneUnitM\n        return LiveRightLowerArm (label,oneUnit)\n        }\n\nlet makeLiveRightUpperArm (DeadRightUpperArm label) = \n    monster {\n        let! oneUnit = useUpOneUnitM\n        return LiveRightUpperArm (label,oneUnit)\n        }\n\n// create the M-parts\nlet lowerRightArmM = DeadRightLowerArm \"Tom\" |> makeLiveRightLowerArm \nlet upperRightArmM = DeadRightUpperArm \"Jerry\" |> makeLiveRightUpperArm \n\n// turn armSurgery into an M-function \nlet armSurgeryM  = map2M armSurgery \n\n// do surgery to combine the two M-parts into a new M-part\nlet rightArmM = armSurgeryM lowerRightArmM upperRightArmM \n```", "```\nlet rightArmM = monster {\n    let! lowerArm = DeadRightLowerArm \"Tom\" |> makeLiveRightLowerArm \n    let! upperArm = DeadRightUpperArm \"Jerry\" |> makeLiveRightUpperArm \n    return {lowerArm=lowerArm; upperArm=upperArm}\n    } \n```", "```\nlet headM = monster {\n    let! brain = makeLiveBrain deadBrain\n    return {brain=brain; skull=skull}\n    } \n```", "```\n// a function to create a M-body given all the M-parts\nlet createBodyM leftLegM rightLegM leftArmM rightArmM headM beatingHeartM = \n    monster {\n        let! leftLeg = leftLegM\n        let! rightLeg = rightLegM\n        let! leftArm = leftArmM\n        let! rightArm = rightArmM\n        let! head = headM \n        let! beatingHeart = beatingHeartM\n\n        // create the record\n        return {\n            leftLeg = leftLeg\n            rightLeg = rightLeg\n            leftArm = leftArm\n            rightArm = rightArm\n            head = head\n            heart = beatingHeart \n            }\n        }\n\n// create the M-body \nlet bodyM = createBodyM leftLegM rightLegM leftArmM rightArmM headM beatingHeartM \n```", "```\nlet createBody leftLeg rightLeg leftArm rightArm head beatingHeart =\n    {\n    leftLeg = leftLeg\n    rightLeg = rightLeg\n    leftArm = leftArm\n    rightArm = rightArm\n    head = head\n    heart = beatingHeart \n    }\n\nlet bodyM = \n    createBody \n    <!> leftLegM\n    <*> rightLegM\n    <*> leftArmM\n    <*> rightArmM\n    <*> headM \n    <*> beatingHeartM \n```", "```\ntype S<'State,'Value> = \n    S of ('State -> 'Value * 'State) \n```", "```\n// encapsulate the function call that \"runs\" the state\nlet runS (S f) state = f state\n\n// lift a value to the S-world \nlet returnS x = \n    let run state = \n        x, state\n    S run\n\n// lift a monadic function to the S-world \nlet bindS f xS = \n    let run state = \n        let x, newState = runS xS state\n        runS (f x) newState \n    S run \n```", "```\nval runS : S<'a,'b> -> 'a -> 'b * 'a\nval bindS : f:('a -> S<'b,'c>) -> S<'b,'a> -> S<'b,'c> \n```", "```\ntype StateBuilder()=\n    member this.Return(x) = returnS x\n    member this.Bind(xS,f) = bindS f xS\n\nlet state = new StateBuilder() \n```", "```\nlet getS = \n    let run state = \n        // return the current state in the first element of the tuple\n        state, state\n    S run\n// val getS : S<State> \n\nlet putS newState = \n    let run _ = \n        // return nothing in the first element of the tuple\n        // return the newState in the second element of the tuple\n        (), newState\n    S run\n// val putS : 'State -> S<unit> \n```", "```\n// combine get and put to extract one unit\nlet useUpOneUnitS = state {\n    let! vitalForce = getS\n    let oneUnit, remainingVitalForce = getVitalForce vitalForce \n    do! putS remainingVitalForce \n    return oneUnit\n    }\n\ntype DeadLeftLeg = DeadLeftLeg of Label \ntype LiveLeftLeg = LiveLeftLeg of Label * VitalForce\n\n// new version with implicit handling of vital force\nlet makeLiveLeftLeg (DeadLeftLeg label) = state {\n    let! oneUnit = useUpOneUnitS\n    return LiveLeftLeg (label,oneUnit)\n    } \n```", "```\ntype DeadHeart = DeadHeart of Label \ntype LiveHeart = LiveHeart of Label * VitalForce\ntype BeatingHeart = BeatingHeart of LiveHeart * VitalForce\n\nlet makeLiveHeart (DeadHeart label) = state {\n    let! oneUnit = useUpOneUnitS\n    return LiveHeart (label,oneUnit)\n    }\n\nlet makeBeatingHeart liveHeart = state {\n    let! oneUnit = useUpOneUnitS\n    return BeatingHeart (liveHeart,oneUnit)\n    }\n\nlet beatingHeartS = state {\n    let! liveHeart = DeadHeart \"Anne\" |> makeLiveHeart \n    return! makeBeatingHeart liveHeart\n    }\n\nlet beatingHeart, remainingFromHeart = runS beatingHeartS vf \n```", "```\n// define the type to use as the state\ntype Stack<'a> = Stack of 'a list\n\n// define pop outside of state expressions\nlet popStack (Stack contents) = \n    match contents with\n    | [] -> failwith \"Stack underflow\"\n    | head::tail ->     \n        head, (Stack tail)\n\n// define push outside of state expressions\nlet pushStack newTop (Stack contents) = \n    Stack (newTop::contents)\n\n// define an empty stack\nlet emptyStack = Stack []\n\n// get the value of the stack when run \n// starting with the empty stack\nlet getValue stackM = \n    runS stackM emptyStack |> fst \n```", "```\nlet pop() = state {\n    let! stack = getS\n    let top, remainingStack = popStack stack\n    do! putS remainingStack \n    return top\n    }\n\nlet push newTop = state {\n    let! stack = getS\n    let newStack = pushStack newTop stack\n    do! putS newStack \n    return ()\n    } \n```", "```\nlet helloWorldS = state {\n    do! push \"world\"\n    do! push \"hello\" \n    let! top1 = pop()\n    let! top2 = pop()\n    let combined = top1 + \" \" + top2 \n    return combined \n    }\n\nlet helloWorld = getValue helloWorldS // \"hello world\" \n```", "```\nlet one = state {do! push 1}\nlet two = state {do! push 2}\n\nlet add = state {\n    let! top1 = pop()\n    let! top2 = pop()\n    do! push (top1 + top2)\n    } \n```", "```\nlet three = state {\n    do! one\n    do! two\n    do! add\n    }\n\nlet five = state {\n    do! two\n    do! three\n    do! add\n    } \n```", "```\nlet calculate stackOperations = state {\n    do! stackOperations\n    let! top = pop()\n    return top \n    } \n```", "```\nlet threeN = calculate three |> getValue // 3\n\nlet fiveN = calculate five |> getValue   // 5 \n```"]