- en: Thirteen ways of looking at a turtle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于乌龟的十三种观察方式
- en: Thirteen ways of looking at a turtle
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于乌龟的十三种观察方式
- en: This post is part of the [F# Advent Calendar in English 2015](https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/)
    project. Check out all the other great posts there! And special thanks to Sergey
    Tihon for organizing this.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本文是[F#英文版 2015 年圣诞日历](https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/)项目的一部分。请查看那里的所有其他精彩文章！特别感谢
    Sergey Tihon 组织此活动。
- en: I was discussing how to implement a simple [turtle graphics system](https://en.wikipedia.org/wiki/Turtle_graphics)
    some time ago, and it struck me that, because the turtle requirements are so simple
    and so well known, it would make a great basis for demonstrating a range of different
    techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，我正在讨论如何实现一个简单的[turtle graphics system](https://en.wikipedia.org/wiki/Turtle_graphics)，我突然意识到，由于乌龟的需求如此简单且众所周知，它将成为展示各种不同技术的绝佳基础。
- en: 'So, in this two part mega-post, I''ll stretch the turtle model to the limit
    while demonstrating things like: partial application, validation with Success/Failure
    results, the concept of "lifting", agents with message queues, dependency injection,
    the State monad, event sourcing, stream processing, and finally a custom interpreter!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这两部分的超级帖子中，我将极限展示乌龟模型，同时演示诸如：部分应用、使用成功/失败结果进行验证、"lifting" 概念、带有消息队列的代理、依赖注入、State
    monad、事件溯源、流处理，最后是自定义解释器！
- en: 'Without further ado then, I hereby present thirteen different ways of implementing
    a turtle:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我在此呈现十三种不同的乌龟实现方式，不再拖泥带水：
- en: '[Way 1\. A basic object-oriented approach](13-ways-of-looking-at-a-turtle.html#way1),
    in which we create a class with mutable state.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第一种方式：基本的面向对象方法](13-ways-of-looking-at-a-turtle.html#way1)，在这种方式中，我们创建了一个具有可变状态的类。'
- en: '[Way 2\. A basic functional approach](13-ways-of-looking-at-a-turtle.html#way2),
    in which we create a module of functions with immutable state.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二种方式：基本的函数式方法](13-ways-of-looking-at-a-turtle.html#way2)，在这种方式中，我们创建了一个具有不可变状态的函数模块。'
- en: '[Way 3\. An API with a object-oriented core](13-ways-of-looking-at-a-turtle.html#way3),
    in which we create an object-oriented API that calls a stateful core class.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第三种方式：具有面向对象核心的 API](13-ways-of-looking-at-a-turtle.html#way3)，在这种方式中，我们创建了一个面向对象的
    API，调用一个有状态核心类。'
- en: '[Way 4\. An API with a functional core](13-ways-of-looking-at-a-turtle.html#way4),
    in which we create an stateful API that uses stateless core functions.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第四种方式：具有功能核心的 API](13-ways-of-looking-at-a-turtle.html#way4)，在这种方式中，我们创建了一个使用无状态核心函数的有状态
    API。'
- en: '[Way 5\. An API in front of an agent](13-ways-of-looking-at-a-turtle.html#way5),
    in which we create an API that uses a message queue to communicate with an agent.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第五种方式：代理前端的 API](13-ways-of-looking-at-a-turtle.html#way5)，在这种方式中，我们创建了一个使用消息队列与代理通信的
    API。'
- en: '[Way 6\. Dependency injection using interfaces](13-ways-of-looking-at-a-turtle.html#way6),
    in which we decouple the implementation from the API using an interface or record
    of functions.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第六种方式：使用接口进行依赖注入](13-ways-of-looking-at-a-turtle.html#way6)，在这种方式中，我们通过接口或函数记录将实现与
    API 解耦。'
- en: '[Way 7\. Dependency injection using functions](13-ways-of-looking-at-a-turtle.html#way7),
    in which we decouple the implementation from the API by passing a function parameter.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第七种方式：使用函数进行依赖注入](13-ways-of-looking-at-a-turtle.html#way7)，在这种方式中，我们通过传递函数参数来将实现与
    API 解耦。'
- en: '[Way 8\. Batch processing using a state monad](13-ways-of-looking-at-a-turtle.html#way8),
    in which we create a special "turtle workflow" computation expression to track
    state for us.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第八种方式：使用状态单子进行批处理](13-ways-of-looking-at-a-turtle.html#way8)，在这种方式中，我们创建了一个特殊的"乌龟工作流"计算表达式来跟踪状态。'
- en: '[Way 9\. Batch processing using command objects](13-ways-of-looking-at-a-turtle.html#way9),
    in which we create a type to represent a turtle command, and then process a list
    of commands all at once.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第九种方式：使用命令对象进行批处理](13-ways-of-looking-at-a-turtle.html#way9)，在这种方式中，我们创建了一种表示乌龟命令的类型，然后一次处理所有命令的列表。'
- en: '[Interlude: Conscious decoupling with data types](13-ways-of-looking-at-a-turtle.html#decoupling).
    A few notes on using data vs. interfaces for decoupling.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[插曲：使用数据类型进行有意识的解耦](13-ways-of-looking-at-a-turtle.html#decoupling)。关于使用数据与接口进行解耦的一些注意事项。'
- en: '[Way 10\. Event sourcing](13-ways-of-looking-at-a-turtle-2.html#way10), in
    which state is built from a list of past events.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第十种方式：事件溯源](13-ways-of-looking-at-a-turtle-2.html#way10)，在这种方式中，状态是从过去事件列表中构建的。'
- en: '[Way 11\. Functional Retroactive Programming (stream processing)](13-ways-of-looking-at-a-turtle-2.html#way11),
    in which business logic is based on reacting to earlier events.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方式 11\. 函数式后时代编程（流处理）](13-ways-of-looking-at-a-turtle-2.html#way11)，在其中业务逻辑基于对早期事件的反应。'
- en: '[Episode V: The Turtle Strikes Back](13-ways-of-looking-at-a-turtle-2.html#strikes-back),
    in which the turtle API changes so that some commands may fail.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第五集：海龟反击](13-ways-of-looking-at-a-turtle-2.html#strikes-back)，在其中海龟 API 发生变化，以至于一些命令可能失败。'
- en: '[Way 12\. Monadic control flow](13-ways-of-looking-at-a-turtle-2.html#way12),
    in which we make decisions in the turtle workflow based on results from earlier
    commands.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方式 12\. 单子式控制流](13-ways-of-looking-at-a-turtle-2.html#way12)，在其中根据早期命令的结果来决定海龟工作流程中的决策。'
- en: '[Way 13\. A turtle interpreter](13-ways-of-looking-at-a-turtle-2.html#way13),
    in which we completely decouple turtle programming from turtle implementation,
    and nearly encounter the free monad.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方式 13\. 一个海龟解释器](13-ways-of-looking-at-a-turtle-2.html#way13)，在其中我们完全将海龟编程与海龟实现解耦，并且几乎遇到了自由单子。'
- en: '[Review of all the techniques used](13-ways-of-looking-at-a-turtle-2.html#review).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[所有技术的回顾](13-ways-of-looking-at-a-turtle-2.html#review)。'
- en: 'and 2 bonus ways for the extended edition:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种扩展版的奖励方式：
- en: '[Way 14\. Abstract Data Turtle](13-ways-of-looking-at-a-turtle-3.html#way14),
    in which we encapsulate the details of a turtle implementation by using an Abstract
    Data Type.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方式 14\. 抽象数据海龟](13-ways-of-looking-at-a-turtle-3.html#way14)，在其中我们通过使用抽象数据类型封装了海龟实现的细节。'
- en: '[Way 15\. Capability-based Turtle](13-ways-of-looking-at-a-turtle-3.html#way15),
    in which we control what turtle functions are available to a client, based on
    the current state of the turtle.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方式 15\. 基于能力的海龟](13-ways-of-looking-at-a-turtle-3.html#way15)，在其中我们根据海龟的当前状态控制客户端可用的海龟函数。'
- en: All source code for this post is available [on github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的所有源代码都可以在 [github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle)
    上找到。
- en: '* * *'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The requirements for a Turtle
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个海龟的要求
- en: 'A turtle supports four instructions:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个海龟支持四个指令：
- en: Move some distance in the current direction.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前方向上移动一定距离。
- en: Turn a certain number of degrees clockwise or anticlockwise.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺时针或逆时针转动一定角度。
- en: Put the pen down or up. When the pen is down, moving the turtle draws a line.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放下或抬起画笔。当画笔放下时，移动海龟会画一条线。
- en: Set the pen color (one of black, blue or red).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置画笔颜色（黑色、蓝色或红色中的一种）。
- en: 'These requirements lead naturally to some kind of "turtle interface" like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需求自然地导致了一种类似于"海龟接口"的东西：
- en: '`Move aDistance`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Move aDistance`'
- en: '`Turn anAngle`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Turn anAngle`'
- en: '`PenUp`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PenUp`'
- en: '`PenDown`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PenDown`'
- en: '`SetColor aColor`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetColor aColor`'
- en: All of the following implementations will be based on this interface or some
    variant of it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以下实现都将基于此接口或其某个变体。
- en: Note that the turtle must convert these instructions to drawing lines on a canvas
    or other graphics context. So the implementation will probably need to keep track
    of the turtle position and current state somehow.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，海龟必须将这些指令转换为在画布或其他图形上绘制线条。因此，实现可能需要以某种方式跟踪海龟的位置和当前状态。
- en: '* * *'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Common code
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共代码
- en: Before we start implementing, let's get some common code out of the way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现之前，让我们先处理一些公共代码。
- en: First, we'll need some types to represent distances, angles, the pen state,
    and the pen colors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些类型来表示距离、角度、笔的状态和笔的颜色。
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'and we''ll also need a type to represent the position of the turtle:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要一个类型来表示海龟的位置：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''ll also need a helper function to calculate a new position based on moving
    a certain distance at a certain angle:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个辅助函数来计算基于在某个角度移动一定距离后的新位置：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s also define the initial state of a turtle:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义海龟的初始状态：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And a helper that pretends to draw a line on a canvas:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个模拟在画布上画线的辅助函数：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we're ready for the first implementation!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好进行第一次实现了！
- en: '* * *'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1\. Basic OO -- A class with mutable state
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 基本面向对象 -- 一个具有可变状态的类
- en: In this first design, we will use an object-oriented approach and represent
    the turtle with a simple class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个首次设计中，我们将采用面向对象的方法，并用一个简单的类来表示海龟。
- en: The state will be stored in local fields (`currentPosition`, `currentAngle`,
    etc) that are mutable.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态将存储在本地字段（`currentPosition`、`currentAngle` 等）中，这些字段是可变的。
- en: We will inject a logging function `log` so that we can monitor what happens.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将注入一个日志记录函数 `log`，以便我们可以监视发生的情况。
- en: '![](turtle-oo.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-oo.png)'
- en: 'And here''s the complete code, which should be self-explanatory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的代码，应该是不言自明的：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Calling the turtle object
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用乌龟对象
- en: 'The client code instantiates the turtle and talks to it directly:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码实例化乌龟并直接与其交互：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The logged output of `drawTriangle()` is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawTriangle()`的记录输出为：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, here''s the code to draw a polygon:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这是绘制多边形的代码：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `drawOneSide()` does not return anything -- all the code is imperative
    and stateful. Compare this to the code in the next example, which takes a pure
    functional approach.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`drawOneSide()`不返回任何东西 - 所有代码都是命令式和有状态的。将其与下一个示例中采用纯函数式方法的代码进行比较。
- en: Advantages and disadvantages
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: So what are the advantages and disadvantages of this simple approach?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这种简单方法的优缺点是什么呢？
- en: '*Advantages*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: It's very easy to implement and understand.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这非常容易实现和理解。
- en: '*Disadvantages*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: The stateful code is harder to test. We have to put an object into a known state
    state before testing, which is simple in this case, but can be long-winded and
    error-prone for more complex objects.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态的代码更难测试。在测试之前，我们必须将对象置于已知状态之中，对于更复杂的对象来说，这可能会很啰嗦且容易出错。
- en: The client is coupled to a particular implementation. No interfaces here! We'll
    look at using interfaces shortly.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端与特定实现耦合。这里没有接口！我们将很快看到如何使用接口。
- en: '*The source code for this version is available [here (turtle class)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/OOTurtleLib.fsx)
    and [here (client)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/01-OOTurtle.fsx).*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个版本的源代码可以在[这里（乌龟类）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/OOTurtleLib.fsx)和[这里（客户端）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/01-OOTurtle.fsx)找到。*'
- en: '* * *'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '2: Basic FP - A module of functions with immutable state'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2: 基本FP - 一个带有不可变状态的函数模块'
- en: The next design will use a pure, functional approach. An immutable `TurtleState`
    is defined, and then the various turtle functions accept a state as input and
    return a new state as output.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个设计将使用纯函数式方法。定义了一个不可变的`TurtleState`，然后各种乌龟函数接受状态作为输入并返回新的状态作为输出。
- en: In this approach then, the client is responsible for keeping track of the current
    state and passing it into the next function call.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，客户端负责跟踪当前状态并将其传递给下一个函数调用。
- en: '![](turtle-fp.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-fp.png)'
- en: 'Here''s the definition of `TurtleState` and the values for the initial state:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`TurtleState`的定义以及初始状态的值：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here are the "api" functions, all of which take a state parameter and return
    a new state:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是"api"函数，它们全部接受一个状态参数并返回一个新的状态：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the `state` is always the last parameter -- this makes it easier to
    use the "piping" idiom.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`state`始终是最后一个参数 - 这样使用"管道"习语更容易。
- en: Using the turtle functions
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用乌龟函数
- en: The client now has to pass in both the `log` function and the `state` to every
    function, every time!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端必须每次在每个函数中传递`log`函数和`state`！
- en: 'We can eliminate the need to pass in the log function by using partial application
    to create new versions of the functions with the logger baked in:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用偏函数应用来创建带有记录器的新函数版本，我们可以消除传递日志函数的需要：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With these simpler versions, the client can just pipe the state through in
    a natural way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些更简单的版本，客户端只需以自然的方式传递状态：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When it comes to drawing a polygon, it''s a little more complicated, as we
    have to "fold" the state through the repetitions for each side:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及绘制多边形时，情况会稍微复杂一些，因为我们必须通过每个边的重复来"折叠"状态：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Advantages and disadvantages
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: What are the advantages and disadvantages of this purely functional approach?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种纯函数式方法的优缺点是什么呢？
- en: '*Advantages*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Again, it's very easy to implement and understand.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，这种方法非常容易实现和理解。
- en: The stateless functions are easier to test. We always provide the current state
    as input, so there is no setup needed to get an object into a known state.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态函数更易于测试。我们始终将当前状态提供为输入，因此无需设置即可将对象置于已知状态。
- en: Because there is no global state, the functions are modular and can be reused
    in other contexts (as we'll see later in this post).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有全局状态，这些函数是模块化的，并且可以在其他上下文中重用（正如我们稍后在本文中将看到的那样）。
- en: '*Disadvantages*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: As before, the client is coupled to a particular implementation.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与以前一样，客户端与特定实现耦合。
- en: The client has to keep track of the state (but some solutions to make this easier
    are shown later in this post).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须跟踪状态（但本文稍后将展示一些使此变得更容易的解决方案）。
- en: '*The source code for this version is available [here (turtle functions)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/FPTurtleLib.fsx)
    and [here (client)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/02-FPTurtle.fsx).*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*此版本的源代码可在 [此处（turtle functions）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/FPTurtleLib.fsx)
    和 [此处（client）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/02-FPTurtle.fsx)
    获取。*'
- en: '* * *'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '3: An API with a object-oriented core'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3: 具有面向对象核心的 API'
- en: Let's hide the client from the implementation using an API!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 API 将客户端隐藏在实现之后！
- en: In this case, the API will be string based, with text commands such as `"move
    100"` or `"turn 90"`. The API must validate these commands and turn them into
    method calls on the turtle (we'll use the OO approach of a stateful `Turtle` class
    again).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，API 将基于字符串，使用文本命令如 `"move 100"` 或 `"turn 90"`。API 必须验证这些命令并将其转换为对乌龟的方法调用（我们将再次使用具有状态的面向对象方法
    `Turtle` 类）。
- en: '![](turtle-oo-api.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-oo-api.png)'
- en: If the command is *not* valid, the API must indicate that to the client. Since
    we are using an OO approach, we'll do this by throwing a `TurtleApiException`
    containing a string, like this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令*无效*，API 必须向客户端指示此情况。由于我们使用的是面向对象的方法，我们将通过抛出一个包含字符串的 `TurtleApiException`
    来实现这一点，如下所示。
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next we need some functions that validate the command text:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些函数来验证命令文本：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With these in place, we can create the API.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就可以创建 API 了。
- en: The logic for parsing the command text is to split the command text into tokens
    and then match the first token to `"move"`, `"turn"`, etc.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 解析命令文本的逻辑是将命令文本拆分为标记，然后将第一个标记与`"move"`、`"turn"`等进行匹配。
- en: 'Here''s the code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the API
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 API
- en: 'Here''s how `drawPolygon` is implemented using the `TurtleApi` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用 `TurtleApi` 类实现 `drawPolygon` 的：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see that the code is quite similar to the earlier OO version, with the
    direct call `turtle.Move 100.0` being replaced with the indirect API call `api.Exec
    "Move 100.0"`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，代码与早期的面向对象版本非常相似，只是直接调用 `turtle.Move 100.0` 被间接的 API 调用 `api.Exec "Move
    100.0"` 替换了。
- en: 'Now if we trigger an error with a bad command such as `api.Exec "Move bad"`,
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用一个坏命令触发错误，比如 `api.Exec "Move bad"`，就像这样：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'then the expected exception is thrown:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生了预期的异常，那么异常会被抛出：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Advantages and disadvantages
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优缺点
- en: What are the advantages and disadvantages of an API layer like this?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的 API 层有何优缺点？
- en: The turtle implementation is now hidden from the client.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 龟实现现在对客户端隐藏了起来。
- en: An API at a service boundary supports validation and can be extended to support
    monitoring, internal routing, load balancing, etc.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务边界上的 API 支持验证，并且可以扩展为支持监视、内部路由、负载均衡等。
- en: '*Disadvantages*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: The API is coupled to a particular implementation, even though the client isn't.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 与特定实现耦合在一起，即使客户端没有耦合。
- en: The system is very stateful. Even though the client does not know about the
    implementation behind the API, the client is still indirectly coupled to the inner
    core via shared state which in turn can make testing harder.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统非常具有状态性。即使客户端不知道 API 背后的实现，客户端仍然通过共享状态与内核间接耦合，这反过来又会使测试变得更加困难。
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/03-Api_OO_Core.fsx).*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*此版本的源代码可在 [此处](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/03-Api_OO_Core.fsx)
    获取。*'
- en: '* * *'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '4: An API with a functional core'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4: 具有功能核心的 API'
- en: An alternative approach for this scenario is to use a hybrid design, where the
    core of the application consists of pure functions, while the boundaries are imperative
    and stateful.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种场景的另一种方法是使用混合设计，其中应用程序的核心由纯函数组成，而边界是命令式和具有状态性的。
- en: This approach has been named "Functional Core/Imperative Shell" by [Gary Bernhardt](https://www.youtube.com/watch?v=yTkzNHF6rMs).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被 [Gary Bernhardt](https://www.youtube.com/watch?v=yTkzNHF6rMs) 命名为 "Functional
    Core/Imperative Shell"。
- en: Applied to our API example, the API layer uses only pure turtle functions, but
    the API layer manages the state (rather than the client) by storing a mutable
    turtle state.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于我们的 API 示例，API 层仅使用纯龟函数，但 API 层通过存储可变龟状态来管理状态（而不是客户端）。
- en: Also, to be more functional, the API will not throw exceptions if the command
    text is not valid, but instead will return a `Result` value with `Success` and
    `Failure` cases, where the `Failure` case is used for any errors. (See [my talk
    on the functional approach to error handling](http://fsharpforfunandprofit.com/rop/)
    for a more in depth discussion of this technique).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了更加函数式，如果命令文本无效，API 将不会抛出异常，而是会返回一个带有`Success`和`Failure`情况的`Result`值，其中`Failure`情况用于任何错误。（有关此技术的更深入讨论，请参阅[我的有关函数式错误处理方法的演讲](http://fsharpforfunandprofit.com/rop/)）。
- en: '![](turtle-fp-api.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-fp-api.png)'
- en: 'Let''s start by implementing the API class. This time it contains a `mutable`
    turtle state:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现 API 类。这次它包含一个`mutable`的 turtle 状态：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The validation functions no longer throw an exception, but return `Success`
    or `Failure`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 验证函数不再抛出异常，而是返回`Success`或`Failure`：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The error cases are documented in their own type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 错误情况在它们自己的类型中有记录：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now because the validation functions now return a `Result<Distance>` rather
    than a "raw" distance, the `move` function needs to be lifted to the world of
    `Results`, as does the current state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在因为验证函数现在返回一个`Result<Distance>`而不是一个“原始”的距离，`move`函数需要被提升到`Results`的世界中，当前状态也是如此。
- en: 'There are three functions that we will use when working with `Result`s: `returnR`,
    `mapR` and `lift2R`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Result`时，有三个我们将使用的函数：`returnR`、`mapR`和`lift2R`。
- en: '`returnR` transforms a "normal" value into a value in the world of Results:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returnR`将“普通”值转换为结果世界中的值：'
- en: '![](turtle-returnR.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-returnR.png)'
- en: '`mapR` transforms a "normal" one-parameter function into a one-parameter function
    in the world of Results:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapR`将“普通”的单参数函数转换为结果世界中的单参数函数：'
- en: '![](turtle-mapR.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-mapR.png)'
- en: '`lift2R` transforms a "normal" two-parameter function into a two-parameter
    function in the world of Results:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lift2R`将“普通”的二参数函数转换为结果世界中的二参数函数：'
- en: '![](turtle-lift2R.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-lift2R.png)'
- en: 'As an example, with these helper functions, we can turn the normal `move` function
    into a function in the world of Results:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用这些辅助函数，我们可以将普通的`move`函数转换为结果世界中的函数：
- en: The distance parameter is already in `Result` world
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离参数已经在`Result`世界中
- en: The state parameter is lifted into `Result` world using `returnR`
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`returnR`将状态参数提升到`Result`世界中
- en: The `move` function is lifted into `Result` world using `lift2R`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lift2R`将`move`函数提升到`Result`世界中
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*(For more details on lifting functions to `Result` world, see the post on
    ["lifting" in general](elevated-world.html#lift) )*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*(有关将函数提升到`Result`世界的更多详细信息，请参阅有关[“lifting”在一般情况下的文章](elevated-world.html#lift)
    )*'
- en: 'Here''s the complete code for `Exec`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Exec`的完整代码：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using the API
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 API
- en: The API returns a `Result`, so the client can no longer call each function in
    sequence, as we need to handle any errors coming from a call and abandon the rest
    of the steps.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: API 返回一个`Result`，因此客户端不能再按顺序调用每个函数，因为我们需要处理来自调用的任何错误并放弃其余的步骤。
- en: To make our lives easier, we'll use a `result` computation expression (or workflow)
    to chain the calls and preserve the imperative "feel" of the OO version.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的生活更轻松，我们将使用一个`result`计算表达式（或工作流）来链接调用并保留 OO 版本的命令式“感觉”。
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*The source code for the `result` computation expression is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/Common.fsx#L70).*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*`result`计算表达式的源代码可在[此处](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/Common.fsx#L70)找到。*'
- en: Similarly, for the `drawPolygon` code, we can create a helper to draw one side
    and then call it `n` times inside a `result` expression.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于`drawPolygon`代码，我们可以创建一个辅助函数来绘制一条边，然后在`result`表达式内调用它`n`次。
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code looks imperative, but is actually purely functional, as the returned
    `Result` values are being handled transparently by the `result` workflow.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来是命令式的，但实际上是纯函数式的，因为返回的`Result`值是由`result`工作流透明地处理的。
- en: Advantages and disadvantages
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: '*Advantages*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: The same as for the OO version of an API -- the turtle implementation is hidden
    from the client, validation can be done, etc.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 API 的 OO 版本一样-- turtle 实现对客户端是隐藏的，可以进行验证等。
- en: The only stateful part of the system is at the boundary. The core is stateless
    which makes testing easier.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中唯一有状态的部分是在边界上。核心是无状态的，这使得测试更容易。
- en: '*Disadvantages*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: The API is still coupled to a particular implementation.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 仍然与特定实现耦合。
- en: '*The source code for this version is available [here (api helper functions)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/TurtleApiHelpers.fsx)
    and [here (API and client)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/04-Api_FP_Core.fsx).*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个版本的源代码在[这里（API辅助函数）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/TurtleApiHelpers.fsx)和[这里（API和客户端）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/04-Api_FP_Core.fsx)可用。*'
- en: '* * *'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '5: An API in front of an agent'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5：代理前面的API
- en: In this design, an API layer communicates with a `TurtleAgent` via a message
    queue and the client talks to the API layer as before.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，API层通过消息队列与`TurtleAgent`通信，客户端像以前一样与API层通信。
- en: '![](turtle-agent.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-agent.png)'
- en: There are no mutables in the API (or anywhere). The `TurtleAgent` manages state
    by storing the current state as a parameter in the recursive message processing
    loop.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: API（或任何地方）中没有可变的东西。`TurtleAgent`通过将当前状态存储为递归消息处理循环中的参数来管理状态。
- en: Now because the `TurtleAgent` has a typed message queue, where all messages
    are the same type, we must combine all possible commands into a single discriminated
    union type (`TurtleCommand`).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`TurtleAgent`有一个类型化的消息队列，其中所有消息都是相同类型，我们必须将所有可能的命令组合成一个单一的辨别联合类型(`TurtleCommand`)。
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The agent implementation is similar to the previous ones, but rather than exposing
    the turtle functions directly, we now do pattern matching on the incoming command
    to decide which function to call:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 代理实现与以前的实现类似，但现在我们不再直接暴露乌龟函数，而是对传入的命令进行模式匹配，以决定调用哪个函数：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sending a command to the Agent
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向代理发送命令
- en: The API calls the agent by constructing a `TurtleCommand` and posting it to
    the agent's queue.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: API通过构造`TurtleCommand`并将其发布到代理的队列来调用代理。
- en: 'This time, rather than using the previous approach of "lifting" the `move`
    command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们不再使用之前的“提升”`move`命令的方法：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'we''ll use the `result` computation expression instead, so the code above would
    have looked like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`result`计算表达式，因此上面的代码将会是这样的：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the agent implementation, we are not calling a `move` command, but instead
    creating the `Move` case of the `Command` type, so the code looks like:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理实现中，我们不调用`move`命令，而是创建`Command`类型的`Move`情况，所以代码看起来像这样：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s the complete code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整的代码：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Advantages and disadvantages of the Agent approach
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理方法的优缺点
- en: '*Advantages*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: A great way to protect mutable state without using locks.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种保护可变状态而不使用锁的好方法。
- en: The API is decoupled from a particular implementation via the message queue.
    The `TurtleCommand` acts as a sort of protocol that decouples the two ends of
    the queue.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API通过消息队列与特定的实现解耦。`TurtleCommand`充当了一种协议，解耦了队列的两端。
- en: The turtle agent is naturally asynchronous.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乌龟代理自然是异步的。
- en: Agents can easily be scaled horizontally.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理可以很容易地水平扩展。
- en: '*Disadvantages*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*不利之处*'
- en: 'Agents are stateful and have the same problem as stateful objects:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理是有状态的，并且与有状态对象存在相同的问题：
- en: It is harder to reason about your code.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于你的代码进行推理变得更加困难。
- en: Testing is harder.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试更加困难。
- en: It is all too easy to create a web of complex dependencies between actors.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建复杂的依赖关系网络太容易了。
- en: A robust implementation for agents can get quite complex, as you may need support
    for supervisors, heartbeats, back pressure, etc.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于代理的健壮实现可能会变得相当复杂，因为你可能需要支持监管者、心跳、反压等。
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/05-TurtleAgent.fsx)
    .*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个版本的源代码在[这里](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/05-TurtleAgent.fsx)可用。*'
- en: '* * *'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '6: Dependency injection using interfaces'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6：使用接口进行依赖注入
- en: All the implementations so far have been tied to a specific implementation of
    the turtle functions, with the exception of the Agent version, where the API communicated
    indirectly via a queue.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的实现都与特定的乌龟函数实现相关联，Agent 版本除外，其中API通过队列间接通信。
- en: So let's now look at some ways of decoupling the API from the implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些将API与实现解耦的方法。
- en: Designing an interface, object-oriented style
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计接口，面向对象风格
- en: 'We''ll start with the classic OO way of decoupling implementations: using interfaces.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从经典的面向对象的解耦实现方式开始：使用接口。
- en: Applying that approach to the turtle domain, we can see that our API layer will
    need to communicate with a `ITurtle` interface rather than a specific turtle implementation.
    The client injects the turtle implementation later, via the API's constructor.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法应用于乌龟领域，我们可以看到我们的 API 层将需要与`ITurtle`接口通信，而不是特定的乌龟实现。客户端稍后通过 API 的构造函数注入乌龟实现。
- en: 'Here''s the interface definition:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接口定义：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that there are a lot of `unit`s in these functions. A `unit` in a function
    signature implies side effects, and indeed the `TurtleState` is not used anywhere,
    as this is a OO-based approach where the mutable state is encapsulated in the
    object.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些函数中有很多`unit`。函数签名中的`unit`意味着副作用，确实`TurtleState`没有在任何地方使用，因为这是一种基于面向对象的方法，其中可变状态封装在对象中。
- en: 'Next, we need to change the API layer to use the interface by injecting it
    in the constructor for `TurtleApi`. Other than that, the rest of the API code
    is unchanged, as shown by the snippet below:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更改 API 层，通过在`TurtleApi`的构造函数中注入接口来使用它。除此之外，API 代码的其余部分保持不变，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating some implementations of an OO interface
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一些面向对象接口的实现
- en: Now let's create and test some implementations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建并测��一些实现。
- en: The first implementation will be called `normalSize` and will be the original
    one. The second will be called `halfSize` and will reduce all the distances by
    half.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实现将被称为`normalSize`，并且将是原始的实现。第二个将被称为`halfSize`，并且将所有距离减半。
- en: For `normalSize` we could go back and retrofit the orginal `Turtle` class to
    support the `ITurtle` interface. But I hate having to change working code! Instead,
    we can create a "proxy" wrapper around the orginal `Turtle` class, where the proxy
    implements the new interface.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`normalSize`，我们可以回头修改原始的`Turtle`类以支持`ITurtle`接口。但我讨厌修改正常工作的代码！相反，我们可以创建一个围绕原始`Turtle`类的“代理”包装器，其中代理实现新接口。
- en: 'In some languages, creating proxy wrappers can be long-winded, but in F# you
    can use [object expressions](object-expressions.html) to implement an interface
    quickly:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，创建代理包装可能会很冗长，但在 F# 中，您可以使用[对象表达式](object-expressions.html)快速实现接口：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And to create the `halfSize` version, we do the same thing, but intercept the
    calls to `Move` and halve the distance parameter:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`halfSize`版本，我们做同样的事情，但拦截对`Move`的调用并将距离参数减半：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is actually [the "decorator" pattern](https://en.wikipedia.org/wiki/Decorator_pattern)
    at work: we''re wrapping `normalSize` in a proxy with an identical interface,
    then changing the behavior for some of the methods, while passing others though
    untouched.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是[“装饰器”模式](https://en.wikipedia.org/wiki/Decorator_pattern)的工作原理：我们将`normalSize`包装在具有相同接口的代理中，然后更改某些方法的行为，同时保持其他方法不变。
- en: Injecting dependencies, OO style
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入依赖项，面向对象风格
- en: Now let's look at the client code that injects the dependencies into the API.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看将依赖项注入到 API 中的客户端代码。
- en: 'First, some code to draw a triangle, where a `TurtleApi` is passed in:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一些绘制三角形的代码，其中传入一个`TurtleApi`：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And now let''s try drawing the triangle by instantiating the API object with
    the normal interface:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试通过使用正常接口实例化 API 对象来绘制三角形：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Obviously, in a real system, the dependency injection would occur away from
    the call site, using an IoC container or similar.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在真实系统中，依赖注入将在调用站点之外进行，使用 IoC 容器或类似方法。
- en: 'If we run it, the output of `drawTriangle` is just as before:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，`drawTriangle`的输出与以前一样：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And now with the half-size interface..
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用半尺寸接口……
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '...the output is, as we hoped, half the size!'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ……输出正如我们所希望的，大小减半！
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Designing an interface, functional style
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计接口，函数式风格
- en: In a pure FP world, OO-style interfaces do not exist. However, you can emulate
    them by using a record containing functions, with one function for each method
    in the interface.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯函数式编程世界中，不存在面向对象风格的接口。但是，您可以通过使用包含函数的记录来模拟它们，每个方法在接口中对应一个函数。
- en: So let's create a alternative version of dependency injection, where this time
    the API layer will use a record of functions rather than an interface.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个依赖注入的替代版本，这次 API 层将使用函数记录而不是接口。
- en: 'A record of functions is a normal record, but the types of the fields are function
    types. Here''s the definition we''ll use:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数记录是一个普通记录，但字段的类型是函数类型。这里是我们将使用的定义：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that there are no `unit`s in these function signatures, unlike the OO version.
    Instead, the `TurtleState` is explicitly passed in and returned.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些函数签名中没有`unit`，与 OO 版本不同。相反，`TurtleState`被显式传入和返回。
- en: Also note that there is no logging either. The logging method will be baked
    in to the functions when the record is created.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这里也没有日志记录。当创建记录时，日志记录方法将被内置到函数中。
- en: The `TurtleApi` constructor now takes a `TurtleFunctions` record rather than
    an `ITurtle`, but as these functions are pure, the API needs to manage the state
    again with a `mutable` field.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`TurtleApi` 构造函数现在接受一个`TurtleFunctions`记录，而不是一个`ITurtle`，但由于这些函数是纯函数，API 需要再次使用`mutable`字段管理状态。'
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The implementation of the main `Exec` method is very similar to what we have
    seen before, with these differences:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 主要`Exec`方法的实现与之前看到的非常相似，但有以下区别：
- en: The function is fetched from the record (e.g. `turtleFunctions.move`).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从记录中获取函数（例如`turtleFunctions.move`）。
- en: All the activity takes place in a `result` computation expression so that the
    result of the validations can be used.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有活动都发生在一个`result`计算表达式中，以便可以使用验证的结果。
- en: 'Here''s the code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Creating some implementations of a "record of functions"
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一些“函数记录”的实现
- en: Noe let's create some implementations.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一些实现。
- en: Again, we'll have a `normalSize` implementation and a `halfSize` implementation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将有一个`normalSize`实现和一个`halfSize`实现。
- en: 'For `normalSize` we just need to use the functions from the original `Turtle`
    module, with the logging baked in using partial application:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`normalSize`，我们只需要使用原始`Turtle`模块中的函数，并使用部分应用程序内置的日志记录：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And to create the `halfSize` version, we clone the record, and change just
    the `move` function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`halfSize`版本，我们克隆记录，并仅更改`move`函数：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What's nice about cloning records rather than proxying interfaces is that we
    don't have to reimplement every function in the record, just the ones we care
    about.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用克隆记录而不是代理接口的好处在于，我们不必重新实现记录中的每个函数，只需关心的函数即可。
- en: Injecting dependencies again
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 再次注入依赖项
- en: 'The client code that injects the dependencies into the API is implemented just
    as you expect. The API is a class with a constructor, and so the record of functions
    can be passed into the constructor in exactly the same way that the `ITurtle`
    interface was:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖项注入到 API 中的客户端代码实现就像你期望的那样。API 是一个带有构造函数的类，因此函数记录可以以与`ITurtle`接口完全相同的方式传递给构造函数：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, the client code in the `ITurtle` version and `TurtleFunctions`
    version looks identical! If it wasn't for the different types, you could not tell
    them apart.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在`ITurtle`版本和`TurtleFunctions`版本中的客户端代码看起来是相同的！如果不是因为不同的类型，你无法区分它们。
- en: Advantages and disadvantages of using interfaces
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用接口的优缺点
- en: The OO-style interface and the FP-style "record of functions" are very similar,
    although the FP functions are stateless, unlike the OO interface.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象风格的接口和函数记录的函数式编程风格非常相似，尽管函数式编程函数是无状态的，而面向对象接口不是。
- en: '*Advantages*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: The API is decoupled from a particular implementation via the interface.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过接口，API 与特定实现解耦。
- en: 'For the FP "record of functions" approach (compared to OO interfaces):'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于函数记录的函数式编程方法（与面向对象接口相比）：
- en: Records of functions can be cloned more easily than interfaces.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数记录比接口更容易克隆。
- en: The functions are stateless
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是无状态的
- en: '*Disadvantages*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Interfaces are more monolithic than individual functions and can easily grow
    to include too many unrelated methods, breaking the [Interface Segregation Principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
    if care is not taken.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口比单个函数更加庞大，如果不小心，很容易包含太多不相关的方法，违反[接口隔离原则](https://en.wikipedia.org/wiki/Interface_segregation_principle)。
- en: Interfaces are not composable (unlike individual functions).
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口不可组合（与单个函数不同）。
- en: For more on the problems with this approach, see [this Stack Overflow answer
    by Mark Seemann](https://stackoverflow.com/questions/34011895/f-how-to-pass-equivalent-of-interface/34028711?stw=2#34028711).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欲了解更多关于这种方法的问题，请参阅[Mark Seemann 在 Stack Overflow 上的回答](https://stackoverflow.com/questions/34011895/f-how-to-pass-equivalent-of-interface/34028711?stw=2#34028711)。
- en: 'For the OO interface approach in particular:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是对于面向对象接口方法：
- en: You may have to modify existing classes when refactoring to an interface.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重构为接口时，可能需要修改现有类。
- en: 'For the FP "record of functions" approach:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于函数记录的函数式编程方法：
- en: Less tooling support, and poor interop, compared to OO interfaces.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 OO 接口相比，工具支持较少，互操作性较差。
- en: '*The source code for these versions is available [here (interface)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/06-DependencyInjection_Interface-1.fsx)
    and [here (record of functions)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/06-DependencyInjection_Interface-2.fsx).*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些版本的源代码可在 [此处（接口）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/06-DependencyInjection_Interface-1.fsx)
    和 [此处（函数记录）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/06-DependencyInjection_Interface-2.fsx)
    下载。*'
- en: '* * *'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '7: Dependency injection using functions'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7: 使用函数进行依赖注入'
- en: The two main disadvantages of the "interface" approach is that interfaces are
    not composable, and they break the ["pass in only the dependencies you need" rule](https://en.wikipedia.org/wiki/Interface_segregation_principle),
    which is a key part of functional design.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: “接口”方法的两个主要缺点是接口不可组合，并且它们违反了功能设计的关键部分之一，即打破“只传递你需要的依赖项”规则。
- en: In a true functional approach, we would pass in functions. That is, the API
    layer communicates via one or more functions that are passed in as parameters
    to the API call. These functions are typically partially applied so that the call
    site is decoupled from the "injection".
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正的功能方法中，我们会传递函数。也就是说，API 层通过一个或多个作为参数传递给 API 调用的函数进行通信。这些函数通常是部分应用的，以使调用站点与“注入”解耦。
- en: No interface is passed to the constructor as generally there is no constructor!
    (I'm only using a API class here to wrap the mutable turtle state.)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不需要将接口传递给构造函数！（我这里仅使用 API 类来包装可变的乌龟状态。）
- en: 'In the approach in this section, I''ll show two alternatives which use function
    passing to inject dependencies:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中的方法中，我将展示两种使用函数传递来注入依赖项的替代方法：
- en: In the first approach, each dependency (turtle function) is passed separately.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种方法中，每个依赖项（乌龟函数）都是分开传递的。
- en: In the second approach, only one function is passed in. So to determine which
    specific turtle function is used, a discriminated union type is defined.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种方法中，只传入一个函数。因此，为了确定使用哪个具体的乌龟函数，定义了一个标记联合类型。
- en: Approach 1 - passing in each dependency as a separate function
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法1 - 将每个依赖项作为单独的函数传递
- en: The simplest way to manage dependencies is always just to pass in all dependencies
    as parameters to the function that needs them.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 管理依赖项的最简单方法始终是将所有依赖项作为参数传递给需要它们的函数。
- en: 'In our case, the `Exec` method is the only function that needs to control the
    turtle, so we can pass them in there directly:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`Exec` 方法是唯一需要控制乌龟的函数，所以我们可以直接将它们传递进去：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To stress that point again: in this approach dependencies are always passed
    "just in time", to the function that needs them. No dependencies are used in the
    constructor and then used later.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调一下：在这种方法中，依赖项始终“按需”传递给需要它们的函数。构造函数中不使用任何依赖项，然后再次使用。
- en: 'Here''s a bigger snippet of the `Exec` method using those functions:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这些函数的 `Exec` 方法的更大片段：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using partial application to bake in an implementation
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用偏函数应用来固定实现
- en: 'To create a normal or half-size version of `Exec`, we just pass in different
    functions:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建普通或半尺寸版本的 `Exec`，我们只需传递不同的函数：
- en: '[PRE50]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In both cases we are returning a *function* of type `string -> Result<unit,ErrorMessage>`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，我们都返回一个类型为 `string -> Result<unit,ErrorMessage>` 的*函数*。
- en: Using a purely functional API
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用纯粹功能的 API
- en: So now when we want to draw something, we need only pass in *any* function of
    type `string -> Result<unit,ErrorMessage>`. The `TurtleApi` is no longer needed
    or mentioned!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在当我们想要画点东西时，我们只需要传入*任何*类型为 `string -> Result<unit,ErrorMessage>` 的函数即可。不再需要或提及
    `TurtleApi`！
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And here is how the API would be used:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 API 的使用方法：
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So, although we did have mutable state in the `TurtleApi`, the final "published"
    api is a function that hides that fact.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我们在 `TurtleApi` 中有可变状态，但最终的“发布”API 是隐藏了这一事实的函数。
- en: This approach of having the api be a single function makes it very easy to mock
    for testing!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将 API 设计为单个函数的这种方法使得它非常容易进行测试时的模拟！
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Approach 2 - passing a single function that handles all commands
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法2 - 传递一个处理所有命令的单个函数
- en: In the version above, we passed in 5 separate functions!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的版本中，我们传入了 5 个单独的函数！
- en: Generally, when you are passing in more than three or four parameters, that
    implies that your design needs tweaking. You shouldn't really need that many,
    if the functions are truly independent.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你传递超过三四个参数时，这意味着你的设计需要调整。如果这些函数确实是独立的，你实际上不应该需要那么多。
- en: But in our case, the five functions are *not* independent -- they come as a
    set -- so how can we pass them in together without using a "record of functions"
    approach?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们的情况下，这五个函数*不是*独立的--它们作为一个集合出现--那么我们如何在不使用“函数记录”方法的情况下将它们一起传递？
- en: The trick is to pass in just *one* function! But how can one function handle
    five different actions? Easy - by using a discriminated union to represent the
    possible commands.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是只传递*一个*函数！但是一个函数如何处理五种不同的操作呢？很简单——通过使用一个标记联合来表示可能的命令。
- en: 'We''ve seen this done before in the agent example, so let''s revisit that type
    again:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在代理示例中已经看过这个了，所以让我们再次查看那个类型：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: All we need now is a function that handles each case of that type.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所需要的只是一个处理该类型的每种情况的函数。
- en: 'Befor we do that though, let''s look at the changes to the `Exec` method implementation:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，让我们看一下`Exec`方法实现的更改：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that a `command` object is being created and then the `turtleFn` parameter
    is being called with it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，正在创建一个`command`对象，然后使用`turtleFn`参数调用它。
- en: 'And by the way, this code is very similar to the agent implementation, which
    used `turtleAgent.Post command` rather than `newState = turtleFn command state`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这段代码与代理实现非常相似，代理实现使用的是`turtleAgent.Post command`而不是`newState = turtleFn
    command state`：
- en: Using partial application to bake in an implementation
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用部分应用程序来嵌入实现
- en: 'Let''s create the two implementations using this approach:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这种方法创建两个实现：
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As before, in both cases we are returning a function of type `string -> Result<unit,ErrorMessage>`,.
    which we can pass into the `drawTriangle` function we defined earlier:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，在这两种情况下，我们都返回了一个类型为`string -> Result<unit,ErrorMessage>`的函数，我们可以将其传递给我们之前定义的`drawTriangle`函数：
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Advantages and disadvantages of using functions
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数的优缺点
- en: '*Advantages*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: The API is decoupled from a particular implementation via parameterization.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API通过参数化与特定实现解耦。
- en: Because dependencies are passed in at the point of use ("in your face") rather
    than in a constructor ("out of sight"), the tendency for dependencies to multiply
    is greatly reduced.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为依赖项是在使用点传递的（“在你面前”），而不是在构造函数中（“不在视线范围内”），所以依赖项增加的倾向大大降低了。
- en: Any function parameter is automatically a "one method interface" so no retrofitting
    is needed.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何函数参数都自动成为“单一方法接口”，因此不需要进行修改。
- en: Regular partial application can be used to bake in parameters for "dependency
    injection". No special pattern or IoC container is needed.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用常规部分应用程序来为“依赖注入”嵌入参数。不需要特殊的模式或IoC容器。
- en: '*Disadvantages*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: If the number of dependent functions is too great (say more than four) passing
    them all in as separate parameters can become awkward (hence, the second approach).
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果依赖函数的数量太多（比如超过四个），将它们全部作为单独的参数传递可能会变得很麻烦（因此，采用第二种方法）。
- en: The discriminated union type can be trickier to work with than an interface.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与接口相比，标记联合类型可能更难处理。
- en: '*The source code for these versions is available [here (five function params)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/07-DependencyInjection_Functions-1.fsx)
    and [here (one function param)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/07-DependencyInjection_Functions-2.fsx).*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些版本的源代码可以在 [这里（五个函数参数）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/07-DependencyInjection_Functions-1.fsx)
    和 [这里（一个函数参数）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/07-DependencyInjection_Functions-2.fsx)
    找到。*'
- en: '* * *'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '8: Batch processing using a state monad'
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8: 使用状态单子进行批处理处理'
- en: In the next two sections, we'll switch from "interactive" mode, where instructions
    are processed one at a time, to "batch" mode, where a whole series of instructions
    are grouped together and then run as one unit.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将从“交互”模式切换到“批处理”模式，其中指令逐个处理，然后作为一个整体一起运行。
- en: In the first design, we'll go back to the model where the client uses the Turtle
    functions directly.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种设计中，我们将回到客户端直接使用Turtle函数的模型。
- en: Just as before, the client must keep track of the current state and pass it
    into the next function call, but this time we'll keep the state out of sight by
    using a so-called "state monad" to thread the state through the various instructions.
    As a result, there are no mutables anywhere!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，客户端必须跟踪当前状态并将其传递到下一个函数调用中，但这一次我们将通过使用所谓的“状态单子”来将状态隐藏起来，以便通过各种指令。结果，任何地方都没有可变对象！
- en: This won't be a generalized state monad, but a simplified one just for this
    demonstration. I'll call it the `turtle` workflow.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会是一个通用的状态单子，而是一个专门为此演示而简化的状态单子。我将其称为 `turtle` 工作流。
- en: '*(For more on the state monad see my ["monadster" talk and post](http://fsharpforfunandprofit.com/monadster/)
    and [post on parser combinators](understanding-parser-combinators1.html) )*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*(有关状态单子的更多信息，请参阅我的["单子兽"演讲和文章](http://fsharpforfunandprofit.com/monadster/)以及[关于解析组合器的文章](understanding-parser-combinators1.html))*'
- en: '![](turtle-monad.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-monad.png)'
- en: Defining the `turtle` workflow
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 `turtle` 工作流
- en: The core turtle functions that we defined at the very beginning follow the same
    "shape" as many other state-transforming functions, an input plus the turtle state,
    and the output plus the turtle state.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一开始定义的核心 turtle 函数遵循与许多其他状态转换函数相同的“形状”，一个输入加上 turtle 状态，以及一个输出加上 turtle 状态。
- en: '![](turtle-monad-1.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-monad-1.png)'
- en: '*(It''s true that, so far. we have not had any useable output from the turtle
    functions, but in a later example we will see this output being used to make decisions.)*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*(尽管到目前为止，我们还没有从 turtle 函数中得到任何可用的输出，但在后面的例子中，我们将看到这些输出被用来做出决策。)*'
- en: There is a standard way to deal with these kinds of functions -- the "state
    monad".
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种标准方法来处理这些类型的函数——“状态单子”。
- en: Let's look at how this is built.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何构建的。
- en: 'First, note that, thanks to currying, we can recast a function in this shape
    into two separate one-parameter functions: processing the input generates another
    function that in turn has the state as the parameter:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，由于柯里化，我们可以将具有这种形状的函数重新表述为两个单独的单参数函数：处理输入生成另一个函数，该函数又以状态作为参数：
- en: '![](turtle-monad-2.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-monad-2.png)'
- en: 'We can then think of a turtle function as something that takes an input and
    returns a new *function*, like this:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把一个 turtle 函数想象成接受一个输入并返回一个新的*函数*，就像这样：
- en: '![](turtle-monad-3.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-monad-3.png)'
- en: 'In our case, using `TurtleState` as the state, the returned function will look
    like this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，使用 `TurtleState` 作为状态，返回的函数将如下所示：
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, to make it easier to work with, we can treat the returned function
    as a thing in its own right, give it a name such as `TurtleStateComputation`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了更容易地处理，我们可以将返回的函数视为一个独立的东西，并为其命名，例如 `TurtleStateComputation`：
- en: '![](turtle-monad-4.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-monad-4.png)'
- en: 'In the implementation, we would typically wrap the function with a [single
    case discriminated union](designing-with-types-single-case-dus.html) like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，我们通常会使用一个[单一情况辨别联合体](designing-with-types-single-case-dus.html)来包装函数，就像这样：
- en: '[PRE59]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So that is the basic idea behind the "state monad". However, it's important
    to realize that a state monad consists of more than just this type -- you also
    need some functions ("return" and "bind") that obey some sensible laws.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是“状态单子”的基本思想。但是，重要的是要意识到，状态单子不仅仅由这种类型组成——你还需要一些满足一些合理规律的函数（"return" 和 "bind"）。
- en: I won't define the `returnT` and `bindT` functions here, but you can see their
    definitions in the [full source](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/8e4e8d23b838ca88702d0b318bfd57a87801305e/08-StateMonad.fsx#L46).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里定义 `returnT` 和 `bindT` 函数，但你可以在[完整源代码](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/8e4e8d23b838ca88702d0b318bfd57a87801305e/08-StateMonad.fsx#L46)中看到它们的定义。
- en: We need some additional helper functions too. (I'm going to add a `T` for Turtle
    suffix to all the functions).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也需要一些额外的辅助函数。（我将在所有函数的末尾添加一个 `T` 作为 Turtle 后缀）。
- en: 'In particular, we need a way to feed some state into the `TurtleStateComputation`
    to "run" it:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们需要一种方法将一些状态输入到 `TurtleStateComputation` 中以“运行”它：
- en: '[PRE60]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, we can create a `turtle` workflow, which is a computation expression
    that makes it easier to work with the `TurtleStateComputation` type:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个 `turtle` 工作流，这是一个计算表达式，使得更容易处理 `TurtleStateComputation` 类型：
- en: '[PRE61]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using the Turtle workflow
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Turtle 工作流
- en: 'To use the `turtle` workflow, we first need to create "lifted" or "monadic"
    versions of the turtle functions:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `turtle` 工作流，我们首先需要创建“提升”的或“单子化”的 turtle 函数版本：
- en: '[PRE62]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `toUnitComputation` helper function does the lifting. Don't worry about
    how it works, but the effect is that the original version of the `move` function
    (`Distance -> TurtleState -> TurtleState`) is reborn as a function returning a
    `TurtleStateComputation` (`Distance -> TurtleStateComputation<unit>`)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`toUnitComputation` 辅助函数完成了提升。不用担心它是如何工作的，但其效果是 `move` 函数的原始版本 (`Distance ->
    TurtleState -> TurtleState`) 被重塑为返回 `TurtleStateComputation` (`Distance -> TurtleStateComputation<unit>`)
    的函数。'
- en: 'Once we have these "monadic" versions, we can use them inside the `turtle`
    workflow like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些“单子”版本，我们就可以像这样在 `turtle` 工作流中使用它们：
- en: '[PRE63]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first part of `drawTriangle` chains together six instructions, but importantly,
    does *not* run them. Only when the `runT` function is used at the end are the
    instructions actually executed.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawTriangle` 的第一部分连接了六个指令，但重要的是，并*不*运行它们。只有在最后使用 `runT` 函数时，这些指令才会被执行。'
- en: 'The `drawPolygon` example is a little more complicated. First we define a workflow
    for drawing one side:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawPolygon` 示例稍微复杂一些。首先，我们定义了绘制一个边的工作流程：'
- en: '[PRE64]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: But then we need a way of combining all the sides into a single workflow. There
    are a couple of ways of doing this. I'll go with creating a pairwise combiner
    `chain` and then using `reduce` to combine all the sides into one operation.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 但是然后我们需要一种将所有边组合成单个工作流的方法。有几种做法。我会选择创建一个成对组合器 `chain`，然后使用 `reduce` 将所有边组合成一个操作。
- en: '[PRE65]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here''s the complete code for `drawPolygon`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `drawPolygon` 的完整代码：
- en: '[PRE66]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Advantages and disadvantages of the `turtle` workflow
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`turtle` 工作流的优点和缺点'
- en: '*Advantages*'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: The client code is similar to imperative code, but preserves immutability.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端代码类似于命令式代码，但保持了不可变性。
- en: The workflows are composable -- you can define two workflows and then combine
    them to create another workflow.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作流是可组合的——你可以定义两个工作流，然后将它们组合起来创建另一个工作流。
- en: '*Disadvantages*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Coupled to a particular implementation of the turtle functions.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与特定实现的 turtle 函数耦合。
- en: More complex than tracking state explicitly.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比显式跟踪状态更复杂。
- en: Stacks of nested monads/workflows are hard to work with.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆叠的嵌套单子/工作流很难处理。
- en: As an example of that last point, let's say we have a `seq` containing a `result`
    workflow containing a `turtle` workflow and we want to invert them so that the
    `turtle` workflow is on the outside. How would you do that? It's not obvious!
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一点的示例，假设我们有一个包含 `turtle` 工作流的 `result` 工作流的 `seq`，我们想要反转它们，使 `turtle` 工作流位于外部。你会怎么做？这不明显！
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/08-StateMonad.fsx).*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个版本的源代码可以在[这里](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/08-StateMonad.fsx)找到。*'
- en: '* * *'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '9: Batch processing using command objects'
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9: 使用命令对象进行批处理'
- en: Another batch-oriented approach is to reuse the `TurtleCommand` type in a new
    way. Instead of calling functions immediately, the client creates a list of commands
    that will be run as a group.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种面向批处理的方法是以一种新的方式重用 `TurtleCommand` 类型。客户端不再立即调用函数，而是创建一个将作为组一起运行的命令列表。
- en: When you "run" the list of commands, you can just execute each one in turn using
    the standard Turtle library functions, using `fold` to thread the state through
    the sequence.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当你“运行”命令列表时，你可以使用标准的 Turtle 库函数依次执行每个命令，使用 `fold` 将状态穿过序列。
- en: '![](turtle-batch.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-batch.png)'
- en: And since all the commands are run at once, this approach means that there is
    no state that needs to be persisted between calls by the client.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有命令都是一次性运行的，这种方法意味着客户端之间不需要持久化的状态。
- en: 'Here''s the `TurtleCommand` definition again:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `TurtleCommand` 的定义：
- en: '[PRE67]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To process a sequence of commands, we will need to fold over them, threading
    the state through, so we need a function that applies a single command to a state
    and returns a new state:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理一系列命令，我们需要对它们进行折叠，并通过它们线程化状态，所以我们需要一个将单个命令应用于状态并返回新状态的函数：
- en: '[PRE68]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And then, to run all the commands, we just use `fold`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要运行所有命令，我们只需使用 `fold`：
- en: '[PRE69]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Running a batch of Commands
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行一批命令
- en: 'To draw a triangle, say, we just create a list of the commands and then run
    them:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个三角形，我们只需创建一个命令列表，然后运行它们：
- en: '[PRE70]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, since the commands are just a collection, we can easily build bigger collections
    from smaller ones.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于命令只是一个集合，我们可以很容易地从小集合构建更大的集合。
- en: 'Here''s an example for `drawPolygon`, where `drawOneSide` returns a collection
    of commands, and that collection is duplicated for each side:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`drawPolygon`的例子，其中`drawOneSide`返回一系列命令，并且该系列为每个边都重复：
- en: '[PRE71]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Advantages and disadvantages of batch commands
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理命令的优点和缺点
- en: '*Advantages*'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Simpler to construct and use than workflows or monads.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比工作流程或单子简单。
- en: Only one function is coupled to a particular implementation. The rest of the
    client is decoupled.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个函数与特定实现耦合。客户端的其余部分是解耦的。
- en: '*Disadvantages*'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Batch oriented only.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅面向批处理。
- en: Only suitable when control flow is *not* based on the response from a previous
    command. If you *do* need to respond to the result of each command, consider using
    the "interpreter" approach discussed later.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于控制流*不*基于先前命令的响应时。如果您*需要*对每个命令的结果做出响应，请考虑使用稍后讨论的"解释器"方法。
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/09-BatchCommands.fsx).*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个版本的源代码可以在[这里](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/09-BatchCommands.fsx)找到。*'
- en: '* * *'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Interlude: Conscious decoupling with data types'
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插曲：使用数据类型进行有意识的解耦
- en: In three of the examples so far (the [agent](13-ways-of-looking-at-a-turtle.html#way5),
    [functional dependency injection](13-ways-of-looking-at-a-turtle.html#way7) and
    [batch processing](13-ways-of-looking-at-a-turtle.html#way9)) we have used a `Command`
    type -- a discriminated union containing a case for each API call. We'll also
    see something similar used for the event sourcing and interpreter approaches in
    the next post.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的三个示例中（[代理](13-ways-of-looking-at-a-turtle.html#way5)、[函数依赖注入](13-ways-of-looking-at-a-turtle.html#way7)和[批处理](13-ways-of-looking-at-a-turtle.html#way9)），我们使用了一个`Command`类型
    -- 包含每个API调用的情况的辨别联合。在下一篇文章中，我们还将看到类似的东西用于事件源和解释器方法。
- en: This is not an accident. One of the differences between object-oriented design
    and functional design is that OO design focuses on behavior, while functional
    design focuses on data transformation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是偶然的。面向对象设计和函数设计之间的一个区别是，面向对象设计侧重于行为，而函数设计侧重于数据转换。
- en: As a result, their approach to decoupling differs too. OO designs prefer to
    provide decoupling by sharing bundles of encapsulated behavior ("interfaces")
    while functional designs prefer to provide decoupling by agreeing on a common
    data type, sometimes called a "protocol" (although I prefer to reserve that word
    for message exchange patterns).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他们的解耦方法也不同。面向对象设计倾向于通过共享捆绑的封装行为("接口")来提供解耦，而函数设计倾向于通过就共同数据类型达成一致，有时称为"协议"（尽管我更喜欢将该词保留给消息交换模式）。
- en: Once that common data type is agreed upon, any function that emits that type
    can be connected to any function that consumes that type using regular function
    composition.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦达成共同的数据类型协议，任何发出该类型的函数都可以通过常规函数组合连接到任何消费该类型的函数。
- en: You can also think of the two approaches as analogous to the choice between
    [RPC or message-oriented APIs in web services](https://sbdevel.wordpress.com/2009/12/17/the-case-rpc-vs-messaging/),
    and just as [message-based designs have many advantages](https://github.com/ServiceStack/ServiceStack/wiki/Advantages-of-message-based-web-services#advantages-of-message-based-designs)
    over RPC, so the data-based decoupling has similar advantages over the behavior-based
    decoupling.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将这两种方法视为类似于在Web服务中选择[RPC或基于消息的API](https://sbdevel.wordpress.com/2009/12/17-the-case-rpc-vs-messaging/)之间的选择，就像[基于消息的设计有许多优势](https://github.com/ServiceStack/ServiceStack/wiki/Advantages-of-message-based-web-services#advantages-of-message-based-designs)一样，数据解耦也具有类似于基于行为的解耦的优势。
- en: 'Some advantages of decoupling using data include:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据进行解耦的一些优势包括：
- en: Using a shared data type means that composition is trivial. It is harder to
    compose behavior-based interfaces.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享数据类型意味着组合是微不足道的。组合基于行为的接口更难。
- en: '*Every* function is already "decoupled", as it were, and so there is no need
    to retrofit existing functions when refactoring. At worst you might need to convert
    one data type to another, but that is easily accomplished using... moar functions
    and moar function composition!'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个*函数已经像"解耦"一样，因此在重构时无需修改现有函数。最坏的情况下，您可能需要将一种数据类型转换为另一种，但这很容易通过...更多函数和更多函数组合来实现！'
- en: Data structures are easy to serialize to remote services if and when you need
    to split your code into physically separate services.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要将代码拆分为物理上分开的服务时，数据结构很容易序列化到远程服务。
- en: Data structures are easy to evolve safely. For example, if I added a sixth turtle
    action, or removed an action, or changed the parameters of an action, the discriminated
    union type would change and all clients of the shared type would fail to compile
    until the sixth turtle action is accounted for, etc. On the other hand, if you
    *didn't* want existing code to break, you can use a versioning-friendly data serialization
    format like [protobuf](https://developers.google.com/protocol-buffers/docs/proto3#updating).
    Neither of these options are as easy when interfaces are used.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构易于安全演变。例如，如果我添加了第六种海龟动作，或者删除了一个动作，或者改变了一个动作的参数，那么歧视联合类型将会改变，并且所有共享类型的客户端在考虑到第六种海龟动作之前都将无法编译等等。另一方面，如果*不*想让现有代码中断，您可以使用一个友好的版本化数据序列化格式，比如[protobuf](https://developers.google.com/protocol-buffers/docs/proto3#updating)。当使用接口时，这两个选项都不容易。
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The meme is spreading.
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个梗正在传播。
- en: The turtle must be paddling.
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 海龟必须划桨。
- en: -- *"Thirteen ways of looking at a turtle", by Wallace D Coriacea*
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- *《观察海龟的13种方式》，作者 Wallace D Coriacea*
- en: Hello? Anyone still there? Thanks for making it this far!
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 喂？还有人在吗？感谢您一直坚持到现在！
- en: So, time for a break! In the [next post](13-ways-of-looking-at-a-turtle-2.html),
    we'll cover the remaining four ways of looking at a turtle.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是时候休息一下了！在[下一篇帖子](13-ways-of-looking-at-a-turtle-2.html)中，我们将涵盖剩下的四种观察海龟的方式。
- en: '*The source code for this post is available [on github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle).*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*本帖子的源代码可在 [github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle)
    上找到。*'
- en: Thirteen ways of looking at a turtle (part 2)
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13种观察海龟的方式（第2部分）
- en: Thirteen ways of looking at a turtle (part 2)
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13种观察海龟的方式（第2部分）
- en: This post is part of the [F# Advent Calendar in English 2015](https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/)
    project. Check out all the other great posts there! And special thanks to Sergey
    Tihon for organizing this.
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本帖子是[F#英文2015年的圣诞日历](https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/)项目的一部分。看看那里的所有其他精彩帖子！特别感谢
    Sergey Tihon 组织此活动。
- en: In this two-part mega-post, I'm stretching the simple turtle graphics model
    to the limit while demonstrating partial application, validation, the concept
    of "lifting", agents with message queues, dependency injection, the State monad,
    event sourcing, stream processing, and an interpreter!
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个两部分的超级帖子中，我正在极限地推动简单的 turtle 图形模型，同时演示部分应用、验证、"lifting" 概念、带有消息队列的代理、依赖注入、State
    monad、事件源、流处理和一个解释器！
- en: In the [previous post](13-ways-of-looking-at-a-turtle.html), we covered the
    first nine ways of looking at a turtle. In this post, we'll look at the remaining
    four.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一篇帖子](13-ways-of-looking-at-a-turtle.html)中，我们涵盖了前九种观察海龟的方式。在这篇帖子中，我们将看看剩下的四种方式。
- en: 'As a reminder, here are the thirteen ways:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这里是十三种方式：
- en: '[Way 1\. A basic object-oriented approach](13-ways-of-looking-at-a-turtle.html#way1),
    in which we create a class with mutable state.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1种方式\. 一个基本的面向对象方法](13-ways-of-looking-at-a-turtle.html#way1)，在这种情况下，我们创建一个具有可变状态的类。'
- en: '[Way 2\. A basic functional approach](13-ways-of-looking-at-a-turtle.html#way2),
    in which we create a module of functions with immutable state.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2种方式\. 一个基本的功能方法](13-ways-of-looking-at-a-turtle.html#way2)，在这种情况下，我们创建一个具有不可变状态的函数模块。'
- en: '[Way 3\. An API with a object-oriented core](13-ways-of-looking-at-a-turtle.html#way3),
    in which we create an object-oriented API that calls a stateful core class.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3种方式\. 具有面向对象核心的 API](13-ways-of-looking-at-a-turtle.html#way3)，在这种情况下，我们创建一个调用有状态核心类的面向对象
    API。'
- en: '[Way 4\. An API with a functional core](13-ways-of-looking-at-a-turtle.html#way4),
    in which we create an stateful API that uses stateless core functions.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4种方式\. 具有功能核心的 API](13-ways-of-looking-at-a-turtle.html#way4)，在这种情况下，我们创建一个使用无状态核心函数的有状态
    API。'
- en: '[Way 5\. An API in front of an agent](13-ways-of-looking-at-a-turtle.html#way5),
    in which we create an API that uses a message queue to communicate with an agent.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5种方式\. 代理前面的 API](13-ways-of-looking-at-a-turtle.html#way5)，在这种情况下，我们创建一个使用消息队列与代理进行通信的
    API。'
- en: '[Way 6\. Dependency injection using interfaces](13-ways-of-looking-at-a-turtle.html#way6),
    in which we decouple the implementation from the API using an interface or record
    of functions.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6种方式\. 使用接口进行依赖注入](13-ways-of-looking-at-a-turtle.html#way6)，在这种情况下，我们使用接口或函数记录将实现与
    API 解耦。'
- en: '[Way 7\. Dependency injection using functions](13-ways-of-looking-at-a-turtle.html#way7),
    in which we decouple the implementation from the API by passing a function parameter.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7种方式\. 使用函数进行依赖注入](13-ways-of-looking-at-a-turtle.html#way7)，在这种情况下，我们通过传递函数参数将实现与
    API 解耦。'
- en: '[Way 8\. Batch processing using a state monad](13-ways-of-looking-at-a-turtle.html#way8),
    in which we create a special "turtle workflow" computation expression to track
    state for us.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8种方式：使用状态单子进行批处理](13-种看待龟的方式.html#way8)，其中我们创建一个特殊的“龟工作流”计算表达式来跟踪状态。'
- en: '[Way 9\. Batch processing using command objects](13-ways-of-looking-at-a-turtle.html#way9),
    in which we create a type to represent a turtle command, and then process a list
    of commands all at once.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9种方式：使用命令对象进行批处理](13-种看待龟的方式.html#way9)，我们创建一个表示龟命令的类型，然后一次处理一个命令列表。'
- en: '[Interlude: Conscious decoupling with data types](13-ways-of-looking-at-a-turtle.html#decoupling).
    A few notes on using data vs. interfaces for decoupling.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[插曲：使用数据类型有意识地解耦](13-种看待龟的方式.html#decoupling)。关于使用数据与接口进行解耦的一些注释。'
- en: '[Way 10\. Event sourcing](13-ways-of-looking-at-a-turtle-2.html#way10), in
    which state is built from a list of past events.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10种方式：事件溯源](13-种看待龟的方式-2.html#way10)，其中状态是从过去事件列表中构建的。'
- en: '[Way 11\. Functional Retroactive Programming (stream processing)](13-ways-of-looking-at-a-turtle-2.html#way11),
    in which business logic is based on reacting to earlier events.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11种方式：功能性反向编程（流处理）](13-种看待龟的方式-2.html#way11)，其中业务逻辑基于对先前事件的反应。'
- en: '[Episode V: The Turtle Strikes Back](13-ways-of-looking-at-a-turtle-2.html#strikes-back),
    in which the turtle API changes so that some commands may fail.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第五集：龟之反击](13-种看待龟的方式-2.html#strikes-back)，其中龟的 API 更改，因此某些命令可能会失败。'
- en: '[Way 12\. Monadic control flow](13-ways-of-looking-at-a-turtle-2.html#way12),
    in which we make decisions in the turtle workflow based on results from earlier
    commands.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第12种方式：单子控制流](13-种看待龟的方式-2.html#way12)，其中我们根据先前命令的结果在龟工作流中做出决策。'
- en: '[Way 13\. A turtle interpreter](13-ways-of-looking-at-a-turtle-2.html#way13),
    in which we completely decouple turtle programming from turtle implementation,
    and nearly encounter the free monad.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第13种方式：龟解释器](13-种看待龟的方式-2.html#way13)，其中我们将龟编程与龟实现完全解耦，并几乎遇到了自由单子。'
- en: '[Review of all the techniques used](13-ways-of-looking-at-a-turtle-2.html#review).'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[所有技术的回顾](13-种看待龟的方式-2.html#review)。'
- en: 'and 2 bonus ways for the extended edition:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展版的两种额外方式：
- en: '[Way 14\. Abstract Data Turtle](13-ways-of-looking-at-a-turtle-3.html#way14),
    in which we encapsulate the details of a turtle implementation by using an Abstract
    Data Type.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第14种方式：抽象数据龟](13-种看待龟的方式-3.html#way14)，通过使用抽象数据类型封装了龟实现的详细信息。'
- en: '[Way 15\. Capability-based Turtle](13-ways-of-looking-at-a-turtle-3.html#way15),
    in which we control what turtle functions are available to a client, based on
    the current state of the turtle.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第15种方式：基于能力的龟](13-种看待龟的方式-3.html#way15)，其中我们根据龟的当前状态控制客户端可用的龟功能。'
- en: It's turtles all the way down!
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种无穷递归的设计！
- en: All source code for this post is available [on github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的所有源代码都可在 [github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle)
    上找到。
- en: '* * *'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '10: Event sourcing -- Building state from a list of past events'
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10: 事件溯源 -- 从过去事件列表构建状态'
- en: In this design, we build on the "command" concept used in the [Agent (way 5)](13-ways-of-looking-at-a-turtle.html#way5)
    and [Batch (way 9)](13-ways-of-looking-at-a-turtle.html#way9) approaches, but
    replacing "commands" with "events" as the method of updating state.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，我们建立在“命令”概念上，该概念在 [代理（第5种方式）](13-种看待龟的方式.html#way5) 和 [批处理（第9种方式）](13-种看待龟的方式.html#way9)
    中使用，但将“命令”替换为“事件”作为更新状态的方法。
- en: 'The way that it works is:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式是：
- en: The client sends a `Command` to a `CommandHandler`.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送 `Command` 给 `CommandHandler`。
- en: Before processing a `Command`, the `CommandHandler` first rebuilds the current
    state from scratch using the past events associated with that particular turtle.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理 `Command` 之前，`CommandHandler` 首先使用与特定龟相关联的过去事件从头开始重建当前状态。
- en: The `CommandHandler` then validates the command and decides what to do based
    on the current (rebuilt) state. It generates a (possibly empty) list of events.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`CommandHandler` 验证命令，并根据当前（重建的）状态决定要执行什么操作。它生成一个（可能为空的）事件列表。
- en: The generated events are stored in an `EventStore` for the next command to use.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的事件存储在 `EventStore` 中供下一个命令使用。
- en: '![](turtle-event-source.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-event-source.png)'
- en: In this way, neither the client nor the command handler needs to track state.
    Only the `EventStore` is mutable.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，既不需要客户端也不需要命令处理程序跟踪状态。只有 `EventStore` 是可变的。
- en: The Command and Event types
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令和事件类型
- en: 'We will start by defining the types relating to our event sourcing system.
    First, the types related to commands:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义与我们的事件源系统相关的类型。首先，与命令相关的类型：
- en: '[PRE72]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that the command is addressed to a particular turtle using a `TurtleId`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命令是针对特定乌龟的，使用`TurtleId`。
- en: 'Next, we will define two kinds of events that can be generated from a command:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义从命令生成的两种类型的事件：
- en: A `StateChangedEvent` which represents what changed in the state
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示状态变化的`StateChangedEvent`
- en: A `MovedEvent` which represents the start and end positions of a turtle movement.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示乌龟移动的开始和结束位置的`MovedEvent`。
- en: '[PRE73]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'It is an important part of event sourcing that all events are labeled in the
    past tense: `Moved` and `Turned` rather than `Move` and `Turn`. The event are
    facts -- they have happened in the past.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的事件源的一部分是所有事件都以过去式标记：`Moved`和`Turned`而不是`Move`和`Turn`。事件是事实--它们发生在过去。
- en: The Command handler
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令处理器
- en: The next step is to define the functions that convert a command into events.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义将命令转换为事件的函数。
- en: 'We will need:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要：
- en: A (private) `applyEvent` function that updates the state from a previous event.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个（私有的）`applyEvent`函数，用于从先前的事件更新状态。
- en: A (private) `eventsFromCommand` function that determines what events to generate,
    based on the command and the state.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个（私有的）`eventsFromCommand`函数，根据命令和状态确定要生成的事件。
- en: A public `commandHandler` function that handles the command, reads the events
    from the event store and calls the other two functions.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公共的`commandHandler`函数处理命令，从事件存储中读取事件并调用其他两个函数。
- en: Here's `applyEvent`. You can see that it is very similar to the `applyCommand`
    function that we saw in the [previous batch-processing example](13-ways-of-looking-at-a-turtle.html#way9).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`applyEvent`。你可以看到它与我们在[上一批处理示例](13-ways-of-looking-at-a-turtle.html#way9)中看到的`applyCommand`函数非常相似。
- en: '[PRE74]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `eventsFromCommand` function contains the key logic for validating the command
    and creating events.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`eventsFromCommand`函数包含验证命令并创建事件的关键逻辑。'
- en: In this particular design, the command is always valid, so at least one event
    is returned.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个特定的设计中，命令总是有效的，所以至少返回一个事件。
- en: The `StateChangedEvent` is created from the `TurtleCommand` in a direct one-to-one
    map of the cases.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StateChangedEvent`是从`TurtleCommand`中创建的，它们是一对一映射的情况。'
- en: The `MovedEvent` is only created from the `TurtleCommand` if the turtle has
    changed position.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在乌龟改变位置时，才会从`TurtleCommand`创建`MovedEvent`。
- en: '[PRE75]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, the `commandHandler` is the public interface. It is passed in some
    dependencies as parameters: a logging function, a function to retrieve the historical
    events from the event store, and a function to save the newly generated events
    into the event store.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`commandHandler`是公共接口。它将一些依赖项作为参数传递进来：一个记录函数，一个函数用于从事件存储中检索历史事件，以及一个函数用于将新生成的事件保存到事件存储中。
- en: '[PRE76]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Calling the command handler
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用命令处理器
- en: Now we are ready to send events to the command handler.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备向命令处理器发送事件。
- en: 'First we need some helper functions that create commands:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要一些帮助函数来创建命令：
- en: '[PRE77]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'And then we can draw a figure by sending the various commands to the command
    handler:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过将各种命令发送到命令处理器来绘制图形：
- en: '[PRE78]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'NOTE: I have not shown how to create the command handler or event store, see
    the code for full details.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我没有展示如何创建命令处理器或事件存储，请查看完整的代码详细信息。
- en: Advantages and disadvantages of event sourcing
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件源的优缺点
- en: '*Advantages*'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '*优势*'
- en: All code is stateless, hence easy to test.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的代码都是无状态的，因此易于测试。
- en: Supports replay of events.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持事件重放。
- en: '*Disadvantages*'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Can be more complex to implement than a CRUD approach (or at least, less support
    from tools and libraries).
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能比CRUD方法更复杂（或者至少，工具和库的支持更少）。
- en: If care is not taken, the command handler can get overly complex and evolve
    into implementing too much business logic.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不小心，命令处理器可能会变得过于复杂，并且演变成实现过多业务逻辑。
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/10-EventSourcing.fsx).*'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个版本的源代码可以在[这里](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/10-EventSourcing.fsx)找到。*'
- en: '* * *'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '11: Functional Retroactive Programming (stream processing)'
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11：功能性后向编程（流处理）
- en: In the event sourcing example above, all the domain logic (in our case, just
    tracing the state) is embedded in the command handler. One drawback of this is
    that, as the application evolves, the logic in the command handler can become
    very complex.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的事件溯源示例中，所有领域逻辑（在我们的情况下，只是跟踪状态）都嵌入在命令处理程序中。这种方法的一个缺点是，随着应用程序的发展，命令处理程序中的逻辑可能变得非常复杂。
- en: A way to avoid this is to combine ["functional reactive programming"](https://en.wikipedia.org/wiki/Functional_reactive_programming)
    with event sourcing to create a design where the domain logic is performed on
    the "read-side", by listening to events ("signals") emitted from the event store.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 一种避免这种情况的方法是将["功能性反应式编程"](https://en.wikipedia.org/wiki/Functional_reactive_programming)与事件溯源结合起来，创建一个设计，在该设计中，领域逻辑在“读取端”执行，通过监听从事件存储器发出的事件（“信号”）。
- en: In this approach, the "write-side" follows the same pattern as the event-sourcing
    example. A client sends a `Command` to a `commandHandler`, which converts that
    to a list of events and stores them in an `EventStore`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，“写入端”遵循与事件溯源示例相同的模式。客户端向 `commandHandler` 发送一个 `Command`，它将其转换为事件列表并将其存储在
    `EventStore` 中。
- en: However the `commandHandler` only does the *minimal* amount of work, such as
    updating state, and does NOT do any complex domain logic. The complex logic is
    performed by one or more downstream "processors" (also sometimes called "aggregators")
    that subscribe to the event stream.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`commandHandler` 只做*最小*的工作，比如更新状态，不执行任何复杂的领域逻辑。复杂逻辑由一个或多个下游的“处理器”（有时也称为“聚合器”）执行，它们订阅事件流。
- en: '![](turtle-frp.png)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-frp.png)'
- en: You can even think of these events as "commands" to the processors, and of course,
    the processors can generate new events for another processor to consume, so this
    approach can be extended into an architectural style where an application consists
    of a set of command handlers linked by an event store.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以将这些事件视为处理器的“命令”，当然，处理器可以生成新事件供另一个处理器消费，因此这种方法可��扩展为一种架构风格，其中应用程序由一组通过事件存储器连接的命令处理程序组成。
- en: This techique is often called ["stream processing"](http://www.confluent.io/blog/making-sense-of-stream-processing/).
    However, Jessica Kerr once called this approach ["Functional Retroactive Programming"](https://twitter.com/jessitron/status/408554836578537472)
    -- I like that, so I'm going to steal that name!
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通常被称为["流处理"](http://www.confluent.io/blog/making-sense-of-stream-processing/)。然而，Jessica
    Kerr 曾经将这种方法称为["功能性追溯式编程"](https://twitter.com/jessitron/status/408554836578537472)
    -- 我喜欢这个名字，所以我要借用这个名字！
- en: '![](turtle-stream-processor.png)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-stream-processor.png)'
- en: Implementing the design
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现设计
- en: For this implementation, the `commandHandler` function is the same as in the
    event sourcing example, except that no work (just logging!) is done at all. The
    command handler *only* rebuilds state and generates events. How the events are
    used for business logic is no longer in its scope.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实现，`commandHandler` 函数与事件溯源示例中的相同，只是根本没有任何工作（只是记录！）。命令处理程序*仅*重建状态并生成事件。事件如何用于业务逻辑已不再是其范围内。
- en: The new stuff comes in creating the processors.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 新的东西在于创建处理器。
- en: However, before we can create a processor, we need some helper functions that
    can filter the event store feed to only include turtle specific events, and of
    those only `StateChangedEvent`s or `MovedEvent`s.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在创建处理器之前，我们需要一些辅助函数，可以过滤事件存储器的反馈，仅包括特定于乌龟的事件，并且其中仅包括 `StateChangedEvent`
    或 `MovedEvent`。
- en: '[PRE79]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now let's create a processor that listens for movement events and moves a physical
    turtle when the virtual turtle is moved.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个处理器，监听移动事件，并在虚拟乌龟移动时移动实际乌龟。
- en: We will make the input to the processor be an `IObservable` -- an event stream
    -- so that it is not coupled to any specific source such as the `EventStore`.
    We will connect the `EventStore` "save" event to this processor when the application
    is configured.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理器的输入设置为一个 `IObservable` -- 一个事件流 -- 这样它就不会与任何特定来源（如 `EventStore`）耦合。当应用程序配置时，我们将连接
    `EventStore` 的“保存”事件到这个处理器。
- en: '[PRE80]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this case we are just printing the movement -- I'll leave the building of
    an [actual Lego Mindstorms turtle](https://www.youtube.com/watch?v=pcJHLClDKVw)
    as an exercise for the reader!
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是打印移动 -- 我将构建一个[实际的乐高乌龟](https://www.youtube.com/watch?v=pcJHLClDKVw)留给读者作为练习！
- en: 'Let''s also create a processor that draws lines on a graphics display:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也创建一个在图形显示器上绘制线条的处理器：
- en: '[PRE81]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: And finally, let's create a processor that accumulates the total distance moved
    so that we can keep track of how much ink has been used, say.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个处理器，累积总移动距离，以便我们可以跟踪已使用的墨水量。
- en: '[PRE82]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This processor uses `Observable.scan` to accumulate the events into a single
    value -- the total distance travelled.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理器使用`Observable.scan`将事件累积成单个值--总行驶距离。
- en: Processors in practice
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际中的处理器
- en: Let's try these out!
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这些！
- en: 'For example, here is `drawTriangle`:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是`drawTriangle`的样子：
- en: '[PRE83]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note that `eventStore.SaveEvent` is cast into an `IObservable<Guid*obj>` (that
    is, an event stream) before being passed to the processors as a parameter.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`eventStore.SaveEvent`被转换为一个`IObservable<Guid*obj>`（即事件流）之后，才被传递给处理器作为参数。
- en: '`drawTriangle` generates this output:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawTriangle`生成以下输出：'
- en: '[PRE84]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You can see that all the processors are handling events successfully.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到所有处理器都成功处理了事件。
- en: The turtle is moving, the graphics processor is drawing lines, and the ink used
    processor has correctly calculated the total distance moved as 300 units.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 乌龟正在移动，图形处理器正在绘制线条，墨水使用处理器已正确计算出总移动距离为300单位。
- en: Note, though, that the ink used processor is emitting output on *every* state
    change (such as turning), rather than only when actual movement happens.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，墨水使用的处理器在*每一次*状态改变（比如转向）时都会发出输出，而不仅仅是在实际移动发生时。
- en: We can fix this by putting a pair `(previousDistance, currentDistance)` in the
    stream, and then filtering out those events where the values are the same.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在流中放置一对`(previousDistance, currentDistance)`，然后过滤掉那些值相同的事件来解决这个问题。
- en: 'Here''s the new `inkUsedProcessor` code, with the following changes:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的`inkUsedProcessor`代码，带有以下更改：
- en: The `accumulate` function now emits a pair.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accumulate`函数现在发出一对。'
- en: There is a new filter `changedDistanceOnly`.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个新的过滤器`changedDistanceOnly`。
- en: '[PRE85]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'With these changes, the output of `drawTriangle` looks like this:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些改变，`drawTriangle`的输出看起来像这样：
- en: '[PRE86]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: and there are no longer any duplicate messages from the `inkUsedProcessor`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`inkUsedProcessor`中不再存在重复的消息。'
- en: Advantages and disadvantages of stream processing
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流处理的优缺点
- en: '*Advantages*'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Same advantages as event-sourcing.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与事件源相同的优点。
- en: Decouples stateful logic from other non-intrinsic logic.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有状态的逻辑与其他非固有逻辑分离。
- en: Easy to add and remove domain logic without affecting the core command handler.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以轻松添加和删除领域逻辑，而不影响核心命令处理程序。
- en: '*Disadvantages*'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: More complex to implement.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更复杂的实现。
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/11-FRP.fsx).*'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个版本的源代码可以在[这里](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/11-FRP.fsx)找到。*'
- en: '* * *'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Episode V: The Turtle Strikes Back'
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五集：乌龟反击
- en: So far, we have not had to make decisions based on the turtle's state. So, for
    the two final approaches, we will change the turtle API so that some commands
    may fail.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有根据乌龟的状态做出决定。因此，对于最后两种方法，我们将更改乌龟API，使得一些命令可能失败。
- en: For example, we might say that the turtle must move within a limited arena,
    and a `move` instruction may cause the turtle to hit the barrier. In this case,
    the `move` instruction can return a choice of `MovedOk` or `HitBarrier`.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以说乌龟必须在有限的竞技场内移动，`move`指令可能会导致乌龟碰到障碍物。在这种情况下，`move`指令可以返回`MovedOk`或`HitBarrier`的选择。
- en: Or let's say that there is only a limited amount of colored ink. In this case,
    trying to set the color may return an "out of ink" response.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以说，有限的彩色墨水。在这种情况下，尝试设置颜色可能会返回“墨水用完”的响应。
- en: 'So let''s update the turtle functions with these cases. First the new response
    types for `move` and `setColor`:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们用这些情况更新乌龟函数。首先是`move`和`setColor`的新响应类型：
- en: '[PRE87]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We will need a bounds checker to see if the turtle is in the arena. Say that
    if the position tries to go outside the square (0,0,100,100), the response is
    `HitABarrier`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个边界检查器来查看乌龟是否在竞技场内。假设如果位置尝试移出方形（0,0,100,100），则响应为`HitABarrier`：
- en: '[PRE88]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And finally, the `move` function needs an extra line to check the new position:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`move`函数需要额外的一行来检查新的位置：
- en: '[PRE89]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here''s the complete `move` function:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的`move`函数：
- en: '[PRE90]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We will make similar changes for the `setColor` function too, returning `OutOfInk`
    if we attempt to set the color to `Red`.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`setColor`函数，我们也会进行类似的更改，如果尝试将颜色设置为`Red`，则返回`OutOfInk`。
- en: '[PRE91]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: With the new versions of the turtle functions available, we have to create implementations
    that can respond to the error cases. That will be done in the next two examples.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 随着可用的新版本的turtle函数，我们必须创建能够响应错误情况的实现。这将在接下来的两个示例中完成。
- en: '*The source code for the new turtle functions is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/FPTurtleLib2.fsx).*'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '*新turtle函数的源代码可以在[此处](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/FPTurtleLib2.fsx)找到。*'
- en: '* * *'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '12: Monadic control flow'
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12：单调控制流
- en: In this approach, we will reuse the `turtle` workflow from [way 8](13-ways-of-looking-at-a-turtle.html#way8).
    This time though, we will make decisions for the next command based on the result
    of the previous one.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们将重用来自[第8种方法](13-ways-of-looking-at-a-turtle.html#way8)的`turtle`工作流。不过，这一次，我们将根据前一次的结果为下一次的命令做出决策。
- en: Before we do that though, let's look at what effect the change to `move` will
    have on our code. Let's say that we want to move forwards a few times using `move
    40.0`, say.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在我们这样做之前，让我们看看对`move`的更改对我们的代码有什么影响。比方说，我们想要使用`move 40.0`向前移动几次。
- en: 'If we write the code using `do!` as we did before, we get a nasty compiler
    error:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像以前一样使用`do!`编写代码，我们会得到一个难以处理的编译器错误：
- en: '[PRE92]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Instead, we need to use `let!` and assign the response to something.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要使用`let!`并将响应分配给某个东西。
- en: In the following code, we assign the response to a value and then ignore it!
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将响应分配给一个值，然后将其忽略！
- en: '[PRE93]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The code does compile and work, but if we run it the output shows that, by the
    third call, we are banging our turtle against the wall (at 100,0) and not moving
    anywhere.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编译并工作了，但是如果我们运行它，输出显示，到第三次调用时，我们把乌龟撞到了墙上（在100,0处），而且没有移动到任何地方。
- en: '[PRE94]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Making decisions based on a response
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于响应做出决策
- en: Let's say that our response to a `move` that returns `HitABarrier` is to turn
    90 degrees and wait for the next command. Not the cleverest algorithm, but it
    will do for demonstration purposes!
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对返回`HitABarrier`的`move`的响应是转向90度并等待下一个命令。不是最聪明的算法，但作为演示目的，它可以！
- en: Let's design a function to implement this. The input will be a `MoveResponse`,
    but what will the output be? We want to encode the `turn` action somehow, but
    the raw `turn` function needs state input that we don't have. So instead let's
    return a `turtle` workflow that represents the instruction we *want* to do, when
    the state becomes available (in the `run` command).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个函数来实现这个功能。输入将是一个`MoveResponse`，但输出将是什么？我们想要以某种方式编码`turn`动作，但原始的`turn`函数需要我们没有的状态输入。所以我们改为返回一个代表我们想要在状态可用时（在`run`命令中）执行的`turtle`工作流。
- en: 'So here is the code:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里是代码：
- en: '[PRE95]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The type signature looks like this:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名看起来像这样：
- en: '[PRE96]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: which means that it is a monadic (or "diagonal") function -- one that starts
    in the normal world and ends in the `TurtleStateComputation` world.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它是一个单调的（或“对角线”）函数——一个从正常世界开始并以`TurtleStateComputation`世界结束的函数。
- en: These are exactly the functions that we can use "bind" with, or within computation
    expressions, `let!` or `do!`.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们可以使用“绑定”或在计算表达式中使用`let!`或`do!`的函数。
- en: 'Now we can add this `handleMoveResponse` step after `move` in the turtle workflow:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在乌龟工作流的`move`之后添加这个`handleMoveResponse`步骤：
- en: '[PRE97]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'And the result of running it is:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 运行结果如下：
- en: '[PRE98]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: You can see that the move response worked. When the turtle hit the edge at (100,0)
    it turned 90 degrees and the next move succeeded (from (100,0) to (100,60)).
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到移动响应起作用了。当乌龟撞到边缘（100,0）时，它转了90度，然后下一步移动成功了（从（100,0）到（100,60））。
- en: So there you go! This code demonstrates how you can make decisions inside the
    `turtle` workflow while the state is being passed around behind the scenes.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你明白了！这段代码演示了如何在`turtle`工作流中做出决策，同时在幕后传递状态。
- en: Advantages and disadvantages
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优势和劣势
- en: '*Advantages*'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '*优势*'
- en: Computation expressions allow the code to focus on the logic while taking care
    of the "plumbing" -- in this case, the turtle state.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算表达式允许代码专注于逻辑，同时处理“管道”——在这种情况下是turtle状态。
- en: '*Disadvantages*'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '*劣势*'
- en: Still coupled to a particular implementation of the turtle functions.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然与特定的turtle函数实现耦合。
- en: Computation expressions can be complex to implement and how they work is not
    obvious for beginners.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算表达式的实现可能很复杂，对于初学者来说，它们的工作原理并不明显。
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/12-BranchingOnResponse.fsx).*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '*此版本的源代码可在[此处](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/12-BranchingOnResponse.fsx)找到。*'
- en: '* * *'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '13: A turtle interpreter'
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13：乌龟解释器
- en: For our final approach, we'll look at a way to *completely* decouple the programming
    of the turtle from its interpretation.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终方法，我们将看一种*完全*将乌龟的编程与其解释分离的方法。
- en: This is similar to the [batch processing using command objects](13-ways-of-looking-at-a-turtle.html#way9)
    approach, but is enhanced to support responding to the output of a command.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于[使用命令对象进行批处理](13-ways-of-looking-at-a-turtle.html#way9)的方法，但已经增强以支持对命令输出的响应。
- en: Designing an interpreter
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计一个解释器
- en: The approach we will take is to design an "interpreter" for a set of turtle
    commands, where the client provides the commands to the turtle, and responds to
    outputs from the turtle, but the actual turtle functions are provided later by
    a particular implementation.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的方法是为一组乌龟命令设计一个“解释器”，其中客户端提供命令给乌龟，并响应乌龟的输出，但实际的乌龟函数稍后由特定的实现提供。
- en: 'In other words, we have a chain of interleaved commands and turtle functions
    that look like this:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们有一系列交错的命令和乌龟函数，看起来像这样：
- en: '![](turtle-interpreter-chain.png)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-interpreter-chain.png)'
- en: So how can we model this design in code?
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何在代码中建模这个设计？
- en: 'For a first attempt, let''s model the chain as a sequence of request/response
    pairs. We send a command to the turtle and it responds appropriately with a `MoveResponse`
    or whatever, like this:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 首先尝试，让我们将链模拟为一系列请求/响应对。我们向乌龟发送一个命令，它会以`MoveResponse`或其他方式适当地响应，就像这样：
- en: '[PRE99]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The problem is that we cannot be sure that the response correctly matches the
    command. For example, if I send a `Move` command, I expect to get a `MoveResponse`,
    and never a `SetColorResponse`. But this implementation doesn't enforce that!
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们无法确定响应是否正确匹配命令。例如，如果我发送一个`Move`命令，我期望得到一个`MoveResponse`，而不是一个`SetColorResponse`。但是这个实现并没有强制执行！
- en: We want to [make illegal states unrepresentable](designing-with-types-making-illegal-states-unrepresentable.html)
    -- how can we do that?
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要[使非法状态不可表示](designing-with-types-making-illegal-states-unrepresentable.html)
    -- 我们该怎么做？
- en: The trick is to combine the request and response in *pairs*. That is, for a
    `Move` command, there is an associated function which is given a `MoveResponse`
    as input, and similarly for each other combination. Commands that have no response
    can be considered as returning `unit` for now.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是将请求和响应组合成*配对*。也就是说，对于`Move`命令，有一个关联的函数，该函数以`MoveResponse`作为输入，并对每个其他组合也是如此。现在可以将没有响应的命令暂时视为返回`unit`。
- en: '[PRE100]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The way this works is that:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作原理是：
- en: The client creates a command, say `Move 100`, and also provides the additional
    function that handles the response.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端创建一个命令，比如`Move 100`，并且还提供处理响应的附加函数。
- en: The turtle implementation for the Move command (inside the interpreter) processes
    the input (a `Distance`) and then generates a `MoveResponse`.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Move命令的乌龟实现（在解释器内部）处理输入（一个`Distance`），然后生成一个`MoveResponse`。
- en: The interpreter then takes this `MoveResponse` and calls the associated function
    in the pair, as supplied by the client.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后解释器接收此`MoveResponse`并调用客户端提供的配对中的关联函数。
- en: By associating the `Move` command with a function in this way, we can *guarantee*
    that the internal turtle implementation must accept a `distance` and return a
    `MoveResponse`, just as we want.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式将`Move`命令与函数关联，我们可以*保证*内部乌龟实现必须接受一个`distance`并返回一个`MoveResponse`，就像我们想要的那样。
- en: 'The next question is: what is the `something` that is the output? It is the
    output after the client has handled the response -- that is, another command/response
    chain!'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是：`something`是什么输出？这是客户端处理响应后的输出 -- 也就是，另一个命令/响应链！
- en: 'So we can model the whole chain of pairs as a recursive structure:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将整个配对链模拟成一个递归结构：
- en: '![](turtle-interpreter-nested.png)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![](turtle-interpreter-nested.png)'
- en: 'Or in code:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在代码中：
- en: '[PRE101]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: I've renamed the type from `TurtleCommand` to `TurtleProgram` because it is
    no longer just a command, but is now a complete chain of commands and associated
    response handlers.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将类型从`TurtleCommand`重命名为`TurtleProgram`，因为它不再只是一个命令，而是现在是一组完整的命令链和关联的响应处理程序。
- en: There's a problem though! Every step needs yet another `TurtleProgram` to follow
    -- so when will it stop? We need some way of saying that there is no next command.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每一步都需要另一个`TurtleProgram`来跟随 -- 那么什么时候会停止呢？我们需要一种方式来表示没有下一个命令。
- en: 'To solve this issue, we will add a special `Stop` case to the program type:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将在程序类型中添加一个特殊的`Stop`情况：
- en: '[PRE102]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note that there is no mention of `TurtleState` in this structure. How the turtle
    state is managed is internal to the interpreter, and is not part of the "instruction
    set", as it were.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这个结构中没有提及`TurtleState`。如何管理乌龟状态是解释器内部的事情，不是“指令集”的一部分。
- en: '`TurtleProgram` is an example of an Abstract Syntax Tree (AST) -- a structure
    that represents a program to interpreted (or compiled).'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`TurtleProgram`是一个抽象语法树（AST）的示例 -- 一种表示要解释（或编译）的程序的结构。'
- en: Testing the interpreter
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试解释器
- en: 'Let''s create a little program using this model. Here''s our old friend `drawTriangle`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个模型创建一个小程序。这是我们的老朋友`drawTriangle`：
- en: '[PRE103]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This program is a data structure containing only client commands and responses
    -- there are no actual turtle functions in it anywhere! And yes, it is really
    ugly right now, but we will fix that shortly.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是一个仅包含客户端命令和响应的数据结构 -- 它没有任何实际的乌龟函数！是的，现在看起来非常丑陋，但我们很快会修复它。
- en: Now the next step is to interpret this data structure.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的下一步是解释这个数据结构。
- en: Let's create an interpreter that calls the real turtle functions. How would
    we implement the `Move` case, say?
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个调用真正乌龟函数的解释器。我们如何实现`Move`情况呢？
- en: 'Well, just as described above:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，就像上面描述的那样：
- en: Get the distance and associated function from the `Move` case
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Move`情况获取距离和相关函数
- en: Call the real turtle function with the distance and current turtle state, to
    get a `MoveResult` and a new turtle state.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用真正的乌龟函数，传递距离和当前乌龟状态，以获得`MoveResult`和新的乌龟状态。
- en: Get the next step in the program by passing the `MoveResult` to the associated
    function
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`MoveResult`传递给相关函数来获取程序中的下一步
- en: Finally call the interpreter again (recursively) with the new program and new
    turtle state.
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后再次调用解释器（递归）并使用新程序和新乌龟状态。
- en: '[PRE104]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: You can see that the updated turtle state is passed as a parameter to the next
    recursive call, and so no mutable field is needed.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到更新后的乌龟状态作为参数传递给下一个递归调用，因此不需要可变字段。
- en: 'Here''s the full code for `interpretAsTurtle`:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`interpretAsTurtle`的完整代码：
- en: '[PRE105]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Let''s run it:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它：
- en: '[PRE106]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'and the output is exactly what we have seen before:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们之前看到的完全相同：
- en: '[PRE107]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: But unlike all the previous approaches we can take *exactly the same program*
    and interpret it in a new way. We don't need to set up any kind of dependency
    injection, we just need to use a different interpreter.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 但与以往所有的方法不同，我们可以*完全相同的程序*以一种新的方式解释。我们不需要设置任何形式的依赖注入，只需要使用不同的解释器。
- en: 'So let''s create another interpreter that aggregates the distance travelled,
    without caring about the turtle state:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建另一个解释器，聚合已行进的距离，而不关心乌龟状态：
- en: '[PRE108]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In this case, I've aliased `interpretAsDistance` as `recurse` locally to make
    it obvious what kind of recursion is happening.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我将`interpretAsDistance`本地别名为`recurse`，以明确表明正在发生的递归类型。
- en: 'Let''s run the same program with this new interpreter:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个新的解释器运行相同的程序：
- en: '[PRE109]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'and the output is again exactly what we expect:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 输出再次与我们期望的完全相同：
- en: '[PRE110]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Creating a "turtle program" workflow
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个“乌龟程序”工作流程
- en: That code for creating a program to interpret was pretty ugly! Can we create
    a computation expression to make it look nicer?
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个解释程序的代码非常丑陋！我们能创建一个计算表达式使其看起来更好吗？
- en: Well, in order to create a computation expression, we need `return` and `bind`
    functions, and those require that the `TurtleProgram` type be generic.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，为了创建一个计算表达式，我们需要`return`和`bind`函数，而这些需要`TurtleProgram`类型是泛型的。
- en: 'No problem! Let''s make `TurtleProgram` generic then:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题！让我们将`TurtleProgram`泛型化：
- en: '[PRE111]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Note that the `Stop` case has a value of type `''a` associated with it now.
    This is needed so that we can implement `return` properly:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Stop`情况现在有一个与之关联的`'a`类型的值。这是必要的，以便我们可以正确实现`return`：
- en: '[PRE112]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `bind` function is more complicated to implement. Don't worry about how
    it works right now -- the important thing is that the types match up and it compiles!
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`bind`函数更复杂。现在不要担心它是如何工作的 -- 重要的是类型匹配并且编译通过！
- en: '[PRE113]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'With `bind` and `return` in place, we can create a computation expression:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`bind`和`return`，我们可以创建一个计算表达式：
- en: '[PRE114]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We can now create a workflow that handles `MoveResponse`s just as in the monadic
    control flow example (way 12) earlier.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个处理`MoveResponse`的工作流程，就像之前的单调控制流示例（way 12）一样。
- en: '[PRE115]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Let''s interpret this using the real turtle functions (assuming that the `interpretAsTurtle`
    function has been modified to handle the new generic structure):'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用真正的乌龟函数来解释这个（假设`interpretAsTurtle`函数已经被修改以处理新的通用结构）：
- en: '[PRE116]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output shows that the `MoveResponse` is indeed being handled correctly
    when the barrier is encountered:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，当遇到障碍时确实正确处理了`MoveResponse`：
- en: '[PRE117]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Refactoring the `TurtleProgram` type into two parts
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将`TurtleProgram`类型重构为两部分
- en: This approach works fine, but it bothers me that there is a special `Stop` case
    in the `TurtleProgram` type. It would nice if we could somehow just focus on the
    five turtle actions and ignore it.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法运行良好，但是`TurtleProgram`类型中存在一个特殊的`Stop`情况让我感到困扰。如果我们能够只专注于五个乌龟动作并忽略它就好了。
- en: As it turns out, there *is* a way to do this. In Haskell and Scalaz it would
    be called a "free monad", but since F# doesn't support typeclasses, I'll just
    call it the "free monad pattern" that you can use to solve the problem. There's
    a little bit of boilerplate that you have to write, but not much.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，确实有一种方法可以做到这一点。在Haskell和Scalaz中，它将被称为“自由单子”，但由于F#不支持类型类，我将其称为“自由单子模式”，您可以使用它来解决问题。您需要编写一些样板代码，但不多。
- en: 'The trick is to separate the api cases and "stop"/"keep going" logic into two
    separate types, like this:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧是将API案例和“停止”/“继续”的逻辑分开成两种不同的类型，就像这样：
- en: '[PRE118]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note that I've also changed the responses for `Turn`, `PenUp` and `PenDown`
    to be single values rather than a unit function. `Move` and `SetColor` remain
    as functions though.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我还将`Turn`、`PenUp`和`PenDown`的响应更改为单个值，而不是一个单位函数。`Move`和`SetColor`仍然是函数。
- en: 'In this new "free monad" approach, the only custom code we need to write is
    a simple `map` function for the api type, in this case `TurtleInstruction`:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种新的“自由单子”方法中，我们需要编写的唯一自定义代码是API类型的简单`map`函数，本例中为`TurtleInstruction`：
- en: '[PRE119]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The rest of the code (`return`, `bind`, and the computation expression) is [always
    implemented exactly the same way](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/4a8cdf3bda9fc9db030842e99f78487aea928e57/13-Interpreter-v2.fsx#L67),
    regardless of the particular api. That is, more boilerplate is needed but less
    thinking is required!
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 其余代码（`return`、`bind`和计算表达式）[始终以完全相同的方式实现](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/4a8cdf3bda9fc9db030842e99f78487aea928e57/13-Interpreter-v2.fsx#L67)，无论特定的API如何。也就是说，需要更多的样板代码，但需要的思考较少！
- en: 'The interpreters need to change in order to handle the new cases. Here''s a
    snippet of the new version of `interpretAsTurtle`:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器需要更改以处理新情况。以下是`interpretAsTurtle`的新版本片段：
- en: '[PRE120]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: And we also need to adjust the helper functions when creating a workflow. You
    can see below that we now have slightly more complicated code like `KeepGoing
    (Move (dist, Stop))` instead of the simpler code in the original interpreter.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建工作流程时，我们还需要调整辅助函数。您可以看到，现在我们有了稍微复杂一些的代码，例如`KeepGoing (Move (dist, Stop))`，而不是原始解释器中的简单代码。
- en: '[PRE121]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: But with those changes, we are done, and the code works just as before.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 但是随着这些更改，我们完成了，代码的工作方式与以前完全相同。
- en: Advantages and disadvantages of the interpreter pattern
  id: totrans-706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释器模式的优缺点
- en: '*Advantages*'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '*优势*'
- en: '*Decoupling.* An abstract syntax tree completely decouples the program flow
    from the implementation and allows lots of flexibility.'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解耦.* 抽象语法树完全将程序流程与实现分离，并允许灵活性。'
- en: '*Optimization*. Abstract syntax trees can be manipulated and changed *before*
    running them, in order to do optimizations or other transformations. As an example,
    for the turtle program, we could process the tree and collapse all contiguous
    sequences of `Turn` into a single `Turn` operation. This is a simple optimization
    which saves on the number of times we need to communicate with a physical turtle.
    [Twitter''s Stitch library](https://engineering.twitter.com/university/videos/introducing-stitch)
    does something like this, but obviously, in a more sophisticated way. [This video
    has a good explanation](https://www.youtube.com/watch?v=VVpmMfT8aYw&feature=youtu.be&t=625).'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化*。抽象语法树可以在运行之前被操纵和修改，以进行优化或其他转换。例如，对于乌龟程序，我们可以处理树并将所有连续的`Turn`序列折叠成单个`Turn`操作。这是一种简单的优化，可以减少我们与物理乌龟通信的次数。[Twitter的Stitch库](https://engineering.twitter.com/university/videos/introducing-stitch)也做了类似的事情，但显然更加复杂。[这个视频有一个很好的解释](https://www.youtube.com/watch?v=VVpmMfT8aYw&feature=youtu.be&t=625)。'
- en: '*Minimal code for a lot of power*. The "free monad" approach to creating abstract
    syntax trees allows you to focus on the API and ignore the Stop/KeepGoing logic,
    and also means that only a minimal amount of code needs to be customized. For
    more on the free monad, start with [this excellent video](https://www.youtube.com/watch?v=hmX2s3pe_qk)
    and then see [this post](http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html)
    and [this one](http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html).'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为了获得很大的功能而编写的最小代码量*。使用自由单子方法创建抽象语法树允许您专注于API并忽略Stop/KeepGoing逻辑，并且意味着只需定制一小部分代码。有关自由单子的更多信息，请从[这个出色的视频](https://www.youtube.com/watch?v=hmX2s3pe_qk)开始，然后查看[这篇文章](http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html)和[这篇文章](http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html)。'
- en: '*Disadvantages*'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Complex to understand.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解起来复杂。
- en: Only works well if there are a limited set of operations to perform.
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在需要执行有限的操作集时才能正常工作。
- en: Can be inefficient if the ASTs get too large.
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果AST变得太大，可能效率低下。
- en: '*The source code for this version is available [here (original version)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/13-Interpreter-v1.fsx)
    and [here ("free monad" version)](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/13-Interpreter-v2.fsx).*'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '*此版本的源代码可在[此处（原始版本）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/13-Interpreter-v1.fsx)和[此处（"free
    monad"版本）](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/13-Interpreter-v2.fsx)找到。*'
- en: '* * *'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Review of techniques used
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用的技术回顾
- en: 'In this post, we looked at thirteen different ways to implement a turtle API,
    using a wide variety of different techniques. Let''s quickly run down all the
    techniques that were used:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们看了13种不同的方式来实现一个乌龟API，使用了各种各样的技术。让我们快速回顾一下所使用的所有技术：
- en: '**Pure, stateless functions**. As seen in all of the FP-oriented examples.
    All these are very easy to test and mock.'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯粹的，无状态的函数**。正如所有以FP为导向的示例所见。所有这些都非常容易测试和模拟。'
- en: '**Partial application**. As first seen in [the simplest FP example (way 2)](13-ways-of-looking-at-a-turtle.html#way2),
    when the turtle functions had the logging function applied so that the main flow
    could use piping, and thereafter used extensively, particularly in the ["dependency
    injection using functions approach" (way 7)](13-ways-of-looking-at-a-turtle.html#way7).'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分应用**。正如首次在[最简单的FP示例（方式2）](13-ways-of-looking-at-a-turtle.html#way2)中所见，当应用了日志记录函数以便主流程可以使用管道后，便得到广泛应用，特别是在["使用函数进行依赖注入的方法"（方式7）](13-ways-of-looking-at-a-turtle.html#way7)中。'
- en: '**Object expressions** to implement an interface without creating a class,
    as seen in [way 6](13-ways-of-looking-at-a-turtle.html#way6).'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象表达式**用于实现接口而不创建类，正如[方式6](13-ways-of-looking-at-a-turtle.html#way6)所示。'
- en: '**The Result type** (a.k.a the Either monad). Used in all the functional API
    examples ([e.g. way 4](13-ways-of-looking-at-a-turtle.html#way4)) to return an
    error rather than throw an exception.'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Result类型**（又称Either单子）。在所有的函数式API示例中使用（[例如方式4](13-ways-of-looking-at-a-turtle.html#way4)）返回错误而不是抛出异常。'
- en: '**Applicative "lifting"** (e.g. `lift2`) to lift normal functions to the world
    of `Result`s, again [in way 4](13-ways-of-looking-at-a-turtle.html#way4) and others.'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Applicative "lifting"**（例如`lift2`）将普通函数提升到`Result`的世界中，同样在[方式4](13-ways-of-looking-at-a-turtle.html#way4)和其他地方。'
- en: '**Lots of different ways of managing state**:'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理状态的不同方式很多**：'
- en: mutable fields (way 1)
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变字段（方式1）
- en: managing state explicitly and piping it though a series of functions (way 2)
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确管理状态并通过一系列函数进行管道传输（第2种方式）
- en: having state only at the edge (the functional core/imperative shell in way 4)
  id: totrans-727
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在边缘拥有状态（第4种方式中的功能核心/命令外壳）
- en: hiding state in an agent (way 5)
  id: totrans-728
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代理中隐藏状态（第5种方式）
- en: threading state behind the scenes in a state monad (the `turtle` workflow in
    ways 8 and 12)
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态单子中在幕后线程状态（第8和第12种方式中的`turtle`工作流程）
- en: avoiding state altogether by using batches of commands (way 9) or batches of
    events (way 10) or an interpreter (way 13)
  id: totrans-730
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用命令批处理（第9种方式）或事件批处理（第10种方式）或解释器（第13种方式）来完全避免状态。
- en: '**Wrapping a function in a type**. Used in [way 8](13-ways-of-looking-at-a-turtle.html#way8)
    to manage state (the State monad) and in [way 13](13-ways-of-looking-at-a-turtle.html#way13)
    to store responses.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数包装在类型中。在[第8种方式](13-ways-of-looking-at-a-turtle.html#way8)中用于管理状态（状态单子），在[第13种方式](13-ways-of-looking-at-a-turtle.html#way13)中用于存储响应。
- en: '**Computation expressions**, lots of them! We created and used three:'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算表达式**，很多！我们创建并使用了三个：'
- en: '`result` for working with errors'
  id: totrans-733
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理错误的`result`
- en: '`turtle` for managing turtle state'
  id: totrans-734
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于管理龟状态的`turtle`
- en: '`turtleProgram` for building an AST in the interpreter approach ([way 13](13-ways-of-looking-at-a-turtle-2.html#way13)).'
  id: totrans-735
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在解释器方法中构建AST的`turtleProgram`（[第13种方式](13-ways-of-looking-at-a-turtle-2.html#way13)）。
- en: '**Chaining of monadic functions** in the `result` and `turtle` workflows. The
    underlying functions are monadic ("diagonal") and would not normally compose properly,
    but inside a workflow, they can be sequenced easily and transparently.'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在`result`和`turtle`工作流程中链式单子函数**。底层函数是单子的（"对角线"）并且通常不能正确组合，但在工作流程中，它们可以轻松和透明地被顺序化。'
- en: '**Representing behavior as a data structure** in the ["functional dependency
    injection" example (way 7)](13-ways-of-looking-at-a-turtle.html#way7) so that
    a single function could be passed in rather than a whole interface.'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在["函数依赖注入"示例（第7种方式）](13-ways-of-looking-at-a-turtle.html#way7)中将行为表示为数据结构，这样就可以传递单个函数而不是整个接口。
- en: '**Decoupling using a data-centric protocol** as seen in the agent, batch command,
    event sourcing, and interpreter examples.'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用以数据为中心的协议解耦**，如代理、批处理命令、事件源和解释器示例中所见。'
- en: '**Lock free and async processing** using an agent (way 5).'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理（第5种方式）进行无锁和异步处理。
- en: '**The separation of "building" a computation vs. "running" it**, as seen in
    the `turtle` workflows (ways 8 and 12) and the `turtleProgram` workflow (way 13:
    interpreter).'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在`turtle`工作流程（第8和第12种方式）以及`turtleProgram`工作流程（第13种方式：解释器）中看到的**"构建"计算与"运行"它的分离。'
- en: '**Use of event sourcing to rebuild state** from scratch rather than maintaining
    mutable state in memory, as seen in the [event sourcing (way 10)](13-ways-of-looking-at-a-turtle-2.html#way10)
    and [FRP (way 11)](13-ways-of-looking-at-a-turtle-2.html#way11) examples.'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用事件源重新构建状态**，而不是在内存中维护可变状态，如在[event sourcing（第10种方式）](13-ways-of-looking-at-a-turtle-2.html#way10)和[FRP（第11种方式）](13-ways-of-looking-at-a-turtle-2.html#way11)示例中所见。'
- en: '**Use of event streams** and [FRP (way 11)](13-ways-of-looking-at-a-turtle-2.html#way11)
    to break business logic into small, independent, and decoupled processors rather
    than having a monolithic object.'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用事件流**和[FRP（第11种方式）](13-ways-of-looking-at-a-turtle-2.html#way11)将业务逻辑分解为小型、独立和解耦的处理器，而不是使用单块对象。'
- en: I hope it's clear that examining these thirteen ways is just a fun exercise,
    and I'm not suggesting that you immediately convert all your code to use stream
    processors and interpreters! And, especially if you are working with people who
    are new to functional programming, I would tend to stick with the earlier (and
    simpler) approaches unless there is a clear benefit in exchange for the extra
    complexity.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些十三种方法的检查只是一个有趣的练习，我并不是建议您立即将所有代码转换为使用流处理器和解释器！特别是如果您正在与新手接触函数式编程的人一起工作，我倾向于坚持早期（更简单）的方法，除非有明显的好处可以换取额外的复杂性。
- en: '* * *'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summary
  id: totrans-745
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: When the tortoise crawled out of sight,
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当乌龟爬出视线时，
- en: It marked the edge
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它标记了边缘
- en: Of one of many circles.
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其中一个许多圈之一。
- en: -- *"Thirteen ways of looking at a turtle", by Wallace D Coriacea*
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- *《审视乌龟的十三种方式》, 华莱士·D·科里亚斯*
- en: I hope you enjoyed this post. I certainly enjoyed writing it. As usual, it ended
    up much longer than I intended, so I hope that the effort of reading it was worth
    it to you!
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢这篇文章。我当然喜欢写它。像往常一样，它的长度比我预期的要长得多，所以我希望您阅读它的努力对您来说是值得的！
- en: If you like this kind of comparative approach, and want more, check out [the
    posts by Yan Cui, who is doing something similar](http://theburningmonk.com/fsharp-exercises-in-programming-style/)
    on his blog.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这种比较的方法，并想要更多，请查看[Yan Cui 的文章，他在博客上做了类似的事情](http://theburningmonk.com/fsharp-exercises-in-programming-style/)。
- en: Enjoy the rest of the [F# Advent Calendar](https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/).
    Happy Holidays!
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 祝您享受[F# Advent Calendar](https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/)的剩余部分。节日快乐！
- en: '*The source code for this post is available [on github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle).*'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文的源代码可在[GitHub](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle)上找到。*'
- en: Thirteen ways of looking at a turtle - addendum
  id: totrans-754
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看待海龟的十三种方式 - 补充说明
- en: Thirteen ways of looking at a turtle - addendum
  id: totrans-755
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看待海龟的十三种方式 - 补充说明
- en: In this, the third part of my two-part mega-post, I'm continuing to stretch
    the simple turtle graphics model to the breaking point.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个两部分巨篇的第三部分中，我继续将简单的海龟图形模型拉伸到极限。
- en: In the [first](13-ways-of-looking-at-a-turtle.html) and [second post](13-ways-of-looking-at-a-turtle-2.html),
    I described thirteen different ways of looking at a turtle graphics implementation.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一篇](13-ways-of-looking-at-a-turtle.html)和[第二篇](13-ways-of-looking-at-a-turtle-2.html)文章中，我描述了看待海龟图形实现的十三种不同方式。
- en: Unfortunately, after I published them, I realized that there were some other
    ways that I had forgotten to mention. So in this post, you'll get to see two BONUS
    ways.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，发布后，我意识到有一些我忘记提到的其他方法。所以在这篇文章中，您将看到两种额外的方式。
- en: '[Way 14\. Abstract Data Turtle](13-ways-of-looking-at-a-turtle-3.html#way14),
    in which we encapsulate the details of a turtle implementation by using an Abstract
    Data Type.'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 14 种方式：抽象数据海龟](13-ways-of-looking-at-a-turtle-3.html#way14)，通过使用抽象数据类型封装海龟实现的细节。'
- en: '[Way 15\. Capability-based Turtle](13-ways-of-looking-at-a-turtle-3.html#way15),
    in which we control what turtle functions are available to a client, based on
    the current state of the turtle.'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 15 种方式：基于能力的海龟](13-ways-of-looking-at-a-turtle-3.html#way15)，根据海龟的当前状态控制客户端可用的海龟函数。'
- en: 'As a reminder, here were the previous thirteen ways:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这是之前的十三种方式：
- en: '[Way 1\. A basic object-oriented approach](13-ways-of-looking-at-a-turtle.html#way1),
    in which we create a class with mutable state.'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 种方式：基本面向对象方法](13-ways-of-looking-at-a-turtle.html#way1)，创建一个具有可变状态的类。'
- en: '[Way 2\. A basic functional approach](13-ways-of-looking-at-a-turtle.html#way2),
    in which we create a module of functions with immutable state.'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 2 种方式：基本函数式方法](13-ways-of-looking-at-a-turtle.html#way2)，创建一个具有不可变状态的函数模块。'
- en: '[Way 3\. An API with a object-oriented core](13-ways-of-looking-at-a-turtle.html#way3),
    in which we create an object-oriented API that calls a stateful core class.'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 种方式：具有面向对象核心的 API](13-ways-of-looking-at-a-turtle.html#way3)，创建一个调用有状态核心类的面向对象
    API。'
- en: '[Way 4\. An API with a functional core](13-ways-of-looking-at-a-turtle.html#way4),
    in which we create an stateful API that uses stateless core functions.'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 4 种方式：具有功能核心的 API](13-ways-of-looking-at-a-turtle.html#way4)，创建一个使用无状态核心函数的有状态
    API。'
- en: '[Way 5\. An API in front of an agent](13-ways-of-looking-at-a-turtle.html#way5),
    in which we create an API that uses a message queue to communicate with an agent.'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 5 种方式：代理前端的 API](13-ways-of-looking-at-a-turtle.html#way5)，创建一个使用消息队列与代理通信的
    API。'
- en: '[Way 6\. Dependency injection using interfaces](13-ways-of-looking-at-a-turtle.html#way6),
    in which we decouple the implementation from the API using an interface or record
    of functions.'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 6 种方式：使用接口进行依赖注入](13-ways-of-looking-at-a-turtle.html#way6)，通过使用接口或函数记录将实现与
    API 解耦。'
- en: '[Way 7\. Dependency injection using functions](13-ways-of-looking-at-a-turtle.html#way7),
    in which we decouple the implementation from the API by passing a function parameter.'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 7 种方式：使用函数进行依赖注入](13-ways-of-looking-at-a-turtle.html#way7)，通过传递函数参数将实现与
    API 解耦。'
- en: '[Way 8\. Batch processing using a state monad](13-ways-of-looking-at-a-turtle.html#way8),
    in which we create a special "turtle workflow" computation expression to track
    state for us.'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 8 种方式：使用状态单子进行批处理](13-ways-of-looking-at-a-turtle.html#way8)，创建一个特殊的“海龟工作流”计算表达式来跟踪状态。'
- en: '[Way 9\. Batch processing using command objects](13-ways-of-looking-at-a-turtle.html#way9),
    in which we create a type to represent a turtle command, and then process a list
    of commands all at once.'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 9 种方式：使用命令对象进行批处理](13-ways-of-looking-at-a-turtle.html#way9)，创建一个代表海龟命令的类型，然后一次处理所有命令列表。'
- en: '[Interlude: Conscious decoupling with data types](13-ways-of-looking-at-a-turtle.html#decoupling).
    A few notes on using data vs. interfaces for decoupling.'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[插曲：使用数据类型进行有意识的解耦](13-ways-of-looking-at-a-turtle.html#decoupling)。关于使用数据与接口进行解耦的一些注意事项。'
- en: '[Way 10\. Event sourcing](13-ways-of-looking-at-a-turtle-2.html#way10), in
    which state is built from a list of past events.'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10种方式：事件溯源](13-ways-of-looking-at-a-turtle-2.html#way10)，其中状态是从过去事件列表中构建的。'
- en: '[Way 11\. Functional Retroactive Programming (stream processing)](13-ways-of-looking-at-a-turtle-2.html#way11),
    in which business logic is based on reacting to earlier events.'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11种方式：函数式追溯编程（流处理）](13-ways-of-looking-at-a-turtle-2.html#way11)，其中业务逻辑基于对之前事件的反应。'
- en: '[Episode V: The Turtle Strikes Back](13-ways-of-looking-at-a-turtle-2.html#strikes-back),
    in which the turtle API changes so that some commands may fail.'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第五集：乌龟的反击](13-ways-of-looking-at-a-turtle-2.html#strikes-back)，在这一集中，乌龟API发生变化，因此一些命令可能会失败。'
- en: '[Way 12\. Monadic control flow](13-ways-of-looking-at-a-turtle-2.html#way12),
    in which we make decisions in the turtle workflow based on results from earlier
    commands.'
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第12种方式：单子控制流](13-ways-of-looking-at-a-turtle-2.html#way12)，在这种方式中，我们根据之前命令的结果在乌龟工作流中做出决策。'
- en: '[Way 13\. A turtle interpreter](13-ways-of-looking-at-a-turtle-2.html#way13),
    in which we completely decouple turtle programming from turtle implementation,
    and nearly encounter the free monad.'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第13种方式：乌龟解释器](13-ways-of-looking-at-a-turtle-2.html#way13)，在这种方式中，我们完全将乌龟编程与乌龟实现解耦，并几乎遇到了自由单子。'
- en: '[Review of all the techniques used](13-ways-of-looking-at-a-turtle-2.html#review).'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[所有使用的技术的回顾](13-ways-of-looking-at-a-turtle-2.html#review)。'
- en: All source code for this post is available [on github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle).
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 本文所有源代码都可以在[github上找到](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle)。
- en: '* * *'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '14: Abstract Data Turtle'
  id: totrans-780
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14：抽象数据乌龟
- en: In this design, we use the concept of an [abstract data type](https://en.wikipedia.org/wiki/Abstract_data_type)
    to encapsulate the operations on a turtle.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，我们使用[抽象数据类型](https://en.wikipedia.org/wiki/Abstract_data_type)的概念来封装对乌龟的操作。
- en: That is, a "turtle" is defined as an opaque type along with a corresponding
    set of operations, in the same way that standard F# types such as `List`, `Set`
    and `Map` are defined.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，“乌龟”被定义为一个不透明类型，以及一组相应的操作，就像标准的F#类型（如`List`、`Set`和`Map`）一样被定义。
- en: That is, we have number of functions that work on the type, but we are not allowed
    to see "inside" the type itself.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们有许多在该类型上工作的函数，但我们不允许看到类型本身的“内部”。
- en: In a sense, you can think of it as a third alternative to the [OO approach in
    way 1](13-ways-of-looking-at-a-turtle.html#way1) and the [functional approach
    in way 2](13-ways-of-looking-at-a-turtle.html#way2).
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上讲，你可以将其视为[第1种方式中的面向对象方法](13-ways-of-looking-at-a-turtle.html#way1)和[第2种方式中的函数式方法](13-ways-of-looking-at-a-turtle.html#way2)的第三种替代方案。
- en: In the OO implementation, the details of the internals are nicely encapsulated,
    and access is only via methods. The downside of the OO class is that it is mutable.
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面向对象实现中，内部细节被很好地封装，访问只能通过方法进行。面向对象类的缺点是它是可变的。
- en: In the FP implementation, the `TurtleState` is immutable, but the downside is
    that the internals of the state are public, and some clients may have accessed
    these fields, so if we ever change the design of `TurtleState`, these clients
    may break.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数式编程实现中，`TurtleState`是不可变的，但缺点是状态的内部是公开的，一些客户端可能已经访问了这些字段，因此如果我们改变`TurtleState`的设计，这些客户端可能会出现问题。
- en: 'The abstract data type implementation combines the best of both worlds: the
    turtle state is immutable, as in the original FP way, but no client can access
    it, as in the OO way.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象数据类型的实现结合了两种方式的优点：乌龟状态是不可变的，就像原始的FP方式一样，但没有客户端可以访问它，就像OO方式一样。
- en: 'The design for this (and for any abstract type) is as follows:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这种（以及任何抽象类型的）设计如下：
- en: The turtle state type itself is public, but its constructor and fields are private.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乌龟状态类型本身是公开的，但其构造函数和字段是私有的。
- en: The functions in the associated `Turtle` module can see inside the turtle state
    type (and so are unchanged from the FP design).
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关的`Turtle`模块中的函数可以看到乌龟状态类型的内部（因此与FP设计相同）。
- en: Because the turtle state constructor is private, we need a constructor function
    in the `Turtle` module.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为乌龟状态构造函数是私有的，所以我们需要在`Turtle`模块中有一个构造函数。
- en: The client can *not* see inside the turtle state type, and so must rely entirely
    on the `Turtle` module functions.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端*不能*看到乌龟状态类型的内部，因此必须完全依赖`Turtle`模块函数。
- en: That's all there is to it. We only need to add some privacy modifiers to the
    earlier FP version and we are done!
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们只需要为之前的FP版本添加一些隐私修饰符，然后就完成了！
- en: The implementation
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: First, we are going to put both the turtle state type and the `Turtle` module
    inside a common module called `AdtTurtle`. This allows the turtle state to be
    accessible to the functions in the `AdtTurtle.Turtle` module, while being inaccessible
    outside the `AdtTurtle`.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把海龟状态类型和`Turtle`模块都放在一个名为`AdtTurtle`的公共模块中。这允许海龟状态对`AdtTurtle.Turtle`模块中的函数可见，而在`AdtTurtle`之外是不可访问的。
- en: Next, the turtle state type is going to be called `Turtle` now, rather than
    `TurtleState`, because we are treating it almost as an object.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，海龟状态类型现在将被称为`Turtle`，而不是`TurtleState`，因为我们几乎将其视为一个对象。
- en: 'Finally, the associated module `Turtle` (that contains the functions) is going
    have some special attributes:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关联模块`Turtle`（包含函数的模块）将具有一些特殊属性：
- en: '`RequireQualifiedAccess` means the module name *must* be used when accessing
    the functions (just like `List` module)'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequireQualifiedAccess`意味着在访问函数时必须使用模块名称（就像`List`模块一样）'
- en: '`ModuleSuffix` is needed so the that module can have the same name as the state
    type. This would not be required for generic types (e.g if we had `Turtle<''a>`
    instead).'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleSuffix`是必需的，以便模块可以与状态类型具有相同的名称。对于通用类型（例如如果我们有`Turtle<''a>`），这是不需要的。'
- en: '[PRE122]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'An alternative way to avoid collisions is to have the state type have a different
    case, or a different name with a lowercase alias, like this:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 避免冲突的另一种方法是让状态类型具有不同的大小写，或者使用一个小写别名，像这样：
- en: '[PRE123]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: No matter how the naming is done, we will need a way to construct a new `Turtle`.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 无论命名方式如何，我们都需要一种方法来构造一个新的`Turtle`。
- en: If there are no parameters to the constructor, and the state is immutable, then
    we just need an initial value rather than a function (like `Set.empty` say).
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数没有参数，并且状态是不可变的，那么我们只需要一个初始值而不是一个函数（比如`Set.empty`）。
- en: 'Otherwise we can define a function called `make` (or `create` or similar):'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可以定义一个名为`make`（或`create`或类似的）的函数：
- en: '[PRE124]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The rest of the turtle module functions are unchanged from their implementation
    in [way 2](13-ways-of-looking-at-a-turtle.html#way2).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟模块的其余功能与它们在[way 2](13-ways-of-looking-at-a-turtle.html#way2)中的实现保持不变。
- en: An ADT client
  id: totrans-808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ADT客户端
- en: Let's look the client now.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看客户端。
- en: 'First, let''s check that the state really is private. If we try to create a
    state explicitly, as shown below, we get a compiler error:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查状态是否真的是私有的。如果我们尝试显式创建状态，如下所示，我们会得到一个编译器错误：
- en: '[PRE125]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If we use the constructor and then try to directly access a field directly
    (such as `position`), we again get a compiler error:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用构造函数然后尝试直接访问字段（例如`position`），我们会再次收到编译器错误：
- en: '[PRE126]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'But if we stick to the functions in the `Turtle` module, we can safely create
    a state value and then call functions on it, just as we did before:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们坚持使用`Turtle`模块中的函数，我们可以安全地创建一个状态值，然后调用函数，就像以前一样：
- en: '[PRE127]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Advantages and disadvantages of ADTs
  id: totrans-816
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ADT的优缺点
- en: '*Advantages*'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '*优势*'
- en: All code is stateless, hence easy to test.
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代码都是无状态的，因此易于测试。
- en: The encapsulation of the state means that the focus is always fully on the behavior
    and properties of the type.
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态的封装意味着焦点始终完全放在类型的行为和属性上。
- en: Clients can never have a dependency on a particular implementation, which means
    that implementations can be changed safely.
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端永远不会依赖于特定的实现，这意味着可以安全地更改实现。
- en: You can even swap implementations (e.g. by shadowing, or linking to a different
    assembly) for testing, performance, etc.
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至可以交换实现（例如通过遮盖或链接到不同的程序集）进行测试、性能等。
- en: '*Disadvantages*'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: The client has to manage the current turtle state.
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须管理当前的海龟状态。
- en: The client has no control over the implementation (e.g. by using dependency
    injection).
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端无法控制实现（例如使用依赖注入）。
- en: For more on ADTs in F#, see [this talk and thread](https://www.reddit.com/r/fsharp/comments/36s0zr/structuring_f_programs_with_abstract_data_types/?)
    by Bryan Edds.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 有关F#中ADT的更多信息，请参阅Bryan Edds的[此演讲和帖子](https://www.reddit.com/r/fsharp/comments/36s0zr/structuring_f_programs_with_abstract_data_types/?)。
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/14-AdtTurtle.fsx).*'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '*此版本的源代码可在[此处](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/14-AdtTurtle.fsx)找到。*'
- en: '* * *'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '15: Capability-based Turtle'
  id: totrans-828
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15：基于能力的海龟
- en: In the "monadic control flow" approach [(way 12)](13-ways-of-looking-at-a-turtle-2.html#way12)
    we handled responses from the turtle telling us that it had hit a barrier.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 在“单子控制流”方法中 [(way 12)](13-ways-of-looking-at-a-turtle-2.html#way12)，我们处理了乌龟告诉我们它已经撞到障碍物的响应。
- en: But even though we had hit a barrier, nothing was stopping us from calling the
    `move` operation over and over again!
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使我们撞到了障碍物，也没有阻止我们一遍又一遍地调用`move`操作！
- en: Now imagine that, once we had hit the barrier, the `move` operation was no longer
    available to us. We couldn't abuse it because it would be no longer there!
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，一旦我们撞到了障碍物，`move`操作对我们将不再可用。我们无法滥用它，因为它将不再存在！
- en: To make this work, we shouldn't provide an API, but instead, after each call,
    return a list of functions that the client can call to do the next step. The functions
    would normally include the usual suspects of `move`, `turn`, `penUp`, etc., but
    when we hit a barrier, `move` would be dropped from that list. Simple, but effective.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此工作生效，我们不应提供API，而是在每次调用后返回客户端可以调用的函数列表来执行下一步。这些函数通常会包括`move`，`turn`，`penUp`等常见功能，但当我们遇到障碍时，`move`将从列表中删除。简单而有效。
- en: This technique is closely related to an authorization and security technique
    called *capability-based security*. If you are interested in learning more, I
    have [a whole series of posts devoted to it](capability-based-security.html).
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与一种称为*基于能力的安全*的授权和安全技术密切相关。如果你想了解更多，我有[一整套专门的帖子](capability-based-security.html)。
- en: Designing a capability-based Turtle
  id: totrans-834
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计基于能力的Turtle
- en: 'The first thing is to define the record of functions that will be returned
    after each call:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是定义每次调用后将返回的函数记录：
- en: '[PRE128]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Let's look at these declarations in detail.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看这些声明。
- en: First, there is no `TurtleState` anywhere. The published turtle functions will
    encapsulate the state for us. Similarly there is no `log` function.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，任何地方都没有`TurtleState`。发布的乌龟函数将为我们封装状态。同样，也没有`log`函数。
- en: 'Next, the record of functions `TurtleFunctions` defines a field for each function
    in the API (`move`, `turn`, etc.):'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数记录`TurtleFunctions`为API中的每个函数定义了一个字段（`move`，`turn`等）：
- en: The `move` function is optional, meaning that it might not be available.
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`move`函数是可选的，意味着它可能不可用。'
- en: The `turn`, `penUp` and `penDown` functions are always available.
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`turn`，`penUp`和`penDown`函数始终可用。'
- en: The `setColor` operation has been broken out into three separate functions,
    one for each color, because you might not be able to use red ink, but still be
    able to use blue ink. To indicate that these functions might not be available,
    `option` is used again.
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setColor`操作已被分解为三个单独的函数，每个函数对应一个颜色，因为你可能无法使用红色墨水，但仍然可以使用蓝色墨水。为了表明这些函数可能不可用，再次使用了`option`。'
- en: We have also declared type aliases for each function to make them easier to
    work. Writing `MoveFn` is easier than writing `Distance -> (MoveResponse * TurtleFunctions)`
    everywhere! Note that, since these definitions are mutually recursive, I was forced
    to use the `and` keyword.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为每个函数声明了类型别名，以使它们更易于工作。编写`MoveFn`比在所有地方写`Distance -> (MoveResponse * TurtleFunctions)`更容易！请注意，由于这些定义是相互递归的，我被迫使用`and`关键字。
- en: Finally, note the difference between the signature of `MoveFn` in this design
    and the signature of `move` in [the earlier design of way 12](13-ways-of-looking-at-a-turtle-2.html#way12).
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意此设计中`MoveFn`的签名与[way 12的早期设计中`move`的签名](13-ways-of-looking-at-a-turtle-2.html#way12)之间的差异。
- en: 'Earlier version:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本：
- en: '[PRE129]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'New version:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本：
- en: '[PRE130]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: On the input side, the `Log` and `TurtleState` parameters are gone, and on the
    output side, the `TurtleState` has been replaced with `TurtleFunctions`.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入端，`Log`和`TurtleState`参数消失了，而在输出端，`TurtleState`已被`TurtleFunctions`替换。
- en: This means that somehow, the output of every API function must be changed to
    be a `TurtleFunctions` record.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个API函数的输出都必须以`TurtleFunctions`记录的形式改变。
- en: Implementing the turtle operations
  id: totrans-851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现乌龟操作
- en: 'In order to decide whether we can indeed move, or use a particular color, we
    first need to augment the `TurtleState` type to track these factors:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定我们是否确实可以移动，或者使用特定颜色，我们首先需要扩充`TurtleState`类型以跟踪这些因素：
- en: '[PRE131]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This has been enhanced with
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经得到增强
- en: '`canMove`, which if false means that we are at a barrier and should not return
    a valid `move` function.'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canMove`，如果为false意味着我们处于障碍物位置，不应返回有效的`move`函数。'
- en: '`availableInk` contains a set of colors. If a color is not in this set, then
    we should not return a valid `setColorXXX` function for that color.'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`availableInk`包含一组颜色。如果一个颜色不在这个集合中，那么我们就不应该为该颜色返回一个有效的`setColorXXX`函数。'
- en: Finally, we've added the `log` function into the state so that we don't have
    to pass it explicitly to each operation. It will get set once, when the turtle
    is created.
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将`log`函数添加到状态中，这样我们就不必明确地将其传递给每个操作。它将在乌龟创建时设置一次。
- en: The `TurtleState` is getting a bit ugly now, but that's alright, because it's
    private! The clients will never even see it.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '`TurtleState`现在有点丑陋，但没关系，因为它是私有的！客户端甚至不会看到它。'
- en: 'With this augmented state available, we can change `move`. First we''ll make
    it private, and second we''ll set the `canMove` flag (using `moveResult <> HitABarrier`)
    before returning a new state:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个增强的状态，我们可以改变`move`。首先我们将其设置为私有，然后在返回新状态之前设置`canMove`标志（使用`moveResult <>
    HitABarrier`）：
- en: '[PRE132]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We need some way of changing `canMove` back to true! So let's assume that if
    you turn, you can move again.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要某种方法来将`canMove`改回true！所以让我们假设如果你转弯了，你就能再次移动。
- en: 'Let''s add that logic to the `turn` function then:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个逻辑加到`turn`函数中去：
- en: '[PRE133]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The `penUp` and `penDown` functions are unchanged, other than being made private.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '`penUp`和`penDown`函数没有变化，除了被设置为私有。'
- en: And for the last operation, `setColor`, we'll remove the ink from the availability
    set as soon as it is used just once!
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个操作`setColor`，我们将在它被使用一次后立即从可用性集合中删除墨水！
- en: '[PRE134]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Finally we need a function that can create a `TurtleFunctions` record from the
    `TurtleState`. I'll call it `createTurtleFunctions`.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们需要一个函数，它可以从`TurtleState`创建一个`TurtleFunctions`记录。我会叫它`createTurtleFunctions`。
- en: 'Here''s the complete code, and I''ll discuss it in detail below:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的代码，我将在下面详细讨论它：
- en: '[PRE135]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Let's look at how this works.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。
- en: First, note that this function needs the `rec` keyword attached, as it refers
    to itself. I've added a shorter alias (`ctf`) for it as well.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意该函数需要附加`rec`关键字，因为它引用了自身。我还为其添加了一个更短的别名（`ctf`）。
- en: 'Next, new versions of each of the API functions are created. For example, a
    new `turn` function is defined like this:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建每个API函数的新版本。例如，定义一个新的`turn`函数如下：
- en: '[PRE136]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This calls the original `turn` function with the logger and state, and then
    uses the recursive call (`ctf`) to convert the new state into the record of functions.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用了原始的`turn`函数，并使用递归调用（`ctf`）将新状态转换为函数记录。
- en: 'For an optional function like `move`, it is a bit more complicated. An inner
    function `f` is defined, using the orginal `move`, and then either `f` is returned
    as `Some`, or `None` is returned, depending on whether the `state.canMove` flag
    is set:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`move`这样的可选函数，情况就有点复杂了。定义一个内部函数`f`，使用原始的`move`，然后根据`state.canMove`标志是设置为`Some`还是`None`：
- en: '[PRE137]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Similarly, for `setColor`, an inner function `f` is defined and then returned
    or not depending on whether the color parameter is in the `state.availableInk`
    collection:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于`setColor`，定义了一个内部函数`f`，然后根据颜色参数是否在`state.availableInk`集合中返回或不返回：
- en: '[PRE138]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Finally, all these functions are added to the record:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有这些函数都被添加到记录中：
- en: '[PRE139]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: And that's how you build a `TurtleFunctions` record!
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何构建`TurtleFunctions`记录的方式！
- en: 'We need one more thing: a constructor to create some initial value of the `TurtleFunctions`,
    since we no longer have direct access to the API. This is now the ONLY public
    function available to the client!'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一件事情：一个构造函数来创建`TurtleFunctions`的一些初始值，因为我们不再直接访问API了。这现在是客户端唯一可用的公共函数！
- en: '[PRE140]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This function bakes in the `log` function, creates a new state, and then calls
    `createTurtleFunctions` to return a `TurtleFunction` record for the client to
    use.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将`log`函数固定，创建一个新状态，然后调用`createTurtleFunctions`返回一个供客户端使用的`TurtleFunction`记录。
- en: Implementing a client of the capability-based turtle
  id: totrans-885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个基于能力的海龟客户端
- en: Let's try using this now. First, let's try to do `move 60` and then `move 60`
    again. The second move should take us to the boundary (at 100), and so at that
    point the `move` function should no longer be available.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着使用它。首先，让我们尝试执行`move 60`，然后再次执行`move 60`。第二次移动应该将我们带到边界（在100处），因此在那一点上`move`函数不应再可用。
- en: 'First, we create the `TurtleFunctions` record with `Turtle.make`. Then we can''t
    just move immediately, we have to test to see if the `move` function is available
    first:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`Turtle.make`创建`TurtleFunctions`记录。然后我们不能立即移动，我们必须先测试`move`函数是否可用：
- en: '[PRE141]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: In the last case, the `moveFn` is available, so we can call it with a distance
    of 60\.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，`moveFn`是可用的，所以我们可以用距离为60的距离调用它。
- en: 'The output of the function is a pair: a `MoveResponse` type and a new `TurtleFunctions`
    record.'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输出是一对：`MoveResponse`类型和一个新的`TurtleFunctions`记录。
- en: 'We''ll ignore the `MoveResponse` and check the `TurtleFunctions` record again
    to see if we can do the next move:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将忽略`MoveResponse`并再次检查`TurtleFunctions`记录，看看我们是否可以进行下一步移动：
- en: '[PRE142]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And finally, one more time:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再说一遍：
- en: '[PRE143]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'If we run this, we get the output:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们会得到输出：
- en: '[PRE144]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Which shows that indeed, the concept is working!
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明概念确实有效！
- en: 'That nested option matching is really ugly, so let''s whip up a quick `maybe`
    workflow to make it look nicer:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 那个嵌套的选项匹配真的很丑，所以让我们快速创建一个`maybe`工作流来使其看起来更好：
- en: '[PRE145]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'And a logging function that we can use inside the workflow:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 以及我们可以在工作流中使用的记录函数：
- en: '[PRE146]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Now we can try setting some colors using the `maybe` workflow:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试使用`maybe`工作流设置一些颜色：
- en: '[PRE147]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The output of this is:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 这的输出是：
- en: '[PRE148]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Actually, using a `maybe` workflow is not a very good idea, because the first
    failure exits the workflow! You'd want to come up with something a bit better
    for real code, but I hope that you get the idea.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用`maybe`工作流并不是一个很好的主意，因为第一个失败会退出工作流！你会希望为真实代码想出更好的解决方案，但我希望你能理解这个想法。
- en: Advantages and disadvantages of a capability-based approach
  id: totrans-907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于能力的方法的优缺点
- en: '*Advantages*'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Prevents clients from abusing the API.
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止客户滥用API。
- en: Allows APIs to evolve (and devolve) without affecting clients. For example,
    I could transition to a monochrome-only turtle by hard-coding `None` for each
    color function in the record of functions, after which I could safely remove the
    `setColor` implementation. During this process no client would break! This is
    similar to the [HATEAOS approach](https://en.wikipedia.org/wiki/HATEOAS) for RESTful
    web services.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许API发展（和退化）而不影响客户。例如，我可以通过在函数记录中为每个颜色函数硬编码`None`来过渡到仅单色乌龟，之后我可以安全地删除`setColor`实现。在此过程中，没有客户端会中断！这类似于RESTful
    Web服务的[HATEAOS方法](https://en.wikipedia.org/wiki/HATEOAS)。
- en: Clients are decoupled from a particular implementation because the record of
    functions acts as an interface.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端与特定实现解耦，因为函数记录充当接口。
- en: '*Disadvantages*'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Complex to implement.
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现复杂。
- en: The client's logic is much more convoluted as it can never be sure that a function
    will be available! It has to check every time.
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端的逻辑更加复杂，因为它永远无法确定函数是否可用！它必须每次都进行检查。
- en: The API is not easily serializable, unlike some of the data-oriented APIs.
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与一些面向数据的API不同，该API不容易序列化。
- en: For more on capability-based security, see [my posts](capability-based-security.html)
    or watch my ["Enterprise Tic-Tac-Toe" video](http://fsharpforfunandprofit.com/ettt/).
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于基于能力的安全性，请参阅[我的文章](capability-based-security.html)或观看我的["企业井字游戏"视频](http://fsharpforfunandprofit.com/ettt/)。
- en: '*The source code for this version is available [here](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/15-CapabilityBasedTurtle.fsx).*'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '*此版本的源代码可在[此处](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle/blob/master/15-CapabilityBasedTurtle.fsx)找到。*'
- en: Summary
  id: totrans-918
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: I was of three minds,
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我有三种想法，
- en: Like a finger tree
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 像一棵指树
- en: In which there are three immutable turtles.
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其中有三只不可变的乌龟。
- en: -- *"Thirteen ways of looking at a turtle", by Wallace D Coriacea*
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- *《观看乌龟的十三种方式》，华莱士·D·科里亚斯卡*
- en: I feel better now that I've got these two extra ways out of my system! Thanks
    for reading!
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我感觉好多了，因为我已经摆脱了这两种额外的方式！谢谢阅读！
- en: '*The source code for this post is available [on github](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle).*'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文的源代码可在[github上](https://github.com/swlaschin/13-ways-of-looking-at-a-turtle)找到。*'
- en: .
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 。
