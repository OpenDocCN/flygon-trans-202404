- en: Expressions and Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you will learn more about Functional Programming. You will
    also learn about expressions and evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we jump into the Racket language itself, we will go over the deceptively
    simple big idea for this lesson. In short, it states that, when evaluating an
    expression, we can take the value returned by one function and use it as an argument
    to another function. By "hooking up" two functions in this way, we invent a new,
    third function. For example, let''s say we have a function that adds the letter
    s to the end of a word (in pseudo-code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and another function that puts two words together into a sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine these to create a new function that represents the third person
    singular form of a verb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That general formula looks like this when applied to a particular verb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The way we say it in Racket is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if this is confusing or unintuitive to you; you'll get plenty of
    practice on this concept. Nevertheless, it will turn out that we can express a
    wide variety of computational algorithms by linking functions together in this
    way. This linking is what we mean by **functional programming**.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The Big Idea:** You can ask Racket "questions", called **expressions**. The
    Racket interpreter will then "think" about your question, or **evaluate** your
    expression. You then get back answers, called **values**. Everything we type into
    Racket (that does not error) is an expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want Racket to *do* something (e.g. add two numbers together), you
    write an expression in **prefix notation**. Although all non-error inputs are
    expressions, the most interesting kind is a **call to a procedure**. Take a look
    at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`+`** is the procedure, or the *operator* of the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`3`** is an argument to `+`, or an *operand* of the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`4`** is also an argument/operand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This syntax allows us to **nest** expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`*`, `max`, and `/` are all procedures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` is the operator of the large expression, while `(max 2 3)` and `(/ 8 4)`
    are the operands of the large expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` is the operator of the first subexpression, while `2` and `3` are the
    operands of the first subexpression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/` is the operator of the second subexpression, while `8` and `4` are the
    operands of the second subexpression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following are valid Racket expressions? Select all that apply.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open up the Racket interpreter on your computer and try out some expressions
    of your own.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Racket evaluates expressions using Applicative Order (taught in Lesson 1),
    which follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the operator and operands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the operator to the operands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How Racket actually understands and evaluates an expression is rather complex,
    and is gone over in Lesson 11\. For now, let's move on to the next subsection!
  prefs: []
  type: TYPE_NORMAL
