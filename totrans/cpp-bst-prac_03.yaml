- en: Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consistency is the most important aspect of style. The second most important
    aspect is following a style that the average C++ programmer is used to reading.
  prefs: []
  type: TYPE_NORMAL
- en: C++ allows for arbitrary-length identifier names, so there's no reason to be
    terse when naming things. Use descriptive names, and be consistent in the style.
  prefs: []
  type: TYPE_NORMAL
- en: '`CamelCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snake_case`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: are common examples. *snake_case* has the advantage that it can also work with
    spell checkers, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing A Style Guideline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whatever style guidelines you establish, be sure to implement a `.clang-format`
    file that specifies the style you expect. While this cannot help with naming,
    it is particularly important for an open source project to maintain a consistent
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Every IDE and many editors have support for clang-format built in or easily
    installable with an add-in.
  prefs: []
  type: TYPE_NORMAL
- en: VSCode [https://marketplace.visualstudio.com/items?itemName=xaver.clang-format](https://marketplace.visualstudio.com/items?itemName=xaver.clang-format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VisualStudio [https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.ClangFormat#review-details](https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.ClangFormat#review-details)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resharper++: [https://www.jetbrains.com/help/resharper/2017.2/Using_Clang_Format.html](https://www.jetbrains.com/help/resharper/2017.2/Using_Clang_Format.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/rhysd/vim-clang-format](https://github.com/rhysd/vim-clang-format)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/chiel92/vim-autoformat](https://github.com/chiel92/vim-autoformat)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XCode: [https://github.com/travisjeffery/ClangFormat-Xcode](https://github.com/travisjeffery/ClangFormat-Xcode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common C++ Naming Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Types start with upper case: `MyClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functions and variables start with lower case: `myMethod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constants are all upper case: `const double PI=3.14159265358979323;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C++ Standard Library (and other well-known C++ libraries like [Boost](http://www.boost.org/))
    use these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Macro names use upper case with underscores: `INT_MAX`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template parameter names use camel case: `InputIterator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other names use snake case: `unordered_map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distinguish Private Object Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Name private data with a `m_` prefix to distinguish it from public data. `m_`
    stands for "member" data.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguish Function Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important thing is consistency within your codebase; this is one possibility
    to help with consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Name function parameters with an `t_` prefix. `t_` can be thought of as "the",
    but the meaning is arbitrary. The point is to distinguish function parameters
    from other variables in scope while giving us a consistent naming strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Any prefix or postfix can be chosen for your organization. This is just one
    example. *This suggestion is controversial, for a discussion about it see issue
    [#11](https://github.com/lefticus/cppbestpractices/issues/11).*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Don't Name Anything Starting With `_`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you do, you risk colliding with names reserved for compiler and standard
    library implementation use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier](http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier)'
  prefs: []
  type: TYPE_NORMAL
- en: Well-Formed Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Enable Out-of-Source-Directory Builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure generated files go into an output folder that is separate from the
    source folder.
  prefs: []
  type: TYPE_NORMAL
- en: Use `nullptr`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 introduces `nullptr` which is a special value denoting a null pointer.
    This should be used instead of `0` or `NULL` to indicate a null pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comment blocks should use `//`, not `/* */`. Using `//` makes it much easier
    to comment out a block of code while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To comment out this function block during debugging we might do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: which would be impossible if the function comment header used `/* */`.
  prefs: []
  type: TYPE_NORMAL
- en: Never Use `using namespace` in a Header File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This causes the namespace you are `using` to be pulled into the namespace of
    all files that include the header file. It pollutes the namespace and it may lead
    to name collisions in the future. Writing `using namespace` in an implementation
    file is fine though.
  prefs: []
  type: TYPE_NORMAL
- en: Include Guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Header files must contain a distinctly-named include guard to avoid problems
    with including the same header multiple times and to prevent conflicts with headers
    from other projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You may also consider using the `#pragma once` directive instead which is quasi-standard
    across many compilers. It's short and makes the intent clear.
  prefs: []
  type: TYPE_NORMAL
- en: '{} Are Required for Blocks.'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leaving them off can lead to semantic errors in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Keep Lines a Reasonable Length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Many projects and coding standards have a soft guideline that one should try
    to use less than about 80 or 100 characters per line. Such code is generally easier
    to read. It also makes it possible to have two separate files next to each other
    on one screen without having a tiny font.
  prefs: []
  type: TYPE_NORMAL
- en: Use "" for Including Local Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '... `<>` is [reserved for system includes](http://blog2.emptycrate.com/content/when-use-include-verses-include).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Initialize Member Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '...with the member initializer list.'
  prefs: []
  type: TYPE_NORMAL
- en: For POD types, the performance of an initializer list is the same as manual
    initialization, but for other types there is a clear performance gain, see below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In C++11 you can assign default values to each member (using `=` or using `{}`).
  prefs: []
  type: TYPE_NORMAL
- en: Assigning default values with =
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that no constructor ever "forgets" to initialize a member object.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning default values with brace initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using brace initialization does not allow narrowing at compile-time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Prefer `{}` initialization over `=` unless you have a strong reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting to initialize a member is a source of undefined behavior bugs which
    are often extremely hard to find.
  prefs: []
  type: TYPE_NORMAL
- en: If the member variable is not expected to change after the initialization, then
    mark it `const`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since a const member variable cannot be assigned a new value, such a class may
    not have a meaningful copy assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: Always Use Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is almost never a reason to declare an identifier in the global namespace.
    Instead, functions and classes should exist in an appropriately named namespace
    or in a class inside of a namespace. Identifiers which are placed in the global
    namespace risk conflicting with identifiers from other libraries (mostly C, which
    doesn't have namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: Use the Correct Integer Type for Standard Library Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard library generally uses `std::size_t` for anything related to size.
    The size of `size_t` is implementation defined.
  prefs: []
  type: TYPE_NORMAL
- en: In general, using `auto` will avoid most of these issues, but not all.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you stick with the correct integer types and remain consistent with
    the C++ standard library. It might not warn on the platform you are currently
    using, but it probably will when you change platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that you can cause integer underflow when performing some operations
    on unsigned values. For example:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use .hpp and .cpp for Your File Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ultimately this is a matter of preference, but .hpp and .cpp are widely recognized
    by various editors and tools. So the choice is pragmatic. Specifically, Visual
    Studio only automatically recognizes .cpp and .cxx for C++ files, and Vim doesn't
    necessarily recognize .cc as a C++ file.
  prefs: []
  type: TYPE_NORMAL
- en: One particularly large project ([OpenStudio](https://github.com/NREL/OpenStudio))
    uses .hpp and .cpp for user-generated files and .hxx and .cxx for tool-generated
    files. Both are well recognized and having the distinction is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Never Mix Tabs and Spaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some editors like to indent with a mixture of tabs and spaces by default. This
    makes the code unreadable to anyone not using the exact same tab indentation settings.
    Configure your editor so this does not happen.
  prefs: []
  type: TYPE_NORMAL
- en: Never Put Code with Side Effects Inside an assert()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The above code succeeds when making a debug build, but gets removed by the compiler
    when making a release build, giving you different behavior between debug and release
    builds. This is because `assert()` is a macro which expands to nothing in release
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Don't Be Afraid of Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: They can help you stick to [DRY principles](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself).
    They should be preferred to macros, because macros do not honor namespaces, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Use Operator Overloads Judiciously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operator overloading was invented to enable expressive syntax. Expressive in
    the sense that adding two big integers looks like `a + b` and not `a.add(b)`.
    Another common example is `std::string`, where it is very common to concatenate
    two strings with `string1 + string2`.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can easily create unreadable expressions using too much or wrong
    operator overloading. When overloading operators, there are three basic rules
    to follow as described [on stackoverflow](http://stackoverflow.com/questions/4421706/operator-overloading/4421708#4421708).
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, you should keep these things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Overloading `operator=()` when handling resources is a must. See [Consider the
    Rule of Zero](03-Style.html#consider-the-rule-of-zero) below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all other operators, only overload them when they are used in a context
    that is commonly connected to these operators. Typical scenarios are concatenating
    things with +, negating expressions that can be considered "true" or "false",
    etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always be aware of the [operator precedence](http://en.cppreference.com/w/cpp/language/operator_precedence)
    and try to circumvent unintuitive constructs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not overload exotic operators such as ~ or % unless implementing a numeric
    type or following a well recognized syntax in specific domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Never](http://stackoverflow.com/questions/5602112/when-to-overload-the-comma-operator?answertab=votes#tab-top)
    overload `operator,()` (the comma operator).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use non-member functions `operator>>()` and `operator<<()` when dealing with
    streams. For example, you can overload `operator<<(std::ostream &, MyClass const
    &)` to enable "writing" your class into a stream, such as `std::cout` or an `std::fstream`
    or `std::stringstream`. The latter is often used to create a string representation
    of a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more common operators to overload [described here](http://stackoverflow.com/questions/4421706/operator-overloading?answertab=votes#tab-top).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More tips regarding the implementation details of your custom operators can
    be found [here](http://courses.cms.caltech.edu/cs11/material/cpp/donnie/cpp-ops.html).
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Implicit Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Single Parameter Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single parameter constructors can be applied at compile time to automatically
    convert between types. This is handy for things like `std::string(const char *)`
    but should be avoided in general because they can add to accidental runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Instead mark single parameter constructors as `explicit`, which requires them
    to be explicitly called.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly to single parameter constructors, conversion operators can be called
    by the compiler and introduce unexpected overhead. They should also be marked
    as `explicit`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Consider the Rule of Zero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Rule of Zero states that you do not provide any of the functions that the
    compiler can provide (copy constructor, copy assignment operator, move constructor,
    move assignment operator, destructor) unless the class you are constructing does
    some novel form of ownership.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to let the compiler provide optimal versions that are automatically
    maintained when more member variables are added.
  prefs: []
  type: TYPE_NORMAL
- en: The [original article](https://rmf.io/cxx11/rule-of-zero) provides the background,
    while a [follow up article](http://www.nirfriedman.com/2015/06/27/cpp-rule-of-zero/)
    explains techniques for implementing nearly 100% of the time.
  prefs: []
  type: TYPE_NORMAL
