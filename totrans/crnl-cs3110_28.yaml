- en: 'Lecture 19: Logic'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](#intro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Propositions](#propositions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Inference Rules](#rules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A sample proof](#proof)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Can we prove that any given program works for all possible inputs? No, that
    question is undecidable. But can we develop a program for a given computable task
    so that we can prove that it works for all possible inputs? In principle, yes.
    In practice, this approach is too time-consuming to be applied to large programs.
    However, it is useful to look at how proofs of correctness can be constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: For short code that absolutely has to work, proofs of correctness are very useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic theorem provers continue to improve, and proving correctness is becoming
    increasingly cost-effective.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what it means to prove a program correct helps make you a better
    programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is a proof? A completely convincing argument that something is true. For
    an argument to be completely convincing, it should be made up of small steps,
    each of which is obviously true. In fact, each step should be so simple and obvious
    that we could build a computer program to check the proof. Two ingredients are
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: A language for clearly expressing what we want to prove.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rules for building up an argument in steps that are obviously correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **logic** accomplishes these two goals.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy for proving programs correct will be to convert programs and their
    specifications into a purely logical statement that is either true or false. If
    the statement is true, then the program is correct. But for our proofs to be truly
    convincing, we need a clear understanding of what a proof is.
  prefs: []
  type: TYPE_NORMAL
- en: Curiously, mathematicians did not really study the proofs that they were constructing
    until the 20th century. Once they did, they discovered that logic itself was a
    deep topic with many implications for the rest of mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Propositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with **propositional logic**, which is a logic built up from simple
    symbols representing propositions about some world. For our example, we will use
    the letters A, B, C, ... as propositional symbols. For example, these symbols
    might stand for various propositions:'
  prefs: []
  type: TYPE_NORMAL
- en: A = "got 90% on the final"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B = "attended class every time"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C = "got an A in the class"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D = "x + 1 ≤ y"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E = "e ∈ s"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not the job of *propositional* logic to assign meanings to these symbols.
    However, we use statements to the meanings of D and E to talk about the correctness
    of programs.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of Propositions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We define a grammar for **propositions** built up from these symbols. We use
    the letters P, Q, R to represent propositions (or **formulas**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: On some browsers, on some operating systems, in some fonts, the symbol
    for conjunction (and) is rendered incorrectly as a small circle. It should look
    like an upside-down ∨. In this document, it will appear variously as `∧`, ∧, or
    ∧.'
  prefs: []
  type: TYPE_NORMAL
- en: The precedence of these forms decreases as we go down the list, so P ∧ Q ⇒ R
    is the same as (P ∧ Q) ⇒ R. One thing to watch out for is that ⇒ is right-associative
    (like →), so P ⇒ Q ⇒ R is the same as P ⇒ (Q ⇒ R). We will introduce parentheses
    as needed for clarity. We will use the notation for logical negation, but it is
    really just syntactic sugar for the implication P ⇒ ⊥. We also write P ⇔ Q as
    syntactic sugar for (P ⇒ Q) ∧ (Q ⇒ P), meaning that P and Q are logically equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'This grammar defines the language of propositions. With suitable propositional
    symbols, we can express various interesting statements, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: A ∧ B ⇒ C
  prefs: []
  type: TYPE_NORMAL
- en: '"If I got a 90% on the final and I attended class, I will get an A"'
  prefs: []
  type: TYPE_NORMAL
- en: ¬C ⇒ (¬A ∨ ¬B)
  prefs: []
  type: TYPE_NORMAL
- en: '"If I didn''t get an A in the class, then either I didn''t get a 90% on the
    final or I didn''t attend class"'
  prefs: []
  type: TYPE_NORMAL
- en: C ∨ ¬A ∨ ¬B
  prefs: []
  type: TYPE_NORMAL
- en: '"Either I got an A in the class, or I didn''t get a 90% on the final or I didn''t
    attend class"'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, all three of these propositions are logically equivalent, which we
    can determine without knowing about what finals and attendance mean.
  prefs: []
  type: TYPE_NORMAL
- en: Proofs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing whether a proposition is a tautology by testing every possible truth
    assignment is expensive—there are exponentially many. We need a **deductive system**,
    which will allow us to construct proofs of tautologies in a step-by-step fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The system we will use is known as **natural deduction**. The system consists
    of a set of **rules of inference** for deriving consequences from premises. One
    builds a proof tree whose root is the proposition to be proved and whose leaves
    are the initial assumptions or axioms (for proof trees, we usually draw the root
    at the bottom and the leaves at the top).
  prefs: []
  type: TYPE_NORMAL
- en: For example, one rule of our system is known as **modus ponens**. Intuitively,
    this says that if we know P is true, and we know that P implies Q, then we can
    conclude Q.
  prefs: []
  type: TYPE_NORMAL
- en: The propositions above the line are called **premises**; the proposition below
    the line is the **conclusion**. Both the premises and the conclusion may contain
    metavariables (in this case, P and Q) representing arbitrary propositions. When
    an inference rule is used as part of a proof, the metavariables are replaced in
    a consistent way with the appropriate kind of object (in this case, propositions).
  prefs: []
  type: TYPE_NORMAL
- en: During the course of informal proofs, we typically make temporary assumptions.
    In formal proofs, the ⊢ symbol (read "turnstyle") is used to separate these temporary
    assumptions from the statements that we are proving. The assumptions are placed
    to the left of the turnstyle, and the conclusion is placed to the right. The **sequent**
    P ⊢ Q should be read "Q holds under the assumptions P".
  prefs: []
  type: TYPE_NORMAL
- en: Inference rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most rules come in one of two flavors: **introduction** or **elimination**
    rules. Introduction rules tell us how to prove a conclusion containing a logical
    operator ("introducing" it into the conclusion) while elimination rules tell us
    how we can use a logical statement once proved ("eliminating" it from the premises).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, modus ponens is the elimination rule for ⇒: it tells us what we
    can conclude once we''ve proven P ⇒ Q. Here are the introduction and elimination
    rules for the logical connectives described above:'
  prefs: []
  type: TYPE_NORMAL
- en: '| rule name | rule | intuition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ∧ | intro |  | To prove (under no assumptions) that P∧Q holds, we must prove
    that P holds (⊢P), and we must prove that Q holds (⊢Q). |'
  prefs: []
  type: TYPE_TB
- en: '| elim |  | If we know P∧Q, we can use it to conclude P. We can also use it
    to conclude Q. |'
  prefs: []
  type: TYPE_TB
- en: '| ∨ | intro |  | We can prove P∨Q by proving P, or we can prove it by proving
    Q. |'
  prefs: []
  type: TYPE_TB
- en: '| elim |  | If we know either P∨Q holds, and we can prove R holds in the case
    that P holds, and we can also prove that R holds when Q holds, then we know R
    holds in either case, so R holds. |'
  prefs: []
  type: TYPE_TB
- en: '| ⇒ | intro |'
  prefs: []
  type: TYPE_TB
- en: '&#124; P⊢Q &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ⊢P⇒Q &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| To prove P⇒Q, we first assume P, and under that assumption we must prove
    Q |'
  prefs: []
  type: TYPE_TB
- en: '| elim |'
  prefs: []
  type: TYPE_TB
- en: '&#124; ⊢P &#124; ⊢ P⇒Q &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ⊢Q &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| If we know P⇒Q, and we know P, then we can conclude Q. |'
  prefs: []
  type: TYPE_TB
- en: '| ¬ | intro |'
  prefs: []
  type: TYPE_TB
- en: '&#124; ⊢P⇒⊥ &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ⊢¬P &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| ¬P is just shorthand for P⇒⊥, so we have rules for changing between these
    representations. |'
  prefs: []
  type: TYPE_TB
- en: '| elim |'
  prefs: []
  type: TYPE_TB
- en: '&#124; ⊢¬P &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ⊢P⇒⊥ &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| T | intro |'
  prefs: []
  type: TYPE_TB
- en: '&#124;  &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ⊢T &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| It''s easy to prove "true"! (But it doesn''t get you much — there is no elimination
    rule) |'
  prefs: []
  type: TYPE_TB
- en: '| ⊥ | elim |'
  prefs: []
  type: TYPE_TB
- en: '&#124; ⊢⊥ &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ⊢P &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| If you manage to prove "false", you can conclude anything you want. (But
    good luck proving it — there is no introduction rule). |'
  prefs: []
  type: TYPE_TB
- en: '| assum |'
  prefs: []
  type: TYPE_TB
- en: '&#124;  &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; P⊢P &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| You may use your assumptions. |'
  prefs: []
  type: TYPE_TB
- en: '| excluded middle |'
  prefs: []
  type: TYPE_TB
- en: '&#124;  &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ⊢P∨¬P &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| Every proposition is either true or false |'
  prefs: []
  type: TYPE_TB
- en: An example proof
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now walk through a formal proof that (A∧B⇒C)⇒(¬C⇒¬A∨¬B). It is often
    easiest to construct these proofs in a "goal directed" fashion — we start with
    the conclusion and build the proof tree above it. Our goal is ⊢(A∧B⇒C)⇒(¬C⇒¬A∨¬B).
    To prove this informally, we would assume the left hand-side of the implication
    and try to prove the RHS. Formally, we apply the ⇒ introduction rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (A∧B⇒C) ⊢ ¬C⇒¬A∨¬B &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ⊢ (A∧B⇒C)⇒(¬C⇒¬A∨¬B) &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| (⇒ intro) |'
  prefs: []
  type: TYPE_TB
- en: 'Now we must construct a proof of ¬C⇒¬A∨¬B. Again, we apply the ⇒ introduction
    rule since we are trying to prove an implication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must show that either ¬A or ¬B holds, but the proof we want to use depends
    on whether A is true or not. So we will use excluded middle to introduce A∨¬A,
    and we will use the ∨ elimination rule to prove our current goal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second of the two remaining subgoals is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus all that remains to prove is (A∧B⇒C), ¬C ⊢ A ⇒ ¬A∨¬B. We will again break
    the proof into cases using the law of the excluded middle, this time with B:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Progress has been made! All that''s left is to prove A∧B⇒C, ¬C, A, B ⊢ ¬A ∨
    ¬B (from the middle branch). At this point we have a contradiction in our assumptions,
    so we will use it:'
  prefs: []
  type: TYPE_NORMAL
- en: We have now discharged all of our subgoals, which means we've completed the
    proof. To assemble the final proof, we merely need to snap together the pieces
    that we have constructed above.
  prefs: []
  type: TYPE_NORMAL
- en: Formal proofs like this have both advantages and disadvantages compared to the
    informal proofs we have seen earlier in the course. The advantage is that every
    step is completely explicit, and can be checked completely mechanically. The disadvantage
    is that we have to write every step, and the high-level argument for why the theorem
    is true becomes obscured.
  prefs: []
  type: TYPE_NORMAL
