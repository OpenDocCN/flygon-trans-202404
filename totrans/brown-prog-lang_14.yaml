- en: 14Predicting Growth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14预测增长
- en: '|     [14.1 A Little (True) Story](#%28part._.A_.Little__.True__.Story%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [14.1 一个小（真实）故事](#%28part._.A_.Little__.True__.Story%29) |'
- en: '|     [14.2 The Analytical Idea](#%28part._.The_.Analytical_.Idea%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [14.2 分析的想法](#%28part._.The_.Analytical_.Idea%29) |'
- en: '|     [14.3 A Cost Model for Pyret Running Time](#%28part._cost-model%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [14.3 Pyret运行时间的成本模型](#%28part._cost-model%29) |'
- en: '|     [14.4 The Size of the Input](#%28part._size-of-input%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|     [14.4 输入的大小](#%28part._size-of-input%29) |'
- en: '|     [14.5 The Tabular Method for Singly-Structurally-Recursive Functions](#%28part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|     [14.5 单结构递归函数的表格方法](#%28part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions%29)
    |'
- en: '|     [14.6 Creating Recurrences](#%28part._creating-recurrences%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|     [14.6 创建递归](#%28part._creating-recurrences%29) |'
- en: '|     [14.7 A Notation for Functions](#%28part._math-anon-functions%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|     [14.7 函数的符号表示](#%28part._math-anon-functions%29) |'
- en: '|     [14.8 Comparing Functions](#%28part._big-oh-def%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|     [14.8 比较函数](#%28part._big-oh-def%29) |'
- en: '|     [14.9 Combining Big-Oh Without Woe](#%28part._big-oh-closure%29) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|     [14.9 无忧地结合大O](#%28part._big-oh-closure%29) |'
- en: '|     [14.10 Solving Recurrences](#%28part._solving-recurrences%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|     [14.10 解决递归](#%28part._solving-recurrences%29) |'
- en: We will now commence the study of determining how long a computation takes.
    We’ll begin with a little (true) story.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始研究确定计算需要多长时间的学习。我们将从一个小（真实）故事开始。
- en: 14.1A Little (True) Story
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1一个小（真实）故事
- en: My student Debbie recently wrote tools to analyze data for a startup. The company
    collects information about product scans made on mobile phones, and Debbie’s analytic
    tools classified these by product, by region, by time, and so on. As a good programmer,
    Debbie first wrote synthetic test cases, then developed her programs and tested
    them. She then obtained some actual test data from the company, broke them down
    into small chunks, computed the expected answers by hand, and tested her programs
    again against these real (but small) data sets. At the end of this she was ready
    to declare the programs ready.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我的学生黛比最近为一家初创公司编写了用于分析数据的工具。该公司收集有关手机上进行的产品扫描的信息，黛比的分析工具按产品、地区、时间等对其进行了分类。作为一个优秀的程序员，黛比首先编写了合成测试用例，然后开发了她的程序并对其进行了测试。然后，她从公司获得了一些实际的测试数据，将它们分解成小块，手工计算了预期的答案，然后再次对其进行了测试（但是数据集较小）。在这一过程结束时，她准备好宣布程序已准备就绪。
- en: 'At this point, however, she had only tested them for functional correctness.
    There was still a question of how quickly her analytical tools would produce answers.
    This presented two problems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此时她只是测试了它们的功能正确性。还有一个问题是她的分析工具能够多快地生成答案。这带来了两个问题：
- en: The company was rightly reluctant to share the entire dataset with outsiders,
    and in turn we didn’t want to be responsible for carefully guarding all their
    data.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司理所当然地不愿意与外界分享整个数据集，而我们也不想负责仔细保护所有的数据。
- en: Even if we did get a sample of their data, as more users used their product,
    the amount of data they had was sure to grow.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们获得了他们数据的样本，随着更多用户使用他们的产品，他们拥有的数据量肯定会增长。
- en: We therefore got only a sampling of their full data, and from this had to make
    some prediction on how long it would take to run the analytics on subsets (e.g.,
    those corresponding to just one region) or all of their data set, both today and
    as it grew over time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只得到了他们完整数据的一个样本，并且需要根据这个样本对在今天和随着时间推移而增长时运行分析所需的时间进行一些预测，无论是对数据子集（例如，仅对应于一个地区的子集）还是对整个数据集。
- en: Debbie was given 100,000 data points. She broke them down into input sets of
    10, 100, 1,000, 10,000, and 100,000 data points, ran her tools on each input size,
    and plotted the result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 黛比获得了100,000个数据点。她将它们分解成包含10、100、1,000、10,000和100,000个数据点的输入集，并在每个输入大小上运行她的工具，并绘制结果。
- en: From this graph we have a good bet at guessing how long the tool would take
    on a dataset of 50,000\. It’s much harder, however, to be sure how long it would
    take on datasets of size 1.5 million or 3 million or 10 million.These processes
    are respectively called interpolation and extrapolation. We’ve already explained
    why we couldn’t get more data from the company. So what could we do?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个图表，我们可以很好地猜测工具在一个包含50,000个数据点的数据集上需要多长时间。然而，要确定工具在包含1.5百万、3百万或1千万数据点的数据集上需要多长时间就要困难得多了。这些过程分别称为插值和外推。我们已经解释了为什么我们不能从公司获取更多数据。那么我们能做些什么呢？
- en: 'As another problem, suppose we have multiple implementations available. When
    we plot their running time, say the graphs look like this, with red, green, and
    blue each representing different implementations. On small inputs, suppose the
    running times look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，假设我们有多个可用的实现。当我们绘制它们的运行时间时，假设图表看起来像这样，红色、绿色和蓝色分别代表不同的实现。在小输入上，假设运行时间看起来像这样：
- en: '![image](../Images/161579f02374f222dd7841886f410721.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/161579f02374f222dd7841886f410721.jpg)'
- en: 'This doesn’t seem to help us distinguish between the implementations. Now suppose
    we run the algorithms on larger inputs, and we get the following graphs:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎并没有帮助我们区分实现之间的差异。现在假设我们在更大的输入上运行算法，我们得到以下图表：
- en: '![image](../Images/7910dc4f35f470ccfbe24b4466fc7a4b.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/7910dc4f35f470ccfbe24b4466fc7a4b.jpg)'
- en: 'Now we seem to have a clear winner (red), though it’s not clear there is much
    to give between the other two (blue and green). But if we calculate on even larger
    inputs, we start to see dramatic differences:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们似乎有一个明显的赢家（红色），虽然其他两个（蓝色和绿色）之间没有太大差别。但如果我们计算更大的输入，我们开始看到明显的差异：
- en: '![image](../Images/f3bd44d1531671deb5a2e576761aafec.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f3bd44d1531671deb5a2e576761aafec.jpg)'
- en: In fact, the functions that resulted in these lines were the same in all three
    figures. What these pictures tell us is that it is dangerous to extrapolate too
    much from the performance on small inputs. If we could obtain closed-form descriptions
    of the performance of computations, it would be nice if we could compare them
    better. That is what we will now do.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，导致这些线条的函数在所有三个图中都是相同的。这些图片告诉我们的是，在小输入上推断性过多是危险的。如果我们能够获得计算性能的封闭形式描述，那么如果我们能够更好地比较它们，这将是很好的。这就是我们现在要做的。
- en: 14.2The Analytical Idea
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析思想
- en: 'With many physical processes, the best we can do is obtain as many data points
    as possible, extrapolate, and apply statistics to reason about the most likely
    outcome. Sometimes we can do that in computer science, too, but fortunately we
    computer scientists have an enormous advantage over most other sciences: instead
    of measuring a black-box process, we have full access to its internals, namely
    the source code. This enables us to apply analytical methods.“Analytical” means
    applying algebraic and other mathematical methods to make predictive statements
    about a process without running it. The answer we compute this way is complementary
    to what we obtain from the above experimental analysis, and in practice we will
    usually want to use a combination of the two to arrive a strong understanding
    of the program’s behavior.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多物理过程，我们所能做的最好的事情就是获得尽可能多的数据点，进行外推，并应用统计学来推断最有可能的结果。有时我们在计算机科学中也可以这样做，但幸运的是，我们计算机科学家比大多数其他科学领域有一个巨大的优势：我们不是测量黑盒过程，而是完全可以访问其内部，即源代码。这使我们能够应用分析方法。“分析”意味着应用代数和其他数学方法来对一个过程进行预测性陈述，而不运行它。我们用这种方式计算的答案是对上述实验性分析所得到的结果的补充，实际上，我们通常会希望使用两者的组合来获得对程序行为的深刻理解。
- en: 'The analytical idea is startlingly simple. We look at the source of the program
    and list the operations it performs. For each operation, we look up what it costs.We
    are going to focus on one kind of cost, namely running time. There are many other
    other kinds of costs one can compute. We might naturally be interested in space
    (memory) consumed, which tells us how big a machine we need to buy. We might also
    care about power, this tells us the cost of our energy bills, or of bandwidth,
    which tells us what kind of Internet connection we will need. In general, then,
    we’re interested in resource consumption. In short, don’t make the mistake of
    equating “performance” with “speed”: the costs that matter depend on the context
    in which the application runs. We add up these costs for all the operations. This
    gives us a total cost for the program.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分析的思想非常简单。我们查看程序的源代码并列出它执行的操作。对于每个操作，我们查找它的成本。我们将专注于一种成本，即运行时间。还有许多其他类型的成本可以计算。我们可能自然地对消耗的空间（内存）感兴趣，这告诉我们需要购买多大的机器。我们可能还关心功耗，这告诉我们我们的能源账单的成本，或者带宽，这告诉我们我们需要什么样的互联网连接。总之，我们对资源消耗感兴趣。简而言之，不要犯将“性能”等同于“速度”的错误：重要的成本取决于应用程序运行的上下文。我们将所有操作的成本相加。这给了我们程序的总成本。
- en: Naturally, for most programs the answer will not be a constant number. Rather,
    it will depend on factors such as the size of the input. Therefore, our answer
    is likely to be an expression in terms of parameters (such as the input’s size).
    In other words, our answer will be a function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，对于大多数程序，答案不会是一个常数。相反，它将取决于诸如输入大小之类的因素。因此，我们的答案很可能是一个关于参数（如输入大小）的表达式。换句话说，我们的答案将是一个函数。
- en: 'There are many functions that can describe the running-time of a function.
    Often we want an upper bound on the running time: i.e., the actual number of operations
    will always be no more than what the function predicts. This tells us the maximunm
    resource we will need to allocate. Another function may present a lower bound,
    which tells us the least resource we need. Sometimes we want an average-case analysis.
    And so on. In this text we will focus on upper-bounds, but keep in mind that all
    these other analyses are also extremely valuable.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 描述函数运行时间的函数有很多种。通常我们希望得到运行时间的上界：即，实际操作次数永远不会超过函数预测的次数。这告诉我们我们需要分配的最大资源。另一个函数可能给出一个下界，告诉我们我们需要的最小资源。有时我们需要进行平均情况分析。等等。在这个文本中，我们将专注于上界，但请记住，所有这些其他分析也非常有价值。
- en: Exercise
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is incorrect to speak of “the” upper-bound function, because there isn’t
    just one. Given one upper-bound function, can you construct another one?
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 把“上界函数”说成“上界函数”是不正确的，因为不止一个。给定一个上界函数，你能构造另一个吗？
- en: 14.3A Cost Model for Pyret Running Time
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pyret 运行时间的成本模型
- en: We begin by presenting a cost model for the running time of Pyret programs.
    We are interested in the cost of running a program, which is tantamount to studying
    the expressions of a program. Simply making a definition does not cost anything;
    the cost is incurred only when we use a definition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提出了 Pyret 程序运行时间的成本模型。我们对运行程序的成本感兴趣，这等同于研究程序的表达式。简单地做出一个定义不需要花费任何东西；只有当我们使用一个定义时才会产生成本。
- en: 'We will use a very simple (but sufficiently accurate) cost model: every operation
    costs one unit of time in addition to the time needed to evaluate its sub-expressions.
    Thus it takes one unit of time to look up a variable or to allocate a constant.
    Applying primitive functions also costs one unit of time. Everything else is a
    compound expression with sub-expressions. The cost of a compound expression is
    one plus that of each of its sub-expressions. For instance, the running time cost
    of the expression e1 + e2 (for some sub-expressions e1 and e2) is the running
    time for e1 + the running time for e2 + 1\. Thus the expression 17 + 29 has a
    cost of 3 (one for each sub-expression and one for the addition); the expression
    1 + (7 * (2 / 9)) costs 7.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个非常简单（但足够准确）的成本模型：每个操作除了评估其子表达式所需的时间外，还会花费一个时间单位。因此查找一个变量或分配一个常数需要一个时间单位。应用原始函数也需要一个时间单位。其他一切都是具有子表达式的复合表达式。复合表达式的成本是其每个子表达式的成本加上
    1。例如，表达式 e1 + e2（对于一些子表达式 e1 和 e2）的运行时间成本是 e1 的运行时间加上 e2 的运行时间加上 1。因此，表达式 17 +
    29 的成本为 3（每个子表达式一个，加上加法一个）；表达式 1 +（7 *（2 / 9））的成本为 7。
- en: 'As you can see, there are two big approximations here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里有两个大的近似：
- en: First, we are using an abstract rather than concrete notion of time. This is
    unhelpful in terms of estimating the so-called “wall clock” running time of a
    program, but then again, that number depends on numerous factors—<wbr>not just
    what kind of processor and how much memory you have, but even what other tasks
    are running on your computer at the same time. In contrast, abstract time units
    are more portable.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用的是抽象而不是具体的时间概念。就估计程序的所谓“挂钟”运行时间而言，这并不方便，但话又说回来，这个数字取决于许多因素——不仅是你有什么样的处理器和多少内存，甚至是在同一时间运行在你的计算机上的其他任务。相比之下，抽象时间单位更具可移植性。
- en: Second, not every operation takes the same number of machine cycles, whereas
    we have charged all of them the same number of abstract time units. As long as
    the actual number of cycles each one takes is bounded by a constant factor of
    the number taken by another, this will not pose any mathematical problems for
    reasons we will soon understand ([Comparing Functions](#%28part._big-oh-def%29)).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，并非每个操作都需要相同数量的机器周期，而我们已经为它们都收取了相同数量的抽象时间单位。只要每个操作所花费的实际周期数受另一个操作所花费的周期数的一个常数因子的限制，这就不会对我们产生任何数学问题，原因我们很快就会理解（[比较函数](#%28part._big-oh-def%29)）。
- en: Of course, it is instructive—<wbr>after carefully settting up the experimental
    conditions—<wbr>to make an analytical prediction of a program’s behavior and then
    verify it against what the implementation actually does. If the analytical prediction
    is accurate, we can reconstruct the constant factors hidden in our calculations
    and thus obtain very precise wall-clock time bounds for the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在仔细设置实验条件后，<wbr>对程序的行为进行分析预测然后验证实现与预测是否一致是很有教益的。
- en: 14.4The Size of the Input
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4输入的大小
- en: 'We are going to gloss over how to measure the size of a number. Observe that
    the value of a number is exponentially larger than its size: given three spaces
    we can write 1,000 different natural numbers, but given a fourth space we can
    write not 1,001 but 10,000 different numbers. Thus, when studying functions over
    numbers, the space we charge should be only logarithmic in the value. This distinction
    will not matter for the programs we work with in this text, so we permit ourselves
    the fiction of equating value and size. In programs where numbers are central—<wbr>e.g.,
    when testing primality—<wbr>this distinction is everything! We will return to
    this briefly later ([The Complexity of Numbers](Algorithms_That_Exploit_State.html#%28part._numbers-not-constant%29)).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将忽略如何测量数字的大小。请注意，数字的值比其大小大得多：给定三个空格，我们可以写出 1,000 个不同的自然数，但是给定第四个空格，我们可以写出的不是
    1,001 而是 10,000 个不同的数字。因此，在研究与数字相关的函数时，我们收取的空间应该只是值的对数。这种区别对我们在本文中处理的程序不重要，所以我们允许自己假设值和大小是相等的。在数字是中心的程序中——<wbr>例如，在测试素数时——<wbr>这种区别就至关重要了！稍后我们将简要回到这一点（[数字的复杂性](Algorithms_That_Exploit_State.html#%28part._numbers-not-constant%29)）。
- en: It can be subtle to define the size of the argument. Suppose a function consumes
    a list of numbers; it would be natural to define the size of its argument to be
    the length of the list, i.e., the number of links in the list. We could also define
    it to be twice as large, to account for both the links and the individual numbers
    (but as we’ll see ([Comparing Functions](#%28part._big-oh-def%29)), constants
    usually don’t matter). But suppose a function consumes a list music albums, and
    each music album is itself a list of songs, each of which has information about
    singers and so on. Then how we measure the size depends on what part of the input
    the function being analyzed actually examines. If, say, it only returns the length
    of the list of albums, then it is indifferent to what each list element contains
    [REF para poly], and only the length of the list of albums matters. If, however,
    the function returns a list of all the singers on every album, then it traverses
    all the way down to individual songs, and we have to account for all these data.
    In short, we care about the size of the data potentially accessed by the function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定义参数的大小可能会很微妙。假设一个函数消耗了一个数字列表；将其参数的大小定义为列表的长度，即列表中的链接数，这是很自然的。我们也可以将其定义为两倍大，以考虑到链接和单独的数字（但正如我们将看到的（[比较函数](#%28part._big-oh-def%29)），常数通常并不重要）。但是假设一个函数消耗了一个音乐专辑列表，每个音乐专辑本身都是一个包含有关歌手等信息的歌曲列表。那么我们如何衡量大小取决于被分析的函数实际检查的输入部分。例如，如果它仅返回专辑列表的长度，则它对列表元素的内容是无关紧要的
    [REF para poly]，只有专辑列表的长度才重要。但是，如果函数返回每个专辑上所有歌手的列表，则它会遍历到单个歌曲，并且我们必须考虑所有这些数据。简而言之，我们关心函数可能访问的数据的大小。
- en: 14.5The Tabular Method for Singly-Structurally-Recursive Functions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5单结构递归函数的表格法
- en: Given sizes for the arguments, we simply examine the body of the function and
    add up the costs of the individual operations. Most interesting functions are,
    however, conditionally defined, and may even recur. Here we will assume there
    is only one structural recursive call. We will get to more general cases in a
    bit [[Creating Recurrences](#%28part._creating-recurrences%29)].
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 给定参数的大小，我们只需检查函数体并将各个操作的成本相加即可。然而，大多数有趣的函数都是有条件定义的，甚至可能是递归的。在这里，我们将假设只有一个结构递归调用。我们稍后将讨论更一般的情况（[创建递归关系](#%28part._creating-recurrences%29)）。
- en: When we have a function with only one recursive call, and it’s structural, there’s
    a handy technique we can use to handle conditionals.This idea is due to Prabhakar
    Ragde. We will set up a table. It won’t surprise you to hear that the table will
    have as many rows as the cond has clauses. But instead of two columns, it has
    seven! This sounds daunting, but you’ll soon see where they come from and why
    they’re there.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个仅包含一个递归调用且是结构性的函数时，我们可以使用一个方便的技巧来处理条件。这个想法归功于Prabhakar Ragde。我们将设置一个表格。你可能会惊讶地听到表格将有与cond有几个从句一样多的行。但是，它不是两列，而是七列！这听起来很吓人，但很快你就会看到它们来自哪里以及为什么它们在那里。
- en: 'For each row, fill in the columns as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，填写列如下：
- en: '|Q|: the number of operations in the question'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '|Q|：问题中的操作次数'
- en: '#Q: the number of times the question will execute'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#Q：问题执行的次数'
- en: 'TotQ: the total cost of the question (multiply the previous two)'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TotQ：问题的总成本（将前两个相乘）
- en: '|A|: the number of operations in the answer'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '|A|：答案中的操作次数'
- en: '#A: the number of times the answer will execute'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#A：答案执行的次数'
- en: 'TotA: the total cost of the answer (multiply the previous two)'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TotA：答案的总成本（将前两个相乘）
- en: 'Total: add the two totals to obtain an answer for the clause'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总计：将两个总计相加以获得从句的答案
- en: Finally, the total cost of the cond expression is obtained by summing the Total
    column in the individual rows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，cond表达式的总成本是通过对各行中的总列进行求和获得的。
- en: In the process of computing these costs, we may come across recursive calls
    in an answer expression. So long as there is only one recursive call in the entire
    answer, ignore it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算这些成本的过程中，我们可能会在答案表达式中遇到递归调用。只要整个答案中只有一个递归调用，就忽略它。
- en: Exercise
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once you’ve read the material on [Creating Recurrences](#%28part._creating-recurrences%29),
    come back to this and justify why it is okay to just skip the recursive call.
    Explain in the context of the overall tabular method.
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 阅读完[创建递归](#%28part._creating-recurrences%29)的材料后，回到这里并解释为什么跳过递归调用是可以的。在整体表格方法的背景下解释。
- en: Exercise
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Excluding the treatment of recursion, justify (a) that these columns are individually
    accurate (e.g., the use of additions and multiplications is appropriate), and
    (b) sufficient (i.e., combined, they account for all operations that will be performed
    by that cond clause).
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在不考虑递归处理的情况下，证明（a）这些列是准确的（例如，使用加法和乘法是适当的），以及（b）足够（即，它们组合起来考虑了该cond从句将执行的所有操作）。
- en: 'It’s easiest to understand this by applying it to a few examples. First, let’s
    consider the len function, noting before we proceed that it does meet the criterion
    of having a single recursive call where the argument is structural:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将它应用到几个例子中来理解这一点是最容易的。首先，让我们考虑len函数，注意在我们继续之前，它确实符合具有一个单一递归调用且参数是结构性的标准：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s compute the cost of running len on a list of length \(k\) (where we are
    only counting the number of links in the list, and ignoring the content of each
    first element, since len ignores them too).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算在长度为\(k\)的列表上运行len的成本（在这里我们只计算列表中链接的数量，忽略每个第一个元素的内容，因为len也会忽略它们）。
- en: Because the entire body of len is given by a conditional, we can proceed directly
    to building the table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为len的整个主体由条件给出，所以我们可以直接开始建立表格。
- en: Let’s consider the first row. The question costs three units (one each to evaluate
    empty? and l, and one to apply the function). This is evaluated once per element
    in the list and once more when the list is empty, i.e., \(k+1\) times. The total
    cost of the question is thus \(3(k+1)\). The answer takes one unit of time to
    compute, and is evaluated only once (when the list is empty). Thus it takes a
    total of one unit, for a total of \(3k+4\) units.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑第一行。问题的成本为三个单位（一个用于评估empty?和l，一个用于应用函数）。这在列表中的每个元素和列表为空时都评估一次，即\(k+1\)次。问题的总成本因此为\(3(k+1)\)。答案需要一个单位的时间来计算，并且只计算一次（当列表为空时）。因此，总共需要一个单位，总共为\(3k+4\)个单位。
- en: Now for the second row. The question again costs three units, and is evaluated
    \(k\) times. The answer involves 3 units to evaluate (rest l), two more to evaluate
    and apply add1, one more to evaluate len...and no more, because we are ignoring
    the time spent in the recursive call itself. In short, it takes six units of time
    (in addition to the recursion we’ve chosen to ignore).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是第二行。问题再次需要三个单位，评估 \(k\) 次。答案涉及 3 个单位的评估（剩余 l），再加上两个单位的评估和应用 add1，再加上一个单位的评估
    len……没有更多，因为我们正在忽略递归调用本身所花费的时间。简而言之，除了我们选择忽略的递归，还需要六个单位的时间。
- en: 'In tabular form:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以表格形式：
- en: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    总计 |'
- en: '| \(3\) |  | \(k+1\) |  | \(3(k+1)\) |  | \(1\) |  | \(1\) |  | \(1\) |  |
    \(3k+4\) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| \(3\) |  | \(k+1\) |  | \(3(k+1)\) |  | \(1\) |  | \(1\) |  | \(1\) |  |
    \(3k+4\) |'
- en: '| \(3\) |  | \(k\) |  | \(3k\) |  | \(6\) |  | \(k\) |  | \(6k\) |  | \(9k\)
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| \(3\) |  | \(k\) |  | \(3k\) |  | \(6\) |  | \(k\) |  | \(6k\) |  | \(9k\)
    |'
- en: Adding, we get \(12k + 4\). Thus running len on a \(k\)-element list takes \(12k+4\)
    units of time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后，我们得到 \(12k + 4\)。因此，在一个 \(k\) 元素列表上运行 len 需要 \(12k+4\) 单位的时间。
- en: Exercise
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How accurate is this estimate? If you try applying len to different sizes of
    lists, do you obtain a consistent estimate for \(k\)?
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个估计有多准确？如果尝试将 len 应用于不同大小的列表，能否得到一致的 \(k\) 估计？
- en: 14.6Creating Recurrences
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建递归
- en: We will now see a systematic way of analytically computing the time of a program.
    Suppose we have only one function f. We will define a function, \(T\), to compute
    an upper-bound of the time of f.In general, we will have one such cost function
    for each function in the program. In such cases, it would be useful to give a
    different name to each function to easily tell them apart. Since we are looking
    at only one function for now, we’ll reduce notational overhead by having only
    one \(T\). \(T\) takes as many parameters as f does. The parameters to \(T\) represent
    the sizes of the corresponding arguments to f. Eventually we will want to arrive
    at a closed form solution to \(T\), i.e., one that does not refer to \(T\) itself.
    But the easiest way to get there is to write a solution that is permitted to refer
    to \(T\), called a recurrence relation, and then see how to eliminate the self-reference
    [REF].
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到一种系统的方法来分析计算程序的时间。假设我们只有一个函数 f。我们将定义一个函数 \(T\)，来计算 f 的时间的上界。通常情况下，程序中的每个函数都会有一个这样的成本函数。在这种情况下，给每个函数起一个不同的名字会很有用，以便轻松区分它们。由于我们现在只看一个函数，所以我们将通过只有一个
    \(T\) 来减少符号开销。\(T\) 接受与 f 相同数量的参数。\(T\) 的参数代表与 f 相应参数的大小。最终，我们希望得到 \(T\) 的封闭形式解，即不引用
    \(T\) 本身的解。但是，到达那里的最简单方法是编写一个允许引用 \(T\) 的解，称为递归关系，然后看看如何消除自引用 [REF]。
- en: We repeat this procedure for each function in the program in turn. If there
    are many functions, first solve for the one with no dependencies on other functions,
    then use its solution to solve for a function that depends only on it, and progress
    thus up the dependency chain. That way, when we get to a function that refers
    to other functions, we will already have a closed-form solution for the referred
    function’s running time and can simply plug in parameters to obtain a solution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依次对程序中的每个函数重复此过程。如果有许多函数，首先解决没有依赖其他函数的函数，然后使用其解来解决仅依赖它的函数，并以此方式沿着依赖链前进。这样，当我们到达引用其他函数的函数时，我们将已经有了被引用函数的运行时间的封闭形式解决方案，只需插入参数即可获得解决方案。
- en: Exercise
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The strategy outlined above doesn’t work when there are functions that depend
    on each other. How would you generalize it to handle this case?
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上面概述的策略在有相互依赖的函数时无法奏效。您如何将其概括以处理此情况？
- en: The process of setting up a recurrence is easy. We simply define the right-hand-side
    of \(T\) to add up the operations performed in f’s body. This is straightforward
    except for conditionals and recursion. We’ll elaborate on the treatment of conditionals
    in a moment. If we get to a recursive call to f on the argument a, in the recurrence
    we turn this into a (self-)reference to \(T\) on the size of a.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 建立递归的过程很简单。我们只需定义 \(T\) 的右侧来累加 f 主体中执行的操作。这很简单，除了条件和递归。我们稍后会详细介绍条件的处理。如果我们到达对参数
    a 的 f 的递归调用，在递归中我们将其转换为对 a 大小的 \(T\) （自）引用。
- en: 'For conditionals, we use only the |Q| and |A| columns of the corresponding
    table. Rather than multiplying by the size of the input, we add up the operations
    that happen on one invocation of f other than the recursive call, and then add
    the cost of the recursive call in terms of a reference to \(T\). Thus, if we were
    doing this for len above, we would define \(T(k)\)—<wbr>the time needed on an
    input of length \(k\)—<wbr>in two parts: the value of \(T(0)\) (when the list
    is empty) and the value for non-zero values of \(k\). We know that \(T(0) = 4\)
    (the cost of the first conditional and its corresponding answer). If the list
    is non-empty, the cost is \(T(k) = 3 + 3 + 6 + T(k-1)\) (respectively from the
    first question, the second question, the remaining operations in the second answer,
    and the recursive call on a list one element smaller). This gives the following
    recurrence:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条件语句，我们只使用相应表格的 |Q| 和 |A| 列。我们不是乘以输入的大小，而是将除递归调用外在一个函数调用中发生的操作相加，然后加上递归调用的成本，用
    \(T\) 的引用来表示。因此，如果我们对长度进行这样的处理，我们将分两部分定义 \(T(k)\) ——长度为 \(k\) 的输入所需的时间—— 第一部分是
    \(T(0)\) 的值（当列表为空时），另一部分是 \(k\) 的非零值的值。我们知道 \(T(0) = 4\)（第一个条件语句及其相应的答案的成本）。如果列表非空，则成本为
    \(T(k) = 3 + 3 + 6 + T(k-1)\)（分别来自第一个问题，第二个问题，第二个答案中的剩余操作，以及对一个元素较小的列表的递归调用）。这给出了以下递归式：
- en: \begin{equation*}T(k) = \begin{cases} 4 & \text{when } k = 0 \\ 12 + T(k-1)
    & \text{when } k > 0\\ \end{cases}\end{equation*}
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}T(k) = \begin{cases} 4 & \text{当 } k = 0 \\ 12 + T(k-1) & \text{当
    } k > 0\\ \end{cases}\end{equation*}
- en: 'For a given list that is \(p\) elements long (note that \(p \geq 0\)), this
    would take \(12\) steps for the first element, \(12\) more steps for the second,
    \(12\) more for the third, and so on, until we run out of list elements and need
    \(4\) more steps: a total of \(12p + 4\) steps. Notice this is precisely the same
    answer we obtained by the tabular method!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个长度为 \(p\) 的给定列表（注意 \(p \geq 0\)），这需要 \(12\) 步处理第一个元素，再处理第二个需要 \(12\) 步，第三个需要
    \(12\) 步，以此类推，直到列表元素耗尽，需要额外的 \(4\) 步：总共 \(12p + 4\) 步。注意，这恰好是我们通过表格方法得到的相同答案！
- en: Exercise
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why can we assume that for a list \(p\) elements long, \(p \geq 0\)? And why
    did we take the trouble to explicitly state this above?
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们为什么可以假设对于一个长度为 \(p\) 的列表，\(p \geq 0\)？为什么我们要费力地在上面明确声明这一点？
- en: With some thought, you can see that the idea of constructing a recurrence works
    even when there is more than one recursive call, and when the argument to that
    call is one element structurally smaller. What we haven’t seen, however, is a
    way to solve such relations in general. That’s where we’re going next ([Solving
    Recurrences](#%28part._solving-recurrences%29)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些思考，你会发现即使存在多个递归调用，以及当该调用的参数结构上比原来的元素小一个元素时，构建递归的想法仍然有效。然而，我们还没有看到一种解决这种关系的普遍方法。这就是我们接下来要去的地方（[解决递归](#%28part._solving-recurrences%29)）。
- en: 14.7A Notation for Functions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.7 函数符号
- en: 'We have seen above that we can describe the running time of len through a function.
    We don’t have an especially good notation for writing such (anonymous) functions.
    Wait, we do—<wbr>fun (k): (12 * k) + 4 end—<wbr>but my colleagues would be horrified
    if you wrote this on their exams. Therefore, we’ll introduce the following notation
    to mean precisely the same thing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经看到，我们可以通过一个函数来描述 len 的运行时间。我们没有一个特别好的符号来书写这样的（匿名）函数。等等，我们有 —— `fun (k):
    (12 * k) + 4 end` —— 但如果你在他们的考试上写下这个，我的同事们会感到震惊。因此，我们将引入以下符号来精确表示相同的意思：'
- en: \begin{equation*}[k \rightarrow 12k + 4]\end{equation*}
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 12k + 4]\end{equation*}
- en: The brackets denote anonymous functions, with the parameters before the arrow
    and the body after.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 括号表示匿名函数，箭头前是参数，箭头后是函数体。
- en: 14.8Comparing Functions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.8 比较函数
- en: 'Let’s return to the running time of len. We’ve written down a function of great
    precision: 12! 4! Is this justified?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 len 的运行时间。我们已经写下了一个非常精确的函数：\(12k + 4\)！这种做法是否合理？
- en: At a fine-grained level already, no, it’s not. We’ve lumped many operations,
    with different actual running times, into a cost of one. So perhaps we should
    not worry too much about the differences between, say, \([k \rightarrow 12k +
    4]\) and \([k \rightarrow 4k + 10]\). If we were given two implementations with
    these running times, it’s likely that we would pick other characteristics to choose
    between them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个细粒度级别上，实际上是不合理的。我们将许多操作，具有不同实际运行时间的操作，汇总成一个成本。所以也许我们不应该太担心，比如说，\([k \rightarrow
    12k + 4]\) 和 \([k \rightarrow 4k + 10]\) 之间的差异。如果我们得到了这些运行时间的两个实现，我们很可能会选择其他特征来选择它们之间的区别。
- en: 'What this boils down to is being able to compare two functions—<wbr>representing
    the performance of implementations—<wbr>for whether one is somehow quantitatively
    better than the other. The example above suggests that small differences in constants
    probably do not matter. This suggests a definition of this form:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这归结为能够比较两个函数——代表实现性能的——看看其中一个是否在某种程度上比另一个更好。上面的例子表明，常数的微小差异可能并不重要。这暗示了以下形式的定义：
- en: \begin{equation*}\exists c . \forall n \in \mathbb{N}, f_1(n) \leq c \cdot f_2(n)
    \Rightarrow f_1 \leq f_2\end{equation*}
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}\exists c . \forall n \in \mathbb{N}, f_1(n) \leq c \cdot f_2(n)
    \Rightarrow f_1 \leq f_2\end{equation*}
- en: Obviously, the “bigger” function is likely to be a less useful bound than a
    “tighter” one. That said, it is conventional to write a “minimal” bound for functions,
    which means avoiding unnecessary constants, sum terms, and so on. The justification
    for this is given below ([Combining Big-Oh Without Woe](#%28part._big-oh-closure%29)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，“更大”的函数可能不如“更紧”的函数有用。也就是说，通常会为函数写一个“最小”的界限，这意味着避免不必要的常数、求和项等。这一点的理由如下所示（[不费力地结合大O](#%28part._big-oh-closure%29)）。
- en: Note carefully the order of identifiers. We must be able to pick the constant
    \(c\) up front for this relationship to hold. Had we swapped the order, it would
    mean that for every point along the number line, there must exist a constant—<wbr>and
    there always does! The swapped definition would therefore be useless. What is
    important is that we can identify the constant no matter how large the parameter
    gets. That is what makes this truly a constant.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细注意标识符的顺序。我们必须能够提前选择常数\(c\)，以使这种关系成立。如果我们交换了顺序，那意味着在数轴上的每一点，必须存在一个常数——而总是存在的！交换后的定义因此将是无用的。重要的是，无论参数变得多么大，我们都能确定常数。这才是真正的常数。
- en: 'This definition has more flexibility than we might initially think. For instance,
    consider our running example compared with \([k \rightarrow k^2]\). Clearly, the
    latter function eventually dominates the former: i.e.,'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义比我们最初想象的更灵活。例如，考虑我们的运行示例与\([k \rightarrow k^2]\)的比较。显然，后者最终会支配前者：即，
- en: \begin{equation*}[k \rightarrow 12k+4] \leq [k \rightarrow k^2]\end{equation*}
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 12k+4] \leq [k \rightarrow k^2]\end{equation*}
- en: We just need to pick a sufficiently large constant and we will find this to
    be true.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要选择一个足够大的常数，就会发现这是真的。
- en: Exercise
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the smallest constant that will suffice?
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是足够的最小常数？
- en: You will find more complex definitions in the literature and they all have merits,
    because they enable us to make finer-grained distinctions than this definition
    allows. For the purpose of this book, however, the above definition suffices.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中会找到更复杂的定义，它们都有其优点，因为它们使我们能够做出比这个定义更细致的区分。然而，对于本书的目的，上述定义就足够了。
- en: Observe that for a given function \(f\), there are numerous functions that are
    less than it. We use the notation \(O(\cdot)\) to describe this family of functions.In
    computer science this is usually pronounced “big-Oh”, though some prefer to call
    it the Bachmann-Landau notation after its originators. Thus if \(g \leq f\), we
    can write \(g \in O(f)\), which we can read as “\(f\) is an upper-bound for \(g\)”.
    Thus, for instance,
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对于给定函数\(f\)，存在许多小于它的函数。我们使用符号\(O(\cdot)\)来描述这个函数族。在计算机科学中，这通常被发音为“大O”，尽管有些人更喜欢称之为巴赫曼-朗道符号，以纪念其创始人。因此，如果\(g
    \leq f\)，我们可以写成\(g \in O(f)\)，我们可以将其解读为“\(f\)是\(g\)的一个上界”。因此，例如，
- en: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
- en: \begin{equation*}[k \rightarrow 4k+12] \in O([k \rightarrow k^2])\end{equation*}
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 4k+12] \in O([k \rightarrow k^2])\end{equation*}
- en: and so on.Pay especially close attention to our notation. We write \(\in\) rather
    than \(=\) or some other symbol, because \(O(f)\) describes a family of functions
    of which \(g\) is a member. We also write \(f\) rather than \(f(x)\) because we
    are comparing functions—<wbr>\(f\)—<wbr>rather than their values at particular
    points—<wbr>\(f(x)\)—<wbr>which would be ordinary numbers! Most of the notation
    in most the books and Web sites suffers from one or both flaws. We know, however,
    that functions are values, and that functions can be anonymous. We have actually
    exploited both facts to be able to write
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意我们的符号。我们使用 \(\in\) 而不是 \(=\) 或其他符号，因为 \(O(f)\) 描述的是 \(g\) 是其中一个成员的函数族。我们也写成
    \(f\) 而不是 \(f(x)\)，因为我们正在比较函数——\(f\)——而不是它们在特定点的值——\(f(x)\——这将是普通的数字！大多数书籍和网站上的符号都存在这两个缺陷之一或两者。然而，我们知道函数是值，函数可以是匿名的。我们实际上利用了这两个事实才能够写出
- en: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
- en: This is not the only notion of function comparison that we can have. For instance,
    given the definition of \(\leq\) above, we can define a natural relation \(<\).
    This then lets us ask, given a function \(f\), what are all the functions \(g\)
    such that \(g \leq f\) but not \(g < f\), i.e., those that are “equal” to \(f\).Look
    out! We are using quotes because this is not the same as ordinary function equality,
    which is defined as the two functions giving the same answer on all inputs. Here,
    two “equal” functions may not give the same answer on any inputs. This is the
    family of functions that are separated by at most a constant; when the functions
    indicate the order of growth of programs, “equal” functions signify programs that
    grow at the same speed (up to constants). We use the notation \(\Theta(\cdot)\)
    to speak of this family of functions, so if \(g\) is equivalent to \(f\) by this
    notion, we can write \(g \in \Theta(f)\) (and it would then also be true that
    \(f \in \Theta(g)\)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们可以有的唯一的函数比较概念。例如，鉴于上面的 \(\leq\) 的定义，我们可以定义一个自然的关系 \(<\)。这样我们就可以问，给定一个函数
    \(f\)，所有函数 \(g\) 是什么，使得 \(g \leq f\) 但不是 \(g < f\)，即“等于” \(f\) 的函数。注意！我们使用引号是因为这与普通的函数相等不同，普通的函数相等被定义为两个函数在所有输入上都给出相同的答案。在这里，两个“相等”的函数可能在任何输入上都不给出相同的答案。这是由最多一个常数分隔的函数族；当函数指示程序的增长顺序时，“相等”的函数表示以相同的速度增长的程序（直到常数因子）。我们使用符号
    \(\Theta(\cdot)\) 来谈论这个函数族，因此如果 \(g\) 根据这个概念等价于 \(f\)，我们可以写成 \(g \in \Theta(f)\)（那么
    \(f \in \Theta(g)\) 也成立）。
- en: Exercise
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convince yourself that this notion of function equality is an equivalence relation,
    and hence worthy of the name “equal”. It needs to be (a) reflexive (i.e., every
    function is related to itself); (b) antisymmetric (if \(f \leq g\) and \(g \leq
    f\) then \(f\) and \(g\) are equal); and (c) transitive (\(f \leq g\) and \(g
    \leq h\) implies \(f \leq h\)).
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说服自己，这种函数相等概念是一个等价关系，因此值得称为“相等”。它需要是（a）自反的（即，每个函数与自身相关）；（b）反对称的（如果 \(f \leq
    g\) 并且 \(g \leq f\)，那么 \(f\) 和 \(g\) 是相等的）；和（c）传递的（\(f \leq g\) 并且 \(g \leq h\)
    意味着 \(f \leq h\)）。
- en: 14.9Combining Big-Oh Without Woe
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.9 毫不费力地结合大 Oh 符号
- en: 'Now that we’ve introduced this notation, we should inquire about its closure
    properties: namely, how do these families of functions combine? To nudge your
    intuitions, assume that in all cases we’re discussing the running time of functions.
    We’ll consider three cases:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍了这个符号，我们应该询问它的封闭性质：也就是说，这些函数族如何组合？为了激发你的直觉，假设在所有情况下我们讨论的是函数的运行时间。我们将考虑三种情况：
- en: 'Suppose we have a function f (whose running time is) in \(O(F)\). Let’s say
    we run it \(p\) times, for some given constant. The running time of the resulting
    code is then \(p \times O(F)\). However, observe that this is really no different
    from \(O(F)\): we can simply use a bigger constant for \(c\) in the definition
    of \(O(\cdot)\)—<wbr>in particular, we can just use \(pc\). Conversely, then,
    \(O(pF)\) is equivalent to \(O(F)\). This is the heart of the intution that “multiplicative
    constants don’t matter”.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个函数 \(f\)（其运行时间为）在 \(O(F)\) 中。假设我们运行它 \(p\) 次，对于某个给定的常数。那么生成代码的运行时间就是
    \(p \times O(F)\)。然而，请注意，这与 \(O(F)\) 没有任何不同：我们可以在 \(O(\cdot)\) 的定义中简单地使用更大的常数——特别是，我们可以只是使用
    \(pc\)。反过来，\(O(pF)\) 等价于 \(O(F)\)。这就是“乘法常数无关紧要”的直觉核心。
- en: Suppose we have two functions, f in \(O(F)\) and g in \(O(G)\). If we run f
    followed by g, we would expect the running time of the combination to be the sum
    of their individual running times, i.e., \(O(F) + O(G)\). You should convince
    yourself that this is simply \(O(F + G)\).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有两个函数，f在\(O(F)\)中，g在\(O(G)\)中。如果我们先运行f，然后是g，我们期望组合的运行时间是它们各自运行时间的总和，即\(O(F)
    + O(G)\)。你应该说服自己这只是\(O(F + G)\)。
- en: Suppose we have two functions, f in \(O(F)\) and g in \(O(G)\). If f invokes
    g in each of its steps, we would expect the running time of the combination to
    be the product of their individual running times, i.e., \(O(F) \times O(G)\).
    You should convince yourself that this is simply \(O(F \times G)\).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有两个函数，f在\(O(F)\)中，g在\(O(G)\)中。如果f在每一步中调用g，我们期望组合的运行时间是它们各自运行时间的乘积，即\(O(F)
    \times O(G)\)。你应该说服自己这只是\(O(F \times G)\)。
- en: 'These three operations—<wbr>addition, multiplication by a constant, and multiplication
    by a function—<wbr>cover just about all the cases. For instance, we can use this
    to reinterpret the [tabular operations](#%28elem._length-cost-table%29) above
    (assuming everything is a function of \(k\)):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种操作——加法、乘以常数、乘以函数——几乎涵盖了所有情况。例如，我们可以利用这一点重新解释上面的[表操作](#%28elem._length-cost-table%29)（假设一切都是\(k\)的函数）：
- en: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
- en: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(1)\) |  | \(O(1)\)
    |  | \(O(k)\) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(1)\) |  | \(O(1)\)
    |  | \(O(k)\) |'
- en: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(k)\) |  | \(O(k)\)
    |  | \(O(k)\) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(k)\) |  | \(O(k)\)
    |  | \(O(k)\) |'
- en: 'Because multiplication by constants doesn’t matter, we can replace the \(3\)
    with \(1\). Because addition of a constant doesn’t matter (run the addition rule
    in reverse), \(k+1\) can become \(k\). Adding this gives us \(O(k) + O(k) = 2
    \times O(k) \in O(k)\). This justifies claiming that running len on a \(k\)-element
    list takes time in \(O([k \rightarrow k])\), which is a much simpler way of describing
    its bound than \(O([k \rightarrow 12k + 4])\). In particular, it provides us with
    the essential information and nothing else: as the input (list) grows, the running
    time grows proportional to it, i.e., if we add one more element to the input,
    we should expect to add a constant more of time to the running time.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因为乘以常数不重要，所以我们可以用\(1\)代替\(3\)。因为加常数不重要（将加法规则反向运行），\(k+1\)可以变成\(k\)。加上这一项给我们\(O(k)
    + O(k) = 2 \times O(k) \in O(k)\)。这证明了对一个\(k\)元素列表运行len花费的时间是\(O([k \rightarrow
    k])\)的说法是合理的，这比\(O([k \rightarrow 12k + 4])\)描述它的边界更简单。特别是，它为我们提供了基本信息，没有其他东西：随着输入（列表）的增长，运行时间与之成正比，即，如果我们向输入添加一个元素，我们应该期望增加一个常数的运行时间。
- en: 14.10Solving Recurrences
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.10解递推关系
- en: There is a great deal of literature on solving recurrence equations. In this
    section we won’t go into general techniques, nor will we even discuss very many
    different recurrences. Rather, we’ll focus on just a handful that should be in
    the repertoire of every computer scientist. You’ll see these over and over, so
    you should instinctively recognize their recurrence pattern and know what complexity
    they describe (or know how to quickly derive it).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多文献介绍如何解决递推方程。在本节中，我们不会讨论一般技术，也不会讨论很多不同的递推关系。相反，我们将专注于应该是每个计算机科学家的基本技能之一的几个。你会一遍又一遍地看到这些，所以你应该本能地识别它们的递推模式，并知道它们描述的复杂度（或者知道如何快速推导出它）。
- en: 'Earlier we saw a recurrence that had two cases: one for the empty input and
    one for all others. In general, we should expect to find one case for each non-recursive
    call and one for each recursive one, i.e., roughly one per cases clause. In what
    follows, we will ignore the base cases so long as the size of the input is constant
    (such as zero or one), because in such cases the amount of work done will also
    be a constant, which we can generally ignore ([Comparing Functions](#%28part._big-oh-def%29)).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到一个有两种情况的递推关系：一个是空输入，另一个是其他所有情况。通常，我们应该期望为每个非递归调用找到一个情况，并为每个递归调用找到一个情况，即，大致每个情况子句一个。在接下来的内容中，我们将忽略基本情况，只要输入的大小是常量（如零或一），因为在这种情况下所做的工作量也将是一个常量，我们通常可以忽略它（[比较函数](#%28part._big-oh-def%29)）。
- en: '| \(T(k)\) | = | \(T(k-1) + c\) |'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k-1) + c\) |'
- en: '|  | = | \(T(k-2) + c + c\) |'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-2) + c + c\) |'
- en: '|  | = | \(T(k-3) + c + c + c\) |'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-3) + c + c + c\) |'
- en: '|  | = | ... |'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(0) + c \times k\) |'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(0) + c \times k\) |'
- en: '|  | = | \(c_0 + c \times k\) |'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + c \times k\) |'
- en: Thus \(T \in O([k \rightarrow k])\). Intuitively, we do a constant amount of
    work (\(c\)) each time we throw away one element (\(k-1\)), so we do a linear
    amount of work overall.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此 \(T \in O([k \rightarrow k])\)。直观地，每次丢弃一个元素时我们都做了固定量的工作（\(c\)），因此总体上我们做了线性量的工作。
- en: '| \(T(k)\) | = | \(T(k-1) + k\) |'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k-1) + k\) |'
- en: '|  | = | \(T(k-2) + (k-1) + k\) |'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-2) + (k-1) + k\) |'
- en: '|  | = | \(T(k-3) + (k-2) + (k-1) + k\) |'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k-3) + (k-2) + (k-1) + k\) |'
- en: '|  | = | ... |'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) |'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) |'
- en: '|  | = | \(c_0 + 1 + 2 + \cdots + (k-2) + (k-1) + k\) |'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + 1 + 2 + \cdots + (k-2) + (k-1) + k\) |'
- en: '|  | = | \(c_0 + {\frac{k \cdot (k+1)}{2}}\) |'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_0 + {\frac{k \cdot (k+1)}{2}}\) |'
- en: Thus \(T \in O([k \rightarrow k^2])\). This follows from the solution to the
    sum of the first \(k\) numbers.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此 \(T \in O([k \rightarrow k^2])\)。这是根据前 \(k\) 个数的和的解得出的。
- en: '| \(T(k)\) | = | \(T(k/2) + c\) |'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k/2) + c\) |'
- en: '|  | = | \(T(k/4) + c + c\) |'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/4) + c + c\) |'
- en: '|  | = | \(T(k/8) + c + c + c\) |'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/8) + c + c + c\) |'
- en: '|  | = | ... |'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(k/2^{\log_2 k}) + c \cdot \log_2 k\) |'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/2^{\log_2 k}) + c \cdot \log_2 k\) |'
- en: '|  | = | \(c_1 + c \cdot \log_2 k\) |'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + c \cdot \log_2 k\) |'
- en: Thus \(T \in O([k \rightarrow \log k])\). Intuitively, we’re able to do only
    constant work (\(c\)) at each level, then throw away half the input. In a logarithmic
    number of steps we will have exhausted the input, having done only constant work
    each time. Thus the overall complexity is logarithmic.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此 \(T \in O([k \rightarrow \log k])\)。直观地，我们每次在每个级别上都只做常量工作（\(c\)），然后丢弃一半的输入。在对数步骤中，我们将耗尽输入，每次都只做常量工作。因此，总体复杂度是对数的。
- en: '| \(T(k)\) | = | \(T(k/2) + k\) |'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(T(k/2) + k\) |'
- en: '|  | = | \(T(k/4) + k/2 + k\) |'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(k/4) + k/2 + k\) |'
- en: '|  | = | ... |'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(T(1) + k/2^{\log_2 k} + \cdots + k/4 + k/2 + k\) |'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(T(1) + k/2^{\log_2 k} + \cdots + k/4 + k/2 + k\) |'
- en: '|  | = | \(c_1 + k(1/2^{\log_2 k} + \cdots + 1/4 + 1/2 + 1)\) |'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + k(1/2^{\log_2 k} + \cdots + 1/4 + 1/2 + 1)\) |'
- en: '|  | = | \(c_1 + 2k\) |'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(c_1 + 2k\) |'
- en: Thus \(T \in O([k \rightarrow k])\). Intuitively, the first time your process
    looks at all the elements, the second time it looks at half of them, the third
    time a quarter, and so on. This kind of successive halving is equivalent to scanning
    all the elements in the input a second time. Hence this results in a linear process.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此 \(T \in O([k \rightarrow k])\)。直观地，第一次处理时查看所有元素，第二次查看其中一半，第三次查看四分之一，依此类推。这种逐步减半等同于第二次扫描输入中的所有元素。因此，这导致了一个线性的过程。
- en: '| \(T(k)\) | = | \(2T(k/2) + k\) |'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(2T(k/2) + k\) |'
- en: '|  | = | \(2(2T(k/4) + k/2) + k\) |'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2(2T(k/4) + k/2) + k\) |'
- en: '|  | = | \(4T(k/4) + k + k\) |'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k/4) + k + k\) |'
- en: '|  | = | \(4(2T(k/8) + k/4) + k + k\) |'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4(2T(k/8) + k/4) + k + k\) |'
- en: '|  | = | \(8T(k/8) + k + k + k\) |'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k/8) + k + k + k\) |'
- en: '|  | = | ... |'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(2^{\log_2 k} T(1) + k \cdot \log_2 k\) |'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2^{\log_2 k} T(1) + k \cdot \log_2 k\) |'
- en: '|  | = | \(k \cdot c_1 + k \cdot \log_2 k\) |'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(k \cdot c_1 + k \cdot \log_2 k\) |'
- en: Thus \(T \in O([k \rightarrow k \cdot \log k])\). Intuitively, each time we’re
    processing all the elements in each recursive call (the \(k\)) as well as decomposing
    into two half sub-problems. This decomposition gives us a recursion tree of logarithmic
    height, at each of which levels we’re doing linear work.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此 \(T \in O([k \rightarrow k \cdot \log k])\)。直观地，每次我们处理所有递归调用中的元素（\(k\)），同时将其分解为两个子问题。这种分解给出了一个高度为对数的递归树，在每个级别上我们都在做线性工作。
- en: '| \(T(k)\) | = | \(2T(k-1) + c\) |'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_TB
  zh: '| \(T(k)\) | = | \(2T(k-1) + c\) |'
- en: '|  | = | \(2T(k-1) + (2-1)c\) |'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2T(k-1) + (2-1)c\) |'
- en: '|  | = | \(2(2T(k-2) + c) + (2-1)c\) |'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2(2T(k-2) + c) + (2-1)c\) |'
- en: '|  | = | \(4T(k-2) + 3c\) |'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k-2) + 3c\) |'
- en: '|  | = | \(4T(k-2) + (4-1)c\) |'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4T(k-2) + (4-1)c\) |'
- en: '|  | = | \(4(2T(k-3) + c) + (4-1)c\) |'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(4(2T(k-3) + c) + (4-1)c\) |'
- en: '|  | = | \(8T(k-3) + 7c\) |'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k-3) + 7c\) |'
- en: '|  | = | \(8T(k-3) + (8-1)c\) |'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(8T(k-3) + (8-1)c\) |'
- en: '|  | = | ... |'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | ... |'
- en: '|  | = | \(2^k T(0) + (2^k-1)c\) |'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | \(2^k T(0) + (2^k-1)c\) |'
- en: Thus \(T \in O([k \rightarrow 2^k])\). Disposing of each element requires doing
    a constant amount of work for it and then doubling the work done on the rest.
    This successive doubling leads to the exponential.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此 \(T \in O([k \rightarrow 2^k])\)。每个元素的处理都需要做一定量的工作，然后在其余部分上加倍工作。这种逐步加倍导致指数增长。
- en: Exercise
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using induction, prove each of the above derivations.
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用归纳法证明上述每个推导。
