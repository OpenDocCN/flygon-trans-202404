- en: 14Predicting Growth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [14.1 A Little (True) Story](#%28part._.A_.Little__.True__.Story%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
- en: '|     [14.2 The Analytical Idea](#%28part._.The_.Analytical_.Idea%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
- en: '|     [14.3 A Cost Model for Pyret Running Time](#%28part._cost-model%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
- en: '|     [14.4 The Size of the Input](#%28part._size-of-input%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
- en: '|     [14.5 The Tabular Method for Singly-Structurally-Recursive Functions](#%28part._.The_.Tabular_.Method_for_.Singly-.Structurally-.Recursive_.Functions%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
- en: '|     [14.6 Creating Recurrences](#%28part._creating-recurrences%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
- en: '|     [14.7 A Notation for Functions](#%28part._math-anon-functions%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
- en: '|     [14.8 Comparing Functions](#%28part._big-oh-def%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: '|     [14.9 Combining Big-Oh Without Woe](#%28part._big-oh-closure%29) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
- en: '|     [14.10 Solving Recurrences](#%28part._solving-recurrences%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: We will now commence the study of determining how long a computation takes.
    We’ll begin with a little (true) story.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 14.1A Little (True) Story
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My student Debbie recently wrote tools to analyze data for a startup. The company
    collects information about product scans made on mobile phones, and Debbie’s analytic
    tools classified these by product, by region, by time, and so on. As a good programmer,
    Debbie first wrote synthetic test cases, then developed her programs and tested
    them. She then obtained some actual test data from the company, broke them down
    into small chunks, computed the expected answers by hand, and tested her programs
    again against these real (but small) data sets. At the end of this she was ready
    to declare the programs ready.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, however, she had only tested them for functional correctness.
    There was still a question of how quickly her analytical tools would produce answers.
    This presented two problems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The company was rightly reluctant to share the entire dataset with outsiders,
    and in turn we didn’t want to be responsible for carefully guarding all their
    data.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if we did get a sample of their data, as more users used their product,
    the amount of data they had was sure to grow.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We therefore got only a sampling of their full data, and from this had to make
    some prediction on how long it would take to run the analytics on subsets (e.g.,
    those corresponding to just one region) or all of their data set, both today and
    as it grew over time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Debbie was given 100,000 data points. She broke them down into input sets of
    10, 100, 1,000, 10,000, and 100,000 data points, ran her tools on each input size,
    and plotted the result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: From this graph we have a good bet at guessing how long the tool would take
    on a dataset of 50,000\. It’s much harder, however, to be sure how long it would
    take on datasets of size 1.5 million or 3 million or 10 million.These processes
    are respectively called interpolation and extrapolation. We’ve already explained
    why we couldn’t get more data from the company. So what could we do?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'As another problem, suppose we have multiple implementations available. When
    we plot their running time, say the graphs look like this, with red, green, and
    blue each representing different implementations. On small inputs, suppose the
    running times look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/161579f02374f222dd7841886f410721.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'This doesn’t seem to help us distinguish between the implementations. Now suppose
    we run the algorithms on larger inputs, and we get the following graphs:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/7910dc4f35f470ccfbe24b4466fc7a4b.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Now we seem to have a clear winner (red), though it’s not clear there is much
    to give between the other two (blue and green). But if we calculate on even larger
    inputs, we start to see dramatic differences:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f3bd44d1531671deb5a2e576761aafec.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: In fact, the functions that resulted in these lines were the same in all three
    figures. What these pictures tell us is that it is dangerous to extrapolate too
    much from the performance on small inputs. If we could obtain closed-form descriptions
    of the performance of computations, it would be nice if we could compare them
    better. That is what we will now do.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 14.2The Analytical Idea
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With many physical processes, the best we can do is obtain as many data points
    as possible, extrapolate, and apply statistics to reason about the most likely
    outcome. Sometimes we can do that in computer science, too, but fortunately we
    computer scientists have an enormous advantage over most other sciences: instead
    of measuring a black-box process, we have full access to its internals, namely
    the source code. This enables us to apply analytical methods.“Analytical” means
    applying algebraic and other mathematical methods to make predictive statements
    about a process without running it. The answer we compute this way is complementary
    to what we obtain from the above experimental analysis, and in practice we will
    usually want to use a combination of the two to arrive a strong understanding
    of the program’s behavior.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The analytical idea is startlingly simple. We look at the source of the program
    and list the operations it performs. For each operation, we look up what it costs.We
    are going to focus on one kind of cost, namely running time. There are many other
    other kinds of costs one can compute. We might naturally be interested in space
    (memory) consumed, which tells us how big a machine we need to buy. We might also
    care about power, this tells us the cost of our energy bills, or of bandwidth,
    which tells us what kind of Internet connection we will need. In general, then,
    we’re interested in resource consumption. In short, don’t make the mistake of
    equating “performance” with “speed”: the costs that matter depend on the context
    in which the application runs. We add up these costs for all the operations. This
    gives us a total cost for the program.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, for most programs the answer will not be a constant number. Rather,
    it will depend on factors such as the size of the input. Therefore, our answer
    is likely to be an expression in terms of parameters (such as the input’s size).
    In other words, our answer will be a function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many functions that can describe the running-time of a function.
    Often we want an upper bound on the running time: i.e., the actual number of operations
    will always be no more than what the function predicts. This tells us the maximunm
    resource we will need to allocate. Another function may present a lower bound,
    which tells us the least resource we need. Sometimes we want an average-case analysis.
    And so on. In this text we will focus on upper-bounds, but keep in mind that all
    these other analyses are also extremely valuable.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is incorrect to speak of “the” upper-bound function, because there isn’t
    just one. Given one upper-bound function, can you construct another one?
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 14.3A Cost Model for Pyret Running Time
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin by presenting a cost model for the running time of Pyret programs.
    We are interested in the cost of running a program, which is tantamount to studying
    the expressions of a program. Simply making a definition does not cost anything;
    the cost is incurred only when we use a definition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a very simple (but sufficiently accurate) cost model: every operation
    costs one unit of time in addition to the time needed to evaluate its sub-expressions.
    Thus it takes one unit of time to look up a variable or to allocate a constant.
    Applying primitive functions also costs one unit of time. Everything else is a
    compound expression with sub-expressions. The cost of a compound expression is
    one plus that of each of its sub-expressions. For instance, the running time cost
    of the expression e1 + e2 (for some sub-expressions e1 and e2) is the running
    time for e1 + the running time for e2 + 1\. Thus the expression 17 + 29 has a
    cost of 3 (one for each sub-expression and one for the addition); the expression
    1 + (7 * (2 / 9)) costs 7.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are two big approximations here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: First, we are using an abstract rather than concrete notion of time. This is
    unhelpful in terms of estimating the so-called “wall clock” running time of a
    program, but then again, that number depends on numerous factors—<wbr>not just
    what kind of processor and how much memory you have, but even what other tasks
    are running on your computer at the same time. In contrast, abstract time units
    are more portable.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, not every operation takes the same number of machine cycles, whereas
    we have charged all of them the same number of abstract time units. As long as
    the actual number of cycles each one takes is bounded by a constant factor of
    the number taken by another, this will not pose any mathematical problems for
    reasons we will soon understand ([Comparing Functions](#%28part._big-oh-def%29)).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, it is instructive—<wbr>after carefully settting up the experimental
    conditions—<wbr>to make an analytical prediction of a program’s behavior and then
    verify it against what the implementation actually does. If the analytical prediction
    is accurate, we can reconstruct the constant factors hidden in our calculations
    and thus obtain very precise wall-clock time bounds for the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在仔细设置实验条件后，<wbr>对程序的行为进行分析预测然后验证实现与预测是否一致是很有教益的。
- en: 14.4The Size of the Input
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4输入的大小
- en: 'We are going to gloss over how to measure the size of a number. Observe that
    the value of a number is exponentially larger than its size: given three spaces
    we can write 1,000 different natural numbers, but given a fourth space we can
    write not 1,001 but 10,000 different numbers. Thus, when studying functions over
    numbers, the space we charge should be only logarithmic in the value. This distinction
    will not matter for the programs we work with in this text, so we permit ourselves
    the fiction of equating value and size. In programs where numbers are central—<wbr>e.g.,
    when testing primality—<wbr>this distinction is everything! We will return to
    this briefly later ([The Complexity of Numbers](Algorithms_That_Exploit_State.html#%28part._numbers-not-constant%29)).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将忽略如何测量数字的大小。请注意，数字的值比其大小大得多：给定三个空格，我们可以写出 1,000 个不同的自然数，但是给定第四个空格，我们可以写出的不是
    1,001 而是 10,000 个不同的数字。因此，在研究与数字相关的函数时，我们收取的空间应该只是值的对数。这种区别对我们在本文中处理的程序不重要，所以我们允许自己假设值和大小是相等的。在数字是中心的程序中——<wbr>例如，在测试素数时——<wbr>这种区别就至关重要了！稍后我们将简要回到这一点（[数字的复杂性](Algorithms_That_Exploit_State.html#%28part._numbers-not-constant%29)）。
- en: It can be subtle to define the size of the argument. Suppose a function consumes
    a list of numbers; it would be natural to define the size of its argument to be
    the length of the list, i.e., the number of links in the list. We could also define
    it to be twice as large, to account for both the links and the individual numbers
    (but as we’ll see ([Comparing Functions](#%28part._big-oh-def%29)), constants
    usually don’t matter). But suppose a function consumes a list music albums, and
    each music album is itself a list of songs, each of which has information about
    singers and so on. Then how we measure the size depends on what part of the input
    the function being analyzed actually examines. If, say, it only returns the length
    of the list of albums, then it is indifferent to what each list element contains
    [REF para poly], and only the length of the list of albums matters. If, however,
    the function returns a list of all the singers on every album, then it traverses
    all the way down to individual songs, and we have to account for all these data.
    In short, we care about the size of the data potentially accessed by the function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定义参数的大小可能会很微妙。假设一个函数消耗了一个数字列表；将其参数的大小定义为列表的长度，即列表中的链接数，这是很自然的。我们也可以将其定义为两倍大，以考虑到链接和单独的数字（但正如我们将看到的（[比较函数](#%28part._big-oh-def%29)），常数通常并不重要）。但是假设一个函数消耗了一个音乐专辑列表，每个音乐专辑本身都是一个包含有关歌手等信息的歌曲列表。那么我们如何衡量大小取决于被分析的函数实际检查的输入部分。例如，如果它仅返回专辑列表的长度，则它对列表元素的内容是无关紧要的
    [REF para poly]，只有专辑列表的长度才重要。但是，如果函数返回每个专辑上所有歌手的列表，则它会遍历到单个歌曲，并且我们必须考虑所有这些数据。简而言之，我们关心函数可能访问的数据的大小。
- en: 14.5The Tabular Method for Singly-Structurally-Recursive Functions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5单结构递归函数的表格法
- en: Given sizes for the arguments, we simply examine the body of the function and
    add up the costs of the individual operations. Most interesting functions are,
    however, conditionally defined, and may even recur. Here we will assume there
    is only one structural recursive call. We will get to more general cases in a
    bit [[Creating Recurrences](#%28part._creating-recurrences%29)].
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 给定参数的大小，我们只需检查函数体并将各个操作的成本相加即可。然而，大多数有趣的函数都是有条件定义的，甚至可能是递归的。在这里，我们将假设只有一个结构递归调用。我们稍后将讨论更一般的情况（[创建递归关系](#%28part._creating-recurrences%29)）。
- en: When we have a function with only one recursive call, and it’s structural, there’s
    a handy technique we can use to handle conditionals.This idea is due to Prabhakar
    Ragde. We will set up a table. It won’t surprise you to hear that the table will
    have as many rows as the cond has clauses. But instead of two columns, it has
    seven! This sounds daunting, but you’ll soon see where they come from and why
    they’re there.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'For each row, fill in the columns as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '|Q|: the number of operations in the question'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '#Q: the number of times the question will execute'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TotQ: the total cost of the question (multiply the previous two)'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|A|: the number of operations in the answer'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '#A: the number of times the answer will execute'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TotA: the total cost of the answer (multiply the previous two)'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Total: add the two totals to obtain an answer for the clause'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the total cost of the cond expression is obtained by summing the Total
    column in the individual rows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In the process of computing these costs, we may come across recursive calls
    in an answer expression. So long as there is only one recursive call in the entire
    answer, ignore it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once you’ve read the material on [Creating Recurrences](#%28part._creating-recurrences%29),
    come back to this and justify why it is okay to just skip the recursive call.
    Explain in the context of the overall tabular method.
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Excluding the treatment of recursion, justify (a) that these columns are individually
    accurate (e.g., the use of additions and multiplications is appropriate), and
    (b) sufficient (i.e., combined, they account for all operations that will be performed
    by that cond clause).
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It’s easiest to understand this by applying it to a few examples. First, let’s
    consider the len function, noting before we proceed that it does meet the criterion
    of having a single recursive call where the argument is structural:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s compute the cost of running len on a list of length \(k\) (where we are
    only counting the number of links in the list, and ignoring the content of each
    first element, since len ignores them too).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Because the entire body of len is given by a conditional, we can proceed directly
    to building the table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the first row. The question costs three units (one each to evaluate
    empty? and l, and one to apply the function). This is evaluated once per element
    in the list and once more when the list is empty, i.e., \(k+1\) times. The total
    cost of the question is thus \(3(k+1)\). The answer takes one unit of time to
    compute, and is evaluated only once (when the list is empty). Thus it takes a
    total of one unit, for a total of \(3k+4\) units.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Now for the second row. The question again costs three units, and is evaluated
    \(k\) times. The answer involves 3 units to evaluate (rest l), two more to evaluate
    and apply add1, one more to evaluate len...and no more, because we are ignoring
    the time spent in the recursive call itself. In short, it takes six units of time
    (in addition to the recursion we’ve chosen to ignore).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'In tabular form:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| \(3\) |  | \(k+1\) |  | \(3(k+1)\) |  | \(1\) |  | \(1\) |  | \(1\) |  |
    \(3k+4\) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| \(3\) |  | \(k\) |  | \(3k\) |  | \(6\) |  | \(k\) |  | \(6k\) |  | \(9k\)
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: Adding, we get \(12k + 4\). Thus running len on a \(k\)-element list takes \(12k+4\)
    units of time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How accurate is this estimate? If you try applying len to different sizes of
    lists, do you obtain a consistent estimate for \(k\)?
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 14.6Creating Recurrences
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now see a systematic way of analytically computing the time of a program.
    Suppose we have only one function f. We will define a function, \(T\), to compute
    an upper-bound of the time of f.In general, we will have one such cost function
    for each function in the program. In such cases, it would be useful to give a
    different name to each function to easily tell them apart. Since we are looking
    at only one function for now, we’ll reduce notational overhead by having only
    one \(T\). \(T\) takes as many parameters as f does. The parameters to \(T\) represent
    the sizes of the corresponding arguments to f. Eventually we will want to arrive
    at a closed form solution to \(T\), i.e., one that does not refer to \(T\) itself.
    But the easiest way to get there is to write a solution that is permitted to refer
    to \(T\), called a recurrence relation, and then see how to eliminate the self-reference
    [REF].
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: We repeat this procedure for each function in the program in turn. If there
    are many functions, first solve for the one with no dependencies on other functions,
    then use its solution to solve for a function that depends only on it, and progress
    thus up the dependency chain. That way, when we get to a function that refers
    to other functions, we will already have a closed-form solution for the referred
    function’s running time and can simply plug in parameters to obtain a solution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The strategy outlined above doesn’t work when there are functions that depend
    on each other. How would you generalize it to handle this case?
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The process of setting up a recurrence is easy. We simply define the right-hand-side
    of \(T\) to add up the operations performed in f’s body. This is straightforward
    except for conditionals and recursion. We’ll elaborate on the treatment of conditionals
    in a moment. If we get to a recursive call to f on the argument a, in the recurrence
    we turn this into a (self-)reference to \(T\) on the size of a.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'For conditionals, we use only the |Q| and |A| columns of the corresponding
    table. Rather than multiplying by the size of the input, we add up the operations
    that happen on one invocation of f other than the recursive call, and then add
    the cost of the recursive call in terms of a reference to \(T\). Thus, if we were
    doing this for len above, we would define \(T(k)\)—<wbr>the time needed on an
    input of length \(k\)—<wbr>in two parts: the value of \(T(0)\) (when the list
    is empty) and the value for non-zero values of \(k\). We know that \(T(0) = 4\)
    (the cost of the first conditional and its corresponding answer). If the list
    is non-empty, the cost is \(T(k) = 3 + 3 + 6 + T(k-1)\) (respectively from the
    first question, the second question, the remaining operations in the second answer,
    and the recursive call on a list one element smaller). This gives the following
    recurrence:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: \begin{equation*}T(k) = \begin{cases} 4 & \text{when } k = 0 \\ 12 + T(k-1)
    & \text{when } k > 0\\ \end{cases}\end{equation*}
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'For a given list that is \(p\) elements long (note that \(p \geq 0\)), this
    would take \(12\) steps for the first element, \(12\) more steps for the second,
    \(12\) more for the third, and so on, until we run out of list elements and need
    \(4\) more steps: a total of \(12p + 4\) steps. Notice this is precisely the same
    answer we obtained by the tabular method!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why can we assume that for a list \(p\) elements long, \(p \geq 0\)? And why
    did we take the trouble to explicitly state this above?
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: With some thought, you can see that the idea of constructing a recurrence works
    even when there is more than one recursive call, and when the argument to that
    call is one element structurally smaller. What we haven’t seen, however, is a
    way to solve such relations in general. That’s where we’re going next ([Solving
    Recurrences](#%28part._solving-recurrences%29)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 14.7A Notation for Functions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen above that we can describe the running time of len through a function.
    We don’t have an especially good notation for writing such (anonymous) functions.
    Wait, we do—<wbr>fun (k): (12 * k) + 4 end—<wbr>but my colleagues would be horrified
    if you wrote this on their exams. Therefore, we’ll introduce the following notation
    to mean precisely the same thing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: \begin{equation*}[k \rightarrow 12k + 4]\end{equation*}
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The brackets denote anonymous functions, with the parameters before the arrow
    and the body after.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 14.8Comparing Functions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s return to the running time of len. We’ve written down a function of great
    precision: 12! 4! Is this justified?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: At a fine-grained level already, no, it’s not. We’ve lumped many operations,
    with different actual running times, into a cost of one. So perhaps we should
    not worry too much about the differences between, say, \([k \rightarrow 12k +
    4]\) and \([k \rightarrow 4k + 10]\). If we were given two implementations with
    these running times, it’s likely that we would pick other characteristics to choose
    between them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'What this boils down to is being able to compare two functions—<wbr>representing
    the performance of implementations—<wbr>for whether one is somehow quantitatively
    better than the other. The example above suggests that small differences in constants
    probably do not matter. This suggests a definition of this form:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这归结为能够比较两个函数——代表实现性能的——看看其中一个是否在某种程度上比另一个更好。上面的例子表明，常数的微小差异可能并不重要。这暗示了以下形式的定义：
- en: \begin{equation*}\exists c . \forall n \in \mathbb{N}, f_1(n) \leq c \cdot f_2(n)
    \Rightarrow f_1 \leq f_2\end{equation*}
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}\exists c . \forall n \in \mathbb{N}, f_1(n) \leq c \cdot f_2(n)
    \Rightarrow f_1 \leq f_2\end{equation*}
- en: Obviously, the “bigger” function is likely to be a less useful bound than a
    “tighter” one. That said, it is conventional to write a “minimal” bound for functions,
    which means avoiding unnecessary constants, sum terms, and so on. The justification
    for this is given below ([Combining Big-Oh Without Woe](#%28part._big-oh-closure%29)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，“更大”的函数可能不如“更紧”的函数有用。也就是说，通常会为函数写一个“最小”的界限，这意味着避免不必要的常数、求和项等。这一点的理由如下所示（[不费力地结合大O](#%28part._big-oh-closure%29)）。
- en: Note carefully the order of identifiers. We must be able to pick the constant
    \(c\) up front for this relationship to hold. Had we swapped the order, it would
    mean that for every point along the number line, there must exist a constant—<wbr>and
    there always does! The swapped definition would therefore be useless. What is
    important is that we can identify the constant no matter how large the parameter
    gets. That is what makes this truly a constant.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细注意标识符的顺序。我们必须能够提前选择常数\(c\)，以使这种关系成立。如果我们交换了顺序，那意味着在数轴上的每一点，必须存在一个常数——而总是存在的！交换后的定义因此将是无用的。重要的是，无论参数变得多么大，我们都能确定常数。这才是真正的常数。
- en: 'This definition has more flexibility than we might initially think. For instance,
    consider our running example compared with \([k \rightarrow k^2]\). Clearly, the
    latter function eventually dominates the former: i.e.,'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义比我们最初想象的更灵活。例如，考虑我们的运行示例与\([k \rightarrow k^2]\)的比较。显然，后者最终会支配前者：即，
- en: \begin{equation*}[k \rightarrow 12k+4] \leq [k \rightarrow k^2]\end{equation*}
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 12k+4] \leq [k \rightarrow k^2]\end{equation*}
- en: We just need to pick a sufficiently large constant and we will find this to
    be true.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要选择一个足够大的常数，就会发现这是真的。
- en: Exercise
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the smallest constant that will suffice?
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是足够的最小常数？
- en: You will find more complex definitions in the literature and they all have merits,
    because they enable us to make finer-grained distinctions than this definition
    allows. For the purpose of this book, however, the above definition suffices.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中会找到更复杂的定义，它们都有其优点，因为它们使我们能够做出比这个定义更细致的区分。然而，对于本书的目的，上述定义就足够了。
- en: Observe that for a given function \(f\), there are numerous functions that are
    less than it. We use the notation \(O(\cdot)\) to describe this family of functions.In
    computer science this is usually pronounced “big-Oh”, though some prefer to call
    it the Bachmann-Landau notation after its originators. Thus if \(g \leq f\), we
    can write \(g \in O(f)\), which we can read as “\(f\) is an upper-bound for \(g\)”.
    Thus, for instance,
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对于给定函数\(f\)，存在许多小于它的函数。我们使用符号\(O(\cdot)\)来描述这个函数族。在计算机科学中，这通常被发音为“大O”，尽管有些人更喜欢称之为巴赫曼-朗道符号，以纪念其创始人。因此，如果\(g
    \leq f\)，我们可以写成\(g \in O(f)\)，我们可以将其解读为“\(f\)是\(g\)的一个上界”。因此，例如，
- en: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
- en: \begin{equation*}[k \rightarrow 4k+12] \in O([k \rightarrow k^2])\end{equation*}
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}[k \rightarrow 4k+12] \in O([k \rightarrow k^2])\end{equation*}
- en: and so on.Pay especially close attention to our notation. We write \(\in\) rather
    than \(=\) or some other symbol, because \(O(f)\) describes a family of functions
    of which \(g\) is a member. We also write \(f\) rather than \(f(x)\) because we
    are comparing functions—<wbr>\(f\)—<wbr>rather than their values at particular
    points—<wbr>\(f(x)\)—<wbr>which would be ordinary numbers! Most of the notation
    in most the books and Web sites suffers from one or both flaws. We know, however,
    that functions are values, and that functions can be anonymous. We have actually
    exploited both facts to be able to write
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: \begin{equation*}[k \rightarrow 3k] \in O([k \rightarrow 4k+12])\end{equation*}
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only notion of function comparison that we can have. For instance,
    given the definition of \(\leq\) above, we can define a natural relation \(<\).
    This then lets us ask, given a function \(f\), what are all the functions \(g\)
    such that \(g \leq f\) but not \(g < f\), i.e., those that are “equal” to \(f\).Look
    out! We are using quotes because this is not the same as ordinary function equality,
    which is defined as the two functions giving the same answer on all inputs. Here,
    two “equal” functions may not give the same answer on any inputs. This is the
    family of functions that are separated by at most a constant; when the functions
    indicate the order of growth of programs, “equal” functions signify programs that
    grow at the same speed (up to constants). We use the notation \(\Theta(\cdot)\)
    to speak of this family of functions, so if \(g\) is equivalent to \(f\) by this
    notion, we can write \(g \in \Theta(f)\) (and it would then also be true that
    \(f \in \Theta(g)\)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convince yourself that this notion of function equality is an equivalence relation,
    and hence worthy of the name “equal”. It needs to be (a) reflexive (i.e., every
    function is related to itself); (b) antisymmetric (if \(f \leq g\) and \(g \leq
    f\) then \(f\) and \(g\) are equal); and (c) transitive (\(f \leq g\) and \(g
    \leq h\) implies \(f \leq h\)).
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 14.9Combining Big-Oh Without Woe
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve introduced this notation, we should inquire about its closure
    properties: namely, how do these families of functions combine? To nudge your
    intuitions, assume that in all cases we’re discussing the running time of functions.
    We’ll consider three cases:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a function f (whose running time is) in \(O(F)\). Let’s say
    we run it \(p\) times, for some given constant. The running time of the resulting
    code is then \(p \times O(F)\). However, observe that this is really no different
    from \(O(F)\): we can simply use a bigger constant for \(c\) in the definition
    of \(O(\cdot)\)—<wbr>in particular, we can just use \(pc\). Conversely, then,
    \(O(pF)\) is equivalent to \(O(F)\). This is the heart of the intution that “multiplicative
    constants don’t matter”.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose we have two functions, f in \(O(F)\) and g in \(O(G)\). If we run f
    followed by g, we would expect the running time of the combination to be the sum
    of their individual running times, i.e., \(O(F) + O(G)\). You should convince
    yourself that this is simply \(O(F + G)\).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose we have two functions, f in \(O(F)\) and g in \(O(G)\). If f invokes
    g in each of its steps, we would expect the running time of the combination to
    be the product of their individual running times, i.e., \(O(F) \times O(G)\).
    You should convince yourself that this is simply \(O(F \times G)\).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three operations—<wbr>addition, multiplication by a constant, and multiplication
    by a function—<wbr>cover just about all the cases. For instance, we can use this
    to reinterpret the [tabular operations](#%28elem._length-cost-table%29) above
    (assuming everything is a function of \(k\)):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '| &#124;Q&#124; |  | #Q |  | TotQ |  | &#124;A&#124; |  | #A |  | TotA |  |
    Total |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(1)\) |  | \(O(1)\)
    |  | \(O(k)\) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| \(O(1)\) |  | \(O(k)\) |  | \(O(k)\) |  | \(O(1)\) |  | \(O(k)\) |  | \(O(k)\)
    |  | \(O(k)\) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: 'Because multiplication by constants doesn’t matter, we can replace the \(3\)
    with \(1\). Because addition of a constant doesn’t matter (run the addition rule
    in reverse), \(k+1\) can become \(k\). Adding this gives us \(O(k) + O(k) = 2
    \times O(k) \in O(k)\). This justifies claiming that running len on a \(k\)-element
    list takes time in \(O([k \rightarrow k])\), which is a much simpler way of describing
    its bound than \(O([k \rightarrow 12k + 4])\). In particular, it provides us with
    the essential information and nothing else: as the input (list) grows, the running
    time grows proportional to it, i.e., if we add one more element to the input,
    we should expect to add a constant more of time to the running time.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 14.10Solving Recurrences
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a great deal of literature on solving recurrence equations. In this
    section we won’t go into general techniques, nor will we even discuss very many
    different recurrences. Rather, we’ll focus on just a handful that should be in
    the repertoire of every computer scientist. You’ll see these over and over, so
    you should instinctively recognize their recurrence pattern and know what complexity
    they describe (or know how to quickly derive it).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we saw a recurrence that had two cases: one for the empty input and
    one for all others. In general, we should expect to find one case for each non-recursive
    call and one for each recursive one, i.e., roughly one per cases clause. In what
    follows, we will ignore the base cases so long as the size of the input is constant
    (such as zero or one), because in such cases the amount of work done will also
    be a constant, which we can generally ignore ([Comparing Functions](#%28part._big-oh-def%29)).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| \(T(k)\) | = | \(T(k-1) + c\) |'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_TB
- en: '|  | = | \(T(k-2) + c + c\) |'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(T(k-3) + c + c + c\) |'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | ... |'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(T(0) + c \times k\) |'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(c_0 + c \times k\) |'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Thus \(T \in O([k \rightarrow k])\). Intuitively, we do a constant amount of
    work (\(c\)) each time we throw away one element (\(k-1\)), so we do a linear
    amount of work overall.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| \(T(k)\) | = | \(T(k-1) + k\) |'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_TB
- en: '|  | = | \(T(k-2) + (k-1) + k\) |'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(T(k-3) + (k-2) + (k-1) + k\) |'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | ... |'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) |'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(c_0 + 1 + 2 + \cdots + (k-2) + (k-1) + k\) |'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(c_0 + {\frac{k \cdot (k+1)}{2}}\) |'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Thus \(T \in O([k \rightarrow k^2])\). This follows from the solution to the
    sum of the first \(k\) numbers.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| \(T(k)\) | = | \(T(k/2) + c\) |'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_TB
- en: '|  | = | \(T(k/4) + c + c\) |'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(T(k/8) + c + c + c\) |'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | ... |'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(T(k/2^{\log_2 k}) + c \cdot \log_2 k\) |'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(c_1 + c \cdot \log_2 k\) |'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Thus \(T \in O([k \rightarrow \log k])\). Intuitively, we’re able to do only
    constant work (\(c\)) at each level, then throw away half the input. In a logarithmic
    number of steps we will have exhausted the input, having done only constant work
    each time. Thus the overall complexity is logarithmic.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| \(T(k)\) | = | \(T(k/2) + k\) |'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_TB
- en: '|  | = | \(T(k/4) + k/2 + k\) |'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | ... |'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(T(1) + k/2^{\log_2 k} + \cdots + k/4 + k/2 + k\) |'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(c_1 + k(1/2^{\log_2 k} + \cdots + 1/4 + 1/2 + 1)\) |'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(c_1 + 2k\) |'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Thus \(T \in O([k \rightarrow k])\). Intuitively, the first time your process
    looks at all the elements, the second time it looks at half of them, the third
    time a quarter, and so on. This kind of successive halving is equivalent to scanning
    all the elements in the input a second time. Hence this results in a linear process.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| \(T(k)\) | = | \(2T(k/2) + k\) |'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_TB
- en: '|  | = | \(2(2T(k/4) + k/2) + k\) |'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(4T(k/4) + k + k\) |'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(4(2T(k/8) + k/4) + k + k\) |'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(8T(k/8) + k + k + k\) |'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | ... |'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(2^{\log_2 k} T(1) + k \cdot \log_2 k\) |'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(k \cdot c_1 + k \cdot \log_2 k\) |'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Thus \(T \in O([k \rightarrow k \cdot \log k])\). Intuitively, each time we’re
    processing all the elements in each recursive call (the \(k\)) as well as decomposing
    into two half sub-problems. This decomposition gives us a recursion tree of logarithmic
    height, at each of which levels we’re doing linear work.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| \(T(k)\) | = | \(2T(k-1) + c\) |'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_TB
- en: '|  | = | \(2T(k-1) + (2-1)c\) |'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(2(2T(k-2) + c) + (2-1)c\) |'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(4T(k-2) + 3c\) |'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(4T(k-2) + (4-1)c\) |'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(4(2T(k-3) + c) + (4-1)c\) |'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(8T(k-3) + 7c\) |'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(8T(k-3) + (8-1)c\) |'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | ... |'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  | = | \(2^k T(0) + (2^k-1)c\) |'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Thus \(T \in O([k \rightarrow 2^k])\). Disposing of each element requires doing
    a constant amount of work for it and then doubling the work done on the rest.
    This successive doubling leads to the exponential.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using induction, prove each of the above derivations.
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
