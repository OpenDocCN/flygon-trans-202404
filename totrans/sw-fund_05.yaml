- en: PolyPolymorphism and Higher-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export Lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphic Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the last couple of chapters, we've been working just
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with lists of numbers.  Obviously, interesting programs also need
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to be able to manipulate lists with elements from other types —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lists of strings, lists of booleans, lists of lists, etc.  We
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*could* just define a new inductive datatype for each of these,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for example...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '... but this would quickly become tedious, partly because we'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have to make up different constructor names for each datatype, but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mostly because we would also need to define new versions of all
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: our list manipulating functions (length, rev, etc.) for each
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new datatype definition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To avoid all this repetition, Coq supports *polymorphic*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inductive type definitions.  For example, here is a *polymorphic list* datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly like the definition of natlist from the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: previous chapter, except that the nat argument to the cons
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructor has been replaced by an arbitrary type X, a binding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for X has been added to the header, and the occurrences of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: natlist in the types of the constructors have been replaced by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: list X.  (We can re-use the constructor names nil and cons
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: because the earlier definition of natlist was inside of a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Module definition that is now out of scope.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What sort of thing is list itself?  One good way to think
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about it is that list is a *function* from Types to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inductive definitions; or, to put it another way, list is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function from Types to Types.  For any particular type X,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the type list X is an Inductively defined set of lists whose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elements are of type X.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this definition, when we use the constructors nil and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cons to build lists, we need to tell Coq the type of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elements in the lists we are building — that is, nil and cons
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are now *polymorphic constructors*.  Observe the types of these
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'constructors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '(Side note on notation: In .v files, the "forall" quantifier'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is spelled out in letters.  In the generated HTML files and in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: way various IDEs show .v files (with certain settings of their
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: display controls), ∀ is usually typeset as the usual
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mathematical "upside down A," but you'll still see the spelled-out
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"forall" in a few places.  This is just a quirk of typesetting:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: there is no difference in meaning.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The "∀ X" in these types can be read as an additional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argument to the constructors that determines the expected types of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the arguments that follow.  When nil and cons are used, these
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arguments are supplied in the same way as the others.  For
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'example, the list containing 2 and 1 is written like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: (We've written nil and cons explicitly here because we haven't
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'yet defined the [] and :: notations for the new version of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lists.  We'll do that in a bit.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can now go back and make polymorphic versions of all the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: list-processing functions that we wrote before.  Here is repeat,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As with nil and cons, we can use repeat by applying it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'first to a type and then to its list argument:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To use repeat to build other kinds of lists, we simply
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'instantiate it with an appropriate type parameter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 starsM (mumble_grumble)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the following two inductively defined types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Which of the following are well-typed elements of grumble X for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: some type X?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d (b a 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d mumble (b a 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d bool (b a 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e bool true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e mumble (b c 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e bool (b c 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Type Annotation Inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's write the definition of repeat again, but this time we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: won't specify the types of any of the arguments.  Will Coq still
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: accept it?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed it will.  Let''s see what type Coq has assigned to repeat'':'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It has exactly the same type type as repeat.  Coq was able
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to use *type inference* to deduce what the types of X, x, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: count must be, based on how they are used.  For example, since
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: X is used as an argument to cons, it must be a Type, since
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cons expects a Type as its first argument; matching count
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with 0 and S means it must be a nat; and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This powerful facility means we don't always have to write
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: explicit type annotations everywhere, although explicit type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: annotations are still quite useful as documentation and sanity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: checks, so we will continue to use them most of the time.  You
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: should try to find a balance in your own code between too many
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type annotations (which can clutter and distract) and too
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: few (which forces readers to perform type inference in their heads
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in order to understand your code).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: repeat' X x count : list X :=
  prefs: []
  type: TYPE_NORMAL
- en: we can also replace the types with _
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint repeat'''' X x count : list X :='
  prefs: []
  type: TYPE_NORMAL
- en: match count with
  prefs: []
  type: TYPE_NORMAL
- en: '| 0        ⇒ nil _'
  prefs: []
  type: TYPE_NORMAL
- en: '| S count'' ⇒ cons _ x (repeat'''' _ x count'')'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Definition list123 :=
  prefs: []
  type: TYPE_NORMAL
- en: cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Definition list123' :=
  prefs: []
  type: TYPE_NORMAL
- en: cons _ 1 (cons _ 2 (cons _ 3 (nil _))).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Arguments nil {X}.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments cons {X} _ _.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments repeat {X} x count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Definition list123'' := cons 1 (cons 2 (cons 3 nil)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint repeat'''''' {X : Type} (x : X) (count : nat) : list X :='
  prefs: []
  type: TYPE_NORMAL
- en: match count with
  prefs: []
  type: TYPE_NORMAL
- en: '| 0        ⇒ nil'
  prefs: []
  type: TYPE_NORMAL
- en: '| S count'' ⇒ cons x (repeat'''''' x count'')'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive list'' {X:Type} : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| nil'' : list'''
  prefs: []
  type: TYPE_NORMAL
- en: '| cons'' : X → list'' → list''.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint app {X : Type} (l[1] l[2] : list X)'
  prefs: []
  type: TYPE_NORMAL
- en: ': (list X) :='
  prefs: []
  type: TYPE_NORMAL
- en: match l[1] with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil      ⇒ l[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '| cons h t ⇒ cons h (app t l[2])'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint rev {X:Type} (l:list X) : list X :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil      ⇒ nil'
  prefs: []
  type: TYPE_NORMAL
- en: '| cons h t ⇒ app (rev t) (cons h nil)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint length {X : Type} (l : list X) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil ⇒ 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| cons _ l'' ⇒ S (length l'')'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_rev1 :'
  prefs: []
  type: TYPE_NORMAL
- en: rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_rev2:'
  prefs: []
  type: TYPE_NORMAL
- en: rev (cons true nil) = cons true nil.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Fail Definition mynil := nil.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition mynil : list nat := nil.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Check @nil.
  prefs: []
  type: TYPE_NORMAL
- en: Definition mynil' := @nil nat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notation "x :: y" := (cons x y)'
  prefs: []
  type: TYPE_NORMAL
- en: (at level 60, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "[ ]" := nil.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "[ x ; .. ; y ]" := (cons x .. (cons y []) ..).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "x ++ y" := (app x y)
  prefs: []
  type: TYPE_NORMAL
- en: (at level 60, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Definition list123''' := [1; 2; 3].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem app_nil_r : ∀(X:Type), ∀l:list X,'
  prefs: []
  type: TYPE_NORMAL
- en: l ++ [] = l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem app_assoc : ∀A (l m n:list A),'
  prefs: []
  type: TYPE_NORMAL
- en: l ++ m ++ n = (l ++ m) ++ n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma app_length : ∀(X:Type) (l[1] l[2] : list X),'
  prefs: []
  type: TYPE_NORMAL
- en: length (l[1] ++ l[2]) = length l[1] + length l[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem rev_app_distr: ∀X (l[1] l[2] : list X),'
  prefs: []
  type: TYPE_NORMAL
- en: rev (l[1] ++ l[2]) = rev l[2] ++ rev l[1].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rev_involutive : ∀X : Type, ∀l : list X,'
  prefs: []
  type: TYPE_NORMAL
- en: rev (rev l) = l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphic Pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the same pattern, the type definition we gave in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the last chapter for pairs of numbers can be generalized to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*polymorphic pairs*, often called *products*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As with lists, we make the type arguments implicit and define the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: familiar concrete notation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the Notation mechanism to define the standard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'notation for product *types*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '(The annotation : type_scope tells Coq that this abbreviation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: should only be used when parsing types.  This avoids a clash with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the multiplication symbol.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is easy at first to get (x,y) and X*Y confused.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember that (x,y) is a *value* built from two other values,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: while X*Y is a *type* built from two other types.  If x has
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type X and y has type Y, then (x,y) has type X*Y.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first and second projection functions now look pretty
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: much as they would in any functional programming language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The following function takes two lists and combines them
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: into a list of pairs.  In other functional languages, it is often
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: called zip; we call it combine for consistency with Coq's
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: standard library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optionalM (combine_checks)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try answering the following questions on paper and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'checking your answers in coq:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is the type of combine (i.e., what does Check @combine print?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, recommended (split)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The function split is the right inverse of combine: it takes a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: list of pairs and returns a pair of lists.  In many functional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: languages, it is called unzip.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill in the definition of split below.  Make sure it passes the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given unit test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive option (X:Type) : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| Some : X → option X'
  prefs: []
  type: TYPE_NORMAL
- en: '| None : option X.'
  prefs: []
  type: TYPE_NORMAL
- en: Arguments Some {X} _.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments None {X}.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint nth_error {X : Type} (l : list X) (n : nat)'
  prefs: []
  type: TYPE_NORMAL
- en: ': option X :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: '| a :: l'' ⇒ if beq_nat n O then Some a else nth_error l'' (pred n)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example test_nth_error3 : nth_error [true] 2 = None.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition hd_error {X : Type} (l : list X) : option X'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Check @hd_error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_hd_error1 : hd_error [1;2] = Some 1.'
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].'
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Functions as Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many other modern programming languages — including
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all functional languages (ML, Haskell, Scheme, Scala, Clojure,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: etc.) — Coq treats functions as first-class citizens, allowing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: them to be passed as arguments to other functions, returned as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: results, stored in data structures, etc.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition doit3times {X:Type} (f:X→X) (n:X) : X :='
  prefs: []
  type: TYPE_NORMAL
- en: f (f (f n)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Check @doit3times.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> doit3times : forall X : Type, (X -> X) -> X -> X *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_doit3times: doit3times minustwo 9 = 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_doit3times'': doit3times negb true = false.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint filter {X:Type} (test: X→bool) (l:list X)'
  prefs: []
  type: TYPE_NORMAL
- en: ': (list X) :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| []     ⇒ []'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒ if test h then h :: (filter test t)'
  prefs: []
  type: TYPE_NORMAL
- en: else       filter test t
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Example test_filter1: filter evenb [1;2;3;4] = [2;4].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition length_is_1 {X : Type} (l : list X) : bool :='
  prefs: []
  type: TYPE_NORMAL
- en: beq_nat (length l) 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_filter2:'
  prefs: []
  type: TYPE_NORMAL
- en: filter length_is_1
  prefs: []
  type: TYPE_NORMAL
- en: '[ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]'
  prefs: []
  type: TYPE_NORMAL
- en: = [ [3]; [4]; [8] ].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition countoddmembers'' (l:list nat) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: length (filter oddb l).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_countoddmembers''1:   countoddmembers'' [1;0;3;1;4;5] = 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_countoddmembers''2:   countoddmembers'' [0;2;4] = 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_countoddmembers''3:   countoddmembers'' nil = 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Example test_anon_fun'':'
  prefs: []
  type: TYPE_NORMAL
- en: doit3times (fun n ⇒ n * n) 2 = 256.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Example test_filter2'':'
  prefs: []
  type: TYPE_NORMAL
- en: filter (fun l ⇒ beq_nat (length l) 1)
  prefs: []
  type: TYPE_NORMAL
- en: '[ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]'
  prefs: []
  type: TYPE_NORMAL
- en: = [ [3]; [4]; [8] ].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition filter_even_gt[7] (l : list nat) : list nat'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_filter_even_gt7_1 :'
  prefs: []
  type: TYPE_NORMAL
- en: filter_even_gt[7] [1;2;6;9;10;3;12;8] = [10;12;8].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_filter_even_gt7_2 :'
  prefs: []
  type: TYPE_NORMAL
- en: filter_even_gt[7] [5;2;6;19;129] = [].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: partition : ∀X : Type,
  prefs: []
  type: TYPE_NORMAL
- en: (X → bool) → list X → list X * list X
  prefs: []
  type: TYPE_NORMAL
- en: Given a set X, a test function of type X → bool and a list X, partition should
    return a pair of lists.  The first member of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the pair is the sublist of the original list containing the
  prefs: []
  type: TYPE_NORMAL
- en: elements that satisfy the test, and the second is the sublist
  prefs: []
  type: TYPE_NORMAL
- en: containing those that fail the test.  The order of elements in the
  prefs: []
  type: TYPE_NORMAL
- en: two sublists should be the same as their order in the original
  prefs: []
  type: TYPE_NORMAL
- en: list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint map {X Y:Type} (f:X→Y) (l:list X) : (list Y) :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| []     ⇒ []'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒ (f h) :: (map f t)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Example test_map1: map (fun x ⇒ plus 3 x) [2;0;2] = [5;3;5].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Example test_map2:'
  prefs: []
  type: TYPE_NORMAL
- en: map oddb [2;1;2;5] = [false;true;false;true].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Example test_map3:'
  prefs: []
  type: TYPE_NORMAL
- en: map (fun n ⇒ [evenb n;oddb n]) [2;1;2;5]
  prefs: []
  type: TYPE_NORMAL
- en: = [[true;false];[false;true];[true;false];[false;true]].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem map_rev : ∀(X Y : Type) (f : X → Y) (l : list X),'
  prefs: []
  type: TYPE_NORMAL
- en: map f (rev l) = rev (map f l).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: flat_map (fun n ⇒ [n;n+1;n+2]) [1;5;10]
  prefs: []
  type: TYPE_NORMAL
- en: = [1; 2; 3; 5; 6; 7; 10; 11; 12].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lists are not the only inductive type that we can write a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: map function for.  Here is the definition of map for the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'option type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional (implicit_args)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The definitions and uses of filter and map use implicit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arguments in many places.  Replace the curly braces around the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: implicit arguments with parentheses, and then fill in explicit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type parameters where necessary and use Coq to check that you've
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: done so correctly.  (This exercise is not to be turned in; it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: probably easiest to do it on a *copy* of this file that you can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: throw away afterwards.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint fold {X Y:Type} (f: X→Y→Y) (l:list X) (b:Y)'
  prefs: []
  type: TYPE_NORMAL
- en: ': Y :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil ⇒ b'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒ f h (fold f t b)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: fold plus [1;2;3;4] 0
  prefs: []
  type: TYPE_NORMAL
- en: yields
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Check (fold andb).
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> fold andb : list bool -> bool -> bool *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example fold_example1 :'
  prefs: []
  type: TYPE_NORMAL
- en: fold mult [1;2;3;4] 1 = 24.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example fold_example2 :'
  prefs: []
  type: TYPE_NORMAL
- en: fold andb [true;true;false;true] true = false.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example fold_example3 :'
  prefs: []
  type: TYPE_NORMAL
- en: fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Functions That Construct Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the higher-order functions we have talked about so
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: far take functions as arguments.  Let's look at some examples that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involve *returning* functions as the results of other functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To begin, here is a function that takes a value x (drawn from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: some type X) and returns a function from nat to X that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yields x whenever it is called, ignoring its nat argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In fact, the multiple-argument functions we have already
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: seen are also examples of passing functions as data.  To see why,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: recall the type of plus.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Each → in this expression is actually a *binary* operator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: on types.  This operator is *right-associative*, so the type of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: plus is really a shorthand for nat → (nat → nat) — i.e., it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can be read as saying that "plus is a one-argument function that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: takes a nat and returns a one-argument function that takes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: another nat and returns a nat."  In the examples above, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have always applied plus to both of its arguments at once, but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if we like we can supply just the first.  This is called *partial application*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Additional Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars (fold_length)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many common functions on lists can be implemented in terms of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fold.  For example, here is an alternative definition of length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Prove the correctness of fold_length.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 starsM (fold_map)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can also define map in terms of fold.  Finish fold_map
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Write down a theorem fold_map_correct in Coq stating that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fold_map is correct, and prove it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, advanced (currying)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Coq, a function f : A → B → C really has the type A → (B → C).  That is,
    if you give f a value of type A, it'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'will give you function f'' : B → C.  If you then give f'' a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: value of type B, it will return a value of type C.  This
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: allows for partial application, as in plus3.  Processing a list
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of arguments with functions that return functions is called
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*currying*, in honor of the logician Haskell Curry.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Conversely, we can reinterpret the type A → B → C as (A * B) → C.  This is called
    *uncurrying*.  With an uncurried binary
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function, both arguments must be given at once as a pair; there is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: no partial application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can define currying as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, define its inverse, prod_uncurry.  Then prove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the theorems below to show that the two are inverses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As a (trivial) example of the usefulness of currying, we can use it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'to shorten one of the examples that we saw above:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Thought exercise: before running the following commands, can you'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: calculate the types of prod_curry and prod_uncurry?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, advancedM (nth_error_informal)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall the definition of the nth_error function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: ∀X n l, length l = n → @nth_error X l n = None
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 stars, advanced (church_numerals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This exercise explores an alternative way of defining natural
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: numbers, using the so-called *Church numerals*, named after
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mathematician Alonzo Church.  We can represent a natural number
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n as a function that takes a function f as a parameter and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: returns f iterated n times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how to write some numbers with this notation. Iterating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a function once should be the same as just applying it.  Thus:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, two should apply f twice to its argument:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining zero is somewhat trickier: how can we "apply a function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'zero times"?  The answer is actually simple: just return the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argument untouched.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: More generally, a number n can be written as fun X f x ⇒ f (f ... (f x) ...),
    with n occurrences of f.  Notice in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: particular how the doit3times function we've defined previously
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is actually just the Church representation of 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Complete the definitions of the following functions. Make sure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that the corresponding unit tests pass by proving them with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reflexivity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Successor of a natural number:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Addition of two natural numbers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplication:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Exponentiation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '(*Hint*: Polymorphism plays a crucial role here.  However,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: choosing the right type to iterate over can be tricky.  If you hit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a "Universe inconsistency" error, try iterating over a different
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'type: nat itself is usually problematic.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
