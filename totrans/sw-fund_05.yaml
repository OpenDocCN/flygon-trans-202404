- en: PolyPolymorphism and Higher-Order Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性和高阶函数
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Export Lists.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要导出列表。
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Polymorphic Lists
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态列表
- en: For the last couple of chapters, we've been working just
  id: totrans-5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们一直在工作
- en: with lists of numbers.  Obviously, interesting programs also need
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与数字列表。显然，有趣的程序也需要
- en: to be able to manipulate lists with elements from other types —
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 能够操作具有其他类型元素的列表 —
- en: lists of strings, lists of booleans, lists of lists, etc.  We
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字符串列表，布尔列表，列表列表等。我们
- en: '*could* just define a new inductive datatype for each of these,'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*可能*只是为这些中的每一个定义一个新的归纳数据类型，'
- en: for example...
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如...
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '... but this would quickly become tedious, partly because we'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...但这很快会变得乏味，部分原因是我们'
- en: have to make up different constructor names for each datatype, but
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须为每种数据类型编造不同的构造函数名称，但
- en: mostly because we would also need to define new versions of all
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主要是因为我们还需要定义所有的新版本
- en: our list manipulating functions (length, rev, etc.) for each
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的列表操作函数（length，rev 等）对于每个
- en: new datatype definition.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的数据类型定义。
- en: To avoid all this repetition, Coq supports *polymorphic*
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了避免所有这些重复，Coq支持*多态*
- en: inductive type definitions.  For example, here is a *polymorphic list* datatype.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 归纳类型定义。例如，这是一个*多态列表*数据类型。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is exactly like the definition of natlist from the
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与 natlist 的定义完全相同
- en: previous chapter, except that the nat argument to the cons
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一章节，除了 cons 的 nat 参数
- en: constructor has been replaced by an arbitrary type X, a binding
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数已被替换为任意类型 X，一个绑定
- en: for X has been added to the header, and the occurrences of
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 X 已经添加到标题中，并且出现的
- en: natlist in the types of the constructors have been replaced by
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数的类型中的 natlist 已被替换为
- en: list X.  (We can re-use the constructor names nil and cons
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表 X。（我们可以重复使用构造函数名称 nil 和 cons
- en: because the earlier definition of natlist was inside of a
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为 natlist 的早期定义在
- en: Module definition that is now out of scope.)
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在已经超出范围的模块定义。）
- en: What sort of thing is list itself?  One good way to think
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: list 本身是什么样的东西？一个好的思考方式
- en: about it is that list is a *function* from Types to
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于它的一点是 list 是一个*从类型到函数*的
- en: Inductive definitions; or, to put it another way, list is a
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 归纳定义；或者，换句话说，list 是一个
- en: function from Types to Types.  For any particular type X,
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从类型到类型的函数。对于任何特定类型 X，
- en: the type list X is an Inductively defined set of lists whose
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型列表 X 是一个归纳定义的列表集合
- en: elements are of type X.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 元素的类型为 X。
- en: With this definition, when we use the constructors nil and
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这个定义，当我们使用构造函数 nil 和
- en: cons to build lists, we need to tell Coq the type of the
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cons 来构建列表，我们需要告诉 Coq 类型的
- en: elements in the lists we are building — that is, nil and cons
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在构建的列表中的元素 — 即 nil 和 cons
- en: are now *polymorphic constructors*.  Observe the types of these
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在是*多态构造函数*。观察这些的类型
- en: 'constructors:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '(Side note on notation: In .v files, the "forall" quantifier'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （关于符号的侧注：在 .v 文件中，“forall”量词
- en: is spelled out in letters.  In the generated HTML files and in the
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用字母拼写出来。在生成的 HTML 文件和
- en: way various IDEs show .v files (with certain settings of their
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 各种 IDE 显示 .v 文件的方式（使用特定设置）
- en: display controls), ∀ is usually typeset as the usual
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示控制），∀ 通常被排版为通常的
- en: mathematical "upside down A," but you'll still see the spelled-out
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数学中的"倒立的A"，但你仍然会看到拼写出来的
- en: '"forall" in a few places.  This is just a quirk of typesetting:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几个地方会看到"forall"。这只是排版的一种怪癖：
- en: there is no difference in meaning.)
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 意义上没有区别。)
- en: The "∀ X" in these types can be read as an additional
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些类型中的"∀ X"可以被解读为额外的
- en: argument to the constructors that determines the expected types of
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数的参数，确定预期的类型
- en: the arguments that follow.  When nil and cons are used, these
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后面跟随的参数。当使用 nil 和 cons 时，这些
- en: arguments are supplied in the same way as the others.  For
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数以与其他参数相同的方式提供。对于
- en: 'example, the list containing 2 and 1 is written like this:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，包含 2 和 1 的列表写成这样：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (We've written nil and cons explicitly here because we haven't
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (我们在这里明确写出了 nil 和 cons，因为我们还没有
- en: 'yet defined the [] and :: notations for the new version of'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '尚未定义新版本的 [] 和 :: 符号'
- en: lists.  We'll do that in a bit.)
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表。我们稍后会做这个。)
- en: We can now go back and make polymorphic versions of all the
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以回去制作所有
- en: list-processing functions that we wrote before.  Here is repeat,
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们之前编写的列表处理函数。这是 repeat，
- en: 'for example:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As with nil and cons, we can use repeat by applying it
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 nil 和 cons 一样，我们可以通过应用 repeat 来��用它
- en: 'first to a type and then to its list argument:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先是一个类型，然后是它的列表参数：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To use repeat to build other kinds of lists, we simply
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用重复来构建其他类型的列表，我们只需
- en: 'instantiate it with an appropriate type parameter:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实例化它与适当的类型参数：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Exercise: 2 starsM (mumble_grumble)'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星M（mumble_grumble）
- en: Consider the following two inductively defined types.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下两种归纳定义的类型。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Which of the following are well-typed elements of grumble X for
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下哪些是 grumble X 的良好类型化元素
- en: some type X?
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些类型 X？
- en: d (b a 5)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: d（b a 5）
- en: d mumble (b a 5)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: d mumbo-jumbo（b a 5）
- en: d bool (b a 5)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: d 布尔（b a 5）
- en: e bool true
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e bool true
- en: e mumble (b c 0)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e mumbo-jumbo（b c 0）
- en: e bool (b c 0)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e 布尔（b c 0）
- en: c
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: c
- en: (* FILL IN HERE *)
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （*填写此处*）
- en: ☐
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Type Annotation Inference
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型注释推断
- en: Let's write the definition of repeat again, but this time we
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们再次编写 repeat 的定义，但这次我们
- en: won't specify the types of any of the arguments.  Will Coq still
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将不指定任何参数的类型。 Coq 仍然会
- en: accept it?
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接受吗？
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Indeed it will.  Let''s see what type Coq has assigned to repeat'':'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 的确会。 让我们看看 Coq 分配给 repeat' 的类型是什么：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It has exactly the same type type as repeat.  Coq was able
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它的类型与 repeat 完全相同。 Coq 能够
- en: to use *type inference* to deduce what the types of X, x, and
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 *类型推断* 来推断 X、x 和
- en: count must be, based on how they are used.  For example, since
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据它们的使用方式，count 必须是什么。 例如，因为
- en: X is used as an argument to cons, it must be a Type, since
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X 用作 cons 的参数，它必须是一个 Type，因为
- en: cons expects a Type as its first argument; matching count
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cons 期望作为其第一个参数的类型； 匹配计数
- en: with 0 and S means it must be a nat; and so on.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 0 和 S 意味着它必须是 nat； 等等。
- en: This powerful facility means we don't always have to write
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个强大的工具意味着我们不必总是写
- en: explicit type annotations everywhere, although explicit type
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显式类型注释到处都是，尽管显式类型
- en: annotations are still quite useful as documentation and sanity
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注释仍然非常有用作文档和理智
- en: checks, so we will continue to use them most of the time.  You
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查，所以我们将继续大多数时候使用它们。 你
- en: should try to find a balance in your own code between too many
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该尝试在自己的代码中找到太多之间的平衡
- en: type annotations (which can clutter and distract) and too
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型注释（可能会混乱和分散注意力）和太
- en: few (which forces readers to perform type inference in their heads
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很少（迫使读者在脑海中执行类型推断
- en: in order to understand your code).
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了理解您的代码）。
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: repeat' X x count : list X :=
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重复' X x 计数：列表 X :=
- en: we can also replace the types with _
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以用 _ 替换类型
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Fixpoint repeat'''' X x count : list X :='
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 递归重复'' X x count：列表 X :=
- en: match count with
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 count with
- en: '| 0        ⇒ nil _'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 ⇒ nil _'
- en: '| S count'' ⇒ cons _ x (repeat'''' _ x count'')'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '| S count'' ⇒ cons _ x（repeat'''' _ x count''）'
- en: end.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Definition list123 :=
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 定义列表123 :=
- en: cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: cons nat 1（cons nat 2（cons nat 3（nil nat）））。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Definition list123' :=
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 定义列表123' :=
- en: cons _ 1 (cons _ 2 (cons _ 3 (nil _))).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: cons _ 1（cons _ 2（cons _ 3（nil _）））。
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Arguments nil {X}.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 nil {X}。
- en: Arguments cons {X} _ _.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 cons {X} _ _。
- en: Arguments repeat {X} x count.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 参数重复 {X} x 计数。
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Definition list123'' := cons 1 (cons 2 (cons 3 nil)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 定义列表123'' := cons 1 (cons 2 (cons 3 nil))。
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Fixpoint repeat'''''' {X : Type} (x : X) (count : nat) : list X :='
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重复''' {X：Type}（x：X）（计数：nat）：列表 X :=
- en: match count with
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 count with
- en: '| 0        ⇒ nil'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 ⇒ nil'
- en: '| S count'' ⇒ cons x (repeat'''''' x count'')'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '| S count'' ⇒ cons x（repeat'''''' x count''）'
- en: end.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inductive list'' {X:Type} : Type :='
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳列表' {X：Type}：Type :=
- en: '| nil'' : list'''
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil'' : list'''
- en: '| cons'' : X → list'' → list''.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '| cons'' : X → list'' → list''。'
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Fixpoint app {X : Type} (l[1] l[2] : list X)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重复应用 {X：Type}（l[1] l[2]：列表 X）
- en: ': (list X) :='
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ：（列表 X）：=
- en: match l[1] with
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l[1] with
- en: '| nil      ⇒ l[2]'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil ⇒ l[2]'
- en: '| cons h t ⇒ cons h (app t l[2])'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '| cons h t ⇒ cons h (app t l[2])'
- en: end.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Fixpoint rev {X:Type} (l:list X) : list X :='
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 递归 rev {X：Type}（l：列表 X）：列表 X :=
- en: match l with
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l with
- en: '| nil      ⇒ nil'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil ⇒ nil'
- en: '| cons h t ⇒ app (rev t) (cons h nil)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '| cons h t ⇒ app（rev t）（cons h nil）'
- en: end.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: end.
- en: 'Fixpoint length {X : Type} (l : list X) : nat :='
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 递归长度 {X：Type}（l：列表 X）：nat :=
- en: match l with
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l with
- en: '| nil ⇒ 0'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil ⇒ 0'
- en: '| cons _ l'' ⇒ S (length l'')'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '| cons _ l'' ⇒ S (length l'')'
- en: end.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Example test_rev1 :'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 test_rev1：
- en: rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: rev（cons 1（cons 2 nil））=（cons 2（cons 1 nil））。
- en: Proof. reflexivity. Qed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 一致性。 Qed。
- en: 'Example test_rev2:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 test_rev2：
- en: rev (cons true nil) = cons true nil.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: rev（cons true nil）= cons true nil。
- en: Proof. reflexivity. Qed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 一致性。 Qed。
- en: 'Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 test_length1：长度（cons 1（cons 2（cons 3 nil）））= 3。
- en: Proof. reflexivity. Qed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 一致性。 Qed。
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Fail Definition mynil := nil.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Fail Definition mynil := nil。
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Definition mynil : list nat := nil.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 mynil：列表 nat := nil。
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Check @nil.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 @nil。
- en: Definition mynil' := @nil nat.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 mynil' := @nil nat。
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notation "x :: y" := (cons x y)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '符号"x :: y" :=（cons x y）'
- en: (at level 60, right associativity).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: （级别60，右结合）。
- en: Notation "[ ]" := nil.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"[ ]" := nil。
- en: Notation "[ x ; .. ; y ]" := (cons x .. (cons y []) ..).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"[ x ; .. ; y ]" :=（cons x ..（cons y []）..）。
- en: Notation "x ++ y" := (app x y)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表示法 "x ++ y" := (app x y)
- en: (at level 60, right associativity).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: （在级别 60，右结合性）。
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Definition list123''' := [1; 2; 3].
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 list123''' := [1; 2; 3]。
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Theorem app_nil_r : ∀(X:Type), ∀l:list X,'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 app_nil_r : ∀(X:Type), ∀l:list X,'
- en: l ++ [] = l.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: l ++ [] = l.
- en: Proof.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*）Admitted。
- en: 'Theorem app_assoc : ∀A (l m n:list A),'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 app_assoc : ∀A (l m n:list A),'
- en: l ++ m ++ n = (l ++ m) ++ n.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: l ++ m ++ n = (l ++ m) ++ n。
- en: Proof.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*）Admitted。
- en: 'Lemma app_length : ∀(X:Type) (l[1] l[2] : list X),'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 app_length : ∀(X:Type) (l[1] l[2] : list X),'
- en: length (l[1] ++ l[2]) = length l[1] + length l[2].
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: length (l[1] ++ l[2]) = length l[1] + length l[2].
- en: Proof.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*）Admitted。
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Theorem rev_app_distr: ∀X (l[1] l[2] : list X),'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rev_app_distr: ∀X (l[1] l[2] : list X),'
- en: rev (l[1] ++ l[2]) = rev l[2] ++ rev l[1].
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: rev (l[1] ++ l[2]) = rev l[2] ++ rev l[1]。
- en: Proof.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*）Admitted。
- en: 'Theorem rev_involutive : ∀X : Type, ∀l : list X,'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rev_involutive : ∀X : Type, ∀l : list X,'
- en: rev (rev l) = l.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: rev (rev l) = l。
- en: Proof.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*）Admitted。
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Polymorphic Pairs
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态对
- en: Following the same pattern, the type definition we gave in
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遵循相同的模式，我们在
- en: the last chapter for pairs of numbers can be generalized to
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于数字对的最后一章可以推广到
- en: '*polymorphic pairs*, often called *products*:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*多态对*，通常称为 *乘积*：'
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As with lists, we make the type arguments implicit and define the
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与列表一样，我们使类型参数隐式，并定义
- en: familiar concrete notation.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 熟悉的具体表示法。
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can also use the Notation mechanism to define the standard
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以使用表示法机制来定义标准的
- en: 'notation for product *types*:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于乘积 *类型* 的表示法：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '(The annotation : type_scope tells Coq that this abbreviation'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '（注释 : type_scope 告诉 Coq 这个缩写'
- en: should only be used when parsing types.  This avoids a clash with
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在解析类型时应该使用，这样可以避免与
- en: the multiplication symbol.)
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 乘法符号。）
- en: It is easy at first to get (x,y) and X*Y confused.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 起初很容易混淆 (x,y) 和 X*Y。
- en: Remember that (x,y) is a *value* built from two other values,
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住 (x,y) 是从另外两个值构建的 *值*，
- en: while X*Y is a *type* built from two other types.  If x has
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而 X*Y 是从其他两种类型构建的 *类型*。如果 x 有
- en: type X and y has type Y, then (x,y) has type X*Y.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型 X 和 y 的类型为 Y，那么 (x,y) 的类型为 X*Y。
- en: The first and second projection functions now look pretty
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个和第二个投影函数现在看起来相当
- en: much as they would in any functional programming language.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像它们在任何函数式编程语言中一样。
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The following function takes two lists and combines them
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下函数接受两个列表并将它们组合
- en: into a list of pairs.  In other functional languages, it is often
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转换为一对列表。在其他函数式语言中，通常
- en: called zip; we call it combine for consistency with Coq's
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们称之为 zip；为了与 Coq 的一致性，我们称之为 combine。
- en: standard library.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标准库。
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Exercise: 1 star, optionalM (combine_checks)'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星，可选M（combine_checks）
- en: Try answering the following questions on paper and
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试在纸上回答以下问题并
- en: 'checking your answers in coq:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查你在 coq 中的答案：
- en: What is the type of combine (i.e., what does Check @combine print?)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: combine 的类型是什么（即，Check @combine 打印什么？）
- en: What does
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是
- en: '[PRE35]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ☐
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars, recommended (split)'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星，推荐（split）
- en: 'The function split is the right inverse of combine: it takes a'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数 split 是 combine 的右逆：它接受一个
- en: list of pairs and returns a pair of lists.  In many functional
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一对列表并返回一对列表。在许多函数式
- en: languages, it is called unzip.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语言，它被称为 unzip。
- en: Fill in the definition of split below.  Make sure it passes the
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面填写 split 的定义。确保它通过
- en: given unit test.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定的单元测试。
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ☐
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inductive option (X:Type) : Type :='
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '形式 option (X:Type) : Type :='
- en: '| Some : X → option X'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '| Some : X → option X'
- en: '| None : option X.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '| None : option X。'
- en: Arguments Some {X} _.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 Some {X} _。
- en: Arguments None {X}.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 None {X}。
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Fixpoint nth_error {X : Type} (l : list X) (n : nat)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint nth_error {X : Type} (l : list X) (n : nat)'
- en: ': option X :='
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ': option X :='
- en: match l with
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l with
- en: '| [] ⇒ None'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '| [] ⇒ None'
- en: '| a :: l'' ⇒ if beq_nat n O then Some a else nth_error l'' (pred n)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '| a :: l'' ⇒ 如果 beq_nat n O 则 Some a 否则 nth_error l'' (pred n)'
- en: end.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4。'
- en: Proof. reflexivity. Qed.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: 'Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].'
- en: Proof. reflexivity. Qed.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: 'Example test_nth_error3 : nth_error [true] 2 = None.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_nth_error3 : nth_error [true] 2 = None.'
- en: Proof. reflexivity. Qed.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Definition hd_error {X : Type} (l : list X) : option X'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 hd_error {X : Type} (l : list X) : option X'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ." 替换此行*). Admitted.
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Check @hd_error.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 @hd_error。
- en: 'Example test_hd_error1 : hd_error [1;2] = Some 1.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_hd_error1 : hd_error [1;2] = Some 1。'
- en: (* FILL IN HERE *) Admitted.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写*）Admitted。
- en: 'Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1]。'
- en: (* FILL IN HERE *) Admitted.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写内容 *) 已承认。
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Functions as Data
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为数据
- en: Like many other modern programming languages — including
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与许多其他现代编程语言一样 — 包括
- en: all functional languages (ML, Haskell, Scheme, Scala, Clojure,
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有的函数式语言（ML、Haskell、Scheme、Scala、Clojure等）
- en: etc.) — Coq treats functions as first-class citizens, allowing
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等等。） — Coq 将函数视为一等公民，允许它们作为参数传递给其他函数，作为结果返回，存储在数据结构中等。
- en: them to be passed as arguments to other functions, returned as
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们可以作为参数传递给其他函数，作为结果返回，存储在数据结构中等。
- en: results, stored in data structures, etc.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果，存储在数据结构中等。
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Definition doit3times {X:Type} (f:X→X) (n:X) : X :='
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 doit3times {X:Type} (f:X→X) (n:X) : X :='
- en: f (f (f n)).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: f (f (f n))。
- en: '[PRE43]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Check @doit3times.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 @doit3times。
- en: (* ===> doit3times : forall X : Type, (X -> X) -> X -> X *)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> doit3times : forall X : Type, (X -> X) -> X -> X *)
- en: 'Example test_doit3times: doit3times minustwo 9 = 3.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_doit3times: doit3times minustwo 9 = 3。'
- en: Proof. reflexivity. Qed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: 'Example test_doit3times'': doit3times negb true = false.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_doit3times'': doit3times negb true = false。'
- en: Proof. reflexivity. Qed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Fixpoint filter {X:Type} (test: X→bool) (l:list X)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '固定点 filter {X:Type} (test: X→bool) (l:list X)，'
- en: ': (list X) :='
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ': (list X) :='
- en: match l with
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l，
- en: '| []     ⇒ []'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '| []     ⇒ []'
- en: '| h :: t ⇒ if test h then h :: (filter test t)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒ if test h then h :: (filter test t)'
- en: else       filter test t
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: else       filter test t
- en: end.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: end。
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Example test_filter1: filter evenb [1;2;3;4] = [2;4].'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_filter1: filter evenb [1;2;3;4] = [2;4]。'
- en: Proof. reflexivity. Qed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: 'Definition length_is_1 {X : Type} (l : list X) : bool :='
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 length_is_1 {X : Type} (l : list X) : bool :='
- en: beq_nat (length l) 1.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: beq_nat (length l) 1。
- en: 'Example test_filter2:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_filter2:'
- en: filter length_is_1
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: filter length_is_1
- en: '[ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]'
- en: = [ [3]; [4]; [8] ].
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: = [ [3]; [4]; [8] ]。
- en: Proof. reflexivity. Qed.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Definition countoddmembers'' (l:list nat) : nat :='
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 countoddmembers'' (l:list nat) : nat :='
- en: length (filter oddb l).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: length (filter oddb l)。
- en: 'Example test_countoddmembers''1:   countoddmembers'' [1;0;3;1;4;5] = 4.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_countoddmembers''1:   countoddmembers'' [1;0;3;1;4;5] = 4。'
- en: Proof. reflexivity. Qed.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: 'Example test_countoddmembers''2:   countoddmembers'' [0;2;4] = 0.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_countoddmembers''2:   countoddmembers'' [0;2;4] = 0。'
- en: Proof. reflexivity. Qed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: 'Example test_countoddmembers''3:   countoddmembers'' nil = 0.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_countoddmembers''3:   countoddmembers'' nil = 0。'
- en: Proof. reflexivity. Qed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: '[PRE47]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Example test_anon_fun'':'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_anon_fun'':'
- en: doit3times (fun n ⇒ n * n) 2 = 256.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: doit3times (fun n ⇒ n * n) 2 = 256。
- en: Proof. reflexivity. Qed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: '[PRE48]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Example test_filter2'':'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_filter2'':'
- en: filter (fun l ⇒ beq_nat (length l) 1)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: filter (fun l ⇒ beq_nat (length l) 1)
- en: '[ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]'
- en: = [ [3]; [4]; [8] ].
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: = [ [3]; [4]; [8] ]。
- en: Proof. reflexivity. Qed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Definition filter_even_gt[7] (l : list nat) : list nat'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 filter_even_gt[7] (l : list nat) : list nat'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: (* 将此行替换为 ":= _your_definition_ ." *）。已承认。
- en: 'Example test_filter_even_gt7_1 :'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_filter_even_gt7_1 :'
- en: filter_even_gt[7] [1;2;6;9;10;3;12;8] = [10;12;8].
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: filter_even_gt[7] [1;2;6;9;10;3;12;8] = [10;12;8]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写内容 *) 已承认。
- en: 'Example test_filter_even_gt7_2 :'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_filter_even_gt7_2 :'
- en: filter_even_gt[7] [5;2;6;19;129] = [].
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: filter_even_gt[7] [5;2;6;19;129] = []。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写内容 *) 已承认。
- en: '[PRE50]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: partition : ∀X : Type,
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: partition : ∀X : Type，
- en: (X → bool) → list X → list X * list X
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: (X → bool) → list X → list X * list X
- en: Given a set X, a test function of type X → bool and a list X, partition should
    return a pair of lists.  The first member of
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定一个集合 X、一个类型为 X → bool 的测试函数和一个列表 X，partition 应该返回一个列表对。第一个成员是满足测试的元素的列表，第二个是原始列表中包含不满足测试的元素的子列表。元素的顺序应与原始列表中的顺序相同。
- en: the pair is the sublist of the original list containing the
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 该对是原始列表中包含满足测试的子列表和包含不满足测试的子列表。
- en: elements that satisfy the test, and the second is the sublist
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 满足测试条件的元素，第二个是包含不满足测试的元素的子列表。元素的顺序应与原始列表中的顺序相同。
- en: containing those that fail the test.  The order of elements in the
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 包含不满足测试的那些元素。元素的顺序应与原始列表中的顺序相同。
- en: two sublists should be the same as their order in the original
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 两个子列表的顺序应与它们在原始列表中的顺序相同。
- en: list.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: list。
- en: '[PRE51]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ☐
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE52]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Fixpoint map {X Y:Type} (f:X→Y) (l:list X) : (list Y) :='
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '固定点 map {X Y:Type} (f:X→Y) (l:list X) : (list Y) :='
- en: match l with
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l，
- en: '| []     ⇒ []'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '| []     ⇒ []'
- en: '| h :: t ⇒ (f h) :: (map f t)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒ (f h) :: (map f t)'
- en: end.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: end。
- en: '[PRE53]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Example test_map1: map (fun x ⇒ plus 3 x) [2;0;2] = [5;3;5].'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_map1: map (fun x ⇒ plus 3 x) [2;0;2] = [5;3;5]。'
- en: Proof. reflexivity. Qed.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: '[PRE54]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Example test_map2:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_map2:'
- en: map oddb [2;1;2;5] = [false;true;false;true].
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: map oddb [2;1;2;5] = [false;true;false;true]。
- en: Proof. reflexivity. Qed.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: '[PRE55]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Example test_map3:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example test_map3:'
- en: map (fun n ⇒ [evenb n;oddb n]) [2;1;2;5]
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: map (fun n ⇒ [evenb n;oddb n]) [2;1;2;5]
- en: = [[true;false];[false;true];[true;false];[false;true]].
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: = [[true;false];[false;true];[true;false];[false;true]]。
- en: Proof. reflexivity. Qed.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。反射性。Qed。
- en: '[PRE56]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Theorem map_rev : ∀(X Y : Type) (f : X → Y) (l : list X),'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 map_rev : ∀(X Y : Type) (f : X → Y) (l : list X)，'
- en: map f (rev l) = rev (map f l).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: map f（rev l）= rev（map f l）。
- en: Proof.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: （* 在这里填写 *）承认。
- en: '[PRE57]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: flat_map (fun n ⇒ [n;n+1;n+2]) [1;5;10]
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: flat_map （fun n ⇒ [n;n+1;n+2]） [1;5;10]
- en: = [1; 2; 3; 5; 6; 7; 10; 11; 12].
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: = [1; 2; 3; 5; 6; 7; 10; 11; 12]。
- en: '[PRE58]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ☐
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: Lists are not the only inductive type that we can write a
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表不是我们可以编写的唯一归纳类型
- en: map function for.  Here is the definition of map for the
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: map 函数。这是 map 的定义
- en: 'option type:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选项类型：
- en: '[PRE59]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Exercise: 2 stars, optional (implicit_args)'
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星，可选（implicit_args）
- en: The definitions and uses of filter and map use implicit
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: filter 和 map 的定义和使用使用隐式
- en: arguments in many places.  Replace the curly braces around the
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多地方使用参数。替换大括号周围的
- en: implicit arguments with parentheses, and then fill in explicit
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 带括号的隐式参数，然后填写显式
- en: type parameters where necessary and use Coq to check that you've
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必要时使用类型参数，并使用 Coq 检查您是否
- en: done so correctly.  (This exercise is not to be turned in; it is
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做是正确的。（这个练习不需要提交；它是
- en: probably easiest to do it on a *copy* of this file that you can
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能最容易在您可以
- en: throw away afterwards.)
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后丢弃。）
- en: ☐
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE60]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Fixpoint fold {X Y:Type} (f: X→Y→Y) (l:list X) (b:Y)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Fixpoint fold {X Y:Type}（f：X→Y→Y）（l:list X）（b:Y）
- en: ': Y :='
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ：Y :=
- en: match l with
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l 与
- en: '| nil ⇒ b'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil ⇒ b'
- en: '| h :: t ⇒ f h (fold f t b)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒ f h (fold f t b)'
- en: end.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE61]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: fold plus [1;2;3;4] 0
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: fold plus [1;2;3;4] 0
- en: yields
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 产生
- en: '[PRE62]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Check (fold andb).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 检查（fold andb）。
- en: (* ===> fold andb : list bool -> bool -> bool *)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: （* ===> fold andb : list bool -> bool -> bool *）
- en: 'Example fold_example1 :'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 fold_example1：
- en: fold mult [1;2;3;4] 1 = 24.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: fold mult [1;2;3;4] 1 = 24。
- en: Proof. reflexivity. Qed.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: 'Example fold_example2 :'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 fold_example2：
- en: fold andb [true;true;false;true] true = false.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: fold andb [true;true;false;true] true = false。
- en: Proof. reflexivity. Qed.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: 'Example fold_example3 :'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 fold_example3：
- en: fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4]。
- en: Proof. reflexivity. Qed.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: '[PRE63]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: (* FILL IN HERE *)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: （* 在这里填写 *）
- en: '[PRE64]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Functions That Construct Functions
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数的函数
- en: Most of the higher-order functions we have talked about so
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们谈到的大多数高阶函数
- en: far take functions as arguments.  Let's look at some examples that
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 远的函数作为参数。让我们看一些示例
- en: involve *returning* functions as the results of other functions.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 涉及 *返回* 函数作为其他函数的结果。
- en: To begin, here is a function that takes a value x (drawn from
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，这里有一个函数，它接受一个值 x（来自
- en: some type X) and returns a function from nat to X that
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些类型 X）并返回一个从自然数到 X 的函数
- en: yields x whenever it is called, ignoring its nat argument.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当调用它时，都会返回 x，忽略其自然数参数。
- en: '[PRE65]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In fact, the multiple-argument functions we have already
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，我们已经
- en: seen are also examples of passing functions as data.  To see why,
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看到的也是将函数作为数据传递的示例。要了解原因，请参考
- en: recall the type of plus.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回忆加法的类型。
- en: '[PRE66]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Each → in this expression is actually a *binary* operator
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个表达式中的每个 → 实际上都是一个 *二元* 运算符
- en: on types.  This operator is *right-associative*, so the type of
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在类型上。这个运算符是 *右结合* 的，所以类型
- en: plus is really a shorthand for nat → (nat → nat) — i.e., it
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加号实际上是 nat →（nat → nat）的简写，即
- en: can be read as saying that "plus is a one-argument function that
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以解释为“plus 是一个接受一个参数的函数
- en: takes a nat and returns a one-argument function that takes
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接受一个自然数并返回一个接受
- en: another nat and returns a nat."  In the examples above, we
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个自然数并返回一个自然数。”在上面的例子中，我们
- en: have always applied plus to both of its arguments at once, but
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总是同时应用加法到它的两个参数，但
- en: if we like we can supply just the first.  This is called *partial application*.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以只提供第一个。这被称为 *部分应用*。
- en: '[PRE67]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Additional Exercises
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加练习
- en: '[PRE68]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Exercise: 2 stars (fold_length)'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星（fold_length）
- en: Many common functions on lists can be implemented in terms of
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经谈到的许多列表上的常见函数可以根据
- en: 'fold.  For example, here is an alternative definition of length:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠。例如，这里是长度的另一种定义：
- en: '[PRE69]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Prove the correctness of fold_length.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明 fold_length 的正确性。
- en: '[PRE70]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ☐
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 starsM (fold_map)'
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星M（fold_map）
- en: We can also define map in terms of fold.  Finish fold_map
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以根据 fold 定义 map。完成 fold_map
- en: below.
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面。
- en: '[PRE71]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Write down a theorem fold_map_correct in Coq stating that
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Coq 中写下一个定理 fold_map_correct，陈述
- en: fold_map is correct, and prove it.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: fold_map 正确，并证明它。
- en: '[PRE72]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ☐
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars, advanced (currying)'
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星，高级（柯里化）
- en: 'In Coq, a function f : A → B → C really has the type A → (B → C).  That is,
    if you give f a value of type A, it'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Coq 中，函数 f：A → B → C 实际上具有类型 A →（B → C）。也就是说，如果您给 f 一个类型为 A 的值
- en: 'will give you function f'' : B → C.  If you then give f'' a'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将给您一个函数 f'：B → C。然后，如果您给 f' 一个
- en: value of type B, it will return a value of type C.  This
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型 B 的值，它将返回类型 C 的值。这
- en: allows for partial application, as in plus3.  Processing a list
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许部分应用，如 plus3。处理一个列表
- en: of arguments with functions that return functions is called
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用返回函数的函数组合参数的过程被称为
- en: '*currying*, in honor of the logician Haskell Curry.'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*柯里化*，以逻辑学家 Haskell Curry 命名。'
- en: Conversely, we can reinterpret the type A → B → C as (A * B) → C.  This is called
    *uncurrying*.  With an uncurried binary
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，我们可以重新解释类型 A → B → C 为 (A * B) → C。这被称为 *非柯里化*。通过一个非柯里化的二元
- en: function, both arguments must be given at once as a pair; there is
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数，两个参数必须一次性给出作为一对；没有
- en: no partial application.
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有部分应用。
- en: 'We can define currying as follows:'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将柯里化定义如下：
- en: '[PRE73]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As an exercise, define its inverse, prod_uncurry.  Then prove
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为练习，定义它的逆函数 prod_uncurry。然后证明
- en: the theorems below to show that the two are inverses.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下定理来展示这两者是互为反函数。
- en: '[PRE74]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As a (trivial) example of the usefulness of currying, we can use it
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为柯里化有用性的（微不足道的）例子，我们可以使用它
- en: 'to shorten one of the examples that we saw above:'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缩短我们之前看到的例子之一：
- en: '[PRE75]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Thought exercise: before running the following commands, can you'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 思考练习：在运行以下命令之前，你能否
- en: calculate the types of prod_curry and prod_uncurry?
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算 prod_curry 和 prod_uncurry 的类型？
- en: '[PRE76]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ☐
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars, advancedM (nth_error_informal)'
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星，高级M（nth_error_informal）
- en: 'Recall the definition of the nth_error function:'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回顾 nth_error 函数的定义：
- en: '[PRE77]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ∀X n l, length l = n → @nth_error X l n = None
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ∀X n l，length l = n → @nth_error X l n = None
- en: (* FILL IN HERE *)
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （*在这里填写*）
- en: ☐
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 4 stars, advanced (church_numerals)'
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：4 星，高级（church_numerals）
- en: This exercise explores an alternative way of defining natural
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个练习探讨了定义自然数的另一种方式
- en: numbers, using the so-called *Church numerals*, named after
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字，使用所谓的 *Church 数*，以其名字命名
- en: mathematician Alonzo Church.  We can represent a natural number
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数学家阿隆佐·邱奇。我们可以用一种自然数表示
- en: n as a function that takes a function f as a parameter and
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 n 视为一个以函数 f 为参数的函数，并
- en: returns f iterated n times.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 f 迭代 n 次。
- en: '[PRE78]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Let's see how to write some numbers with this notation. Iterating
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看如何用这种表示法写一些数字。迭代
- en: 'a function once should be the same as just applying it.  Thus:'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个函数应用一次应该与直接应用它相同。因此：
- en: '[PRE79]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Similarly, two should apply f twice to its argument:'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，two 应该将 f 应用两次到它的参数上：
- en: '[PRE80]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Defining zero is somewhat trickier: how can we "apply a function'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义零有些棘手：我们如何“应用一个函数
- en: 'zero times"?  The answer is actually simple: just return the'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 零次”？答案实际上很简单：只需返回
- en: argument untouched.
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持参数不变。
- en: '[PRE81]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: More generally, a number n can be written as fun X f x ⇒ f (f ... (f x) ...),
    with n occurrences of f.  Notice in
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更一般地，一个数 n 可以写成 fun X f x ⇒ f (f ... (f x) ...), 其中 f 出现 n 次。请注意
- en: particular how the doit3times function we've defined previously
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是我们之前定义的 doit3times 函数
- en: is actually just the Church representation of 3.
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上只是 3 的 Church 表示。
- en: '[PRE82]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Complete the definitions of the following functions. Make sure
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成以下函数的定义。确保
- en: that the corresponding unit tests pass by proving them with
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过证明相应的单元测试是否通过
- en: reflexivity.
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自反性。
- en: 'Successor of a natural number:'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自然数的后继：
- en: '[PRE83]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Addition of two natural numbers:'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个自然数的加法：
- en: '[PRE84]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Multiplication:'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 乘法：
- en: '[PRE85]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Exponentiation:'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指数运算：
- en: '(*Hint*: Polymorphism plays a crucial role here.  However,'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （*提示*：多态在这里起着至关重要的作用。然而，
- en: choosing the right type to iterate over can be tricky.  If you hit
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择正确的类型进行迭代可能会有些棘手。如果你遇到
- en: a "Universe inconsistency" error, try iterating over a different
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个“宇宙不一致”错误，请尝试迭代不同的
- en: 'type: nat itself is usually problematic.)'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型：nat 本身通常会有问题。）
- en: '[PRE86]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ☐
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE87]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
