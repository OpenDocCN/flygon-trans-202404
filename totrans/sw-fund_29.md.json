["```\n\n```", "```\n\n# Adding Records\n\n    We saw in chapter [MoreStlc](MoreStlc.html) how records can be treated as just\n    syntactic sugar for nested uses of products.  This is OK for\n    simple examples, but the encoding is informal (in reality, if we\n    actually treated records this way, it would be carried out in the\n    parser, which we are eliding here), and anyway it is not very\n    efficient.  So it is also interesting to see how records can be\n    treated as first-class citizens of the language.  This chapter\n    shows how.\n\n    Recall the informal definitions we gave before: \n\n    Syntax:\n\n```", "```\n\n    Reduction:\n\n                        ti\u00a0\u21d2\u00a0ti'\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(ST_Rcd)\n           |\n\n           |\n\n* * *\n\n           |\n\n                        {i[1]=v[1],\u00a0...,\u00a0im=vm,\u00a0in=tn,\u00a0...}\u00a0\u21d2\u00a0{i[1]=v[1],\u00a0...,\u00a0im=vm,\u00a0in=tn',\u00a0...}\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Proj1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        t[1].i\u00a0\u21d2\u00a0t[1]'.i\n           |\n\n                     |\n\n           |\n\n                        (ST_ProjRcd) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {...,\u00a0i=vi,\u00a0...}.i\u00a0\u21d2\u00a0vi\n           |\n\n                     |\n\n    Typing:\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[1]\u00a0\u00a0\u00a0\u00a0\u00a0...\u00a0\u00a0\u00a0\u00a0\u00a0\u0393\u00a0\u22a2\u00a0tn\u00a0:\u00a0Tn\n           |\n\n                        (T_Rcd) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0{i[1]=t[1],\u00a0...,\u00a0in=tn}\u00a0:\u00a0{i[1]:T[1],\u00a0...,\u00a0in:Tn}\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t\u00a0:\u00a0{...,\u00a0i:Ti,\u00a0...}\n           |\n\n                        (T_Proj) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0t.i\u00a0:\u00a0Ti\n           |\n\n                     |\n\n```", "```\nModule STLCExtendedRecords.\n\n```", "```\nModule FirstTry.\n\nDefinition alist (X : Type) := list (id * X).\n\nInductive ty : Type :=\n\u00a0\u00a0| TBase     : id \u2192 ty\n\u00a0\u00a0| TArrow    : ty \u2192 ty \u2192 ty\n\u00a0\u00a0| TRcd      : (alist ty) \u2192 ty.\n\n```", "```\n(*\u00a0Check\u00a0ty_ind. \u00a0\u00a0\u00a0====> \u00a0\u00a0\u00a0\u00a0ty_ind\u00a0: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forall\u00a0P\u00a0:\u00a0ty\u00a0->\u00a0Prop, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(forall\u00a0i\u00a0:\u00a0id,\u00a0P\u00a0(TBase\u00a0i))\u00a0-> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(forall\u00a0t\u00a0:\u00a0ty,\u00a0P\u00a0t\u00a0->\u00a0forall\u00a0t[0]\u00a0:\u00a0ty,\u00a0P\u00a0t[0]\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->\u00a0P\u00a0(TArrow\u00a0t\u00a0t[0]))\u00a0-> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(forall\u00a0a\u00a0:\u00a0alist\u00a0ty,\u00a0P\u00a0(TRcd\u00a0a))\u00a0->\u00a0\u00a0\u00a0\u00a0(*\u00a0???\u00a0*) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forall\u00a0t\u00a0:\u00a0ty,\u00a0P\u00a0t *)\n\nEnd FirstTry.\n\n```", "```\nInductive ty : Type :=\n\u00a0\u00a0| TBase : id \u2192 ty\n\u00a0\u00a0| TArrow : ty \u2192 ty \u2192 ty\n\u00a0\u00a0| TRNil : ty\n\u00a0\u00a0| TRCons : id \u2192 ty \u2192 ty \u2192 ty.\n\n```", "```\nInductive tm : Type :=\n\u00a0\u00a0| tvar : id \u2192 tm\n\u00a0\u00a0| tapp : tm \u2192 tm \u2192 tm\n\u00a0\u00a0| tabs : id \u2192 ty \u2192 tm \u2192 tm\n\u00a0\u00a0(*\u00a0records\u00a0*)\n\u00a0\u00a0| tproj : tm \u2192 id \u2192 tm\n\u00a0\u00a0| trnil :  tm\n\u00a0\u00a0| trcons : id \u2192 tm \u2192 tm \u2192 tm.\n\n```", "```\nNotation a := (Id \"a\").\nNotation f := (Id \"f\").\nNotation g := (Id \"g\").\nNotation l := (Id \"l\").\nNotation A := (TBase (Id \"A\")).\nNotation B := (TBase (Id \"B\")).\nNotation k := (Id \"k\").\nNotation i[1] := (Id \"i1\").\nNotation i[2] := (Id \"i2\").\n\n```", "```\n(*\u00a0Check\u00a0(TRCons\u00a0i[1]\u00a0A\u00a0TRNil).\u00a0*)\n\n```", "```\n(*\u00a0Check\u00a0(TRCons\u00a0i[1]\u00a0(TArrow\u00a0A\u00a0B) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(TRCons\u00a0i[2]\u00a0A\u00a0TRNil)).\u00a0*)\n\n```", "```\nDefinition weird_type := TRCons X A B.\n\n```", "```\nInductive record_ty : ty \u2192 Prop :=\n\u00a0\u00a0| RTnil :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_ty TRNil\n\u00a0\u00a0| RTcons : \u2200i T[1] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_ty (TRCons i T[1] T[2]).\n\n```", "```\nInductive well_formed_ty : ty \u2192 Prop :=\n\u00a0\u00a0| wfTBase : \u2200i,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty (TBase i)\n\u00a0\u00a0| wfTArrow : \u2200T[1] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty (TArrow T[1] T[2])\n\u00a0\u00a0| wfTRNil :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty TRNil\n\u00a0\u00a0| wfTRCons : \u2200i T[1] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_ty T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty (TRCons i T[1] T[2]).\n\nHint Constructors record_ty well_formed_ty.\n\n```", "```\nInductive record_tm : tm \u2192 Prop :=\n\u00a0\u00a0| rtnil :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_tm trnil\n\u00a0\u00a0| rtcons : \u2200i t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_tm (trcons i t[1] t[2]).\n\nHint Constructors record_tm.\n\n```", "```\nFixpoint subst (x:id) (s:tm) (t:tm) : tm :=\n\u00a0\u00a0match t with\n\u00a0\u00a0| tvar y \u21d2 if beq_id x y then s else t\n\u00a0\u00a0| tabs y T t[1] \u21d2 tabs y T\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(if beq_id x y then t[1] else (subst x s t[1]))\n\u00a0\u00a0| tapp t[1] t[2] \u21d2 tapp (subst x s t[1]) (subst x s t[2])\n\u00a0\u00a0| tproj t[1] i \u21d2 tproj (subst x s t[1]) i\n\u00a0\u00a0| trnil \u21d2 trnil\n\u00a0\u00a0| trcons i t[1] tr[1] \u21d2 trcons i (subst x s t[1]) (subst x s tr[1])\n\u00a0\u00a0end.\n\nNotation \"'[' x ':=' s ']' t\" := (subst x s t) (at level 20).\n\n```", "```\nInductive value : tm \u2192 Prop :=\n\u00a0\u00a0| v_abs : \u2200x T[11] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tabs x T[11] t[12])\n\u00a0\u00a0| v_rnil : value trnil\n\u00a0\u00a0| v_rcons : \u2200i v[1] vr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value vr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (trcons i v[1] vr).\n\nHint Constructors value.\n\n```", "```\nFixpoint tlookup (i:id) (tr:tm) : option tm :=\n\u00a0\u00a0match tr with\n\u00a0\u00a0| trcons i' t tr' \u21d2 if beq_id i i' then Some t else tlookup i tr'\n\u00a0\u00a0| _ \u21d2 None\n\u00a0\u00a0end.\n\n```", "```\nReserved Notation \"t1 '\u21d2' t2\" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_AppAbs : \u2200x T[11] t[12] v[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tabs x T[11] t[12]) v[2]) \u21d2 ([x:=v[2]]t[12])\n\u00a0\u00a0| ST_App1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp t[1] t[2]) \u21d2 (tapp t[1]' t[2])\n\u00a0\u00a0| ST_App2 : \u2200v[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp v[1] t[2]) \u21d2 (tapp v[1] t[2]')\n\u00a0\u00a0| ST_Proj1 : \u2200t[1] t[1]' i,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tproj t[1] i) \u21d2 (tproj t[1]' i)\n\u00a0\u00a0| ST_ProjRcd : \u2200tr i vi,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tlookup i tr = Some vi \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tproj tr i) \u21d2 vi\n\u00a0\u00a0| ST_Rcd_Head : \u2200i t[1] t[1]' tr[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons i t[1] tr[2]) \u21d2 (trcons i t[1]' tr[2])\n\u00a0\u00a0| ST_Rcd_Tail : \u2200i v[1] tr[2] tr[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tr[2] \u21d2 tr[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons i v[1] tr[2]) \u21d2 (trcons i v[1] tr[2]')\n\nwhere \"t1 '\u21d2' t2\" := (step t[1] t[2]).\n\nNotation multistep := (multi step).\nNotation \"t1 '\u21d2*' t2\" := (multistep t[1] t[2]) (at level 40).\n\nHint Constructors step.\n\n```", "```\nFixpoint Tlookup (i:id) (Tr:ty) : option ty :=\n\u00a0\u00a0match Tr with\n\u00a0\u00a0| TRCons i' T Tr' \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id i i' then Some T else Tlookup i Tr'\n\u00a0\u00a0| _ \u21d2 None\n\u00a0\u00a0end.\n\nDefinition context := partial_map ty.\n\nReserved Notation \"Gamma '\u22a2' t '\u2208' T\" (at level 40).\n\nInductive has_type : context \u2192 tm \u2192 ty \u2192 Prop :=\n\u00a0\u00a0| T_Var : \u2200\u0393 x T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 x = Some T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tvar x) \u2208 T\n\u00a0\u00a0| T_Abs : \u2200\u0393 x T[11] T[12] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[11] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(update \u0393 x T[11]) \u22a2 t[12] \u2208 T[12] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tabs x T[11] t[12]) \u2208 (TArrow T[11] T[12])\n\u00a0\u00a0| T_App : \u2200T[1] T[2] \u0393 t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 (TArrow T[1] T[2]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tapp t[1] t[2]) \u2208 T[2]\n\u00a0\u00a0(*\u00a0records:\u00a0*)\n\u00a0\u00a0| T_Proj : \u2200\u0393 i t Ti Tr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t \u2208 Tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Tlookup i Tr = Some Ti \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tproj t i) \u2208 Ti\n\u00a0\u00a0| T_RNil : \u2200\u0393,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 trnil \u2208 TRNil\n\u00a0\u00a0| T_RCons : \u2200\u0393 i t T tr Tr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tr \u2208 Tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_ty Tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_tm tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (trcons i t tr) \u2208 (TRCons i T Tr)\n\nwhere \"Gamma '\u22a2' t '\u2208' T\" := (has_type \u0393 t T).\n\nHint Constructors has_type.\n\n```", "```\nLemma typing_example_2 :\n\u00a0\u00a0empty \u22a2\n\u00a0\u00a0\u00a0\u00a0(tapp (tabs a (TRCons i[1] (TArrow A A)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(TRCons i[2] (TArrow B B)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TRNil))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tproj (tvar a) i[2]))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons i[1] (tabs a A (tvar a))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons i[2] (tabs a B (tvar a))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0trnil))) \u2208\n\u00a0\u00a0\u00a0\u00a0(TArrow B B).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample typing_nonexample :\n\u00a0\u00a0\u00ac \u2203T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(update empty a (TRCons i[2] (TArrow A A)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TRNil)) \u22a2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons i[1] (tabs a B (tvar a)) (tvar a)) \u2208\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample typing_nonexample_2 : \u2200y,\n\u00a0\u00a0\u00ac \u2203T,\n\u00a0\u00a0\u00a0\u00a0(update empty y A) \u22a2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tabs a (TRCons i[1] A TRNil)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tproj (tvar a) i[1]))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons i[1] (tvar y) (trcons i[2] (tvar y) trnil))) \u2208\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n### Well-Formedness\n\n```", "```\n\n### Field Lookup\n\n    Lemma: If empty \u22a2 v : T and Tlookup i T returns Some Ti,\n     then tlookup i v returns Some ti for some term ti such\n     that empty \u22a2 ti \u2208 Ti.\n\n    Proof: By induction on the typing derivation Htyp.  Since\n      Tlookup i T = Some Ti, T must be a record type, this and\n      the fact that v is a value eliminate most cases by inspection,\n      leaving only the T_RCons case.\n\n    If the last step in the typing derivation is by T_RCons, then\n      t = trcons i[0] t tr and T = TRCons i[0] T Tr for some i[0],\n      t, tr, T and Tr.\n\n    This leaves two possiblities to consider - either i[0] = i or\n      not.\n\n*   If i = i[0], then since Tlookup i (TRCons i[0] T Tr) = Some Ti we have T = Ti. It follows that t itself satisfies the theorem. \n\n*   On the other hand, suppose i \u2260 i[0]. Then \n\n    ```", "```\n    tlookup\u00a0i\u00a0t\u00a0=\u00a0tlookup\u00a0i\u00a0tr,\n\n     so the result follows from the induction hypothesis. \u2610\n    ```", "```\n\n    Here is the formal statement:\n\n```", "```\n\n### Progress\n\n```", "```\n\n### Context Invariance\n\n```", "```\n\n### Preservation\n\n```", "```\n\n    \u2610\n\n```", "```\n\n```", "```\n\n```"]