- en: Constructing Procedures Using Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the following definition of `sum-doubles`, which takes two numbers
    `a` and `b`, and returns the sum of all numbers between `a` and `b` doubled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since the `double` function was not already defined for us, we had to define
    it ourselves inside of our `sum-doubles` definition.
  prefs: []
  type: TYPE_NORMAL
- en: But doing that is such a waste! Outside of our `sum-doubles` definition, we
    won't ever be able use that `double` function. Isn't there a quick, easy way to
    make a user-defined function without first defining, then applying the named function?
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambdas: The Anonymous Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, yes. Let's introduce the **lambda** function, otherwise known as an
    anonymous function. These mysterious functions will be major players in the concepts
    we will discuss in future lessons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general form for a lambda is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dissect this. Within the parentheses, we have three major parts:'
  prefs: []
  type: TYPE_NORMAL
- en: a **tag**, `lambda`, which tells Racket that this is a lambda function,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a **list of parameters** (as many as you want),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and the **body**â€”anything following the list of parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The procedure `double`, for example, can be defined as the following lambda
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In other words,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'would be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When describing lambdas, you would call it "the function of [params] that returns
    [body]." For example, "`double` is the function of `x` that returns `(* 2 x)`."
  prefs: []
  type: TYPE_NORMAL
- en: Calling Lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we can call procedures created using `define`, we can also call lambda
    functions. The general form of a call to a lambda is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`((lambda (<param1> <param2> ... <paramn>) <body>) <arg1> <arg2> ... <argn>)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we want to call `(double 5)` as an anonymous function, the substitution
    model would give us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What happens here? When we call a lambda function, the first argument corresponds
    to the first parameter, the second argument to the second parameter, ..., and
    the nth argument to the nth parameter. Then, in the body, every occurence of each
    parameter is replaced with the corresponding argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate this with an example expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the body of the lambda, we replace every occurence of `x` with `1`. We replace
    every `y` we see with `2`. And every time we see a `z`, we replace it with `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can rewrite `sum-doubles` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:** The value returned by creating a `lambda` is a procedure, just as
    much as one made with a call to `define`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try these expressions out in the Racket interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
