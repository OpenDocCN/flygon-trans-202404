- en: MVars revisited
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVars再访
- en: 'Exercise: Write transfer function to move money between accounts'
  id: totrans-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习：编写转账函数在账户之间转移资金
- en: '`wget` [`cs240h.stanford.edu/transfer.hs`](http://cs240h.scs.stanford.edu/transfer.hs)'
  id: totrans-2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wget` [`cs240h.stanford.edu/transfer.hs`](http://cs240h.scs.stanford.edu/transfer.hs)'
- en: '[PRE0]'
  id: totrans-3
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Should work atomically with multiple threads
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该能够与多个线程一起原子地工作
- en: E.g., other threads should never see money in neither account or both accounts
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，其他线程不应该看到任何一个账户中的资金或两个账户中的资金
- en: Don't transfer money if insufficient funds in account
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果账户中资金不足，则不要转移资金
- en: 'Example:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE1]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First attempt at solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次尝试解决方案
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What's wrong with the above code?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述代码有什么问题？
- en: First attempt at solution
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次尝试解决方案
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What's wrong with the above code?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述代码有什么问题？
- en: Can deadlock when simultaneously transferring money in both directions
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同时在两个方向转移资金时可能会发生死锁
- en: '[PRE4]'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Throwing an exception when not enough money is ugly... what if we just waited
    for enough money to show up before completing the transfer?
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当账户中没有足够的资金时抛出异常很丑陋...如果我们只是等待足够的资金出现然后完成转账会怎样？
- en: 'How would you fix #1?'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会如何解决＃1？
- en: Second attempt at solution
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二次尝试解决方案
- en: 'Strategy: Use non-blocking [`tryTakeMVar`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/Control-Concurrent-MVar.html#v:tryTakeMVar)
    for second `MVar`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略：对第二个`MVar`使用非阻塞[`tryTakeMVar`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/Control-Concurrent-MVar.html#v:tryTakeMVar)
- en: If it fails, release both and try again in different order
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果失败，释放两者并以不同顺序重试
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Is this gross enough for you yet?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这已经够恶心了吗？
- en: If not, make the code sleep when not enough funds are present in `from`
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有，在`from`中没有足够的资金时让代码休眠
- en: '... or fix it to handle asynchronous exceptions properly'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...或修复以正确处理异步异常'
- en: '[Software transactional memory](http://hackage.haskell.org/package/stm)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[软件事务内存](http://hackage.haskell.org/package/stm)'
- en: What if instead we used database-like transactions?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们改用类似数据库的事务呢？
- en: Read and write a bunch of variables
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入一堆变量
- en: Writes initially go to log, then get committed atomically at end
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入最初进入日志，然后在最后以原子方式提交
- en: Did you get an inconsistent view or clash with another update? No problem, just
    abort and retry the whole transaction
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否出现不一致的视图或与另一个更新冲突？没问题，只需中止并重试整个事务
- en: Would be hard to do in C or Java
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C或Java中很难做到
- en: What if you wrote to the network or file system during transaction?
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果事务期间向网络或文件系统写入会怎样？
- en: '"Externalized" actions can''t easily be rolled back'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “外部化”操作不容易回滚
- en: But in Haskell, the `IO` type (or lack thereof) can control side effects
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但在Haskell中，`IO`类型（或其缺乏）可以控制副作用
- en: Slides inspired by good write-up in [[Peyton Jones]](http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幻灯片灵感来自[[Peyton Jones]](http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf)中的优秀文章
- en: '[STM](http://hackage.haskell.org/package/stm) basics'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[STM](http://hackage.haskell.org/package/stm)基础知识'
- en: New variable type `TVar a` (kind of like an [`IORef a`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/Data-IORef.html))
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的变量类型`TVar a`（有点像[`IORef a`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/Data-IORef.html)）
- en: Module [`Control.Concurrent.TVar`](http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TVar.html)
    gives you
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块[`Control.Concurrent.TVar`](http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TVar.html)提供给你
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: New [`STM` monad](http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Monad-STM.html)
    allows `TVar` access but no irreversible side effects
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的[`STM`单子](http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Monad-STM.html)允许`TVar`访问但没有不可逆的副作用
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`atomically` lets you run `STM` computations from `IO`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atomically`让你从`IO`中运行`STM`计算'
- en: 'You get: semantics of one global lock + parallelism of fine-grained locks!'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会得到：一个全局锁的语义+细粒度锁的并行性！
- en: In exchange, you give up the ability to perform externalized `IO` actions
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为交换，你放弃了执行外部化的`IO`操作的能力
- en: STM Example
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STM示例
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note: `subtract a b = b - a`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意：`subtract a b = b - a`
- en: 'Language wart: Unlike all other binary operators, can''t make section with
    `(- a)` because that''s unary negation (i.e., `0-a`)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言瑕疵：与所有其他二元运算符不同，无法使用`(- a)`创建部分，因为那是一元否定（即`0-a`）
- en: What if you want to wait when not enough money in account?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果账户中没有足够的资金，你想等待吗？
- en: Aborting
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中止
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`retry` aborts the transaction'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry`中止事务'
- en: But `STM` knows what `TVar`s code read to detect conflicts...
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但`STM`知道`TVar`的代码读取以检测冲突...
- en: Can sleep until some `TVar` code read changes w/o explicit condition variables
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以休眠直到某些`TVar`代码读取发生变化而无需显式条件变量
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`orElse` tries second action if first one aborts (sleeps if both abort)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElse`如果第一个操作中止则尝试第二个操作（如果两个都中止则休眠）'
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Effectively provides nested transactions
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上提供了嵌套事务
- en: Enforcing invariants
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制执行不变量
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`alwaysSucceeds` adds invariant to check after every transaction'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alwaysSucceeds`在每次事务后添加不变量检查'
- en: (Either the invariant throws an exception or its return value ignored)
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （不变量抛出异常或其返回值被忽略）
- en: 'Example: say you are paranoid about negative account balances'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：假设你对负账户余额很担心
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Will catch errors immediately at end of & roll back faulty transactions
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将立即捕获错误并回滚错误事务
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Switching gears...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换话题...
- en: Let's get back to pure functional code
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们回到纯函数式代码
- en: How does the compiler represent data in memory?
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器如何在内存中表示数据？
- en: Naïve Haskell data representation
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 天真的Haskell数据表示
- en: A value requires a constructor, plus arguments
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值需要一个构造函数，加上参数
- en: At runtime, need to determine a value's constructor, but not it's type
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，需要确定值的构造函数，但不需要确定其类型
- en: (Compiler already type-checked program, so no runtime type checks)
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （编译器已经对程序进行了类型检查，因此没有运行时类型检查）
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For a type like `[Int]`, `constrno` might be 0 for `[]` and 1 for `(:)`, where
    `[]` has 0-sized `args` and `(:)` has 2-element `args`
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于像`[Int]`这样的类型，`constrno`可能为`[]`的0，`(:)`的1，其中`[]`具有0大小的`args`，`(:)`具有2个元素的`args`
- en: For a type like `Int`, `constrno` can be the actual integer, with no `args`
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于像`Int`这样的类型，`constrno`可以是实际的整数，没有`args`
- en: For a single-constructor type (e.g., `Point`) `constrno` not used
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于单构造函数类型（例如`Point`），不使用`constrno`
- en: Problems with our approach so far
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止我们的方法存在问题
- en: No way to represent exceptions or thunks
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有办法表示异常或惰性计算
- en: Garbage collector needs to know how many elements are in `args`
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器需要知道`args`中有多少元素
- en: Small values such as `Int`s always require chasing a pointer
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如`Int`之类的小值总是需要追踪指针
- en: Add level of indirection to describe values
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加间接层来描述值
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`gcInfo` says how many `Val *`s are in `args` and where they are'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcInfo`指示`args`中有多少个`Val *`以及它们的位置'
- en: '`tag == CONSTRNO` means `constrno` valid, used as on last slide'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag == CONSTRNO`表示`constrno`有效，如上一张幻灯片所示'
- en: '`tag == IND` means `args[0]` is an indirect *forwarding pointer* to another
    `Val` and union is unused; useful if size of `args` grows'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag == IND`表示`args[0]`是指向另一个`Val`的间接*转发指针*，联合体未使用；如果`args`的大小增长，则此方法很有用'
- en: Function values
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数值
- en: A `Val` whose `ValInfo` has `tag == FUNC` uses the `func` field
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`ValInfo`的`tag == FUNC`的`Val`使用`func`字段
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To apply function `f` to argument `a` (where both are type `Val *`):'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将函数`f`应用于参数`a`（其中两者都是类型为`Val *`的值）：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that `func`'s first argument (`closure`) is the function `Val` itself
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，`func`的第一个参数（`closure`）是函数`Val`本身
- en: Provides a *closure* environment so `ValInfo`/`func` can be re-used
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个*闭包*环境，以便可以重复使用`ValInfo`/`func`
- en: '`func`''s second argument (`arg`) is the argument `a` on which the function
    is being evaluated'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`的第二个参数（`arg`）是函数正在评估的参数`a`'
- en: Assume all functions take one argument
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设所有函数都只接受一个参数
- en: Logically this is fine since we have currying
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑上这是没问题的，因为我们有柯里化
- en: For performance, real compilers must optimize multi-argument case
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了性能，真正的编译器必须优化多参数情况
- en: Closures
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: Top-level bindings don't need the `closure` argument to `func`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层绑定不需要`func`的`closure`参数
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Val` for function `addOne` can have zero-length `args`
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`addOne`的`Val`可以具有零长度的`args`
- en: Local bindings may need environment values in `closure`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地绑定可能需要`closure`中的环境值
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compiler will only emit code for local function `addn` once
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器只会为本地函数`addn`生成一次代码
- en: But logically, there is a separate `addn` function (with a different `n`) for
    each invocation of `add`
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但从逻辑上讲，每次调用`add`都会有一个单独的`addn`函数（带有不同的`n`）
- en: So each `addn` instance is a different `Val`, but all share the same `ValInfo`
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，每个`addn`实例都是不同的`Val`，但都共享相同的`ValInfo`
- en: Use `args[0]` in each `Val` to specify the value of `n`
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个`Val`中使用`args[0]`来指定`n`的值
- en: Thunk values
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性计算值
- en: A `Val` with `tag == THUNK` uses the `thunk` field in `ValInfo`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有`tag == THUNK`的`Val`使用`ValInfo`中的`thunk`字段
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Updates* `v` (turns it into non-thunk) or returns a non-`NULL` `Exception
    *`'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新* `v`（将其转换为非惰性）或返回一个非`NULL`的`Exception *`'
- en: 'To evaluate a thunk:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要评估一个惰性计算：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Two big differences between thunks and functions
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性计算和函数之间有两个重要区别
- en: A function takes an argument, while a thunk does not
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数需要一个参数，而一个惰性计算不需要
- en: A function value is immutable, while a thunk updates itself
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数值是不可变的，而惰性计算会更新自身
- en: Note also that a thunk may throw an exception
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还要注意，惰性计算可能会抛出异常
- en: Functions can, too, but for simplicity let's implement it by having the function
    return a thunk that throws an exception
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数也可以，但为了简单起见，让函数返回一个会抛出异常的惰性计算
- en: Forcing
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制执行
- en: Turning a thunk into a non-thunk is known as *forcing* it
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将thunk转换为非thunk称为*强制*它
- en: What if a thunk's return value doesn't fit in thunk's `args`?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个thunk的返回值不适合thunk的`args`怎么办？
- en: This is why we have the `IND` `ValInfo` tag--Allocate new `Val`, place indirect
    forwarding pointer in old `Val`
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是为什么我们有`IND` `ValInfo`标记--分配新的`Val`，在旧的`Val`中放置间接转发指针
- en: 'A possible implementation of forcing that walks `IND` pointers:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可能的强制实现，遍历`IND`指针：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Currying
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: Let's use simple implementation of currying (GHC very complex)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们使用柯里化的简单实现（GHC非常复杂）
- en: Set `closure->args` to head of list of previously curried args
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`closure->args`设置为先前柯里化参数列表的头部
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compiler emits 3 `ValInfo`s and 3 functions for `const3`
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器发出3个`ValInfo`和3个`const3`函数
- en: Top-level binding's `ValInfo` has `func = const3_1`
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层绑定的`ValInfo`具有`func = const3_1`
- en: '`const3_1` creates `Val v1` where `arg[0]` is first argument (`a`) and `info->func
    = const3_2`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const3_1`创建`Val v1`，其中`arg[0]`是第一个参数（`a`），`info->func = const3_2`'
- en: '`const3_2` creates a `Val v2` where `arg[0]` is the second argument (`b`),
    `arg[1]` is `v1`, and `info->func` is `const3_3`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const3_2`创建一个`Val v2`，其中`arg[0]`是第二个参数（`b`），`arg[1]`是`v1`，`info->func`是`const3_3`'
- en: '`const3_3` has access to all arguments and actually implements `const3`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const3_3`可以访问所有参数，并实际实现`const3`'
- en: Shared arguments have common arg tails, only evaluated once
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享参数具有共同的参数尾部，只评估一次
- en: '[PRE25]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Code for currying example
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化示例的代码
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unboxed types
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未装箱类型
- en: Unfortunately, now `Int` has even more overhead
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，现在`Int`有更多的开销
- en: To use, must check `i->info->tag` then access `i->info->constr`
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用，必须检查`i->info->tag`，然后访问`i->info->constr`
- en: Moreover, each number needs a distinct `ValInfo` structure (but `ValInfo`s statically
    allocated--how do you know what numbers the program will need)
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，每个数字都需要一个不同的`ValInfo`结构（但`ValInfo`是静态分配的--你怎么知道程序将需要哪些数字）
- en: 'Idea: Have special *unboxed* types that don''t use `struct Val`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思路：有特殊的*未装箱*类型，不使用`struct Val`
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Unboxed types have no constructor and cannot be thunks (no `ValInfo`)
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未装箱类型没有构造函数，不能是thunk（没有`ValInfo`）
- en: Can fit in a single register or take the place of a `Val *` arg
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以适合单个寄存器或取代`Val *`参数的位置
- en: Must extend `GCInfo` to identify which args are and are not boxed
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须扩展`GCInfo`以识别哪些参数是装箱的，哪些不是
- en: Unboxed types in GHC
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GHC中的未装箱类型
- en: GHC exposes unboxed types (even though not part of Haskell)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GHC暴露了未装箱类型（尽管不是Haskell的一部分）
- en: Symbols use `#` character--must enable with [`-XMagicHash`](http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#magic-hash)
    option
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号使用`#`字符--必须使用[`-XMagicHash`](http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#magic-hash)选项启用
- en: Have unboxed types (`Int#`) and primitive operations on them (`+#`)
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有未装箱类型（`Int#`）和对它们的原始操作（`+#`）
- en: See [GHC.Prim](http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.1.0/GHC-Prim.html)
    or type "`:browse GHC.Prim`" in GHCI
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[GHC.Prim](http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.1.0/GHC-Prim.html)或在GHCI中键入"`:browse
    GHC.Prim`"
- en: Also have [unboxed constants](http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#magic-hash)--`2#`,
    `'a'#`, `2##` (unsigned), `2.0##`
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也有[未装箱常量](http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#magic-hash)--`2#`,
    `'a'#`, `2##`（无符号），`2.0##`
- en: What is `Int` really?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`到底是什么？'
- en: Single-constructor data type, with a single, unboxed argument
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单构造函数数据类型，带有单个未装箱参数
- en: '[PRE29]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Lets `Int` contain thunk, but avoids pointer dereference once evaluated
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让`Int`包含thunk，但一旦评估就避免指针解引用
- en: Restrictions on unboxed types
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未装箱类型的限制
- en: Cannot instantiate type variables with unboxed types
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能用未装箱类型实例化类型变量
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Enforced by making unboxed types a different kind of type
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使未装箱类型成为不同种类的类型来强制执行
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Recall type variables have kinds with stars (∗, ∗ → ∗, etc.), never `#`
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住类型变量的种类是星号（∗，∗ → ∗等），而不是`#`
- en: Polymorphism works because all types of kind ∗ represented as `Val *`
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性有效，因为所有种类为∗的类型都表示为`Val *`
- en: '`seq` revisited'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视`seq`
- en: 'Recall `seq :: a -> b -> b`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '回想一下`seq :: a -> b -> b`'
- en: If `seq a b` is forced, then first `a` is forced, then `b` is forced and returned
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果强制`seq a b`，那么首先强制`a`，然后强制并返回`b`
- en: 'Consider the following code (similar to concurrency lecture):'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下代码（类似于并发讲座）：
- en: '[PRE32]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`seqTest1` hangs forever, while `seqTest2` happily returns 6'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seqTest1`永远挂起，而`seqTest2`愉快地返回6'
- en: '`seq` only forces a `Val`, not the `arg` fields of the `Val`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seq`只强制`Val`，而不是`Val`的`arg`字段'
- en: '`seqTest2`''s `seq` forces `str`''s constructor `(:)`, but not the head or
    tail'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seqTest2`的`seq`强制`str`的构造函数`(:)`，但不强制头部或尾部'
- en: This is known as putting `str` in *Weak Head Normal Form* (WHNF)
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这被称为将`str`放入*弱头正规形式*（WHNF）
- en: Can't fully evaluate an arbitrary data type (but see [Control.DeepSeq](http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/Control-DeepSeq.html))
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法完全评估任意数据类型（但参见[Control.DeepSeq](http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/Control-DeepSeq.html)）
- en: 'Example: hypothetical `seq` implementation'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子：假设的`seq`实现
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Strictness revisited
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视严格性
- en: Recall strictness flag on fields in data declarations
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾数据声明中字段的严格性标志
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Int` has `!` before it, meaning it must be strict'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`之前有`!`，表示它必须是严格的'
- en: Strict means the `Int`'s `ValInfo` cannot have `tag` `THUNK` or `IND`
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格意味着`Int`的`ValInfo`不能有`tag` `THUNK`或`IND`
- en: Accessing a strict `Int` touches only one cache line
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问严格的`Int`只会触及一个缓存行
- en: Recall `data Int = I# Int#` has only one constructor
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾`data Int = I# Int#`只有一个构造函数
- en: Plus strict flag means `tag == CONSTRNO`, so know what's in `ValInfo`
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加上严格标志意味着`tag == CONSTRNO`，所以知道`ValInfo`中有什么
- en: Plus `Int#` is unboxed
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外`Int#`是非装箱的
- en: Thus, once `IntWrapper` forced, immediately safe to access `Int` as
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，一旦`IntWrapper`被强制，立即可以安全地访问`Int`
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Semantic effects of strictness
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格性的语义效果
- en: Strictness is primarily used for optimization
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格性主要用于优化
- en: To avoid building up long chains of thunks
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免建立长链的thunks
- en: To save overhead of checking whether thunk evaluated
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了节省检查thunk是否已评估的开销
- en: 'But has semantic effects: A non-strict `Int` is not just a number'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但具有语义效果：非严格的`Int`不仅仅是一个数字
- en: Can also throw an exception or loop forever when evaluated
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以在评估时抛出异常或永远循环
- en: Such behavior can be modeled as a special value ⊥ ("bottom")
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种行为可以被建模为一个特殊值 ⊥（"底部"）
- en: So the values of `Int` are {0, 1}^(64) ∪ {⊥}
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，`Int`的值为{0, 1}^(64) ∪ {⊥}
- en: Types that include value ⊥ are called *lifted*
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含值 ⊥ 的类型称为*lifted*
- en: 'Note 1: an unboxed type is necessarily unlifted'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意1：非装箱类型必然是非lifted的
- en: 'Note 2: `!Int` not a first-class type, only valid for `data` fields'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意2：`!Int`不是一种一流类型，只对`data`字段有效
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`case` statements revisited'
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视`case`语句
- en: '`case` statement pattern matching can force thunks'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case`语句模式匹配可以强制thunks'
- en: An *irrefutable* pattern is one that always matches
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*不可辩驳*的模式总是匹配的
- en: A pattern consisting of a single variable or `_` is irrefutable
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由单个变量或`_`组成的模式是不可辩驳的
- en: Any non-irrefutable pattern forces evaluation of the argument
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何非不可辩驳的模式都会强制评估参数
- en: Matching happens top-to-bottom, and left-to-right within alternatives
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配从上到下进行，而在备选方案内从左到右进行
- en: Function pattern matching is the same as (desuggared into) `case`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数模式匹配与`case`相同
- en: 'Recall `undefined :: a` is `Prelude` symbol with value ⊥'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '回想`undefined :: a`是一个值为 ⊥ 的`Prelude`符号'
- en: '[PRE37]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Adding `~` before a pattern makes it irrefutable
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模式之前加上`~`使其不可辩驳
- en: '[PRE38]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`newtype` declarations'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`newtype`声明'
- en: We've seen two ways to introduce new types
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经看到了引入新类型的两种方式
- en: '`data` -- creates a new (boxed) type, adding overhead of a `Val` wrapper'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` -- 创建一个新的（装箱的）类型，增加了`Val`包装器的开销'
- en: '`type` -- creates an alias for an existing type, with no overhead'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type` -- 为现有类型创建一个别名，没有额外开销'
- en: Sometimes you want a new type implemented by an existing type
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时你想要一个由现有类型实现的新类型
- en: E.g., might want `Meters`, `Seconds`, `Grams`, all implemented by `Double`
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，可能希望`Meters`、`Seconds`、`Grams`都由`Double`实现
- en: Using `type` would make them all synonymous, facilitating errors
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`type`会使它们变得同义，容易出错
- en: Might want different instances of `Show` for each, impossible with `type`
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能希望为每个实例使用不同的`Show`，这在`type`中是不可能的
- en: Could say `data Meters = Meters Double` -- but will add overhead
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以说`data Meters = Meters Double` -- 但会增加开销
- en: The `newtype` keyword introduces new type with no overhead
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newtype`关键字引入了没有额外开销的新类型'
- en: Use just like `data`, but limited to one constructor and one field
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方式与`data`相同，但限于一个构造函数和一个字段
- en: This is possible because all type-checking is compile-time
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是因为所有类型检查都是在编译时进行的
- en: '`newtype` semantics'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`newtype`语义'
- en: What's the semantic difference between these two declarations?
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个声明之间的语义差异是什��？
- en: '[PRE39]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Exercise: Suppose you have'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习：假设你有
- en: '[PRE41]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Write code that behaves differently for `uNTInt` vs. `uSInt`
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写代码，使`uNTInt`与`uSInt`的行为不同
- en: '`newtype` semantics'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`newtype`语义'
- en: What's the semantic difference between these two declarations?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个声明之间的语义差异是什么？
- en: '[PRE42]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `NTInt` constructor is a "fake" compile-time-only construct
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NTInt`构造函数是一个"虚假"的仅在编译时存在的构造'
- en: A case statement deconstructing a `newtype` compiles to nothing
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构`newtype`的`case`语句编译成空
- en: '[PRE44]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Conversely, forcing a value (by matching constructor) forces strict fields
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，强制一个值（通过匹配构造函数）会强制严格字段
- en: '[PRE45]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The [`UNPACK`](http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#unpack-pragma)
    pragma
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`UNPACK`](http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#unpack-pragma)指令'
- en: '`newtype` almost always better than `data` when it applies'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当适用时，`newtype`几乎总是比`data`更好
- en: What about a multi-field data type?
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多字段数据类型怎么办？
- en: '[PRE46]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Fields are strict, we know they'll have `CONSTRNO` `ValInfo`
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段是严格的，我们知道它们将具有`CONSTRNO` `ValInfo`
- en: Why not stick the `Int#`s directly into the `args` of a `TwoInts` `Val`?
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么不直接将`Int#`直接放入`TwoInts` `Val`的`args`中？
- en: GHC provides an `UNPACK` pragma to do just this
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GHC提供了一个`UNPACK`指令来做到这一点
- en: '[PRE47]'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Works for any strict field with a single-constructor datatype
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于任何具有单构造器数据类型的严格字段
- en: Unlike `newtype`, `UNPACK` is not always a win
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`newtype`不同，`UNPACK`并不总是胜出
- en: If you pass field as argument, will need to re-box it
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将字段作为参数传递，将需要重新装箱它
- en: '`-funbox-strict-fields` flag unpacks *all* strict fields'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-funbox-strict-fields`标志展开*所有*严格字段'
- en: '[`ByteString`s](http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.4.0/index.html)'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`ByteString`](http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.4.0/index.html)'
- en: Haskell `String`s obviously not very efficient
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell `String`显然不是很高效
- en: Strict `ByteString`s efficiently manipulate raw bytes
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格`ByteString`可以高效地操作原始字节
- en: '[PRE48]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implements a similar interface to lists: `S.head`, `S.tail`, `S.length`, `S.foldl`,
    `S.cons` (like `:`), `S.empty` (like `[]`), `S.hPut` (like `hPutStr`), `S.readFile`'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了类似于列表的接口：`S.head`、`S.tail`、`S.length`、`S.foldl`、`S.cons`（类似于`:`）、`S.empty`（类似于`[]`）、`S.hPut`（类似于`hPutStr`）、`S.readFile`
- en: Must import qualified to avoid name clashes
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须导入限定以避免名称冲突
- en: '`S.pack` and `S.unpack` translate to/from `[Word8]`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S.pack`和`S.unpack`转换为/从`[Word8]`'
- en: '`S8` has same functions as `S`, but uses `Char` instead of `Word8`--means you
    lose upper bits of `Char` (use [`toString`](http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html#v:toString)
    from [utf8-string](http://hackage.haskell.org/package/utf8-string) to avoid loss)'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S8`具有与`S`相同的函数，但使用`Char`而不是`Word8`--这意味着您会丢失`Char`的高位（使用来自[utf8-string](http://hackage.haskell.org/package/utf8-string)的[`toString`](http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html#v:toString)来避免丢失）'
- en: Implementation
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现
- en: '[PRE49]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Lazy `ByteString`s](http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.4.0/Data-ByteString-Lazy.html)'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[惰性`ByteString`](http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.4.0/Data-ByteString-Lazy.html)'
- en: Same package implements [*lazy* `ByteString`s](http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.4.0/Data-ByteString-Lazy.html)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一软件包实现了[*惰性* `ByteString`](http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.4.0/Data-ByteString-Lazy.html)
- en: '[PRE50]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Provides mostly the same functions as strict `ByteString` modules
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了与严格`ByteString`模块大部分相同的函数
- en: Confusing that both modules use same names for many things
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人困惑的是两个模块对许多事物使用相同的名称
- en: Important to look at import qualifications to understand code
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看导入限定以理解代码是很重要的
- en: 'Worse: documentation does not qualify symbol names'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更糟糕的是：文档没有限定符号名称
- en: 'Tip: **hover your mouse over symbol and look at URL to figure out module**'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示：**将鼠标悬停在符号上并查看URL以找出模块**
- en: Also, `S.ByteString` and `S8.ByteString` are the same type (re-exported), and
    similarly for `L.ByteString` and `L8.ByteString`
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`S.ByteString`和`S8.ByteString`是相同类型（重新导出的），类似地，`L.ByteString`和`L8.ByteString`也是如此
- en: '`S.ByteString` and `L.ByteString` *not* same type, but can convert:'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S.ByteString`和`L.ByteString` *不*是相同类型，但可以转换：'
- en: '[PRE51]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Lazy `ByteString` implementation
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性`ByteString`实现
- en: Lazy `ByteString`s are implemented in terms of strict ones
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性`ByteString`是以严格的方式实现的
- en: '[PRE52]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Invariant: `Chunk`''s first argument (`S.ByteString`) never `null`'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变性：`Chunk`的第一个参数（`S.ByteString`）永远不会为`null`
- en: Basically a linked list of strict `ByteString`s
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本上是严格`ByteString`的链表
- en: Head is strict, tail is not, allowing lazy computation or I/O
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Head是严格的，tail不是，允许惰性计算或I/O
- en: When to use strict/lazy `ByteString`s?
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用严格/惰性`ByteString`？
- en: Obviously use lazy when you need laziness (e.g., lazy I/O, infinite or cyclical
    strings, etc.)
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要惰性时显然使用惰性（例如，惰性I/O，无限或循环字符串等）
- en: Lazy also much faster at concatenation (need to build a new list of `S.ByteString`s,
    but not copy the data they contain)
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性也在连接方面更快（需要构建一个新的`S.ByteString`列表，但不复制它们包含的数据）
- en: Strict makes it much easier to implement things like string search
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格使得实现诸如字符串搜索之类的功能变得更加容易
- en: Converting strict to lazy `ByteString`s is cheap, reverse is not (so if a library
    can work efficiently on lazy `ByteString`s, good to expose that functionality)
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将严格转换为惰性`ByteString`是廉价的，反之则不是（因此，如果一个库可以在惰性`ByteString`上高效工作，最好暴露该功能）
