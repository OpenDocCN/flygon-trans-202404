["```\n # Lab 12 RNN\nimport sys\nimport torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\n\ntorch.manual_seed(777)  # reproducibility\n#            0    1    2    3    4\nidx2char = ['h', 'i', 'e', 'l', 'o']\n\n# Teach hihell -> ihello\nx_data = [0, 1, 0, 2, 3, 3]   # hihell\none_hot_lookup = [[1, 0, 0, 0, 0],  # 0\n                  [0, 1, 0, 0, 0],  # 1\n                  [0, 0, 1, 0, 0],  # 2\n                  [0, 0, 0, 1, 0],  # 3\n                  [0, 0, 0, 0, 1]]  # 4\n\ny_data = [1, 0, 2, 3, 3, 4]    # ihello\nx_one_hot = [one_hot_lookup[x] for x in x_data]\n\n# As we have one batch of samples, we will change them to variables only once\ninputs = Variable(torch.Tensor(x_one_hot))\nlabels = Variable(torch.LongTensor(y_data))\n\nnum_classes = 5\ninput_size = 5  # one-hot size\nhidden_size = 5  # output from the RNN. 5 to directly predict one-hot\nbatch_size = 1   # one sentence\nsequence_length = 1  # One by one\nnum_layers = 1  # one-layer rnn\n\nclass Model(nn.Module):\n\n    def __init__(self):\n        super(Model, self).__init__()\n        self.rnn = nn.RNN(input_size=input_size,\n                          hidden_size=hidden_size, batch_first=True)\n\n    def forward(self, hidden, x):\n        # Reshape input (batch first)\n        x = x.view(batch_size, sequence_length, input_size)\n\n        # Propagate input through RNN\n        # Input: (batch, seq_len, input_size)\n        # hidden: (num_layers * num_directions, batch, hidden_size)\n        out, hidden = self.rnn(x, hidden)\n        return hidden, out.view(-1, num_classes)\n\n    def init_hidden(self):\n        # Initialize hidden and cell states\n        # (num_layers * num_directions, batch, hidden_size)\n        return Variable(torch.zeros(num_layers, batch_size, hidden_size))\n\n# Instantiate RNN model\nmodel = Model()\nprint(model)\n\n# Set loss and optimizer function\n# CrossEntropyLoss = LogSoftmax + NLLLoss\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n# Train the model\nfor epoch in range(100):\n    optimizer.zero_grad()\n    loss = 0\n    hidden = model.init_hidden()\n\n    sys.stdout.write(\"predicted string: \")\n    for input, label in zip(inputs, labels):\n        # print(input.size(), label.size())\n        hidden, output = model(hidden, input)\n        val, idx = output.max(1)\n        sys.stdout.write(idx2char[idx.data[0]])\n        loss += criterion(output, label)\n\n    print(\", epoch: %d, loss: %1.3f\" % (epoch + 1, loss.data[0]))\n\n    loss.backward()\n    optimizer.step()\n\nprint(\"Learning finished!\") \n```"]