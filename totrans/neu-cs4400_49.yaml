- en: Lambda Calculus — SchlacTuesday, February 14th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PLAI §22](plai.pdf#chapter.22 "Shrinking the Language") (we do much more)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We know that many constructs that are usually thought of as primitives are not
    really needed — we can implement them ourselves given enough tools. The question
    is how far can we go?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer: as far as we want. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We begin with a very minimal language, which is based on the Lambda Calculus.
    In this language we get a very minimal set of constructs and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In DrRacket, this we will use the Schlac language level (stands for “~~Scheme~~Racket
    as Lambda Calculus”). This language has a Racket-like syntax, but don’t be confused
    — it is *very* different from Racket. The only constructs that are available in
    this language are: lambda expressions of at least one argument, function application
    (again, at least one argument), and simple definition forms which are similar
    to the ones in the “Broken define” language — definitions are used as shorthand,
    and cannot be used for recursive function definition. They’re also only allowed
    at the toplevel — no local helpers, and a definition is not an expression that
    can appear anywhere. The BNF is therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since this language has no primitive values (other than functions), Racket numbers
    and booleans are also considered identifiers, and have no built-in value that
    come with the language. In addition, all functions and function calls are curried,
    so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: is actually shorthand for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The rules for evaluation are simple, there is one very important rule for evaluation
    which is called “beta reduction”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: where substitution in this context requires being careful so you won’t capture
    names. This requires you to be able to do another kind of transformation which
    is called “alpha conversion”, which basically says that you can rename identifiers
    as long as you keep the same binding structure (eg, a valid renaming does not
    change the de-Bruijn form of the expression). There is one more rule that can
    be used, *eta conversion* which says that `(lambda (x) (f x))` is the same as
    `f` (we used this rule above when deriving the Y combinator).
  prefs: []
  type: TYPE_NORMAL
- en: One last difference between Schlac and Racket is that Schlac is a *lazy* language.
    This will be important since we do not have any built-in special forms like `if`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Schlac definition for the identity function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and there is not much that we can do with this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: (In the last expression, note that `(id id id)` is shorthand for `((id id) id)`,
    and since `(id id)` is the identity, applying that on `id` returns it again.)
  prefs: []
  type: TYPE_NORMAL
