- en: 'Recursion: Racket’s `letrec`Tuesday, February 21st'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So we want to add recursion to our language, practically. We already know that
    Racket makes it possible to write recursive functions, which is possible because
    of the way it implements its “global environment”: our evaluator can only *extend*
    an environment, while Racket *modifies* its global environment. This means that
    whenever a function is defined in the global environment, the resulting closure
    will have it as its environment “pointer”, but the global environment was not
    extended — it stays the same, and was just modified with one additional binding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But Racket has another, a bit more organized way of using recursion: there
    is a special local-binding construct that is similar to `let`, but allows a function
    to refer to itself. It is called `letrec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Some people may remember that there was a third way for creating recursive
    functions: using local definition in function bodies. For example, we have seen
    things like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like the same kind of environment magic that happens with a global
    `define` — but actually, Racket defines the meaning of internal definitions using
    `letrec` — so the above code is exactly the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The scoping rules for a `letrec` is that the scope of the bound name covers
    both the body *and* the named expression. Furthermore, multiple names can be bound
    to multiple expressions, and the scope of each name covers all named expression
    as well as the body. This makes it easy to define mutually recursive functions,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is not a required functionality — it could be done with a single recursive
    binding that contains several functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is basically the same problem we face if we want to use the Y combinator
    for mutually recursive bindings. The above solution is inconvenient, but it can
    be improved using more `let`s to have easier name access. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
