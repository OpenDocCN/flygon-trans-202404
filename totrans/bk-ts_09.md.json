["```\nclass Bus {\n\n    private myRouteNumber: number;\n    public SeatingCapacity: number; \n\n    private myRunCost: number;\n\n    constructor(routeNumber: number) {\n        this.myRouteNumber = routeNumber;\n\n        // Next line is allowed - objects may invoke their own private functions\n        this.myRunCost = this.calculateRunCost(30, 1.95); \n    }\n\n    public SayRoute() {\n        console.log(`My route is ${this.myRouteNumber}`);\n    }\n\n    private calculateRunCost(forDistance: number, fuelCostPerMile: number): number {\n        // Logic goes here to calculate cost for this bus to run this route.\n        // This function is invisible to client objects.\n    }\n\n}\n\nconst myBus = new Bus(999);\nmyBus.SeatingCapacity = 80;\n\n// Edit-time error since \"calculateRunCost\" is private\nconsole.log(myBus.calculateRunCost(30, 1.95)); \n```", "```\nclass Bus3 {\n\n    private myRouteNumber: number;\n    public SeatingCapacity: number; \n\n    private myRunCost: number;\n\n    constructor(routeNumber: number) {\n        this.myRouteNumber = routeNumber;\n        this.myRunCost = this.calculateRunCost(30, 1.95); // Allowed - objects may invoke their own private functions\n    }\n\n    public SayRoute() {\n        console.log(`My route is ${this.myRouteNumber}`);\n    }\n\n    private calculateRunCost(forDistance: number, fuelCostPerMile: number): number {\n        // Logic goes here to calculate cost for this bus to run this route.\n        // This function is invisible to client objects.\n        return 0; // Method signature requires us to return some numeric value to avoid syntax error.\n    }\n\n}\n\nconst myBus3: Bus3 = new Bus3(999);\nmyBus3.SeatingCapacity = 80;\nmyBus3.SayRoute();\nmyBus3[\"myRunCost\"] = 999; // Use bracket access to change the value of the \"private\" class property, myRunCost \n```", "```\nvar Bus3 = (function () {\n    function Bus3(routeNumber) {\n        this.myRouteNumber = routeNumber;\n        this.myRunCost = this.calculateRunCost(30, 1.95); // Allowed - objects may invoke their own private functions\n    }\n    Bus3.prototype.SayRoute = function () {\n        console.log(\"My route is \" + this.myRouteNumber);\n    };\n    Bus3.prototype.calculateRunCost = function (forDistance, fuelCostPerMile) {\n        // Logic goes here to calculate cost for this bus to run this route.\n        // This function is invisible to client objects.\n        return 0; // Method signature requires us to return some numeric value to avoid syntax error.\n    };\n    return Bus3;\n}());\nvar myBus3 = new Bus3(999);\nmyBus3.SeatingCapacity = 80;\nmyBus3.SayRoute();\nmyBus3[\"myRunCost\"] = 999; \n```", "```\nclass Bus4 {\n\n    private _mySeatingCapacity: number;\n\n    public set SeatingCapacity(val: number) { this._mySeatingCapacity = val;}\n    public get SeatingCapacity() { return this._mySeatingCapacity;}\n\n    constructor() {\n    }\n}\n\nconst theBus: Bus4 = new Bus4();\ntheBus.SeatingCapacity = 80;\n\nconsole.log(\"Seating capacity:\", theBus.SeatingCapacity); \n```", "```\nvar Bus4 = (function () {\n    function Bus4() {\n    }\n    Object.defineProperty(Bus4.prototype, \"SeatingCapacity\", {\n        get: function () { return this._mySeatingCapacity; },\n        set: function (val) { this._mySeatingCapacity = val; },\n        enumerable: true,\n        configurable: true\n    });\n    return Bus4;\n}());\nvar theBus = new Bus4();\ntheBus.SeatingCapacity = 80;\nconsole.log(\"Seating capacity:\", theBus.SeatingCapacity); \n```", "```\nclass Bus5 {\n\n    private _myTotalPassengers: number;\n    private _myCostPerMile: number;\n    private _myTotalRouteDistance: number;\n\n    private _myRouteNumber: number;\n    public get myRouteNumber() { return this.myRouteNumber; }\n\n    private _mySeatingCapacity: number;\n    public set SeatingCapacity(val: number) { this._mySeatingCapacity = val; } \n\n    public get CostPerRider() {\n        const totalRouteCost = this._myTotalRouteDistance * this._myCostPerMile;\n        const costPerRider = totalRouteCost / this._myTotalPassengers;\n        return costPerRider;\n    }\n\n    constructor(routeNumber, costPerMile, totalPassengers, routeDistance) {\n        this._myRouteNumber = routeNumber;\n        this._myCostPerMile = costPerMile;\n        this._myTotalPassengers =  totalPassengers;\n        this._myTotalRouteDistance = routeDistance;\n    }\n}\n\nconst myBus5: Bus5 = new Bus5(148, 12.50, 72, 80);\nmyBus5.SeatingCapacity = 80;\n\nconsole.log(\"My total cost per rider:\", myBus5.CostPerRider)\nconsole.log(\"Cost per rider with 80 riders: \", new Bus5(148, 12.50, 80, 50).CostPerRider) \n```", "```\nconst myBus5: Bus5 = new Bus5(148, 12.50, 72, 80); \n```", "```\nconst myBus5: Bus5 = new Bus5();\nmyBus5.RouteNumber = 148;\nmyBus5.CostPerMile = 12.50;\nmyBus5.TotalPassengers = 72;\nmyBus5.RouteDistance = 55; \n```", "```\ninterface Bus6Args {\n    routeNumber: number;\n    routeDistance: number;\n    costPerMile: number;\n    totalPassengers: number;\n}\n\nclass Bus6 {\n    private _myTotalPassengers: number;\n    private _myCostPerMile: number;\n    private _myTotalRouteDistance: number;\n\n    private _myRouteNumber: number;\n    public get myRouteNumber() { return this.myRouteNumber; }\n\n    private _mySeatingCapacity: number;\n    public set SeatingCapacity(val: number) { this._mySeatingCapacity = val; } \n\n    public get CostPerRider() {\n        const totalRouteCost = this._myTotalRouteDistance * this._myCostPerMile;\n        const costPerRider = totalRouteCost / this._myTotalPassengers;\n        return costPerRider;\n    }\n\n    constructor(args: Bus6Args) {\n        this._myRouteNumber = args.routeNumber;\n        this._myCostPerMile = args.costPerMile;\n        this._myTotalPassengers =  args.totalPassengers;\n        this._myTotalRouteDistance = args.routeDistance;\n    }\n}\n\nconst myBus6: Bus6 = new Bus6(\n        {routeDistance: 44,\n         costPerMile: 12.50,\n         routeNumber: 148, \n         totalPassengers: 72});\n\nmyBus6.SeatingCapacity = 80;\n\nconsole.log(\"My total cost per rider:\", myBus6.CostPerRider)\nconsole.log(\"Cost per rider with 80 riders: \", \n    new Bus6({routeDistance: 44, routeNumber: 148, costPerMile: 12.50, totalPassengers: 80})\n    .CostPerRider) \n```", "```\nconst myBus6: Bus6 = new Bus6(\n    {routeDistance: 44,\n     costPerMile: 12.50, \n     routeNumber: 148, \n     totalPassengers: 72}); \n```", "```\nvar myBus6 = new Bus6(44, 12.5, 148, 72); \n```", "```\nclass Shirt {\n    public color: string;\n    public fabricType: string;\n    public price: number;\n    public cut: string;\n    constructor() { }\n}\n\nclass Shoe {\n    public color: string;\n    public size: string;\n    public price: number;\n    constructor() {}\n}\n\nclass Pants {\n    public color: string;\n    public inseam: number;\n    public waist: number;\n    public price: number;\n    constructor();\n} \n```", "```\nconst allProducts: any[] = [].concat(\n    new Shirt(), \n    new Shirt(), \n    new Pants(), \n    new Shoe(), \n    new Pants(), \n    new Shirt());\n\nconst Recommend = function(minPrice, maxPrice, requestedColor) {\n    return allProducts.reduce(function(prev, curr) {\n        if ((curr[\"color\"] === requestedColor) ||\n            (curr[\"price\"] >= minPrice && curr[\"price\"] <= maxPrice)) {\n                return prev.concat(curr);\n            }\n    }, []);\n}\n\nconsole.log(\"Recommended for min/max price of 10/20 and color = blue:\", \n    Recommend(10, 20, \"blue\")); \n```", "```\nclass Scarf {\n    public Color: string;\n    public price: number;\n    public length: number;\n    constructor();\n} \n```", "```\ninterface IRecommendable {\n    color: string;\n    price: number;\n} \n```", "```\ninterface IRecommendable {\n    color: string;\n    price: number;\n}\n\nclass Scarf implements IRecommendable{\n    public color: string;\n    public fabricType: string;\n    public price: number;\n    public length: string;\n    constructor() { }\n} \n```", "```\ninterface IRecommendable {\n    color: string;\n    price: number;\n}\n\nclass Scarf implements IRecommendable{\n    public color: string;\n    public fabricType: string;\n    public price: number;\n    public length: string;\n    constructor() { }\n}\n\n// Product Displays can't be recommended so doesn't implement the interface.\nclass ProductDisplay {\n    public name: string;\n    public location: string;\n    constructor() {}\n}\n\nclass Sneaker implements IRecommendable {\n    public color: string;\n    public inseam: number;\n    public waist: number;\n    public price: number;\n}\n\nconst allRecommendableProducts: IRecommendable[] = \n    [].concat(\n        new Sneaker(), \n        new Sneaker(), \n        new Scarf(), \n        new Sneaker(), \n        new Sneaker(), \n        new Scarf());\n\nconst GetRecommended = function(minPrice, maxPrice, requestedColor) {\n\n    return <IRecommendable> allProducts.reduce(\n        function(prev: IRecommendable[], curr: IRecommendable) {\n            if ((curr.color === requestedColor) ||\n                (curr.price <= maxPrice && curr.price <= maxPrice)) {\n                    return prev.concat(curr);\n                }\n        }, []);\n}\n\nconst RecommendedItems = GetRecommended(10, 20, \"blue\");\n\nconsole.log(\"Recommended for min/max price of 10/20 and color = blue:\", Recommend(10, 20, \"blue\")); \n```", "```\ninterface StandardProduct {\n    name: string;\n    description: string;\n}\n\ninterface SecuredFieldsItem {\n    GetAllowedFieldNames: (requestedByRole: string) => string[]; \n    // NOTE: requestedBy would normally be a more complex object.\n}\n\nclass Fidget implements StandardProduct, SecuredFieldsItem {\n\n    public name: string;\n    public description: string;\n    public inventory: number;\n    public weight: number;\n    public recommendedAge: number;\n    public cost: number;\n\n    constructor() {};\n\n    public GetAllowedFieldNames(requestedByRole: string) : string[] {\n        const minFields = [\"name\", \"weight\", \"recommendedAge\", \"description\", \"inventory\"];\n        if (requestedByRole === \"Price Admin\") {\n            return minFields.concat(\"cost\");\n        }\n        return minFields;\n    }\n}\n\nclass HotItem implements StandardProduct, SecuredFieldsItem {\n    public name: string;\n    public description: string;\n    public features: string[];\n    public inventory: number;\n    public cost: number;\n\n    constructor() {};\n\n    public GetAllowedFieldNames(requestedByRole: string) : string[] {\n        const minFields = [\"name\", \"description\", \"features\"];\n        let allFields = minFields;\n        if (requestedByRole === \"Price Admin\") {\n             allFields = allFields.concat(\"cost\");\n        }\n        if (requestedByRole === \"Inventory Admin\") {\n             allFields = allFields.concat(\"inventory\");\n        }\n        return allFields;\n    }\n}\n\nfunction getGeneratedCsv(forProducts: SecuredFieldsItem[], forRoleLabel: string) {\n    return forProducts.reduce( (prev: string[], curr: SecuredFieldsItem) => {\n        const result = getFormattedCsvRow (curr, curr.GetAllowedFieldNames(forRoleLabel));\n        return prev.concat(result);\n    }, []);\n\n}\n\nfunction getFormattedCsvRow(sourceItem: SecuredFieldsItem, fieldsToRetrieve: string[]): string {\n    return fieldsToRetrieve.reduce( (csvFieldAsBuilt: string, currentField: string) => {\n        if (csvFieldAsBuilt.length < 1) {\n            return sourceItem[currentField];\n        }\n        return csvFieldAsBuilt + \",\" + sourceItem[currentField];\n    }, \"\");\n}\n\n// Pretend that these products are initialized with real data.\nconst allSecurableProducts = [].concat(\n    new HotItem(), \n    new Fidget(), \n    new Fidget(), \n    new HotItem());\n\nconst csvOutput = getGeneratedCsv(allProducts, \"Inventory Admin\"); \n```", "```\ninterface SecuredFieldsItem {\n    GetAllowedFieldNames: (requestedByRole: string) => string[]; \n    // NOTE: requestedBy would normally be a more complex object.\n} \n```", "```\n Resident \n                 |\n    -----------------------------\n    |                           |\n    v                           v \n```", "```\nclass Resident {\n\n    private _name: string;\n    public get MyName() { return this._name; }\n\n    constructor(name: string) {\n        this._name = name;\n    }\n} \n```", "```\nconst Kelly = new Resident(\"Kelly\"); \n```", "```\nconsole.log(`Resident's name: ${Kelly.MyName}.`); \n```", "```\nclass TemporaryResident extends Resident {\n    private _countryOfOrigin: string;\n    public get MyCountryOfOrigin() { return this._countryOfOrigin; }\n\n    private _requiredExitDate: Date;\n\n    constructor(name: string, countryOfOrigin: string, requiredExitDate: Date) {\n        super(name);\n        this._countryOfOrigin = countryOfOrigin;\n        this._requiredExitDate = requiredExitDate;\n    }\n\n} \n```", "```\nclass TemporaryResident extends Resident { \n```", "```\n constructor(name: string, countryOfOrigin: string, requiredExitDate: Date) {\n        super(name);\n        this._countryOfOrigin = countryOfOrigin;\n        this._requiredExitDate = requiredExitDate;\n    } \n```", "```\nclass USCitizen extends Resident {\n\n    private _cityOfBirth: string;\n    public get MyBirthCity() { return this._cityOfBirth; }\n\n    constructor(name: string, birthCity: string) {\n        super(name);\n\n        this._cityOfBirth = birthCity;\n    }\n} \n```", "```\nclass BaseClass {\n    private _myPrivateProperty: string = \"No one can see me except BaseClass.\";\n    protected _myProtectedProperty: string = \"Extended classes can see me.\";\n    public MyPublicProperty: string = \"Anyone can see and manipulate me.\";\n}\n\nclass ExtendedBaseClass extends BaseClass {\n\n    constructor() {\n        super();\n\n        // Next line would be an error since myPrivateProperty is private in BaseClass\n        //this._myPrivateProperty = \"xyzzy\";\n\n        // ExtendedBaseClass can access _myProtectedProperty.\n        this._myProtectedProperty = \"I can change this value.\";\n\n        // Public property values can always be accessed within and outside of the class.\n        this.MyPublicProperty = \"I can also change this value.\";\n    }\n}\n\nconst myExtendedClass = new ExtendedBaseClass();\nmyExtendedClass.MyPublicProperty = \"Set directly on the class via client code.\";\n\n// Error:\n// myExtendedClass._myPrivateProperty = \n//      \"This is not allowed since private properties cannot be read or written.\";\n\n// Error:\n// myExtendedClass._myProtectedProperty = \n//      \"This is also not allowed since it's protected.\"; \n```", "```\ninterface Activatable {\n    ActivateSelf: () => void;\n}\n\nclass NaiveBase {\n    private _myName: string;\n    public get Name() { return this._myName; }\n    constructor (name: string) {\n        this._myName = name;\n    }\n}\n\nclass NaiveArmyBase extends NaiveBase implements Activatable{\n    private _totalSolders: number;\n    public get TotalSolders() { return this._totalSolders; }\n\n    constructor(name: string, totalSolders: number) {\n        super(name);\n        this._totalSolders = totalSolders;\n    }\n\n    public ActivateSelf() {\n        throw \"Not yet implemented\";\n    }\n}\n\nclass NaiveNavyBase extends NaiveBase implements Activatable {\n    private _totalShips: number;\n    public get TotalShips() { return this._totalShips; }\n\n    constructor(name: string, totalShips: number) {\n        super(name);\n        this._totalShips = totalShips;\n    }\n\n    public ActivateSelf() {\n        throw \"Not yet implemented\";\n    }\n}\n\nconst naiveArmyBase = new NaiveArmyBase(\"First army base\", 100);\nconst naiveNavyBase = new NaiveNavyBase(\"First navy base\", 3);\n\n// This is allowed but makes no sense:\nconst someOtherBase = new NaiveBase(\"what kind of base is this?\"); \n```", "```\ninterface Activatable {\n    ActivateSelf: () => void;\n}\n\nabstract class AbstractBase implements Activatable{\n    private _myName: string;\n    public get Name() { return this._myName; }\n\n    constructor (name: string) {\n        this._myName = name;\n    }\n\n    abstract ActivateSelf(): void;\n}\n\nclass ArmyBase extends AbstractBase {\n    private _totalSolders: number;\n    public get TotalSolders() { return this._totalSolders; }\n\n    constructor(name: string, totalSolders: number) {\n        super(name);\n        this._totalSolders = totalSolders;\n    }\n\n    public ActivateSelf() {\n        throw \"Not yet implemented\";\n    }\n}\n\nclass NavyBase extends AbstractBase {\n    private _totalShips: number;\n    public get TotalShips() { return this._totalShips; }\n\n    constructor(name: string, totalShips: number) {\n        super(name);\n        this._totalShips = totalShips;\n    }\n\n    public ActivateSelf() {\n        throw \"Not yet implemented\";\n    }\n}\n\nconst armyBase = new ArmyBase(\"First army base\", 100);\nconst navyBase = new NavyBase(\"First navy base\", 3);\nconst anotherArmyBase: Activatable = new ArmyBase(\"Second army base\", 250);\n\n// Compiler throws an error - abstract classes can not be instantiated:\nconst someOtherKindOfBase = new AbstractBase(\"what kind of base is this?\"); \n```", "```\n abstract ActivateSelf(): void; \n```", "```\nconst armyBase = new ArmyBase(\"First army base\", 100);\nconst navyBase = new NavyBase(\"First navy base\", 3); \n```", "```\nconst anotherArmyBase: Activatable = new ArmyBase(\"Second army base\", 250);\nconst activatableNavyBase = <Activatable> navyBase; \n```"]