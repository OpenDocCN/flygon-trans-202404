["```\nlet add x y = x + y\nlet result = add (1 2)  //wrong\n    // error FS0003: This value is not a function and cannot be applied\nlet result = add 1 2    //correct \n```", "```\naddTwoParams (1,2)  // trying to pass a single tuple rather than two args\n   // error FS0001: This expression was expected to have type\n   //               int but here has type 'a * 'b \n```", "```\naddTuple 1 2   // trying to pass two args rather than one tuple\n  // error FS0003: This value is not a function and cannot be applied \n```", "```\nlet list1 = [1,2,3]    // wrong! This is a ONE-element list containing \n                       // a three-element tuple\nlet list1 = [1;2;3]    // correct\n\ntype Customer = {Name:string, Address: string}  // wrong\ntype Customer = {Name:string; Address: string}  // correct \n```", "```\nlet y = true\nlet z = !y\n// => error FS0001: This expression was expected to have \n//    type 'a ref but here has type bool \n```", "```\nlet y = true\nlet z = not y       //correct \n```", "```\nlet z = 1 <> 2      //correct \n```", "```\nlet mutable x = 1\nx = x + 1          // returns false. x is not equal to x+1 \nx <- x + 1         // assigns x+1 to x \n```", "```\nlet add x y =     \n{tab}x + y   \n// => error FS1161: TABs are not allowed in F# code \n```", "```\nlet reader = new System.IO.StringReader(\"hello\")\nlet nextLineFn   =  reader.ReadLine()  //wrong\nlet nextLineFn() =  reader.ReadLine()  //correct\nlet nextLineFn   =  fun() -> reader.ReadLine()  //correct\n\nlet r = new System.Random()\nlet randomFn   =  r.Next()  //wrong\nlet randomFn() =  r.Next()  //correct\nlet randomFn   =  fun () -> r.Next()  //correct \n```", "```\n1 + 2.0  //wrong\n   // => error FS0001: The type 'float' does not match the type 'int' \n```", "```\nfloat 1 + 2.0  //correct \n```", "```\n[1..10] |> List.average   // wrong\n   // => error FS0001: The type 'int' does not support any \n   //    operators named 'DivideByInt' \n```", "```\n[1..10] |> List.map float |> List.average  //correct \n[1..10] |> List.averageBy float  //correct (uses averageBy) \n```", "```\nprintfn \"hello %i\" 1.0  // should be a int not a float\n  // error FS0001: The type 'float' is not compatible \n  //               with any of the types byte,int16,int32... \n```", "```\nprintfn \"hello %i\" (int 1.0) \n```", "```\nlet add x y = x + y\nlet result = add 1 2 3\n// ==> error FS0001: The type ''a -> 'b' does not match the type 'int' \n```", "```\nprintfn \"hello\" 42\n// ==> error FS0001: This expression was expected to have type 'a -> 'b    \n//                   but here has type unit    \n\nprintfn \"hello %i\" 42 43\n// ==> Error FS0001: Type mismatch. Expecting a 'a -> 'b -> 'c    \n//                   but given a 'a -> unit    \n\nprintfn \"hello %i %i\" 42 43 44\n// ==> Error FS0001: Type mismatch. Expecting a  'a -> 'b -> 'c -> 'd    \n//                   but given a 'a -> 'b -> unit \n```", "```\nlet reader = new System.IO.StringReader(\"hello\");\n\nlet line = reader.ReadLine        //wrong but compiler doesn't complain\nprintfn \"The line is %s\" line     //compiler error here!\n// ==> error FS0001: This expression was expected to have type string    \n//                   but here has type unit -> string \n```", "```\nlet line = reader.ReadLine()      //correct\nprintfn \"The line is %s\" line     //no compiler error \n```", "```\nprintfn \"hello %s\" 1.0\n// => error FS0001: This expression was expected to have type string    \n//                  but here has type float \n```", "```\nlet f x = \n  if x > 1 then \"hello\"\n  else 42\n// => error FS0001: This expression was expected to have type string    \n//                  but here has type int \n```", "```\nlet g x = \n  match x with\n  | 1 -> \"hello\"\n  | _ -> 42\n// error FS0001: This expression was expected to have type\n//               string but here has type int \n```", "```\nlet f x = \n  if x > 1 then \"hello\"\n  else \"42\"\n\nlet g x = \n  match x with\n  | 1 -> \"hello\"\n  | _ -> \"42\" \n```", "```\nlet f x = \n  if x > 1 then \"hello\"\n// error FS0001: This expression was expected to have type\n//               unit but here has type string \n```", "```\ntype StringOrInt = | S of string | I of int  // new union type\nlet f x = \n  if x > 1 then S \"hello\"\n  else I 42 \n```", "```\nlet doSomething x = \n   // do something\n   printfn \"x is %s\" x\n   // do something more\n\ndoSomething 1\n// => error FS0001: This expression was expected to have type string    \n//    but here has type int \n```", "```\n// define a two parameter function\nlet add x y = x + 1\n\nadd(x,y)   // FS0001: This expression was expected to have \n           // type int but here has type  'a * 'b \n```", "```\nadd x y    // OK \n```", "```\n// correct\nSystem.String.Compare(\"a\",\"b\")\n\n// incorrect\nSystem.String.Compare \"a\" \"b\" \n```", "```\nlet  t1 = (0, 1)\nlet  t2 = (0, \"hello\")\nt1 = t2\n// => error FS0001: Type mismatch. Expecting a int * int    \n//    but given a int * string    \n//    The type 'int' does not match the type 'string' \n```", "```\nlet  t1 = (0, 1)\nlet  t2 = (0, 1, \"hello\")\nt1 = t2\n// => error FS0001: Type mismatch. Expecting a int * int    \n//    but given a int * int * string    \n//    The tuples have differing lengths of 2 and 3 \n```", "```\nlet x,y = 1,2,3\n// => error FS0001: Type mismatch. Expecting a 'a * 'b    \n//                  but given a 'a * 'b * 'c    \n//                  The tuples have differing lengths of 2 and 3\n\nlet f (x,y) = x + y\nlet z = (1,\"hello\")\nlet result = f z\n// => error FS0001: Type mismatch. Expecting a int * int    \n//                  but given a int * string    \n//                  The type 'int' does not match the type 'string' \n```", "```\nlet y = true\nlet z = !y     //wrong\n// => error FS0001: This expression was expected to have \n//    type 'a ref but here has type bool \n```", "```\nlet y = true\nlet z = not y   //correct \n```", "```\nString.length \"hello\" + \"world\"\n   // => error FS0001:  The type 'string' does not match the type 'int'\n\n// what is really happening\n(String.length \"hello\") + \"world\" \n```", "```\nString.length (\"hello\" + \"world\")  // corrected \n```", "```\nlet result = 42 + [1..10] |> List.sum\n // => => error FS0001:  The type ''a list' does not match the type 'int'\n\n// what is really happening\nlet result = (42 + [1..10]) |> List.sum \n```", "```\nlet result = 42 + ([1..10] |> List.sum) \n```", "```\ntype Wrapper<'a> = Wrapped of 'a\n\ntype wrapBuilder() = \n    member this.Bind (wrapper:Wrapper<'a>) (func:'a->Wrapper<'b>) = \n        match wrapper with\n        | Wrapped(innerThing) -> func innerThing\n\n    member this.Return innerThing = \n        Wrapped(innerThing) \n\nlet wrap = new wrapBuilder() \n```", "```\nwrap {\n    let! x1 = Wrapped(1)   // <== error here\n    let! y1 = Wrapped(2)\n    let z1 = x + y\n    return z\n    }\n// error FS0001: This expression was expected to have type Wrapper<'a>\n//               but here has type 'b * 'c \n```", "```\ntype wrapBuilder() = \n    member this.Bind (wrapper:Wrapper<'a>, func:'a->Wrapper<'b>) = \n        match wrapper with\n        | Wrapped(innerThing) -> func innerThing \n```", "```\nlet add1 x = x + 1\nlet x = add1 2 3\n// ==>   error FS0003: This value is not a function and cannot be applied \n```", "```\nlet (!!) x y = x + y\n(!!) 1 2              // ok\n1 !! 2                // failed !! cannot be used as an infix operator\n// error FS0003: This value is not a function and cannot be applied \n```", "```\nlet detectType v =\n    match v with\n        | :? int -> printfn \"this is an int\"\n        | _ -> printfn \"something else\"\n// error FS0008: This runtime coercion or type test from type 'a to int    \n// involves an indeterminate type based on information prior to this program point. \n// Runtime type tests are not allowed on some types. Further type annotations are needed. \n```", "```\nlet detectTypeBoxed v =\n    match box v with      // used \"box v\" \n        | :? int -> printfn \"this is an int\"\n        | _ -> printfn \"something else\"\n\n//test\ndetectTypeBoxed 1\ndetectTypeBoxed 3.14 \n```", "```\n//3456789\nlet f = \n  let x=1     // offside line is at column 3 \n   x+1        // oops! don't start at column 4\n              // error FS0010: Unexpected identifier in binding \n```", "```\ntype Something() =\n   let field = ()\n\nlet x1 = new Something     // Error FS0010 \nlet x2 = new Something()   // OK! \n```", "```\n// define new operator\nlet (|+) a = -a\n\n|+ 1    // error FS0010: \n        // Unexpected infix operator\n\n(|+) 1  // with parentheses -- OK! \n```", "```\n|| true  // error FS0010: Unexpected symbol '||'\nfalse || true  // OK \n```", "```\nnamespace Customer  // FS0010: Incomplete structured construct \n\n// declare a type\ntype Person= {First:string; Last:string} \n```", "```\nlet something = \n  2+2               // => FS0020: This expression should have type 'unit'\n  \"hello\" \n```", "```\nlet something = \n  2+2 |> ignore     // ok\n  \"hello\" \n```", "```\n// wrong\nlet result = 2+2; \"hello\";\n\n// fixed\nlet result = 2+2 |> ignore; \"hello\"; \n```", "```\nThis expression should have type 'unit', but has type 'Y'. \n```", "```\n// '=' versus '<-'\nlet add() =\n    let mutable x = 1\n    x = x + 1          // warning FS0020\n    printfn \"%d\" x \n```", "```\n// fixed\nlet add() =\n    let mutable x = 1\n    x <- x + 1\n    printfn \"%d\" x \n```", "```\nlet id x = x\nlet compose f g x = g (f x)\nlet opt = None \n```", "```\nval id : 'a -> 'a\nval compose : ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c\nval opt : 'a option \n```", "```\nlet idMap = List.map id             // error FS0030\nlet blankConcat = String.concat \"\"  // error FS0030 \n```", "```\nlet idMap list = List.map id list             // OK\nlet blankConcat list = String.concat \"\" list  // OK \n```", "```\nlet x = 10\nlet rnd1 = System.Random x         // Good\nlet rnd2 = new System.Random(x)    // Good\nlet rnd3 = new System.Random x     // error FS0035 \n```", "```\ntype MyResource() = \n   interface System.IDisposable with\n       member this.Dispose() = printfn \"disposed\" \n```", "```\nlet x = new MyResource()\nx.Dispose()  // error FS0039: The field, constructor \n             // or member 'Dispose' is not defined \n```", "```\n// fixed by casting to System.IDisposable \n(x :> System.IDisposable).Dispose()   // OK\n\nlet y =  new MyResource() :> System.IDisposable \ny.Dispose()   // OK \n```", "```\nlet fib i = \n   match i with\n   | 1 -> 1\n   | 2 -> 1\n   | n -> fib(n-1) + fib(n-2) \n```", "```\nError FS0039: The value or constructor 'fib' is not defined \n```", "```\nlet rec fib i = \n   match i with\n   | 1 -> 1\n   | 2 -> 1\n   | n -> fib(n-1) + fib(n-2) \n```", "```\ntype FibHelper() =\n    member this.fib i = \n       match i with\n       | 1 -> 1\n       | 2 -> 1\n       | n -> fib(n-1) + fib(n-2) \n```", "```\nmodule IntExtensions = \n    type System.Int32 with\n        member this.IsEven = this % 2 = 0 \n```", "```\nlet i = 2\nlet result = i.IsEven  \n    // FS0039: The field, constructor or \n    // member 'IsEven' is not defined \n```", "```\nopen IntExtensions // bring module into scope\nlet i = 2\nlet result = i.IsEven  // fixed! \n```", "```\nlet streamReader filename = new System.IO.StreamReader(filename) // FS0041 \n```", "```\nlet streamReader filename = new System.IO.StreamReader(filename:string) // OK \n```", "```\nlet streamReader filename = new System.IO.StreamReader(path=filename) // OK \n```", "```\nlet streamReader filename = \n    let fileInfo = System.IO.FileInfo(filename)\n    new System.IO.StreamReader(fileInfo.FullName) // OK \n```", "```\ntype ColorUnion = Red | Yellow \nlet redUnion = Red  \n\nmatch redUnion with\n| Red -> printfn \"red\"     // no problem\n| _ -> printfn \"something else\" \n```", "```\ntype ColorEnum = Green=0 | Blue=1      // enum \nlet blueEnum = ColorEnum.Blue  \n\nmatch blueEnum with\n| Blue -> printfn \"blue\"     // warning FS0049\n| _ -> printfn \"something else\" \n```", "```\nmatch blueEnum with\n| ColorEnum.Blue -> printfn \"blue\" \n| _ -> printfn \"something else\" \n```", "```\nlet stringLength x = x.Length // Error FS0072 \n```", "```\nlet stringLength (x:string) = x.Length  // OK \n```", "```\nList.map (fun x -> x.Length) [\"hello\"; \"world\"] // Error FS0072 \n```", "```\nList.map (fun x:string -> x.Length) [\"hello\"; \"world\"] // OK \n```", "```\n[\"hello\"; \"world\"] |> List.map (fun x -> x.Length)   // OK \n```", "```\n//3456789\nlet f = \n  let x=1    // offside line is at column 3 \n x+1         // offside! You are ahead of the ball!\n             // error FS0588: Block following this \n             // 'let' is unfinished \n```"]