["```\n\n```", "```\n\n# Enumerated Types\n\n    One notable aspect of Coq is that its set of built-in\n    features is *extremely* small.  For example, instead of providing\n    the usual palette of atomic data types (booleans, integers,\n    strings, etc.), Coq offers a powerful mechanism for defining new\n    data types from scratch, with all these familiar types as\n    instances.\n\n    Naturally, the Coq distribution comes preloaded with an extensive\n    standard library providing definitions of booleans, numbers, and\n    many common data structures like lists and hash tables.  But there\n    is nothing magic or primitive about these library definitions.  To\n    illustrate this, we will explicitly recapitulate all the\n    definitions we need in this course, rather than just getting them\n    implicitly from the library.\n\n```", "```\nInductive day : Type :=\n\u00a0\u00a0| monday : day\n\u00a0\u00a0| tuesday : day\n\u00a0\u00a0| wednesday : day\n\u00a0\u00a0| thursday : day\n\u00a0\u00a0| friday : day\n\u00a0\u00a0| saturday : day\n\u00a0\u00a0| sunday : day.\n\n```", "```\nDefinition next_weekday (d:day) : day :=\n\u00a0\u00a0match d with\n\u00a0\u00a0| monday    \u21d2 tuesday\n\u00a0\u00a0| tuesday   \u21d2 wednesday\n\u00a0\u00a0| wednesday \u21d2 thursday\n\u00a0\u00a0| thursday  \u21d2 friday\n\u00a0\u00a0| friday    \u21d2 monday\n\u00a0\u00a0| saturday  \u21d2 monday\n\u00a0\u00a0| sunday    \u21d2 monday\n\u00a0\u00a0end.\n\n```", "```\nCompute (next_weekday friday).\n(*\u00a0==>\u00a0monday\u00a0:\u00a0day\u00a0*)\n\nCompute (next_weekday (next_weekday saturday)).\n(*\u00a0==>\u00a0tuesday\u00a0:\u00a0day\u00a0*)\n\n```", "```\nExample test_next_weekday:\n\u00a0\u00a0(next_weekday (next_weekday saturday)) = tuesday.\n\n```", "```\nProof. simpl. reflexivity. Qed.\n\n```", "```\n\n## Homework Submission Guidelines\n\n    If you are using Software Foundations in a course, your instructor\n    may use automatic scripts to help grade your homework assignments.\n    In order for these scripts to work correctly (so that you get full\n    credit for your work!), please be careful to follow these rules:\n\n*   The grading scripts work by extracting marked regions of the .v files that you submit. It is therefore important that you do not alter the \"markup\" that delimits exercises: the Exercise header, the name of the exercise, the \"empty square bracket\" marker at the end, etc. Please leave this markup exactly as you find it.\n\n*   Do not delete exercises. If you skip an exercise (e.g., because it is marked Optional, or because you can't solve it), it is OK to leave a partial proof in your .v file, but in this case please make sure it ends with Admitted (not, for example Abort).\n\n```", "```\nInductive bool : Type :=\n\u00a0\u00a0| true : bool\n\u00a0\u00a0| false : bool.\n\n```", "```\nDefinition negb (b:bool) : bool :=\n\u00a0\u00a0match b with\n\u00a0\u00a0| true \u21d2 false\n\u00a0\u00a0| false \u21d2 true\n\u00a0\u00a0end.\n\nDefinition andb (b[1]:bool) (b[2]:bool) : bool :=\n\u00a0\u00a0match b[1] with\n\u00a0\u00a0| true \u21d2 b[2]\n\u00a0\u00a0| false \u21d2 false\n\u00a0\u00a0end.\n\nDefinition orb (b[1]:bool) (b[2]:bool) : bool :=\n\u00a0\u00a0match b[1] with\n\u00a0\u00a0| true \u21d2 true\n\u00a0\u00a0| false \u21d2 b[2]\n\u00a0\u00a0end.\n\n```", "```\nExample test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity. Qed.\nExample test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity. Qed.\nExample test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity. Qed.\nExample test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity. Qed.\n\n```", "```\nInfix \"&&\" := andb.\nInfix \"||\" := orb.\n\nExample test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed.\n\n```", "```\nDefinition nandb (b[1]:bool) (b[2]:bool) : bool\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_nandb1:               (nandb true false) = true.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_nandb2:               (nandb false false) = true.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_nandb3:               (nandb false true) = true.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_nandb4:               (nandb true true) = false.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition andb3 (b[1]:bool) (b[2]:bool) (b[3]:bool) : bool\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_andb31:                 (andb3 true true true) = true.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_andb32:                 (andb3 false true true) = false.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_andb33:                 (andb3 true false true) = false.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_andb34:                 (andb3 true true false) = false.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Function Types\n\n    Every expression in Coq has a type, describing what sort of\n    thing it computes. The Check command asks Coq to print the type\n    of an expression.\n\n```", "```\n\n    Functions like negb itself are also data values, just like\n    true and false.  Their types are called *function types*, and\n    they are written with arrows.\n\n```", "```\n\n    The type of negb, written bool \u2192 bool and pronounced\n    \"bool arrow bool,\" can be read, \"Given an input of type\n    bool, this function produces an output of type bool.\"\n    Similarly, the type of andb, written bool \u2192 bool \u2192 bool, can\n    be read, \"Given two inputs, both of type bool, this function\n    produces an output of type bool.\"\n\n```", "```\nModule NatPlayground.\n\n```", "```\nInductive nat : Type :=\n\u00a0\u00a0| O : nat\n\u00a0\u00a0| S : nat \u2192 nat.\n\n```", "```\nInductive nat' : Type :=\n\u00a0\u00a0| stop : nat'\n\u00a0\u00a0| tick : nat' \u2192 nat'.\n\n```", "```\nDefinition pred (n : nat) : nat :=\n\u00a0\u00a0match n with\n\u00a0\u00a0\u00a0\u00a0| O \u21d2 O\n\u00a0\u00a0\u00a0\u00a0| S n' \u21d2 n'\n\u00a0\u00a0end.\n\n```", "```\nEnd NatPlayground.\n\nDefinition minustwo (n : nat) : nat :=\n\u00a0\u00a0match n with\n\u00a0\u00a0\u00a0\u00a0| O \u21d2 O\n\u00a0\u00a0\u00a0\u00a0| S O \u21d2 O\n\u00a0\u00a0\u00a0\u00a0| S (S n') \u21d2 n'\n\u00a0\u00a0end.\n\n```", "```\nCheck (S (S (S (S O)))).\n\u00a0\u00a0(*\u00a0===>\u00a04\u00a0:\u00a0nat\u00a0*)\nCompute (minustwo 4).\n\u00a0\u00a0(*\u00a0===>\u00a02\u00a0:\u00a0nat\u00a0*)\n\n```", "```\nCheck S.\nCheck pred.\nCheck minustwo.\n\n```", "```\nFixpoint evenb (n:nat) : bool :=\n\u00a0\u00a0match n with\n\u00a0\u00a0| O        \u21d2 true\n\u00a0\u00a0| S O      \u21d2 false\n\u00a0\u00a0| S (S n') \u21d2 evenb n'\n\u00a0\u00a0end.\n\n```", "```\nDefinition oddb (n:nat) : bool   :=   negb (evenb n).\n\nExample test_oddb1:    oddb 1 = true.\nProof. simpl. reflexivity. Qed.\nExample test_oddb2:    oddb 4 = false.\nProof. simpl. reflexivity. Qed.\n\n```", "```\nModule NatPlayground2.\n\nFixpoint plus (n : nat) (m : nat) : nat :=\n\u00a0\u00a0match n with\n\u00a0\u00a0\u00a0\u00a0| O \u21d2 m\n\u00a0\u00a0\u00a0\u00a0| S n' \u21d2 S (plus n' m)\n\u00a0\u00a0end.\n\n```", "```\nCompute (plus 3 2).\n\n```", "```\n(*\u00a0\u00a0plus (S (S (S O))) (S (S O)) ==>\u00a0S (plus (S (S O)) (S (S O))) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0by\u00a0the\u00a0second\u00a0clause\u00a0of\u00a0the\u00a0match ==>\u00a0S (S (plus (S O) (S (S O)))) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0by\u00a0the\u00a0second\u00a0clause\u00a0of\u00a0the\u00a0match ==>\u00a0S (S (S (plus O (S (S O))))) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0by\u00a0the\u00a0second\u00a0clause\u00a0of\u00a0the\u00a0match ==>\u00a0S (S (S (S (S O)))) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0by\u00a0the\u00a0first\u00a0clause\u00a0of\u00a0the\u00a0match *)\n\n```", "```\nFixpoint mult (n m : nat) : nat :=\n\u00a0\u00a0match n with\n\u00a0\u00a0\u00a0\u00a0| O \u21d2 O\n\u00a0\u00a0\u00a0\u00a0| S n' \u21d2 plus m (mult n' m)\n\u00a0\u00a0end.\n\nExample test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity. Qed.\n\n```", "```\nFixpoint minus (n m:nat) : nat :=\n\u00a0\u00a0match n, m with\n\u00a0\u00a0| O   , _    \u21d2 O\n\u00a0\u00a0| S _ , O    \u21d2 n\n\u00a0\u00a0| S n', S m' \u21d2 minus n' m'\n\u00a0\u00a0end.\n\n```", "```\nEnd NatPlayground2.\n\nFixpoint exp (base power : nat) : nat :=\n\u00a0\u00a0match power with\n\u00a0\u00a0\u00a0\u00a0| O \u21d2 S O\n\u00a0\u00a0\u00a0\u00a0| S p \u21d2 mult base (exp base p)\n\u00a0\u00a0end.\n\n```", "```\n       factorial(0)  =  1\n       factorial(n)  =  n * factorial(n-1)     (if n>0)\n\n```", "```\nFixpoint factorial (n:nat) : nat\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_factorial1:          (factorial 3) = 6.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_factorial2:          (factorial 5) = (mult 10 12).\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nNotation \"x + y\" := (plus x y)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 50, left associativity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: nat_scope.\nNotation \"x - y\" := (minus x y)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 50, left associativity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: nat_scope.\nNotation \"x * y\" := (mult x y)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 40, left associativity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: nat_scope.\n\nCheck ((0 + 1) + 1).\n\n```", "```\nFixpoint beq_nat (n m : nat) : bool :=\n\u00a0\u00a0match n with\n\u00a0\u00a0| O \u21d2 match m with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| O \u21d2 true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| S m' \u21d2 false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0| S n' \u21d2 match m with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| O \u21d2 false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| S m' \u21d2 beq_nat n' m'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0end.\n\n```", "```\nFixpoint leb (n m : nat) : bool :=\n\u00a0\u00a0match n with\n\u00a0\u00a0| O \u21d2 true\n\u00a0\u00a0| S n' \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0match m with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| O \u21d2 false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| S m' \u21d2 leb n' m'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0end.\n\nExample test_leb1:             (leb 2 2) = true.\nProof. simpl. reflexivity. Qed.\nExample test_leb2:             (leb 2 4) = true.\nProof. simpl. reflexivity. Qed.\nExample test_leb3:             (leb 4 2) = false.\nProof. simpl. reflexivity. Qed.\n\n```", "```\nDefinition blt_nat (n m : nat) : bool\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_blt_nat1:             (blt_nat 2 2) = false.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_blt_nat2:             (blt_nat 2 4) = true.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_blt_nat3:             (blt_nat 4 2) = false.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Proof by Simplification\n\n    Now that we've defined a few datatypes and functions, let's\n    turn to stating and proving properties of their behavior.\n    Actually, we've already started doing this: each Example in the\n    previous sections makes a precise claim about the behavior of some\n    function on some particular inputs.  The proofs of these claims\n    were always the same: use simpl to simplify both sides of the\n    equation, then use reflexivity to check that both sides contain\n    identical values.\n\n    The same sort of \"proof by simplification\" can be used to prove\n    more interesting properties as well.  For example, the fact that\n    0 is a \"neutral element\" for + on the left can be proved just\n    by observing that 0 + n reduces to n no matter what n is, a\n    fact that can be read directly off the definition of plus.\n\n```", "```\n\n    (You may notice that the above statement looks different in\n    the .v file in your IDE than it does in the HTML rendition in\n    your browser, if you are viewing both. In .v files, we write the\n    \u2200 universal quantifier using the reserved identifier\n    \"forall.\"  When the .v files are converted to HTML, this gets\n    transformed into an upside-down-A symbol.)\n\n    This is a good place to mention that reflexivity is a bit\n    more powerful than we have admitted. In the examples we have seen,\n    the calls to simpl were actually not needed, because\n    reflexivity can perform some simplification automatically when\n    checking that two sides are equal; simpl was just added so that\n    we could see the intermediate state \u2014 after simplification but\n    before finishing the proof.  Here is a shorter proof of the\n    theorem:\n\n```", "```\n\n    Moreover, it will be useful later to know that reflexivity\n    does somewhat *more* simplification than simpl does \u2014 for\n    example, it tries \"unfolding\" defined terms, replacing them with\n    their right-hand sides.  The reason for this difference is that,\n    if reflexivity succeeds, the whole goal is finished and we don't\n    need to look at whatever expanded expressions reflexivity has\n    created by all this simplification and unfolding; by contrast,\n    simpl is used in situations where we may have to read and\n    understand the new goal that it creates, so we would not want it\n    blindly expanding definitions and leaving the goal in a messy\n    state.\n\n    The form of the theorem we just stated and its proof are almost\n    exactly the same as the simpler examples we saw earlier; there are\n    just a few differences.\n\n    First, we've used the keyword Theorem instead of Example.\n    This difference is purely a matter of style; the keywords\n    Example and Theorem (and a few others, including Lemma,\n    Fact, and Remark) mean exactly the same thing to Coq.\n\n    Second, we've added the quantifier \u2200 n:nat, so that our\n    theorem talks about *all* natural numbers n.  Informally, to\n    prove theorems of this form, we generally start by saying \"Suppose\n    n is some number...\"  Formally, this is achieved in the proof by\n    intros n, which moves n from the quantifier in the goal to a\n    *context* of current assumptions.\n\n    The keywords intros, simpl, and reflexivity are examples of\n    *tactics*.  A tactic is a command that is used between Proof and\n    Qed to guide the process of checking some claim we are making.\n    We will see several more tactics in the rest of this chapter and\n    yet more in future chapters.\n\n    Other similar theorems can be proved with the same pattern.\n\n```", "```\n\n    The _l suffix in the names of these theorems is\n    pronounced \"on the left.\" \n\n    It is worth stepping through these proofs to observe how the\n    context and the goal change.  You may want to add calls to simpl\n    before reflexivity to see the simplifications that Coq performs\n    on the terms before checking that they are equal.\n\n    Although simplification is powerful enough to prove some fairly\n    general facts, there are many statements that cannot be handled by\n    simplification alone.  For instance, we cannot use it to prove\n    that 0 is also a neutral element for + *on the right*.\n\n```", "```\n\n    (Can you explain why this happens?  Step through both proofs\n    with Coq and notice how the goal and context change.)\n\n    When stuck in the middle of a proof, we can use the Abort\n    command to give up on it for the moment.\n\n```", "```\n\n    The next chapter will introduce *induction*, a powerful\n    technique that can be used for proving this goal.  For the moment,\n    though, let's look at a few more simple tactics.\n\n```", "```\nTheorem plus_id_example : \u2200n m:nat,\n\u00a0\u00a0n = m \u2192\n\u00a0\u00a0n + n = m + m.\n\n```", "```\nProof.\n\u00a0\u00a0(*\u00a0move\u00a0both\u00a0quantifiers\u00a0into\u00a0the\u00a0context:\u00a0*)\n\u00a0\u00a0intros n m.\n\u00a0\u00a0(*\u00a0move\u00a0the\u00a0hypothesis\u00a0into\u00a0the\u00a0context:\u00a0*)\n\u00a0\u00a0intros H.\n\u00a0\u00a0(*\u00a0rewrite\u00a0the\u00a0goal\u00a0using\u00a0the\u00a0hypothesis:\u00a0*)\n\u00a0\u00a0rewrite \u2192 H.\n\u00a0\u00a0reflexivity. Qed.\n\n```", "```\nTheorem plus_id_exercise : \u2200n m o : nat,\n\u00a0\u00a0n = m \u2192 m = o \u2192 n + m = m + o.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem mult_0_plus : \u2200n m : nat,\n\u00a0\u00a0(0 + n) * m = n * m.\nProof.\n\u00a0\u00a0intros n m.\n\u00a0\u00a0rewrite \u2192 plus_O_n.\n\u00a0\u00a0reflexivity. Qed.\n\n```", "```\nTheorem mult_S_1 : \u2200n m : nat,\n\u00a0\u00a0m = S n \u2192\n\u00a0\u00a0m * (1 + n) = m * m.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n(*\u00a0(N.b.\u00a0This\u00a0proof\u00a0can\u00a0actually\u00a0be\u00a0completed\u00a0without\u00a0using\u00a0rewrite, \u00a0\u00a0\u00a0but\u00a0please\u00a0do\u00a0use\u00a0rewrite\u00a0for\u00a0the\u00a0sake\u00a0of\u00a0the\u00a0exercise.)\u00a0*)\n\n```", "```\n\n# Proof by Case Analysis\n\n    Of course, not everything can be proved by simple\n    calculation and rewriting: In general, unknown, hypothetical\n    values (arbitrary numbers, booleans, lists, etc.) can block\n    simplification.  For example, if we try to prove the following\n    fact using the simpl tactic as above, we get stuck.\n\n```", "```\n\n    The reason for this is that the definitions of both\n    beq_nat and + begin by performing a match on their first\n    argument.  But here, the first argument to + is the unknown\n    number n and the argument to beq_nat is the compound\n    expression n + 1; neither can be simplified.\n\n    To make progress, we need to consider the possible forms of n\n    separately.  If n is O, then we can calculate the final result\n    of beq_nat (n + 1) 0 and check that it is, indeed, false.  And\n    if n = S n' for some n', then, although we don't know exactly\n    what number n + 1 yields, we can calculate that, at least, it\n    will begin with one S, and this is enough to calculate that,\n    again, beq_nat (n + 1) 0 will yield false.\n\n    The tactic that tells Coq to consider, separately, the cases where\n    n = O and where n = S n' is called destruct.\n\n```", "```\n\n    The destruct generates *two* subgoals, which we must then\n    prove, separately, in order to get Coq to accept the theorem. The\n    annotation \"as [| n']\" is called an *intro pattern*.  It tells\n    Coq what variable names to introduce in each subgoal.  In general,\n    what goes between the square brackets is a *list of lists* of\n    names, separated by |.  In this case, the first component is\n    empty, since the O constructor is nullary (it doesn't have any\n    arguments).  The second component gives a single name, n', since\n    S is a unary constructor.\n\n    The - signs on the second and third lines are called *bullets*,\n    and they mark the parts of the proof that correspond to each\n    generated subgoal.  The proof script that comes after a bullet is\n    the entire proof for a subgoal.  In this example, each of the\n    subgoals is easily proved by a single use of reflexivity, which\n    itself performs some simplification \u2014 e.g., the first one\n    simplifies beq_nat (S n' + 1) 0 to false by first rewriting\n    (S n' + 1) to S (n' + 1), then unfolding beq_nat, and then\n    simplifying the match.\n\n    Marking cases with bullets is entirely optional: if bullets are\n    not present, Coq simply asks you to prove each subgoal in\n    sequence, one at a time. But it is a good idea to use bullets.\n    For one thing, they make the structure of a proof apparent, making\n    it more readable. Also, bullets instruct Coq to ensure that a\n    subgoal is complete before trying to verify the next one,\n    preventing proofs for different subgoals from getting mixed\n    up. These issues become especially important in large\n    developments, where fragile proofs lead to long debugging\n    sessions.\n\n    There are no hard and fast rules for how proofs should be\n    formatted in Coq \u2014 in particular, where lines should be broken\n    and how sections of the proof should be indented to indicate their\n    nested structure.  However, if the places where multiple subgoals\n    are generated are marked with explicit bullets at the beginning of\n    lines, then the proof will be readable almost no matter what\n    choices are made about other aspects of layout.\n\n    This is also a good place to mention one other piece of somewhat\n    obvious advice about line lengths.  Beginning Coq users sometimes\n    tend to the extremes, either writing each tactic on its own line\n    or writing entire proofs on one line.  Good style lies somewhere\n    in the middle.  One reasonable convention is to limit yourself to\n    80-character lines.\n\n    The destruct tactic can be used with any inductively defined\n    datatype.  For example, we use it next to prove that boolean\n    negation is involutive \u2014 i.e., that negation is its own\n    inverse.\n\n```", "```\n\n    Note that the destruct here has no as clause because\n    none of the subcases of the destruct need to bind any variables,\n    so there is no need to specify any names.  (We could also have\n    written as [|], or as [].)  In fact, we can omit the as\n    clause from *any* destruct and Coq will fill in variable names\n    automatically.  This is generally considered bad style, since Coq\n    often makes confusing choices of names when left to its own\n    devices.\n\n    It is sometimes useful to invoke destruct inside a subgoal,\n    generating yet more proof obligations. In this case, we use\n    different kinds of bullets to mark goals on different \"levels.\"\n    For example:\n\n```", "```\n\n    Each pair of calls to reflexivity corresponds to the\n    subgoals that were generated after the execution of the destruct c\n    line right above it. \n\n    Besides - and +, we can use * (asterisk) as a third kind of\n    bullet.  We can also enclose sub-proofs in curly braces, which is\n    useful in case we ever encounter a proof that generates more than\n    three levels of subgoals:\n\n```", "```\n\n    Since curly braces mark both the beginning and the end of a\n    proof, they can be used for multiple subgoal levels, as this\n    example shows. Furthermore, curly braces allow us to reuse the\n    same bullet shapes at multiple levels in a proof:\n\n```", "```\n\n    Before closing the chapter, let's mention one final\n    convenience.  As you may have noticed, many proofs perform case\n    analysis on a variable right after introducing it:\n\n```", "```\nTheorem plus_1_neq_0' : \u2200n : nat,\n\u00a0\u00a0beq_nat (n + 1) 0 = false.\nProof.\n\u00a0\u00a0intros [|n].\n\u00a0\u00a0- reflexivity.\n\u00a0\u00a0- reflexivity. Qed.\n\n```", "```\nTheorem andb_commutative'' :\n\u00a0\u00a0\u2200b c, andb b c = andb c b.\nProof.\n\u00a0\u00a0intros [] [].\n\u00a0\u00a0- reflexivity.\n\u00a0\u00a0- reflexivity.\n\u00a0\u00a0- reflexivity.\n\u00a0\u00a0- reflexivity.\nQed.\n\n```", "```\nTheorem andb_true_elim2 : \u2200b c : bool,\n\u00a0\u00a0andb b c = true \u2192 c = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem zero_nbeq_plus_1 : \u2200n : nat,\n\u00a0\u00a0beq_nat 0 (n + 1) = false.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## More on Notation (Optional)\n\n    (In general, sections marked Optional are not needed to follow the\n    rest of the book, except possibly other Optional sections.  On a\n    first reading, you might want to skim these sections so that you\n    know what's there for future reference.)\n\n    Recall the notation definitions for infix plus and times:\n\n```", "```\n\n    For each notation symbol in Coq, we can specify its *precedence level* and its *associativity*.  The precedence level n is\n    specified by writing at level n; this helps Coq parse compound\n    expressions.  The associativity setting helps to disambiguate\n    expressions containing multiple occurrences of the same\n    symbol. For example, the parameters specified above for + and\n    * say that the expression 1+2*3*4 is shorthand for\n    (1+((2*3)*4)). Coq uses precedence levels from 0 to 100, and\n    *left*, *right*, or *no* associativity.  We will see more examples\n    of this later, e.g., in the [Lists](Lists.html)\n    chapter.\n\n    Each notation symbol is also associated with a *notation scope*.\n    Coq tries to guess what scope is meant from context, so when it\n    sees S(O*O) it guesses nat_scope, but when it sees the\n    cartesian product (tuple) type bool*bool (which we'll see in\n    later chapters) it guesses type_scope.  Occasionally, it is\n    necessary to help it out with percent-notation by writing\n    (x*y)%nat, and sometimes in what Coq prints it will use %nat\n    to indicate what scope a notation is in.\n\n    Notation scopes also apply to numeral notation (3, 4, 5,\n    etc.), so you may sometimes see 0%nat, which means O (the\n    natural number 0 that we're using in this chapter), or 0%Z,\n    which means the Integer zero (which comes from a different part of\n    the standard library).\n\n    Pro tip: Coq's notation mechanism is not especially powerful.\n    Don't expect too much from it!\n\n```", "```\nFixpoint plus' (n : nat) (m : nat) : nat :=\n\u00a0\u00a0match n with\n\u00a0\u00a0| O \u21d2 m\n\u00a0\u00a0| S n' \u21d2 S (plus' n' m)\n\u00a0\u00a0end.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n# More Exercises\n\n#### Exercise: 2 starsM (boolean_functions)\n\n    Use the tactics you have learned so far to prove the following\n    theorem about boolean functions.\n\n```", "```\n\n    Now state and prove a theorem negation_fn_applied_twice similar\n    to the previous one but where the second hypothesis says that the\n    function f has the property that f x = negb x.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars (andb_eq_orb)\n\n    Prove the following theorem.  (You may want to first prove a\n    subsidiary lemma or two. Alternatively, remember that you do\n    not have to introduce all hypotheses at the same time.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 starsM (binary)\n\n    Consider a different, more efficient representation of natural\n    numbers using a binary rather than unary system.  That is, instead\n    of saying that each natural number is either zero or the successor\n    of a natural number, we can say that each binary number is either\n\n*   zero,\n\n*   twice a binary number, or\n\n*   one more than twice a binary number.\n\n    (a) First, write an inductive definition of the type bin\n        corresponding to this description of binary numbers.\n\n    (Hint: Recall that the definition of nat above,\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]