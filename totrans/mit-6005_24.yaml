- en: 'Reading 24: Map, Filter, Reduce'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 24：Map、Filter、Reduce
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 安全免于错误 | 易于理解 | 可轻松更改 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确且未来未知时也正确。 | 与未来程序员清晰沟通，包括未来的你。 | 设计以适应更改而无需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: In this reading you’ll learn a design pattern for implementing functions that
    operate on sequences of elements, and you’ll see how treating functions themselves
    as *first-class values* that we can pass around and manipulate in our programs
    is an especially powerful idea.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇阅读中，您将学习一种用于实现对元素序列操作的函数的设计模式，并且您将看到将函数本身视为*第一类值*，我们可以在程序中传递和操作它们，这是一个特别强大的想法。
- en: Map/filter/reduce
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map/filter/reduce
- en: Lambda expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Functional objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能对象
- en: Higher-order functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'Introduction: an example'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介：一个示例
- en: 'Suppose we’re given the following problem: write a method that finds the words
    in the Java files in your project.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们面临以下问题：编写一个方法，找出项目中 Java 文件中的单词。
- en: 'Following good practice, we break it down into several simpler steps and write
    a method for each one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循良好的实践，我们将其拆分为几个较简单的步骤，并为每个步骤编写一个方法：
- en: find all the files in the project, by scanning recursively from the project’s
    root folder
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找项目中的所有文件，通过从项目的根文件夹递归扫描
- en: restrict them to files with a particular suffix, in this case `.java`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们限制在具有特定后缀的文件中，本例中为`.java`
- en: open each file and read it in line-by-line
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开每个文件并逐行读取
- en: break each line into words
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每行拆分成单词
- en: 'Writing the individual methods for these substeps, we’ll find ourselves writing
    a lot of low-level iteration code. For example, here’s what the recursive traversal
    of the project folder might look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这些子步骤的各个方法时，我们会发现自己写了很多低级别的迭代代码。例如，这是项目文件夹的递归遍历可能看起来像什么：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here’s what the filtering method might look like, which restricts that
    file list down to just the Java files (imagine calling this like `onlyFilesWithSuffix(files,
    ".java")`):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '这是过滤方法可能的样子，它将文件列表限制为只有 Java 文件（想象一下像这样调用它：`onlyFilesWithSuffix(files, ".java")`）:'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[**→ full Java code for the example**](https://github.com/mit6005/fa16-ex24-words/blob/master/src/words/Words1.java)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[**→ 示例的完整 Java 代码**](https://github.com/mit6005/fa16-ex24-words/blob/master/src/words/Words1.java)'
- en: In this reading we discuss *map/filter/reduce*, a design pattern that substantially
    simplifies the implementation of functions that operate over sequences of elements.
    In this example, we’ll have lots of sequences — lists of files; input streams
    that are sequences of lines; lines that are sequences of words; frequency tables
    that are sequences of (word, count) pairs. Map/filter/reduce will enable us to
    operate on those sequences with no explicit control flow — not a single `for`
    loop or `if` statement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇阅读中，我们讨论*map/filter/reduce*，这是一种设计模式，可以大大简化对元素序列操作的函数的实现。在这个例子中，我们会有很多序列——文件列表；作为行序列的输入流；作为单词序列的行；作为（单词，计数）对序列的频率表。Map/filter/reduce
    将使我们能够在这些序列上操作，而无需显式的控制流程——没有一个`for`循环或`if`语句。
- en: 'Along the way, we’ll also see an important Big Idea: functions as “first-class”
    data values, meaning that they can be stored in variables, passed as arguments
    to functions, and created dynamically like other values.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们还将看到一个重要的大思想：函数作为“第一类”数据值，意味着它们可以存储在变量中，作为参数传递给函数，并像其他值一样动态创建。
- en: Using first-class functions in Java is more verbose, uses some unfamiliar syntax,
    and the interaction with static typing adds some complexity. So to get started
    with map/filter/reduce, we’ll switch back to Python.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中使用第一类函数更加冗长，使用了一些不熟悉的语法，并且与静态类型的交互增加了一些复杂性。因此，为了开始使用 map/filter/reduce，我们将切换回
    Python。
- en: Abstracting out control flow
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象出控制流
- en: 'We’ve already seen one design pattern that abstracts away from the details
    of iterating over a data structure: Iterator.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个设计模式，它抽象出了对数据结构进行迭代的细节：迭代器。
- en: Iterator abstraction
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器抽象
- en: Iterator gives you a sequence of elements from a data structure, without you
    having to worry about whether the data structure is a set or a token stream or
    a list or an array — the [`Iterator`](http://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html)
    looks the same no matter what the data structure is.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器为您提供了来自数据结构的元素序列，而无需担心数据结构是集合、令牌流、列表还是数组 — 无论数据结构是什么，[`Iterator`](http://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html)看起来都是一样的。
- en: 'For example, given a `List<File> files`, we can iterate using indices:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个`List<File> files`，我们可以使用索引进行迭代：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But this code depends on the `size` and `get` methods of `List`, which might
    be different in another data structure. Using an iterator abstracts away the details:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但这段代码依赖于`List`的`size`和`get`方法，这在另一个数据结构中可能会有所不同。使用迭代器可以抽象出这些细节：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the loop will be identical for any type that provides an `Iterator`. There
    is, in fact, an interface for such types: [`Iterable`](http://docs.oracle.com/javase/8/docs/api/?java/lang/Iterable.html).
    Any `Iterable` can be used with Java’s [enhanced for statement](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html)
    — `for (File f : files)` — and under the hood, it uses an iterator.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '现在循环对于任何提供`Iterator`的类型都是相同的。实际上，有一个适用于这些类型的接口：[`Iterable`](http://docs.oracle.com/javase/8/docs/api/?java/lang/Iterable.html)。任何`Iterable`都可以与Java的[增强for语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html)一起使用
    — `for (File f : files)` — 在幕后，它使用一个迭代器。'
- en: Map/filter/reduce abstraction
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射/过滤/归约抽象
- en: 'The map/filter/reduce patterns in this reading do something similar to Iterator,
    but at an even higher level: they treat the entire sequence of elements as a unit,
    so that the programmer doesn’t have to name and work with the elements individually.
    In this paradigm, the control statements disappear: specifically, the `for` statements,
    the `if` statements, and the `return` statements in the code from our introductory
    example will be gone. We’ll also be able to get rid of most of the temporary names
    (i.e., the local variables `files`, `f`, and `result`).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本文中的映射/过滤/归约模式与迭代器做的事情类似，但在更高的层面上：它们将整个元素序列视为一个单元，使程序员无需单独命名和处理元素。在这种范式中，控制语句消失了：具体来说，我们介绍示例代码中的`for`语句、`if`语句和`return`语句将不复存在。我们还将能够摆脱大部分临时名称（即，局部变量`files`、`f`和`result`）。
- en: Sequences
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列
- en: Let’s imagine an abstract datatype `Seq<E>` that represents a *sequence* of
    elements of type `E`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个抽象数据类型`Seq<E>`，表示类型为`E`的元素*序列*。
- en: For example, `[1, 2, 3, 4]` ∈ `Seq<Integer>`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`[1, 2, 3, 4]` ∈ `Seq<Integer>`。
- en: 'Any datatype that has an iterator can qualify as a sequence: array, list, set,
    etc. A string is also a sequence (of characters), although Java’s strings don’t
    offer an iterator. Python is more consistent in this respect: not only are lists
    iterable, but so are strings, tuples (which are immutable lists), and even input
    streams (which produce a sequence of lines). We’ll see these examples in Python
    first, since the syntax is very readable and familiar to you, and then we’ll see
    how it works in Java.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有迭代器的数据类型都可以作为序列：数组、列表、集合等。字符串也是一个序列（字符的序列），尽管Java的字符串不提供迭代器。在这方面，Python更加一致：不仅列表可迭代，字符串、元组（不可变列表）甚至输入流（产生一系列行）也是可迭代的。我们将首先在Python中看到这些示例，因为语法非常易读且对您来说很熟悉，然后我们将看看它在Java中是如何工作的。
- en: 'We’ll have three operations for sequences: map, filter, and reduce. Let’s look
    at each one in turn, and then look at how they work together.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有三个序列操作：映射、过滤和归约。让我们依次看看每个操作，然后看看它们如何一起工作。
- en: Map
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: '**Map** applies a unary function to each element in the sequence and returns
    a new sequence containing the results, in the same order:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**将一个一元函数应用于序列中的每个元素，并返回一个包含结果的新序列，顺序相同：'
- en: '**map : (E → F) × Seq<‍E> → Seq<‍F>**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**map：(E → F) × Seq<‍E> → Seq<‍F>**'
- en: 'For example, in Python:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Python中：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`map` is built-in, but it is also straightforward to implement in Python:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`是内置的，但在Python中实现也很简单：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This operation captures a common pattern for operating over sequences: doing
    the same thing to each element of the sequence.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作捕捉了对序列进行操作的常见模式：对序列的每个元素执行相同的操作。
- en: Functions as values
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为值
- en: Let’s pause here for a second, because we’re doing something unusual with functions.
    The `map` function takes a reference to a *function* as its first argument — not
    to the result of that function. When we wrote
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里停顿一下，因为我们正在对函数做一些不寻常的事情。`map`函数将一个*函数*的引用作为其第一个参数 — 而不是该函数的结果。当我们写下
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'we didn’t *call* `sqrt` (like `sqrt(25)` is a call), instead we just used its
    name. In Python, the name of a function is a reference to an object representing
    that function. You can assign that object to another variable if you like, and
    it still behaves like `sqrt`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有*调用*`sqrt`（像`sqrt(25)`是一次调用一样），而是只使用了它的名称。在Python中，函数的名称是对表示该函数的对象的引用。如果您愿意，您可以将该对象分配给另一个变量，并且它仍然像`sqrt`一样行为：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also pass a reference to the function object as a parameter to another
    function, and that’s what we’re doing here with `map`. You can use function objects
    the same way you would use any other data value in Python (like numbers or strings
    or objects).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将函数对象的引用作为参数传递给另一个函数，并且这就是我们在这里使用`map`所做的。您可以像在Python中使用任何其他数据值（如数字、字符串或对象）一样使用函数对象。
- en: Functions are **first-class** in Python, meaning that they can be assigned to
    variables, passed as parameters, used as return values, and stored in data structures.
    First-class functions are a very powerful programming idea. The first practical
    programming language that used them was Lisp, invented by John McCarthy at MIT.
    But the idea of programming with functions as first-class values actually predates
    computers, tracing back to Alonzo Church’s lambda calculus. The lambda calculus
    used the Greek letter λ to define new functions; this term stuck, and you’ll see
    it as a keyword not only in Lisp and its descendants, but also in Python.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数是**一等公民**，这意味着它们可以赋值给变量、作为参数传递、作为返回值使用，并且存储在数据结构中。一等函数是一个非常强大的编程思想。第一个使用它们的实用编程语言是由MIT的John
    McCarthy发明的Lisp。但是使用函数作为一等值进行编程的想法实际上早于计算机，可以追溯到Alonzo Church的lambda演算。lambda演算使用希腊字母λ来定义新函数；这个术语流行开来，您将在Lisp及其后代中看到它作为关键字，还会在Python中看到它。
- en: 'We’ve seen how to use built-in library functions as first-class values; how
    do we make our own? One way is using a familiar function definition, which gives
    the function a name:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何将内置库函数用作一等值；我们如何创建我们自己的函数呢？一种方法是使用熟悉的函数定义，为函数赋予一个名称：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you only need the function in one place, however — which often comes up
    in programming with functions — it’s more convenient to use a **lambda expression**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当您只需要函数在一个地方时 —— 这在函数编程中经常出现 —— 使用**lambda表达式**更方便：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This expression represents a function of one argument (called `k`) that returns
    the value 2^k. You can use it anywhere you would have used `powerOfTwo`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式表示一个参数（称为`k`）的函数，它返回值为2^k。您可以在任何您将使用`powerOfTwo`的地方使用它：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Python lambda expressions are unfortunately syntactically limited, to functions
    that can be written with just a `return` statement and nothing else (no `if` statements,
    no `for` loops, no local variables). But remember that’s our goal with map/filter/reduce
    anyway, so it won’t be a serious obstacle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python的lambda表达式可惜地在语法上受到限制，只能编写具有`return`语句而没有其他内容（没有`if`语句、没有`for`循环、没有局部变量）的函数。但请记住，这正是我们使用`map/filter/reduce`的目标，因此这不会是一个严重的障碍。
- en: 'Guido Von Rossum, the creator of Python, wrote a blog post about the design
    principle that led not only to first-class functions in Python, but first-class
    methods as well: [First-class Everything](http://python-history.blogspot.com/2009/02/first-class-everything.html).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python的创始人Guido Von Rossum在一篇博文中讨论了这种设计原则，这种原则不仅导致了Python中的一等函数，还导致了一等方法：[一切皆一等](http://python-history.blogspot.com/2009/02/first-class-everything.html)。
- en: More ways to use map
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多使用`map`的方法
- en: 'Map is useful even if you don’t care about the return value of the function.
    When you have a sequence of mutable objects, for example, you can map a mutator
    operation over them:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不关心函数的返回值，`map`也是有用的。例如，当您有一系列可变对象时，您可以在它们上面映射一个改变操作：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some versions of map (including Python’s built-in `map`) also support mapping
    functions with multiple arguments. For example, you can add two lists of numbers
    element-wise:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些版本的`map`（包括Python内置的`map`）还支持将具有多个参数的函数映射。例如，您可以对元素逐个添加两个数字列表：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: reading exercises
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: map 1
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: map 1
- en: Try these in the Python interpreter if you’re not sure!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定，请在Python解释器中尝试！
- en: What is the result of `map(len, [ [1], [2], [3] ])`?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`map(len, [ [1], [2], [3] ])`的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: map 2
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: map 2
- en: What is the result of `map(len, [1, 2, 3])`?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`map(len, [1, 2, 3])`的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: map 3
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 映射 3
- en: What is the result of `map(len, ['1', '2', '3'])`?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`map(len, [''1'', ''2'', ''3''])` 的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: map 4
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 映射 4
- en: 'What is the result of `map(lambda x: x.split('' ''), ''a b c'')`?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`map(lambda x: x.split('' ''), ''a b c'')` 的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: map 5
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 映射 5
- en: 'What is the result of `map(lambda x: x.split('' ''), [''a b c''])`?'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`map(lambda x: x.split('' ''), [''a b c''])` 的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Filter
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: Our next important sequence operation is **filter**, which tests each element
    with a unary predicate. Elements that satisfy the predicate are kept; those that
    don’t are removed. A new list is returned; filter doesn’t modify its input list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来重要的序列操作是**过滤器**，它使用一元谓词测试每个元素。满足谓词的元素被保留；不满足的被移除。返回一个新列表；过滤器不会修改其输入列表。
- en: '**filter : (E → boolean) × Seq<‍E> → Seq<‍E>**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤器：(E → boolean) × Seq<‍E> → Seq<‍E>**'
- en: 'Python examples:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python示例：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can define filter in a straightforward way:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接定义过滤器：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: reading exercises
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: filter 1
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器 1
- en: Try these in the Python interpreter if you’re not sure!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不确定，可以在Python解释器中尝试这些！
- en: 'Given:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 给定：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What is the result of `filter(lambda d: ''x'' in d.keys(), [ x1, y2, x3_y4
    ])`?'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter(lambda d: ''x'' in d.keys(), [ x1, y2, x3_y4 ])` 的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: filter 2
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器 2
- en: 'Again given:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次给定：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What is the result of `filter(lambda d: 0 in d.values(), [ x1, y2, x3_y4 ])`?'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter(lambda d: 0 in d.values(), [ x1, y2, x3_y4 ])` 的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: filter 3
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器 3
- en: What is the result of `filter(str.isalpha, [ 'a', '1', 'b', '2' ])`?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter(str.isalpha, [ ''a'', ''1'', ''b'', ''2'' ])` 的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: filter 4
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器 4
- en: What is the result of `filter(str.swapcase, [ 'a', '1', 'b', '2' ])`?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter(str.swapcase, [ ''a'', ''1'', ''b'', ''2'' ])` 的结果是什么？'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Reduce
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩减
- en: Our final operator, **reduce**, combines the elements of the sequence together,
    using a binary function. In addition to the function and the list, it also takes
    an *initial value* that initializes the reduction, and that ends up being the
    return value if the list is empty.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个操作符，**reduce**，使用二元函数将序列的元素组合在一起。除了函数和列表，它还接受一个*初始值*来初始化缩减，并且如果列表为空，它最终成为返回值。
- en: '**reduce : (F × E → F) × Seq<‍E> × F → F**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩减：(F × E → F) × Seq<‍E> × F → F**'
- en: '`reduce(f, list, init)` combines the elements of the list from left to right,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce(f, list, init)` 将列表的元素从左到右组合在一起，如下所示：'
- en: result[0] = init
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[0] = init
- en: result[1] = f(result[0], list[0])
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[1] = f(result[0], list[0])
- en: result[2] = f(result[1], list[1])
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[2] = f(result[1], list[1])
- en: '...'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...'
- en: result[n] = f(result[n-1], list[n-1])
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[n] = f(result[n-1], list[n-1])
- en: result[n] is the final result for an n-element list.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: result[n] 是一个 n 元素列表的最终结果。
- en: 'Adding numbers is probably the most straightforward example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 加法运算可能是最直接的例子：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are two design choices in the reduce operation. First is whether to require
    an initial value. In Python’s reduce function, the initial value is optional,
    and if you omit it, reduce uses the first element of the list as its initial value.
    So you get behavior like this instead:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在reduce操作中有两个设计选择。首先是是否需要一个初始值。在Python的reduce函数中，初始值是可选的，如果省略它，reduce将使用列表的第一个元素作为其初始值。所以你会得到如下的行为：
- en: result[0] = undefined (reduce throws an exception if the list is empty)
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[0] = undefined（如果列表为空，reduce会抛出异常）
- en: result[1] = list[0]
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[1] = list[0]
- en: result[2] = f(result[1], list[1])
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[2] = f(result[1], list[1])
- en: '...'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...'
- en: result[n] = f(result[n-1], list[n-1])
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[n] = f(result[n-1], list[n-1])
- en: 'This makes it easier to use reducers like `max`, which have no well-defined
    initial value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得使用像`max`这样没有明确定义初始值的减少器更容易：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second design choice is the order in which the elements are accumulated.
    For associative operators like `add` and `max` it makes no difference, but for
    other operators it can. Python’s reduce is also called **fold-left** in other
    programming languages, because it combines the sequence starting from the left
    (the first element). **Fold-right** goes in the other direction:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个设计选择是元素累积的顺序。对于像`add`和`max`这样的关联运算符，顺序没有影响，但对于其他运算符可能会有影响。Python的reduce在其他编程语言中也被称为**fold-left**，因为它从左边（第一个元素）开始组合序列。**Fold-right**则相反：
- en: '**fold-right : (E × F → F) × Seq<‍E> × F → F**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**fold-right : (E × F → F) × Seq<‍E> × F → F**'
- en: 'where `fold-right(f, list, init)` of an n-element list follows this pattern:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于n个元素列表的`fold-right(f, list, init)`遵循以下模式：
- en: result[0] = init
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[0] = init
- en: result[1] = f(list[n-1], result[0])
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[1] = f(list[n-1], result[0])
- en: result[2] = f(list[n-2], result[1])
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[2] = f(list[n-2], result[1])
- en: '...'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...'
- en: result[n] = f(list[0], result[n-1])
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result[n] = f(list[0], result[n-1])
- en: to produce result[n] as the final result.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 产生result[n]作为最终结果。
- en: 'Here’s a diagram of two ways to reduce: from the left or from the right:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从左边或从右边减少的两种方式的图示：
- en: '| ![](http://web.mit.edu/6.005/www/fa16/classes/24-map-filter-reducefold-left.svg)
    | fold-left : (F × E → F) × Seq<‍E> × F → F **fold-left(-, [1, 2, 3], 0) = -6**
    | ![](http://web.mit.edu/6.005/www/fa16/classes/24-map-filter-reducefold-right.svg)
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| ![](http://web.mit.edu/6.005/www/fa16/classes/24-map-filter-reducefold-left.svg)
    | fold-left : (F × E → F) × Seq<‍E> × F → F **fold-left(-, [1, 2, 3], 0) = -6**
    | ![](http://web.mit.edu/6.005/www/fa16/classes/24-map-filter-reducefold-right.svg)
    |'
- en: '| fold-right : (E × F → F) × Seq<‍E> × F → F **fold-right(-, [1, 2, 3], 0)
    = 2** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| fold-right : (E × F → F) × Seq<‍E> × F → F **fold-right(-, [1, 2, 3], 0)
    = 2** |'
- en: 'The return type of the reduce operation doesn’t have to match the type of the
    list elements. For example, we can use reduce to glue together a sequence into
    a string:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 减少操作的返回类型不必与列表元素的类型匹配。例如，我们可以使用reduce将序列粘合成一个字符串：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or to flatten out nested sublists into a single list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者将嵌套子列表展平为单个列表：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a useful enough sequence operation that we’ll define it as **flatten**,
    although it’s just a reduce step inside:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个足够有用的序列操作，我们将其定义为**flatten**，尽管它只是一个减少步骤内部：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: More examples
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多例子
- en: 'Suppose we have a polynomial represented as a list of coefficients, a[0], a[1],
    ..., a[n-1], where a[i] is the coefficient of x^i. Then we can evaluate it using
    map and reduce:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个表示为系数列表的多项式，a[0]，a[1]，...，a[n-1]，其中a[i]是x^i的系数。然后我们可以使用map和reduce来评估它：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code uses the convenient Python generator method `range(a,b)`, which generates
    a list of integers from a to b-1. In map/filter/reduce programming, this kind
    of method replaces a `for` loop that indexes from a to b.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了方便的Python生成器方法`range(a,b)`，它生成从a到b-1的整数列表。在map/filter/reduce编程中，这种方法取代了从a到b索引的`for`循环。
- en: 'Now let’s look at a typical database query example. Suppose we have a database
    about digital cameras, in which each object is of type `Camera` with observer
    methods for its properties (`brand()`, `pixels()`, `cost()`, etc.). The whole
    database is in a list called `cameras`. Then we can describe queries on this database
    using map/filter/reduce:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个典型的数据库查询示例。假设我们有一个关于数码相机的数据库，其中每个对象都是`Camera`类型，具有其属性的观察方法（`brand()`，`pixels()`，`cost()`等）。整个数据库在名为`cameras`的列表中。然后我们可以使用map/filter/reduce描述对该数据库的查询：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Relational databases use the map/filter/reduce paradigm (where it’s called
    project/select/aggregate). [SQL](https://en.wikipedia.org/wiki/SQL) (Structured
    Query Language) is the *de facto* standard language for querying relational databases.
    A typical SQL query looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库使用map/filter/reduce范式（在其中称为project/select/aggregate��。[SQL](https://en.wikipedia.org/wiki/SQL)（结构化查询语言）是查询关系数据库的*事实上*标准语言。典型的SQL查询如下：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`cameras` is a **sequence** (a list of rows, where each row has the data for
    one camera)'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`cameras`是一个**sequence**（一系列行，每行包含一个相机的数据）'
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`where brand = "Nikon"` is a **filter**'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`where brand = "Nikon"`是一个**filter**'
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`pixels` is a **map** (extracting just the pixels field from the row)'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`pixels`是一个**map**（仅提取行中的像素字段）'
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`max` is a **reduce**'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`max`是一个**reduce**'
- en: reading exercises
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: reduce 1
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: reduce 1
- en: Which is the best description of this reduction?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个是对这种减少的最佳描述？
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: reduce 2
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 减少2
- en: Try these in the Python interpreter if you’re not sure!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定，请在Python解释器中尝试这些！
- en: 'What is the result of:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 的结果是什么：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: (missing answer)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: 'What is the result of:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 的结果是什么：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: (missing answer)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Back to the intro example
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到介绍示例
- en: 'Going back to the example we started with, where we want to find all the words
    in the Java files in our project, let’s try creating a useful abstraction for
    filtering files by suffix:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们开始的例子，我们想要找到项目中Java文件中的所有单词，让我们尝试创建一个有用的抽象，以按后缀过滤文件：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`fileEndsWith` returns *functions* that are useful as filters: it takes a filename
    suffix like `.java` and dynamically generates a function that we can use with
    filter to test for that suffix:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileEndsWith`返回作为过滤器有用的*函数*：它接受像`.java`这样的文件名后缀，并动态生成一个我们可以与filter一起使用来测试该后缀的函数：'
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`fileEndsWith` is a different kind of beast than our usual functions. It’s
    a **higher-order function**, meaning that it’s a function that takes another function
    as an argument, or returns another function as its result. Higher-order functions
    are operations on the datatype of functions; in this case, `fileEndsWith` is a
    *creator* of functions.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileEndsWith`与我们通常的函数不同。它是一种**高阶函数**，意味着它是一个接受另一个函数作为参数的函数，或者将另一个函数作为其结果返回的函数。高阶函数是对函数数据类型的操作；在这种情况下，`fileEndsWith`是一个*函数的创建者*。'
- en: 'Now let’s use map, filter, and flatten (which we defined above using reduce)
    to recursively traverse the folder tree:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用map、filter和flatten（我们以上使用reduce定义的）来递归地遍历文件夹树：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first line gets all the children of the folder, which might look like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行获取文件夹的所有子级，可能看起来像这样：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The second line is the key bit: it filters the children for just the subfolders,
    and then recursively maps `allFilesIn` against this list of subfolders! The result
    might look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是关键部分：它过滤子级，只保留子文件夹，然后对这个子文件夹列表递归地映射`allFilesIn`！结果可能会像这样：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So we have to flatten it to remove the nested structure. Then we add the immediate
    children that are plain files (not folders), and that’s our result.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们必须将其展平以消除嵌套结构。然后我们添加那些不是文件夹而是普通文件的直接子级，这就是我们的结果。
- en: 'We can also do the other pieces of the problem with map/filter/reduce. Once
    we have the list of files we want to extract words from, we’re ready to load their
    contents. We can use map to get their pathnames as strings, open them, and then
    read in each file as a list of files:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用map/filter/reduce来解决问题的其他部分。一旦我们有了要从中提取单词的文件列表，我们就可以加载它们的内容。我们可以使用map获取它们的路径名作为字符串，打开它们，然后将每个文件读入为一个文件列表：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This actually looks like a single map operation where we want to apply three
    functions to the elements, so let’s pause to create another useful higher-order
    function: composing functions together.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这看起来像是一个单一的map操作，我们想要将三个函数应用于元素，所以让我们暂停一下，创建另一个有用的高阶函数：将函数组合在一起。
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can use a single map:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用一个单一的映射：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Better, since we already have three functions to apply, let’s design a way
    to compose an arbitrary chain of functions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，既然我们已经有了三个要应用的函数，让我们设计一种方法来组合任意链式函数：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So that the map operation becomes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以至于map操作变成了：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we see more of the power of first-class functions. We can put functions
    into data structures and use operations on those data structures, like map, reduce,
    and filter, on the functions themselves!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到更多一等函数的威力。我们可以将函数放入数据结构中，并在这些数据结构上使用像map、reduce和filter这样的操作，对函数本身进行操作！
- en: 'Since this map will produce a list of lists of lines (one list of lines for
    each file), let’s flatten it to get a single line list, ignoring file boundaries:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此映射将生成一个行列表的列表（每个文件的一行列表），让我们将其展平以获得一个单行列表，忽略文件边界：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then we split each line into words similarly:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们类似地将每一行分割成单词：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And we’re done, we have our list of all words in the project’s Java files! As
    promised, the control statements have disappeared.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们完成了，我们得到了项目的Java文件中所有单词的列表！正如承诺的那样，控制语句已经消失了。
- en: '[**→ full Python code for the example**](https://github.com/mit6005/fa16-ex24-words/blob/master/src/words/Words2.py)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[**→ 示例的完整Python代码**](https://github.com/mit6005/fa16-ex24-words/blob/master/src/words/Words2.py)'
- en: Benefits of abstracting out control
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象控制的好处
- en: Map/filter/reduce can often make code shorter and simpler, and allow the programmer
    to focus on the heart of the computation rather than on the details of loops,
    branches, and control flow.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Map/filter/reduce通常可以使代码更简短、更简单，并允许程序员专注于计算的核心，而不是循环、分支和控制流的细节。
- en: By arranging our program in terms of map, filter, and reduce, and in particular
    using immutable datatypes and pure functions (functions that do not mutate data)
    as much as possible, we’ve created more opportunities for safe concurrency. Maps
    and filters using pure functions over immutable datatypes are instantly parallelizable
    — invocations of the function on different elements of the sequence can be run
    in different threads, on different processors, even on different machines, and
    the result will still be the same. [MapReduce](https://en.wikipedia.org/wiki/MapReduce)
    is a pattern for parallelizing large computations in this way.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用map、filter和reduce组织我们的程序，特别是尽可能使用不可变数据类型和纯函数（不会改变数据的函数），我们为安全并发创造了更多机会。使用纯函数在不可变数据类型上的映射和过滤可以立即并行化——对序列的不同元素的函数调用可以在不同的线程、不同的处理器甚至不同的机器上运行，结果仍然相同。[MapReduce](https://en.wikipedia.org/wiki/MapReduce)是一种以这种方式并行化大型计算的模式。
- en: reading exercises
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: map/filter/reduce
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: map/filter/reduce
- en: 'This Python function accepts a list of numbers and computes the product of
    all the odd numbers:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python函数接受一个数字列表，并计算所有奇数的乘积：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Rewrite the Python code using map, filter, and reduce:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用map、filter和reduce重写Python代码：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Where `m_func`, `f_func`, and `r_func` are each one of the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`m_func`、`f_func`和`r_func`分别是以下之一：
- en: '| **A.** |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **A.** |'
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|  | **H.** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|  | **H.** |'
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **B.** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **B.** |'
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|  | **I.** |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  | **I.** |'
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **C.** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **C.** |'
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|  | **J.** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  | **J.** |'
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **D.** |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **D.** |'
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|  | **K.** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  | **K.** |'
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **E.** |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **E.** |'
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|  | **L.** |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  | **L.** |'
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **F.** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **F.** |'
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|  | **M.** |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  | **M.** |'
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **G.** |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **G.** |'
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|  | **N.** |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  | **N.** |'
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: For each of the choices below, is it a correct implementation?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的每个选项，是否是正确的实现？
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**D + H + L**: `reduce(product, filter(is_odd, map(identity_function, list)))`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**D + H + L**: `reduce(product, filter(is_odd, map(identity_function, list)))`'
- en: (missing answer)(missing answer)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: '**E + F + L**: `reduce(product, filter(always_true, map(identity, list)))`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**E + F + L**: `reduce(product, filter(always_true, map(identity, list)))`'
- en: (missing answer)(missing answer)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: '**E + G + L**: `reduce(product, filter(modulus_tester, map(identity, list)))`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**E + G + L**: `reduce(product, filter(modulus_tester, map(identity, list)))`'
- en: (missing answer)(missing answer)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: '**B + J + L**: `reduce(product, filter(odd_or_identity, map(x, list)))`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**B + J + L**: `reduce(product, filter(odd_or_identity, map(x, list)))`'
- en: (missing answer)(missing answer)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: '**J + F + M**: `reduce(operator.mul, filter(always_true, map(odd_or_identity,
    list)))`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**J + F + M**: `reduce(operator.mul, filter(always_true, map(odd_or_identity,
    list)))`'
- en: (missing answer)(missing answer)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: '**D + I + N**: `reduce(x * y, filter(x_is_odd, map(identity_function, list)))`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**D + I + N**: `reduce(x * y, filter(x_is_odd, map(identity_function, list)))`'
- en: (missing answer)(missing answer)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: First-class functions in Java
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java中的一等函数
- en: We’ve seen what first-class functions look like in Python; how does this all
    work in Java?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Python中看到了一等函数是什么样的；那么在Java中这一切是如何工作的？
- en: In Java, the only first-class values are primitive values (ints, booleans, characters,
    etc.) and object references. But objects can carry functions with them, in the
    form of methods. So it turns out that the way to implement a first-class function,
    in an object-oriented programming language like Java that doesn’t support first-class
    functions directly, is to use an object with a method representing the function.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，唯一的一等值是原始值（int、布尔值、字符等）和对象引用。但是对象可以携带函数，以方法的形式。所以事实证明，在像Java这样不直接支持一等函数的面向对象编程语言中实现一等函数的方式是使用一个代表函数的方法的对象。
- en: 'We’ve actually seen this before several times already:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们已经多次看到这个：
- en: The `Runnable` object that you pass to a `Thread` constructor is a first-class
    function, `void run()`.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`Thread`构造函数的`Runnable`对象是一个一等函数，`void run()`。
- en: The `Comparator<T>` object that you pass to a sorted collection (e.g. `SortedSet`)
    is a first-class function, `int compare(T o1, T o2)`.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给排序集合（例如`SortedSet`）的`Comparator<T>`对象是一个一等函数，`int compare(T o1, T o2)`。
- en: In a future class, we’ll see `KeyListener` objects that you register with the
    graphical user interface toolkit to get keyboard events. They act as a bundle
    of several functions, `keyPressed(KeyEvent)`, `keyReleased(KeyEvent)`, etc.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以后的课程中，我们将会看到你可以注册到图形用户界面工具包的 `KeyListener` 对象来获取键盘事件。它们作为多个函数的集合，例如 `keyPressed(KeyEvent)`、`keyReleased(KeyEvent)`
    等等。
- en: This design pattern is called a **functional object** or **functor**, an object
    whose purpose is to represent a function.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式称为**函数对象**或**函数子**，一个代表函数目的的对象。
- en: Lambda expressions in Java
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java 中的 Lambda 表达式
- en: 'Java’s lambda expression syntax provides a succinct way to create instances
    of functional objects. For example, instead of writing:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 lambda 表达式语法提供了一种简洁的方式来创建函数对象的实例。例如，不是写成：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'we can use a lambda expression:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 lambda 表达式：
- en: '[PRE60]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: On the Java Tutorials page for Lambda Expressions, read [Syntax of Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lambda 表达式的 Java 教程页面中，阅读 [Lambda 表达式的语法](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax)。
- en: 'There’s no magic here: Java still doesn’t have first-class functions. So you
    can only use a lambda when the Java compiler can verify two things:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有魔法：Java 仍然没有一级函数。所以只有当 Java 编译器能够验证两件事时，你才能使用 lambda：
- en: It must be able to determine the type of the functional object the lambda will
    create. In this example, the compiler sees that the `Thread` constructor takes
    a `Runnable`, so it will infer that the type must be `Runnable`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须能够确定 lambda 将创建的函数对象的类型。在这个例子中，编译器看到 `Thread` 构造函数接受一个 `Runnable`，所以它将推断类型必须是
    `Runnable`。
- en: 'This inferred type must be *functional interface*: an interface with only one
    (abstract) method. In this example, `Runnable` indeed only has a single method
    — `void run()` — so the compiler knows the code in the body of the lambda belongs
    in the body of a `run` method of a new `Runnable` object.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断出的类型必须是 *函数式接口*：一个只有一个（抽象）方法的接口。在这个例子中，`Runnable` 确实只有一个方法 — `void run()`
    — 所以编译器知道 lambda 表达式中的代码属于新的 `Runnable` 对象的 `run` 方法的主体。
- en: 'Java provides some [standard functional interfaces](http://docs.oracle.com/javase/8/docs/api/?java/util/function/package-summary.html)
    we can use to write code in the map/filter/reduce pattern, e.g.:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了一些[标准函数接口](http://docs.oracle.com/javase/8/docs/api/?java/util/function/package-summary.html)，我们可以使用它们来按照
    map/filter/reduce 模式编写代码，例如：
- en: '[`Function<T,R>`](http://docs.oracle.com/javase/8/docs/api/?java/util/function/Function.html)
    represents unary functions from `T` to `R`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Function<T,R>`](http://docs.oracle.com/javase/8/docs/api/?java/util/function/Function.html)代表从
    `T` 到 `R` 的一元函数'
- en: '[`BiFunction<T,U,R>`](http://docs.oracle.com/javase/8/docs/api/?java/util/function/BiFunction.html)
    represents binary functions from `T`×`U` to `R`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`BiFunction<T,U,R>`](http://docs.oracle.com/javase/8/docs/api/?java/util/function/BiFunction.html)代表从
    `T`×`U` 到 `R` 的二元函数'
- en: '[`Predicate<T>`](http://docs.oracle.com/javase/8/docs/api/?java/util/function/Predicate.html)
    represents functions from `T` to boolean'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Predicate<T>`](http://docs.oracle.com/javase/8/docs/api/?java/util/function/Predicate.html)代表从
    `T` 到 boolean 的函数'
- en: 'So we could implement map in Java like so:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以像这样在 Java 中实现 map：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And here’s an example of using map; first we’ll write it using the familiar
    syntax:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 map 的示例；首先我们将使用熟悉的语法来写：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And with a lambda expression:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用 lambda 表达式：
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this example, the lambda expression is just wrapping a call to `String`’s
    `toLowerCase`. We can use a *method reference* to avoid writing the lambda, with
    the syntax `::`. The signature of the method we refer to must match the signature
    required by the functional interface for static typing to be satisfied:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，lambda 表达式只是包装了对 `String` 的 `toLowerCase` 的调用。我们可以使用 *方法引用* 来避免编写 lambda，语法是
    `::`。我们引用的方法的签名必须与静态类型所需的函数接口的签名匹配才能满足类型检查：
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the Java Tutorials, you can read more about [**method references**](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)
    if you want the details.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 教程中，如果你想了解更多关于[**方法引用**](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)的细节，可以阅读更多内容。
- en: Using a method reference (vs. calling it) in Java serves the same purpose as
    referring to a function by name (vs. calling it) in Python.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中使用方法引用（与调用它不同）的目的与在 Python 中通过名称引用函数（与调用它不同）的目的相同。
- en: Map/filter/reduce in Java
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 中的 Map/filter/reduce
- en: The [abstract sequence type](#sequences) we defined above exists in Java as
    [`Stream`](http://docs.oracle.com/javase/8/docs/api/?java/util/stream/Stream.html),
    which defines `map`, `filter`, `reduce`, and many other operations.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面定义的[抽象序列类型](#sequences)在Java中存在为[`Stream`](http://docs.oracle.com/javase/8/docs/api/?java/util/stream/Stream.html)，它定义了`map`、`filter`、`reduce`和许多其他操作。
- en: Collection types like `List` and `Set` provide a `stream()` operation that returns
    a `Stream` for the collection, and there’s an `Arrays.stream` function for creating
    a `Stream` from an array.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 类似`List`和`Set`的集合类型提供了一个`stream()`操作，返回集合的一个`Stream`，而`Arrays.stream`函数可以从数组创建一个`Stream`。
- en: 'Here’s one implementation of `allFilesIn` in Java with map and filter:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在Java中使用映射和过滤实现的`allFilesIn`的一个例子：
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The map-and-flatten pattern is so common that Java provides a `flatMap` operation
    to do just that, and we’ve used it instead of defining `flatten`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 映射和扁平化模式非常常见，Java提供了`flatMap`操作来执行此操作，我们已经使用它代替了定义`flatten`。
- en: 'Here’s `endsWith`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`endsWith`：
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Given a `Stream<File> files`, we can now write e.g. `files.filter(endsWith(".java"))`
    to obtain a new filtered stream.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`Stream<File> files`，我们现在可以编写例如`files.filter(endsWith(".java"))`来获取一个新的过滤流。
- en: Look at the [revised Java code for this example](https://github.com/mit6005/fa16-ex24-words/blob/master/src/words/Words3.java).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[此示例的修订Java代码](https://github.com/mit6005/fa16-ex24-words/blob/master/src/words/Words3.java)。
- en: 'You can compare [all three versions](https://github.com/mit6005/fa16-ex24-words/tree/master/src/words):
    the familiar Java implementation, Python with map/filter/reduce, and Java with
    map/filter/reduce.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以比较[所有三个版本](https://github.com/mit6005/fa16-ex24-words/tree/master/src/words)：熟悉的Java实现、具有map/filter/reduce的Python和具有map/filter/reduce的Java。
- en: Higher-order functions in Java
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java中的高阶函数
- en: 'Map/filter/reduce are of course higher-order functions; so is `endsWith` above.
    Let’s look at two more that we saw before: `compose` and `chain`.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Map/filter/reduce当然是高阶函数；`endsWith`也是。让我们再看两个我们之前看过的：`compose`和`chain`。
- en: 'The `Function` interface provides `compose` — but the implementation is very
    straightforward. In particular, once you get the types of the arguments and return
    values correct, Java’s static typing makes it pretty much impossible to get the
    method body wrong:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function`接口提供了`compose`——但实现非常简单。特别是，一旦您正确获取了参数和返回值的类型，Java的静态类型使得几乎不可能错误地编写方法体：'
- en: '[PRE67]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It turns out that we *can’t* write `chain` in strongly-typed Java, because `List`s
    (and other collections) must be homogeneous — we can specify a list whose elements
    are all of type `Function<A,B>`, but not one whose first element is a `Function<A,B>`,
    second is a `Function<B,C>`, and so on.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，我们*无法*在强类型的Java中编写`chain`，因为`List`（和其他集合）必须是同构的——我们可以指定一个元素类型都为`Function<A,B>`的列表，但不能指定一个第一个元素为`Function<A,B>`、第二个元素为`Function<B,C>`，依此类推的列表。
- en: 'But here’s `chain` for functions of the same input/output type:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这里是用于相同输入/输出类型的`chain`：
- en: '[PRE68]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Our Python version didn’t use an initial value in the `reduce`, it required
    a non-empty list of functions. In Java, we’ve provided the identity function (that
    is, *f(t) = t*) as the identity value for the reduction.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python版本在`reduce`中没有使用初始值，它需要一个非空函数列表。在Java中，我们已经提供了身份函数（即，*f(t) = t*）作为归约的身份值。
- en: reading exercises
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取练习
- en: Comparator<‌Dog>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator<‌Dog>`'
- en: 'In Java, suppose we have:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，假设我们有：
- en: '[PRE69]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We have several `Dog` objects, and we’d like to keep a collection of them, sorted
    by how loud they bark.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个`Dog`对象，我们想保留它们的一个按照它们叫声响亮程度排序的集合。
- en: Java provides an interface `SortedSet` for sorted sets of objects. `TreeSet`
    implements `SortedSet`, so we’ll use that.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Java为对象的排序集提供了一个接口`SortedSet`。`TreeSet`实现了`SortedSet`，所以我们将使用它。
- en: The `TreeSet` constructor takes as an argument a `Comparator` that tells it
    how to compare two objects in the set; in this case, two `Dog`s.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeSet`构造函数接受一个`Comparator`作为参数，告诉它如何比较集合中的两个对象；在这种情况下，是两个`Dog`。'
- en: '`Comparator` is a functional interface: it has a single unimplemented method:
    [`int compare(...)`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator`是一个函数接口：它有一个未实现的方法：[`int compare(...)`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-)。'
- en: 'So our code will look like:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们的代码看起来像这样：
- en: '[PRE70]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'An instance of `Comparator` is an example of:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator`的一个实例是一个示例：'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Barking up the wrong TreeSet
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的TreeSet
- en: Which of these would create a `TreeSet` to sort our dogs from quietest bark
    to loudest?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中哪一个会创建一个 `TreeSet` 来将我们的狗按照吠声从最安静到最响进行排序？
- en: Read the documentation for [`Comparator.compare(...)`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-)
    to understand what it needs to do.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读[`Comparator.compare(...)`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-)的文档，了解它需要做什么。
- en: '[PRE71]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: (missing answer)(missing answer)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[PRE72]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: (missing answer)(missing answer)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[PRE73]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: (missing answer)(missing answer)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[PRE74]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: (missing answer)(missing answer)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This reading is about modeling problems and implementing systems with *immutable
    data* and operations that implement *pure functions*, as opposed to *mutable data*
    and operations with *side effects*. *Functional programming* is the name for this
    style of programming.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍的是用 *不可变数据* 和实现 *纯函数* 的操作来对问题建模和实现系统，而不是使用 *可变数据* 和具有 *副作用* 的操作。*函数式编程*
    就是这种编程风格的名称。
- en: Functional programming is much easier to do when you have *first-class functions*
    in your language and you can build *higher-order functions* that abstract away
    control flow code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的语言中有 *一等函数* 并且你可以构建抽象控制流代码的 *高阶函数* 时，函数式编程就变得更容易了。
- en: Some languages — [Haskell](http://www.haskell.org/), [Scala](http://www.scala-lang.org/),
    [OCaml](http://ocaml.org/) — are strongly associated with functional programming.
    Many other languages — [JavaScript](https://developer.mozilla.org/en-US/docs/JavaScript),
    [Swift](https://developer.apple.com/swift/), [several](http://msdn.microsoft.com/en-us/library/67ef8sbd.aspx)
    [.NET](http://fsharp.org) [languages](http://msdn.microsoft.com/en-us/vstudio/hh388573.aspx),
    [Ruby](http://www.ruby-lang.org/), and so on — use functional programming to a
    greater or lesser extent. With Java’s recently-added functional language features,
    if you continue programming in Java you should expect to see more functional programming
    there, too.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言 — [Haskell](http://www.haskell.org/)、[Scala](http://www.scala-lang.org/)、[OCaml](http://ocaml.org/)
    — 与函数式编程紧密相关。许多其他语言 — [JavaScript](https://developer.mozilla.org/en-US/docs/JavaScript)、[Swift](https://developer.apple.com/swift/)、[几种](http://msdn.microsoft.com/en-us/library/67ef8sbd.aspx)
    [.NET](http://fsharp.org) [语言](http://msdn.microsoft.com/en-us/vstudio/hh388573.aspx)、[Ruby](http://www.ruby-lang.org/)
    等 — 在不同程度上使用函数式编程。随着 Java 最近增加的函数式语言特性，如果你继续在 Java 中编程，你也应该预期在那里看到更多的函数式编程。
