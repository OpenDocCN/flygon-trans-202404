- en: 非同期処理:Promise/Async Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/async/](https://jsprimer.net/basic/async/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: この章ではJavaScriptの非同期処理について学んでいきます。 非同期処理はJavaScriptにおけるとても重要な概念です。 また、ブラウザやNode.jsなどのAPIには非同期処理でしか扱えないものもあるため、非同期処理を避けることはできません。
    JavaScriptには非同期処理を扱うためのPromiseというビルトインオブジェクト、さらにはAsync Functionと呼ばれる構文的なサポートがあります。
  prefs: []
  type: TYPE_NORMAL
- en: この章では非同期処理とはどのようなものかという話から、非同期処理での例外処理、非同期処理の扱い方を見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#sync-processing)*同期処理*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*多くのプログラミング言語にはコードの評価の仕方として、**同期処理**（sync）と**非同期処理**（async）という大きな分類があります。'
  prefs: []
  type: TYPE_NORMAL
- en: 今まで書いていたコードは**同期処理**と呼ばれているものです。 同期処理ではコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。
    同期処理では実行している処理はひとつだけとなるため、とても直感的な動作となります。
  prefs: []
  type: TYPE_NORMAL
- en: 一方、同期的にブロックする処理が行われていた場合には問題があります。 同期処理ではひとつの処理が終わるまで、次の処理へ進むことができないためです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`blockTime`関数は指定した`timeout`ミリ秒だけ無限ループを実行し、同期的にブロックする処理です。 `timeout`ミリ秒経過したかの判定には、無限ループの中でUnix時間（1970年1月1日午前0時0分0秒から経過した時間）のミリ秒を返す`Date.now`メソッドを利用しています。
    この`blockTime`関数を呼び出すと、指定時間が経過するまで次の処理（タスクB）は呼ばれません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 同期的にブロックする処理があると、ブラウザでは大きな問題となります。 なぜなら、JavaScriptは基本的にブラウザのメインスレッド（UIスレッドとも呼ばれる）で実行されるためです。
    メインスレッドは表示の更新といったUIに関する処理も行っています。 そのため、メインスレッドがJavaScriptの処理で専有されると、表示が更新されなくなりフリーズしたようになります。
  prefs: []
  type: TYPE_NORMAL
- en: '![single-thread-tasks](../Images/ea2de27ccec75c73dbf81a75015f0ab8.png)'
  prefs: []
  type: TYPE_IMG
- en: 先ほどの例では1秒間も処理をブロックしているため、1秒間スクロールなどの操作が効かないといった悪影響がでます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#async-processing)*非同期処理*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を評価します。 つまり、非同期処理では同時に実行している処理が複数あります。'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptにおいて非同期処理の代表的な関数として`setTimeout`関数があります。 `setTimeout`関数は`delay`ミリ秒後に、`コールバック関数`を呼び出すようにタイマーへ登録する非同期処理です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは、見た目上はタスクA → 非同期のタスク → タスクBという流れになっています。 しかし、`setTimeout`関数を使い、非同期のタスクは1000ミリ秒（1秒）後に実行するようにタイマーへ登録しています。
    そのため、実際にはタスクA → タスクB → 非同期のタスクという順番で実行されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: このように、非同期処理（`setTimeout`のコールバック関数）は、コードの見た目上の並びとは異なる順番で実行されることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '![非同期処理とタイマー](../Images/7c4cf9a7c958c70e85a0602203d1afc1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[](#async-and-main-thread)*非同期処理はメインスレッドで実行される*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*メインスレッドはUIスレッドとも呼ばれ、重たいJavaScriptの同期処理はメインスレッドで実行する他の処理（画面の更新など）をブロックする問題について紹介しました。
    これは非同期処理においても同様の問題があります。なぜならJavaScriptにおける非同期処理の大部分はメインスレッドで実行されるためです。'
  prefs: []
  type: TYPE_NORMAL
- en: 非同期処理は名前から考えるとメインスレッド以外で実行されるように見えますが、 基本的には非同期処理も同期処理と同じようにメインスレッドで実行されます。
    このセクションでは非同期処理がどのようにメインスレッドで実行されているかを簡潔に見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードは、`setTimeout`関数でタイマーに登録したコールバック関数が呼ばれるまで、実際にどの程度の時間がかかったかを計測しています。 `setTimeout`関数で10ミリ秒後に非同期のタスクを実行するように登録し、その直後に1秒間を同期的にブロックする処理を呼び出しています。
    このコードを実行してみると、同期的にブロックする処理により、非同期のタスクはタイマーに登録した時間（10ミリ秒後）よりも大きく遅れて呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 非同期処理（`setTimeout`のコールバック関数）がメインスレッド以外のスレッドで実行されるならば、 この非同期処理はメインスレッドで同期的にブロックする処理の影響を受けないはずです。
    しかし、実際にはこの非同期処理もメインスレッドで実行された同期的にブロックする処理の影響を受けます。
  prefs: []
  type: TYPE_NORMAL
- en: 多くの環境では、このときの非同期処理のコールバック関数が呼ばれるまでは1秒以上かかります。 これは、10ミリ秒後に非同期のコールバック関数を実行するようにタイマーへ登録自体はできていますが、同期的にブロックする処理によって非同期のタスクの実行も後ろにずれてしまうためです。
    このように**非同期処理**も**同期処理**の影響を受けることから、同じメインスレッドで実行されていることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '![非同期処理とブロックする同期処理](../Images/08ac12ef96bd2d65a0790af3d9e3cc26.png)'
  prefs: []
  type: TYPE_IMG
- en: JavaScriptでは一部の例外を除き非同期処理が**並行処理（Concurrent）**として扱われます。 並行処理とは、処理を一定の単位ごとに分けて処理を切り替えながら実行することです。
    そのため非同期処理の実行前にとても重たい処理があると、非同期処理の実行が遅れるという現象を引き起こします。
  prefs: []
  type: TYPE_NORMAL
- en: ただし、非同期処理の中にもメインスレッドとは別のスレッドで実行できるAPIが実行環境によっては存在します。 たとえばブラウザでは[Web Worker](https://developer.mozilla.org/ja/docs/Web/API/Web_Workers_API/Using_web_workers)
    APIを使い、メインスレッド以外でJavaScriptを実行できます。 このWeb Workerにおける非同期処理は**並列処理（Parallel）**です。
    並列処理とは、排他的に複数の処理を同時に実行することです。
  prefs: []
  type: TYPE_NORMAL
- en: Web Workerではメインスレッドとは異なるWorkerスレッドで実行されるため、Workerスレッド内で同期的にブロックする処理を実行してもメインスレッドは影響を受けにくくなります。
    ただし、Web Workerとメインスレッドでのデータのやり取りには`postMessage`というメソッドを利用する必要があります。 そのため、重たい処理をWorkerに移動できるというメリットはありますが、メインスレッドとWorkerスレッドのデータのやり取りに制限があるというトレードオフの関係になります。
  prefs: []
  type: TYPE_NORMAL
- en: このように、非同期処理のすべてをひとくくりにはできませんが、基本的な非同期処理（タイマーなど）はメインスレッドで実行されているという性質を知ることは大切です。JavaScriptの大部分の**非同期処理**は**非同期的なタイミングで実行される処理**であると理解しておく必要があります。
    この書籍で紹介する非同期処理のほとんどは、メインスレッドで処理を切り替えながら実行する**並行処理（Concurrent）**となっています。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#async-processing-and-error-handling)*非同期処理と例外処理*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*非同期処理は処理の流れが同期処理とは異なることについて紹介しました。 これは非同期処理における**例外処理**においても大きな影響を与えます。'
  prefs: []
  type: TYPE_NORMAL
- en: 同期処理では、`try...catch`構文を使うことで同期的に発生した例外がキャッチできます（詳細は「[例外処理](../error-try-catch/)」の章を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 非同期処理では、`try...catch`構文を使っても非同期的に発生した例外をキャッチできません。 次のコードでは、10ミリ秒後に非同期的なエラーを発生させています。
    しかし、`try...catch`構文では次のような非同期エラーをキャッチできません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`try`ブロックはそのブロック内で発生した例外をキャッチする構文です。 しかし、`setTimeout`関数で登録されたコールバック関数が実際に実行されて例外を投げるのは、すべての同期処理が終わった後となります。
    つまり、`try`ブロックで例外が発生しうるとマークした**範囲外**で例外が発生します。'
  prefs: []
  type: TYPE_NORMAL
- en: そのため、`setTimeout`関数のコールバック関数における例外は、次のようにコールバック関数内で同期的なエラーとしてキャッチする必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: このようにコールバック関数内でエラーをキャッチできますが、**非同期処理の外**からは**非同期処理の中**で例外が発生したかがわかりません。 非同期処理の外から例外が起きたことを知るためには、非同期処理の中で例外が発生したことを非同期処理の外へ伝える方法が必要です。
  prefs: []
  type: TYPE_NORMAL
- en: また、JavaScriptでのHTTPリクエストやファイルの読み書きといった処理も非同期処理のAPIとして提供されています。 これらの非同期処理はネットワークにつながっていない場合やファイルが存在しない場合などには失敗します。
    そのため、非同期処理における例外の扱い方（エラーハンドリング）は、極めて重要になります。
  prefs: []
  type: TYPE_NORMAL
- en: 非同期処理で発生した例外の扱い方についてはさまざまなパターンがあります。 この章では主要な非同期処理と例外の扱い方として、主にPromise、Async
    Functionの2つを見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: Async FunctionはPromiseの上に成り立っている構文です。 そのため、どちらか片方ではなく両方とも理解することが重要です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#promise)*[ES2015] Promise*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*[Promise](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise)はES2015で導入された非同期処理の状態や結果を表現するビルトインオブジェクトです。
    非同期処理はPromiseのインスタンスを返し、そのPromiseインスタンスには状態変化をした際に呼び出されるコールバック関数を登録できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードは、Promiseを扱う非同期処理を行う例です。 このコードは、大きく分けて2つの部分からなっています。
  prefs: []
  type: TYPE_NORMAL
- en: '非同期処理をする部分（`asyncPromiseTask`関数）: Promiseのインスタンスを返す'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '非同期処理の結果を扱う部分: Promiseのインスタンスを受け取り、成功時の処理と失敗時の処理をコールバック関数で登録する'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`asyncPromiseTask`関数は、`Promise`というビルトインオブジェクトのインスタンスを返しています。 `Promise`インスタンスは、`asyncPromiseTask`関数内で行った非同期処理が成功したか失敗したかの状態を表すオブジェクトです。
    また、この`Promise`インスタンスに対して、`then`や`catch`メソッドで成功時や失敗時に呼び出される処理をコールバック関数として登録することで、非同期処理の結果を扱えます。'
  prefs: []
  type: TYPE_NORMAL
- en: Promiseに慣れるまで少しややこしいように見えますが、Promiseは非同期処理の状態や結果をラップしたようなオブジェクトです。 同期的な関数では関数を実行するとすぐ結果がわかりますが、非同期な関数では関数を実行してもすぐには結果がわかりません。
    そのため、非同期な関数はPromiseという非同期処理の状態をラップしたオブジェクトを返し、その結果が決まったら登録しておいたコールバック関数へ結果を渡すという仕組みになっています。
  prefs: []
  type: TYPE_NORMAL
- en: 実際に`Promise`の使い方をみていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#promise-instance)*`Promise`インスタンスの作成*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Promiseは`new`演算子で`Promise`のインスタンスを作成して利用します。 このときのコンストラクタには`resolve`と`reject`の2つの引数を取る`executor`と呼ばれる関数を渡します。
    `executor`関数の中で非同期処理を行い、非同期処理が成功した場合は`resolve`関数を呼び、失敗した場合は`reject`関数を呼び出します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: この`Promise`インスタンスの`then`メソッドで、Promiseが`resolve`（成功）、`reject`（失敗）したときに呼ばれるコールバック関数を登録します。
    `then`メソッドの第一引数には`resolve`（成功）時に呼ばれるコールバック関数、第二引数には`reject`（失敗）時に呼ばれるコールバック関数を渡します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise`コンストラクタの`resolve`と`reject`、`then`メソッドの`onFulfilled`と`onRejected`は次のような関係となります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`resolve`（成功）したとき'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onFulfilled`が呼ばれる'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reject`（失敗）したとき'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRejected` が呼ばれる'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](#promise-then-and-catch)*`Promise.prototype.then`と`Promise.prototype.catch`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Promise`のようにコンストラクタに関数を渡すパターンは今までなかったので、`then`メソッドの使い方について具体的な例を紹介します。 また、`then`メソッドのエイリアスでもある`catch`メソッドについても見ていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`dummyFetch`関数は`Promise`のインスタンスを作成して返します。 `dummyFetch`関数はリソースの取得に成功した場合は`resolve`関数を呼び、失敗した場合は`reject`関数を呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: '`resolve`に渡した値は、`then`メソッドの1番目のコールバック関数（`onFulfilled`）に渡されます。 `reject`に渡したエラーオブジェクトは、`then`メソッドの2番目のコールバック関数（`onRejected`）に渡されます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Promiseの`then`メソッドは成功（`onFulfilled`）と失敗（`onRejected`）のコールバック関数の2つを受け取りますが、どちらの引数も省略できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`delay`関数は一定時間後に解決（`resolve`）される`Promise`インスタンスを返します。 この`Promise`インスタンスに対して`then`メソッドで**成功時のコールバック関数だけ**を登録しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 一方、`then`メソッドでは失敗時のコールバック関数だけの登録もできます。 このとき`then(undefined, onRejected)`のように第1引数には`undefined`を渡す必要があります。
    `then(undefined, onRejected)`と同様のことを行う方法としてPromiseの`catch`メソッドが用意されています。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは`then`メソッドと`catch`メソッドで失敗時のエラー処理をしていますが、どちらも同じ意味となります。 `then`メソッドに`undefined`を渡すのはわかりにくいため、失敗時の処理だけを登録する場合は`catch`メソッドの利用を推奨しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[](#promise-exception)*Promiseと例外*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Promiseではコンストラクタの処理で例外が発生した場合に自動的に例外がキャッチされます。 例外が発生した`Promise`インスタンスは`reject`関数を呼び出したのと同じように失敗したものとして扱われます。
    そのため、Promise内で例外が発生すると`then`メソッドの第二引数や`catch`メソッドで登録したエラー時のコールバック関数が呼び出されます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: このようにPromiseにおける処理では`try...catch`構文を使わなくても、自動的に例外がキャッチされます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#promise-status)*Promiseの状態*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Promiseの`then`メソッドや`catch`メソッドによる処理がわかったところで、`Promise`インスタンスの状態について整理していきます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise`インスタンスには、内部的に次の3つの状態が存在します。'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fulfilled**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resolve`（成功）したときの状態。このとき`onFulfilled`が呼ばれる'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reject`（失敗）または例外が発生したときの状態。このとき`onRejected`が呼ばれる'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pending**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FulfilledまたはRejectedではない状態
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Promise`でインスタンスを作成したときの初期状態'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: これらの状態はECMAScriptの仕様として決められている内部的な状態です。 しかし、この状態をPromiseのインスタンスから取り出す方法はありません。
    そのためAPIとしてこの状態を直接扱うことはできませんが、Promiseについて理解するのに役立ちます。
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise`インスタンスの状態は作成時に**Pending**となり、一度でも**Fulfilled**または**Rejected**へ変化すると、それ以降状態は変化しなくなります。
    そのため、**Fulfilled**または**Rejected**の状態であることを**Settled**（不変）と呼びます。'
  prefs: []
  type: TYPE_NORMAL
- en: 一度でも**Settled**（**Fulfilled**または**Rejected**）となった`Promise`インスタンスは、それ以降別の状態には変化しません。
    そのため、`resolve`を呼び出した後に`reject`を呼び出しても、その`Promise`インスタンスは最初に呼び出した`resolve`によって**Fulfilled**のままとなります。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`reject`を呼び出しても状態が変化しないため、`then`で登録したonRejectedのコールバック関数は呼び出されません。 `then`メソッドで登録したコールバック関数は、状態が変化した場合に一度だけ呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 同じように、`Promise`コンストラクタ内で`resolve`を何度呼び出しても、その`Promise`インスタンスの状態は一度しか変化しません。
    そのため、次のように`resolve`を何度呼び出しても、`then`で登録したコールバック関数は一度しか呼び出されません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: このように`Promise`インスタンスの状態が変化したときに、一度だけ呼ばれるコールバック関数を登録するのが`then`や`catch`メソッドとなります。
  prefs: []
  type: TYPE_NORMAL
- en: また`then`や`catch`メソッドはすでにSettledへと状態が変化済みの`Promise`インスタンスに対してもコールバック関数を後から登録できます。
    状態が変化済みの`Promise`インスタンスに`then`や`catch`メソッドで登録したコールバック関数も同じように非同期処理として呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: 具体的にどうなるかを、状態が変化済みの`Promise`インスタンスを作成できる`Promise.resolve`と`Promise.reject`メソッドと一緒に見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#promise-resolve)*`Promise.resolve`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Promise.resolve`メソッドは**Fulfilled**の状態となった`Promise`インスタンスを作成します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.resolve`メソッドは`new Promise`の糖衣構文（シンタックスシュガー）です。 糖衣構文とは、同じ意味の処理を元の構文よりシンプルに書ける別の書き方のことです。
    `Promise.resolve`メソッドは次のコードの糖衣構文です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.resolve`メソッドは引数に`resolve`される値を渡すこともできます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.resolve`メソッドで作成した**Fulfilled**の状態となった`Promise`インスタンスに対しても`then`メソッドでコールバック関数を登録できます。
    状態が変化済みの`Promise`インスタンスに`then`メソッドで登録したコールバック関数は、常に非同期なタイミングで実行されます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードを実行すると、すべての同期的な処理が実行された後に、`then`メソッドのコールバック関数が非同期なタイミングで実行されることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.resolve`メソッドは`new Promise`の糖衣構文であるため、この実行順序は`new Promise`を使った場合も同じです。
    次のコードは、先ほどの`Promise.resolve`メソッドを使ったものと同じ動作になります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: このコードを実行すると、まず`Promise`のコンストラクタ関数が実行され、続いて同期的な処理が実行されます。最後に`then`メソッドで登録していたコールバック関数が非同期的に呼ばれることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#promise-reject)*`Promise.reject`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Promise.reject`メソッドは **Rejected**の状態となった`Promise`インスタンスを作成します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.reject`メソッドは`new Promise`の糖衣構文（シンタックスシュガー）です。 そのため、`Promise.reject`メソッドは次のコードと同じ意味になります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.reject`メソッドで作成した**Rejected**状態の`Promise`インスタンスに対しても`then`や`catch`メソッドでコールバック関数を登録できます。
    **Rejected**状態へ変化済みの`Promise`インスタンスに登録したコールバック関数は、常に非同期なタイミングで実行されます。これは**Fulfilled**の場合と同様です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.resolve`や`Promise.reject`は短く書けるため、テストコードなどで利用されることがあります。 また、`Promise.reject`は次に解説するPromiseチェーンにおいて、Promiseの状態を操作するのに利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#promise-chain)*Promiseチェーン*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Promiseは非同期処理における統一的なインターフェースを提供するビルトインオブジェクトです。 Promiseによる統一的な処理方法は複数の非同期処理を扱う場合に特に効力を発揮します。
    これまでは、1つの`Promise`インスタンスに対して`then`や`catch`メソッドで1組のコールバック処理を登録するだけでした。'
  prefs: []
  type: TYPE_NORMAL
- en: 非同期処理が終わったら次の非同期処理というように、複数の非同期処理を順番に扱いたい場合もあります。 Promiseではこのような複数の非同期処理からなる一連の非同期処理を簡単に書く方法が用意されています。
  prefs: []
  type: TYPE_NORMAL
- en: この仕組みのキーとなるのが`then`や`catch`メソッドは常に新しい`Promise`インスタンスを作成して返すという仕様です。 そのため`then`メソッドの返り値である`Promise`インスタンスにさらに`then`メソッドで処理を登録できます。
    これはメソッドチェーンと呼ばれる仕組みですが、この書籍ではPromiseをメソッドチェーンでつなぐことを**Promiseチェーン**と呼びます（メソッドチェーンは「[配列](../array/#method-chain-and-high-order-function)」の章を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`then`メソッドでPromiseチェーンをしています。 Promiseチェーンでは、Promiseが失敗（**Rejected**な状態）しない限り、順番に`then`メソッドで登録した成功時のコールバック関数を呼び出します。
    そのため、次のコードでは、`1`、`2`と順番にコンソールへログが出力されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: このPromiseチェーンは、次のコードのように毎回新しい変数に入れて処理をつなげるのと結果的には同じ意味となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: もう少し具体的なPromiseチェーンの例を見ていきましょう。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`asyncTask`関数はランダムでFulfilledまたはRejected状態の`Promise`インスタンスを返します。 この関数が返す`Promise`インスタンスに対して、`then`メソッドで成功時の処理を書いています。
    `then`メソッドの返り値は新しい`Promise`インスタンスであるため、続けて`catch`メソッドで失敗時の処理を書けます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`asyncTask`関数が成功（resolve）した場合は`then`メソッドで登録した成功時の処理だけが呼び出され、`catch`メソッドで登録した失敗時の処理は呼び出されません。
    一方、`asyncTask`関数が失敗（reject）した場合は`then`メソッドで登録した成功時の処理は呼び出されずに、`catch`メソッドで登録した失敗時の処理だけが呼び出されます。'
  prefs: []
  type: TYPE_NORMAL
- en: 先ほどのコードにおけるPromiseの状態とコールバック関数は次のような処理の流れとなります。
  prefs: []
  type: TYPE_NORMAL
- en: '![promise-chain](../Images/8725c9e1178b5a8f4700fe3a8210c63b.png)'
  prefs: []
  type: TYPE_IMG
- en: Promiseの状態が**Rejected**となった場合は、もっとも近い失敗時の処理（`catch`または`then`の第二引数）が呼び出されます。
    このとき間にある成功時の処理（`then`の第一引数）はスキップされます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、**Rejected**のPromiseに対して`then` → `then` → `catch`とPromiseチェーンで処理を記述しています。
    このときもっとも近い失敗時の処理（`catch`）が呼び出されますが、間にある2つの成功時の処理（`then`）は実行されません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Promiseのコンストラクタの処理の場合と同様に、`then`や`catch`のコールバック関数内で発生した例外は自動的にキャッチされます。 例外が発生したとき、`then`や`catch`メソッドは**Rejected**な`Promise`インスタンスを返します。
    そのため、例外が発生するともっとも近くの失敗時の処理（`catch`または`then`の第二引数）が呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: また、Promiseチェーンで失敗を`catch`メソッドなどで一度キャッチすると、次に呼ばれるのは成功時の処理です。 これは、`then`や`catch`メソッドは**Fulfilled**状態のPromiseインスタンスを作成して返すためです。
    そのため、一度キャッチするとそこからは次の`then`で登録した処理が呼ばれるPromiseチェーンに戻ります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: このようにPromiseの`then`メソッドや`catch`メソッドをつないで、成功時や失敗時の処理を書いていくことをPromiseチェーンと呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#promise-chain-value)*Promiseチェーンで値を返す*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Promiseチェーンではコールバックで返した値を次のコールバックへ引数として渡せます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`then`や`catch`メソッドのコールバック関数は数値、文字列、オブジェクトなどの任意の値を返せます。 このコールバック関数が返した値は、次の`then`のコールバック関数へ引数として渡されます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: ここでは`then`メソッドを元に解説しますが、`catch`メソッドは`then`メソッドの糖衣構文であるため同じ動作となります。 Promiseチェーンで一度キャッチすると、次に呼ばれるのは成功時の処理となります。
    そのため、`catch`メソッドで返した値は次の`then`メソッドのコールバック関数に引数として渡されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[](#promise-then-return-promise)*コールバック関数で`Promise`インスタンスを返す*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Promiseチェーンで一度キャッチすると、次に呼ばれるのは成功時の処理（`then`メソッド）でした。 これは、コールバック関数で任意の値を返すと、その値で`resolve`された**Fulfilled**状態の`Promise`インスタンスを作成するためです。
    しかし、コールバック関数で`Promise`インスタンスを返した場合は例外的に異なります。'
  prefs: []
  type: TYPE_NORMAL
- en: コールバック関数で`Promise`インスタンスを返した場合は、同じ状態を持つ`Promise`インスタンスが`then`や`catch`メソッドの返り値となります。
    つまり`then`メソッドで**Rejected**状態の`Promise`インスタンスを返した場合は、次に呼ばれるのは失敗時の処理です。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`then`メソッドのコールバック関数で`Promise.reject`メソッドを使って**Rejected**な`Promise`インスタンスを返しています。
    **Rejected**な`Promise`インスタンスは、次の`catch`メソッドで登録した失敗時の処理を呼び出すまで、`then`メソッドの成功時の処理をスキップします。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: このコードにおけるPromiseの状態とコールバック関数は次のような処理の流れとなります。
  prefs: []
  type: TYPE_NORMAL
- en: '![then-rejected-promise.png](../Images/6694fa071bb3df0a84426ce082708c0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 通常は一度`catch`すると次に呼び出されるのは成功時の処理でした。 この`Promise`インスタンスを返す仕組みを使うことで、`catch`してもそのまま**Rejected**な状態を継続できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは`catch`メソッドでログを出力しつつ`Promise.reject`メソッドを使って**Rejected**な`Promise`インスタンスを返しています。
    これによって、`main`で発生したエラーのログを取りながら、Promiseチェーンはエラーのまま処理を継続できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[](#promise-finally)*[ES2018] Promiseチェーンの最後に処理を書く*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Promiseの`finally`メソッドは成功時、失敗時どちらの場合でも呼び出されるコールバック関数を登録できます。 `try...catch...finally`構文の`finally`節と同様の役割を持つメソッドです。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは、リソースを取得して`then`で成功時の処理、`catch`で失敗時の処理を登録しています。 また、リソースを取得中かどうかを判定するためのフラグを`isLoading`という変数で管理しています。
    成功失敗どちらにもかかわらず、取得が終わったら`isLoading`は`false`にします。 `then`と`catch`の両方で`isLoading`へ`false`を代入できますが、`finally`メソッドを使うことで代入を一箇所にまとめられます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[](#promise-sequential)*Promiseチェーンで逐次処理*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Promiseチェーンで非同期処理の流れを書く大きなメリットは、非同期処理のさまざまなパターンに対応できることです。'
  prefs: []
  type: TYPE_NORMAL
- en: ここでは、典型的な例として複数の非同期処理を順番に処理していく逐次処理を考えていきましょう。 Promiseで逐次的な処理といっても難しいことはなく、単純に`then`で非同期処理をつないでいくだけです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、Resource AとResource Bを順番に取得しています。 それぞれ取得したリソースを変数`results`に追加し、すべて取得し終わったらコンソールに出力します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[](#promise-all)*`Promise.all`で複数のPromiseをまとめる*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Promise.all`を使うことで複数のPromiseを使った非同期処理をひとつのPromiseとして扱えます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.all`メソッドは `Promise`インスタンスの配列を受け取り、新しい`Promise`インスタンスを返します。 その配列のすべての`Promise`インスタンスが**Fulfilled**となった場合は、返り値の`Promise`インスタンスも**Fulfilled**となります。
    一方で、ひとつでも**Rejected**となった場合は、返り値の`Promise`インスタンスも**Rejected**となります。'
  prefs: []
  type: TYPE_NORMAL
- en: 返り値の`Promise`インスタンスに`then`メソッドで登録したコールバック関数には、Promiseの結果をまとめた配列が渡されます。 このときの配列の要素の順番は`Promise.all`メソッドに渡した配列のPromiseの要素の順番と同じになります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 先ほどのPromiseチェーンでリソースを取得する例では、Resource Aを取得し終わってからResource Bを取得というように逐次的でした。
    しかし、Resource AとBどちらを先に取得しても問題ない場合は、`Promise.all`メソッドを使って複数のPromiseを1つのPromiseとしてまとめられます。
    また、Resource AとBを同時に取得すればより早い時間で処理が完了します。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、Resource AとBを同時に取得開始しています。 両方のリソースの取得が完了すると、`then`のコールバック関数にはAとBの結果が配列として渡されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 渡したPromiseがひとつでも**Rejected**となった場合は、失敗時の処理が呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[](#promise-race)*`Promise.race`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Promise.all`メソッドは複数のPromiseがすべて完了するまで待つ処理でした。 `Promise.race`メソッドでは複数のPromiseを受け取りますが、Promiseが1つでも完了した（Settled状態となった）時点で次の処理を実行します。'
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.race`メソッドは`Promise`インスタンスの配列を受け取り、新しい`Promise`インスタンスを返します。 この新しい`Promise`インスタンスは、配列の中で一番最初に**Settled**状態となった`Promise`インスタンスと同じ状態になります。'
  prefs: []
  type: TYPE_NORMAL
- en: 配列の中で一番最初に**Settled**となったPromiseが**Fulfilled**の場合は、新しい`Promise`インスタンスも**Fulfilled**になる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 配列の中で一番最初に**Settled**となったPromiseが**Rejected**の場合は、新しい`Promise`インスタンスも **Rejected**になる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: つまり、複数のPromiseによる非同期処理を同時に実行して競争（race）させて、一番最初に完了した`Promise`インスタンスに対する次の処理を呼び出します。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`delay`関数という`timeoutMs`ミリ秒後に**Fulfilled**となる`Promise`インスタンスを返す関数を定義しています。
    `Promise.race`メソッドは1ミリ秒、32ミリ秒、64ミリ秒、128ミリ秒後に完了する`Promise`インスタンスの配列を受け取っています。 この配列の中で一番最初に完了するのは、1ミリ秒後に**Fulfilled**となる`Promise`インスタンスです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: このときに、一番最初に`resolve`された値で`racePromise`も`resolve`されます。 そのため、`then`メソッドのコールバック関数に`1`という値が渡されます。
  prefs: []
  type: TYPE_NORMAL
- en: 他の`delay`関数が作成した`Promise`インスタンスも32ミリ秒、64ミリ秒、128ミリ秒後に`resolve`されます。 しかし、`Promise`インスタンスは一度**Settled**（**Fulfilled**または**Rejected**）となると、それ以降は状態も変化せず`then`のコールバック関数も呼び出しません。
    そのため、`racePromise`は何度も`resolve`されますが、初回以外は無視されるため`then`のコールバック関数は一度しか呼び出されません。
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.race`メソッドを使うことでPromiseを使った非同期処理のタイムアウトが実装できます。 ここでのタイムアウトとは、一定時間経過しても処理が終わっていないならエラーとして扱う処理のことです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは`timeout`関数と`dummyFetch`関数が返す`Promise`インスタンスを`Promise.race`メソッドで競争させています。
    `dummyFetch`関数ではランダムな時間をかけてリソースを取得し`resolve`する`Promise`インスタンスを返します。 `timeout`関数は指定ミリ秒経過すると`reject`する`Promise`インスタンスを返します。
  prefs: []
  type: TYPE_NORMAL
- en: この2つの`Promise`インスタンスを競争させて、`dummyFetch`が先に完了すれば処理は成功、`timeout`が先に完了すれば処理は失敗というタイムアウト処理が実現できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: このようにPromiseを使うことで非同期処理のさまざまなパターンが形成できます。 より詳しいPromiseの使い方については「[JavaScript
    Promiseの本](https://azu.github.io/promises-book/)」というオンラインで公開されている文書にまとめられています。
  prefs: []
  type: TYPE_NORMAL
- en: 一方で、Promiseはただのビルトインオブジェクトであるため、非同期処理間の連携をするにはPromiseチェーンのように少し特殊な書き方や見た目になります。
    また、エラーハンドリングについてもPromiseの`catch`メソッドや`finally`メソッドなど`try...catch`構文とよく似た名前を使います。
    しかし、Promiseは構文ではなくただのオブジェクトであるため、それらをメソッドチェーンとして実現しないといけないといった制限があります。
  prefs: []
  type: TYPE_NORMAL
- en: ES2017では、このPromiseチェーンの不格好な見た目を解決するためにAsync Functionと呼ばれる構文が導入されました。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#async-function)*[ES2017] Async Function*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ES2017では、Async Functionという非同期処理を行う関数を定義する構文が導入されました。 Async Functionは通常の関数とは異なり、必ず`Promise`インスタンスを返す関数を定義する構文です。'
  prefs: []
  type: TYPE_NORMAL
- en: Async Functionは次のように関数の前に`async`をつけることで定義できます。 この`doAsync`関数は常に`Promise`インスタンスを返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: このAsync Functionは次のように書いた場合と同じ意味になります。 Async Functionでは`return`した値の代わりに、`Promise.resolve(返り値)`のように返り値をラップした`Promise`インスタンスを返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 重要なこととしてAsync FunctionはPromiseの上に作られた構文です。 そのためAsync Functionを理解するには、Promiseを理解する必要があることに注意してください。
  prefs: []
  type: TYPE_NORMAL
- en: またAsync Function内では`await`式というPromiseの非同期処理が完了するまで待つ構文が利用できます。 `await`式を使うことで非同期処理を同期処理のように扱えるため、Promiseチェーンで実現していた処理の流れを読みやすく書けます。
  prefs: []
  type: TYPE_NORMAL
- en: このセクションではAsync Functionと`await`式について見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#declare-async-function)*Async Functionの定義*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Async Functionは関数の定義に`async`キーワードをつけることで定義できます。 JavaScriptの関数定義には関数宣言や関数式、Arrow
    Function、メソッドの短縮記法などがあります。 どの定義方法でも`async`キーワードを前につけるだけでAsync Functionとして定義できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: これらのAsync Functionは、次の点以外は通常の関数と同じ性質を持ちます。
  prefs: []
  type: TYPE_NORMAL
- en: Async Functionは必ず`Promise`インスタンスを返す
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async Function内では`await`式が利用できる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](#async-function-return-promise)*Async FunctionはPromiseを返す*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Async Functionとして定義した関数は必ず`Promise`インスタンスを返します。 具体的にはAsync Functionが返す値は次の3つのケースが考えられます。'
  prefs: []
  type: TYPE_NORMAL
- en: Async Functionが値をreturnした場合、その返り値を持つ**Fulfilled**なPromiseを返す
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Async FunctionがPromiseをreturnした場合、その返り値のPromiseをそのまま返す
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Async Function内で例外が発生した場合は、そのエラーを持つ**Rejected**なPromiseを返す
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 次のコードでは、Async Functionがそれぞれの返り値によってどのような`Promise`インスタンスを返すかを確認できます。 この1から3の挙動は、Promiseの`then`メソッドの返り値とそのコールバック関数の関係とほぼ同じです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: どの場合でもAsync Functionは必ずPromiseを返すことがわかります。 このようにAsync Functionを呼び出す側から見れば、Async
    FunctionはPromiseを返すただの関数と何も変わりません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#await-expression)*`await`式*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`await`式は次の箇所で利用できる式です。 次の箇所以外では`await`式は構文エラーとなるため、利用できません。'
  prefs: []
  type: TYPE_NORMAL
- en: Async Functionの関数の直下
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScriptモジュールの直下
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: まず最初に、一般的に使われるAsync Functionの関数の直下における`await`式を見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '`await`式は右辺の`Promise`インスタンスが**Fulfilled**または**Rejected**になるまでその場で非同期処理の完了を待ちます。
    そして`Promise`インスタンスの状態が変わると、次の行の処理を再開します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 普通の処理の流れでは、非同期処理を実行した場合にその非同期処理の完了を待つことなく、次の行（次の文）を実行します。 しかし`await`式では非同期処理を実行して完了するまで、次の行（次の文）を実行しません。
    そのため`await`式を使うことで非同期処理が同期処理のように上から下へと順番に実行するような処理順で書けます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`await`式は、`await`の右辺（`Promise`インスタンス）の評価結果を値として返します（**式**については「[文と式](../statement-expression/)」の章を参照）。
    この`await`式の評価方法は評価するPromiseの状態（**Fulfilled**または**Rejected**）によって異なります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`await`の右辺のPromiseが**Fulfilled**となった場合は、resolveされた値が`await`式の返り値となります。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`await`の右辺にある`Promise`インスタンスは`42`という値でresolveされています。 そのため`await`式の返り値は`42`となり、`value`変数にもその値が入ります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: これはPromiseを使って書くと次のコードと同様の意味となります。 `await`式を使うことでコールバック関数を使わずに非同期処理の流れを表現できていることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`await`式の右辺のPromiseが**Rejected**となった場合は、その場でエラーを`throw`します。 またAsync Function内で発生した例外は自動的にキャッチされます。
    そのため`await`式でPromiseが**Rejected**となった場合は、そのAsync Functionが**Rejected**なPromiseを返すことになります。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`await`の右辺にある`Promise`インスタンスが**Rejected**の状態になっています。 そのため`await`式は`エラー`を`throw`します。そのエラーを自動的にキャッチするため`asyncMain`関数は**Rejected**なPromiseを返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`await`式がエラーを`throw`するということは、そのエラーは`try...catch`構文でキャッチできます（詳細は「[例外処理](../error-try-catch/)」の章の「[try...catch構文](../error-try-catch/#try-catch)」を参照）。
    通常の非同期処理では完了する前に次の行が実行されてしまうため`try...catch`構文ではエラーをキャッチできませんでした。 そのためPromiseでは`catch`メソッドを使ってPromise内で発生したエラーをキャッチしていました。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`await`式で発生した例外を`try...catch`構文でキャッチしています。 そのため、`asyncMain`関数はResolvedなPromiseを返し、`catch`メソッドのコールバック関数は呼び出されません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: このように`await`式を使うことで、`try...catch`構文のように非同期処理を同期処理と同じ構文を使って扱えます。 またコードの見た目も同期処理と同じように、その行（その文）の処理が完了するまで次の行を評価しないという分かりやすい形になるのは大きな利点です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#promise-chain-to-async-function)*Promiseチェーンを`await`式で表現する*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Async Functionと`await`式を使うことでPromiseチェーンとして表現していた非同期処理を同期処理のような見た目で書けます。 まずは、Promiseチェーンで複数の非同期処理を逐次的に行うケースを見ていきます。
    その後に、同様の処理をAsync Functionと`await`式で書き直して比較してみます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`fetchAB`関数はリソースAとリソースBを順番に取得する処理をPromiseチェーンで書いています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 同様の処理をAsync Functionと`await`式で書くと次のように書けます。 `await`式を使ってリソースが取得できるまで待ち、その結果を変数`results`に追加していくという形で逐次処理が実装できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Promiseチェーンで`fetchAB`関数を書いた場合は、コールバックの中で処理するためややこしい見た目になりがちです。 一方、Async Functionと`await`式で書いた場合は、取得と追加を順番に行うだけとなり、ネストがなく、見た目はシンプルです。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#async-function-combination)*Async Functionと組み合わせ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*これまでで基本的なAsync Functionの動きを見てきましたが、他の構文やPromise APIと組み合わせたAsync Functionの使い方を見ていきましょう。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#async-function-array)*Async Functionと反復処理*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*複数の非同期処理を行う際に、Async Functionはforループなどの反復処理と組み合わせることが可能です。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、指定したリソースのパスの配列を渡してそれらを順番に取得する`fetchResources`関数を実装しています。 Async Function内でfor文を使った反復処理を行い、forループの中で`await`文を使ってリソースの取得を待ち、その結果を追加しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Async Functionでは、非同期処理であってもforループのような既存の構文と組み合わせて利用することが簡単です。 Promiseのみの場合は、Promiseチェーンでコールバック関数を使った反復処理を実装する必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#relationship-promise-async-function)*Promise APIとAsync Functionを組み合わせる*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Async Functionと`await`式を使うことで、非同期処理を同期処理のような見た目で書けます。 一方で同期処理のような見た目となるため、複数の非同期処理を反復処理する場合に無駄な待ち時間を作ってしまうコードを書きやすくなります。'
  prefs: []
  type: TYPE_NORMAL
- en: 先ほどの`fetchResources`関数ではリソースを順番に1つずつ取得していました。 たとえば、リソースAとBを取得しようとした場合にかかる時間は、リソースAとBの取得時間の合計となります。
    このとき、リソースAに1秒、リソースBに2秒かかるとした場合、すべてのリソースを取得するのに3秒かかります。
  prefs: []
  type: TYPE_NORMAL
- en: 取得する順番に意味がない場合は、複数のリソースを同時に取得することで余計な待ち時間を解消できます。 先ほどの例ならば、リソースAとBを同時に取得すれば、最大でもリソースBの取得にかかる2秒程度ですべてのリソースが取得できるはずです。
  prefs: []
  type: TYPE_NORMAL
- en: Promiseチェーンでは`Promise.all`メソッドを使って、複数の非同期処理を1つの`Promise`インスタンスにまとめることで同時に取得していました。
    `await`式が評価するのは`Promise`インスタンスであるため、`await`式も`Promise.all`メソッドと組み合わせて利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`Promise.all`メソッドとAsync Functionを組み合わせて、同時にリソースを取得する`fetchAllResources`関数を実装しています。
    `Promise.all`メソッドは複数のPromiseを配列で受け取り、それを1つのPromiseとしてまとめたものを返す関数です。 `Promise.all`メソッドの返す`Promise`インスタンスを`await`することで、非同期処理の結果を配列としてまとめて取得できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: このようにAsync Functionや`await`式は既存のPromise APIと組み合わせて利用できます。 Async Functionも内部的にPromiseの仕組みを利用しているため、両者は対立関係ではなく共存関係になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#await-in-async-function)*`await`式はAsync Functionの直下でのみ利用可能*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Async Functionで`await`式を利用する際には、`await`式が関数の直下でのみ利用可能な点に注意が必要です。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードのように、Async Functionではない通常の関数で`await`式を使うと構文エラー（`SyntaxError`）となります。 これは、間違った`await`式の使い方を防止するための仕様です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Async Function内で`await`式を使って処理を待っている間も、関数の外側では通常どおり処理が進みます。 次のコードを実行してみると、Async
    Function内で`await`しても、Async Function外の処理は停止していないことがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: このように`await`式でAsync Function内の非同期処理を一時停止しても、Async Function外の処理が停止するわけではありません。
    Async Function外の処理も停止できてしまうと、JavaScriptでは基本的にメインスレッドで多くの処理をするため、UIを含めた他の処理が止まってしまいます。
    これが`await`式がAsync Functionの外で利用できない理由の1つです。
  prefs: []
  type: TYPE_NORMAL
- en: この仕様は、Async Functionをコールバック関数内で利用しようとしたときに混乱を生む場合があります。 具体例として、先ほどの逐次的にリソースを取得する`fetchResources`関数を見てみます。
  prefs: []
  type: TYPE_NORMAL
- en: 先ほどの`fetchResources`関数ではforループと`await`式を利用していました。 このときにforループの代わりにArrayの`forEach`メソッドは利用できません。
  prefs: []
  type: TYPE_NORMAL
- en: 単純に`fetchResources`関数のforループから`Array`の`forEach`メソッドに書き換えてみると、構文エラー（`SyntaxError`）が発生してしまいます。
    これは`await`式がAsync Functionの中でのみ利用ができる構文であるためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: そのため、Arrayの`forEach`メソッドのコールバック関数もAsync Functionとして定義しないと、コールバック関数では`await`式が利用できません。
  prefs: []
  type: TYPE_NORMAL
- en: この構文エラーはArrayの`forEach`メソッドのコールバック関数をAsync Functionにすることで解決できます。 しかし、コールバック関数をAsync
    Functionにしただけでは、`fetchResources`関数は常に空の配列で解決されるPromiseを返すという意図しない挙動となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: なぜこのようになるかを`fetchResources`関数の動きを見てみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach`メソッドのコールバック関数としてAsync Functionを渡し、コールバック関数中で`await`式を利用して非同期処理の完了を待っています。
    しかし、この非同期処理の完了を待つのはコールバック関数Async Functionの中だけで、コールバック関数の外側では`fetchResources`関数の処理が進んでいます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のように`fetchResources`関数にコンソールログを入れてみると動作がわかりやすいでしょう。 `forEach`メソッドのコールバック関数が完了するのは、`fetchResources`関数の呼び出しがすべて終わった後になります。
    そのため、`forEach`メソッドのコールバック関数でリソースの取得が完了する前に、`fetchResources`関数はその時点の`results`である空の配列で解決してしまいます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: このように、Async Functionとコールバック関数を組み合わせた場合には気をつける必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: この問題を解決する方法として、最初の`fetchResources`関数のように、コールバック関数を使わずにすむforループと`await`式を組み合わせる方法があります。
    また、`fetchAllResources`関数のように、複数の非同期処理を1つのPromiseにまとめることでループ中に`await`式を使わないようにする方法があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#top-level-await-in-module)*[ES2022] Module直下での`await`式*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ES2021までは、`await`式はAsync Functionの直下でのみ利用可能なことを紹介しました。 ES2022では、これに加えてModuleの直下ではAsync
    Functionで囲まなくても`await`式が利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 最初に「[JavaScriptとは](../introduction/)」の章において、JavaScriptには実行コンテキストとして"Script"と"Module"があるという話をしました。
    たとえば、ブラウザでは`<script>`と書けば"Script"として実行され、`<script type="module">`と書けば"Module"として実行されます。
  prefs: []
  type: TYPE_NORMAL
- en: '"Module"としてJavaScriptを実行した時のみ、トップレベル（もっとも外側のスコープ）においてはAsync Functionなしで`await`式が利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: たとえば、次のコードを"Module"として実行した場合は、Async Functionなしで`await`式が利用できていることがわかります。 これは、"Module"ではトップレベルでの`await`が許可されているためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: このようにModuleのトップレベルにおいて`await`式が利用できることは、Top-Level `await`と呼ばれます。
  prefs: []
  type: TYPE_NORMAL
- en: ES2021まではAsync Functionの直下のみでしか`await`式が利用できませんでした。 そのため、メイン処理のように他の処理を呼び出すスクリプトの開始地点で`await`を使いたい場合は、Async
    Functionを使った即時実行関数で`await`を囲むケースがありました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: しかし、ES2022ではTop-Level `await`が利用できるようになったため、"Module"においてはこのような即時実行関数は不要となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#error-first-callback)*[コラム] エラーファーストコールバック*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ECMAScript 2015（ES2015）でPromiseが仕様に入るまで、非同期処理中に発生した例外を扱う仕様はありませんでした。 このため、ES2015より前までは、**エラーファーストコールバック**という非同期処理中に発生した例外を扱う方法をコミュニティで決めたルールが広く使われていました。'
  prefs: []
  type: TYPE_NORMAL
- en: エラーファーストコールバックとは、非同期処理におけるコールバック関数の呼び出し方を決めた次のようなルールです。
  prefs: []
  type: TYPE_NORMAL
- en: 処理が失敗した場合は、コールバック関数の1番目の引数にエラーオブジェクトを渡して呼び出す
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 処理が成功した場合は、コールバック関数の1番目の引数には`null`を渡し、2番目以降の引数に成功時の結果を渡して呼び出す
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: つまり、ひとつのコールバック関数で失敗した場合と成功した場合の両方を扱うルールとなります。
  prefs: []
  type: TYPE_NORMAL
- en: たとえば、Node.jsでは`fs.readFile`関数というファイルシステムからファイルをロードする非同期処理の関数があります。 指定したパスのファイルを読むため、ファイルが存在しない場合やアクセス権限の問題から読み取りに失敗することがあります。
    そのため、`fs.readFile`関数の第2引数に渡すコールバック関数にはエラーファーストコールバックスタイルの関数を渡します。
  prefs: []
  type: TYPE_NORMAL
- en: ファイルを読み込むことに失敗した場合は、コールバック関数の1番目の引数に`Error`オブジェクトが渡されます。 ファイルを読み込むことに成功した場合は、コールバック関数の1番目の引数に`null`、2番目の引数に読み込んだデータを渡します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'このエラーファーストコールバックはNode.jsでは広く使われ、Node.jsの標準APIでも利用されています。 詳しい扱い方については、「[ユースケース:
    Node.jsでCLIアプリケーション](../../use-case/nodecli/)」の章にて紹介します。'
  prefs: []
  type: TYPE_NORMAL
- en: 実際にエラーファーストコールバックで非同期な例外処理を扱うコードを書いてみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`dummyFetch`関数は、疑似的なリソースの取得をする非同期な処理です。 第1引数に任意のパスを受け取り、第2引数にエラーファーストコールバックスタイルの関数を受け取ります。
  prefs: []
  type: TYPE_NORMAL
- en: この`dummyFetch`関数は、任意のパスにマッチするリソースがある場合には、第2引数のコールバック関数に`null`とレスポンスオブジェクトを渡して呼び出します。
    一方、任意のパスにマッチするリソースがない場合には、第2引数のコールバック関数にエラーオブジェクトを渡して呼び出します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: このように、コールバック関数の1番目の引数にはエラーオブジェクトまたは`null`を入れ、それ以降の引数にデータを渡すというルールを**エラーファーストコールバック**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: エラーファーストコールバックは言語の仕様ではなく、非同期処理を扱う関数の呼び出し方をコミュニティで決めたルールです。 そのため、エラーファーストコールバックというルールを破ってもコードが動かなくなるわけではありません。
    また、エラーファーストコールバックはPromiseとは異なり、コールバック内で例外が発生した場合に自動的にエラーをキャッチできる仕組みはありません。
  prefs: []
  type: TYPE_NORMAL
- en: Promiseが標準化されて以降は、多くの非同期APIはPromiseベースのAPIとして提供されています。 これはNode.jsのコアモジュールも同様で、現在（Node.js
    v20.11.1）ではPromiseベースのAPIが提供されています。 そのため、エラーファーストコールバックを新しいコードで利用することはかなり限定的となっています。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#conclusion)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では、非同期処理に関するPromise、Async Functionについて学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: 非同期処理はその処理が終わるのを待つ前に次の処理を評価すること
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 非同期処理であってもメインスレッドで実行されることがある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promiseは、ES2015で導入された非同期処理を扱うビルトインオブジェクト
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async Functionは、ES2017で導入された非同期処理を扱う構文
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async FunctionはPromiseの上に作られた構文であるため、Promiseと組み合わせて利用する
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: エラーファーストコールバックは、非同期処理での例外を扱うルールの1つで、Node.jsで広く使われていた
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PromiseやAsync Functionの応用パターンについては「[JavaScript Promiseの本](https://azu.github.io/promises-book/)」も参照してください。******************************
  prefs: []
  type: TYPE_NORMAL
