["```\ntype CustomerId = CustomerId of int\ntype OrderId = OrderId of int \n```", "```\n// type is an wrapper for a primitive type\ntype CustomerId = CustomerId of int\n\n// create two silly functions for mapping and filtering \nlet add1ToCustomerId (CustomerId i) = \n    CustomerId (i+1)\n\nlet isCustomerIdSmall (CustomerId i) = \n    i < 100000\n\n// ---------------------------------\n// timed with a 1 million element array\n// ---------------------------------\n#time\nArray.init 1000000 CustomerId\n// map it \n|> Array.map add1ToCustomerId \n// map it again\n|> Array.map add1ToCustomerId \n// filter it \n|> Array.filter isCustomerIdSmall \n|> ignore\n#time \n```", "```\nReal: 00:00:00.296, CPU: 00:00:00.296, GC gen0: 6, gen1: 4, gen2: 0 \n```", "```\nReal: 00:00:03.489, CPU: 00:00:03.541, GC gen0: 68, gen1: 46, gen2: 2 \n```", "```\ntype CustomerId = int\ntype OrderId = int \n```", "```\nlet add1ToCustomerId (id:CustomerId) :CustomerId = \n    id+1 \n```", "```\ntype CustomerId = int\n\n// create two silly functions for mapping and filtering \nlet add1ToCustomerId (id:CustomerId) :CustomerId = \n    id+1\n// val add1ToCustomerId : id:CustomerId -> CustomerId\n\nlet isCustomerIdSmall (id:CustomerId) = \n    id < 100000\n// val isCustomerIdSmall : id:CustomerId -> bool\n\n// ---------------------------------\n// timed with a 1 million element array\n// ---------------------------------\n#time\nArray.init 1000000 (fun i -> i)\n// map it \n|> Array.map add1ToCustomerId \n// map it again\n|> Array.map add1ToCustomerId \n// filter it \n|> Array.filter isCustomerIdSmall \n|> Array.length\n#time \n```", "```\nReal: 00:00:00.017, CPU: 00:00:00.015, GC gen0: 0, gen1: 0, gen2: 0 \n```", "```\nReal: 00:00:00.166, CPU: 00:00:00.156, GC gen0: 0, gen1: 0, gen2: 0 \n```", "```\ntype CustomerId = int\ntype OrderId = int\n\n// create two\nlet cid : CustomerId = 12\nlet oid : OrderId = 12 \n```", "```\ncid = oid              // true\n\n// pass OrderId to function expecting a CustomerId \nadd1ToCustomerId oid   // CustomerId = 13 \n```", "```\ntype [<Measure>] CustomerIdUOM \ntype [<Measure>] OrderIdUOM \n\ntype CustomerId = int<CustomerIdUOM>\ntype OrderId = int<OrderIdUOM> \n```", "```\n// create two silly functions for mapping and filtering \nlet add1ToCustomerId id  = \n    id+1<CustomerIdUOM>\n\nlet isCustomerIdSmall i = \n    i < 100000<CustomerIdUOM>\n\n// ---------------------------------\n// timed with a 1 million element array\n// ---------------------------------\n#time\nArray.init 1000000 (fun i -> LanguagePrimitives.Int32WithMeasure<CustomerIdUOM> i)\n// map it \n|> Array.map add1ToCustomerId \n// map it again\n|> Array.map add1ToCustomerId \n// filter it \n|> Array.filter isCustomerIdSmall \n|> ignore\n#time \n```", "```\nReal: 00:00:00.022, CPU: 00:00:00.031, GC gen0: 0, gen1: 0, gen2: 0 \n```", "```\nReal: 00:00:00.157, CPU: 00:00:00.156, GC gen0: 0, gen1: 0, gen2: 0 \n```", "```\nlet cid = 12<CustomerIdUOM>\nlet oid = 4<OrderIdUOM> \n```", "```\nlet ratio = cid / oid\n// val ratio : int<CustomerIdUOM/OrderIdUOM> = 3 \n```", "```\n#if COMPILED  // uncomment to use aliased version \n//#if INTERACTIVE // uncomment to use wrapped version\n\n// type is an wrapper for a primitive type\ntype CustomerId = CustomerId of int\n\n// constructor\nlet createCustomerId i = CustomerId i\n\n// get data\nlet customerIdValue (CustomerId i) = i\n\n// pattern matching\n// not needed\n\n#else\n// type is an alias for a primitive type\ntype CustomerId = int\n\n// constructor\nlet inline createCustomerId i :CustomerId = i\n\n// get data\nlet inline customerIdValue (id:CustomerId) = id\n\n// pattern matching\nlet inline (|CustomerId|) (id:CustomerId) :int = id\n\n#endif \n```", "```\n// test the getter\nlet testGetter c1 c2 =\n    let i1 = customerIdValue c1\n    let i2 = customerIdValue c2\n    printfn \"Get inner value from customers %i %i\" i1 i2\n// Note that the signature is as expected:\n// c1:CustomerId -> c2:CustomerId -> unit\n\n// test pattern matching\nlet testPatternMatching c1 =\n    let (CustomerId i) = c1\n    printfn \"Get inner value from Customers via pattern match: %i\" i\n\n    match c1 with\n    | CustomerId i2 -> printfn \"match/with %i\" i\n// Note that the signature is as expected:\n// c1:CustomerId -> unit\n\nlet test() = \n    // create two ids\n    let c1 = createCustomerId 1\n    let c2 = createCustomerId 2\n    let custArray : CustomerId [] = [| c1; c2 |]\n\n    // test them\n    testGetter c1 c2 \n    testPatternMatching c1 \n```", "```\n// create two silly functions for mapping and filtering \nlet add1ToCustomerId (CustomerId i) = \n    createCustomerId (i+1)\n\nlet isCustomerIdSmall (CustomerId i) = \n    i < 100000\n\n// ---------------------------------\n// timed with a 1 million element array\n// ---------------------------------\n#time\nArray.init 1000000 createCustomerId\n// map it \n|> Array.map add1ToCustomerId \n// map it again\n|> Array.map add1ToCustomerId \n// filter it \n|> Array.filter isCustomerIdSmall \n|> Array.length\n#time \n```", "```\n// results using wrapped version\nReal: 00:00:00.408, CPU: 00:00:00.405, GC gen0: 7, gen1: 4, gen2: 1\n\n// results using aliased version\nReal: 00:00:00.022, CPU: 00:00:00.031, GC gen0: 0, gen1: 0, gen2: 0 \n```", "```\n// results using wrapped version\nReal: 00:00:03.199, CPU: 00:00:03.354, GC gen0: 67, gen1: 45, gen2: 2\n\n// results using aliased version\nReal: 00:00:00.239, CPU: 00:00:00.202, GC gen0: 0, gen1: 0, gen2: 0 \n```", "```\nmodule EmailAddress =\n    // type with private constructor \n    type EmailAddress = private EmailAddress of string\n\n    // safe constructor\n    let create s = \n        if System.String.IsNullOrWhiteSpace(s) then \n            None\n        else if s.Contains(\"@\") then\n            Some (EmailAddress s)\n        else\n            None\n\n    // get data\n    let value (EmailAddress s) = s\n\nmodule ActivityHistory =\n    open EmailAddress\n\n    // type with private constructor \n    type ActivityHistory = private {\n        emailAddress : EmailAddress\n        visits : int\n        }\n\n    // safe constructor\n    let create email visits = \n        {emailAddress = email; visits = visits }\n\n    // get data\n    let email {emailAddress=e} = e\n    let visits {visits=a} = a \n```", "```\nmodule EmailAddress =\n\n    // aliased type \n    type EmailAddress = string\n\n    // safe constructor\n    let inline create s :EmailAddress option = \n        if System.String.IsNullOrWhiteSpace(s) then \n            None\n        else if s.Contains(\"@\") then\n            Some s\n        else\n            None\n\n    // get data\n    let inline value (e:EmailAddress) :string = e\n\nmodule ActivityHistory =\n    open EmailAddress\n\n    [<Struct>]\n    type ActivityHistory(emailAddress : EmailAddress, visits : int) = \n        member this.EmailAddress = emailAddress \n        member this.Visits = visits \n\n    // safe constructor\n    let create email visits = \n        ActivityHistory(email,visits)\n\n    // get data\n    let email (act:ActivityHistory) = act.EmailAddress\n    let visits (act:ActivityHistory) = act.Visits \n```", "```\nlet rand = new System.Random()\n\nlet createCustomerWithRandomActivityHistory() = \n    let emailOpt = EmailAddress.create \"abc@example.com\"\n    match emailOpt with\n    | Some email  -> \n        let visits = rand.Next(0,100) \n        ActivityHistory.create email visits \n    | None -> \n        failwith \"should not happen\"\n\nlet add1ToVisits activity = \n    let email = ActivityHistory.email activity\n    let visits = ActivityHistory.visits activity \n    ActivityHistory.create email (visits+1)\n\nlet isCustomerInactive activity = \n    let visits = ActivityHistory.visits activity \n    visits < 3\n\n// execute creation and iteration for a large number of records\nlet mapAndFilter noOfRecords = \n    Array.init noOfRecords (fun _ -> createCustomerWithRandomActivity() )\n    // map it \n    |> Array.map add1ToVisits \n    // map it again\n    |> Array.map add1ToVisits \n    // filter it \n    |> Array.filter isCustomerInactive \n    |> ignore  // we don't actually care! \n```", "```\n/// Do countN repetitions of the function f and print the \n/// time elapsed, number of GCs and change in total memory\nlet time countN label f  = \n\n    let stopwatch = System.Diagnostics.Stopwatch()\n\n    // do a full GC at the start but NOT thereafter\n    // allow garbage to collect for each iteration\n    System.GC.Collect()  \n    printfn \"Started\"         \n\n    let getGcStats() = \n        let gen0 = System.GC.CollectionCount(0)\n        let gen1 = System.GC.CollectionCount(1)\n        let gen2 = System.GC.CollectionCount(2)\n        let mem = System.GC.GetTotalMemory(false)\n        gen0,gen1,gen2,mem\n\n    printfn \"=======================\"         \n    printfn \"%s (%s)\" label WrappedOrAliased\n    printfn \"=======================\"         \n    for iteration in [1..countN] do\n        let gen0,gen1,gen2,mem = getGcStats()\n        stopwatch.Restart() \n        f()\n        stopwatch.Stop() \n        let gen0',gen1',gen2',mem' = getGcStats()\n        // convert memory used to K\n        let changeInMem = (mem'-mem) / 1000L\n        printfn \"#%2i elapsed:%6ims gen0:%3i gen1:%3i gen2:%3i mem:%6iK\" iteration stopwatch.ElapsedMilliseconds (gen0'-gen0) (gen1'-gen1) (gen2'-gen2) changeInMem \n```", "```\nlet size = 1000000\nlet label = sprintf \"mapAndFilter: %i records\" size \ntime 10 label (fun () -> mapAndFilter size) \n```", "```\n=======================\nmapAndFilter: 1000000 records (Wrapped)\n=======================\n# 1 elapsed:   820ms gen0: 13 gen1:  8 gen2:  1 mem: 72159K\n# 2 elapsed:   878ms gen0: 12 gen1:  7 gen2:  0 mem: 71997K\n# 3 elapsed:   850ms gen0: 12 gen1:  6 gen2:  0 mem: 72005K\n# 4 elapsed:   885ms gen0: 12 gen1:  7 gen2:  0 mem: 72000K\n# 5 elapsed:  6690ms gen0: 16 gen1: 10 gen2:  1 mem:-216005K\n# 6 elapsed:   714ms gen0: 12 gen1:  7 gen2:  0 mem: 72003K\n# 7 elapsed:   668ms gen0: 12 gen1:  7 gen2:  0 mem: 71995K\n# 8 elapsed:   670ms gen0: 12 gen1:  7 gen2:  0 mem: 72001K\n# 9 elapsed:  6676ms gen0: 16 gen1: 11 gen2:  2 mem:-215998K\n#10 elapsed:   712ms gen0: 13 gen1:  7 gen2:  0 mem: 71998K\n\n=======================\nmapAndFilter: 1000000 records (Aliased)\n=======================\n# 1 elapsed:   193ms gen0:  7 gen1:  0 gen2:  0 mem: 25325K\n# 2 elapsed:   142ms gen0:  8 gen1:  0 gen2:  0 mem: 23779K\n# 3 elapsed:   143ms gen0:  8 gen1:  0 gen2:  0 mem: 23761K\n# 4 elapsed:   138ms gen0:  8 gen1:  0 gen2:  0 mem: 23745K\n# 5 elapsed:   135ms gen0:  7 gen1:  0 gen2:  0 mem: 25327K\n# 6 elapsed:   135ms gen0:  8 gen1:  0 gen2:  0 mem: 23762K\n# 7 elapsed:   137ms gen0:  8 gen1:  0 gen2:  0 mem: 23755K\n# 8 elapsed:   140ms gen0:  8 gen1:  0 gen2:  0 mem: 23777K\n# 9 elapsed:   174ms gen0:  7 gen1:  0 gen2:  0 mem: 25327K\n#10 elapsed:   180ms gen0:  8 gen1:  0 gen2:  0 mem: 23762K \n```", "```\nmodule Classification =\n    open EmailAddress\n    open ActivityHistory\n\n    type Classification = \n        | Active of EmailAddress * int\n        | Inactive of EmailAddress \n\n    // constructor\n    let createActive email visits = \n        Active (email,visits)\n    let createInactive email = \n        Inactive email\n\n    // pattern matching\n    // not needed \n```", "```\nmodule Classification =\n    open EmailAddress\n    open ActivityHistory\n    open System\n\n    [<Struct>]\n    type Classification(isActive : bool, email: EmailAddress, visits: int) = \n        member this.IsActive = isActive \n        member this.Email = email\n        member this.Visits = visits\n\n    // constructor\n    let inline createActive email visits = \n        Classification(true,email,visits)\n    let inline createInactive email = \n        Classification(false,email,0)\n\n    // pattern matching\n    let inline (|Active|Inactive|) (c:Classification) = \n        if c.IsActive then \n            Active (c.Email,c.Visits)\n        else\n            Inactive (c.Email) \n```", "```\nopen Classification\n\nlet createClassifiedCustomer activity = \n    let email = ActivityHistory.email activity\n    let visits = ActivityHistory.visits activity \n\n    if isCustomerInactive activity then \n        Classification.createInactive email \n    else\n        Classification.createActive email visits \n\n// execute creation and iteration for a large number of records\nlet extractActiveEmails noOfRecords =\n    Array.init noOfRecords (fun _ -> createCustomerWithRandomActivityHistory() )\n    // map to a classification\n    |> Array.map createClassifiedCustomer\n    // extract emails for active customers\n    |> Array.choose (function\n        | Active (email,visits) -> email |> Some\n        | Inactive _ -> None )\n    |> ignore \n```", "```\n=======================\nextractActiveEmails: 1000000 records (Wrapped)\n=======================\n# 1 elapsed:   664ms gen0: 12 gen1:  6 gen2:  0 mem: 64542K\n# 2 elapsed:   584ms gen0: 14 gen1:  7 gen2:  0 mem: 64590K\n# 3 elapsed:   589ms gen0: 13 gen1:  7 gen2:  0 mem: 63616K\n# 4 elapsed:   573ms gen0: 11 gen1:  5 gen2:  0 mem: 69438K\n# 5 elapsed:   640ms gen0: 15 gen1:  7 gen2:  0 mem: 58464K\n# 6 elapsed:  4297ms gen0: 13 gen1:  7 gen2:  1 mem:-256192K\n# 7 elapsed:   593ms gen0: 14 gen1:  7 gen2:  0 mem: 64623K\n# 8 elapsed:   621ms gen0: 13 gen1:  7 gen2:  0 mem: 63689K\n# 9 elapsed:   577ms gen0: 11 gen1:  5 gen2:  0 mem: 69415K\n#10 elapsed:   609ms gen0: 15 gen1:  7 gen2:  0 mem: 58480K\n\n=======================\nextractActiveEmails: 1000000 records (Aliased)\n=======================\n# 1 elapsed:   254ms gen0: 32 gen1:  1 gen2:  0 mem: 33162K\n# 2 elapsed:   221ms gen0: 33 gen1:  0 gen2:  0 mem: 31532K\n# 3 elapsed:   196ms gen0: 32 gen1:  0 gen2:  0 mem: 33113K\n# 4 elapsed:   185ms gen0: 33 gen1:  0 gen2:  0 mem: 31523K\n# 5 elapsed:   187ms gen0: 33 gen1:  0 gen2:  0 mem: 31532K\n# 6 elapsed:   186ms gen0: 32 gen1:  0 gen2:  0 mem: 33095K\n# 7 elapsed:   191ms gen0: 33 gen1:  0 gen2:  0 mem: 31514K\n# 8 elapsed:   200ms gen0: 32 gen1:  0 gen2:  0 mem: 33096K\n# 9 elapsed:   189ms gen0: 33 gen1:  0 gen2:  0 mem: 31531K\n#10 elapsed:  3732ms gen0: 33 gen1:  1 gen2:  1 mem:-256432K \n```"]