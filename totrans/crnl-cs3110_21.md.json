["```\n% utop\nutop # #require \"async\";;\nutop # open Async.Std;;\n\n```", "```\nmodule Std : sig = \n  module Deferred : sig = \n    type 'a t\n    val return : 'a -> 'a Deferred.t\n    val bind : 'a Deferred.t -> ('a -> 'b Deferred.t) -> 'b Deferred.t\n    val peek : 'a Deferred.t -> 'a option\n    val map : 'a Deferred.t -> ('a -> 'b) -> 'b Deferred.t\n    val both : 'a Deferred.t -> 'b Deferred.t -> ('a * 'b) Deferred.t\n    val don't_wait_for : unit Deferred.t -> unit \n    module List : sig\n      val map    : 'a list -> ('a -> 'b Deferred.t) -> 'b list Deferred.t\n      val iter   : 'a list -> ('a -> unit Deferred.t) -> unit Deferred.t\n      val fold   : 'a list -> 'b -> ('b -> 'a -> 'b Deferred.t) -> 'b Deferred.t\n      val filter : 'a list -> ('a -> bool Deferred.t) -> 'a list Deferred.t\n      val find   : 'a list -> ('a -> bool Deferred.t) -> 'a option Deferred.t\n      ...\n    end\n    ...\n  end\n  ...\nend\n\n```", "```\nopen Async.Std\n\nlet main () = \n  let f i = \n    printf \"Value is %d\\n\" i;\n    return () in \n  Deferred.both \n    (Deferred.List.iter [1;2;3;4;5] f)\n    (Deferred.List.iter [1;2;3;4;5] f)\n\nlet () = \n  don't_wait_for (main () >>= fun _ -> exit 0);    \n  ignore (Scheduler.go ())\n\n```", "```\nValue is 1\nValue is 1\nValue is 2\nValue is 2\nValue is 3\nValue is 3\nValue is 4\nValue is 4\nValue is 5\nValue is 5\n\n```", "```\nlet d = return 42;;\nval d : int Deferred.t = \n\n```", "```\nDeferred.peek d;;\n- : int option = Some 42\n\n```", "```\nlet d = return 42 >>= fun n -> \n        return (n,3110)\nval d : int * int Deferred.t = \n\n```", "```\nlet both (d1:'a Deferred.t) (d2:'b Deferred.t) : ('a * 'b) Deferred.t = \n  d1 >>= fun v1 -> \n  d2 >>= fun v2 -> \n  return (v1,v2)\n\n```", "```\nmodule Read_result : sig = \n  type 'a t = [ `Eof | `Ok of 'a ]\n  ...\nend\n\nmodule Reader : sig = \n  val open_file : -> string -> t Deferred.t\n  val read_line : t -> string Read_result.t Import.Deferred.t\n  ...\nend\n\n```", "```\".\n\nUsing these functions, we can write a function that reads in the contents of a file:\n\n```", "```\n\nNote that each I/O operation is encapsulated in a deferred computation, so the `async` scheduler is free to interleave them with other computations that might be executing concurrently\u2014e.g., another deferred computation also performing I/O.\n\nGoing a step further, we can write a function that computes the number of characters in a file:\n\n```", "```\n\nThis pattern of sequencing a deferred computation with a computation that consumes the value and immediately returns a value is so common, that the `async` library includes a primitive for implementing it directly:\n\n```", "```\n\nThe `map` function can be written infix as `>>|`. Hence, the above function could be written more succinctly as:\n\n```"]