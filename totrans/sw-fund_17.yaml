- en: EquivProgram Equivalence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: (* IMPORTS *)
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Bool.Bool.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.EqNat.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Lists.List.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Logic.FunctionalExtensionality.
  prefs: []
  type: TYPE_NORMAL
- en: Import ListNotations.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: (* /IMPORTS *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Behavioral Equivalence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an earlier chapter, we investigated the correctness of a very
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'simple program transformation: the optimize_0plus function.  The'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programming language we were considering was the first version of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the language of arithmetic expressions — with no variables — so
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in that setting it was very easy to define what it means for a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'program transformation to be correct: it should always yield a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: program that evaluates to the same number as the original.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To talk about the correctness of program transformations for the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: full Imp language, including assignment and other commands, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need to consider the role of variables and state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition aequiv (a[1] a[2] : aexp) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: ∀(st:state),
  prefs: []
  type: TYPE_NORMAL
- en: aeval st a[1] = aeval st a[2].
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition bequiv (b[1] b[2] : bexp) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: ∀(st:state),
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = beval st b[2].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem aequiv_example:'
  prefs: []
  type: TYPE_NORMAL
- en: aequiv (AMinus (AId X) (AId X)) (ANum 0).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros st. simpl. omega.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Theorem bequiv_example:'
  prefs: []
  type: TYPE_NORMAL
- en: bequiv (BEq (AMinus (AId X) (AId X)) (ANum 0)) BTrue.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros st. unfold [beval](Imp.html#beval).
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [aequiv_example](Equiv.html#aequiv_example). reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition cequiv (c[1] c[2] : com) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '∀(st st'' : state),'
  prefs: []
  type: TYPE_NORMAL
- en: (c[1] / st ⇓ st') ↔ (c[2] / st ⇓ st').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem skip_left: ∀c,'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (SKIP;; c)
  prefs: []
  type: TYPE_NORMAL
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: intros c st st'.
  prefs: []
  type: TYPE_NORMAL
- en: split; intros H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. subst.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[2]. subst.
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply E_Seq with st.
  prefs: []
  type: TYPE_NORMAL
- en: apply E_Skip.
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem skip_right: ∀c,'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (c ;; SKIP)
  prefs: []
  type: TYPE_NORMAL
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem IFB_true_simple: ∀c[1] c[2],'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (IFB BTrue THEN c[1] ELSE c[2] FI)
  prefs: []
  type: TYPE_NORMAL
- en: c[1].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros c[1] c[2].
  prefs: []
  type: TYPE_NORMAL
- en: split; intros H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst. assumption. inversion H[5].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_IfTrue](Imp.html#E_IfTrue). reflexivity. assumption. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem IFB_true: ∀b c[1] c[2],'
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b BTrue  →
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN c[1] ELSE c[2] FI)
  prefs: []
  type: TYPE_NORMAL
- en: c[1].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros b c[1] c[2] Hb.
  prefs: []
  type: TYPE_NORMAL
- en: split; intros H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst.
  prefs: []
  type: TYPE_NORMAL
- en: + (* b evaluates to true *)
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  prefs: []
  type: TYPE_NORMAL
- en: + (* b evaluates to false (contradiction) *)
  prefs: []
  type: TYPE_NORMAL
- en: unfold [bequiv](Equiv.html#bequiv) in Hb. simpl in Hb.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite Hb in H[5].
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[5].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_IfTrue](Imp.html#E_IfTrue); try assumption.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [bequiv](Equiv.html#bequiv) in Hb. simpl in Hb.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite Hb. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem IFB_false: ∀b c[1] c[2],'
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b BFalse  →
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN c[1] ELSE c[2] FI)
  prefs: []
  type: TYPE_NORMAL
- en: c[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem swap_if_branches: ∀b e[1] e[2],'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN e[1] ELSE e[2] FI)
  prefs: []
  type: TYPE_NORMAL
- en: (IFB BNot b THEN e[2] ELSE e[1] FI).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem WHILE_false : ∀b c,'
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b DO c END)
  prefs: []
  type: TYPE_NORMAL
- en: SKIP.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros b c Hb. split; intros H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_WhileEnd *)
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_Skip](Imp.html#E_Skip).
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_WhileLoop *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite Hb in H[2]. inversion H[2].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst.
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_WhileEnd](Imp.html#E_WhileEnd).
  prefs: []
  type: TYPE_NORMAL
- en: rewrite Hb.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma WHILE_true_nonterm : ∀b c st st'','
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: ~( (WHILE b DO c END) / st ⇓ st' ).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: intros b c st st' Hb.
  prefs: []
  type: TYPE_NORMAL
- en: intros H.
  prefs: []
  type: TYPE_NORMAL
- en: remember (WHILE b DO c END) as cw eqn:Heqcw.
  prefs: []
  type: TYPE_NORMAL
- en: induction H;
  prefs: []
  type: TYPE_NORMAL
- en: (* Most rules don't apply, and we can rule them out        by inversion *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqcw; subst; clear Heqcw.
  prefs: []
  type: TYPE_NORMAL
- en: (* The two interesting cases are the ones for WHILE loops: *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_WhileEnd *) (* contradictory -- b is always true! *)'
  prefs: []
  type: TYPE_NORMAL
- en: unfold bequiv in Hb.
  prefs: []
  type: TYPE_NORMAL
- en: (* rewrite is able to instantiate the quantifier in st *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite Hb in H. inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_WhileLoop *) (* immediate from the IH *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHceval2. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem WHILE_true: ∀b c,'
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b BTrue  →
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b DO c END)
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE BTrue DO SKIP END).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem loop_unrolling: ∀b c,'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b DO c END)
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN (c ;; WHILE b DO c END) ELSE SKIP FI).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: intros b c st st'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: split; intros Hce.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hce; subst.
  prefs: []
  type: TYPE_NORMAL
- en: + (* loop doesn't run *)
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_IfFalse](Imp.html#E_IfFalse). assumption. apply [E_Skip](Imp.html#E_Skip).
  prefs: []
  type: TYPE_NORMAL
- en: + (* loop runs *)
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_IfTrue](Imp.html#E_IfTrue). assumption.
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_Seq](Imp.html#E_Seq) with (st' := st'0). assumption. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hce; subst.
  prefs: []
  type: TYPE_NORMAL
- en: + (* loop runs *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[5]; subst.
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_WhileLoop](Imp.html#E_WhileLoop) with (st' := st'0).
  prefs: []
  type: TYPE_NORMAL
- en: assumption. assumption. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: + (* loop doesn't run *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[5]; subst. apply [E_WhileEnd](Imp.html#E_WhileEnd). assumption.
    Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem seq_assoc : ∀c[1] c[2] c[3],'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv ((c[1];;c[2]);;c[3]) (c[1];;(c[2];;c[3])).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem identity_assignment : ∀(X:id),'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= AId X)
  prefs: []
  type: TYPE_NORMAL
- en: SKIP.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros. split; intro H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst. simpl.
  prefs: []
  type: TYPE_NORMAL
- en: replace ([t_update](Maps.html#t_update) st X (st X)) with st.
  prefs: []
  type: TYPE_NORMAL
- en: + constructor.
  prefs: []
  type: TYPE_NORMAL
- en: + apply [functional_extensionality](http://coq.inria.fr/library/Coq.Logic.FunctionalExtensionality.html#functional_extensionality).
    intro.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [t_update_same](Maps.html#t_update_same); reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  prefs: []
  type: TYPE_NORMAL
- en: replace st' with ([t_update](Maps.html#t_update) st' X ([aeval](Imp.html#aeval)
    st' ([AId](Imp.html#AId) X))).
  prefs: []
  type: TYPE_NORMAL
- en: + inversion H. subst. apply [E_Ass](Imp.html#E_Ass). reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + apply [functional_extensionality](http://coq.inria.fr/library/Coq.Logic.FunctionalExtensionality.html#functional_extensionality).
    intro.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [t_update_same](Maps.html#t_update_same). reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem assign_aequiv : ∀X e,'
  prefs: []
  type: TYPE_NORMAL
- en: aequiv (AId X) e →
  prefs: []
  type: TYPE_NORMAL
- en: cequiv SKIP (X ::= e).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[ [prog_a;prog_b;prog_c;prog_d;prog_e;prog_f;prog_g;prog_h] ;'
  prefs: []
  type: TYPE_NORMAL
- en: '[prog_i] ]'
  prefs: []
  type: TYPE_NORMAL
- en: Write down your answer below in the definition of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equiv_classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Behavioral Equivalence Is an Equivalence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we verify that the equivalences on aexps, bexps, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: coms really are *equivalences* — i.e., that they are reflexive,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: symmetric, and transitive.  The proofs are all easy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Behavioral Equivalence Is a Congruence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Less obviously, behavioral equivalence is also a *congruence*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is, the equivalence of two subprograms implies the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'equivalence of the larger programs in which they are embedded:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: aequiv a[1] a[1]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cequiv (i ::= a[1]) (i ::= a[1]')
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cequiv c[1] c[1]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cequiv c[2] c[2]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cequiv (c[1];;c[2]) (c[1]';;c[2]')
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '...and so on for the other forms of commands.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (Note that we are using the inference rule notation here not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: as part of a definition, but simply to write down some valid
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: implications in a readable format. We prove these implications
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: below.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will see a concrete example of why these congruence
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: properties are important in the following section (in the proof of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fold_constants_com_sound), but the main idea is that they allow
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: us to replace a small part of a large program with an equivalent
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: small part and know that the whole large programs are equivalent
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*without* doing an explicit proof about the non-varying parts —'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: i.e., the "proof burden" of a small change to a large program is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proportional to the size of the change, not the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The congruence property for loops is a little more interesting,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: since it requires induction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Theorem*: Equivalence is a congruence for WHILE — that is, if'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b[1] is equivalent to b[1]' and c[1] is equivalent to c[1]', then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WHILE b[1] DO c[1] END is equivalent to WHILE b[1]' DO c[1]' END.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Proof*: Suppose b[1] is equivalent to b[1]'' and c[1] is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equivalent to c[1]'.  We must show, for every st and st', that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WHILE b[1] DO c[1] END / st ⇓ st' iff WHILE b[1]' DO c[1]' END / st ⇓ st'.  We
    consider the two directions separately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (→) We show that WHILE b[1] DO c[1] END / st ⇓ st' implies WHILE b[1]' DO c[1]'
    END / st ⇓ st', by induction on a derivation of WHILE b[1] DO c[1] END / st ⇓
    st'. The only nontrivial cases are when the final rule in the derivation is E_WhileEnd
    or E_WhileLoop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E_WhileEnd: In this case, the form of the rule gives us beval st b[1] = false
    and st = st''. But then, since b[1] and b[1]'' are equivalent, we have beval st
    b[1]'' = false, and E-WhileEnd applies, giving us WHILE b[1]'' DO c[1]'' END /
    st ⇓ st'', as required.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E_WhileLoop: The form of the rule now gives us beval st b[1] = true, with c[1]
    / st ⇓ st''0 and WHILE b[1] DO c[1] END / st''0 ⇓ st'' for some state st''0, with
    the induction hypothesis WHILE b[1]'' DO c[1]'' END / st''0 ⇓ st''.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since c[1] and c[1]' are equivalent, we know that c[1]' / st ⇓ st'0. And since
    b[1] and b[1]' are equivalent, we have beval st b[1]' = true. Now E-WhileLoop
    applies, giving us WHILE b[1]' DO c[1]' END / st ⇓ st', as required.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (←) Similar. ☐
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, optional (CSeq_congruence)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (CIf_congruence)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, here are two equivalent programs and a proof of their
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equivalence...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, advanced, optional (not_congr)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We've shown that the cequiv relation is both an equivalence and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a congruence on commands.  Can you think of a relation on commands
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that is an equivalence but *not* a congruence?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition atrans_sound (atrans : aexp → aexp) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '∀(a : aexp),'
  prefs: []
  type: TYPE_NORMAL
- en: aequiv a (atrans a).
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition btrans_sound (btrans : bexp → bexp) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '∀(b : bexp),'
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b (btrans b).
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition ctrans_sound (ctrans : com → com) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '∀(c : com),'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv c (ctrans c).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint fold_constants_aexp (a : aexp) : aexp :='
  prefs: []
  type: TYPE_NORMAL
- en: match a with
  prefs: []
  type: TYPE_NORMAL
- en: '| ANum n       ⇒ ANum n'
  prefs: []
  type: TYPE_NORMAL
- en: '| AId i        ⇒ AId i'
  prefs: []
  type: TYPE_NORMAL
- en: '| APlus a[1] a[2]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
  prefs: []
  type: TYPE_NORMAL
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] + n[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '| (a[1]'', a[2]'') ⇒ APlus a[1]'' a[2]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| AMinus a[1] a[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
  prefs: []
  type: TYPE_NORMAL
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] - n[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '| (a[1]'', a[2]'') ⇒ AMinus a[1]'' a[2]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| AMult a[1] a[2]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
  prefs: []
  type: TYPE_NORMAL
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] * n[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '| (a[1]'', a[2]'') ⇒ AMult a[1]'' a[2]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example fold_aexp_ex[1] :'
  prefs: []
  type: TYPE_NORMAL
- en: fold_constants_aexp
  prefs: []
  type: TYPE_NORMAL
- en: (AMult (APlus (ANum 1) (ANum 2)) (AId X))
  prefs: []
  type: TYPE_NORMAL
- en: = AMult (ANum 3) (AId X).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Example fold_aexp_ex[2] :'
  prefs: []
  type: TYPE_NORMAL
- en: fold_constants_aexp
  prefs: []
  type: TYPE_NORMAL
- en: (AMinus (AId X) (APlus (AMult (ANum 0) (ANum 6))
  prefs: []
  type: TYPE_NORMAL
- en: (AId Y)))
  prefs: []
  type: TYPE_NORMAL
- en: = AMinus (AId X) (APlus (ANum 0) (AId Y)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint fold_constants_bexp (b : bexp) : bexp :='
  prefs: []
  type: TYPE_NORMAL
- en: match b with
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue        ⇒ BTrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse       ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| BEq a[1] a[2]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2]) with
  prefs: []
  type: TYPE_NORMAL
- en: '| (ANum n[1], ANum n[2]) ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if beq_nat n[1] n[2] then BTrue else BFalse
  prefs: []
  type: TYPE_NORMAL
- en: '| (a[1]'', a[2]'') ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: BEq a[1]' a[2]'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| BLe a[1] a[2]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2]) with
  prefs: []
  type: TYPE_NORMAL
- en: '| (ANum n[1], ANum n[2]) ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if leb n[1] n[2] then BTrue else BFalse
  prefs: []
  type: TYPE_NORMAL
- en: '| (a[1]'', a[2]'') ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: BLe a[1]' a[2]'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| BNot b[1]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (fold_constants_bexp b[1]) with
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse ⇒ BTrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| b[1]'' ⇒ BNot b[1]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| BAnd b[1] b[2]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (fold_constants_bexp b[1], fold_constants_bexp b[2]) with
  prefs: []
  type: TYPE_NORMAL
- en: '| (BTrue, BTrue) ⇒ BTrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| (BTrue, BFalse) ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| (BFalse, BTrue) ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| (BFalse, BFalse) ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| (b[1]'', b[2]'') ⇒ BAnd b[1]'' b[2]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example fold_bexp_ex[1] :'
  prefs: []
  type: TYPE_NORMAL
- en: fold_constants_bexp (BAnd BTrue (BNot (BAnd BFalse BTrue)))
  prefs: []
  type: TYPE_NORMAL
- en: = BTrue.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example fold_bexp_ex[2] :'
  prefs: []
  type: TYPE_NORMAL
- en: fold_constants_bexp
  prefs: []
  type: TYPE_NORMAL
- en: (BAnd (BEq (AId X) (AId Y))
  prefs: []
  type: TYPE_NORMAL
- en: (BEq (ANum 0)
  prefs: []
  type: TYPE_NORMAL
- en: (AMinus (ANum 2) (APlus (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: (ANum 1)))))
  prefs: []
  type: TYPE_NORMAL
- en: = BAnd (BEq (AId X) (AId Y)) BTrue.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint fold_constants_com (c : com) : com :='
  prefs: []
  type: TYPE_NORMAL
- en: match c with
  prefs: []
  type: TYPE_NORMAL
- en: '| SKIP      ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: SKIP
  prefs: []
  type: TYPE_NORMAL
- en: '| i ::= a  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: CAss i (fold_constants_aexp a)
  prefs: []
  type: TYPE_NORMAL
- en: '| c[1] ;; c[2]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: (fold_constants_com c[1]) ;; (fold_constants_com c[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| IFB b THEN c[1] ELSE c[2] FI ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match fold_constants_bexp b with
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue ⇒ fold_constants_com c[1]'
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse ⇒ fold_constants_com c[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '| b'' ⇒ IFB b'' THEN fold_constants_com c[1]'
  prefs: []
  type: TYPE_NORMAL
- en: ELSE fold_constants_com c[2] FI
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| WHILE b DO c END ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match fold_constants_bexp b with
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue ⇒ WHILE BTrue DO SKIP END'
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse ⇒ SKIP'
  prefs: []
  type: TYPE_NORMAL
- en: '| b'' ⇒ WHILE b'' DO (fold_constants_com c) END'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example fold_com_ex[1] :'
  prefs: []
  type: TYPE_NORMAL
- en: fold_constants_com
  prefs: []
  type: TYPE_NORMAL
- en: (* Original program: *)
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= APlus (ANum 4) (ANum 5);;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId X) (ANum 3);;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BEq (AMinus (AId X) (AId Y))
  prefs: []
  type: TYPE_NORMAL
- en: (APlus (ANum 2) (ANum 4)) THEN
  prefs: []
  type: TYPE_NORMAL
- en: SKIP
  prefs: []
  type: TYPE_NORMAL
- en: ELSE
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: FI;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BLe (ANum 0)
  prefs: []
  type: TYPE_NORMAL
- en: (AMinus (ANum 4) (APlus (ANum 2) (ANum 1)))
  prefs: []
  type: TYPE_NORMAL
- en: THEN
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: ELSE
  prefs: []
  type: TYPE_NORMAL
- en: SKIP
  prefs: []
  type: TYPE_NORMAL
- en: FI;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BEq (AId Y) (ANum 0) DO
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: END)
  prefs: []
  type: TYPE_NORMAL
- en: = (* After constant folding: *)
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 9;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId X) (ANum 3);;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BEq (AMinus (AId X) (AId Y)) (ANum 6) THEN
  prefs: []
  type: TYPE_NORMAL
- en: SKIP
  prefs: []
  type: TYPE_NORMAL
- en: ELSE
  prefs: []
  type: TYPE_NORMAL
- en: (Y ::= ANum 0)
  prefs: []
  type: TYPE_NORMAL
- en: FI;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 0;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BEq (AId Y) (ANum 0) DO
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: END).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem fold_constants_aexp_sound :'
  prefs: []
  type: TYPE_NORMAL
- en: atrans_sound fold_constants_aexp.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold [atrans_sound](Equiv.html#atrans_sound). intros a. unfold [aequiv](Equiv.html#aequiv).
    intros st.
  prefs: []
  type: TYPE_NORMAL
- en: induction a; simpl;
  prefs: []
  type: TYPE_NORMAL
- en: (* ANum and AId follow immediately *)
  prefs: []
  type: TYPE_NORMAL
- en: try reflexivity;
  prefs: []
  type: TYPE_NORMAL
- en: (* APlus, AMinus, and AMult follow from the IH        and the observation that
                  aeval st (APlus a[1] a[2])             = ANum ((aeval st a[1]) + (aeval st a[2]))
                = aeval st (ANum ((aeval st a[1]) + (aeval st a[2])))        (and similarly for AMinus/minus and AMult/mult) *)
  prefs: []
  type: TYPE_NORMAL
- en: try (destruct ([fold_constants_aexp](Equiv.html#fold_constants_aexp) a[1]);
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([fold_constants_aexp](Equiv.html#fold_constants_aexp) a[2]);
  prefs: []
  type: TYPE_NORMAL
- en: rewrite IHa1; rewrite IHa2; reflexivity). Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: beval st (BEq a[1] a[2])
  prefs: []
  type: TYPE_NORMAL
- en: = beval st (fold_constants_bexp (BEq a[1] a[2])).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two cases to consider:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, suppose fold_constants_aexp a[1] = ANum n[1] and fold_constants_aexp
    a[2] = ANum n[2] for some n[1] and n[2].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we have
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: beval st (BEq a[1] a[2])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = beq_nat (aeval st a[1]) (aeval st a[2]).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By the soundness of constant folding for arithmetic expressions (Lemma fold_constants_aexp_sound),
    we know
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: aeval st a[2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = aeval st (fold_constants_aexp a[2])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = aeval st (ANum n[2])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = n[2],
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: beval st (if beq_nat n[1] n[2] then BTrue else BFalse)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = if beq_nat n[1] n[2] then beval st BTrue else beval st BFalse
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = if beq_nat n[1] n[2] then true else false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = beq_nat n[1] n[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Otherwise, one of fold_constants_aexp a[1] and fold_constants_aexp a[2] is not
    a constant. In this case, we must show
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: beq_nat (aeval st a[1]) (aeval st a[2])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = beq_nat (aeval st (fold_constants_aexp a[1]))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (aeval st (fold_constants_aexp a[2])).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But the soundness of constant folding for arithmetic expressions (fold_constants_aexp_sound)
    gives us
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: (Doing induction when there are a lot of constructors makes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: specifying variable names a chore, but Coq doesn't always
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: choose nice variable names.  We can rename entries in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'context with the rename tactic: rename a into a[1] will'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: change a to a[1] in the current goal and context.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (fold_constants_com_sound)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Complete the WHILE case of the following proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Fixpoint optimize_0plus (e:aexp) : aexp :=
  prefs: []
  type: TYPE_NORMAL
- en: match e with
  prefs: []
  type: TYPE_NORMAL
- en: '| ANum n ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: ANum n
  prefs: []
  type: TYPE_NORMAL
- en: '| APlus (ANum 0) e[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: optimize_0plus e[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| APlus e[1] e[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: APlus (optimize_0plus e[1]) (optimize_0plus e[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| AMinus e[1] e[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: AMinus (optimize_0plus e[1]) (optimize_0plus e[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| AMult e[1] e[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: AMult (optimize_0plus e[1]) (optimize_0plus e[2])
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this function is defined over the old aexps,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: without states.
  prefs: []
  type: TYPE_NORMAL
- en: Write a new version of this function that accounts for variables,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'plus analogous ones for bexps and commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Proving That Programs Are *Not* Equivalent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that c[1] is a command of the form X ::= a[1];; Y ::= a[2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and c[2] is the command X ::= a[1];; Y ::= a[2]', where a[2]' is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: formed by substituting a[1] for all occurrences of X in a[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, c[1] and c[2] might be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint subst_aexp (i : id) (u : aexp) (a : aexp) : aexp :='
  prefs: []
  type: TYPE_NORMAL
- en: match a with
  prefs: []
  type: TYPE_NORMAL
- en: '| ANum n       ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: ANum n
  prefs: []
  type: TYPE_NORMAL
- en: '| AId i''       ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if beq_id i i' then u else AId i'
  prefs: []
  type: TYPE_NORMAL
- en: '| APlus a[1] a[2]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: APlus (subst_aexp i u a[1]) (subst_aexp i u a[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| AMinus a[1] a[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: AMinus (subst_aexp i u a[1]) (subst_aexp i u a[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| AMult a[1] a[2]  ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: AMult (subst_aexp i u a[1]) (subst_aexp i u a[2])
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example subst_aexp_ex :'
  prefs: []
  type: TYPE_NORMAL
- en: subst_aexp X (APlus (ANum 42) (ANum 53))
  prefs: []
  type: TYPE_NORMAL
- en: (APlus (AId Y) (AId X))
  prefs: []
  type: TYPE_NORMAL
- en: = (APlus (AId Y) (APlus (ANum 42) (ANum 53))).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Definition subst_equiv_property := ∀i[1] i[2] a[1] a[2],
  prefs: []
  type: TYPE_NORMAL
- en: cequiv (i[1] ::= a[1];; i[2] ::= a[2])
  prefs: []
  type: TYPE_NORMAL
- en: (i[1] ::= a[1];; i[2] ::= subst_aexp i[1] a[1] a[2]).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: cequiv (i[1] ::= a[1];; i[2] ::= a[2])
  prefs: []
  type: TYPE_NORMAL
- en: (i[1] ::= a[1];; i[2] ::= subst_aexp i[1] a[1] a[2]).
  prefs: []
  type: TYPE_NORMAL
- en: To see this, suppose (for a contradiction) that for all i[1], i[2],
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a[1], and a[2], we have
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: X ::= APlus (AId X) (ANum 1);; Y ::= AId X
  prefs: []
  type: TYPE_NORMAL
- en: Note that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: cequiv (X ::= APlus (AId X) (ANum 1);;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AId X)
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= APlus (AId X) (ANum 1);;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId X) (ANum 1))
  prefs: []
  type: TYPE_NORMAL
- en: so, by the definition of cequiv, we have
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))
  prefs: []
  type: TYPE_NORMAL
- en: / empty_state ⇓ st[2],
  prefs: []
  type: TYPE_NORMAL
- en: where st[2] = { X ↦ 1, Y ↦ 2 }.  But st[1] ≠ st[2], which is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: contradiction, since ceval is deterministic!  ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 4 stars, optional (better_subst_equiv)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The equivalence we had in mind above was not complete nonsense —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it was actually almost right.  To make it correct, we just need to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: exclude the case where the variable X occurs in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: right-hand-side of the first assignment statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Using var_not_used_in_aexp, formalize and prove a correct verson
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of subst_equiv_property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (inequiv_exercise)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove that an infinite loop is not equivalent to SKIP
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: x = 0;;
  prefs: []
  type: TYPE_NORMAL
- en: f(++x, x)
  prefs: []
  type: TYPE_NORMAL
- en: might call f with arguments (1, 0) or (1, 1), depending how
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the compiler chooses to order things.  This can be a little
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: confusing for programmers, but it gives the compiler writer useful
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: freedom.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we will extend Imp with a simple
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nondeterministic command and study how this change affects
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: program equivalence.  The new command has the syntax HAVOC X,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where X is an identifier. The effect of executing HAVOC X is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to assign an *arbitrary* number to the variable X,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'nondeterministically. For example, after executing the program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Module Himp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive com : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| CSkip : com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CAss : id → aexp → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CSeq : com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CIf : bexp → com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CWhile : bexp → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CHavoc : id → com. (* <---- new *)'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'SKIP'" :=
  prefs: []
  type: TYPE_NORMAL
- en: CSkip.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "X '::=' a" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CAss X a) (at level 60).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "c1 ;; c2" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CWhile b c) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CIf e[1] e[2] e[3]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'HAVOC' l" := (CHavoc l) (at level 60).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "c1 '/' st '⇓' st'"
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive ceval : com → state → state → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Skip : ∀st : state, SKIP / st ⇓ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Ass : ∀(st : state) (a[1] : aexp) (n : nat) (X : id),'
  prefs: []
  type: TYPE_NORMAL
- en: aeval st a[1] = n →
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= a[1]) / st ⇓ t_update st X n
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Seq : ∀(c[1] c[2] : com) (st st'' st'''' : state),'
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / st' ⇓ st'' →
  prefs: []
  type: TYPE_NORMAL
- en: (c[1] ;; c[2]) / st ⇓ st''
  prefs: []
  type: TYPE_NORMAL
- en: '| E_IfTrue : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = true →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_IfFalse : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = false →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_WhileEnd : ∀(b[1] : bexp) (st : state) (c[1] : com),'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = false →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / st ⇓ st
  prefs: []
  type: TYPE_NORMAL
- en: '| E_WhileLoop : ∀(st st'' st'''' : state) (b[1] : bexp) (c[1] : com),'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = true →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / st' ⇓ st'' →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / st ⇓ st''
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: where "c1 '/' st '⇓' st'" := (ceval c[1] st st').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Example havoc_example1 : (HAVOC X) / empty_state ⇓ t_update empty_state X 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example havoc_example2 :'
  prefs: []
  type: TYPE_NORMAL
- en: (SKIP;; HAVOC Z) / empty_state ⇓ t_update empty_state Z 42.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition cequiv (c[1] c[2] : com) : Prop := ∀st st'' : state,'
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' ↔ c[2] / st ⇓ st'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Definition pXY :=
  prefs: []
  type: TYPE_NORMAL
- en: HAVOC X;; HAVOC Y.
  prefs: []
  type: TYPE_NORMAL
- en: Definition pYX :=
  prefs: []
  type: TYPE_NORMAL
- en: HAVOC Y;; HAVOC X.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem pXY_cequiv_pYX :'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv pXY pYX ∨ ¬cequiv pXY pYX.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Definition ptwice :=
  prefs: []
  type: TYPE_NORMAL
- en: HAVOC X;; HAVOC Y.
  prefs: []
  type: TYPE_NORMAL
- en: Definition pcopy :=
  prefs: []
  type: TYPE_NORMAL
- en: HAVOC X;; Y ::= AId X.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ptwice_cequiv_pcopy :'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv ptwice pcopy ∨ ¬cequiv ptwice pcopy.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition p[1] : com :='
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (BNot (BEq (AId X) (ANum 0))) DO
  prefs: []
  type: TYPE_NORMAL
- en: HAVOC Y;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition p[2] : com :='
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (BNot (BEq (AId X) (ANum 0))) DO
  prefs: []
  type: TYPE_NORMAL
- en: SKIP
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma p1_may_diverge : ∀st st'', st X ≠ 0 →'
  prefs: []
  type: TYPE_NORMAL
- en: ¬ p[1] / st ⇓ st'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma p2_may_diverge : ∀st st'', st X ≠ 0 →'
  prefs: []
  type: TYPE_NORMAL
- en: ¬ p[2] / st ⇓ st'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem p1_p2_equiv : cequiv p[1] p[2].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition p[3] : com :='
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 1;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (BNot (BEq (AId X) (ANum 0))) DO
  prefs: []
  type: TYPE_NORMAL
- en: HAVOC X;;
  prefs: []
  type: TYPE_NORMAL
- en: HAVOC Z
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition p[4] : com :='
  prefs: []
  type: TYPE_NORMAL
- en: X ::= (ANum 0);;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= (ANum 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem p3_p4_inequiv : ¬ cequiv p[3] p[4].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition p[5] : com :='
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (BNot (BEq (AId X) (ANum 1))) DO
  prefs: []
  type: TYPE_NORMAL
- en: HAVOC X
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition p[6] : com :='
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem p5_p6_equiv : cequiv p[5] p[6].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: End Himp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: for (c[1] ; b ; c[2]) {
  prefs: []
  type: TYPE_NORMAL
- en: c[3]
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'is equivalent to:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem swap_noninterfering_assignments: ∀l[1] l[2] a[1] a[2],'
  prefs: []
  type: TYPE_NORMAL
- en: l[1] ≠ l[2] →
  prefs: []
  type: TYPE_NORMAL
- en: var_not_used_in_aexp l[1] a[2] →
  prefs: []
  type: TYPE_NORMAL
- en: var_not_used_in_aexp l[2] a[1] →
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  prefs: []
  type: TYPE_NORMAL
- en: (l[1] ::= a[1];; l[2] ::= a[2])
  prefs: []
  type: TYPE_NORMAL
- en: (l[2] ::= a[2];; l[1] ::= a[1]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition capprox (c[1] c[2] : com) : Prop := ∀(st st'' : state),'
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' → c[2] / st ⇓ st'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition c[3] : com (* REPLACE THIS LINE WITH ":= _your_definition_ ." *).
    Admitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition c[4] : com (* REPLACE THIS LINE WITH ":= _your_definition_ ." *).
    Admitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem c3_c4_different : ¬ capprox c[3] c[4] ∧ ¬ capprox c[4] c[3].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition cmin : com'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem cmin_minimal : ∀c, capprox cmin c.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition zprop (c : com) : Prop'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem zprop_preserving : ∀c c'','
  prefs: []
  type: TYPE_NORMAL
- en: zprop c → capprox c c' → zprop c'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
