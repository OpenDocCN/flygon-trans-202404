- en: EquivProgram Equivalence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (* IMPORTS *)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Bool.Bool.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.Arith.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.EqNat.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.omega.Omega.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Lists.List.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Logic.FunctionalExtensionality.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Import ListNotations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: (* /IMPORTS *)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Behavioral Equivalence
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an earlier chapter, we investigated the correctness of a very
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'simple program transformation: the optimize_0plus function.  The'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programming language we were considering was the first version of
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the language of arithmetic expressions — with no variables — so
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in that setting it was very easy to define what it means for a
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'program transformation to be correct: it should always yield a'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: program that evaluates to the same number as the original.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To talk about the correctness of program transformations for the
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: full Imp language, including assignment and other commands, we
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need to consider the role of variables and state.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Definition aequiv (a[1] a[2] : aexp) : Prop :='
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: ∀(st:state),
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: aeval st a[1] = aeval st a[2].
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition bequiv (b[1] b[2] : bexp) : Prop :='
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: ∀(st:state),
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = beval st b[2].
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Theorem aequiv_example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: aequiv (AMinus (AId X) (AId X)) (ANum 0).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros st. simpl. omega.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Theorem bequiv_example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: bequiv (BEq (AMinus (AId X) (AId X)) (ANum 0)) BTrue.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros st. unfold [beval](Imp.html#beval).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [aequiv_example](Equiv.html#aequiv_example). reflexivity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Definition cequiv (c[1] c[2] : com) : Prop :='
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '∀(st st'' : state),'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: (c[1] / st ⇓ st') ↔ (c[2] / st ⇓ st').
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Theorem skip_left: ∀c,'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: (SKIP;; c)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: c.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: intros c st st'.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: split; intros H.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. subst.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[2]. subst.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: apply E_Seq with st.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: apply E_Skip.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Theorem skip_right: ∀c,'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: (c ;; SKIP)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: c.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Theorem IFB_true_simple: ∀c[1] c[2],'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: (IFB BTrue THEN c[1] ELSE c[2] FI)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: c[1].
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros c[1] c[2].
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: split; intros H.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst. assumption. inversion H[5].
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_IfTrue](Imp.html#E_IfTrue). reflexivity. assumption. Qed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Theorem IFB_true: ∀b c[1] c[2],'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b BTrue  →
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN c[1] ELSE c[2] FI)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: c[1].
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros b c[1] c[2] Hb.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: split; intros H.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: + (* b evaluates to true *)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: + (* b evaluates to false (contradiction) *)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: unfold [bequiv](Equiv.html#bequiv) in Hb. simpl in Hb.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: rewrite Hb in H[5].
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[5].
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: apply [E_IfTrue](Imp.html#E_IfTrue); try assumption.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: unfold [bequiv](Equiv.html#bequiv) in Hb. simpl in Hb.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: rewrite Hb. reflexivity. Qed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Theorem IFB_false: ∀b c[1] c[2],'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b BFalse  →
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN c[1] ELSE c[2] FI)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: c[2].
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Theorem swap_if_branches: ∀b e[1] e[2],'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN e[1] ELSE e[2] FI)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: (IFB BNot b THEN e[2] ELSE e[1] FI).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Theorem WHILE_false : ∀b c,'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: bequiv b BFalse →
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: cequiv
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b DO c END)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: SKIP.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros b c Hb. split; intros H.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 b c Hb。分割；假设 H。
- en: '- (* -> *)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* -> *)'
- en: inversion H; subst.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H; 替换。
- en: + (* E_WhileEnd *)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E_WhileEnd *)
- en: apply [E_Skip](Imp.html#E_Skip).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [E_Skip](Imp.html#E_Skip)。
- en: + (* E_WhileLoop *)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E_WhileLoop *)
- en: rewrite Hb in H[2]. inversion H[2].
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hb 中重写 H[2]。反演 H[2]。
- en: '- (* <- *)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* <- *)'
- en: inversion H; subst.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H; 替换。
- en: apply [E_WhileEnd](Imp.html#E_WhileEnd).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [E_WhileEnd](Imp.html#E_WhileEnd)。
- en: rewrite Hb.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 Hb。
- en: reflexivity. Qed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。证明。
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lemma WHILE_true_nonterm : ∀b c st st'','
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 WHILE_true_nonterm: ∀b c st st''，'
- en: bequiv b BTrue →
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: bequiv b BTrue →
- en: ~( (WHILE b DO c END) / st ⇓ st' ).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ~( (WHILE b DO c END) / st ⇓ st' )。
- en: Proof.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* WORKED IN CLASS *)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在课堂上运行 *)
- en: intros b c st st' Hb.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 b c st st' Hb。
- en: intros H.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 H。
- en: remember (WHILE b DO c END) as cw eqn:Heqcw.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 (WHILE b DO c END) 为 cw，等式为 Heqcw。
- en: induction H;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 H;
- en: (* Most rules don't apply, and we can rule them out        by inversion *)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: (* 大多数规则不适用，我们可以通过反演来排除它们 *)
- en: inversion Heqcw; subst; clear Heqcw.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Heqcw; 替换；清除 Heqcw。
- en: (* The two interesting cases are the ones for WHILE loops: *)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (* 两个有趣的情况是 WHILE 循环的情况： *)
- en: '- (* E_WhileEnd *) (* contradictory -- b is always true! *)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E_WhileEnd *) (* 矛盾 -- b 总是为真！ *)'
- en: unfold bequiv in Hb.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hb 中展开 bequiv。
- en: (* rewrite is able to instantiate the quantifier in st *)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (* rewrite 能够实例化 st 中的量词 *)
- en: rewrite Hb in H. inversion H.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H 中重写 Hb。反演 H。
- en: '- (* E_WhileLoop *) (* immediate from the IH *)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E_WhileLoop *) (* 立即由 IH 推出 *)'
- en: apply IHceval2. reflexivity. Qed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHceval2。一致性。已证明。
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Theorem WHILE_true: ∀b c,'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 WHILE_true: ∀b c，'
- en: bequiv b BTrue  →
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: bequiv b BTrue →
- en: cequiv
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv
- en: (WHILE b DO c END)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b DO c END)
- en: (WHILE BTrue DO SKIP END).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE BTrue DO SKIP END)。
- en: Proof.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *) 已承认。
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Theorem loop_unrolling: ∀b c,'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 loop_unrolling: ∀b c，'
- en: cequiv
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv
- en: (WHILE b DO c END)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b DO c END)
- en: (IFB b THEN (c ;; WHILE b DO c END) ELSE SKIP FI).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b THEN (c ;; WHILE b DO c END) ELSE SKIP FI)。
- en: Proof.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* WORKED IN CLASS *)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在课堂上运行 *)
- en: intros b c st st'.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设 b c st st'。
- en: split; intros Hce.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 分割；假设 Hce。
- en: '- (* -> *)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* -> *)'
- en: inversion Hce; subst.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Hce; 替换。
- en: + (* loop doesn't run *)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: + (* 循环不运行 *)
- en: apply [E_IfFalse](Imp.html#E_IfFalse). assumption. apply [E_Skip](Imp.html#E_Skip).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [E_IfFalse](Imp.html#E_IfFalse)。假设。应用 [E_Skip](Imp.html#E_Skip)。
- en: + (* loop runs *)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: + (* 循环运行 *)
- en: apply [E_IfTrue](Imp.html#E_IfTrue). assumption.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [E_IfTrue](Imp.html#E_IfTrue)。假设。
- en: apply [E_Seq](Imp.html#E_Seq) with (st' := st'0). assumption. assumption.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [E_Seq](Imp.html#E_Seq) 与 (st' := st'0)。假设。假设。
- en: '- (* <- *)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* <- *)'
- en: inversion Hce; subst.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Hce; 替换。
- en: + (* loop runs *)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: + (* 循环运行 *)
- en: inversion H[5]; subst.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H[5]; 替换。
- en: apply [E_WhileLoop](Imp.html#E_WhileLoop) with (st' := st'0).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [E_WhileLoop](Imp.html#E_WhileLoop) 与 (st' := st'0)。
- en: assumption. assumption. assumption.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设。假设。假设。
- en: + (* loop doesn't run *)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: + (* 循环不运行 *)
- en: inversion H[5]; subst. apply [E_WhileEnd](Imp.html#E_WhileEnd). assumption.
    Qed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H[5]; 替换。应用 [E_WhileEnd](Imp.html#E_WhileEnd)。假设。已证明。
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Theorem seq_assoc : ∀c[1] c[2] c[3],'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 seq_assoc: ∀c[1] c[2] c[3]，'
- en: cequiv ((c[1];;c[2]);;c[3]) (c[1];;(c[2];;c[3])).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv ((c[1];;c[2]);;c[3]) (c[1];;(c[2];;c[3])。
- en: Proof.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *) 已承认。
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Theorem identity_assignment : ∀(X:id),'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 identity_assignment: ∀(X:id)，'
- en: cequiv
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv
- en: (X ::= AId X)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= AId X)
- en: SKIP.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过。
- en: Proof.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros. split; intro H.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: intros。分割；引入 H。
- en: '- (* -> *)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* -> *)'
- en: inversion H; subst. simpl.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H; 替换。简化。
- en: replace ([t_update](Maps.html#t_update) st X (st X)) with st.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 用 ([t_update](Maps.html#t_update) st X (st X)) 替换 st。
- en: + constructor.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: + 构造者。
- en: + apply [functional_extensionality](http://coq.inria.fr/library/Coq.Logic.FunctionalExtensionality.html#functional_extensionality).
    intro.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [functional_extensionality](http://coq.inria.fr/library/Coq.Logic.FunctionalExtensionality.html#functional_extensionality)。介绍。
- en: rewrite [t_update_same](Maps.html#t_update_same); reflexivity.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 [t_update_same](Maps.html#t_update_same)；一致性。
- en: '- (* <- *)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* <- *)'
- en: replace st' with ([t_update](Maps.html#t_update) st' X ([aeval](Imp.html#aeval)
    st' ([AId](Imp.html#AId) X))).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 用 ([t_update](Maps.html#t_update) st' X ([aeval](Imp.html#aeval) st' ([AId](Imp.html#AId)
    X))) 替换 st'。
- en: + inversion H. subst. apply [E_Ass](Imp.html#E_Ass). reflexivity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: + 反演 H。替换。应用 [E_Ass](Imp.html#E_Ass)。一致性。
- en: + apply [functional_extensionality](http://coq.inria.fr/library/Coq.Logic.FunctionalExtensionality.html#functional_extensionality).
    intro.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: + 应用 [functional_extensionality](http://coq.inria.fr/library/Coq.Logic.FunctionalExtensionality.html#functional_extensionality)。介绍。
- en: rewrite [t_update_same](Maps.html#t_update_same). reflexivity.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 [t_update_same](Maps.html#t_update_same)。一致性。
- en: Qed.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已承认。
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Theorem assign_aequiv : ∀X e,'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 assign_aequiv: ∀X e，'
- en: aequiv (AId X) e →
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: aequiv (AId X) e →
- en: cequiv SKIP (X ::= e).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv SKIP (X ::= e)。
- en: Proof.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *) 已承认。
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[ [prog_a;prog_b;prog_c;prog_d;prog_e;prog_f;prog_g;prog_h] ;'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[ [prog_a;prog_b;prog_c;prog_d;prog_e;prog_f;prog_g;prog_h] ;'
- en: '[prog_i] ]'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[prog_i] ]'
- en: Write down your answer below in the definition of
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的定义中写下你的答案
- en: equiv_classes.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等价类。
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ☐
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Behavioral Equivalence Is an Equivalence
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为等价是一个等价关系
- en: First, we verify that the equivalences on aexps, bexps, and
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们验证 aexps、bexps 和的等价性
- en: coms really are *equivalences* — i.e., that they are reflexive,
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: coms 确实是*等价* — 即，它们是自反的，
- en: symmetric, and transitive.  The proofs are all easy.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对称的，且传递的。所有证明都很容易。
- en: '[PRE21]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Behavioral Equivalence Is a Congruence
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为等价是一个同余关系
- en: Less obviously, behavioral equivalence is also a *congruence*.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更不明显的是，行为等价也是一个*同余关系*。
- en: That is, the equivalence of two subprograms implies the
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，两个子程序的等价性意味着
- en: 'equivalence of the larger programs in which they are embedded:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们嵌入的较大程序的等价性：
- en: aequiv a[1] a[1]'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: aequiv a[1] a[1]'
- en: '|'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: cequiv (i ::= a[1]) (i ::= a[1]')
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: cequiv (i ::= a[1]) (i ::= a[1]')
- en: '|'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: cequiv c[1] c[1]'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: cequiv c[1] c[1]'
- en: '|'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: cequiv c[2] c[2]'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: cequiv c[2] c[2]'
- en: '|'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: cequiv (c[1];;c[2]) (c[1]';;c[2]')
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: cequiv (c[1];;c[2]) (c[1]';;c[2]')
- en: '|'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '...and so on for the other forms of commands.'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...等等其他形式的命令。'
- en: (Note that we are using the inference rule notation here not
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （请注意，这里我们使用推理规则符号，而不是
- en: as part of a definition, but simply to write down some valid
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为定义的一部分，而只是写下一些有效的
- en: implications in a readable format. We prove these implications
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以可读的格式证明这些含义。我们证明这些含义
- en: below.)
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '下文。 '
- en: We will see a concrete example of why these congruence
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将看到为什么这些同余性的具体示例
- en: properties are important in the following section (in the proof of
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些属性在以下部分中很重要（在证明中
- en: fold_constants_com_sound), but the main idea is that they allow
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fold_constants_com_sound），但主要思想是它们允许
- en: us to replace a small part of a large program with an equivalent
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以用一个等价的小部分替换大程序的一部分
- en: small part and know that the whole large programs are equivalent
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 微小部分，并知道整个大程序是等价的
- en: '*without* doing an explicit proof about the non-varying parts —'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*而不是*对于不变部分进行显式证明 —'
- en: i.e., the "proof burden" of a small change to a large program is
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，对于大程序的微小更改的“证明负担”是
- en: proportional to the size of the change, not the program.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与更改的大小成比例，而不是程序的大小。
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The congruence property for loops is a little more interesting,
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 循环的同余性质更有趣，
- en: since it requires induction.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为它需要归纳。
- en: '*Theorem*: Equivalence is a congruence for WHILE — that is, if'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*定理*：对于 WHILE，等价是一个同余关系 — 即，如果'
- en: b[1] is equivalent to b[1]' and c[1] is equivalent to c[1]', then
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b[1] 等价于 b[1]'，c[1] 等价于 c[1]'，那么
- en: WHILE b[1] DO c[1] END is equivalent to WHILE b[1]' DO c[1]' END.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WHILE b[1] DO c[1] END 等价于 WHILE b[1]' DO c[1]' END。
- en: '*Proof*: Suppose b[1] is equivalent to b[1]'' and c[1] is'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*证明*：假设 b[1] 等价于 b[1]''，c[1] 等价于'
- en: equivalent to c[1]'.  We must show, for every st and st', that
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等价于 c[1]'。我们必须证明，对于每个 st 和 st'，都有
- en: WHILE b[1] DO c[1] END / st ⇓ st' iff WHILE b[1]' DO c[1]' END / st ⇓ st'.  We
    consider the two directions separately.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WHILE b[1] DO c[1] END / st ⇓ st' 当且仅当 WHILE b[1]' DO c[1]' END / st ⇓ st'。我们分别考虑这两个方向。
- en: (→) We show that WHILE b[1] DO c[1] END / st ⇓ st' implies WHILE b[1]' DO c[1]'
    END / st ⇓ st', by induction on a derivation of WHILE b[1] DO c[1] END / st ⇓
    st'. The only nontrivial cases are when the final rule in the derivation is E_WhileEnd
    or E_WhileLoop.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （→）我们通过对 WHILE b[1] DO c[1] END / st ⇓ st' 的推导进行归纳，证明 WHILE b[1] DO c[1] END
    / st ⇓ st' 意味着 WHILE b[1]' DO c[1]' END / st ⇓ st'，推导的最终规则是 E_WhileEnd 或 E_WhileLoop
    时，这是唯一的非平凡情况。
- en: 'E_WhileEnd: In this case, the form of the rule gives us beval st b[1] = false
    and st = st''. But then, since b[1] and b[1]'' are equivalent, we have beval st
    b[1]'' = false, and E-WhileEnd applies, giving us WHILE b[1]'' DO c[1]'' END /
    st ⇓ st'', as required.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: E_WhileEnd：在这种情况下，规则的形式给出 beval st b[1] = false 和 st = st'。但是，由于 b[1] 和 b[1]'
    是等价的，我们有 beval st b[1]' = false，然后 E-WhileEnd 应用，给出 WHILE b[1]' DO c[1]' END /
    st ⇓ st'，如所需。
- en: 'E_WhileLoop: The form of the rule now gives us beval st b[1] = true, with c[1]
    / st ⇓ st''0 and WHILE b[1] DO c[1] END / st''0 ⇓ st'' for some state st''0, with
    the induction hypothesis WHILE b[1]'' DO c[1]'' END / st''0 ⇓ st''.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: E_WhileLoop：现在规则的形式给出 beval st b[1] = true，其中 c[1] / st ⇓ st'0，且 WHILE b[1]
    DO c[1] END / st'0 ⇓ st' 对于某个状态 st'0，根据归纳假设 WHILE b[1]' DO c[1]' END / st'0 ⇓
    st'。
- en: Since c[1] and c[1]' are equivalent, we know that c[1]' / st ⇓ st'0. And since
    b[1] and b[1]' are equivalent, we have beval st b[1]' = true. Now E-WhileLoop
    applies, giving us WHILE b[1]' DO c[1]' END / st ⇓ st', as required.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 c[1] 和 c[1]' 是等价的，我们知道 c[1]' / st ⇓ st'0。由于 b[1] 和 b[1]' 是等价的，我们有 beval st
    b[1]' = true。现在 E-WhileLoop 应用，给出 WHILE b[1]' DO c[1]' END / st ⇓ st'，如所需。
- en: (←) Similar. ☐
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （←）类似。☐
- en: '[PRE23]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Exercise: 3 stars, optional (CSeq_congruence)'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，可选（CSeq_congruence）
- en: '[PRE24]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ☐
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars (CIf_congruence)'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星（CIf_congruence）
- en: '[PRE25]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ☐
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: For example, here are two equivalent programs and a proof of their
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，这里有两个等价的程序及其证明
- en: equivalence...
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: equivalence...
- en: '[PRE26]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Exercise: 3 stars, advanced, optional (not_congr)'
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'Exercise: 3 stars, advanced, optional (not_congr)'
- en: We've shown that the cequiv relation is both an equivalence and
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: We've shown that the cequiv relation is both an equivalence and
- en: a congruence on commands.  Can you think of a relation on commands
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a congruence on commands.  Can you think of a relation on commands
- en: that is an equivalence but *not* a congruence?
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: that is an equivalence but *not* a congruence?
- en: '[PRE27]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ☐
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE28]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Definition atrans_sound (atrans : aexp → aexp) : Prop :='
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'Definition atrans_sound (atrans : aexp → aexp) : Prop :='
- en: '∀(a : aexp),'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(a : aexp),'
- en: aequiv a (atrans a).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: aequiv a (atrans a).
- en: 'Definition btrans_sound (btrans : bexp → bexp) : Prop :='
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'Definition btrans_sound (btrans : bexp → bexp) : Prop :='
- en: '∀(b : bexp),'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(b : bexp),'
- en: bequiv b (btrans b).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: bequiv b (btrans b).
- en: 'Definition ctrans_sound (ctrans : com → com) : Prop :='
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'Definition ctrans_sound (ctrans : com → com) : Prop :='
- en: '∀(c : com),'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(c : com),'
- en: cequiv c (ctrans c).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv c (ctrans c).
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Fixpoint fold_constants_aexp (a : aexp) : aexp :='
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint fold_constants_aexp (a : aexp) : aexp :='
- en: match a with
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: match a with
- en: '| ANum n       ⇒ ANum n'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '| ANum n       ⇒ ANum n'
- en: '| AId i        ⇒ AId i'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '| AId i        ⇒ AId i'
- en: '| APlus a[1] a[2]  ⇒'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '| APlus a[1] a[2]  ⇒'
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
- en: with
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: with
- en: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] + n[2])'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] + n[2])'
- en: '| (a[1]'', a[2]'') ⇒ APlus a[1]'' a[2]'''
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '| (a[1]'', a[2]'') ⇒ APlus a[1]'' a[2]'''
- en: end
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '| AMinus a[1] a[2] ⇒'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '| AMinus a[1] a[2] ⇒'
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
- en: with
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: with
- en: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] - n[2])'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] - n[2])'
- en: '| (a[1]'', a[2]'') ⇒ AMinus a[1]'' a[2]'''
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '| (a[1]'', a[2]'') ⇒ AMinus a[1]'' a[2]'''
- en: end
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '| AMult a[1] a[2]  ⇒'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '| AMult a[1] a[2]  ⇒'
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: match (fold_constants_aexp a[1], fold_constants_aexp a[2])
- en: with
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: with
- en: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] * n[2])'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '| (ANum n[1], ANum n[2]) ⇒ ANum (n[1] * n[2])'
- en: '| (a[1]'', a[2]'') ⇒ AMult a[1]'' a[2]'''
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '| (a[1]'', a[2]'') ⇒ AMult a[1]'' a[2]'''
- en: end
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: end.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: end.
- en: 'Example fold_aexp_ex[1] :'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example fold_aexp_ex[1] :'
- en: fold_constants_aexp
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: fold_constants_aexp
- en: (AMult (APlus (ANum 1) (ANum 2)) (AId X))
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: (AMult (APlus (ANum 1) (ANum 2)) (AId X))
- en: = AMult (ANum 3) (AId X).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: = AMult (ANum 3) (AId X).
- en: Proof. reflexivity. Qed.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof. reflexivity. Qed.
- en: '[PRE30]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Example fold_aexp_ex[2] :'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example fold_aexp_ex[2] :'
- en: fold_constants_aexp
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: fold_constants_aexp
- en: (AMinus (AId X) (APlus (AMult (ANum 0) (ANum 6))
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: (AMinus (AId X) (APlus (AMult (ANum 0) (ANum 6))
- en: (AId Y)))
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: (AId Y)))
- en: = AMinus (AId X) (APlus (ANum 0) (AId Y)).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: = AMinus (AId X) (APlus (ANum 0) (AId Y)).
- en: Proof. reflexivity. Qed.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof. reflexivity. Qed.
- en: '[PRE31]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Fixpoint fold_constants_bexp (b : bexp) : bexp :='
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint fold_constants_bexp (b : bexp) : bexp :='
- en: match b with
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: match b with
- en: '| BTrue        ⇒ BTrue'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '| BTrue        ⇒ BTrue'
- en: '| BFalse       ⇒ BFalse'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '| BFalse       ⇒ BFalse'
- en: '| BEq a[1] a[2]  ⇒'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '| BEq a[1] a[2]  ⇒'
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2]) with
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: match (fold_constants_aexp a[1], fold_constants_aexp a[2]) with
- en: '| (ANum n[1], ANum n[2]) ⇒'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '| (ANum n[1], ANum n[2]) ⇒'
- en: if beq_nat n[1] n[2] then BTrue else BFalse
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: if beq_nat n[1] n[2] then BTrue else BFalse
- en: '| (a[1]'', a[2]'') ⇒'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '| (a[1]'', a[2]'') ⇒'
- en: BEq a[1]' a[2]'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: BEq a[1]' a[2]'
- en: end
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '| BLe a[1] a[2]  ⇒'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '| BLe a[1] a[2]  ⇒'
- en: match (fold_constants_aexp a[1], fold_constants_aexp a[2]) with
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: match (fold_constants_aexp a[1], fold_constants_aexp a[2]) with
- en: '| (ANum n[1], ANum n[2]) ⇒'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '| (ANum n[1], ANum n[2]) ⇒'
- en: if leb n[1] n[2] then BTrue else BFalse
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: if leb n[1] n[2] then BTrue else BFalse
- en: '| (a[1]'', a[2]'') ⇒'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '| (a[1]'', a[2]'') ⇒'
- en: BLe a[1]' a[2]'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: BLe a[1]' a[2]'
- en: end
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '| BNot b[1]  ⇒'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '| BNot b[1]  ⇒'
- en: match (fold_constants_bexp b[1]) with
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: match (fold_constants_bexp b[1]) with
- en: '| BTrue ⇒ BFalse'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '| BTrue ⇒ BFalse'
- en: '| BFalse ⇒ BTrue'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '| BFalse ⇒ BTrue'
- en: '| b[1]'' ⇒ BNot b[1]'''
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '| b[1]'' ⇒ BNot b[1]'''
- en: end
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '| BAnd b[1] b[2]  ⇒'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '| BAnd b[1] b[2]  ⇒'
- en: match (fold_constants_bexp b[1], fold_constants_bexp b[2]) with
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: match (fold_constants_bexp b[1], fold_constants_bexp b[2]) with
- en: '| (BTrue, BTrue) ⇒ BTrue'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '| (BTrue, BTrue) ⇒ BTrue'
- en: '| (BTrue, BFalse) ⇒ BFalse'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '| (BTrue, BFalse) ⇒ BFalse'
- en: '| (BFalse, BTrue) ⇒ BFalse'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '| (BFalse, BTrue) ⇒ BFalse'
- en: '| (BFalse, BFalse) ⇒ BFalse'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '| (BFalse, BFalse) ⇒ BFalse'
- en: '| (b[1]'', b[2]'') ⇒ BAnd b[1]'' b[2]'''
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '| (b[1]'', b[2]'') ⇒ BAnd b[1]'' b[2]'''
- en: end
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: end.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: end.
- en: 'Example fold_bexp_ex[1] :'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example fold_bexp_ex[1] :'
- en: fold_constants_bexp (BAnd BTrue (BNot (BAnd BFalse BTrue)))
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: fold_constants_bexp (BAnd BTrue (BNot (BAnd BFalse BTrue)))
- en: = BTrue.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: = BTrue.
- en: Proof. reflexivity. Qed.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof. reflexivity. Qed.
- en: 'Example fold_bexp_ex[2] :'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example fold_bexp_ex[2] :'
- en: fold_constants_bexp
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: fold_constants_bexp
- en: (BAnd (BEq (AId X) (AId Y))
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: (BAnd (BEq (AId X) (AId Y))
- en: (BEq (ANum 0)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: (BEq (ANum 0)
- en: (AMinus (ANum 2) (APlus (ANum 1)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: (AMinus (ANum 2) (APlus (ANum 1)
- en: (ANum 1)))))
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: (ANum 1)))))
- en: = BAnd (BEq (AId X) (AId Y)) BTrue.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: = BAnd (BEq (AId X) (AId Y)) BTrue.
- en: Proof. reflexivity. Qed.
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof. reflexivity. Qed.
- en: '[PRE32]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Fixpoint fold_constants_com (c : com) : com :='
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint fold_constants_com (c : com) : com :='
- en: match c with
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: match c with
- en: '| SKIP      ⇒'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '| SKIP      ⇒'
- en: SKIP
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP
- en: '| i ::= a  ⇒'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '| i ::= a  ⇒'
- en: CAss i (fold_constants_aexp a)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: CAss i (fold_constants_aexp a)
- en: '| c[1] ;; c[2]  ⇒'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '| c[1] ;; c[2]  ⇒'
- en: (fold_constants_com c[1]) ;; (fold_constants_com c[2])
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: (fold_constants_com c[1]) ;; (fold_constants_com c[2])
- en: '| IFB b THEN c[1] ELSE c[2] FI ⇒'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '| IFB b THEN c[1] ELSE c[2] FI ⇒'
- en: match fold_constants_bexp b with
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: match fold_constants_bexp b with
- en: '| BTrue ⇒ fold_constants_com c[1]'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '| BTrue ⇒ fold_constants_com c[1]'
- en: '| BFalse ⇒ fold_constants_com c[2]'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '| BFalse ⇒ fold_constants_com c[2]'
- en: '| b'' ⇒ IFB b'' THEN fold_constants_com c[1]'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '| b'' ⇒ IFB b'' THEN fold_constants_com c[1]'
- en: ELSE fold_constants_com c[2] FI
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE fold_constants_com c[2] FI
- en: end
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '| WHILE b DO c END ⇒'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '| WHILE b DO c END ⇒'
- en: match fold_constants_bexp b with
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 fold_constants_bexp b with
- en: '| BTrue ⇒ WHILE BTrue DO SKIP END'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '| BTrue ⇒ WHILE BTrue DO SKIP END'
- en: '| BFalse ⇒ SKIP'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '| BFalse ⇒ SKIP'
- en: '| b'' ⇒ WHILE b'' DO (fold_constants_com c) END'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '| b'' ⇒ WHILE b'' DO (fold_constants_com c) END'
- en: end
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: end.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: end.
- en: 'Example fold_com_ex[1] :'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 fold_com_ex[1]：
- en: fold_constants_com
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: fold_constants_com
- en: (* Original program: *)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: (* 原始程序： *)
- en: (X ::= APlus (ANum 4) (ANum 5);;
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= APlus (ANum 4) (ANum 5);;
- en: Y ::= AMinus (AId X) (ANum 3);;
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AMinus (AId X) (ANum 3);;
- en: IFB BEq (AMinus (AId X) (AId Y))
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BEq (AMinus (AId X) (AId Y))
- en: (APlus (ANum 2) (ANum 4)) THEN
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: (APlus (ANum 2) (ANum 4)) 然后
- en: SKIP
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP
- en: ELSE
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE
- en: Y ::= ANum 0
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= ANum 0
- en: FI;;
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: FI;;
- en: IFB BLe (ANum 0)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BLe (ANum 0)
- en: (AMinus (ANum 4) (APlus (ANum 2) (ANum 1)))
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: (AMinus (ANum 4) (APlus (ANum 2) (ANum 1)))
- en: THEN
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: Y ::= ANum 0
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= ANum 0
- en: ELSE
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE
- en: SKIP
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP
- en: FI;;
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: FI;;
- en: WHILE BEq (AId Y) (ANum 0) DO
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当 BEq (AId Y) (ANum 0) 时
- en: X ::= APlus (AId X) (ANum 1)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= APlus (AId X) (ANum 1)
- en: END)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: END)
- en: = (* After constant folding: *)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: = (* 常量折叠后： *)
- en: (X ::= ANum 9;;
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= ANum 9;;
- en: Y ::= AMinus (AId X) (ANum 3);;
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AMinus (AId X) (ANum 3);;
- en: IFB BEq (AMinus (AId X) (AId Y)) (ANum 6) THEN
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BEq (AMinus (AId X) (AId Y)) (ANum 6) THEN
- en: SKIP
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP
- en: ELSE
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: (Y ::= ANum 0)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: (Y ::= ANum 0)
- en: FI;;
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: FI;;
- en: Y ::= ANum 0;;
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= ANum 0;;
- en: WHILE BEq (AId Y) (ANum 0) DO
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当 BEq (AId Y) (ANum 0) 时
- en: X ::= APlus (AId X) (ANum 1)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= APlus (AId X) (ANum 1)
- en: END).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: END).
- en: Proof. reflexivity. Qed.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。证毕。
- en: '[PRE33]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Theorem fold_constants_aexp_sound :'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 fold_constants_aexp_sound：
- en: atrans_sound fold_constants_aexp.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: atrans_sound fold_constants_aexp.
- en: Proof.
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: unfold [atrans_sound](Equiv.html#atrans_sound). intros a. unfold [aequiv](Equiv.html#aequiv).
    intros st.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [atrans_sound](https://wiki.example.org/atrans_sound)。intros a. 展开 [aequiv](https://wiki.example.org/aequiv)。intros
    st.
- en: induction a; simpl;
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 a; 简化;
- en: (* ANum and AId follow immediately *)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: (* ANum 和 AId 立即得出 *)
- en: try reflexivity;
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试反射性;
- en: (* APlus, AMinus, and AMult follow from the IH        and the observation that
                  aeval st (APlus a[1] a[2])             = ANum ((aeval st a[1]) + (aeval st a[2]))
                = aeval st (ANum ((aeval st a[1]) + (aeval st a[2])))        (and similarly for AMinus/minus and AMult/mult) *)
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: (* APlus，AMinus 和 AMult 遵循 IH 和观察到的 aeval st (APlus a[1] a[2]) = ANum ((aeval
    st a[1]) + (aeval st a[2])) = aeval st (ANum ((aeval st a[1]) + (aeval st a[2])))（对于
    AMinus/减法 和 AMult/乘法也是类似的） *)
- en: try (destruct ([fold_constants_aexp](Equiv.html#fold_constants_aexp) a[1]);
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 (destruct ([fold_constants_aexp](https://wiki.example.org/fold_constants_aexp)
    a[1]);
- en: destruct ([fold_constants_aexp](Equiv.html#fold_constants_aexp) a[2]);
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([fold_constants_aexp](https://wiki.example.org/fold_constants_aexp)
    a[2]);
- en: rewrite IHa1; rewrite IHa2; reflexivity). Qed.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 IHa1; 重写 IHa2; 反射性）。���毕。
- en: '[PRE34]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: beval st (BEq a[1] a[2])
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: beval st (BEq a[1] a[2])
- en: = beval st (fold_constants_bexp (BEq a[1] a[2])).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: = beval st (fold_constants_bexp (BEq a[1] a[2])).
- en: 'There are two cases to consider:'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有两种情况需要考虑：
- en: First, suppose fold_constants_aexp a[1] = ANum n[1] and fold_constants_aexp
    a[2] = ANum n[2] for some n[1] and n[2].
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，假设 fold_constants_aexp a[1] = ANum n[1]，fold_constants_aexp a[2] = ANum n[2]，其中
    n[1] 和 n[2] 是一些数。
- en: In this case, we have
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有
- en: '[PRE35]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: beval st (BEq a[1] a[2])
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: beval st (BEq a[1] a[2])
- en: = beq_nat (aeval st a[1]) (aeval st a[2]).
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = beq_nat (aeval st a[1]) (aeval st a[2]).
- en: By the soundness of constant folding for arithmetic expressions (Lemma fold_constants_aexp_sound),
    we know
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过算术表达式的常量折叠的正确性（引理 fold_constants_aexp_sound），我们知道
- en: '[PRE36]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: aeval st a[2]
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: aeval st a[2]
- en: = aeval st (fold_constants_aexp a[2])
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = aeval st (fold_constants_aexp a[2])
- en: = aeval st (ANum n[2])
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = aeval st (ANum n[2])
- en: = n[2],
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = n[2],
- en: so
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以
- en: '[PRE37]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: beval st (if beq_nat n[1] n[2] then BTrue else BFalse)
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: beval st (if beq_nat n[1] n[2] then BTrue else BFalse)
- en: = if beq_nat n[1] n[2] then beval st BTrue else beval st BFalse
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = if beq_nat n[1] n[2] then beval st BTrue else beval st BFalse
- en: = if beq_nat n[1] n[2] then true else false
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = if beq_nat n[1] n[2] then true else false
- en: = beq_nat n[1] n[2].
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = beq_nat n[1] n[2].
- en: So
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以
- en: '[PRE38]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Otherwise, one of fold_constants_aexp a[1] and fold_constants_aexp a[2] is not
    a constant. In this case, we must show
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，fold_constants_aexp a[1] 和 fold_constants_aexp a[2] 中的一个不是常数。在这种情况下，我们必须展示
- en: '[PRE42]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: beq_nat (aeval st a[1]) (aeval st a[2])
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: beq_nat (aeval st a[1]) (aeval st a[2])
- en: = beq_nat (aeval st (fold_constants_aexp a[1]))
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = beq_nat (aeval st (fold_constants_aexp a[1]))
- en: (aeval st (fold_constants_aexp a[2])).
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (aeval st (fold_constants_aexp a[2])).
- en: But the soundness of constant folding for arithmetic expressions (fold_constants_aexp_sound)
    gives us
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是算术表达式的常量折叠的正确性（fold_constants_aexp_sound）告诉我们
- en: '[PRE43]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: (Doing induction when there are a lot of constructors makes
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （当有很多构造函数时进行归纳会变得困难）
- en: specifying variable names a chore, but Coq doesn't always
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定变量名是一项繁琐的工作，但 Coq 并不总是
- en: choose nice variable names.  We can rename entries in the
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择好的变量名。我们可以重命名条目
- en: 'context with the rename tactic: rename a into a[1] will'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用重命名策略的上下文：将 a 重命名为 a[1] 将
- en: change a to a[1] in the current goal and context.)
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将当前目标和上下文中的 a 更改为 a[1]。）
- en: '[PRE46]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ☐
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars (fold_constants_com_sound)'
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星（fold_constants_com_sound）
- en: Complete the WHILE case of the following proof.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成以下证明中的 WHILE 情况。
- en: '[PRE47]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ☐
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE48]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Fixpoint optimize_0plus (e:aexp) : aexp :=
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Fixpoint optimize_0plus (e:aexp) : aexp :=
- en: match e with
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 e 与
- en: '| ANum n ⇒'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '| ANum n ⇒'
- en: ANum n
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ANum n
- en: '| APlus (ANum 0) e[2] ⇒'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '| APlus (ANum 0) e[2] ⇒'
- en: optimize_0plus e[2]
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: optimize_0plus e[2]
- en: '| APlus e[1] e[2] ⇒'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '| APlus e[1] e[2] ⇒'
- en: APlus (optimize_0plus e[1]) (optimize_0plus e[2])
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: APlus (optimize_0plus e[1]) (optimize_0plus e[2])
- en: '| AMinus e[1] e[2] ⇒'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '| AMinus e[1] e[2] ⇒'
- en: AMinus (optimize_0plus e[1]) (optimize_0plus e[2])
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: AMinus (optimize_0plus e[1]) (optimize_0plus e[2])
- en: '| AMult e[1] e[2] ⇒'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '| AMult e[1] e[2] ⇒'
- en: AMult (optimize_0plus e[1]) (optimize_0plus e[2])
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: AMult (optimize_0plus e[1]) (optimize_0plus e[2])
- en: end.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: Note that this function is defined over the old aexps,
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，此函数是针对旧的 aexp 定义的，
- en: without states.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 没有状态。
- en: Write a new version of this function that accounts for variables,
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个考虑变量的新版本的此函数，
- en: 'plus analogous ones for bexps and commands:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 以及布尔表达式和命令的类似情况：
- en: '[PRE49]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: (* FILL IN HERE *)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *)
- en: '[PRE50]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Proving That Programs Are *Not* Equivalent
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证明程序*不*等价的方法
- en: Suppose that c[1] is a command of the form X ::= a[1];; Y ::= a[2]
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设 c[1] 是形如 X ::= a[1];; Y ::= a[2] 的命令
- en: and c[2] is the command X ::= a[1];; Y ::= a[2]', where a[2]' is
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而 c[2] 是命令 X ::= a[1];; Y ::= a[2]', 其中 a[2]' 是
- en: formed by substituting a[1] for all occurrences of X in a[2].
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将 a[1] 替换为 a[2] 中所有出现的 X 而形成。
- en: 'For example, c[1] and c[2] might be:'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，c[1] 和 c[2] 可能是：
- en: '[PRE51]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Fixpoint subst_aexp (i : id) (u : aexp) (a : aexp) : aexp :='
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint subst_aexp (i : id) (u : aexp) (a : aexp) : aexp :='
- en: match a with
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 a 与
- en: '| ANum n       ⇒'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '| ANum n       ⇒'
- en: ANum n
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: ANum n
- en: '| AId i''       ⇒'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '| AId i''       ⇒'
- en: if beq_id i i' then u else AId i'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 beq_id i i' 则 u 否则 AId i'
- en: '| APlus a[1] a[2]  ⇒'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '| APlus a[1] a[2]  ⇒'
- en: APlus (subst_aexp i u a[1]) (subst_aexp i u a[2])
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: APlus (subst_aexp i u a[1]) (subst_aexp i u a[2])
- en: '| AMinus a[1] a[2] ⇒'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '| AMinus a[1] a[2] ⇒'
- en: AMinus (subst_aexp i u a[1]) (subst_aexp i u a[2])
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: AMinus (subst_aexp i u a[1]) (subst_aexp i u a[2])
- en: '| AMult a[1] a[2]  ⇒'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '| AMult a[1] a[2]  ⇒'
- en: AMult (subst_aexp i u a[1]) (subst_aexp i u a[2])
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: AMult (subst_aexp i u a[1]) (subst_aexp i u a[2])
- en: end.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Example subst_aexp_ex :'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 subst_aexp_ex：
- en: subst_aexp X (APlus (ANum 42) (ANum 53))
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: subst_aexp X (APlus (ANum 42) (ANum 53))
- en: (APlus (AId Y) (AId X))
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: (APlus (AId Y) (AId X))
- en: = (APlus (AId Y) (APlus (ANum 42) (ANum 53))).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: = (APlus (AId Y) (APlus (ANum 42) (ANum 53))).
- en: Proof. reflexivity. Qed.
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed.
- en: '[PRE52]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Definition subst_equiv_property := ∀i[1] i[2] a[1] a[2],
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 subst_equiv_property := ∀i[1] i[2] a[1] a[2],
- en: cequiv (i[1] ::= a[1];; i[2] ::= a[2])
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv (i[1] ::= a[1];; i[2] ::= a[2])
- en: (i[1] ::= a[1];; i[2] ::= subst_aexp i[1] a[1] a[2]).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: (i[1] ::= a[1];; i[2] ::= subst_aexp i[1] a[1] a[2]).
- en: '[PRE53]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: cequiv (i[1] ::= a[1];; i[2] ::= a[2])
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv (i[1] ::= a[1];; i[2] ::= a[2])
- en: (i[1] ::= a[1];; i[2] ::= subst_aexp i[1] a[1] a[2]).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: (i[1] ::= a[1];; i[2] ::= subst_aexp i[1] a[1] a[2]).
- en: To see this, suppose (for a contradiction) that for all i[1], i[2],
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了看到这一点，假设（为了推导出矛盾）对于所有 i[1], i[2]，
- en: a[1], and a[2], we have
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a[1] 和 a[2]，我们有
- en: '[PRE54]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: X ::= APlus (AId X) (ANum 1);; Y ::= AId X
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= APlus (AId X) (ANum 1);; Y ::= AId X
- en: Note that
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE55]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: cequiv (X ::= APlus (AId X) (ANum 1);;
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv (X ::= APlus (AId X) (ANum 1);;
- en: Y ::= AId X)
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AId X)
- en: (X ::= APlus (AId X) (ANum 1);;
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= APlus (AId X) (ANum 1);;
- en: Y ::= APlus (AId X) (ANum 1))
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= APlus (AId X) (ANum 1))
- en: so, by the definition of cequiv, we have
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，根据 cequiv 的定义，我们有
- en: '[PRE56]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))
- en: / empty_state ⇓ st[2],
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: / empty_state ⇓ st[2],
- en: where st[2] = { X ↦ 1, Y ↦ 2 }.  But st[1] ≠ st[2], which is a
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 st[2] = { X ↦ 1, Y ↦ 2 }。但 st[1] ≠ st[2]，这是一个
- en: contradiction, since ceval is deterministic!  ☐
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 矛盾，因为 ceval 是确定性的！ ☐
- en: '[PRE57]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Exercise: 4 stars, optional (better_subst_equiv)'
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：4 星，可选（better_subst_equiv）
- en: The equivalence we had in mind above was not complete nonsense —
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们上面所考虑的等价性并非完全胡说八道 —
- en: it was actually almost right.  To make it correct, we just need to
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上几乎是正确的。要使其正确，我们只需要
- en: exclude the case where the variable X occurs in the
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 排除变量 X 出现在
- en: right-hand-side of the first assignment statement.
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个赋值语句的右侧。
- en: '[PRE58]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Using var_not_used_in_aexp, formalize and prove a correct verson
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 var_not_used_in_aexp，形式化并证明一个正确的版本
- en: of subst_equiv_property.
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: subst_equiv_property 的证明。
- en: '[PRE59]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ☐
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars (inequiv_exercise)'
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习���3 星（inequiv_exercise）
- en: Prove that an infinite loop is not equivalent to SKIP
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明无限循环不等价于 SKIP
- en: '[PRE60]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ☐
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE61]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: x = 0;;
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: x = 0;;
- en: f(++x, x)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: f(++x, x)
- en: might call f with arguments (1, 0) or (1, 1), depending how
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能会调用 f 时传入参数 (1, 0) 或 (1, 1)，取决于
- en: the compiler chooses to order things.  This can be a little
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编译器选择排列事物的方式。这可能有点
- en: confusing for programmers, but it gives the compiler writer useful
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对程序员来说可能会有些困惑，但对编译器编写者来说却很有用
- en: freedom.
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自由。
- en: In this exercise, we will extend Imp with a simple
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将用一个简单的 Imp 扩展 Imp
- en: nondeterministic command and study how this change affects
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非确定性命令并研究这种变化如何影响
- en: program equivalence.  The new command has the syntax HAVOC X,
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序等价性。新命令的语法是 HAVOC X，
- en: where X is an identifier. The effect of executing HAVOC X is
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 X 是一个标识符。执行 HAVOC X 的效果是
- en: to assign an *arbitrary* number to the variable X,
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给变量 X 分配一个*任意*数字，
- en: 'nondeterministically. For example, after executing the program:'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非确定性地。例如，在执行程序后：
- en: '[PRE62]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Module Himp.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 Himp。
- en: '[PRE63]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Inductive com : Type :='
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义 com：Type :=
- en: '| CSkip : com'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSkip : com'
- en: '| CAss : id → aexp → com'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '| CAss : id → aexp → com'
- en: '| CSeq : com → com → com'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSeq : com → com → com'
- en: '| CIf : bexp → com → com → com'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '| CIf : bexp → com → com → com'
- en: '| CWhile : bexp → com → com'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '| CWhile : bexp → com → com'
- en: '| CHavoc : id → com. (* <---- new *)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '| CHavoc : id → com。 (* <---- 新的 *)'
- en: Notation "'SKIP'" :=
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "'SKIP'" :=
- en: CSkip.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: CSkip。
- en: Notation "X '::=' a" :=
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "'X ::= a'" :=
- en: (CAss X a) (at level 60).
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: (CAss X a)（优先级为60）。
- en: Notation "c1 ;; c2" :=
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "c1 ;; c2" :=
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: (CSeq c[1] c[2])（优先级为80，右结合性）。
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "'WHILE' b 'DO' c 'END'" :=
- en: (CWhile b c) (at level 80, right associativity).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: (CWhile b c)（优先级为80，右结合性）。
- en: Notation "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
- en: (CIf e[1] e[2] e[3]) (at level 80, right associativity).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: (CIf e[1] e[2] e[3])（优先级为80，右结合性）。
- en: Notation "'HAVOC' l" := (CHavoc l) (at level 60).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "'HAVOC' l" := (CHavoc l)（优先级为60）。
- en: '[PRE64]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Reserved Notation "c1 '/' st '⇓' st'"
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 保留记号 "c1 '/' st '⇓' st'"。
- en: (at level 40, st at level 39).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: （优先级为40，st 优先级为39）。
- en: 'Inductive ceval : com → state → state → Prop :='
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义 ceval：com → state → state → Prop :=
- en: '| E_Skip : ∀st : state, SKIP / st ⇓ st'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Skip : ∀st : state, SKIP / st ⇓ st'
- en: '| E_Ass : ∀(st : state) (a[1] : aexp) (n : nat) (X : id),'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Ass : ∀(st : state) (a[1] : aexp) (n : nat) (X : id)，'
- en: aeval st a[1] = n →
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: aeval st a[1] = n →
- en: (X ::= a[1]) / st ⇓ t_update st X n
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= a[1]) / st ⇓ t_update st X n
- en: '| E_Seq : ∀(c[1] c[2] : com) (st st'' st'''' : state),'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Seq : ∀(c[1] c[2] : com) (st st'' st'''' : state)，'
- en: c[1] / st ⇓ st' →
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' →
- en: c[2] / st' ⇓ st'' →
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / st' ⇓ st'' →
- en: (c[1] ;; c[2]) / st ⇓ st''
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: (c[1] ;; c[2]) / st ⇓ st''。
- en: '| E_IfTrue : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_IfTrue : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
- en: beval st b[1] = true →
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = true →
- en: c[1] / st ⇓ st' →
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' →
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
- en: '| E_IfFalse : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_IfFalse : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com)，'
- en: beval st b[1] = false →
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = false →
- en: c[2] / st ⇓ st' →
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / st ⇓ st' →
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
- en: '| E_WhileEnd : ∀(b[1] : bexp) (st : state) (c[1] : com),'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_WhileEnd : ∀(b[1] : bexp) (st : state) (c[1] : com)，'
- en: beval st b[1] = false →
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = false。
- en: (WHILE b[1] DO c[1] END) / st ⇓ st
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / st ⇓ st
- en: '| E_WhileLoop : ∀(st st'' st'''' : state) (b[1] : bexp) (c[1] : com),'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_WhileLoop : ∀(st st'' st'''' : state) (b[1] : bexp) (c[1] : com),'
- en: beval st b[1] = true →
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = true →
- en: c[1] / st ⇓ st' →
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' →
- en: (WHILE b[1] DO c[1] END) / st' ⇓ st'' →
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / st' ⇓ st'' →
- en: (WHILE b[1] DO c[1] END) / st ⇓ st''
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / st ⇓ st''
- en: (* FILL IN HERE *)
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *)
- en: where "c1 '/' st '⇓' st'" := (ceval c[1] st st').
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 "c1 '/' st '⇓' st'" := (ceval c[1] st st')。
- en: '[PRE65]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Example havoc_example1 : (HAVOC X) / empty_state ⇓ t_update empty_state X 0.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 havoc_example1：（HAVOC X）/ empty_state ⇓ t_update empty_state X 0。
- en: Proof.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *) 已被承认。
- en: 'Example havoc_example2 :'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 havoc_example2：
- en: (SKIP;; HAVOC Z) / empty_state ⇓ t_update empty_state Z 42.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: (SKIP;; HAVOC Z) / empty_state ⇓ t_update empty_state Z 42。
- en: Proof.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *) 已被承认。
- en: '[PRE66]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Definition cequiv (c[1] c[2] : com) : Prop := ∀st st'' : state,'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 cequiv (c[1] c[2] : com) : Prop := ∀st st'' : state，'
- en: c[1] / st ⇓ st' ↔ c[2] / st ⇓ st'.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' ↔ c[2] / st ⇓ st'。
- en: '[PRE67]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Definition pXY :=
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 pXY :=
- en: HAVOC X;; HAVOC Y.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: HAVOC X;; HAVOC Y。
- en: Definition pYX :=
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 pYX :=
- en: HAVOC Y;; HAVOC X.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: HAVOC Y;; HAVOC X。
- en: '[PRE68]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Theorem pXY_cequiv_pYX :'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 pXY_cequiv_pYX：
- en: cequiv pXY pYX ∨ ¬cequiv pXY pYX.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv pXY pYX ∨ ¬cequiv pXY pYX。
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在此填写 *) 已被承认。
- en: '[PRE69]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Definition ptwice :=
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 ptwice :=
- en: HAVOC X;; HAVOC Y.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: HAVOC X;; HAVOC Y。
- en: Definition pcopy :=
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 pcopy :=
- en: HAVOC X;; Y ::= AId X.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: HAVOC X;; Y ::= AId X。
- en: '[PRE70]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Theorem ptwice_cequiv_pcopy :'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 ptwice_cequiv_pcopy：
- en: cequiv ptwice pcopy ∨ ¬cequiv ptwice pcopy.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv ptwice pcopy ∨ ¬cequiv ptwice pcopy。
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在此填写 *) 已被承认。
- en: '[PRE71]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Definition p[1] : com :='
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 p[1]：com :=
- en: WHILE (BNot (BEq (AId X) (ANum 0))) DO
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE (BNot (BEq (AId X) (ANum 0))) DO
- en: HAVOC Y;;
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: HAVOC Y;;
- en: X ::= APlus (AId X) (ANum 1)
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= APlus (AId X) (ANum 1)
- en: END.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: END。
- en: 'Definition p[2] : com :='
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 p[2]：com :=
- en: WHILE (BNot (BEq (AId X) (ANum 0))) DO
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE (BNot (BEq (AId X) (ANum 0))) DO
- en: SKIP
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP
- en: END.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: END。
- en: '[PRE72]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Lemma p1_may_diverge : ∀st st'', st X ≠ 0 →'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 p1_may_diverge：∀st st'，st X ≠ 0 →
- en: ¬ p[1] / st ⇓ st'.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: ¬ p[1] / st ⇓ st'。
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在此填写 *) 已被承认。
- en: 'Lemma p2_may_diverge : ∀st st'', st X ≠ 0 →'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 p2_may_diverge：∀st st'，st X ≠ 0 →
- en: ¬ p[2] / st ⇓ st'.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: ¬ p[2] / st ⇓ st'。
- en: Proof.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *) 已被承认。
- en: '[PRE73]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Theorem p1_p2_equiv : cequiv p[1] p[2].'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 p1_p2_equiv：cequiv p[1] p[2]。
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在此填写 *) 已被承认。
- en: '[PRE74]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Definition p[3] : com :='
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 p[3]：com :=
- en: Z ::= ANum 1;;
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= ANum 1;;
- en: WHILE (BNot (BEq (AId X) (ANum 0))) DO
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE (BNot (BEq (AId X) (ANum 0))) DO
- en: HAVOC X;;
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: HAVOC X;;
- en: HAVOC Z
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: HAVOC Z
- en: END.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: END.
- en: 'Definition p[4] : com :='
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 p[4] : com :='
- en: X ::= (ANum 0);;
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= (ANum 0);;
- en: Z ::= (ANum 1).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= (ANum 1).
- en: 'Theorem p3_p4_inequiv : ¬ cequiv p[3] p[4].'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 p3_p4_inequiv : ¬ cequiv p[3] p[4].'
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在这里填写 *) 已承认。
- en: '[PRE75]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Definition p[5] : com :='
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 p[5] : com :='
- en: WHILE (BNot (BEq (AId X) (ANum 1))) DO
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE (BNot (BEq (AId X) (ANum 1))) DO
- en: HAVOC X
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: HAVOC X
- en: END.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: END.
- en: 'Definition p[6] : com :='
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 p[6] : com :='
- en: X ::= ANum 1.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= ANum 1.
- en: 'Theorem p5_p6_equiv : cequiv p[5] p[6].'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 p5_p6_equiv : cequiv p[5] p[6].'
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在这里填写 *) 已承认。
- en: '[PRE76]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: End Himp.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 Himp.
- en: '[PRE77]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: for (c[1] ; b ; c[2]) {
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 (c[1] ; b ; c[2]) {
- en: c[3]
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: c[3]
- en: '}'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'is equivalent to:'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等同于：
- en: '[PRE78]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: (* FILL IN HERE *)
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *)
- en: '[PRE79]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Theorem swap_noninterfering_assignments: ∀l[1] l[2] a[1] a[2],'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 swap_noninterfering_assignments: ∀l[1] l[2] a[1] a[2],'
- en: l[1] ≠ l[2] →
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: l[1] ≠ l[2] →
- en: var_not_used_in_aexp l[1] a[2] →
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: var_not_used_in_aexp l[1] a[2] →
- en: var_not_used_in_aexp l[2] a[1] →
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: var_not_used_in_aexp l[2] a[1] →
- en: cequiv
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv
- en: (l[1] ::= a[1];; l[2] ::= a[2])
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: (l[1] ::= a[1];; l[2] ::= a[2])
- en: (l[2] ::= a[2];; l[1] ::= a[1]).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: (l[2] ::= a[2];; l[1] ::= a[1]).
- en: Proof.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: '[PRE80]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Definition capprox (c[1] c[2] : com) : Prop := ∀(st st'' : state),'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 capprox (c[1] c[2] : com) : Prop := ∀(st st'' : state),'
- en: c[1] / st ⇓ st' → c[2] / st ⇓ st'.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' → c[2] / st ⇓ st'.
- en: '[PRE81]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Definition c[3] : com (* REPLACE THIS LINE WITH ":= _your_definition_ ." *).
    Admitted.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 c[3] : com (* 用":= _your_definition_ ."替换此行 *). 已承认。'
- en: 'Definition c[4] : com (* REPLACE THIS LINE WITH ":= _your_definition_ ." *).
    Admitted.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 c[4] : com (* 用":= _your_definition_ ."替换此行 *). 已承认。'
- en: 'Theorem c3_c4_different : ¬ capprox c[3] c[4] ∧ ¬ capprox c[4] c[3].'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 c3_c4_different : ¬ capprox c[3] c[4] ∧ ¬ capprox c[4] c[3].'
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在这里填写 *) 已承认。
- en: '[PRE82]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Definition cmin : com'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 cmin : com'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ."替换此行 *). 已承认。
- en: 'Theorem cmin_minimal : ∀c, capprox cmin c.'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 cmin_minimal : ∀c, capprox cmin c.'
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在这里填写 *) 已承认。
- en: '[PRE83]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Definition zprop (c : com) : Prop'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 zprop (c : com) : Prop'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ."替换此行 *). 已承认。
- en: 'Theorem zprop_preserving : ∀c c'','
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 zprop_preserving : ∀c c'','
- en: zprop c → capprox c c' → zprop c'.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: zprop c → capprox c c' → zprop c'.
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 (* 在这里填写 *) 已承认。
- en: '[PRE84]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
