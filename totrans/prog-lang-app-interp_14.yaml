- en: 14Control Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14控制操作
- en: The term control refers to any programming language instruction that causes
    evaluation to proceed, because it “controls” the program counter of the machine.
    In that sense, even a simple arithmetic expression should qualify as “control”,
    and operations such as sequential program execution, or function calls and returns,
    most certainly do. However, in practice we use the term to refer primarily to
    those operations that cause non-local transfer of control, especially beyond that
    of mere functions and procedures, and the next step up, namely exceptions. We
    will study such operations in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 控制一词指的是任何导致评估继续进行的编程语言指令，因为它“控制”了机器的程序计数器。在这个意义上，即使是一个简单的算术表达式也应该被视为“控制”，而像顺序程序执行、函数调用和返回等操作则肯定是。然而，在实践中，我们使用这个术语主要是指那些导致非局部控制转移的操作，尤其是超出了仅仅函数和过程的范围，以及更高级别的异常。我们将在本章中研究这些操作。
- en: As we study the following control operators, it’s worth remembering that even
    without them, we still have languages that are Turing-complete, and therefore
    have no more “power”. Therefore, what control operators do is change and potentially
    improve the way we express our intent, and therefore enhance the structure of
    programs. Thus, it pays to being our study by focusing on program structure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习以下控制操作符时，值得记住，即使没有它们，我们仍然拥有图灵完备的语言，因此没有更多的“权力”。因此，控制操作符的作用是改变并潜在地改善我们表达意图的方式，从而增强程序的结构。因此，我们开始学习时应该专注于程序结构。
- en: 14.1Control on the Web
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1网络控制
- en: 'Let us begin our study by examining the structure of Web programs. Consider
    the following program:Henceforth, we’ll call this our “addition server”. You should,
    of course, understand this as a stand-in for more sophisticated applications.
    For instance, the two prompts might ask for starting and ending points for a trip,
    and in place of addition we might compute a route or compute airfares. There might
    even be computation between the two steps: e.g., after entering the first city,
    the airline might prompt us with choices of where it flies from there.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查Web程序的结构来开始我们的学习。考虑以下程序：从现在开始，我们将称之为我们的“加法服务器”。当然，你应该把这看作更复杂应用程序的替身。例如，这两个提示可能要求输入旅行的起点和终点，而在加法的位置上，我们可能计算路线或计算机票价格。甚至可能在两个步骤之间进行计算：例如，在输入第一个城市后，航空公司可能会提示我们选择从那里飞往哪里。
- en: '| (display |'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (display |'
- en: '|   (+ (read-number "First number") |'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (+ (read-number "第一个数字") |'
- en: '|      (read-number "Second number"))) |'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (read-number "第二个数字"))) |'
- en: 'To test these ideas, here’s an implementation of read-number:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些想法，这里是一个read-number的实现：
- en: '| (define (read-number [prompt : string]) : number |'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (read-number [prompt : string]) : number |'
- en: '|   (begin |'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (begin |'
- en: '|     (display prompt) |'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (display prompt) |'
- en: '|     (let ([v (read)]) |'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (let ([v (read)]) |'
- en: '|       (if (s-exp-number? v) |'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (if (s-exp-number? v) |'
- en: '|           (s-exp->number v) |'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (s-exp->number v) |'
- en: '|           (read-number prompt))))) |'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (read-number prompt))))) |'
- en: When run at the console or in DrRacket, this program prompts us for one number,
    then another, and then displays their sum.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当在控制台或DrRacket中运行时，此程序会提示我们输入一个数字，然后另一个数字，然后显示它们的和。
- en: 'Now suppose we want to run this on a Web server. We immediately encounter a
    difficulty: the structure of server-side Web programs is such that they generate
    a single Web page—<wbr>such as the one asking for the first number—<wbr>and then
    halt. As a result, the rest of the program—<wbr>which in this case prompts for
    the second number, then adds them, and then prints that result, is lost.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想在Web服务器上运行这个程序。我们立即遇到一个困难：服务器端Web程序的结构是这样的，它们生成一个单一的网页—<wbr>比如要求输入第一个数字的网页—<wbr>然后停止。因此，程序的其余部分—<wbr>在这种情况下提示输入第二个数字，然后相加，然后打印结果—<wbr>会丢失。
- en: Do Now!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: Why do Web servers behave in such a strange way?
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么Web服务器表现得如此奇怪？
- en: 'There are at least two reasons for this behavior: one perhaps historical, and
    the other technical. The historical reason is that Web servers were initially
    designed to serve pages, i.e., static content. Any program that ran had to generate
    its output to a file, from which a server could offer it. Naturally, developers
    wondered why that same program couldn’t run on demand. This made Web content dynamic.
    Terminating the program after generating a single piece of output was the simplest
    incremental step towards programs, not pages, on the Web.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The more important reason—<wbr>and the one that has stayed with us—<wbr>is
    technical. Imagine our addition server has generated its first prompt. Recall
    that there is considerable pending computation: the second prompt, the addition,
    and the display of the result. This computation must suspend waiting for the user’s
    input. If there are millions of users, then millions of computations must be suspended,
    creating an enormous performance problem. Furthermore, suppose a user does not
    actually complete the computation—<wbr>analogous to searching at an on-line bookstore
    or airline site, but not completing the purchase. How does the server know when
    or even whether to terminate the computation? And until it does, the resources
    associated with that computation remain in use.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, therefore, the Web protocol was designed to be stateless: it
    would not store state on the server associated with intermediate computations.
    Instead, Web program developers would be forced to maintain all necessary state
    elsewhere, and each request would need to be able to resume the computation in
    full. In practice, the Web has not proven to be stateless at all, but it still
    hews largely in this direction, and studying the structure of such programs is
    very instructive.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider client-side Web programs: those that run inside the browser, written
    in or compiled to JavaScript. Suppose such a computation needs to communicate
    with a server. The primitive for this is called XMLHttpRequest. The user makes
    an instance of this primitive and invokes its send method to send a message to
    the server. Communicating with a server is not, however, instantaneous (and indeed
    may never complete, depending on the state of the network). This leaves the sending
    process suspended.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The designers of JavaScript decided to make the language single-threaded: i.e.,
    there would be only one thread of execution at a time.Due to the structuring problems
    this causes, there are now various proposals to, in effect, add “safe” threads
    to JavaScript. The ideas described in this chapter can be viewed as an alternative
    that offer similar structuring benefits. This avoids the various perils that arise
    from combining mutation with threads. As a result, however, the JavaScript process
    locks up awaiting the response, and nothing else can happen: e.g., other handlers
    on the page no longer respond.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, the design of XMLHttpRequest demands that the developer
    provide a procedure that responds to the request if and when it arrives. This
    callback procedure is registered with the system. It needs to embody the rest
    of the processing of that request. Thus, for entirely different reasons—<wbr>not
    performance, but avoiding the problems of synchronization, non-atomicity, and
    deadlocks—<wbr>the client-side Web has evolved to demand the same pattern of developers.
    Let us now better understand that pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.1Program Decomposition into Now and Later
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us consider what it takes to make our above program work in a stateless
    setting, such as on a Web server. First we have to determine the first interaction.
    This is the prompt for the first number, because Racket evaluates arguments from
    left to right. It is instructive to divide the program into two parts: what happens
    to generate the first interaction (which can all run now), and what needs to happen
    after it (which must be “remembered” somehow). The former is easy:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '| (read-number "First number") |'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: We’ve already explained in prose what’s left, but now it’s time to write it
    as a program. It seems to be something likeWe’re intentionally ignoring read-number
    for now, but we’ll return to it. For now, let’s pretend it’s built-in.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '| (display |'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (+ <the result from the first interaction> |'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (read-number "Second number"))) |'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'A Web server can’t execute the above, however, because it evidently isn’t a
    program. We instead need some way of writing this as one.Let’s observe a few characteristics
    of this computation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: It needs to be a legitimate program.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to stay suspended until the request comes in.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs a way—<wbr>such as a parameter—<wbr>to refer to the value from the
    first interaction.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Put together these characteristics and we have a clear representation—<wbr>a
    function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (v1) |'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (display |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (+ v1 |'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        (read-number "Second number")))) |'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 14.1.2A Partial Solution
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the Web, there is an additional wrinkle: each Web page with input elements
    needs to refer to a program stored on the Web, which will receive the data from
    the form and process it. This program is named in the action field of a form.
    Thus, imagine that the server generates a fresh label, stores the above function
    in a table associated with that label, and refers to the table in the action field.
    If and when the client actually submits the form, the server extracts the associated
    function, supplies it with the form’s values, and thus resumes execution.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Is the solution above stateless?
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s imagine that we have a custom Web server that maintains the above table.
    In such a server, we might have a special version of read-number—<wbr>call it
    read-number/suspend—<wbr>that records the rest of the program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '| (read-number/suspend "First number" |'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (lambda (v1) |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (display |'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (+ v1 |'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                            (read-number "Second number"))))) |'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'To test this, let’s implement such a procedure. First, we need a representation
    for labels; numbers are an easy substitute:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-type-alias label number) |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Let’s say new-label generates a fresh label on each invocation.Exercise
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Define new-label. You might use new-loc for inspiration.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We need a table to store the procedures representing the rest of the program.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '| (define table (make-hash empty)) |'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Now we can store these procedures:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (read-number/suspend [prompt : string] rest) |'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (let ([g (new-label)]) |'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (begin |'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (hash-set! table g rest) |'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (display prompt) |'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (display " To enter it, use the action field label ") |'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (display g)))) |'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: If we now run the above invocation of read-number/suspend, the system prints
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '| First number To enter it, use the action field label 1 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: This is tantamount to printing the prompt in a Web page, and putting the label
    1 in the action field. Because we’re simulating it, we need something to represent
    the browser’s submission process. This needs both the label (from the action field)
    and the value entered in the form. Given these two values, this procedure needs
    to extract the relevant procedure from the table, and apply it to the form value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (resume [g : label] [n : number]) |'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   ((some-v (hash-ref table g)) n)) |'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'With this, we can now simulate the act of entering 3 and clicking on a “Submit”
    button by running:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '| > (resume 1 3) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: 'where 1 is the label and 3 is the user’s input. Unfortunately, this simply
    produces another prompt, because we haven’t fully converted the program. If we
    delete read-number, we’re forced to convert the entire program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '| (read-number/suspend "First number" |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (lambda (v1) |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (read-number/suspend "Second number" |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                             (lambda (v2) |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                               (display |'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                                (+ v1 v2)))))) |'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Just to be safe, we can also make sure the computation terminates after each
    output by adding an error invocation at the end of read-number/suspend (to truly
    ensure the most extreme form of “suspension”).When we execute this program, we
    have to use resume twice:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '| First number To enter it, use the action field label 1 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| halting: Program shut down |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| > (resume 1 3) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| Second number To enter it, use the action field label 2 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| halting: Program shut down |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| > (resume 2 10) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| 13 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: where the two user inputs are 3 and 10, giving a total of 13, and the
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '| halting |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: messages are generated by the error command we inserted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve purposely played a little coy with the types of the interesting parts
    of our program. Let’s examine what these types should be. The second argument
    to read-number/suspend needs to be a procedure that consumes numbers and returns
    whatever the computation eventually produces: (number -> ’a). Similarly, the return
    type of resume is the same ’a. How do these ’as communicate with one another?
    This is done by table, which maps labels to (number -> ’a). That is, at every
    step the computation makes progress towards the same outcome. read-number/suspend
    writes into this table, and resume reads from it.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.3Achieving Statelessness
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We haven’t actually achieved statelessness yet, because we have this large table
    residing on the server, with no clear means to remove entries from it. It would
    be better if we could avoid the server state entirely. This means we have to move
    the relevant state to the client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually two ways in which the server holds state. One is that we
    have reserved the right to create as many entries in the hash table as we wish,
    rather than a constant number (i.e., linear in the size of the program itself).
    The other is what we’re storing in the table: honest-to-goodness closures, which
    might be holding on to an arbitrary amount of state. We’ll see this more clearly
    soon.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by eliminating the closure. Instead, let’s have each of the funtion
    arguments to be named, top-level functions (which immediately forces us to have
    only a fixed number of them, because the program’s size cannot be unbounded):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '| (read-number/stateless "First number" prog1) |'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   |'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define (prog1 v1) |'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (read-number/stateless "Second number" prog2)) |'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define (prog2 v2) |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (display (+ v1 v2))) |'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Observe how each code block refers only to the name of the next, rather than
    to a real closure. The value of the argument comes from the form. There’s just
    one problem: v1 in prog2 is a free identifier!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to fix this problem is, instead of creating a closure after one step,
    to send v1 to the client to be stored there. Where do we store this? The browser
    offers two mechanisms for doing this: cookies and hidden fields. Which one do
    we use?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.4Interaction with State
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fundamental difference between cookies and hidden fields is that all pages
    share the same cookie, but each page has its own hidden fields.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s consider a sequence of interactions with the existing program
    that uses read-number/suspend (at both interaction points). It looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '| First number To enter it, use the action field label 1 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| > (resume 1 3) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| Second number To enter it, use the action field label 2 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| > (resume 2 10) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| 13 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: Thus, resuming with label 2 appears to represent adding 3 to the given argument
    (i.e., form field value). To be sure,
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '| > (resume 2 15) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| 18 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: 'So far, so good. Now suppose we use label 1 again:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '| > (resume 1 5) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| Second number To enter it, use the action field label 3 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: Observe that this new program execution needs to be resumed by using label 3,
    not 1. Indeed,
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '| > (resume 3 10) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| 15 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: But we ought to ask, what happens if we reuse label 2?Do Now!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Try (resume 2 10).
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Doing this is tantamount to resuming the old computation. We therefore expect
    it produce the same answer as before:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '| > (resume 2 10) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| 13 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: Now let’s create a stateful implementation. We can simulate this by observing
    that each closure has its own environment, but all closures share the same mutable
    state. We can simulate this using our existing read-number/suspend by making sure
    we don’t rely on the closure behavior of lambda, i.e., by not having any free
    identifiers in the body.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '| (define cookie ''-100) |'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   |'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (read-number/suspend "First number" |'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (lambda (v1) |'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (begin |'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                          (set! cookie v1) |'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                          (read-number/suspend "Second number" |'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                             (lambda (v2) |'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                               (display |'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                                (+ cookie v2))))))) |'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Exercise
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: What do we expect for the same sequence as before?
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: What happens?
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Initially, nothing seems different:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '| First number To enter it, use the action field label 1 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| > (resume 1 3) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| Second number To enter it, use the action field label 2 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| > (resume 2 10) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| 13 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: 'When we reuse the initial computation, we indeed get a new resumption label:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '| > (resume 1 5) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| Second number To enter it, use the action field label 3 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: 'which, when used, computes what we’d expect:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '| > (resume 3 10) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| 15 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: 'Now we come to the critical step:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '| > (resume 2 10) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| 15 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: It is unsurprising that the two resumptions of label 2 would produce different
    answers, given that they rely on mutable state. The reason it’s problematic is
    because of what happens when we translate the same behavior to the Web.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Imagine visiting a hotel reservation Web site and searching for hotels in a
    city. In return, you are shown a list of hotels and the label 1. You explore one
    of them in a new tab or window; this produces information on that hotel, and label
    2 to make the reservation. You decide, however, to return to the hotel listing
    and explore another hotel in a fresh tab or window. This produces the second hotel’s
    information, with label 3 to reserve at that hotel. You decide, however, to choose
    the first hotel, return to the first hotel’s page, and choose its reservation
    button—<wbr>i.e., submit label 2. Which hotel did you expect to be booked into?
    Though you expected a reservation at the first hotel, on most travel sites, this
    will either reserve at the second hotel—<wbr>i.e., the one you last viewed, but
    not the one on the page whose reservation button you clicked—<wbr>or produce an
    error. This is because of the pervasive use of cookies on Web sites, a practice
    encouraged by most Web APIs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 14.2Continuation-Passing Style
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functions we’ve been writing have a name. Though we’ve presented ideas
    in terms of the Web, we’re relying on a much older idea: the functions are called
    continuations, and this style of programs is called continuation-passing style
    (CPS).We will take the liberty of using CPS as both a noun and verb: a particular
    structure of code and the process that converts code into it. This is worth studying
    in its own right, because it is the basis for studying a variety of other non-trivial
    control operations—<wbr>such as generators.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we converted programs so that no Web input operation was nested inside
    another. The motivation was simple: when the program terminates, all nested computations
    are lost. A similar argument applies, in a more local sense, in the case of XMLHttpRequest:
    any computation depending on the result of a response from a Web server needs
    to reside in the callback associated with the request to the server.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we don’t need to transform every expression. We only care about expressions
    that involve actual Web interaction. For example, if we computed a more complex
    mathematical expression than just addition, we wouldn’t need to transform it.
    If, however, we had a function call, we’d either have to be absolutely certain
    the function didn’t have any Web invocations either inside it, or in the functions
    in invokes, or the ones they invoke...or else, to be defensive, we should transform
    them all. Therefore, we have to transform every expression that we can’t be sure
    performs no Web interactions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The heart of our transformation is therefore to turn every one-argument function,
    f, into one with an extra argument. This extra argument is the continuation, which
    represents the rest of the computation. The continuation is itself a function
    of one argument. This argument takes the value that would have been returned by
    f and passes it to the rest of the computation. f, instead of returning a value,
    instead passes the value it would have returned to its continuation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'CPS is a general transformation, which we can apply to any program. Because
    it’s a program transformation, we can think of it as a special kind of desugaring:
    in particular, instead of transforming programs from a larger language to a smaller
    one (as macros do), or from one language to entirely another (as compilers do),
    it transforms programs within the same language: from the full language to a more
    restricted version that obeys the pattern we’ve been discussing. As a result,
    we can reuse an evaluator for the full language to also evaluate programs in the
    CPS subset.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.1Implementation by Desugaring
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we already have good support for desguaring, let’s use to define the
    CPS transform. Concretely, we’ll implement a CPS macro [REF]. To more cleanly
    separate the source language from the target, we’ll use slightly different names
    for most of the language constructs: a one-armed with and rec instead of let and
    letrec; lam instead of lambda; cnd instead of if; seq for begin; and set for set!.
    We’ll also give ourselves a sufficiently rich language to write some interesting
    programs!The presentation that follows orders the cases of the macro from what
    I believe are easiest to hardest. However, the code in the macro must avoid non-overlapping
    patterns, and hence follows a diffent order.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经很好地支持了解糖，让我们使用它来定义 CPS 转换。具体来说，我们将实现一个 CPS 宏[REF]。为了更清晰地将源语言与目标语言分开，我们将为大多数语言构造使用略有不同的名称：一个臂状的
    with 和 rec 代替 let 和 letrec；lam 代替 lambda；cnd 代替 if；seq 代替 begin；set 代替 set!。我们还将给自己一个足够丰富的语言来编写一些有趣的程序！接下来的演示按照我认为从简单到困难的宏案例排序。然而，宏中的代码必须避免不重叠的模式，因此遵循不同的顺序。
- en: '[<cps-macro>](#(elem._(chunk._~3ccps-macro~3e~3a1))) ::='
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro>](#(elem._(chunk._~3ccps-macro~3e~3a1))) ::='
- en: '| (define-syntax (cps e) |'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (cps e) |'
- en: '|   (syntax-case e (with rec lam cnd seq set quote display read-number) |'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case e (with rec lam cnd seq set quote display read-number) |'
- en: '|     [<cps-macro-with-case>](#(elem._(chunk._~3ccps-macro-with-case~3e~3a1)))
    |'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-with-case>](#(elem._(chunk._~3ccps-macro-with-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-rec-case>](#(elem._(chunk._~3ccps-macro-rec-case~3e~3a1)))
    |'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-rec-case>](#(elem._(chunk._~3ccps-macro-rec-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-lam-case>](#(elem._(chunk._~3ccps-macro-lam-case~3e~3a1)))
    |'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-lam-case>](#(elem._(chunk._~3ccps-macro-lam-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-cnd-case>](#(elem._(chunk._~3ccps-macro-cnd-case~3e~3a1)))
    |'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-cnd-case>](#(elem._(chunk._~3ccps-macro-cnd-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-display-case>](#(elem._(chunk._~3ccps-macro-display-case~3e~3a1)))
    |'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-display-case>](#(elem._(chunk._~3ccps-macro-display-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-read-number-case>](#(elem._(chunk._~3ccps-macro-read-number-case~3e~3a1)))
    |'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-read-number-case>](#(elem._(chunk._~3ccps-macro-read-number-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-seq-case>](#(elem._(chunk._~3ccps-macro-seq-case~3e~3a1)))
    |'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-seq-case>](#(elem._(chunk._~3ccps-macro-seq-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-set-case>](#(elem._(chunk._~3ccps-macro-set-case~3e~3a1)))
    |'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-set-case>](#(elem._(chunk._~3ccps-macro-set-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-quote-case>](#(elem._(chunk._~3ccps-macro-quote-case~3e~3a1)))
    |'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-quote-case>](#(elem._(chunk._~3ccps-macro-quote-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-app-1-case>](#(elem._(chunk._~3ccps-macro-app-1-case~3e~3a1)))
    |'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-app-1-case>](#(elem._(chunk._~3ccps-macro-app-1-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-app-2-case>](#(elem._(chunk._~3ccps-macro-app-2-case~3e~3a1)))
    |'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-app-2-case>](#(elem._(chunk._~3ccps-macro-app-2-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-atomic-case>](#(elem._(chunk._~3ccps-macro-atomic-case~3e~3a1)))))
    |'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-atomic-case>](#(elem._(chunk._~3ccps-macro-atomic-case~3e~3a1)))))
    |'
- en: Our representation in CPS will be to turn every expression into a procedure
    of one argument, the continuation. The converted expression will eventually either
    supply a value to the continuation or will pass the continuation on to some other
    expression that will—<wbr>by preserving this invariant inductively—<wbr>supply
    it with a value. Thus, all output from CPS will look like (lambda (k) ...) (and
    we will rely on hygiene [REF] to keep all these introduced k’s from clashing with
    one another).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 CPS 中的表示将是将每个表达式转换为一个带有一个参数（续集）的过程。转换后的表达式最终将向续集提供一个值，或者将续集传递给将会——通过保持这个不变性的归纳——向其提供一个值的其他表达式。因此，CPS
    的所有输出看起来都像 (lambda (k) ...)（我们将依赖卫生性[REF]来防止所有这些引入的 k 互相冲突）。
- en: 'First let’s dispatch with the easy case, which is atomic values. Though conceptually
    easiest, we have written this last because otherwise this pattern would shadow
    all the other cases. (Ideally, we should have written it first and provided a
    guard expression that precisely defines the syntactic cases we want to treat as
    atomic. We’re playing loose here becuase our focus is on more interesting cases.)
    In the atomic case, we already have a value, so we simply need to supply it to
    the continuation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理最简单的情况，即原子值。尽管在概念上最简单，但我们将其放在最后编写，否则此模式将掩盖所有其他情况。（理想情况下，我们应该首先编写它，并提供一个精确定义我们要将其视为原子的语法情况的保护表达式。我们在这里玩得很随意，因为我们的重点是更有趣的情况。）在原子情况下，我们已经有一个值，所以我们只需将其提供给续集：
- en: '[<cps-macro-atomic-case>](#(elem._(chunk._~3ccps-macro-atomic-case~3e~3a1)))
    ::='
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-atomic-case>](#(elem._(chunk._~3ccps-macro-atomic-case~3e~3a1)))
    ::='
- en: '| [(_ atomic) |'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ atomic) |'
- en: '|  #''(lambda (k) |'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      (k atomic))] |'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (k atomic))] |'
- en: 'Similarly for quoted constants:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-quote-case>](#(elem._(chunk._~3ccps-macro-quote-case~3e~3a1)))
    ::='
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ ''e) |'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) (k ''e))] |'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Also, we already know, from [REF] and [REF], that we can treat with and rec
    as macros, respectively:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-with-case>](#(elem._(chunk._~3ccps-macro-with-case~3e~3a1))) ::='
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (with (v e) b)) |'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(cps ((lam (v) b) e))] |'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '[<cps-macro-rec-case>](#(elem._(chunk._~3ccps-macro-rec-case~3e~3a1))) ::='
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (rec (v f) b)) |'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(cps (with (v (lam (arg) (error ''dummy "nothing"))) |'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               (seq |'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                (set v f) |'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                b)))] |'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Mutation is easy: we have to evaluate the new value, and then perform the actual
    update:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-set-case>](#(elem._(chunk._~3ccps-macro-set-case~3e~3a1))) ::='
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (set v e)) |'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps e) (lambda (ev) |'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 (k (set! v ev)))))] |'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Sequencing is also straightforward: we perform each operation in turn. Observe
    how this preserves the semantics of sequencing: not only does it obey the order
    of operations, the value of the first sub-term (e1) is not mentioned anywhere
    in the body of the second (e2), so the name given to the identifier holding its
    value is irrelevant.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-seq-case>](#(elem._(chunk._~3ccps-macro-seq-case~3e~3a1))) ::='
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (seq e1 e2)) |'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps e1) (lambda (_) |'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                  ((cps e2) k))))] |'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'When handling conditionals, we need to create a new continuation to remember
    that we are waiting for the test expression to evaluate. Once we have its value,
    however, we can dispatch on the result and return to the existing continuations:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-cnd-case>](#(elem._(chunk._~3ccps-macro-cnd-case~3e~3a1))) ::='
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (cnd tst thn els)) |'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps tst) (lambda (tstv) |'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                   (if tstv |'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       ((cps thn) k) |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       ((cps els) k)))))] |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'When we get to applications, we have two cases to consider. We absolutely need
    to handle the treatment of procedures created in the language: those with one
    argument. For the purposes of writing example programs, however, it is useful
    to be able to employ primitives such as + and *. Thus, we will assume for simplicity
    that one-argument procedures are written by the user, and hence need conversion
    to CPS, while two-argument ones are primitives that will not perform any Web or
    other control operations and hence can be invoked directly; we will also assume
    that the primitive will be written in-line (i.e., the application position will
    not be a complex expression that can itself, say, perform a Web interaction).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: For an application we have to evaluate both the function and argument expressions.
    Once we’ve obtained these, we are ready to apply the function. Therefore, it is
    tempting to write
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-app-1-case-take-1>](#(elem._(chunk._~3ccps-macro-app-1-case-take-1~3e~3a1)))
    ::='
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (f a)) |'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps f) (lambda (fv) |'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 ((cps a) (lambda (av) |'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                            (k (fv av)))))))] |'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Do Now!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Do you see why this is wrong?
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The problem is that, though the function is now a value, that value is a closure
    with a potentially complicated body: evaluating the body can, for example, result
    in further Web interactions, at which point the rest of the function’s body, as
    well as the pending (k ...) (i.e., the rest of the program), will all be lost.
    To avoid this, we have to supply k to the function’s value, and let the inductive
    invariant ensure that k will eventually be invoked with the value of applying
    fv to av:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-app-1-case>](#(elem._(chunk._~3ccps-macro-app-1-case~3e~3a1)))
    ::='
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (f a)) |'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps f) (lambda (fv) |'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 ((cps a) (lambda (av) |'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                            (fv av k))))))] |'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Treating the special case of built-in binary operations is easier:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-app-2-case>](#(elem._(chunk._~3ccps-macro-app-2-case~3e~3a1)))
    ::='
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (f a b)) |'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps a) (lambda (av) |'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 ((cps b) (lambda (bv) |'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                            (k (f av bv)))))))] |'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: The very pattern we could not use for user-defined procedures we employ here,
    because we assume that the application of f will always return without any unusual
    transfers of control.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'A function is itself a value, so it should be returned to the pending computation.
    The application case above, however, shows that we have to transform functions
    to take an extra argument, namely the continuation at the point of invocation.
    This leaves us with a quandary: which continuation do we supply to the body?'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-lam-case-take-1>](#(elem._(chunk._~3ccps-macro-lam-case-take-1~3e~3a1)))
    ::='
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (lam (a) b)) |'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  (identifier? #''a) |'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (k (lambda (a dyn-k) |'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|           ((cps b) ...))))] |'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'That is, in place of ..., which continuation do we supply: k or dyn-k?'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Which continuation should we supply?
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The former is the continuation at the point of closure creation. The latter
    is the continuation at the point of closure invocation. In other words, the former
    is “static” and the latter is “dynamic”. In this case, we need to use the dynamic
    continuation, otherwise something very strange would happen: the program would
    return to the point where the closure was created, rather than where it is being
    used! This would result in seemingly very strange program behavior, so we wish
    to avoid it. Observe that we are consciously choosing the dynamic continuation
    just as, where scope was concerned, we chose the static environment.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-lam-case>](#(elem._(chunk._~3ccps-macro-lam-case~3e~3a1))) ::='
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (lam (a) b)) |'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  (identifier? #''a) |'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (k (lambda (a dyn-k) |'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|           ((cps b) dyn-k))))] |'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Finally, for the purpose of modeling Web programming, we can add our input
    and output procedures. Output follows the application pattern we’ve already seen:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-display-case>](#(elem._(chunk._~3ccps-macro-display-case~3e~3a1)))
    ::='
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (display output)) |'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps output) (lambda (ov) |'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (k (display ov)))))] |'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Finally, for input, we can use the pre-existing read-number/suspend, but this
    time generate its uses rather than force the programmer to construct them:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-read-number-case>](#(elem._(chunk._~3ccps-macro-read-number-case~3e~3a1)))
    ::='
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (read-number prompt)) |'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps prompt) (lambda (pv) |'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (read-number/suspend pv k))))] |'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Notice that the continuation bound to k is precisely the continuation that we
    need to stash at the point of a Web interaction.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing any code converted to CPS is slightly annoying because all CPS terms
    expect a continuation. The initial continuation is one that simply either (a)
    consumes a value and returns it, or (b) consumes a value and prints it, or (c)
    consumes a value, prints it, and gets ready for another computation (as the prompt
    in the DrRacket Interactions window does). All three of these are effectively
    just the identity function in various guises. Thus, the following definition is
    helpful for testing:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (run c) (c identity)) |'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: For instance,
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '| (test (run (cps 3))                           3) |'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (test (run (cps ((lam ()    5)       )))      5) |'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (test (run (cps ((lam (x)   (* x x)) 5)))     25) |'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (test (run (cps (+ 5 ((lam (x) (* x x)) 5)))) 30) |'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'We can also test our old Web program:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '| (run (cps (display (+ (read-number "First") |'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       (read-number "Second"))))) |'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Lest you get lost in the myriad of code, let me highlight the important lesson
    here: We’ve recovered our code structure. That is, we can write the program in
    direct style, with properly nested expressions, and a compiler—<wbr>in this case,
    the CPS converter—<wbr>takes care of making it work with a suitable underlying
    API. This is what good programming languages ought to do!'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.2Converting the Example
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider the example above and see what it converts to. You can either
    do this by hand, or take the easy way out and employ the Macro Stepper of DrRacket.For
    now, you need to put the code in #lang racket to get the full force of the Macro
    Stepper. Assuming we include the application to identity contained in run, we
    get:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (k) |'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   ((lambda (k) |'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((lambda (k) |'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|         ((lambda (k) |'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (k "First")) (lambda (pv) |'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                           (read-number/suspend pv k)))) |'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (lambda (lv) |'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|         ((lambda (k) |'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            ((lambda (k) |'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               (k "Second")) (lambda (pv) |'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                               (read-number/suspend pv k)))) |'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          (lambda (rv) |'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (k (+ lv rv))))))) |'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|    (lambda (ov) |'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (k (display ov))))) |'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: What! This isn’t at all the version we wrote by hand!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this program is full of so-called administrative lambdas that were
    introduced by the particular CPS algorithm we used.Designing better CPS algorithms,
    that eliminate needless administrative lambdas, is therefore an ongoing and open
    research question. Fear not! If we stepwise apply each of these lambdas and substitute,
    however—<wbr>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Do it!
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —<wbr>the program reduces to
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '| (read-number/suspend "First" |'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (lambda (lv) |'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (read-number/suspend "Second" |'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                             (lambda (rv) |'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                               (identity |'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                                (display (+ lv rv))))))) |'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: which is precisely what we wanted.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.3Implementation in the Core
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve seen how CPS can be implemented through desguaring, we should
    ask whether it can be put in the core instead.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we’ve said that CPS applies to all programs. We have one program
    we are especially interested in: the interpreter. Sure enough, we can apply the
    CPS transformation to it, making available what are effectively the same continuations.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll find it convenient to use a procedural representation of closures
    [REF]. We’ll have the interpreter take an extra argument, which consumes values
    (those given to the continuation) and eventually returns them:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-interp>](#(elem._(chunk._~3ccps-interp~3e~3a1))) ::='
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (interp/k [expr : ExprC] [env : Env] [k : (Value -> Value)]) : Value
    |'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [<cps-interp-body>](#(elem._(chunk._~3ccps-interp-body~3e~3a1)))) |'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'In the easy cases, instead of returning a value we need to simply pass it to
    the continuation argument:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-interp-body>](#(elem._(chunk._~3ccps-interp-body~3e~3a1))) ::='
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '| (type-case ExprC expr |'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [numC (n) (k (numV n))] |'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [idC (n) (k (lookup n env))] |'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [<cps-interp-plusC-case>](#(elem._(chunk._~3ccps-interp-plus.C-case~3e~3a1)))
    |'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [<cps-interp-appC-case>](#(elem._(chunk._~3ccps-interp-app.C-case~3e~3a1)))
    |'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [<cps-interp-lamC-case>](#(elem._(chunk._~3ccps-interp-lam.C-case~3e~3a1))))
    |'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: (Note that multC is handled entirely analogous to plusC.)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the easy case, plusC. First we interpret the left sub-expression.
    The continuation for this evaluation interprets the right sub-expression. The
    continuation for that adds the result. What should happen to the result of addition?
    In interp, it was returned to whichever computation caused the plusC to be interpreted.
    Now, remember, we no longer return values; instead we pass them to the continuation:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-interp-plusC-case>](#(elem._(chunk._~3ccps-interp-plus.C-case~3e~3a1)))
    ::='
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '| [plusC (l r) (interp/k l env |'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (lambda (lv) |'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                          (interp/k r env |'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                    (lambda (rv) |'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                      (k (num+ lv rv))))))] |'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Exercise
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Implement the code for multC.
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This leaves the two difficult, and related, pieces.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'In an application, we again have to interpret the two sub-expressions, and
    then apply the resulting closure to the argument. But we’ve already agreed that
    every application needs a continuation argument. Therefore, we have to update
    our definition of a value:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-type Value |'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [numV (n : number)] |'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [closV (f : (Value (Value -> Value) -> Value))]) |'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Now we have to decide what continuation to pass. In an application, it’s the
    continuation given to the interpreter:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-interp-appC-case>](#(elem._(chunk._~3ccps-interp-app.C-case~3e~3a1)))
    ::='
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '| [appC (f a) (interp/k f env |'
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       (lambda (fv) |'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (interp/k a env |'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                   (lambda (av) |'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                     ((closV-f fv) av k)))))] |'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Finally, the lamC case. We have to create a closV using a lambda, as before.
    However, this procedure needs to take two arguments: the actual value of the argument,
    and the continuation of the application. The critical question is, what is this
    latter value?'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'We have essentially two choices. k represents the static continuation: the
    one active at the point of closure construction. However, what we want is the
    continuation at the point of closure invocation: the dynamic continuation.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-interp-lamC-case>](#(elem._(chunk._~3ccps-interp-lam.C-case~3e~3a1)))
    ::='
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '| [lamC (a b) (k (closV (lambda (arg-val dyn-k) |'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (interp/k b |'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                   (extend-env (bind a arg-val) |'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                               env) |'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                   dyn-k))))] |'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'To test this revised interpreter, we need to invoke interp/k with some kind
    of initial continuation value. This needs to be a procedure that represents nothing
    remaining in the computation. A natural representation for this is the identity
    function:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (interp [expr : ExprC]) : Value |'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (interp/k expr mt-env |'
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (lambda (ans) |'
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               ans))) |'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: To signify that this is strictly a top-level interface to interp/k, we’ve dropped
    the environment parameter and pass the empty environment automatically. If we
    want to be especially sure we haven’t accidentally used this procedure recursively,
    we could insert a call to error at its end to prevent it from returning and its
    return value being used.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 14.3Generators
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many programming languages now have a notion of generators. A generator is like
    a procedure, in that one can invoke it in an application. Whereas a regular procedure
    always begins execution at the beginning, a generator resumes from where it last
    left off. Of course, that means a generator needs a notion of “exiting before
    it’s done”. This is known as yielding, namely returning control to whatever called
    it.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.1Design Variations
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many variations between generators. The points of variation, predictably,
    have to do with how to enter and exit a generator:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In some languages a generator is an object that is instantiated like any other
    object, and its execution is resumed by invoking a method (such as next in Python).
    In others it is just like a procedure, and indeed it is re-entered by applying
    it like a function.In languages where values in addition to regular procedures
    can be used in an application, all such values are collectively called applicables.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some languages the yielding operation—<wbr>such as Python’s yield—<wbr>is
    available only inside the syntactic body of the generator. In others, such as
    Racket, yield is an applicable value bound in the body, but by virtue of being
    a value, it can be passed to abstractions, stored in data structures, and so on.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python’s design represents an extreme point in that a generator is simply any
    function that contains the keyword yield in its body. In addition, Python’s yield
    cannot be passed as a parameter to another function that performs the yielding
    on behalf of the generator.There is also a small issue of naming. In many languages
    with generators, the yielder is automatically called word yield: either as a keyword
    (as in Python) or as an identifier bound to an applicable value (as in Racket).
    Another possibility is that the user of the generator must indicate in the generator
    expression what name to give the yielder.Curiously, Python expects users to determine
    what to call self or this in objects, but it does not provide the same flexibility
    for yield, because it has no other way to determine which functions are generators!
    That is, a use might look like'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '| (generator (yield) (from) |'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (rec (f (lam (n) |'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (seq |'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (yield n) |'
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (f (+ n 1))))) |'
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|              (f from))) |'
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: but it might equivalently be
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '| (generator (y) (from) |'
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (rec (f (lam (n) |'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (seq |'
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (y n) |'
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (f (+ n 1))))) |'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|              (f from))) |'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'and if the yielder is an actual value, a user can also abstract over yielding:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '| (generator (y) (from) |'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (rec (f (lam (n) |'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (seq |'
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        ((yield-helper y) n) |'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (f (+ n 1))))) |'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|              (f from))) |'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'where yield-helper will presumably perform the actual yielding.There are actually
    two more design decisions:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Is yield a statement or expression? In many languages it is actually an expression,
    meaning it has a value: the one supplied when resuming the generator. This makes
    the generator more flexible because the user of a generator can use the parameter(s)
    to alter the generator’s behavior, rather than being forced to use state to communicate
    desired changes.'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens at the end of the generator’s execution? In many languages, a generator
    raises an exception to signal its completion.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 14.3.2Implementing Generators
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement generators, it will be especially useful to employ our CPS macro
    language. Let’s first decide where we stand regarding the above design decisions.
    We will use the applicative representation of generators: that is, asking for
    the next value from the generator is done by applying it to any necessary arguments.
    Similarly, the yielder will also be an applicable value and will in turn be an
    expression. Though we have already seen how macros can automatically capture a
    name [REF], let’s make the yielder’s name explicit to keep the macro simpler.
    Finally, we’ll raise an error when the generator is done executing.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: How do generators work? To yield, a generator must
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: remember where in its execution it currently is, and
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: know where in its caller it should return to.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: while, when invoked, it should
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: remember where in its execution its caller currently is, and
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: know where in its body it should return to.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observe the duality between invocation and yielding.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, these “where”s correspond to continuations.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build up the generator rule of the cps macro incrementally. First a header
    pattern:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-generator-case>](#(elem._(chunk._~3ccps-macro-generator-case~3e~3a1)))
    ::='
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (generator (yield) (v) b)) |'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  (and (identifier? #''v) (identifier? #''yield)) |'
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  [<generator-body>](#(elem._(chunk._~3cgenerator-body~3e~3a1)))] |'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'The beginning of the body is easy: all code in CPS needs to consume a continuation,
    and because a generator is a value, this value should be supplied to the continuation:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[<generator-body>](#(elem._(chunk._~3cgenerator-body~3e~3a1))) ::='
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '| #''(lambda (k) |'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (k [<generator-value>](#(elem._(chunk._~3cgenerator-value~3e~3a1)))))
    |'
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Now we’re ready to tackle the heart of the generator.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that a generator is an applicable value. That means it can occur in
    an application position, and must therefore have the same “interface” as a procedure:
    a procedure of two arguments, the first a value and the second the continuation
    at the point of application. What should this procedure do? We’ve described just
    this above. First the generator must remember where the caller is in its execution,
    which is precisely the continuation at the point of application; “remember” here
    most simply means “must be stored in state”. Then, the generator should return
    to where it previously was, i.e., its own continuation, which must clearly have
    been stored. Therefore the core of the applicable value is:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[<generator-core>](#(elem._(chunk._~3cgenerator-core~3e~3a1))) ::='
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (v dyn-k) |'
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (begin |'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (set! where-to-go dyn-k) |'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (resumer v))) |'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Here, where-to-go records the continuation of the caller, to resume it upon
    yielding; resumer is the local continuation of the generator. Let’s think about
    what their initial values must be:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: where-to-go has no initial value (because the generator has yet to be invoked),
    so it needs to throw an error if ever used. Fortunately this error will never
    occur, because where-to-go is mutated on the first entry into the generator, so
    the error is just a safeguard against bugs in the implementation.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initially, the rest of the generator is the whole generator, so resumer should
    be bound to the (CPS of) b. What is its continuation? This is the continuation
    of the entire generator, i.e., what to do when the generator finishes. We’ve agreed
    that this should also signal an error (except in this case the error truly can
    occur, in case the generator is asked to produce more values than it’s equipped
    to).
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We still need to bind yield. It is, as we’ve pointed out, symmetric to generator
    resumption: save the local continuation in resumer and return by applying where-to-go.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting together these pieces, we get:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[<generator-value>](#(elem._(chunk._~3cgenerator-value~3e~3a1))) ::='
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '| (let ([where-to-go (lambda (v) (error ''where-to-go "nothing"))]) |'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (letrec([resumer (lambda (v) |'
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      ((cps b) (lambda (k) |'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                 (error ''generator "fell through"))))] |'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|           [yield (lambda (v gen-k) |'
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                    (begin |'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (set! resumer gen-k) |'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (where-to-go v)))]) |'
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [<generator-core>](#(elem._(chunk._~3cgenerator-core~3e~3a1))))) |'
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Do Now!
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Why this pattern of let and letrec instead of let?
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe the dependencies between these code fragments. where-to-go doesn’t depend
    on either of resumer or yield. yield clearly depends on both where-to-go and resumer.
    But why are resumer and yield mutually referential?
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Try the alternative!
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The subtle dependency you may be missing is that resumer contains b, the body
    of the generator, which may contain references to yield. Therefore, it needs to
    be closed over the binding of the yielder.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: How do generators differ from coroutines and threads? Implement coroutines and
    threads using a similar strategy.
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 14.4Continuations and Stacks
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Surprising as it may seem, CPS conversion actually provides tremendous insight
    into the nature of the program execution stack. The first thing to understand
    is that every continuation is actually the stack itself. This might seem odd,
    given that stacks are low-level machine primitives while continuations are seemingly
    complex procedures. But what is the stack, really?
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: It’s a record of what remains to be done in the computation. So is the continuation.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s traditionally thought of as a list of stack frames. That is, each frame
    has a reference to the frames remaining after it finishes. Similarly, each continuation
    is a small procedure that refers to—<wbr>and hence closes over—<wbr>its own continuation.
    If we had chosen a different representation for program instructions, combining
    this with the data structure representation of closures, we would obtain a continuation
    representation that is essentially the same as the machine stack.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each stack frame also stores procedure parameters. This is implicitly managed
    by the procedural representation of continuations, whereas this was done explicitly
    in the data stucture representation (using bind).
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each frame also has space for “local variables”. In principle so does the continuation,
    though by using the macro implementation of local binding, we’ve effectively reduced
    everything to procedure parameters. Conceptually, however, some of these are “true”
    procedure parameters while others are local bindings turned into procedure parameters
    by a macro.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack has references to, but does not close over, the heap. Thus changes
    to the heap are visible across stack frames. In precisely the same way, closures
    refer to, but do not close over, the store, so changes to the store are visible
    across closures.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, traditionally the stack is responsible for maintaining lexical scope,
    which we get automatically because we are using closures in a statically-scoped
    language.Now we can study the conversion of various terms to understand the mapping
    to stacks. For instance, consider the conversion of a function application [REF]:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (f a)) |'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps f) (lambda (fv) |'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 ((cps a) (lambda (av) |'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                            (fv av k))))))] |'
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'How do we “read” this? As follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use k to refer to the stack present before the function application begins
    to evaluate.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we begin to evaluate the function position (f), create a new stack frame
    ((lambda (fv) ...)). This frame has one free identifier: k. Thus its closure needs
    to record one element of the environment, namely the rest of the stack.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code portion of the stack frame represents what is left to be done once
    we obtain a value for the function: evaluate the argument, and perform the application,
    and return the result to the stack expecting the result of the application: k.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When evaluation of f completes, we begin to evaluate a, which also creates
    a stack frame: (lambda (av) ...). This frame has two free identifiers: k and fv.
    This tells us:'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We no longer need the stack frame for evaluating the function position, but
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: we now need a temporary that records the value—<wbr>hopefully a function value—<wbr>of
    evaluating the function position.
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code portion of this second frame also represents what is left to be done:
    invoke the function value with the argument, in the stack expecting the value
    of the application.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us apply similar reasoning to conditionals:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (cnd tst thn els)) |'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      ((cps tst) (lambda (tstv) |'
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                   (if tstv |'
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       ((cps thn) k) |'
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       ((cps els) k)))))] |'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: It says that to evaluate the conditional expression we have to create a new
    stack frame. This frame closes over the stack expecting the value of the entire
    conditional. This frame makes a decision based on the value of the conditional
    expression, and invokes one of the other expressions. Once we have examined this
    value the frame created to evaluate the conditional expression is no longer necessary,
    so evaluation can proceed in k.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewed through this lens, we can more easily provide an operational explanation
    for generators. Each generator has its own private stack, and when execution attempts
    to return past its end, our implementation raises an error. On invocation, a generator
    stores a reference to the stack of the “rest of the program” in where-to-go, and
    resumes its own stack, which is referred to by resumer. On yielding, the system
    swaps references to stacks. Coroutines, threads, and generators are all conceptually
    similar: they are all mechanisms to create “many little stacks” instead of having
    a single, global stack.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 14.5Tail Calls
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observe that the stack patterns above add a frame to the current stack, perform
    some evaluation, and eventually always return to the current stack. In particular,
    observe that in an application, we need stack space to evaluate the function position
    and then the arguments, but once all these are evaluated, we resume computation
    using the stack we started out with before the application. In other words, function
    calls do not themselves need to consume stack space: we only need space to compute
    the arguments.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not all languages observe or respect this property. In languages that
    do, programmers can use recursion to obtain iterative behavior: i.e., a sequence
    of function calls can consume no more stack space than no function calls at all.
    This removes the need to create special looping constructs; indeed, loops can
    simply be expressed as a syntactic sugar.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this property does not apply in general. If a call to f is performed
    to compute an argument to a call to g, the call to f is still consuming space
    relative to the context surrounding g. Thus, we should really speak of a relationship
    between expressions: one expression is in tail position relative to another if
    its evaluation requires no additional stack space beyond the other. In our CPS
    macro, every expression that uses k as its continuation—<wbr>such as a function
    application after all the sub-expressions have been evaluated, or the then- and
    else-branches of a conditional—<wbr>are all in tail position relative to the enclosing
    application (and perhaps recursively further up). In contrast, every expression
    that has to create a new stack frame is not in tail position.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages have special support for tail recursion: when a procedure calls
    itself in tail position relative to its body. This is obviously useful, because
    it enables recursion to efficiently implement loops. However, it hurts “loops”
    that cannot be squeezed into a single recursive function. For instance, when implementing
    a scanner or other state machine, it is most convenient to have a set of functions
    each representing one state, and transitioning to other states by making (tail)
    function calls. It is onerous (and misses the point) to turn these into a single
    recursive function. If, however, a language recognizes tail calls as such, it
    can optimize these cross-function calls just as much as it does intra-function
    ones.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Racket, in particular, promises to implement tail calls without allocating
    additional stack space. Though some people refer to this as “tail call optimization”,
    this term is misleading: an optimization is optional, whereas whether or not a
    language promises to properly implement tail calls is a semantic feature. Developers
    need to know how the language will behave because it affects how they program.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this feature, observe something interesting about the program after
    CPS transformation: all of its function applications are themselves tail calls!
    You can see this starting with the read-number/suspend example that began this
    chapter: any pending computation was put into the continuation argument. Assuming
    the program might terminate at any call is tantamount to not using any stack space
    at all (because the stack would get wiped out).'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: How is the program able to function in the absence of a stack?
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 14.6Continuations as a Language Feature
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this insight into the connection between continuations and stacks, we
    can now return to the treatment of procedures: we ignored the continuation at
    the point of closure creation and instead only used the one at the point of closure
    invocation. This of course corresponds to normal procedure behavior. But now we
    can ask, what if we use the creation-time continuation instead? This would correspond
    to maintaining a reference to (a copy of) the stack at the point of “procedure”
    creation, and when the procedure is applied, ignoring the dynamic evaluation and
    going back to the point of procedure creation.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: In principle, we are trying to leave lambda intact and instead give ourselves
    a language construct that corresponds to this behavior:cc = “current continuation”
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-let/cc-case>](#(elem._(chunk._~3ccps-macro-let/cc-case~3e~3a1)))
    ::='
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (let/cc kont b)) |'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  (identifier? #''kont) |'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (let ([kont (lambda (v dyn-k) |'
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                    (k v))]) |'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        ((cps b) k)))] |'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'What this says is that either way, control will return to the expression that
    immediately surrounds the let/cc: either by falling through (because the continuation
    of the body, b, is k) or—<wbr>more interestingly—<wbr>by invoking the continuation,
    which discards the dynamic continuation dyn/k by simply ignoring it and returning
    to k instead.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the simplest test:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '| (test (run (cps (let/cc esc 3))) |'
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       3) |'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'This confirms that if we never use the continuation, evaluation of the body
    proceeds as if the let/cc weren’t there at all (because of the ((cps b) k)). If
    we use it, the value given to the continuation returns to the point of creation:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '| (test (run (cps (let/cc esc (esc 3)))) |'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       3) |'
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'This example, of course, isn’t revealing, but consider this one:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '| (test (run (cps (+ 1 (let/cc esc (esc 3))))) |'
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       4) |'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: This confirms that the addition actually happens. But what about the dynamic
    continuation?
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '| (test (run (cps (let/cc esc (+ 2 (esc 3))))) |'
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       3) |'
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'This shows that the addition by 2 never happens, i.e., the dynamic continuation
    is indeed ignored. And just to be sure that the continuation at the point of creation
    is respected, observe:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '| (test (run (cps (+ 1 (let/cc esc (+ 2 (esc 3)))))) |'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       4) |'
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'From these examples, you have probably noticed a familiar pattern: esc here
    is behaving like an exception. That is, if you do not throw an exception (in this
    case, invoke a continuation) it’s as if it’s not there, but if you do throw it,
    all pending intermediate computation is ignored and computation returns to the
    point of exception creation.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Using let/cc and macros, create a throw/catch mechanism.
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'However, these examples only scratch the surface of available power, because
    the continuation at the point of invocation is always an extension of one at the
    point of creation: i.e., the latter is just earlier in the stack than the former.
    However, nothing actually demands that k and dyn-k be at all related. That means
    they are in fact free to be unrelated, which means each can be a distinct stack,
    so we can in fact easily implement stack-switching procedures with them.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'To be properly analogous to lambda, we should have introduced a construct called,
    say, cont-lambda with the following expansion:'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| [(_ (cont-lambda (a) b)) |'
  id: totrans-519
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  (identifier? #''a) |'
  id: totrans-520
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|  #''(lambda (k) |'
  id: totrans-521
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|      (k (lambda (a dyn-k) |'
  id: totrans-522
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '|           ((cps b) k))))] |'
  id: totrans-523
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: ''
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why didn’t we? Consider both the static typing implications, and also how we
    might construct the above exception-like behaviors using this construct instead.
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 14.6.1Presentation in the Language
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing programs in our little toy languages can soon become frustrating. Fortunately,
    Racket already provides a construct called call/cc that reifies continuations.
    call/cc is a procedure of one argument, which is itself a procedure of one argument,
    which Racket applies to the current continuation—<wbr>which is a procedure of
    one argument. Got that?
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can easily write let/cc as a macro over call/cc and program
    with that instead. Here it is:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-syntax let/cc |'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (syntax-rules () |'
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(let/cc k b) |'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (call/cc (lambda (k) b))])) |'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'To be sure, all our old tests still pass:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '| (test (let/cc esc 3) 3) |'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (test (let/cc esc (esc 3)) 3) |'
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (test (+ 1 (let/cc esc (esc 3))) 4) |'
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (test (let/cc esc (+ 2 (esc 3))) 3) |'
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (test (+ 1 (let/cc esc (+ 2 (esc 3)))) 4) |'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 14.6.2Defining Generators
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we can start to create interesting abstractions. For instance, let’s build
    generators. Whereas previously we needed to both CPS expressions and pass around
    continuations, now this is done for us automatically by call/cc. Therefore, whenever
    we need the current continuation, we simply conjure it up without having to transform
    the program. Thus the extra ...-k parameters can disappear with a let/cc in the
    same place to capture the same continuation:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-syntax (generator e) |'
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (syntax-case e () |'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(generator (yield) (v) b) |'
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      #''(let ([where-to-go (lambda (v) (error ''where-to-go "nothing"))])
    |'
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          (letrec ([resumer (lambda (v) |'
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                              (begin b |'
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                     (error ''generator "fell through")))]
    |'
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                   [yield (lambda (v) |'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                            (let/cc gen-k |'
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                              (begin |'
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                (set! resumer gen-k) |'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                (where-to-go v))))]) |'
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (lambda (v) |'
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|              (let/cc dyn-k |'
  id: totrans-554
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                (begin |'
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                  (set! where-to-go dyn-k) |'
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                  (resumer v))))))])) |'
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Observe the close similarity between this code and the implementation of generators
    by desugaring into CPS code. Specifically, we can drop the extra continuation
    arguments, and replace them with invocations of let/cc that will capture precisely
    the same continuations. The rest of the code is fundamentally unchanged.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we move the let/ccs and mutation to be the first statement inside
    the begins instead?
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can, for instance, write a generator that iterates from the initial value
    upward:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '| (define g1 (generator (yield) (v) |'
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       (letrec ([loop (lambda (n) |'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                        (begin |'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                          (yield n) |'
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                          (loop (+ n 1))))]) |'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (loop v)))) |'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'whose behavior is:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '| > (g1 10) |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
- en: '| 10 |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
- en: '| > (g1 10) |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
- en: '| 11 |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
- en: '| > (g1 0) |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
- en: '| 12 |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
- en: '| > |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
- en: 'Because the body refers only to the initial value, ignoring that returned by
    invoking yield, the values we pass on subsequent invocations are irrelevant. In
    contrast, consider this generator:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '| (define g2 (generator (yield) (v) |'
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       (letrec ([loop (lambda (n) |'
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                        (loop (+ (yield n) n)))]) |'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (loop v)))) |'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'On its first invocation, it returns whatever value it was supplied. On subsequent
    invocations, this value is added to that provided on re-entry into the generator.
    In other words, this generator additively accumulates all values given to it:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '| > (g2 10) |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
- en: '| 10 |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
- en: '| > (g2 15) |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
- en: '| 25 |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
- en: '| > (g2 5) |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
- en: '| 30 |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
- en: Exercise
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to implement generators using call/cc and let/cc, implement
    coroutines and threads as well.
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 14.6.3Defining Threads
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having done generators, let’s do another, similar primitive: threads. That
    is, let’s assume we want to be able to write a program such as this:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '| (define d display) ;; a useful shorthand in what follows |'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   |'
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (scheduler-loop-0 |'
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  (list |'
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (thread-0 (y) (d "t1-1  ") (y) (d "t1-2  ") (y) (d "t1-3 ")) |'
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (thread-0 (y) (d "t2-1  ") (y) (d "t2-2  ") (y) (d "t2-3 ")) |'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (thread-0 (y) (d "t3-1  ") (y) (d "t3-2  ") (y) (d "t3-3 ")))) |'
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: and expect the output
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '| t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3 |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
- en: We’ll build all the pieces necessary to achieve this.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by defining the thread scheduler. It consumes a list of “threads”,
    whose interface we assume will be a procedure that consumes a continuation to
    which it eventually yields control. Each time the scheduler reactivates the thread,
    it supplies it with a continuation. The scheduler might be choose between threads
    in a simple round-robin manner, or it might use some more complex algorithm; the
    details of how it chooses don’t concern us here.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'As with generators, we’ll assume that yielding is done by invoking a procedure
    named by the user: y, above. We could use name capture [REF] to automatically
    bind a name like yield.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, notice that the user of the thread system manually yields
    control. This is called cooperative multitasking. Instead, we could have chosen
    to have a timer or other intrinsic mechanism automtically yield without the user’s
    permission; this is called preemptive multitasking (because the system “pre-empts”—<wbr>i.e.,
    wrests control from—<wbr>the thread). While the distinction is important for buildling
    systems, it is not interesting from the perspective of setting up the continuations.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: After we are done building cooperative multitasking, implement preemptive multitasking.
    What changes?
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With our stated constraints, we can write a first scheduler. It consumes a
    lists of threads and continues executing so long as there are threads remaining.
    Each time, it applies the thread procedure to a continuation that represents returning
    to the scheduler and proceeding to the next thread:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (scheduler-loop-0 threads) |'
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (cond |'
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(empty? threads) ''done] |'
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(cons? threads) |'
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (begin |'
  id: totrans-612
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        (let/cc after-thread ((first threads) after-thread)) |'
  id: totrans-613
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        (scheduler-loop-0 (append (rest threads) |'
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                  (list (first threads)))))])) |'
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'When the recipient thread invokes the continuation bound to after-thread, control
    returns to the end of the first statement in the begin sequence. As a result,
    the value supplied to the continuation is ignored (and can hence be any dummy
    value; we’ll chose ’dummy, so that we can easily spot it if it shows up in undesired
    places). Control then proceeds with the rest of the scheduler loop after appending
    the most recently invoked thread to the end of the list of threads (i.e., treating
    the list as a circular queue).Now let’s define a thread. As we’ve said, it will
    be a procedure of one argument, the scheduler’s continuation. Because the thread
    needs to resume, i.e., continue where it left off, presumably it must store where
    it last was: we’ll call this thread-resumer. Initially this is the entire thread
    body, but on subsequent instances it will be a continuation: specifically, the
    continuation of invoking yield. Thus, we obtain the following skeleton:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-syntax thread-0 |'
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (syntax-rules () |'
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(thread (yielder) b ...) |'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (letrec ([thread-resumer (lambda (_) |'
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                 (begin b ...))]) |'
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        (lambda (sched-k) |'
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          (thread-resumer ''dummy)))])) |'
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'That still leaves the yielder. It needs to be a procedure of no arguments that
    stores the thread’s continuation in thread-resumer, and then invoke the scheduler
    continuation with ’dummy. However, which scheduler continuation does it need to
    invoke? Not the one provided on thread initiation, but rather the most recent
    one. Thus, we must somehow “thread” the value in sched-k to the yielder. There
    are many ways to accomplish it, but the simplest, perhaps most brutal, way is
    to simply reconstruct the yielder on each thread resumption, always closed over
    the most recent value of sched-k:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-syntax thread-0 |'
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (syntax-rules () |'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(thread (yielder) b ...) |'
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (letrec ([thread-resumer (lambda (_) |'
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                 (begin b ...))] |'
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               [yielder (lambda () (error ''yielder "nothing here"))]) |'
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        (lambda (sched-k) |'
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          (begin |'
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (set! yielder |'
  id: totrans-633
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                  (lambda () |'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                    (let/cc thread-k |'
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (begin |'
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (set! thread-resumer thread-k) |'
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (sched-k ''dummy))))) |'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (thread-resumer ''tres))))])) |'
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'When we run this ensemble, we get:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '| t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3 |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
- en: 'Hey, that’s what we wanted! But it continues:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '| t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
- en: Hmmm.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s happening? Well, we’ve been quiet all along about what needs to happen
    when a thread reaches its end. In fact, control just returns to the thread scheduler,
    which appends the thread to the end of the queue, and when the thread comes to
    the head of the queue again, control resumes from the same previously stored continuation:
    the one corresponding to printing the third value. This prints, control returns,
    the thread is appended...ad infinitum.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, we need the thread scheduler to be notified when a thread has terminated,
    so that the scheduler can remove it from the thread queue. We’ll create a simple
    datatype to represent this signal:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-type ThreadStatus |'
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [Tsuspended] |'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [Tdone]) |'
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '(In a real system, of course, these status messages might also carry informative
    values from the computation.) We must now modify our scheduler to actually check
    for and use these values:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (scheduler-loop-1 threads) |'
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (cond |'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(empty? threads) ''done] |'
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(cons? threads) |'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (type-case ThreadStatus (let/cc after-thread ((first threads) after-thread))
    |'
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        [Tsuspended () (scheduler-loop-1 (append (rest threads) |'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                                 (list (first threads))))]
    |'
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        [Tdone () (scheduler-loop-1 (rest threads))])])) |'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'We have to now modify our thread representation in two ways: it must provide
    Tsuspended to the scheduler’s continuation on intermediate returns, and provide
    Tdone when it terminates. Where does it terminate? After executing the code in
    the body, b .... Observe, finally, that the termination process must be sure to
    use the latest scheduler continuation, just as yielding does. Thus:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-syntax thread-1 |'
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (syntax-rules () |'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(thread (yielder) b ...) |'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (letrec ([thread-resumer (lambda (_) |'
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                 (begin b ... |'
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                        (finisher)))] |'
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               [finisher (lambda () (error ''finisher "nothing here"))] |'
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               [yielder (lambda () (error ''yielder "nothing here"))]) |'
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        (lambda (sched-k) |'
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          (begin |'
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (set! finisher |'
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                  (lambda () |'
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                    (let/cc thread-k |'
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (sched-k (Tdone))))) |'
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (set! yielder |'
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                  (lambda () |'
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                          (let/cc thread-k |'
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                            (begin |'
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                              (set! thread-resumer thread-k) |'
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                              (sched-k (Tsuspended)))))) |'
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (thread-resumer ''tres))))])) |'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: If we now replace scheduler-loop-0 with scheduler-loop-1 and thread-0 with thread-1
    and re-run our example program above, we get just the output we desire.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 14.6.4Better Primitives for Web Programming
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, to tie the knot back to where we began, let’s return to read-number:
    observe that, if the language running the server program has call/cc, instead
    of having to CPS the entire program, we can simply capture the current continuation
    and save it in the hash table, leaving the program structure again intact.'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
