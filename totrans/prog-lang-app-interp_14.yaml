- en: 14Control Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14控制操作
- en: The term control refers to any programming language instruction that causes
    evaluation to proceed, because it “controls” the program counter of the machine.
    In that sense, even a simple arithmetic expression should qualify as “control”,
    and operations such as sequential program execution, or function calls and returns,
    most certainly do. However, in practice we use the term to refer primarily to
    those operations that cause non-local transfer of control, especially beyond that
    of mere functions and procedures, and the next step up, namely exceptions. We
    will study such operations in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 控制一词指的是任何导致评估继续进行的编程语言指令，因为它“控制”了机器的程序计数器。在这个意义上，即使是一个简单的算术表达式也应该被视为“控制”，而像顺序程序执行、函数调用和返回等操作则肯定是。然而，在实践中，我们使用这个术语主要是指那些导致非局部控制转移的操作，尤其是超出了仅仅函数和过程的范围，以及更高级别的异常。我们将在本章中研究这些操作。
- en: As we study the following control operators, it’s worth remembering that even
    without them, we still have languages that are Turing-complete, and therefore
    have no more “power”. Therefore, what control operators do is change and potentially
    improve the way we express our intent, and therefore enhance the structure of
    programs. Thus, it pays to being our study by focusing on program structure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习以下控制操作符时，值得记住，即使没有它们，我们仍然拥有图灵完备的语言，因此没有更多的“权力”。因此，控制操作符的作用是改变并潜在地改善我们表达意图的方式，从而增强程序的结构。因此，我们开始学习时应该专注于程序结构。
- en: 14.1Control on the Web
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1网络控制
- en: 'Let us begin our study by examining the structure of Web programs. Consider
    the following program:Henceforth, we’ll call this our “addition server”. You should,
    of course, understand this as a stand-in for more sophisticated applications.
    For instance, the two prompts might ask for starting and ending points for a trip,
    and in place of addition we might compute a route or compute airfares. There might
    even be computation between the two steps: e.g., after entering the first city,
    the airline might prompt us with choices of where it flies from there.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查Web程序的结构来开始我们的学习。考虑以下程序：从现在开始，我们将称之为我们的“加法服务器”。当然，你应该把这看作更复杂应用程序的替身。例如，这两个提示可能要求输入旅行的起点和终点，而在加法的位置上，我们可能计算路线或计算机票价格。甚至可能在两个步骤之间进行计算：例如，在输入第一个城市后，航空公司可能会提示我们选择从那里飞往哪里。
- en: '| (display |'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (display |'
- en: '|   (+ (read-number "First number") |'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (+ (read-number "第一个数字") |'
- en: '|      (read-number "Second number"))) |'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (read-number "第二个数字"))) |'
- en: 'To test these ideas, here’s an implementation of read-number:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些想法，这里是一个read-number的实现：
- en: '| (define (read-number [prompt : string]) : number |'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (read-number [prompt : string]) : number |'
- en: '|   (begin |'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (begin |'
- en: '|     (display prompt) |'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (display prompt) |'
- en: '|     (let ([v (read)]) |'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (let ([v (read)]) |'
- en: '|       (if (s-exp-number? v) |'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (if (s-exp-number? v) |'
- en: '|           (s-exp->number v) |'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (s-exp->number v) |'
- en: '|           (read-number prompt))))) |'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (read-number prompt))))) |'
- en: When run at the console or in DrRacket, this program prompts us for one number,
    then another, and then displays their sum.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当在控制台或DrRacket中运行时，此程序会提示我们输入一个数字，然后另一个数字，然后显示它们的和。
- en: 'Now suppose we want to run this on a Web server. We immediately encounter a
    difficulty: the structure of server-side Web programs is such that they generate
    a single Web page—<wbr>such as the one asking for the first number—<wbr>and then
    halt. As a result, the rest of the program—<wbr>which in this case prompts for
    the second number, then adds them, and then prints that result, is lost.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想在Web服务器上运行这个程序。我们立即遇到一个困难：服务器端Web程序的结构是这样的，它们生成一个单一的网页—<wbr>比如要求输入第一个数字的网页—<wbr>然后停止。因此，程序的其余部分—<wbr>在这种情况下提示输入第二个数字，然后相加，然后打印结果—<wbr>会丢失。
- en: Do Now!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: Why do Web servers behave in such a strange way?
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么Web服务器表现得如此奇怪？
- en: 'There are at least two reasons for this behavior: one perhaps historical, and
    the other technical. The historical reason is that Web servers were initially
    designed to serve pages, i.e., static content. Any program that ran had to generate
    its output to a file, from which a server could offer it. Naturally, developers
    wondered why that same program couldn’t run on demand. This made Web content dynamic.
    Terminating the program after generating a single piece of output was the simplest
    incremental step towards programs, not pages, on the Web.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为至少有两个原因：一个可能是历史原因，另一个是技术原因。历史原因是，Web 服务器最初是设计用来提供页面，即静态内容。任何运行的程序都必须将其输出生成到一个文件中，服务器可以从中提供。自然地，开发人员想知道为什么同样的程序不能按需运行。这使得
    Web 内容变得动态起来。在生成单个输出后终止程序是朝向 Web 上的程序而不是页面的最简单的渐进式步骤。
- en: 'The more important reason—<wbr>and the one that has stayed with us—<wbr>is
    technical. Imagine our addition server has generated its first prompt. Recall
    that there is considerable pending computation: the second prompt, the addition,
    and the display of the result. This computation must suspend waiting for the user’s
    input. If there are millions of users, then millions of computations must be suspended,
    creating an enormous performance problem. Furthermore, suppose a user does not
    actually complete the computation—<wbr>analogous to searching at an on-line bookstore
    or airline site, but not completing the purchase. How does the server know when
    or even whether to terminate the computation? And until it does, the resources
    associated with that computation remain in use.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的原因——并且一直存在着的原因——是技术性的。想象一下，我们的加法服务器已经生成了第一个提示符。回想一下，有相当多的待处理计算：第二个提示符，加法，以及结果的显示。这个计算必须暂停等待用户的输入。如果有数百万的用户，那么数百万的计算必须被暂停，这会产生巨大的性能问题。此外，假设用户实际上没有完成计算——类似于在在线书店或航空公司网站搜索，但没有完成购买。服务器如何知道何时甚至是否终止计算？在它这样做之前，与该计算相关联的资源仍在使用中。
- en: 'Conceptually, therefore, the Web protocol was designed to be stateless: it
    would not store state on the server associated with intermediate computations.
    Instead, Web program developers would be forced to maintain all necessary state
    elsewhere, and each request would need to be able to resume the computation in
    full. In practice, the Web has not proven to be stateless at all, but it still
    hews largely in this direction, and studying the structure of such programs is
    very instructive.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从概念上讲，Web 协议被设计为无状态的：它不会在服务器上存储与中间计算相关的状态。相反，Web 程序开发人员将被迫在其他地方维护所有必要的状态，并且每个请求都需要能够完整地恢复计算。实际上，Web
    并没有被证明是无状态的，但它仍然在很大程度上朝着这个方向发展，研究这种程序的结构非常有启发性。
- en: 'Now consider client-side Web programs: those that run inside the browser, written
    in or compiled to JavaScript. Suppose such a computation needs to communicate
    with a server. The primitive for this is called XMLHttpRequest. The user makes
    an instance of this primitive and invokes its send method to send a message to
    the server. Communicating with a server is not, however, instantaneous (and indeed
    may never complete, depending on the state of the network). This leaves the sending
    process suspended.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑客户端 Web 程序：那些在浏览器内运行的程序，编写或编译成 JavaScript。假设这样的计算需要与服务器通信。这个通信的原语称为 XMLHttpRequest。用户创建这个原语的实例，并调用它的
    send 方法将消息发送到服务器。然而，与服务器通信并不是瞬时的（实际上可能永远不会完成，这取决于网络的状态）。这将导致发送过程被挂起。
- en: 'The designers of JavaScript decided to make the language single-threaded: i.e.,
    there would be only one thread of execution at a time.Due to the structuring problems
    this causes, there are now various proposals to, in effect, add “safe” threads
    to JavaScript. The ideas described in this chapter can be viewed as an alternative
    that offer similar structuring benefits. This avoids the various perils that arise
    from combining mutation with threads. As a result, however, the JavaScript process
    locks up awaiting the response, and nothing else can happen: e.g., other handlers
    on the page no longer respond.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的设计者决定使语言单线程化：即一次只有一个执行线程。由于这导致的结构问题，现在有各种提案，实际上是向 JavaScript 添加“安全”线程。本章描述的思想可以看作是提供类似结构性好处的替代方案。然而，这样一来，JavaScript
    进程会因为等待响应而锁定，其他任何事情都无法发生：例如，页面上的其他处理程序不再响应。
- en: To avoid this problem, the design of XMLHttpRequest demands that the developer
    provide a procedure that responds to the request if and when it arrives. This
    callback procedure is registered with the system. It needs to embody the rest
    of the processing of that request. Thus, for entirely different reasons—<wbr>not
    performance, but avoiding the problems of synchronization, non-atomicity, and
    deadlocks—<wbr>the client-side Web has evolved to demand the same pattern of developers.
    Let us now better understand that pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，XMLHttpRequest 的设计要求开发人员提供一个在请求到达时响应的过程。这个回调过程已在系统中注册。它需要体现该请求的其余处理。因此，出于完全不同的原因——不是性能，而是避免同步、非原子性和死锁的问题——客户端
    Web 已经发展到要求开发人员采用相同的模式。现在让我们更好地理解这种模式。
- en: 14.1.1Program Decomposition into Now and Later
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1程序分解为现在和以后
- en: 'Let us consider what it takes to make our above program work in a stateless
    setting, such as on a Web server. First we have to determine the first interaction.
    This is the prompt for the first number, because Racket evaluates arguments from
    left to right. It is instructive to divide the program into two parts: what happens
    to generate the first interaction (which can all run now), and what needs to happen
    after it (which must be “remembered” somehow). The former is easy:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何使我们上面的程序在无状态设置中运行，比如在 Web 服务器上。首先，我们必须确定第一个交互。这是第一个数字的提示，因为 Racket 从左到右评估参数。将程序分为两部分是有益的：生成第一个交互的操作（现在全部可以运行），以及之后需要发生的操作（必须以某种方式“记住”）。前者很容易：
- en: '| (read-number "First number") |'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (read-number "First number") |'
- en: We’ve already explained in prose what’s left, but now it’s time to write it
    as a program. It seems to be something likeWe’re intentionally ignoring read-number
    for now, but we’ll return to it. For now, let’s pretend it’s built-in.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用散文解释了剩下的内容，但现在是时候将其写成程序了。它似乎是这样的：现在我们有意忽略 read-number，但我们会回到它。现在，让我们假装它是内置的。
- en: '| (display |'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (display |'
- en: '|   (+ <the result from the first interaction> |'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (+ <the result from the first interaction> |'
- en: '|      (read-number "Second number"))) |'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (read-number "Second number"))) |'
- en: 'A Web server can’t execute the above, however, because it evidently isn’t a
    program. We instead need some way of writing this as one.Let’s observe a few characteristics
    of this computation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Web 服务器无法执行上述操作，因为显然它不是一个程序。相反，我们需要以某种方式将其编写为程序。让我们观察一下这个计算的几个特点：
- en: It needs to be a legitimate program.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要是一个合法的程序。
- en: It needs to stay suspended until the request comes in.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要保持挂起，直到请求到达。
- en: It needs a way—<wbr>such as a parameter—<wbr>to refer to the value from the
    first interaction.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要一种方式——比如一个参数——来引用第一个交互的值。
- en: 'Put together these characteristics and we have a clear representation—<wbr>a
    function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些特征放在一起，我们有了一个明确的表示——一个函数：
- en: '| (lambda (v1) |'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (lambda (v1) |'
- en: '|   (display |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (display |'
- en: '|     (+ v1 |'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (+ v1 |'
- en: '|        (read-number "Second number")))) |'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        (read-number "Second number")))) |'
- en: 14.1.2A Partial Solution
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2一个部分解决方案
- en: 'On the Web, there is an additional wrinkle: each Web page with input elements
    needs to refer to a program stored on the Web, which will receive the data from
    the form and process it. This program is named in the action field of a form.
    Thus, imagine that the server generates a fresh label, stores the above function
    in a table associated with that label, and refers to the table in the action field.
    If and when the client actually submits the form, the server extracts the associated
    function, supplies it with the form’s values, and thus resumes execution.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 上，还有一个额外的问题：每个带有输入元素的 Web 页面都需要引用存储在 Web 上的程序，该程序将接收来自表单的数据并进行处理。该程序在表单的
    action 字段中命名。因此，想象一下，服务器生成一个新的标签，将上述函数存储在与该标签关联的表中，并在 action 字段中引用该表。如果客户端实际提交表单，则服务器提取关联的函数，为其提供表单的值，从而恢复执行。
- en: Do Now!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在动手！
- en: Is the solution above stateless?
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上面的解决方案是无状态的吗？
- en: 'Let’s imagine that we have a custom Web server that maintains the above table.
    In such a server, we might have a special version of read-number—<wbr>call it
    read-number/suspend—<wbr>that records the rest of the program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个维护上述表的定制 Web 服务器。在这样的服务器上，我们可能有一个特殊版本的 read-number——称之为 read-number/suspend——记录程序的其余部分：
- en: '| (read-number/suspend "First number" |'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (read-number/suspend "First number" |'
- en: '|                      (lambda (v1) |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (lambda (v1) |'
- en: '|                        (display |'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (display |'
- en: '|                         (+ v1 |'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (+ v1 |'
- en: '|                            (read-number "Second number"))))) |'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (read-number "Second number"))))) |'
- en: 'To test this, let’s implement such a procedure. First, we need a representation
    for labels; numbers are an easy substitute:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，让我们实现这样一个过程。首先，我们需要一个标签的表示；数字是一个简单的替代品：
- en: '| (define-type-alias label number) |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type-alias label number) |'
- en: Let’s say new-label generates a fresh label on each invocation.Exercise
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设new-label在每次调用时生成一个新标签。练习
- en: Define new-label. You might use new-loc for inspiration.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义new-label。你可以借鉴new-loc的方法。
- en: We need a table to store the procedures representing the rest of the program.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个表来存储表示程序其余部分的过程。
- en: '| (define table (make-hash empty)) |'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define table (make-hash empty)) |'
- en: 'Now we can store these procedures:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以存储这些过程：
- en: '| (define (read-number/suspend [prompt : string] rest) |'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (read-number/suspend [prompt : string] rest) |'
- en: '|   (let ([g (new-label)]) |'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([g (new-label)]) |'
- en: '|     (begin |'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (begin |'
- en: '|       (hash-set! table g rest) |'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (hash-set! table g rest) |'
- en: '|       (display prompt) |'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (display prompt) |'
- en: '|       (display " To enter it, use the action field label ") |'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (display " To enter it, use the action field label ") |'
- en: '|       (display g)))) |'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (display g)))) |'
- en: If we now run the above invocation of read-number/suspend, the system prints
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行上述对read-number/suspend的调用，系统将打印
- en: '| First number To enter it, use the action field label 1 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| First number 要输入它，请使用动作字段标签1 |'
- en: This is tantamount to printing the prompt in a Web page, and putting the label
    1 in the action field. Because we’re simulating it, we need something to represent
    the browser’s submission process. This needs both the label (from the action field)
    and the value entered in the form. Given these two values, this procedure needs
    to extract the relevant procedure from the table, and apply it to the form value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在 Web 页面中打印提示，并在动作字段中放置标签1。因为我们正在模拟它，所以我们需要一些来代表浏览器的提交过程。这需要标签（来自动作字段）和表单中输入的值。在拥有这两个值后，该过程需要从表中提取相关过程，并将其应用于表单值。
- en: '| (define (resume [g : label] [n : number]) |'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (resume [g : label] [n : number]) |'
- en: '|   ((some-v (hash-ref table g)) n)) |'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ((some-v (hash-ref table g)) n)) |'
- en: 'With this, we can now simulate the act of entering 3 and clicking on a “Submit”
    button by running:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以通过运行来模拟输入3并点击“提交”按钮的行为：
- en: '| > (resume 1 3) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| > (resume 1 3) |'
- en: 'where 1 is the label and 3 is the user’s input. Unfortunately, this simply
    produces another prompt, because we haven’t fully converted the program. If we
    delete read-number, we’re forced to convert the entire program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其中1是标签，3是用户的输入。不幸的是，这只会产生另一个提示，因为我们还没有完全转换程序。如果我们删除read-number，我们就不得不转换整个程序：
- en: '| (read-number/suspend "First number" |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (read-number/suspend "First number" |'
- en: '|                      (lambda (v1) |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (lambda (v1) |'
- en: '|                        (read-number/suspend "Second number" |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (read-number/suspend "Second number" |'
- en: '|                                             (lambda (v2) |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                             (lambda (v2) |'
- en: '|                                               (display |'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                               (display |'
- en: '|                                                (+ v1 v2)))))) |'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                                (+ v1 v2)))))) |'
- en: 'Just to be safe, we can also make sure the computation terminates after each
    output by adding an error invocation at the end of read-number/suspend (to truly
    ensure the most extreme form of “suspension”).When we execute this program, we
    have to use resume twice:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们还可以确保每次输出后计算都会终止，方法是在read-number/suspend的末尾添加一个错误调用（以确保“悬挂”的最极端形式）。当我们执行这个程序时，我们必须使用resume两次：
- en: '| First number To enter it, use the action field label 1 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| First number 要输入它，请使用动作字段标签1 |'
- en: '| halting: Program shut down |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| halting: 程序关闭 |'
- en: '| > (resume 1 3) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| > (resume 1 3) |'
- en: '| Second number To enter it, use the action field label 2 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| Second number 要输入它，请使用动作字段标签2 |'
- en: '| halting: Program shut down |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| halting: 程序关闭 |'
- en: '| > (resume 2 10) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| > (resume 2 10) |'
- en: '| 13 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 13 |'
- en: where the two user inputs are 3 and 10, giving a total of 13, and the
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 两个用户输入分别是3和10，总计13，
- en: '| halting |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| halting |'
- en: messages are generated by the error command we inserted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由我们插入的错误命令生成消息。
- en: 'We’ve purposely played a little coy with the types of the interesting parts
    of our program. Let’s examine what these types should be. The second argument
    to read-number/suspend needs to be a procedure that consumes numbers and returns
    whatever the computation eventually produces: (number -> ’a). Similarly, the return
    type of resume is the same ’a. How do these ’as communicate with one another?
    This is done by table, which maps labels to (number -> ’a). That is, at every
    step the computation makes progress towards the same outcome. read-number/suspend
    writes into this table, and resume reads from it.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意对程序中有趣部分的类型有点含糊。让我们来看看这些类型应该是什么。read-number/suspend的第二个参数必须是一个消耗数字并返回最终产生的计算结果的过程：（数字
    -> 'a）。类似地，resume的返回类型是相同的'a。这些'a如何相互通信？这是通过表格完成的，它将标签映射到（数字 -> 'a）。也就是说，每一步计算都朝着相同的结果取得进展。read-number/suspend写入这个表格，而resume从中读取。
- en: 14.1.3Achieving Statelessness
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3实现无状态性
- en: We haven’t actually achieved statelessness yet, because we have this large table
    residing on the server, with no clear means to remove entries from it. It would
    be better if we could avoid the server state entirely. This means we have to move
    the relevant state to the client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们还没有实现无状态性，因为我们在服务器上有这个大表，没有明确的方法来删除其中的条目。最好的方法是完全避免服务器状态。这意味着我们必须将相关状态移动到客户端。
- en: 'There are actually two ways in which the server holds state. One is that we
    have reserved the right to create as many entries in the hash table as we wish,
    rather than a constant number (i.e., linear in the size of the program itself).
    The other is what we’re storing in the table: honest-to-goodness closures, which
    might be holding on to an arbitrary amount of state. We’ll see this more clearly
    soon.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实际上有两种保持状态的方式。一种是我们保留了在哈希表中创建任意数量的条目的权利，而不是一个常数（即，与程序本身大小成线性关系）。另一种是我们在表中存储的内容：真正的闭包，可能持有任意数量的状态。我们很快会更清楚地看到这一点。
- en: 'Let’s start by eliminating the closure. Instead, let’s have each of the funtion
    arguments to be named, top-level functions (which immediately forces us to have
    only a fixed number of them, because the program’s size cannot be unbounded):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先消除闭包。相反，让我们使每个函数参数都有命名，成为顶层函数（这立即迫使我们只能有固定数量的函数，因为程序的大小不能无限制增长）：
- en: '| (read-number/stateless "First number" prog1) |'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (read-number/stateless "第一个数字" prog1) |'
- en: '|   |'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define (prog1 v1) |'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (prog1 v1) |'
- en: '|   (read-number/stateless "Second number" prog2)) |'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (read-number/stateless "第二个数字" prog2)) |'
- en: '|   |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define (prog2 v2) |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (prog2 v2) |'
- en: '|   (display (+ v1 v2))) |'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (显示 (+ v1 v2))) |'
- en: 'Observe how each code block refers only to the name of the next, rather than
    to a real closure. The value of the argument comes from the form. There’s just
    one problem: v1 in prog2 is a free identifier!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个代���块只引用下一个的名称，而不是一个真正的闭包。参数的值来自表单。只有一个问题：prog2中的v1是一个自由标识符！
- en: 'The way to fix this problem is, instead of creating a closure after one step,
    to send v1 to the client to be stored there. Where do we store this? The browser
    offers two mechanisms for doing this: cookies and hidden fields. Which one do
    we use?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是，在一步之后不创建闭包，而是将v1发送到客户端存储在那里。我们在哪里存储这个？浏览器提供了两种机制来做到这一点：cookies和隐藏字段。我们使用哪一个？
- en: 14.1.4Interaction with State
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4与状态的交互
- en: The fundamental difference between cookies and hidden fields is that all pages
    share the same cookie, but each page has its own hidden fields.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 饼干和隐藏字段之间的根本区别在于所有页面共享同一个cookie，但每个页面都有自己的隐藏字段。
- en: 'First, let’s consider a sequence of interactions with the existing program
    that uses read-number/suspend (at both interaction points). It looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一系列与现有程序交互的交互，该程序在两个交互点都使用read-number/suspend。它看起来像这样：
- en: '| First number To enter it, use the action field label 1 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 输入第一个数字，使用动作字段标签1 |'
- en: '| > (resume 1 3) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 1 3) |'
- en: '| Second number To enter it, use the action field label 2 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 输入第二个数字，使用动作字段标签2 |'
- en: '| > (resume 2 10) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 2 10) |'
- en: '| 13 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 13 |'
- en: Thus, resuming with label 2 appears to represent adding 3 to the given argument
    (i.e., form field value). To be sure,
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用标签2恢复似乎表示将3添加到给定参数（即，表单字段值）。为了确保，
- en: '| > (resume 2 15) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 2 15) |'
- en: '| 18 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 18 |'
- en: 'So far, so good. Now suppose we use label 1 again:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在假设我们再次使用标签1：
- en: '| > (resume 1 5) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 1 5) |'
- en: '| Second number To enter it, use the action field label 3 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 输入第二个数字，使用动作字段标签3 |'
- en: Observe that this new program execution needs to be resumed by using label 3,
    not 1. Indeed,
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请观察这个新的程序执行需要使用标签 3 来恢复，而不是 1。确实，
- en: '| > (resume 3 10) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 3 10) |'
- en: '| 15 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 15 |'
- en: But we ought to ask, what happens if we reuse label 2?Do Now!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们应该问，如果我们重复使用标签 2 会发生什么？现在做！
- en: Try (resume 2 10).
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试 (恢复 2 10)。
- en: 'Doing this is tantamount to resuming the old computation. We therefore expect
    it produce the same answer as before:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做等同于恢复旧的计算。因此，我们期望它产生与之前相同的答案：
- en: '| > (resume 2 10) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 2 10) |'
- en: '| 13 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 13 |'
- en: Now let’s create a stateful implementation. We can simulate this by observing
    that each closure has its own environment, but all closures share the same mutable
    state. We can simulate this using our existing read-number/suspend by making sure
    we don’t rely on the closure behavior of lambda, i.e., by not having any free
    identifiers in the body.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个有状态的实现。我们可以通过观察到每个闭包都有自己的环境，但所有闭包共享相同的可变状态来模拟这一点。我们可以通过确保我们不依赖于 lambda
    的闭包行为来模拟这一点，即，通过不在主体中具有任何自由标识符。
- en: '| (define cookie ''-100) |'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define cookie ''-100) |'
- en: '|   |'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (read-number/suspend "First number" |'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (read-number/suspend "第一个数字" |'
- en: '|                      (lambda (v1) |'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (lambda (v1) |'
- en: '|                        (begin |'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (begin |'
- en: '|                          (set! cookie v1) |'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                          (set! cookie v1) |'
- en: '|                          (read-number/suspend "Second number" |'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                          (read-number/suspend "第二个数字" |'
- en: '|                                             (lambda (v2) |'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                             (lambda (v2) |'
- en: '|                                               (display |'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                               (display |'
- en: '|                                                (+ cookie v2))))))) |'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                                (+ cookie v2))))))) |'
- en: Exercise
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: What do we expect for the same sequence as before?
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们对相同的序列有什么期望？
- en: Do Now!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: What happens?
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'Initially, nothing seems different:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，似乎没有什么不同：
- en: '| First number To enter it, use the action field label 1 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 第一个数字 要输入它，请使用动作字段标签 1 |'
- en: '| > (resume 1 3) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 1 3) |'
- en: '| Second number To enter it, use the action field label 2 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 第二个数字 要输入它，请使用动作字段标签 2 |'
- en: '| > (resume 2 10) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 2 10) |'
- en: '| 13 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 13 |'
- en: 'When we reuse the initial computation, we indeed get a new resumption label:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重用初始计算时，我们确实得到一个新的恢复标签：
- en: '| > (resume 1 5) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 1 5) |'
- en: '| Second number To enter it, use the action field label 3 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 第二个数字 要输入它，请使用动作字段标签 3 |'
- en: 'which, when used, computes what we’d expect:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时计算我们预期的内容：
- en: '| > (resume 3 10) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 3 10) |'
- en: '| 15 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 15 |'
- en: 'Now we come to the critical step:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到关键步骤：
- en: '| > (resume 2 10) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| > (恢复 2 10) |'
- en: '| 15 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 15 |'
- en: It is unsurprising that the two resumptions of label 2 would produce different
    answers, given that they rely on mutable state. The reason it’s problematic is
    because of what happens when we translate the same behavior to the Web.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于它们依赖于可变状态，标签 2 的两次恢复产生不同的答案并不奇怪。问题所在是当我们将相同的行为转换为 Web 时会发生什么。
- en: Imagine visiting a hotel reservation Web site and searching for hotels in a
    city. In return, you are shown a list of hotels and the label 1. You explore one
    of them in a new tab or window; this produces information on that hotel, and label
    2 to make the reservation. You decide, however, to return to the hotel listing
    and explore another hotel in a fresh tab or window. This produces the second hotel’s
    information, with label 3 to reserve at that hotel. You decide, however, to choose
    the first hotel, return to the first hotel’s page, and choose its reservation
    button—<wbr>i.e., submit label 2. Which hotel did you expect to be booked into?
    Though you expected a reservation at the first hotel, on most travel sites, this
    will either reserve at the second hotel—<wbr>i.e., the one you last viewed, but
    not the one on the page whose reservation button you clicked—<wbr>or produce an
    error. This is because of the pervasive use of cookies on Web sites, a practice
    encouraged by most Web APIs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下访问酒店预订网站并搜索城市中的酒店。作为回报，您将看到酒店列表和标签 1。您在新的标签页或窗口中探索其中一个酒店；这将产生有关该酒店的信息，并提供标签
    2 以进行预订。但是，您决定返回酒店列表，并在新的标签页或窗口中探索另一个酒店。这将产生第二家酒店的信息，带有标签 3 以在该酒店预订。但是，您决定选择第一家酒店，返回第一家酒店的页面，并选择其预订按钮——即，提交标签
    2。您希望预订哪家酒店？尽管您期望在第一家酒店预订，但在大多数旅行网站上，这将预订第二家酒店——即，您最后查看的那家，而不是您单击其预订按钮的页面上的酒店——或者产生错误。这是因为网站普遍使用
    Cookie，这是大多数 Web API 鼓励的做法。
- en: 14.2Continuation-Passing Style
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 过程传递样式
- en: 'The functions we’ve been writing have a name. Though we’ve presented ideas
    in terms of the Web, we’re relying on a much older idea: the functions are called
    continuations, and this style of programs is called continuation-passing style
    (CPS).We will take the liberty of using CPS as both a noun and verb: a particular
    structure of code and the process that converts code into it. This is worth studying
    in its own right, because it is the basis for studying a variety of other non-trivial
    control operations—<wbr>such as generators.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的函数有一个名字。虽然我们以 Web 为基础呈现了这些思想，但我们依赖的是一个更古老的想法：这些函数被称为 continuations，并且这种程序的风格被称为
    continuation-passing style（CPS）。我们将自由地将 CPS 用作名词和动词：一种特定的代码结构和将代码转换为它的过程。这值得单独研究，因为它是研究各种其他非平凡控制操作的基础，比如生成器。
- en: 'Earlier, we converted programs so that no Web input operation was nested inside
    another. The motivation was simple: when the program terminates, all nested computations
    are lost. A similar argument applies, in a more local sense, in the case of XMLHttpRequest:
    any computation depending on the result of a response from a Web server needs
    to reside in the callback associated with the request to the server.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 早先，我们将程序转换成这样一个形式，其中没有 Web 输入操作嵌套在另一个内部。动机很简单：当程序终止时，所有嵌套的计算都会丢失。类似的论点在 XMLHttpRequest
    的情况下也适用，从更局部的角度来看，任何依赖于从 Web 服务器的响应中获得的结果的计算都需要驻留在与向服务器发出请求相关联的回调中。
- en: In fact, we don’t need to transform every expression. We only care about expressions
    that involve actual Web interaction. For example, if we computed a more complex
    mathematical expression than just addition, we wouldn’t need to transform it.
    If, however, we had a function call, we’d either have to be absolutely certain
    the function didn’t have any Web invocations either inside it, or in the functions
    in invokes, or the ones they invoke...or else, to be defensive, we should transform
    them all. Therefore, we have to transform every expression that we can’t be sure
    performs no Web interactions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要转换每一个表达式。我们只关心涉及实际 Web 交互的表达式。例如，如果我们计算的是比简单的加法更复杂的数学表达式，我们就不需要转换它。但是，如果我们有一个函数调用，我们要么必须确信该函数内部没有任何
    Web 调用，要么在它调用的函数中，或者它们调用的函数中也没有，否则，为了防御性，我们应该将它们全部转换。因此，我们必须转换每一个我们不能确定不执行 Web
    交互的表达式。
- en: The heart of our transformation is therefore to turn every one-argument function,
    f, into one with an extra argument. This extra argument is the continuation, which
    represents the rest of the computation. The continuation is itself a function
    of one argument. This argument takes the value that would have been returned by
    f and passes it to the rest of the computation. f, instead of returning a value,
    instead passes the value it would have returned to its continuation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们转换的核心是将每个单参数函数 f 转换为一个带有额外参数的函数。这个额外参数是 continuation，它代表了剩余的计算过程。continuation
    本身是一个带有一个参数的函数。这个参数取决于 f 将返回的值，并将其传递给剩余的计算过程。f 不是返回一个值，而是将它将要返回的值传递给它的 continuation。
- en: 'CPS is a general transformation, which we can apply to any program. Because
    it’s a program transformation, we can think of it as a special kind of desugaring:
    in particular, instead of transforming programs from a larger language to a smaller
    one (as macros do), or from one language to entirely another (as compilers do),
    it transforms programs within the same language: from the full language to a more
    restricted version that obeys the pattern we’ve been discussing. As a result,
    we can reuse an evaluator for the full language to also evaluate programs in the
    CPS subset.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: CPS 是一种通用的转换，我们可以将其应用到任何程序中。因为它是一个程序转换，我们可以将其看作是一种特殊的 desugaring：特别是，它不是将程序从一个更大的语言转换为一个更小的语言（如宏所做的），也不是从一种语言转换为另一种完全不同的语言（如编译器所做的），而是将程序转换到同一种语言中：从完整的语言转换为一个更受限制的版本，它遵循我们一直在讨论的模式。因此，我们可以重用用于完整语言的评估器来评估
    CPS 子集中的程序。
- en: 14.2.1Implementation by Desugaring
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1通过 desugaring 实现
- en: 'Because we already have good support for desguaring, let’s use to define the
    CPS transform. Concretely, we’ll implement a CPS macro [REF]. To more cleanly
    separate the source language from the target, we’ll use slightly different names
    for most of the language constructs: a one-armed with and rec instead of let and
    letrec; lam instead of lambda; cnd instead of if; seq for begin; and set for set!.
    We’ll also give ourselves a sufficiently rich language to write some interesting
    programs!The presentation that follows orders the cases of the macro from what
    I believe are easiest to hardest. However, the code in the macro must avoid non-overlapping
    patterns, and hence follows a diffent order.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经很好地支持了解糖，让我们使用它来定义 CPS 转换。具体来说，我们将实现一个 CPS 宏[REF]。为了更清晰地将源语言与目标语言分开，我们将为大多数语言构造使用略有不同的名称：一个臂状的
    with 和 rec 代替 let 和 letrec；lam 代替 lambda；cnd 代替 if；seq 代替 begin；set 代替 set!。我们还将给自己一个足够丰富的语言来编写一些有趣的程序！接下来的演示按照我认为从简单到困难的宏案例排序。然而，宏中的代码必须避免不重叠的模式，因此遵循不同的顺序。
- en: '[<cps-macro>](#(elem._(chunk._~3ccps-macro~3e~3a1))) ::='
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro>](#(elem._(chunk._~3ccps-macro~3e~3a1))) ::='
- en: '| (define-syntax (cps e) |'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (cps e) |'
- en: '|   (syntax-case e (with rec lam cnd seq set quote display read-number) |'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case e (with rec lam cnd seq set quote display read-number) |'
- en: '|     [<cps-macro-with-case>](#(elem._(chunk._~3ccps-macro-with-case~3e~3a1)))
    |'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-with-case>](#(elem._(chunk._~3ccps-macro-with-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-rec-case>](#(elem._(chunk._~3ccps-macro-rec-case~3e~3a1)))
    |'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-rec-case>](#(elem._(chunk._~3ccps-macro-rec-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-lam-case>](#(elem._(chunk._~3ccps-macro-lam-case~3e~3a1)))
    |'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-lam-case>](#(elem._(chunk._~3ccps-macro-lam-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-cnd-case>](#(elem._(chunk._~3ccps-macro-cnd-case~3e~3a1)))
    |'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-cnd-case>](#(elem._(chunk._~3ccps-macro-cnd-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-display-case>](#(elem._(chunk._~3ccps-macro-display-case~3e~3a1)))
    |'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-display-case>](#(elem._(chunk._~3ccps-macro-display-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-read-number-case>](#(elem._(chunk._~3ccps-macro-read-number-case~3e~3a1)))
    |'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-read-number-case>](#(elem._(chunk._~3ccps-macro-read-number-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-seq-case>](#(elem._(chunk._~3ccps-macro-seq-case~3e~3a1)))
    |'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-seq-case>](#(elem._(chunk._~3ccps-macro-seq-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-set-case>](#(elem._(chunk._~3ccps-macro-set-case~3e~3a1)))
    |'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-set-case>](#(elem._(chunk._~3ccps-macro-set-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-quote-case>](#(elem._(chunk._~3ccps-macro-quote-case~3e~3a1)))
    |'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-quote-case>](#(elem._(chunk._~3ccps-macro-quote-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-app-1-case>](#(elem._(chunk._~3ccps-macro-app-1-case~3e~3a1)))
    |'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-app-1-case>](#(elem._(chunk._~3ccps-macro-app-1-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-app-2-case>](#(elem._(chunk._~3ccps-macro-app-2-case~3e~3a1)))
    |'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-app-2-case>](#(elem._(chunk._~3ccps-macro-app-2-case~3e~3a1)))
    |'
- en: '|     [<cps-macro-atomic-case>](#(elem._(chunk._~3ccps-macro-atomic-case~3e~3a1)))))
    |'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<cps-macro-atomic-case>](#(elem._(chunk._~3ccps-macro-atomic-case~3e~3a1)))))
    |'
- en: Our representation in CPS will be to turn every expression into a procedure
    of one argument, the continuation. The converted expression will eventually either
    supply a value to the continuation or will pass the continuation on to some other
    expression that will—<wbr>by preserving this invariant inductively—<wbr>supply
    it with a value. Thus, all output from CPS will look like (lambda (k) ...) (and
    we will rely on hygiene [REF] to keep all these introduced k’s from clashing with
    one another).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 CPS 中的表示将是将每个表达式转换为一个带有一个参数（续集）的过程。转换后的表达式最终将向续集提供一个值，或者将续集传递给将会——通过保持这个不变性的归纳——向其提供一个值的其他表达式。因此，CPS
    的所有输出看起来都像 (lambda (k) ...)（我们将依赖卫生性[REF]来防止所有这些引入的 k 互相冲突）。
- en: 'First let’s dispatch with the easy case, which is atomic values. Though conceptually
    easiest, we have written this last because otherwise this pattern would shadow
    all the other cases. (Ideally, we should have written it first and provided a
    guard expression that precisely defines the syntactic cases we want to treat as
    atomic. We’re playing loose here becuase our focus is on more interesting cases.)
    In the atomic case, we already have a value, so we simply need to supply it to
    the continuation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理最简单的情况，即原子值。尽管在概念上最简单，但我们将其放在最后编写，否则此模式将掩盖所有其他情况。（理想情况下，我们应该首先编写它，并提供一个精确定义我们要将其视为原子的语法情况的保护表达式。我们在这里玩得很随意，因为我们的重点是更有趣的情况。）在原子情况下，我们已经有一个值，所以我们只需将其提供给续集：
- en: '[<cps-macro-atomic-case>](#(elem._(chunk._~3ccps-macro-atomic-case~3e~3a1)))
    ::='
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-atomic-case>](#(elem._(chunk._~3ccps-macro-atomic-case~3e~3a1)))
    ::='
- en: '| [(_ atomic) |'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ atomic) |'
- en: '|  #''(lambda (k) |'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      (k atomic))] |'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (k atomic))] |'
- en: 'Similarly for quoted constants:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于引用的常量：
- en: '[<cps-macro-quote-case>](#(elem._(chunk._~3ccps-macro-quote-case~3e~3a1)))
    ::='
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-quote-case>](#(elem._(chunk._~3ccps-macro-quote-case~3e~3a1)))
    ::='
- en: '| [(_ ''e) |'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ ''e) |'
- en: '|  #''(lambda (k) (k ''e))] |'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) (k ''e))] |'
- en: 'Also, we already know, from [REF] and [REF], that we can treat with and rec
    as macros, respectively:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经知道，从 [REF] 和 [REF]，我们可以分别将 with 和 rec 视为宏：
- en: '[<cps-macro-with-case>](#(elem._(chunk._~3ccps-macro-with-case~3e~3a1))) ::='
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-with-case>](#(elem._(chunk._~3ccps-macro-with-case~3e~3a1))) ::='
- en: '| [(_ (with (v e) b)) |'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (with (v e) b)) |'
- en: '|  #''(cps ((lam (v) b) e))] |'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(cps ((lam (v) b) e))] |'
- en: '[<cps-macro-rec-case>](#(elem._(chunk._~3ccps-macro-rec-case~3e~3a1))) ::='
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-rec-case>](#(elem._(chunk._~3ccps-macro-rec-case~3e~3a1))) ::='
- en: '| [(_ (rec (v f) b)) |'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (rec (v f) b)) |'
- en: '|  #''(cps (with (v (lam (arg) (error ''dummy "nothing"))) |'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(cps (with (v (lam (arg) (error ''dummy "nothing"))) |'
- en: '|               (seq |'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (seq |'
- en: '|                (set v f) |'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (set v f) |'
- en: '|                b)))] |'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                b)))] |'
- en: 'Mutation is easy: we have to evaluate the new value, and then perform the actual
    update:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 变异很容易：我们必须评估新值，然后执行实际的更新：
- en: '[<cps-macro-set-case>](#(elem._(chunk._~3ccps-macro-set-case~3e~3a1))) ::='
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-set-case>](#(elem._(chunk._~3ccps-macro-set-case~3e~3a1))) ::='
- en: '| [(_ (set v e)) |'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (set v e)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps e) (lambda (ev) |'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps e) (lambda (ev) |'
- en: '|                 (k (set! v ev)))))] |'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 (k (set! v ev)))))] |'
- en: 'Sequencing is also straightforward: we perform each operation in turn. Observe
    how this preserves the semantics of sequencing: not only does it obey the order
    of operations, the value of the first sub-term (e1) is not mentioned anywhere
    in the body of the second (e2), so the name given to the identifier holding its
    value is irrelevant.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序也很简单：我们依次执行每个操作。注意，这样保留了顺序语义：它不仅遵循操作顺序，而且第一个子项（e1）的值在第二个子项（e2）的正文中没有提到，因此保存其值的标识符的名称是无关紧要的。
- en: '[<cps-macro-seq-case>](#(elem._(chunk._~3ccps-macro-seq-case~3e~3a1))) ::='
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-seq-case>](#(elem._(chunk._~3ccps-macro-seq-case~3e~3a1))) ::='
- en: '| [(_ (seq e1 e2)) |'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (seq e1 e2)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps e1) (lambda (_) |'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps e1) (lambda (_) |'
- en: '|                  ((cps e2) k))))] |'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  ((cps e2) k))))] |'
- en: 'When handling conditionals, we need to create a new continuation to remember
    that we are waiting for the test expression to evaluate. Once we have its value,
    however, we can dispatch on the result and return to the existing continuations:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 处理条件时，我们需要创建一个新的延续来记住我们正在等待测试表达式的评估。然而，一旦我们有了它的值，我们就可以根据结果进行分派并返回到现有的延续：
- en: '[<cps-macro-cnd-case>](#(elem._(chunk._~3ccps-macro-cnd-case~3e~3a1))) ::='
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-cnd-case>](#(elem._(chunk._~3ccps-macro-cnd-case~3e~3a1))) ::='
- en: '| [(_ (cnd tst thn els)) |'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (cnd tst thn els)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps tst) (lambda (tstv) |'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps tst) (lambda (tstv) |'
- en: '|                   (if tstv |'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   (if tstv |'
- en: '|                       ((cps thn) k) |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       ((cps thn) k) |'
- en: '|                       ((cps els) k)))))] |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       ((cps els) k)))))] |'
- en: 'When we get to applications, we have two cases to consider. We absolutely need
    to handle the treatment of procedures created in the language: those with one
    argument. For the purposes of writing example programs, however, it is useful
    to be able to employ primitives such as + and *. Thus, we will assume for simplicity
    that one-argument procedures are written by the user, and hence need conversion
    to CPS, while two-argument ones are primitives that will not perform any Web or
    other control operations and hence can be invoked directly; we will also assume
    that the primitive will be written in-line (i.e., the application position will
    not be a complex expression that can itself, say, perform a Web interaction).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 处理应用程序时，我们有两种情况需要考虑。我们绝对需要处理语言中创建的过程的处理：带有一个参数的过程。然而，为了编写示例程序，能够使用诸如 + 和 * 之类的基本操作是很有用的。因此，我们将简单地假设用户编写了带一个参数的过程，因此需要将其转换为
    CPS，而带有两个参数的过程是不会执行任何 Web 或其他控制操作的原语，因此可以直接调用；我们还将假设原语将内联编写（即，应用位置不会是一个可以执行 Web
    交互的复杂表达式）。
- en: For an application we have to evaluate both the function and argument expressions.
    Once we’ve obtained these, we are ready to apply the function. Therefore, it is
    tempting to write
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序，我们必须评估函数和参数表达式。一旦我们获得了这些，我们就可以准备应用函数了。因此，很容易写成
- en: '[<cps-macro-app-1-case-take-1>](#(elem._(chunk._~3ccps-macro-app-1-case-take-1~3e~3a1)))
    ::='
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-app-1-case-take-1>](#(elem._(chunk._~3ccps-macro-app-1-case-take-1~3e~3a1)))
    ::='
- en: '| [(_ (f a)) |'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (f a)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps f) (lambda (fv) |'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps f) (lambda (fv) |'
- en: '|                 ((cps a) (lambda (av) |'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 ((cps a) (lambda (av) |'
- en: '|                            (k (fv av)))))))] |'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (k (fv av)))))))] |'
- en: Do Now!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做！
- en: Do you see why this is wrong?
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你明白这为什么是错误的吗？
- en: 'The problem is that, though the function is now a value, that value is a closure
    with a potentially complicated body: evaluating the body can, for example, result
    in further Web interactions, at which point the rest of the function’s body, as
    well as the pending (k ...) (i.e., the rest of the program), will all be lost.
    To avoid this, we have to supply k to the function’s value, and let the inductive
    invariant ensure that k will eventually be invoked with the value of applying
    fv to av:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，尽管函数现在是一个值，但该值是一个具有潜在复杂体的闭包：评估体可能导致进一步的 Web 交互，此时函数的其余部分体，以及待处理的 (k ...)（即程序的其余部分）都将丢失。为了避免这种情况，我们必须向函数的值提供
    k，并让归纳不变量确保 k 最终将被调用，其值为将 fv 应用于 av 的结果：
- en: '[<cps-macro-app-1-case>](#(elem._(chunk._~3ccps-macro-app-1-case~3e~3a1)))
    ::='
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-app-1-case>](#(elem._(chunk._~3ccps-macro-app-1-case~3e~3a1)))
    ::='
- en: '| [(_ (f a)) |'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (f a)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps f) (lambda (fv) |'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps f) (lambda (fv) |'
- en: '|                 ((cps a) (lambda (av) |'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 ((cps a) (lambda (av) |'
- en: '|                            (fv av k))))))] |'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (fv av k))))))] |'
- en: 'Treating the special case of built-in binary operations is easier:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 处理内置二元操作的特殊情况更容易：
- en: '[<cps-macro-app-2-case>](#(elem._(chunk._~3ccps-macro-app-2-case~3e~3a1)))
    ::='
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-app-2-case>](#(elem._(chunk._~3ccps-macro-app-2-case~3e~3a1)))
    ::='
- en: '| [(_ (f a b)) |'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (f a b)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps a) (lambda (av) |'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps a) (lambda (av) |'
- en: '|                 ((cps b) (lambda (bv) |'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 ((cps b) (lambda (bv) |'
- en: '|                            (k (f av bv)))))))] |'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (k (f av bv)))))))] |'
- en: The very pattern we could not use for user-defined procedures we employ here,
    because we assume that the application of f will always return without any unusual
    transfers of control.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了我们无法用于用户定义���程的模式，因为我们假设 f 的应用总是会在没有任何异常控制转移的情况下返回。
- en: 'A function is itself a value, so it should be returned to the pending computation.
    The application case above, however, shows that we have to transform functions
    to take an extra argument, namely the continuation at the point of invocation.
    This leaves us with a quandary: which continuation do we supply to the body?'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身是一个值，因此应该返回给待处理的计算。然而，上面的应用情况显示，我们必须将函数转换为接受额外参数的形式，即在调用点处的延续。这让我们陷入了困境：我们应该向体提供哪个延续？
- en: '[<cps-macro-lam-case-take-1>](#(elem._(chunk._~3ccps-macro-lam-case-take-1~3e~3a1)))
    ::='
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-lam-case-take-1>](#(elem._(chunk._~3ccps-macro-lam-case-take-1~3e~3a1)))
    ::='
- en: '| [(_ (lam (a) b)) |'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (lam (a) b)) |'
- en: '|  (identifier? #''a) |'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (identifier? #''a) |'
- en: '|  #''(lambda (k) |'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      (k (lambda (a dyn-k) |'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (k (lambda (a dyn-k) |'
- en: '|           ((cps b) ...))))] |'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           ((cps b) ...))))] |'
- en: 'That is, in place of ..., which continuation do we supply: k or dyn-k?'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在...的位置，我们应该提供哪个延续：k 还是 dyn-k？
- en: Do Now!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做！
- en: Which continuation should we supply?
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们应该提供哪个延续？
- en: 'The former is the continuation at the point of closure creation. The latter
    is the continuation at the point of closure invocation. In other words, the former
    is “static” and the latter is “dynamic”. In this case, we need to use the dynamic
    continuation, otherwise something very strange would happen: the program would
    return to the point where the closure was created, rather than where it is being
    used! This would result in seemingly very strange program behavior, so we wish
    to avoid it. Observe that we are consciously choosing the dynamic continuation
    just as, where scope was concerned, we chose the static environment.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前者是在闭包创建时的延续。后者是在闭包调用时的延续。换句话说，前者是“静态的”，后者是“动态的”。在这种情况下，我们需要使用动态延续，否则会发生非常奇怪的事情：程序会返回到创建闭包的地方，而不是使用它的地方！这将导致看似非常奇怪的程序行为，所以我们希望避免这种情况。请注意，我们在这里有意选择动态延续，就像在处理作用域时选择静态环境一样。
- en: '[<cps-macro-lam-case>](#(elem._(chunk._~3ccps-macro-lam-case~3e~3a1))) ::='
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-lam-case>](#(elem._(chunk._~3ccps-macro-lam-case~3e~3a1))) ::='
- en: '| [(_ (lam (a) b)) |'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (lam (a) b)) |'
- en: '|  (identifier? #''a) |'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (identifier? #''a) |'
- en: '|  #''(lambda (k) |'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      (k (lambda (a dyn-k) |'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (k (lambda (a dyn-k) |'
- en: '|           ((cps b) dyn-k))))] |'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           ((cps b) dyn-k))))] |'
- en: 'Finally, for the purpose of modeling Web programming, we can add our input
    and output procedures. Output follows the application pattern we’ve already seen:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了模拟 Web 编程，我们可以添加我们的输入和输出过程。输出遵循我们已经看到的应用模式：
- en: '[<cps-macro-display-case>](#(elem._(chunk._~3ccps-macro-display-case~3e~3a1)))
    ::='
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-display-case>](#(elem._(chunk._~3ccps-macro-display-case~3e~3a1)))
    ::='
- en: '| [(_ (display output)) |'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (display output)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps output) (lambda (ov) |'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps output) (lambda (ov) |'
- en: '|                      (k (display ov)))))] |'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (k (display ov)))))] |'
- en: 'Finally, for input, we can use the pre-existing read-number/suspend, but this
    time generate its uses rather than force the programmer to construct them:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于输入，我们可以使用预先存在的read-number/suspend，但这次生成其用途而不是强制程序员构建它们：
- en: '[<cps-macro-read-number-case>](#(elem._(chunk._~3ccps-macro-read-number-case~3e~3a1)))
    ::='
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-read-number-case>](#(elem._(chunk._~3ccps-macro-read-number-case~3e~3a1)))
    ::='
- en: '| [(_ (read-number prompt)) |'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (read-number prompt)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps prompt) (lambda (pv) |'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps prompt) (lambda (pv) |'
- en: '|                      (read-number/suspend pv k))))] |'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (read-number/suspend pv k))))] |'
- en: Notice that the continuation bound to k is precisely the continuation that we
    need to stash at the point of a Web interaction.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，绑定到k的延续恰好是我们需要在Web交互点存储的延续。
- en: 'Testing any code converted to CPS is slightly annoying because all CPS terms
    expect a continuation. The initial continuation is one that simply either (a)
    consumes a value and returns it, or (b) consumes a value and prints it, or (c)
    consumes a value, prints it, and gets ready for another computation (as the prompt
    in the DrRacket Interactions window does). All three of these are effectively
    just the identity function in various guises. Thus, the following definition is
    helpful for testing:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试转换为CPS的任何代码都稍微麻烦，因为所有CPS术语都期望延续。初始延续是一个简单地（a）消耗一个值并返回它，或者（b）消耗一个值并打印它，或者（c）消耗一个值，打印它，并准备好另一个计算（如DrRacket交互窗口中的提示）。这三者实际上都只是不同形式的恒等函数。因此，以下定义对于测试非常有帮助：
- en: '| (define (run c) (c identity)) |'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (run c) (c identity)) |'
- en: For instance,
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '| (test (run (cps 3))                           3) |'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps 3))                           3) |'
- en: '| (test (run (cps ((lam ()    5)       )))      5) |'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps ((lam ()    5)       )))      5) |'
- en: '| (test (run (cps ((lam (x)   (* x x)) 5)))     25) |'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps ((lam (x)   (* x x)) 5)))     25) |'
- en: '| (test (run (cps (+ 5 ((lam (x) (* x x)) 5)))) 30) |'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps (+ 5 ((lam (x) (* x x)) 5)))) 30) |'
- en: 'We can also test our old Web program:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以测试我们的旧网络程序：
- en: '| (run (cps (display (+ (read-number "First") |'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (run (cps (display (+ (read-number "First") |'
- en: '|                       (read-number "Second"))))) |'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (read-number "Second"))))) |'
- en: 'Lest you get lost in the myriad of code, let me highlight the important lesson
    here: We’ve recovered our code structure. That is, we can write the program in
    direct style, with properly nested expressions, and a compiler—<wbr>in this case,
    the CPS converter—<wbr>takes care of making it work with a suitable underlying
    API. This is what good programming languages ought to do!'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以免您在代码的海洋中迷失，让我强调这里的重要教训：我们恢复了我们的代码结构。也就是说，我们可以用直接的方式编写程序，使用正确的嵌套表达式，并且编译器——在这种情况下，CPS转换器——负责使其与合适的底层API配合工作。这才是良好的编程语言应该做的！
- en: 14.2.2Converting the Example
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 转换示例
- en: 'Let’s consider the example above and see what it converts to. You can either
    do this by hand, or take the easy way out and employ the Macro Stepper of DrRacket.For
    now, you need to put the code in #lang racket to get the full force of the Macro
    Stepper. Assuming we include the application to identity contained in run, we
    get:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑上面的例子并看看它转换成了什么。您可以手工进行此操作，也可以采用DrRacket的宏调试器的简便方法。目前，您需要将代码放在#lang racket中，以充分利用宏调试器的功能。假设我们包含在run中包含的对identity的应用，我们得到：
- en: '| (lambda (k) |'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (lambda (k) |'
- en: '|   ((lambda (k) |'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ((lambda (k) |'
- en: '|      ((lambda (k) |'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((lambda (k) |'
- en: '|         ((lambda (k) |'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         ((lambda (k) |'
- en: '|            (k "First")) (lambda (pv) |'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (k "First")) (lambda (pv) |'
- en: '|                           (read-number/suspend pv k)))) |'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                           (read-number/suspend pv k)))) |'
- en: '|       (lambda (lv) |'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (lambda (lv) |'
- en: '|         ((lambda (k) |'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         ((lambda (k) |'
- en: '|            ((lambda (k) |'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            ((lambda (k) |'
- en: '|               (k "Second")) (lambda (pv) |'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (k "Second")) (lambda (pv) |'
- en: '|                               (read-number/suspend pv k)))) |'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                               (read-number/suspend pv k)))) |'
- en: '|          (lambda (rv) |'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (lambda (rv) |'
- en: '|            (k (+ lv rv))))))) |'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (k (+ lv rv))))))) |'
- en: '|    (lambda (ov) |'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    (lambda (ov) |'
- en: '|      (k (display ov))))) |'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (k (display ov))))) |'
- en: What! This isn’t at all the version we wrote by hand!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 什么！这根本不是我们手工编写的版本！
- en: In fact, this program is full of so-called administrative lambdas that were
    introduced by the particular CPS algorithm we used.Designing better CPS algorithms,
    that eliminate needless administrative lambdas, is therefore an ongoing and open
    research question. Fear not! If we stepwise apply each of these lambdas and substitute,
    however—<wbr>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个程序充满了所谓的管理lambda，这些lambda是由我们使用的特定CPS算法引入的。设计更好的CPS算法，消除不必要的管理lambda，因此是一个持续且开放的研究问题。不用担心！如果我们逐步应用这些lambda并替换，然而—<wbr>
- en: Do Now!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做！
- en: Do it!
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 去做吧！
- en: —<wbr>the program reduces to
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: —<wbr>程序会简化为
- en: '| (read-number/suspend "First" |'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (read-number/suspend "First" |'
- en: '|                      (lambda (lv) |'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (lambda (lv) |'
- en: '|                        (read-number/suspend "Second" |'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (read-number/suspend "Second" |'
- en: '|                                             (lambda (rv) |'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                             (lambda (rv) |'
- en: '|                                               (identity |'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                               (identity |'
- en: '|                                                (display (+ lv rv))))))) |'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                                (display (+ lv rv))))))) |'
- en: which is precisely what we wanted.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的。
- en: 14.2.3Implementation in the Core
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3核心实现
- en: Now that we’ve seen how CPS can be implemented through desguaring, we should
    ask whether it can be put in the core instead.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到CPS如何通过desguaring实现，���们应该问问它是否可以放在核心中。
- en: 'Recall that we’ve said that CPS applies to all programs. We have one program
    we are especially interested in: the interpreter. Sure enough, we can apply the
    CPS transformation to it, making available what are effectively the same continuations.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们曾说过CPS适用于所有程序。我们对一个程序特别感兴趣：解释器。果不其然，我们可以对其应用CPS转换，从而提供实际上是相同的延续。
- en: 'First, we’ll find it convenient to use a procedural representation of closures
    [REF]. We’ll have the interpreter take an extra argument, which consumes values
    (those given to the continuation) and eventually returns them:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们会发现使用过程式闭包表示会更方便[REF]。我们将让解释器接受一个额外的参数，该参数消耗值（传递给延续的值）并最终返回它们：
- en: '[<cps-interp>](#(elem._(chunk._~3ccps-interp~3e~3a1))) ::='
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-interp>](#(elem._(chunk._~3ccps-interp~3e~3a1))) ::='
- en: '| (define (interp/k [expr : ExprC] [env : Env] [k : (Value -> Value)]) : Value
    |'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (interp/k [expr : ExprC] [env : Env] [k : (Value -> Value)]) : Value
    |'
- en: '|   [<cps-interp-body>](#(elem._(chunk._~3ccps-interp-body~3e~3a1)))) |'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<cps-interp-body>](#(elem._(chunk._~3ccps-interp-body~3e~3a1)))) |'
- en: 'In the easy cases, instead of returning a value we need to simply pass it to
    the continuation argument:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单情况下，我们不需要返回一个值，而只需将其传递给延续参数：
- en: '[<cps-interp-body>](#(elem._(chunk._~3ccps-interp-body~3e~3a1))) ::='
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-interp-body>](#(elem._(chunk._~3ccps-interp-body~3e~3a1))) ::='
- en: '| (type-case ExprC expr |'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (type-case ExprC expr |'
- en: '|   [numC (n) (k (numV n))] |'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numC (n) (k (numV n))] |'
- en: '|   [idC (n) (k (lookup n env))] |'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [idC (n) (k (lookup n env))] |'
- en: '|   [<cps-interp-plusC-case>](#(elem._(chunk._~3ccps-interp-plus.C-case~3e~3a1)))
    |'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<cps-interp-plusC-case>](#(elem._(chunk._~3ccps-interp-plus.C-case~3e~3a1)))
    |'
- en: '|   [<cps-interp-appC-case>](#(elem._(chunk._~3ccps-interp-app.C-case~3e~3a1)))
    |'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<cps-interp-appC-case>](#(elem._(chunk._~3ccps-interp-app.C-case~3e~3a1)))
    |'
- en: '|   [<cps-interp-lamC-case>](#(elem._(chunk._~3ccps-interp-lam.C-case~3e~3a1))))
    |'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<cps-interp-lamC-case>](#(elem._(chunk._~3ccps-interp-lam.C-case~3e~3a1))))
    |'
- en: (Note that multC is handled entirely analogous to plusC.)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，multC的处理方式与plusC完全类似。）
- en: 'Let’s start with the easy case, plusC. First we interpret the left sub-expression.
    The continuation for this evaluation interprets the right sub-expression. The
    continuation for that adds the result. What should happen to the result of addition?
    In interp, it was returned to whichever computation caused the plusC to be interpreted.
    Now, remember, we no longer return values; instead we pass them to the continuation:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单情况开始，即plusC。首先解释左子表达式。这个评估的延续解释右子表达式。为此添加结果的延续。加法的结果应该怎么处理？在interp中，它被返回给导致plusC被解释的任何计算。现在，请记住，我们不再返回值；而是将它们传递给延续：
- en: '[<cps-interp-plusC-case>](#(elem._(chunk._~3ccps-interp-plus.C-case~3e~3a1)))
    ::='
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-interp-plusC-case>](#(elem._(chunk._~3ccps-interp-plus.C-case~3e~3a1)))
    ::='
- en: '| [plusC (l r) (interp/k l env |'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [plusC (l r) (interp/k l env |'
- en: '|                        (lambda (lv) |'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (lambda (lv) |'
- en: '|                          (interp/k r env |'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                          (interp/k r env |'
- en: '|                                    (lambda (rv) |'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                    (lambda (rv) |'
- en: '|                                      (k (num+ lv rv))))))] |'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                      (k (num+ lv rv))))))] |'
- en: Exercise
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Implement the code for multC.
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现multC的代码。
- en: This leaves the two difficult, and related, pieces.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了两个困难且相关的部分。
- en: 'In an application, we again have to interpret the two sub-expressions, and
    then apply the resulting closure to the argument. But we’ve already agreed that
    every application needs a continuation argument. Therefore, we have to update
    our definition of a value:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-type Value |'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [numV (n : number)] |'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [closV (f : (Value (Value -> Value) -> Value))]) |'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Now we have to decide what continuation to pass. In an application, it’s the
    continuation given to the interpreter:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-interp-appC-case>](#(elem._(chunk._~3ccps-interp-app.C-case~3e~3a1)))
    ::='
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '| [appC (f a) (interp/k f env |'
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       (lambda (fv) |'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (interp/k a env |'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                   (lambda (av) |'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                     ((closV-f fv) av k)))))] |'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Finally, the lamC case. We have to create a closV using a lambda, as before.
    However, this procedure needs to take two arguments: the actual value of the argument,
    and the continuation of the application. The critical question is, what is this
    latter value?'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'We have essentially two choices. k represents the static continuation: the
    one active at the point of closure construction. However, what we want is the
    continuation at the point of closure invocation: the dynamic continuation.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-interp-lamC-case>](#(elem._(chunk._~3ccps-interp-lam.C-case~3e~3a1)))
    ::='
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '| [lamC (a b) (k (closV (lambda (arg-val dyn-k) |'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (interp/k b |'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                   (extend-env (bind a arg-val) |'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                               env) |'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                   dyn-k))))] |'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'To test this revised interpreter, we need to invoke interp/k with some kind
    of initial continuation value. This needs to be a procedure that represents nothing
    remaining in the computation. A natural representation for this is the identity
    function:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (interp [expr : ExprC]) : Value |'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (interp/k expr mt-env |'
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (lambda (ans) |'
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               ans))) |'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: To signify that this is strictly a top-level interface to interp/k, we’ve dropped
    the environment parameter and pass the empty environment automatically. If we
    want to be especially sure we haven’t accidentally used this procedure recursively,
    we could insert a call to error at its end to prevent it from returning and its
    return value being used.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 14.3Generators
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many programming languages now have a notion of generators. A generator is like
    a procedure, in that one can invoke it in an application. Whereas a regular procedure
    always begins execution at the beginning, a generator resumes from where it last
    left off. Of course, that means a generator needs a notion of “exiting before
    it’s done”. This is known as yielding, namely returning control to whatever called
    it.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.1Design Variations
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many variations between generators. The points of variation, predictably,
    have to do with how to enter and exit a generator:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In some languages a generator is an object that is instantiated like any other
    object, and its execution is resumed by invoking a method (such as next in Python).
    In others it is just like a procedure, and indeed it is re-entered by applying
    it like a function.In languages where values in addition to regular procedures
    can be used in an application, all such values are collectively called applicables.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些语言中，生成器是实例化的对象，像任何其他对象一样，并且通过调用方法（例如 Python 中的 next）恢复其执行。在其他语言中，它就像一个过程一样，并且实际上是通过像函数一样应用它而重新进入的。在除了常规过程之外还可以在应用程序中使用值的语言中，所有这些值都被称为可应用的。
- en: In some languages the yielding operation—<wbr>such as Python’s yield—<wbr>is
    available only inside the syntactic body of the generator. In others, such as
    Racket, yield is an applicable value bound in the body, but by virtue of being
    a value, it can be passed to abstractions, stored in data structures, and so on.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些语言中，yielding 操作——比如 Python 的 yield——只能在生成器的句法主体内部使用。在其他语言中，如 Racket，yield
    是在主体中绑定的可应用值，但由于是值，它可以传递给抽象，存储在数据结构中等等。
- en: 'Python’s design represents an extreme point in that a generator is simply any
    function that contains the keyword yield in its body. In addition, Python’s yield
    cannot be passed as a parameter to another function that performs the yielding
    on behalf of the generator.There is also a small issue of naming. In many languages
    with generators, the yielder is automatically called word yield: either as a keyword
    (as in Python) or as an identifier bound to an applicable value (as in Racket).
    Another possibility is that the user of the generator must indicate in the generator
    expression what name to give the yielder.Curiously, Python expects users to determine
    what to call self or this in objects, but it does not provide the same flexibility
    for yield, because it has no other way to determine which functions are generators!
    That is, a use might look like'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的设计在于生成器只是任何包含关键字 yield 的函数。此外，Python 的 yield 不能作为参数传递给另一个代表生成器执行 yield
    的函数。还有一个小问题是命名。在许多具有生成器的语言中，yielder 自动称为 yield 单词：作为关键字（如 Python 中）或作为绑定到适用值的标识符（如
    Racket 中）。另一种可能性是生成器的使用者必须在生成器表达式中指示要给 yielder 什么名称。有趣的是，Python 期望用户确定在对象中调用 self
    或 this 的名称，但它不提供 yield 相同的灵活性，因为它没有其他方法来确定哪些函数是生成器！即，使用可能看起来像
- en: '| (generator (yield) (from) |'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (generator (yield) (from) |'
- en: '|            (rec (f (lam (n) |'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (rec (f (lam (n) |'
- en: '|                      (seq |'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (seq |'
- en: '|                        (yield n) |'
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (yield n) |'
- en: '|                        (f (+ n 1))))) |'
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (f (+ n 1))))) |'
- en: '|              (f from))) |'
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (f from))) |'
- en: but it might equivalently be
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 但它等价于
- en: '| (generator (y) (from) |'
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (generator (y) (from) |'
- en: '|            (rec (f (lam (n) |'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (rec (f (lam (n) |'
- en: '|                      (seq |'
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (seq |'
- en: '|                        (y n) |'
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (y n) |'
- en: '|                        (f (+ n 1))))) |'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (f (+ n 1))))) |'
- en: '|              (f from))) |'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (f from))) |'
- en: 'and if the yielder is an actual value, a user can also abstract over yielding:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 yielder 是一个实际值，用户还可以抽象出 yield：
- en: '| (generator (y) (from) |'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (generator (y) (from) |'
- en: '|            (rec (f (lam (n) |'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (rec (f (lam (n) |'
- en: '|                      (seq |'
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (seq |'
- en: '|                        ((yield-helper y) n) |'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        ((yield-helper y) n) |'
- en: '|                        (f (+ n 1))))) |'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (f (+ n 1))))) |'
- en: '|              (f from))) |'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (f from))) |'
- en: 'where yield-helper will presumably perform the actual yielding.There are actually
    two more design decisions:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 yield-helper 可能会执行实际的 yield。实际上还有两个设计决策：
- en: 'Is yield a statement or expression? In many languages it is actually an expression,
    meaning it has a value: the one supplied when resuming the generator. This makes
    the generator more flexible because the user of a generator can use the parameter(s)
    to alter the generator’s behavior, rather than being forced to use state to communicate
    desired changes.'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: yield 是语句还是表达式？在许多语言中，它实际上是一个表达式，意味着它有一个值：在恢复生成器时提供的值。这使得生成器更加灵活，因为生成器的使用者可以使用参数来改变生成器的行为，而不是被迫使用状态来传达所需的变化。
- en: What happens at the end of the generator’s execution? In many languages, a generator
    raises an exception to signal its completion.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器执行结束时会发生什么？在许多语言中，生成器会引发异常来表示其完成。
- en: 14.3.2Implementing Generators
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2实现生成器
- en: 'To implement generators, it will be especially useful to employ our CPS macro
    language. Let’s first decide where we stand regarding the above design decisions.
    We will use the applicative representation of generators: that is, asking for
    the next value from the generator is done by applying it to any necessary arguments.
    Similarly, the yielder will also be an applicable value and will in turn be an
    expression. Though we have already seen how macros can automatically capture a
    name [REF], let’s make the yielder’s name explicit to keep the macro simpler.
    Finally, we’ll raise an error when the generator is done executing.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: How do generators work? To yield, a generator must
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: remember where in its execution it currently is, and
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: know where in its caller it should return to.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: while, when invoked, it should
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: remember where in its execution its caller currently is, and
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: know where in its body it should return to.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observe the duality between invocation and yielding.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, these “where”s correspond to continuations.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build up the generator rule of the cps macro incrementally. First a header
    pattern:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[<cps-macro-generator-case>](#(elem._(chunk._~3ccps-macro-generator-case~3e~3a1)))
    ::='
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '| [(_ (generator (yield) (v) b)) |'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  (and (identifier? #''v) (identifier? #''yield)) |'
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  [<generator-body>](#(elem._(chunk._~3cgenerator-body~3e~3a1)))] |'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'The beginning of the body is easy: all code in CPS needs to consume a continuation,
    and because a generator is a value, this value should be supplied to the continuation:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[<generator-body>](#(elem._(chunk._~3cgenerator-body~3e~3a1))) ::='
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '| #''(lambda (k) |'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (k [<generator-value>](#(elem._(chunk._~3cgenerator-value~3e~3a1)))))
    |'
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Now we’re ready to tackle the heart of the generator.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that a generator is an applicable value. That means it can occur in
    an application position, and must therefore have the same “interface” as a procedure:
    a procedure of two arguments, the first a value and the second the continuation
    at the point of application. What should this procedure do? We’ve described just
    this above. First the generator must remember where the caller is in its execution,
    which is precisely the continuation at the point of application; “remember” here
    most simply means “must be stored in state”. Then, the generator should return
    to where it previously was, i.e., its own continuation, which must clearly have
    been stored. Therefore the core of the applicable value is:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[<generator-core>](#(elem._(chunk._~3cgenerator-core~3e~3a1))) ::='
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (v dyn-k) |'
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (begin |'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (set! where-to-go dyn-k) |'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (resumer v))) |'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Here, where-to-go records the continuation of the caller, to resume it upon
    yielding; resumer is the local continuation of the generator. Let’s think about
    what their initial values must be:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: where-to-go has no initial value (because the generator has yet to be invoked),
    so it needs to throw an error if ever used. Fortunately this error will never
    occur, because where-to-go is mutated on the first entry into the generator, so
    the error is just a safeguard against bugs in the implementation.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: where-to-go 没有初始值（因为生成器尚未被调用），所以如果被使用，它需要抛出一个错误。幸运的是，这个错误永远不会发生，因为 where-to-go
    在第一次进入生成器时被修改，所以错误只是针对实现中的错误的保护措施。
- en: Initially, the rest of the generator is the whole generator, so resumer should
    be bound to the (CPS of) b. What is its continuation? This is the continuation
    of the entire generator, i.e., what to do when the generator finishes. We’ve agreed
    that this should also signal an error (except in this case the error truly can
    occur, in case the generator is asked to produce more values than it’s equipped
    to).
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初，生成器的剩余部分是整个生成器，因此 resumer 应该绑定到（CPS of）b。它的 continuation 是什么？这是整个生成器的 continuation，即生成器完成时要执行的操作。我们已经同意，这也应该发出一个错误信号（除非在这种情况下错误确实可能发生，即生成器被要求产生的值超出了其装备的值）。
- en: 'We still need to bind yield. It is, as we’ve pointed out, symmetric to generator
    resumption: save the local continuation in resumer and return by applying where-to-go.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要绑定 yield。正如我们指出的，它对生成器的恢复是对称的：将本地 continuation 保存在 resumer 中，并通过应用 where-to-go
    进行返回。
- en: 'Putting together these pieces, we get:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些片段组合起来，我们得到：
- en: '[<generator-value>](#(elem._(chunk._~3cgenerator-value~3e~3a1))) ::='
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[<生成器值>](#(elem._(chunk._~3cgenerator-value~3e~3a1))) ::='
- en: '| (let ([where-to-go (lambda (v) (error ''where-to-go "nothing"))]) |'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([where-to-go (lambda (v) (error ''where-to-go "nothing"))]) |'
- en: '|   (letrec([resumer (lambda (v) |'
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (letrec([resumer (lambda (v) |'
- en: '|                      ((cps b) (lambda (k) |'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      ((cps b) (lambda (k) |'
- en: '|                                 (error ''generator "fell through"))))] |'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                 (error ''generator "fell through"))))] |'
- en: '|           [yield (lambda (v gen-k) |'
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           [yield (lambda (v gen-k) |'
- en: '|                    (begin |'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (begin |'
- en: '|                      (set! resumer gen-k) |'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (set! resumer gen-k) |'
- en: '|                      (where-to-go v)))]) |'
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (where-to-go v)))]) |'
- en: '|     [<generator-core>](#(elem._(chunk._~3cgenerator-core~3e~3a1))))) |'
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<生成器核心>](#(elem._(chunk._~3cgenerator-core~3e~3a1))))) |'
- en: Do Now!
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: Why this pattern of let and letrec instead of let?
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么要使用 let 和 letrec 的这种模式，而不是 let？
- en: Observe the dependencies between these code fragments. where-to-go doesn’t depend
    on either of resumer or yield. yield clearly depends on both where-to-go and resumer.
    But why are resumer and yield mutually referential?
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这些代码片段之间的依赖关系。where-to-go 不依赖于 resumer 或 yield 中的任何一个。yield 明显依赖于 where-to-go
    和 resumer。但是为什么 resumer 和 yield 互相引用？
- en: Do Now!
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: Try the alternative!
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试替代方案！
- en: The subtle dependency you may be missing is that resumer contains b, the body
    of the generator, which may contain references to yield. Therefore, it needs to
    be closed over the binding of the yielder.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会忽视的微妙依赖关系是，resumer 包含了 b，生成器的主体，它可能包含对 yield 的引用。因此，它需要对 yielder 的绑定进行闭包。
- en: Exercise
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: How do generators differ from coroutines and threads? Implement coroutines and
    threads using a similar strategy.
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成器与协程和线程有何不同？使用类似的策略实现协程和线程。
- en: 14.4Continuations and Stacks
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4续集与栈
- en: Surprising as it may seem, CPS conversion actually provides tremendous insight
    into the nature of the program execution stack. The first thing to understand
    is that every continuation is actually the stack itself. This might seem odd,
    given that stacks are low-level machine primitives while continuations are seemingly
    complex procedures. But what is the stack, really?
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能令人惊讶，但 CPS 转换实际上为程序执行栈的性质提供了巨大的见解。要理解的第一件事是，每个 continuation 实际上都是栈本身。这可能看起来有些奇怪，因为栈是低级别的机器原语，而
    continuation 看起来是复杂的过程。但是栈真的是什么？
- en: It’s a record of what remains to be done in the computation. So is the continuation.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是计算中剩下的工作的记录。继续也是如此。
- en: It’s traditionally thought of as a list of stack frames. That is, each frame
    has a reference to the frames remaining after it finishes. Similarly, each continuation
    is a small procedure that refers to—<wbr>and hence closes over—<wbr>its own continuation.
    If we had chosen a different representation for program instructions, combining
    this with the data structure representation of closures, we would obtain a continuation
    representation that is essentially the same as the machine stack.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   传统上它被认为是堆栈帧的列表。也就是说，每个框架都引用在其完成后剩余的框架。同样，每个继续是一个小过程，引用-<wbr>并因此闭合-<wbr>它自己的继续。如果我们选择了不同的程序指令表示法，将其与闭包的数据结构表示法结合，我们将获得一种基本与机器堆栈相同的继续表示。'
- en: Each stack frame also stores procedure parameters. This is implicitly managed
    by the procedural representation of continuations, whereas this was done explicitly
    in the data stucture representation (using bind).
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   每个堆栈帧还存储过程参数。这是通过继续的程序表示隐式管理的，而在数据结构表示中，这是通过明确使用bind来完成的。'
- en: Each frame also has space for “local variables”. In principle so does the continuation,
    though by using the macro implementation of local binding, we’ve effectively reduced
    everything to procedure parameters. Conceptually, however, some of these are “true”
    procedure parameters while others are local bindings turned into procedure parameters
    by a macro.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   每个框架还有“局部变量”的空间。原则上，继续也有，尽管通过使用局部绑定的宏实现，我们已经将一切有效地减少到了过程参数。然而，在概念上，其中一些是“真正”的过程参数，而其他一些是通过宏转换为过程参数的局部绑定。'
- en: The stack has references to, but does not close over, the heap. Thus changes
    to the heap are visible across stack frames. In precisely the same way, closures
    refer to, but do not close over, the store, so changes to the store are visible
    across closures.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   堆栈引用堆，但不闭合。因此，堆上的更改在堆栈帧之间可见。以完全相同的方式，闭包引用存储，但不关闭，因此对存储的更改在闭包之间可见。'
- en: 'Therefore, traditionally the stack is responsible for maintaining lexical scope,
    which we get automatically because we are using closures in a statically-scoped
    language.Now we can study the conversion of various terms to understand the mapping
    to stacks. For instance, consider the conversion of a function application [REF]:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '-   因此，传统上堆栈负责维护词法作用域，这是自动获得的，因为我们在静态作用域语言中使用闭包。现在我们可以研究各种术语的转换以理解到堆栈的映射。例如，考虑函数应用的转换[REF]：'
- en: '| [(_ (f a)) |'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (f a)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps f) (lambda (fv) |'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps f) (lambda (fv) |'
- en: '|                 ((cps a) (lambda (av) |'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 ((cps a) (lambda (av) |'
- en: '|                            (fv av k))))))] |'
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (fv av k))))))] |'
- en: 'How do we “read” this? As follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '-   我们如何“读取”这个？如下所示：'
- en: Let’s use k to refer to the stack present before the function application begins
    to evaluate.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   让我们使用k来引用函数应用程序开始评估之前存在的堆栈。'
- en: 'When we begin to evaluate the function position (f), create a new stack frame
    ((lambda (fv) ...)). This frame has one free identifier: k. Thus its closure needs
    to record one element of the environment, namely the rest of the stack.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   当我们开始评估函数位置（f）时，创建一个新的堆栈帧((lambda (fv) ...))。该帧有一个自由标识符：k。因此，它的闭包需要记录环境的一个元素，即堆栈的其余部分。'
- en: 'The code portion of the stack frame represents what is left to be done once
    we obtain a value for the function: evaluate the argument, and perform the application,
    and return the result to the stack expecting the result of the application: k.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   堆栈帧的代码部分表示我们获得函数值后剩下的工作：评估参数，并执行应用程序，并将结果返回给期望应用程序的堆栈：k。'
- en: 'When evaluation of f completes, we begin to evaluate a, which also creates
    a stack frame: (lambda (av) ...). This frame has two free identifiers: k and fv.
    This tells us:'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   当f的评估完成时，我们开始评估a，这也创建一个堆栈帧：(lambda (av) ...)。该帧有两个自由标识符：k 和 fv。这告诉我们：'
- en: We no longer need the stack frame for evaluating the function position, but
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   我们不再需要用于评估函数位置的堆栈帧，但是'
- en: we now need a temporary that records the value—<wbr>hopefully a function value—<wbr>of
    evaluating the function position.
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   现在我们需要一个临时记录值-<wbr>希望是函数值-<wbr>评估函数位置的值。'
- en: 'The code portion of this second frame also represents what is left to be done:
    invoke the function value with the argument, in the stack expecting the value
    of the application.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   此第二帧的代码部分也表示剩下的工作：在期望应用程序的值的堆栈中使用参数调用函数值。'
- en: 'Let us apply similar reasoning to conditionals:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '-   让我们对条件应用类似的推理：'
- en: '| [(_ (cnd tst thn els)) |'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (cnd tst thn els)) |'
- en: '|  #''(lambda (k) |'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      ((cps tst) (lambda (tstv) |'
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((cps tst) (lambda (tstv) |'
- en: '|                   (if tstv |'
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   (if tstv |'
- en: '|                       ((cps thn) k) |'
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       ((cps thn) k) |'
- en: '|                       ((cps els) k)))))] |'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       ((cps els) k)))))] |'
- en: It says that to evaluate the conditional expression we have to create a new
    stack frame. This frame closes over the stack expecting the value of the entire
    conditional. This frame makes a decision based on the value of the conditional
    expression, and invokes one of the other expressions. Once we have examined this
    value the frame created to evaluate the conditional expression is no longer necessary,
    so evaluation can proceed in k.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 它说，要评估条件表达式，我们必须创建一个新的栈帧。该帧封闭了期望整个条件值的栈。这个帧根据条件表达式的值做出决定，并调用其他表达式之一。一旦我们检查了这个值，用于评估条件表达式的帧就不再需要了，所以评估可以在
    k 中进行。
- en: 'Viewed through this lens, we can more easily provide an operational explanation
    for generators. Each generator has its own private stack, and when execution attempts
    to return past its end, our implementation raises an error. On invocation, a generator
    stores a reference to the stack of the “rest of the program” in where-to-go, and
    resumes its own stack, which is referred to by resumer. On yielding, the system
    swaps references to stacks. Coroutines, threads, and generators are all conceptually
    similar: they are all mechanisms to create “many little stacks” instead of having
    a single, global stack.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个视角，我们可以更容易地为生成器提供一个操作性的解释。每个生成器都有自己的私有栈，当执行尝试返回到其结束时，我们的实现会引发错误。在调用时，生成器将“程序的其余部分”的栈的引用存储在
    where-to-go 中，并恢复其自己的栈，该栈由 resumer 引用。在产生中，系统交换栈的引用。协程、线程和生成器都是概念上相似的：它们都是创建“许多小栈”而不是拥有单个全局栈的机制。
- en: 14.5Tail Calls
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5尾调用
- en: 'Observe that the stack patterns above add a frame to the current stack, perform
    some evaluation, and eventually always return to the current stack. In particular,
    observe that in an application, we need stack space to evaluate the function position
    and then the arguments, but once all these are evaluated, we resume computation
    using the stack we started out with before the application. In other words, function
    calls do not themselves need to consume stack space: we only need space to compute
    the arguments.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述栈模式会向当前栈添加一个帧，执行一些评估，最终总是返回到当前栈。特别要注意，在应用中，我们需要栈空间来评估函数位置和参数，但一旦所有这些都被评估了，我们就会使用在应用之前开始的栈来恢复计算。换句话说，函数调用本身并不需要消耗栈空间：我们只需要空间来计算参数。
- en: 'However, not all languages observe or respect this property. In languages that
    do, programmers can use recursion to obtain iterative behavior: i.e., a sequence
    of function calls can consume no more stack space than no function calls at all.
    This removes the need to create special looping constructs; indeed, loops can
    simply be expressed as a syntactic sugar.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有的语言都遵守或尊重这个属性。在遵循这个属性的语言中，程序员可以使用递归来获得迭代行为：即，一系列函数调用的堆栈空间消耗不会比根本没有函数调用更多。这消除了创建特殊循环结构的需要；事实上，循环可以简单地表示为一种语法糖。
- en: 'Of course, this property does not apply in general. If a call to f is performed
    to compute an argument to a call to g, the call to f is still consuming space
    relative to the context surrounding g. Thus, we should really speak of a relationship
    between expressions: one expression is in tail position relative to another if
    its evaluation requires no additional stack space beyond the other. In our CPS
    macro, every expression that uses k as its continuation—<wbr>such as a function
    application after all the sub-expressions have been evaluated, or the then- and
    else-branches of a conditional—<wbr>are all in tail position relative to the enclosing
    application (and perhaps recursively further up). In contrast, every expression
    that has to create a new stack frame is not in tail position.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个属性通常并不适用。如果调用 f 来计算调用 g 的参数，那么调用 f 仍然相对于 g 周围的上下文消耗空间。因此，我们真正需要谈论的是表达式之间的关系：一个表达式相对于另一个表达式的尾部位置，如果它的评估不需要比另一个表达式更多的栈空间。在我们的
    CPS 宏中，每个使用 k 作为其延续的表达式——比如在所有子表达式被评估后的函数应用，或者条件语句的 then 分支和 else 分支——都相对于封闭应用的尾部位置（也许是递归地更高位置）。相反，每个必须创建新栈帧的表达式都不在尾部位置。
- en: 'Some languages have special support for tail recursion: when a procedure calls
    itself in tail position relative to its body. This is obviously useful, because
    it enables recursion to efficiently implement loops. However, it hurts “loops”
    that cannot be squeezed into a single recursive function. For instance, when implementing
    a scanner or other state machine, it is most convenient to have a set of functions
    each representing one state, and transitioning to other states by making (tail)
    function calls. It is onerous (and misses the point) to turn these into a single
    recursive function. If, however, a language recognizes tail calls as such, it
    can optimize these cross-function calls just as much as it does intra-function
    ones.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言对尾递归有特殊支持：当一个过程在相对于其主体的尾位置调用自身时。这显然很有用，因为它使递归能够高效地实现循环。然而，它会影响那些无法被压缩成单个递归函数的“循环”。例如，当实现扫描器或其他状态机时，最方便的方法是有一组函数，每个函数代表一个状态，并通过进行（尾）函数调用来转换到其他状态。将这些转换为单个递归函数是繁琐的（并且失去了意义）。然而，如果一种语言将尾调用识别为这样的话，它可以像内部函数一样优化这些跨函数调用。
- en: 'Racket, in particular, promises to implement tail calls without allocating
    additional stack space. Though some people refer to this as “tail call optimization”,
    this term is misleading: an optimization is optional, whereas whether or not a
    language promises to properly implement tail calls is a semantic feature. Developers
    need to know how the language will behave because it affects how they program.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是 Racket 承诺在不分配额外堆栈空间的情况下实现尾调用。尽管有些人将其称为“尾调用优化”，但这个术语是误导性的：优化是可选的，而语言是否承诺正确实现尾调用是一个语义特性。开发人员需要知道语言的行为方式，因为这影响他们的编程方式。
- en: 'Because of this feature, observe something interesting about the program after
    CPS transformation: all of its function applications are themselves tail calls!
    You can see this starting with the read-number/suspend example that began this
    chapter: any pending computation was put into the continuation argument. Assuming
    the program might terminate at any call is tantamount to not using any stack space
    at all (because the stack would get wiped out).'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特性，在 CPS 转换后观察程序的一个有趣之处：所有的函数应用本身都是尾调用！你可以从本章开始的 read-number/suspend 示例中看到这一点：任何待处理的计算都被放入延续参数中。假设程序可能在任何调用时终止等同于根本不使用任何堆栈空间（因为堆栈会被清除）。
- en: Exercise
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: How is the program able to function in the absence of a stack?
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在没有堆栈的情况下，程序是如何能够运行的？
- en: 14.6Continuations as a Language Feature
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.6 延续作为一种语言特性
- en: 'With this insight into the connection between continuations and stacks, we
    can now return to the treatment of procedures: we ignored the continuation at
    the point of closure creation and instead only used the one at the point of closure
    invocation. This of course corresponds to normal procedure behavior. But now we
    can ask, what if we use the creation-time continuation instead? This would correspond
    to maintaining a reference to (a copy of) the stack at the point of “procedure”
    creation, and when the procedure is applied, ignoring the dynamic evaluation and
    going back to the point of procedure creation.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对延续和堆栈之间连接的洞察，我们现在可以回到处理过程的问题：我们在闭包创建时忽略了延续，而是只在闭包调用时使用了延续。这当然对应于正常的过程行为。但现在我们可以问，如果我们使用创建时的延续呢？这将对应于在“过程”创建时保持对（堆栈的副本）的引用，并且在应用过程时，忽略动态评估并返回到过程创建点。
- en: In principle, we are trying to leave lambda intact and instead give ourselves
    a language construct that corresponds to this behavior:cc = “current continuation”
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们试图保持 lambda 不变，而是给自己一个与此行为相对应的语言构造：cc = “当前延续”
- en: '[<cps-macro-let/cc-case>](#(elem._(chunk._~3ccps-macro-let/cc-case~3e~3a1)))
    ::='
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[<cps-macro-let/cc-case>](#(elem._(chunk._~3ccps-macro-let/cc-case~3e~3a1)))
    ::='
- en: '| [(_ (let/cc kont b)) |'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (let/cc kont b)) |'
- en: '|  (identifier? #''kont) |'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (标识符？ #''kont) |'
- en: '|  #''(lambda (k) |'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      (let ([kont (lambda (v dyn-k) |'
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (let ([kont (lambda (v dyn-k) |'
- en: '|                    (k v))]) |'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (k v))]) |'
- en: '|        ((cps b) k)))] |'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        ((cps b) k)))] |'
- en: 'What this says is that either way, control will return to the expression that
    immediately surrounds the let/cc: either by falling through (because the continuation
    of the body, b, is k) or—<wbr>more interestingly—<wbr>by invoking the continuation,
    which discards the dynamic continuation dyn/k by simply ignoring it and returning
    to k instead.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话的意思是，无论如何，控制都将返回到紧邻 let/cc 的表达式：要么通过继续（因为 body 的延续 b 是 k），要么—<wbr>更有趣的是—<wbr>通过调用延续，通过简单地忽略动态延续
    dyn/k 并返回到 k 来丢弃它。
- en: 'Here’s the simplest test:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的测试：
- en: '| (test (run (cps (let/cc esc 3))) |'
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps (let/cc esc 3))) |'
- en: '|       3) |'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       3) |'
- en: 'This confirms that if we never use the continuation, evaluation of the body
    proceeds as if the let/cc weren’t there at all (because of the ((cps b) k)). If
    we use it, the value given to the continuation returns to the point of creation:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了如果我们从未使用延续，那么对 body 的评估将继续进行，就好像 let/cc 根本不存在（因为 ((cps b) k)）。如果我们使用它，那么给定给延续的值将返回到创建点：
- en: '| (test (run (cps (let/cc esc (esc 3)))) |'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps (let/cc esc (esc 3)))) |'
- en: '|       3) |'
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       3) |'
- en: 'This example, of course, isn’t revealing, but consider this one:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子并不具有启示性，但考虑这个例子：
- en: '| (test (run (cps (+ 1 (let/cc esc (esc 3))))) |'
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps (+ 1 ( let/cc esc (esc 3)))) |'
- en: '|       4) |'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       4) |'
- en: This confirms that the addition actually happens. But what about the dynamic
    continuation?
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了实际发生了加法。但动态继续呢？
- en: '| (test (run (cps (let/cc esc (+ 2 (esc 3))))) |'
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps (let/cc esc (+ 2 (esc 3))))) |'
- en: '|       3) |'
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       3) |'
- en: 'This shows that the addition by 2 never happens, i.e., the dynamic continuation
    is indeed ignored. And just to be sure that the continuation at the point of creation
    is respected, observe:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明加法 2 从未发生，即动态继续确实被忽略了。为了确保在创建点处尊重继续，观察：
- en: '| (test (run (cps (+ 1 (let/cc esc (+ 2 (esc 3)))))) |'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (run (cps (+ 1 ( let/cc esc (+ 2 (esc 3)))))) |'
- en: '|       4) |'
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       4) |'
- en: 'From these examples, you have probably noticed a familiar pattern: esc here
    is behaving like an exception. That is, if you do not throw an exception (in this
    case, invoke a continuation) it’s as if it’s not there, but if you do throw it,
    all pending intermediate computation is ignored and computation returns to the
    point of exception creation.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中，你可能已经注意到了一个熟悉的模式：这里的 esc 就像一个异常。也就是说，如果你不抛出异常（在这种情况下，调用一个延续），就好像它不存在一样，但如果你抛出它，所有待处理的中间计算都会被忽略，计算会返回到异常创建点。
- en: Exercise
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Using let/cc and macros, create a throw/catch mechanism.
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 let/cc 和宏，创建一个 throw/catch 机制。
- en: 'However, these examples only scratch the surface of available power, because
    the continuation at the point of invocation is always an extension of one at the
    point of creation: i.e., the latter is just earlier in the stack than the former.
    However, nothing actually demands that k and dyn-k be at all related. That means
    they are in fact free to be unrelated, which means each can be a distinct stack,
    so we can in fact easily implement stack-switching procedures with them.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些例子只是揭示了可用力量的冰山一角，因为在调用点处的延续总是在创建点的延续的扩展：即，后者只是在堆栈中比前者更早。然而，实际上没有任何要求 k
    和 dyn-k 必须相关。这意味着它们实际上可以是无关的，这意味着每个都可以是一个不同的堆栈，因此我们实际上可以很容易地使用它们实现堆栈切换过程。
- en: Exercise
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'To be properly analogous to lambda, we should have introduced a construct called,
    say, cont-lambda with the following expansion:'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了与 lambda 适当类比，我们应该引入一个称为 cont-lambda 的构造，其扩展如下：
- en: ''
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| [(_ (cont-lambda (a) b)) |'
  id: totrans-519
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(_ (cont-lambda (a) b)) |'
- en: '|  (identifier? #''a) |'
  id: totrans-520
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (identifier? #''a) |'
- en: '|  #''(lambda (k) |'
  id: totrans-521
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''(lambda (k) |'
- en: '|      (k (lambda (a dyn-k) |'
  id: totrans-522
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (k (lambda (a dyn-k) |'
- en: '|           ((cps b) k))))] |'
  id: totrans-523
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|           ((cps b) k))))] |'
- en: ''
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why didn’t we? Consider both the static typing implications, and also how we
    might construct the above exception-like behaviors using this construct instead.
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么我们没有？考虑静态类型的影响，以及我们如何使用这个构造来构建类似异常的行为。
- en: 14.6.1Presentation in the Language
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.1 语言中的呈现
- en: Writing programs in our little toy languages can soon become frustrating. Fortunately,
    Racket already provides a construct called call/cc that reifies continuations.
    call/cc is a procedure of one argument, which is itself a procedure of one argument,
    which Racket applies to the current continuation—<wbr>which is a procedure of
    one argument. Got that?
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小玩具语言中编写程序很快就会变得令人沮丧。幸运的是，Racket 已经提供了一个叫做 call/cc 的构造，它实现了延续。call/cc 是一个带有一个参数的过程，该参数本身是一个带有一个参数的过程，Racket
    将其应用于当前延续——<wbr>这是一个带有一个参数的过程。明白了吗？
- en: 'Fortunately, we can easily write let/cc as a macro over call/cc and program
    with that instead. Here it is:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以很容易地将 let/cc 写成一个宏，覆盖 call/cc 并用它来编程。这里是它的实现：
- en: '| (define-syntax let/cc |'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax let/cc |'
- en: '|   (syntax-rules () |'
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-rules () |'
- en: '|     [(let/cc k b) |'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(let/cc k b) |'
- en: '|      (call/cc (lambda (k) b))])) |'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (call/cc (lambda (k) b))])) |'
- en: 'To be sure, all our old tests still pass:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 确保，我们所有的旧测试仍然通过：
- en: '| (test (let/cc esc 3) 3) |'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (let/cc esc 3) 3) |'
- en: '| (test (let/cc esc (esc 3)) 3) |'
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (let/cc esc (esc 3)) 3) |'
- en: '| (test (+ 1 (let/cc esc (esc 3))) 4) |'
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (+ 1 (let/cc esc (esc 3))) 4) |'
- en: '| (test (let/cc esc (+ 2 (esc 3))) 3) |'
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (let/cc esc (+ 2 (esc 3))) 3) |'
- en: '| (test (+ 1 (let/cc esc (+ 2 (esc 3)))) 4) |'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (+ 1 (let/cc esc (+ 2 (esc 3)))) 4) |'
- en: 14.6.2Defining Generators
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.2 定义生成器
- en: 'Now we can start to create interesting abstractions. For instance, let’s build
    generators. Whereas previously we needed to both CPS expressions and pass around
    continuations, now this is done for us automatically by call/cc. Therefore, whenever
    we need the current continuation, we simply conjure it up without having to transform
    the program. Thus the extra ...-k parameters can disappear with a let/cc in the
    same place to capture the same continuation:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始创建有趣的抽象。例如，让我们构建生成器。以前我们需要同时使用 CPS 表达式并传递延续，现在这些都会自动由 call/cc 完成。因此，每当我们需要当前延续时，我们只需简单地召唤它，而无需转换程序。因此，额外的...-k
    参数可以在相同位置的 let/cc 中消失，以捕获相同的延续：
- en: '| (define-syntax (generator e) |'
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (generator e) |'
- en: '|   (syntax-case e () |'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case e () |'
- en: '|     [(generator (yield) (v) b) |'
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(generator (yield) (v) b) |'
- en: '|      #''(let ([where-to-go (lambda (v) (error ''where-to-go "nothing"))])
    |'
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''(let ([where-to-go (lambda (v) (error ''where-to-go "nothing"))])
    |'
- en: '|          (letrec ([resumer (lambda (v) |'
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (letrec ([resumer (lambda (v) |'
- en: '|                              (begin b |'
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                              (begin b |'
- en: '|                                     (error ''generator "fell through")))]
    |'
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                     (error ''generator "fell through")))]
    |'
- en: '|                   [yield (lambda (v) |'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   [yield (lambda (v) |'
- en: '|                            (let/cc gen-k |'
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (let/cc gen-k |'
- en: '|                              (begin |'
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                              (begin |'
- en: '|                                (set! resumer gen-k) |'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                (set! resumer gen-k) |'
- en: '|                                (where-to-go v))))]) |'
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                (where-to-go v))))]) |'
- en: '|            (lambda (v) |'
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (lambda (v) |'
- en: '|              (let/cc dyn-k |'
  id: totrans-554
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (let/cc dyn-k |'
- en: '|                (begin |'
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (begin |'
- en: '|                  (set! where-to-go dyn-k) |'
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (set! where-to-go dyn-k) |'
- en: '|                  (resumer v))))))])) |'
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (resumer v))))))])) |'
- en: Observe the close similarity between this code and the implementation of generators
    by desugaring into CPS code. Specifically, we can drop the extra continuation
    arguments, and replace them with invocations of let/cc that will capture precisely
    the same continuations. The rest of the code is fundamentally unchanged.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这段代码与通过将代码解糖为 CPS 代码来实现生成器之间的密切相似性。具体来说，我们可以去掉额外的延续参数，并用 let/cc 的调用来精确捕获相同的延续。代码的其余部分基本上没有改变。
- en: Exercise
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: What happens if we move the let/ccs and mutation to be the first statement inside
    the begins instead?
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们将 let/cc 和变异移到 begins 中的第一个语句，会发生什么？
- en: 'We can, for instance, write a generator that iterates from the initial value
    upward:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个从初始值开始向上迭代的生成器：
- en: '| (define g1 (generator (yield) (v) |'
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define g1 (generator (yield) (v) |'
- en: '|                       (letrec ([loop (lambda (n) |'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (letrec ([loop (lambda (n) |'
- en: '|                                        (begin |'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                        (begin |'
- en: '|                                          (yield n) |'
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                          (yield n) |'
- en: '|                                          (loop (+ n 1))))]) |'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                          (loop (+ n 1))))]) |'
- en: '|                         (loop v)))) |'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (loop v)))) |'
- en: 'whose behavior is:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 其行为是：
- en: '| > (g1 10) |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| > (g1 10) |'
- en: '| 10 |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| 10 |'
- en: '| > (g1 10) |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| > (g1 10) |'
- en: '| 11 |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| 11 |'
- en: '| > (g1 0) |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| > (g1 0) |'
- en: '| 12 |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| 12 |'
- en: '| > |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| > |'
- en: 'Because the body refers only to the initial value, ignoring that returned by
    invoking yield, the values we pass on subsequent invocations are irrelevant. In
    contrast, consider this generator:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 因为主体只引用��始值，忽略通过调用 yield 返回的值，我们在后续调用中传递的值是无关紧要的。相比之下，考虑这个生成器：
- en: '| (define g2 (generator (yield) (v) |'
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define g2 (generator (yield) (v) |'
- en: '|                       (letrec ([loop (lambda (n) |'
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (letrec ([loop (lambda (n) |'
- en: '|                                        (loop (+ (yield n) n)))]) |'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                        (loop (+ (yield n) n)))]) |'
- en: '|                         (loop v)))) |'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (loop v)))) |'
- en: 'On its first invocation, it returns whatever value it was supplied. On subsequent
    invocations, this value is added to that provided on re-entry into the generator.
    In other words, this generator additively accumulates all values given to it:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次调用时，它返回提供的任何值。在后续调用中，该值会累加到重新进入生成器时提供的值上。换句话说，该生成器会累加所有给定的值：
- en: '| > (g2 10) |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| > (g2 10) |'
- en: '| 10 |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| 10 |'
- en: '| > (g2 15) |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| > (g2 15) |'
- en: '| 25 |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| 25 |'
- en: '| > (g2 5) |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| > (g2 5) |'
- en: '| 30 |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| 30 |'
- en: Exercise
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you’ve seen how to implement generators using call/cc and let/cc, implement
    coroutines and threads as well.
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在您已经看到如何使用 call/cc 和 let/cc 实现生成器，请同时实现协程和线程。
- en: 14.6.3Defining Threads
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.3定义线程
- en: 'Having done generators, let’s do another, similar primitive: threads. That
    is, let’s assume we want to be able to write a program such as this:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了生成器之后，让我们再做另一个类似的基本操作：线程。也就是说，假设我们想要编写这样一个程序：
- en: '| (define d display) ;; a useful shorthand in what follows |'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define d display) ;; 在接下来的内容中，这是一个有用的缩写 |'
- en: '|   |'
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (scheduler-loop-0 |'
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (scheduler-loop-0 |'
- en: '|  (list |'
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (list |'
- en: '|   (thread-0 (y) (d "t1-1  ") (y) (d "t1-2  ") (y) (d "t1-3 ")) |'
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (thread-0 (y) (d "t1-1  ") (y) (d "t1-2  ") (y) (d "t1-3 ")) |'
- en: '|   (thread-0 (y) (d "t2-1  ") (y) (d "t2-2  ") (y) (d "t2-3 ")) |'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (thread-0 (y) (d "t2-1  ") (y) (d "t2-2  ") (y) (d "t2-3 ")) |'
- en: '|   (thread-0 (y) (d "t3-1  ") (y) (d "t3-2  ") (y) (d "t3-3 ")))) |'
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (thread-0 (y) (d "t3-1  ") (y) (d "t3-2  ") (y) (d "t3-3 ")))) |'
- en: and expect the output
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 并期望输出
- en: '| t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3 |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3 |'
- en: We’ll build all the pieces necessary to achieve this.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建实现此目标所需的所有组件。
- en: Let’s start by defining the thread scheduler. It consumes a list of “threads”,
    whose interface we assume will be a procedure that consumes a continuation to
    which it eventually yields control. Each time the scheduler reactivates the thread,
    it supplies it with a continuation. The scheduler might be choose between threads
    in a simple round-robin manner, or it might use some more complex algorithm; the
    details of how it chooses don’t concern us here.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义线程调度程序开始。它会消耗一个“线程”列表，我们假设其接口将是一个消耗延续的过程，最终将控制权交给它。每次调度程序重新激活线程时，它都会提供一个延续给它。调度程序可以简单地循环选择线程，也可以使用一些更复杂的算法；我们在这里不关心它的选择细节。
- en: 'As with generators, we’ll assume that yielding is done by invoking a procedure
    named by the user: y, above. We could use name capture [REF] to automatically
    bind a name like yield.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成器一样，我们假设让出控制权是通过调用用户命名的过程来完成的：上面的 y。我们可以使用名称捕获 [REF] 自动绑定类似 yield 的名称。
- en: More importantly, notice that the user of the thread system manually yields
    control. This is called cooperative multitasking. Instead, we could have chosen
    to have a timer or other intrinsic mechanism automtically yield without the user’s
    permission; this is called preemptive multitasking (because the system “pre-empts”—<wbr>i.e.,
    wrests control from—<wbr>the thread). While the distinction is important for buildling
    systems, it is not interesting from the perspective of setting up the continuations.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，请注意线程系统的用户手动放弃了控制权。这被称为协作式多任务处理。相反，我们也可以选择有一个定时器或其他固有机制在没有用户许可的情况下自动放弃控制权；这被称为抢占式多任务处理（因为系统“抢占”—即，从线程中夺取控制权）。虽然这种区别对于构建系统很重要，但从设置延续的角度来看，这并不重要。
- en: Exercise
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: After we are done building cooperative multitasking, implement preemptive multitasking.
    What changes?
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在完成构建协作式多任务处理之后，实现抢占式多任务处理。会有什么变化？
- en: 'With our stated constraints, we can write a first scheduler. It consumes a
    lists of threads and continues executing so long as there are threads remaining.
    Each time, it applies the thread procedure to a continuation that represents returning
    to the scheduler and proceeding to the next thread:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确定的约束条件下，我们可以编写一个第一个调度程序。它会消耗一个线程列表，并在仍有剩余线程时继续执行。每次，它都会将线程过程应用于表示返回到调度程序并继续到下一个线程的延续：
- en: '| (define (scheduler-loop-0 threads) |'
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (scheduler-loop-0 threads) |'
- en: '|   (cond |'
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (cond |'
- en: '|     [(empty? threads) ''done] |'
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(empty? threads) ''done] |'
- en: '|     [(cons? threads) |'
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(cons? threads) |'
- en: '|      (begin |'
  id: totrans-612
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (begin |'
- en: '|        (let/cc after-thread ((first threads) after-thread)) |'
  id: totrans-613
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        (let/cc after-thread ((first threads) after-thread)) |'
- en: '|        (scheduler-loop-0 (append (rest threads) |'
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        (scheduler-loop-0 (append (rest threads) |'
- en: '|                                  (list (first threads)))))])) |'
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                  (list (first threads)))))])) |'
- en: 'When the recipient thread invokes the continuation bound to after-thread, control
    returns to the end of the first statement in the begin sequence. As a result,
    the value supplied to the continuation is ignored (and can hence be any dummy
    value; we’ll chose ’dummy, so that we can easily spot it if it shows up in undesired
    places). Control then proceeds with the rest of the scheduler loop after appending
    the most recently invoked thread to the end of the list of threads (i.e., treating
    the list as a circular queue).Now let’s define a thread. As we’ve said, it will
    be a procedure of one argument, the scheduler’s continuation. Because the thread
    needs to resume, i.e., continue where it left off, presumably it must store where
    it last was: we’ll call this thread-resumer. Initially this is the entire thread
    body, but on subsequent instances it will be a continuation: specifically, the
    continuation of invoking yield. Thus, we obtain the following skeleton:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-syntax thread-0 |'
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (syntax-rules () |'
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(thread (yielder) b ...) |'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (letrec ([thread-resumer (lambda (_) |'
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                 (begin b ...))]) |'
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        (lambda (sched-k) |'
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          (thread-resumer ''dummy)))])) |'
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'That still leaves the yielder. It needs to be a procedure of no arguments that
    stores the thread’s continuation in thread-resumer, and then invoke the scheduler
    continuation with ’dummy. However, which scheduler continuation does it need to
    invoke? Not the one provided on thread initiation, but rather the most recent
    one. Thus, we must somehow “thread” the value in sched-k to the yielder. There
    are many ways to accomplish it, but the simplest, perhaps most brutal, way is
    to simply reconstruct the yielder on each thread resumption, always closed over
    the most recent value of sched-k:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-syntax thread-0 |'
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (syntax-rules () |'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [(thread (yielder) b ...) |'
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (letrec ([thread-resumer (lambda (_) |'
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                 (begin b ...))] |'
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               [yielder (lambda () (error ''yielder "nothing here"))]) |'
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|        (lambda (sched-k) |'
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|          (begin |'
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (set! yielder |'
  id: totrans-633
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                  (lambda () |'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                    (let/cc thread-k |'
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                      (begin |'
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (set! thread-resumer thread-k) |'
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                        (sched-k ''dummy))))) |'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (thread-resumer ''tres))))])) |'
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'When we run this ensemble, we get:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '| t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3 |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
- en: 'Hey, that’s what we wanted! But it continues:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '| t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
- en: Hmmm.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s happening? Well, we’ve been quiet all along about what needs to happen
    when a thread reaches its end. In fact, control just returns to the thread scheduler,
    which appends the thread to the end of the queue, and when the thread comes to
    the head of the queue again, control resumes from the same previously stored continuation:
    the one corresponding to printing the third value. This prints, control returns,
    the thread is appended...ad infinitum.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？好吧，我们一直对线程到达其结束时需要发生的事情保持沉默。事实上，控制权只是返回给线程调度程序，后者将线程追加到队列的末尾，当线程再次来到队列的头部时，控制权从以前存储的同一个续体恢复：对应于打印第三个值的续体。这打印了，控制返回，线程被追加...无限。
    |
- en: 'Clearly, we need the thread scheduler to be notified when a thread has terminated,
    so that the scheduler can remove it from the thread queue. We’ll create a simple
    datatype to represent this signal:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当线程终止时，我们需要通知线程调度程序，以便调度程序可以将其从线程队列中删除。我们将创建一个简单的数据类型来表示此信号：
- en: '| (define-type ThreadStatus |'
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （定义类型 ThreadStatus |'
- en: '|   [Tsuspended] |'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [Tsuspended] |'
- en: '|   [Tdone]) |'
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （Tdone）） |'
- en: '(In a real system, of course, these status messages might also carry informative
    values from the computation.) We must now modify our scheduler to actually check
    for and use these values:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: （在真实系统中，当然，这些状态消息也可能携带来自计算的信息价值。）我们现在必须修改我们的调度程序以实际检查和使用这些值：
- en: '| (define (scheduler-loop-1 threads) |'
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （定义（scheduler-loop-1 threads） |'
- en: '|   (cond |'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （病情 |'
- en: '|     [(empty? threads) ''done] |'
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(empty？ threads）''done] |'
- en: '|     [(cons? threads) |'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(cons？ threads） |'
- en: '|      (type-case ThreadStatus (let/cc after-thread ((first threads) after-thread))
    |'
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （type-case ThreadStatus（让/cc after-thread（（第一线程） after-thread））） |'
- en: '|        [Tsuspended () (scheduler-loop-1 (append (rest threads) |'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [Tsuspended （）（scheduler-loop-1 （append （rest threads） |'
- en: '|                                                 (list (first threads))))]
    |'
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （列表（第一线程））] |'
- en: '|        [Tdone () (scheduler-loop-1 (rest threads))])])) |'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [Tdone （）（scheduler-loop-1 （rest threads））））））） |'
- en: 'We have to now modify our thread representation in two ways: it must provide
    Tsuspended to the scheduler’s continuation on intermediate returns, and provide
    Tdone when it terminates. Where does it terminate? After executing the code in
    the body, b .... Observe, finally, that the termination process must be sure to
    use the latest scheduler continuation, just as yielding does. Thus:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须以两种方式修改我们的线程表示：它必须在中间返回时向调度程序的续体提供 Tsuspended，并在终止时提供 Tdone。它在哪里终止？在执行主体中的代码之后，b...请注意，最后，终止过程必须确保使用最新的调度程序续体，就像
    yielding 一样。因此：
- en: '| (define-syntax thread-1 |'
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （define-syntax thread-1 |'
- en: '|   (syntax-rules () |'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （语法规则（） |'
- en: '|     [(thread (yielder) b ...) |'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （线程（yielder）b ...） |'
- en: '|      (letrec ([thread-resumer (lambda (_) |'
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （letrec（[thread-resumer（λ（_） |'
- en: '|                                 (begin b ... |'
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （开始 b ... |'
- en: '|                                        (finisher)))] |'
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [（完成者）））] |'
- en: '|               [finisher (lambda () (error ''finisher "nothing here"))] |'
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [完成者（λ（）（错误''finisher“这里没有什么”））] |'
- en: '|               [yielder (lambda () (error ''yielder "nothing here"))]) |'
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [yielder（λ（）（错误''yielder“这里没有什么”））] |'
- en: '|        (lambda (sched-k) |'
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （λ（sched-k） |'
- en: '|          (begin |'
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （开始 |'
- en: '|            (set! finisher |'
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （set！ finisher |'
- en: '|                  (lambda () |'
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （λ（） |'
- en: '|                    (let/cc thread-k |'
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （让/cc thread-k |'
- en: '|                      (sched-k (Tdone))))) |'
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （sched-k （Tdone））））） |'
- en: '|            (set! yielder |'
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （set！ yielder |'
- en: '|                  (lambda () |'
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （λ（） |'
- en: '|                          (let/cc thread-k |'
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （让/cc thread-k |'
- en: '|                            (begin |'
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （开始 |'
- en: '|                              (set! thread-resumer thread-k) |'
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （set！ thread-resumer thread-k） |'
- en: '|                              (sched-k (Tsuspended)))))) |'
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （sched-k （Tsuspended））））） |'
- en: '|            (thread-resumer ''tres))))])) |'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| （thread-resumer ''tres））））））））））））） |'
- en: If we now replace scheduler-loop-0 with scheduler-loop-1 and thread-0 with thread-1
    and re-run our example program above, we get just the output we desire.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在用 scheduler-loop-1 替换 scheduler-loop-0，用 thread-1 替换 thread-0，并重新运行上面的示例程序，我们将得到我们想要的输出。
- en: 14.6.4Better Primitives for Web Programming
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.4 更好的网络编程原语 |
- en: 'Finally, to tie the knot back to where we began, let’s return to read-number:
    observe that, if the language running the server program has call/cc, instead
    of having to CPS the entire program, we can simply capture the current continuation
    and save it in the hash table, leaving the program structure again intact.'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了将结论与我们开始的地方联系起来，让我们回到读数：观察到，如果运行服务器程序的语言具有call/cc，那么我们可以简单地捕获当前的延续并将其保存在哈希表中，而不是必须将整个程序CPS化，从而再次保持程序结构完整。
