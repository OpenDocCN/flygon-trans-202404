- en: Chapter 8\. Syntactic Extension
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 语法扩展
- en: '*Syntactic extensions*, or *macros*, are used to simplify and regularize repeated
    patterns in a program, to introduce syntactic forms with new evaluation rules,
    and to perform transformations that help make programs more efficient.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*语法扩展*，或*宏*，用于简化和规范程序中重复模式，引入具有新评估规则的语法形式，并执行有助于使程序更高效的转换。'
- en: A syntactic extension most often takes the form `(*keyword* *subform* ...)`,
    where `*keyword*` is the identifier that names the syntactic extension. The syntax
    of each `*subform*` varies from one syntactic extension to another. Syntactic
    extensions can also take the form of improper lists or even singleton identifiers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 语法扩展通常采用`(*关键字* *子形式* ...)`的形式，其中`*关键字*`是命名语法扩展的标识符。每个`*子形式*`的语法因语法扩展而异。语法扩展也可以采用不当列表或甚至单一标识符的形式。
- en: New syntactic extensions are defined by associating keywords with transformation
    procedures, or *transformers*. Syntactic extensions are defined using `define-syntax`
    forms or using `let-syntax` or `letrec-syntax`. Transformers may be created using
    `syntax-rules`, which allows simple pattern-based transformations to be performed.
    They may also be ordinary procedures that accept one argument and perform arbitrary
    computations. In this case, `syntax-case` is normally used to destructure the
    input and `syntax` is normally used to construct the output. The `identifier-syntax`
    form and `make-variable-transformer` procedure allow the creation of transformers
    that match singleton identifiers and assignments to those identifiers, the former
    being restricted to simple patterns like `syntax-rules` and the latter allowing
    arbitrary computations to be performed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将关键字与转换过程或*转换器*关联来定义新的语法扩展。可以使用`define-syntax`形式或使用`let-syntax`或`letrec-syntax`来定义语法扩展。可以使用`syntax-rules`创建转换器，允许执行基于简单模式的转换。它们也可以是接受一个参数并执行任意计算的普通过程。在这种情况下，通常使用`syntax-case`来解构输入，通常使用`syntax`来构造输出。`identifier-syntax`形式和`make-variable-transformer`过程允许创建与单一标识符和分配给这些标识符相匹配的转换器，前者受限于像`syntax-rules`一样的简单模式，后者允许执行任意计算。
- en: Syntactic extensions are expanded into core forms at the start of evaluation
    (before compilation or interpretation) by a syntax *expander*. If the expander
    encounters a syntactic extension, it invokes the associated transformer to expand
    the syntactic extension, then repeats the expansion process for the form returned
    by the transformer. If the expander encounters a core syntactic form, it recursively
    processes the subforms, if any, and reconstructs the form from the expanded subforms.
    Information about identifier bindings is maintained during expansion to enforce
    lexical scoping for variables and keywords.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 语法扩展在评估开始时（在编译或解释之前）由语法*扩展器*展开为核心形式。如果扩展器遇到语法扩展，它会调用相关的转换器来展开语法扩展，然后对转换器返回的形式重复展开过程。如果扩展器遇到核心语法形式，它会递归处理子形式（如果有的话），并从展开的子形式重构形式。在展开过程中保留有关标识符绑定的信息，以强制变量和关键字的词法作用域。
- en: The syntactic extension mechanisms described in this chapter are part of the
    "syntax-case" system. A portable implementation of the system that also supports
    libraries and top-level programs is available at [http://www.cs.indiana.edu/syntax-case/](http://www.cs.indiana.edu/syntax-case/).
    A description of the motivations behind and implementation of the system can be
    found in the article "Syntactic Abstraction in Scheme" [[12](bibliography.html#g230)].
    Additional features that have not yet been standardized, including `modules`,
    local `import`, and meta definitions, are described in the *Chez Scheme User's
    Guide* [[9](bibliography.html#g227)].
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的语法扩展机制是“syntax-case”系统的一部分。支持库和顶层程序的可移植实现可在[http://www.cs.indiana.edu/syntax-case/](http://www.cs.indiana.edu/syntax-case/)找到。有关系统背后动机和实现的描述可在文章“Scheme中的语法抽象”[[12](bibliography.html#g230)]中找到。尚未标准化的其他功能，包括`modules`、本地`import`和元定义，可在*Chez
    Scheme用户指南*[[9](bibliography.html#g227)]中找到。
- en: Section 8.1\. Keyword Bindings
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8.1节 关键字绑定
- en: This section describes forms that establish bindings between keywords and transformers.
    Keyword bindings may be established within a top-level program or library body
    using `define-syntax` and in any local scope using `define-syntax`, `let-syntax`,
    or `letrec-syntax`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了在关键字和转换器之间建立绑定的形式。关键字绑定可以在顶层程序或库体中使用`define-syntax`以及在任何局部范围内使用`define-syntax`、`let-syntax`或`letrec-syntax`来建立。
- en: '**syntax**: `(define-syntax *keyword* *expr*)`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(define-syntax *keyword* *expr*)`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`*expr*` must evaluate to a transformer.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`*expr*`必须评估为一个转换器。'
- en: The following example defines `let*` as a syntactic extension, specifying the
    transformer with `syntax-rules` (see Section [8.2](syntax.html#g135)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将`let*`定义为一个语法扩展，使用`syntax-rules`指定转换器（参见第[8.2](syntax.html#g135)节）。
- en: '`(define-syntax let*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax let*'
- en: (syntax-rules ()
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ () b1 b2 ...) (let () b1 b2 ...)]'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ () b1 b2 ...) (let () b1 b2 ...)]'
- en: '[(_ ((i1 e1) (i2 e2) ...) b1 b2 ...)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ((i1 e1) (i2 e2) ...) b1 b2 ...)'
- en: (let ([i1 e1])
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([i1 e1])
- en: (let* ([i2 e2] ...) b1 b2 ...))]))`
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ([i2 e2] ...) b1 b2 ...))]))`
- en: All bindings established by a set of internal definitions, whether keyword or
    variable definitions, are visible everywhere within the immediately enclosing
    body, including within the definitions themselves. For example, the expression
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由一组内部定义建立的所有绑定，无论是关键字定义还是变量定义，都在直接封闭体内的任何地方可见，包括在定义本身内部。例如，表达式
- en: '`(let ()'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ()'
- en: (define even?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: (define even?
- en: (lambda (x)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (or (= x 0) (odd? (- x 1)))))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (or (= x 0) (odd? (- x 1)))))
- en: (define-syntax odd?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax odd?
- en: (syntax-rules ()
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ x) (not (even? x))]))'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ x) (not (even? x))]))'
- en: (even? 10))`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: (even? 10))`
- en: is valid and should evaluate to `#t`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 是有效的，应该评估为`#t`。
- en: The expander processes the initial forms in a `library`, `lambda`, or other
    body from left to right. If it encounters a variable definition, it records the
    fact that the defined identifier is a variable but defers expansion of the right-hand-side
    expression until after all of the definitions have been processed. If it encounters
    a keyword definition, it expands and evaluates the right-hand-side expression
    and binds the keyword to the resulting transformer. If it encounters an expression,
    it fully expands all deferred right-hand-side expressions along with the current
    and remaining body expressions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 展开器按从左到右的顺序处理`library`、`lambda`或其他体中的初始形式。如果遇到变量定义，它记录定义的标识符是一个变量，但推迟右侧表达式的展开，直到所有定义都被处理完毕。如果遇到关键字定义，它展开和评估右侧表达式，并将关键字绑定到生成的转换器。如果遇到表达式，它将完全展开所有推迟的右侧表达式以及当前和剩余的体表达式。
- en: An implication of the left-to-right processing order is that one internal definition
    can affect whether a subsequent form is also a definition. For example, the expression
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右的处理顺序的一个含义是，一个内部定义可以影响后续形式是否也是一个定义。例如，表达式
- en: '`(let ()'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ()'
- en: (define-syntax bind-to-zero
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax bind-to-zero
- en: (syntax-rules ()
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ id) (define id 0)]))'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ id) (define id 0)]))'
- en: (bind-to-zero x)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: (bind-to-zero x)
- en: x)`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: x)`
- en: evaluates to `0`, regardless of any binding for `bind-to-zero` that might appear
    outside of the `let` expression.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 评估为`0`，无论`let`表达式之外是否存在`bind-to-zero`的任何绑定。
- en: '**syntax**: `(let-syntax ((*keyword* *expr*) ...) *form[1]* *form[2]* ...)`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(let-syntax ((*keyword* *expr*) ...) *form[1]* *form[2]* ...)`'
- en: '**syntax**: `(letrec-syntax ((*keyword* *expr*) ...) *form[1]* *form[2]* ...)`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(letrec-syntax ((*keyword* *expr*) ...) *form[1]* *form[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: Each `*expr*` must evaluate to a transformer. For `let-syntax` and `letrec-syntax`
    both, each `*keyword*` is bound within the forms `*form[1]* *form[2]* ...`. For
    `letrec-syntax` the binding scope also includes each `*expr*`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`*expr*`必须评估为一个转换器。对于`let-syntax`和`letrec-syntax`，每个`*keyword*`都在形式`*form[1]* *form[2]* ...`中绑定。对于`letrec-syntax`，绑定范围还包括每个`*expr*`。
- en: A `let-syntax` or `letrec-syntax` form may expand into one or more expressions
    anywhere expressions are permitted, in which case the resulting expressions are
    treated as if enclosed in a `begin` expression. It may also expand into zero or
    more definitions anywhere definitions are permitted, in which case the definitions
    are treated as if they appeared in place of the `let-syntax` or `letrec-syntax`
    form.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`let-syntax`或`letrec-syntax`形式可以展开为一个或多个表达式，任何允许表达式的地方，此时结果表达式被视为被包含在`begin`表达式中。它也可以展开为零个或多个定义，任何允许定义的地方，此时这些定义被视为出现在`let-syntax`或`letrec-syntax`形式的位置。'
- en: The following example highlights how `let-syntax` and `letrec-syntax` differ.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例突出了`let-syntax`和`letrec-syntax`的区别。
- en: '`(let ([f (lambda (x) (+ x 1))])'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([f (lambda (x) (+ x 1))])'
- en: (let-syntax ([f (syntax-rules ()
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: (let-syntax ([f (syntax-rules ()
- en: '[(_ x) x])]'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ x) x])]'
- en: '[g (syntax-rules ()'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[g (syntax-rules ()'
- en: '[(_ x) (f x)])])'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ x) (f x)])])'
- en: (list (f 1) (g 1)))) ![<graphic>](ch2_0.gif) (1 2)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: (list (f 1) (g 1)))) ![<graphic>](ch2_0.gif) (1 2)
- en: (let ([f (lambda (x) (+ x 1))])
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda (x) (+ x 1))])
- en: (letrec-syntax ([f (syntax-rules ()
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (letrec-syntax ([f (syntax-rules ()
- en: '[(_ x) x])]'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ x) x])]'
- en: '[g (syntax-rules ()'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[g (syntax-rules ()'
- en: '[(_ x) (f x)])])'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ x) (f x)])])'
- en: (list (f 1) (g 1)))) ![<graphic>](ch2_0.gif) (1 1)`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (list (f 1) (g 1)))) ![<graphic>](ch2_0.gif) (1 1)`
- en: The two expressions are identical except that the `let-syntax` form in the first
    expression is a `letrec-syntax` form in the second. In the first expression, the
    `f` occurring in `g` refers to the `let`-bound variable `f`, whereas in the second
    it refers to the keyword `f` whose binding is established by the `letrec-syntax`
    form.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表达式除了第一个表达式中的`let-syntax`形式是第二个表达式中的`letrec-syntax`形式外完全相同。在第一个表达式中，`g`中的`f`指的是`let`绑定的变量`f`，而在第二个表达式中，它指的是由`letrec-syntax`形式建立的关键字`f`。
- en: Section 8.2\. Syntax-Rules Transformers
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8.2节。语法规则变换器
- en: The `syntax-rules` form described in this section permits simple transformers
    to be specified in a convenient manner. These transformers may be bound to keywords
    using the mechanisms described in Section [8.1](syntax.html#g134). While it is
    much less expressive than the mechanism described in Section [8.3](syntax.html#g136),
    it is sufficient for defining many common syntactic extensions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的`syntax-rules`形式允许以方便的方式指定简单的变换器。这些变换器可以使用第8.1节描述的机制绑定到关键字。虽然它比第8.3节描述的机制要不太表达，但它足以定义许多常见的语法扩展。
- en: '**syntax**: `(syntax-rules (*literal* ...) *clause* ...)`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `(syntax-rules (*literal* ...) *clause* ...)`'
- en: '**returns:** a transformer'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个变压器'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`, `(rnrs)`'
- en: Each `*literal*` must be an identifier other than an underscore ( `_` ) or ellipsis
    ( `...` ). Each clause must take the form below.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`*literal*`必须是一个标识符，不能是下划线（`_`）或省略号（`...`）。每个子句必须采用下面的形式。
- en: '`(*pattern* *template*)`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*pattern* *template*)`'
- en: Each `*pattern*` specifies one possible syntax that the input form might take,
    and the corresponding `*template*` specifies how the output should appear.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`*pattern*`指定了输入形式可能采用的一种语法，相应的`*template*`指定了输出应该如何显示。
- en: Patterns consist of list structure, vector structure, identifiers, and constants.
    Each identifier within a pattern is either a `*literal*`, a *pattern variable*,
    an *underscore*, or an *ellipsis*. The identifier `_` is an underscore, and the
    identifier `...` is an ellipsis. Any identifier other than `_` or `...` is a literal
    if it appears in the list of literals `(*literal* ...)`; otherwise, it is a pattern
    variable. Literals serve as auxiliary keywords, such as `else` in `case` and `cond`
    expressions. List and vector structure within a pattern specifies the basic structure
    required of the input, the underscore and pattern variables specify arbitrary
    substructure, and literals and constants specify atomic pieces that must match
    exactly. Ellipses specify repeated occurrences of the subpatterns they follow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模式由列表结构、向量结构、标识符和常量组成。模式中的每个标识符都是一个`*literal*`、一个*pattern variable*、一个*underscore*或一个*ellipsis*。标识符`_`是一个下划线，标识符`...`是一个省略号。除了在字面量列表`(*literal* ...)`中出现的标识符`else`之外，任何标识符如果不是`_`或`...`，则是一个字面量。字面量用作辅助关键字，例如`case`和`cond`表达式中的`else`。模式中的列表和向量结构指定了输入所需的基本结构，下划线和模式变量指定了任意子结构，而字面量和常量指定了必须完全匹配的原子片段。省略号指定了其后的子模式的重复出现。
- en: An input form `*F*` matches a pattern `*P*` if and only if
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输入形式`*F*`与模式`*P*`匹配当且仅当
- en: '`*P*` is an underscore or pattern variable,'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`是一个下划线或模式变量，'
- en: '`*P*` is a literal identifier and `*F*` is an identifier with the same binding
    as determined by the predicate `free-identifier=?` (Section [8.3](syntax.html#g136)),'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`是一个字面量标识符，而`*F*`是一个具有相同绑定的标识符，由谓词`free-identifier=?`（第8.3节）确定，'
- en: '`*P*` is of the form `(*P[1]* ... *P[n]*)` and `*F*` is a list of *n* elements
    that match `*P[1]*` through `*P[n]*`,'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`的形式为`(*P[1]* ... *P[n]*)`，而`*F*`是匹配`*P[1]*`到`*P[n]*`的*n*个元素的列表，'
- en: '`*P*` is of the form `(*P[1]* ... *P[n]* . *P[x]*)` and `*F*` is a list or
    improper list of *n* or more elements whose first *n* elements match `*P[1]*`
    through `*P[n]*` and whose *n*th cdr matches `*P[x]*`,'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`的形式为`(*P[1]* ... *P[n]* . *P[x]*)`，而`*F*`是一个包含*n*个或更多元素的列表或不完整列表，其前*n*个元素匹配`*P[1]*`到`*P[n]*`，而第*n*个cdr匹配`*P[x]*`，'
- en: '`*P*` is of the form `(*P[1]* ... *P[k]* *P[e]* *ellipsis* *P[*m*+1]* ... *P[n]*)`,
    where `*ellipsis*` is the identifier `...` and `*F*` is a proper list of *n* elements
    whose first *k* elements match `*P[1]*` through `*P[k]*`, whose next *m* - *k*
    elements each match `*P[e]*`, and whose remaining *n* - *m* elements match `*P[*m*+1]*`
    through `*P[n]*`,'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`的形式为`(*P[1]* ... *P[k]* *P[e]* *ellipsis* *P[*m*+1]* ... *P[n]*)`，其中`*ellipsis*`是标识符`...`，而`*F*`是一个包含*n*个元素的正确列表，其前*k*个元素匹配`*P[1]*`到`*P[k]*`，接下来的*m*
    - *k*个元素每个匹配`*P[e]*`，其余的*n* - *m*个元素匹配`*P[*m*+1]*`到`*P[n]*`，'
- en: '`*P*` is of the form `(*P[1]* ... *P[k]* *P[e]* *ellipsis* *P[*m*+1]* ... *P[n]* . *P[x]*)`,
    where `*ellipsis*` is the identifier `...` and `*F*` is a list or improper list
    of *n* elements whose first *k* elements match `*P[1]*` through `*P[k]*`, whose
    next *m* - *k* elements each match `*P[e]*`, whose next *n* - *m* elements match
    `*P[*m*+1]*` through `*P[n]*`, and whose *n*th and final cdr matches `*P[x]*`,'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`的形式为`(*P[1]* ... *P[k]* *P[e]* *ellipsis* *P[*m*+1]* ... *P[n]* . *P[x]*)`，其中`*ellipsis*`是标识符`...`，而`*F*`是一个包含*n*个元素的列表或不完整列表，其前*k*个元素匹配`*P[1]*`到`*P[k]*`，接下来的*m*
    - *k*个元素分别匹配`*P[e]*`，接下来的*n* - *m*个元素匹配`*P[*m*+1]*`到`*P[n]*`，而第*n*个和最后一个cdr匹配`*P[x]*`，'
- en: '`*P*` is of the form `#(*P[1]* ... *P[n]*)` and `*F*` is a vector of *n* elements
    that match `*P[1]*` through `*P[n]*`,'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`的形式为`#(*P[1]* ... *P[n]*)`，而`*F*`是一个包含*n*个元素的向量，其前*n*个元素匹配`*P[1]*`到`*P[n]*`，'
- en: '`*P*` is of the form `#(*P[1]* ... *P[k]* *P[e]* *ellipsis* *P[*m*+1]* ... *P[n]*)`,
    where `*ellipsis*` is the identifier `...` and `*F*` is a vector of *n* or more
    elements whose first *k* elements match `*P[1]*` through `*P[k]*`, whose next
    *m* - *k* elements each match `*P[e]*`, and whose remaining *n* - *m* elements
    match `*P[*m*+1]*` through `*P[n]*`, or'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`的形式为`#(*P[1]* ... *P[k]* *P[e]* *ellipsis* *P[*m*+1]* ... *P[n]*)`，其中`*ellipsis*`是标识符`...`，而`*F*`是一个包含*n*个或更多元素的向量，其前*k*个元素匹配`*P[1]*`到`*P[k]*`，接下来的*m*
    - *k*个元素每个匹配`*P[e]*`，其余的*n* - *m*个元素匹配`*P[*m*+1]*`到`*P[n]*`，或'
- en: '`*P*` is a pattern datum (any nonlist, nonvector, nonsymbol object) and `*F*`
    is equal to `*P*` in the sense of the `equal?` procedure.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*P*`是一个模式数据（任何非列表、非向量、非符号对象），而`*F*`在`equal?`过程的意义上等于`*P*`。'
- en: The outermost structure of a `syntax-rules` `*pattern*` must actually be in
    one of the list-structured forms above, although subpatterns of the pattern may
    be in any of the above forms. Furthermore, the first element of the outermost
    pattern is ignored, since it is always assumed to be the keyword naming the syntactic
    form. (These statements do not apply to `syntax-case`; see Section [8.3](syntax.html#g136).)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`syntax-rules` `*pattern*`的最外层结构实际上必须是上述列表结构形式之一，尽管模式的子模式可以是上述任何形式。此外，最外层模式的第一个元素被忽略，因为它总是被假定为命名语法形式的关键字。（这些声明不适用于`syntax-case`；请参见第[8.3](syntax.html#g136)节。）'
- en: If an input form passed to a `syntax-rules` transformer matches the pattern
    for a given clause, the clause is accepted and the form is transformed as specified
    by the associated template. As this transformation takes place, pattern variables
    appearing in the pattern are bound to the corresponding input subforms. Pattern
    variables appearing within a subpattern followed by one or more ellipses may be
    bound to a sequence or sequences of zero or more input subforms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给`syntax-rules`转换器的输入表单与给定子句的模式匹配，则接受该子句，并根据关联模板指定的方式转换表单。在进行此转换时，出现在模式中的模式变量将绑定到相应的输入子表单。在一个或多个省略号后面的子模式中出现的模式变量可以绑定到零个或多个输入子表单的序列或序列。
- en: A template is a pattern variable, an identifier that is not a pattern variable,
    a pattern datum, a list of subtemplates `(*S[1]* ... *S[n]*)`, an improper list
    of subtemplates `(*S[1]* *S[2]* ... *S[n]* . *T*)`, or a vector of subtemplates
    `#(*S[1]* ... *S[n]*)`. Each subtemplate `*S[i]*` is a template followed by zero
    or more ellipses. The final element `*T*` of an improper subtemplate list is a
    template.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一个模式变量，一个不是模式变量的标识符，一个模式数据，一个子模板列表`(*S[1]* ... *S[n]*)`，一个不完整子模板列表`(*S[1]* *S[2]* ... *S[n]* . *T*)`，或一个子模板向量`#(*S[1]* ... *S[n]*)`。每个子模板`*S[i]*`是一个模板，后面跟着零个或多个省���号。不完整子模板列表的最后一个元素`*T*`是一个模板。
- en: Pattern variables appearing within a template are replaced in the output by
    the input subforms to which they are bound. Pattern data and identifiers that
    are not pattern variables are inserted directly into the output. List and vector
    structure within the template remains list and vector structure in the output.
    A subtemplate followed by an ellipsis expands into zero or more occurrences of
    the subtemplate. The subtemplate must contain at least one pattern variable from
    a subpattern followed by an ellipsis. (Otherwise, the expander could not determine
    how many times the subform should be repeated in the output.) Pattern variables
    that occur in subpatterns followed by one or more ellipses may occur only in subtemplates
    that are followed by (at least) as many ellipses. These pattern variables are
    replaced in the output by the input subforms to which they are bound, distributed
    as specified. If a pattern variable is followed by more ellipses in the template
    than in the associated pattern, the input form is replicated as necessary.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中出现的模式变量将在输出中被绑定到它们所绑定的输入子表单中。模式数据和标识符不是模式变量的将直接插入到输出中。模板中的列表和向量结构在输出中保持为列表和向量结构。模板后跟省略号的子模板扩展为零个或多个子模板的出现。子模板必须至少包含一个子模式后跟省略号的模式变量。（否则，扩展器无法确定子表单在输出中应重复多少次。）在子模式后跟一个或多个省略号的子模式中出现的模式变量只能出现在后跟（至少）同样多个省略号的子模板中。这些模式变量在输出中被替换为它们所绑定的输入子表单，并按指定方式分布。如果模板中的模式变量后跟的省略号比相关模式中的省略号多，输入形式将根据需要复制。
- en: A template of the form `(... *template*)` is identical to `*template*`, except
    that ellipses within the template have no special meaning. That is, any ellipses
    contained within `*template*` are treated as ordinary identifiers. In particular,
    the template `(... ...)` produces a single ellipsis, `...`. This allows syntactic
    extensions to expand into forms containing ellipses, including `syntax-rules`
    or `syntax-case` patterns and templates.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为`(... *template*)`的模板与`*template*`相同，只是模板中的省略号没有特殊含义。也就是说，包含在`*template*`中的任何省略号都被视为普通标识符。特别是，模板`(... ...)`产生一个单独的省略号，`...`。这允许语法扩展扩展为包含省略号的形式，包括`syntax-rules`或`syntax-case`模式和模板。
- en: The definition of `or` below demonstrates the use of `syntax-rules`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`or`定义演示了`syntax-rules`的使用。
- en: '`(define-syntax or'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax or'
- en: (syntax-rules ()
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_) #f]'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_) #f]'
- en: '[(_ e) e]'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e) e]'
- en: '[(_ e1 e2 e3 ...)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 e3 ...)'
- en: (let ([t e1]) (if t t (or e2 e3 ...)))]))`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([t e1]) (if t t (or e2 e3 ...)))]))`
- en: The input patterns specify that the input must consist of the keyword and zero
    or more subexpressions. An underscore ( `_` ), which is a special pattern symbol
    that matches any input, is often used for the keyword position to remind the programmer
    and anyone reading the definition that the keyword position never fails to contain
    the expected keyword and need not be matched. (In fact, as mentioned above, `syntax-rules`
    ignores what appears in the keyword position.) If more than one subexpression
    is present (third clause), the expanded code both tests the value of the first
    subexpression and returns the value if it is not false. To avoid evaluating the
    expression twice, the transformer introduces a binding for the temporary variable `t`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输入模式指定输入必须由关键字和零个或多个子表达式组成。下划线（ `_` ）是一个特殊的模式符号，匹配任何输入，通常用于关键字位置，以提醒程序员和任何阅读定义的人，关键字位置永远包含预期的关键字且无需匹配。（实际上，如上所述，`syntax-rules`忽略关键字位置的内容。）如果存在多个子表达式（第三条款），扩展的代码既测试第一个子表达式的值，如果不为假则返回该值。为了避免两次评估表达式，变换器引入了临时变量 `t`的绑定。
- en: The expansion algorithm maintains lexical scoping automatically by renaming
    local identifiers as necessary. Thus, the binding for `t` introduced by the transformer
    is visible only within code introduced by the transformer and not within subforms
    of the input. Similarly, the references to the identifiers `let` and `if` are
    unaffected by any bindings present in the context of the input.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展算法通过必要时重命名本地标识符来自动维护词法作用域。因此，变换器引入的`t`的绑定仅在变换器引入的代码内部可见，而不在输入的子表单内部可见。类似地，对标识符`let`和`if`的引用不受输入上下文中的任何绑定的影响。
- en: '`(let ([if #f])'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([if #f])'
- en: (let ([t 'okay])
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([t 'okay])
- en: (or if t))) ![<graphic>](ch2_0.gif) okay`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (或者 如果 t))) ![<graphic>](ch2_0.gif) 好的`
- en: This expression is transformed during expansion to the equivalent of the expression
    below.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展过程中，此表达式被转换为下面表达式的等价形式。
- en: '`((lambda (if1)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`((lambda (if1)'
- en: ((lambda (t1)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (t1)
- en: ((lambda (t2)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ((lambda (t2)
- en: (if t2 t2 t1))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: (if t2 t2 t1))
- en: if1))
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: if1))
- en: '''okay))'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '''好))'
- en: '#f) ![<graphic>](ch2_0.gif) okay`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '#f) ![<graphic>](ch2_0.gif) 好`'
- en: In this sample expansion, `if1`, `t1`, and `t2` represent identifiers to which
    `if` and `t` in the original expression and `t` in the expansion of `or` have
    been renamed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例扩展中，`if1`、`t1` 和 `t2` 代表原始表达式中的 `if` 和 `t`，以及 `or` 的扩展中的 `t` 已被重命名的标识符。
- en: The definition of a simplified version of `cond` below (simplified because it
    requires at least one output expression per clause and does not support the auxiliary
    keyword `=>`) demonstrates how auxiliary keywords such as `else` are recognized
    in the input to a transformer, via inclusion in the list of literals.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面简化版本的 `cond` 定义（简化是因为它每个子句至少需要一个输出表达式，并且不支持辅助关键字 `=>`）演示了辅助关键字如 `else` 如何在变换器的输入中被识别，通过包含在文字列表中。
- en: '`(define-syntax cond'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax cond'
- en: (syntax-rules (else)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules (else)
- en: '[(_ (else e1 e2 ...)) (begin e1 e2 ...)]'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (else e1 e2 ...)) (begin e1 e2 ...)]'
- en: '[(_ (e0 e1 e2 ...)) (if e0 (begin e1 e2 ...))]'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (e0 e1 e2 ...)) (if e0 (begin e1 e2 ...))]'
- en: '[(_ (e0 e1 e2 ...) c1 c2 ...)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (e0 e1 e2 ...) c1 c2 ...)'
- en: (if e0 (begin e1 e2 ...) (cond c1 c2 ...))]))`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: (if e0 (begin e1 e2 ...) (cond c1 c2 ...))]))`
- en: '**syntax**: `_`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`_`'
- en: '**syntax**: `...`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`...`'
- en: '**libraries:** `(rnrs base)`, `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`，`(rnrs syntax-case)`，`(rnrs)`'
- en: These identifiers are auxiliary keywords for `syntax-rules`, `identifier-syntax`,
    and `syntax-case`. The second ( `...` ) is also an auxiliary keyword for `syntax`
    and `quasisyntax`. It is a syntax violation to reference these identifiers except
    in contexts where they are recognized as auxiliary keywords.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标识符是 `syntax-rules`、`identifier-syntax` 和 `syntax-case` 的辅助关键字。第二个（`...`）也是
    `syntax` 和 `quasisyntax` 的辅助关键字。在不被识别为辅助关键字的上下文中引用这些标识符是一个语法违例。
- en: '**syntax**: `(identifier-syntax *tmpl*)`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(identifier-syntax *tmpl*)`'
- en: '**syntax**: `(identifier-syntax (*id[1]* *tmpl[1]*) ((set! *id[2]* *e[2]*) *tmpl[2]*))`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(identifier-syntax (*id[1]* *tmpl[1]*) ((set! *id[2]* *e[2]*) *tmpl[2]*))`'
- en: '**returns:** a transformer'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个变换器'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`，`(rnrs)`'
- en: When a keyword is bound to a transformer produced by the first form of `identifier-syntax`,
    references to the keyword within the scope of the binding are replaced by `*tmpl*`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个关键字绑定到由 `identifier-syntax` 的第一种形式产生的变换器时，在绑定的范围内对关键字的引用将被 `*tmpl*` 替换。
- en: '`(let ()'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ()'
- en: (define-syntax a (identifier-syntax car))
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax a (identifier-syntax car))
- en: (list (a '(1 2 3)) a)) ![<graphic>](ch2_0.gif) (1 #<procedure>)`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (list (a '(1 2 3)) a)) ![<graphic>](ch2_0.gif) (1 #<procedure>)`
- en: With the first form of `identifier-syntax`, an apparent assignment of the associated
    keyword with `set!` is a syntax violation. The second, more general, form of `identifier-syntax`
    permits the transformer to specify what happens when `set!` is used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `identifier-syntax` 的第一种形式，将关联关键字与 `set!` 的表面赋值是一个语法违例。`identifier-syntax`
    的第二种更一般的形式允许变换器指定在使用 `set!` 时发生的情况。
- en: '`(let ([ls (list 0)])'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([ls (list 0)])'
- en: (define-syntax a
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax a
- en: (identifier-syntax
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (identifier-syntax
- en: '[id (car ls)]'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[id (car ls)]'
- en: '[(set! id e) (set-car! ls e)]))'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[(set! id e) (set-car! ls e)]))'
- en: (let ([before a])
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([before a])
- en: (set! a 1)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (set! a 1)
- en: (list before a ls))) ![<graphic>](ch2_0.gif) (0 1 (1))`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: (list before a ls))) ![<graphic>](ch2_0.gif) (0 1 (1))`
- en: A definition of `identifier-syntax` in terms of `make-variable-transformer`
    is shown on page [307](syntax.html#defn:identifier-syntax).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`identifier-syntax` 的定义以 `make-variable-transformer` 的形式显示在第 [307](syntax.html#defn:identifier-syntax)
    页。'
- en: Section 8.3\. Syntax-Case Transformers
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 8.3 节。语法-Case 变换器
- en: This section describes a more expressive mechanism for creating transformers,
    based on `syntax-case`, a generalized version of `syntax-rules`. This mechanism
    permits arbitrarily complex transformations to be specified, including transformations
    that "bend" lexical scoping in a controlled manner, allowing a much broader class
    of syntactic extensions to be defined. Any transformer that may be defined using
    `syntax-rules` may be rewritten easily to use `syntax-case` instead; in fact,
    `syntax-rules` itself may be defined as a syntactic extension in terms of `syntax-case`,
    as demonstrated within the description of `syntax` below.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了一个更具表现力的机制，用于基于 `syntax-case` 创建变换器，这是 `syntax-rules` 的一个广义版本。这种机制允许指定任意复杂的转换，包括以受控方式“弯曲”词法作用域的转换，从而允许定义更广泛类别的语法扩展。任何可以使用
    `syntax-rules` 定义的变换器都可以轻松地重写为使用 `syntax-case`；实际上，`syntax-rules` 本身可以在 `syntax`
    的描述中以 `syntax-case` 的术语定义为一个语法扩展。
- en: With this mechanism, transformers are procedures of one argument. The argument
    is a *syntax object* representing the form to be processed. The return value is
    a syntax object representing the output form. A syntax object may be any of the
    following.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此机制，转换器是一个参数的过程。该参数是代表要处理的形式的 *syntax 对象*。返回值是代表输出形式的语法对象。语法对象可以是以下任何一种。
- en: a nonpair, nonvector, nonsymbol value,
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非对、非向量、非符号值，
- en: a pair of syntax objects,
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对语法对象，
- en: a vector of syntax objects, or
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法对象的向量，或
- en: a wrapped object.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包装对象。
- en: The *wrap* on a wrapped syntax object contains contextual information about
    a form in addition to its structure. This contextual information is used by the
    expander to maintain lexical scoping. The wrap may also contain information used
    by the implementation to correlate source and object code, e.g., track file, line,
    and character information through the expansion and compilation process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语法对象的 *wrap* 包含有关形式的上下文信息，以及其结构。展开器使用此上下文信息来维护词法作用域。包装还可以包含由实现用于在扩展和编译过程中跟踪文件、行和字符信息的信息，例如跟踪文件、行和字符信息。
- en: The contextual information must be present for all identifiers, which is why
    the definition of syntax object above does not allow symbols unless they are wrapped.
    A syntax object representing an identifier is itself referred to as an identifier;
    thus, the term *identifier* may refer either to the syntactic entity (symbol,
    variable, or keyword) or to the concrete representation of the syntactic entity
    as a syntax object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标识符都必须具有上下文信息，这就是为什么上面语法对象的定义不允许除非它们被包装之外的符号。代表标识符的语法对象本身被称为标识符；因此，术语 *identifier*
    可以指代语法实体（符号、变量或关键字）或作为语法对象的具体表示的语法实体。
- en: Transformers normally destructure their input with `syntax-case` and rebuild
    their output with `syntax`. These two forms alone are sufficient for defining
    many syntactic extensions, including any that can be defined using `syntax-rules`.
    They are described below along with a set of additional forms and procedures that
    provide added functionality.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器通常使用 `syntax-case` 对其输入进行解构，并使用 `syntax` 重新构建其输出。仅这两种形式就足以定义许多语法扩展，包括可以使用
    `syntax-rules` 定义的任何扩展。下面将介绍这两种形式以及一组提供附加功能的其他形式和过程。
- en: '**syntax**: `(syntax-case *expr* (*literal* ...) *clause* ...)`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(syntax-case *expr* (*literal* ...) *clause* ...)`'
- en: '**returns:** see below'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 见下文'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
- en: Each `*literal*` must be an identifier. Each `*clause*` must take one of the
    following two forms.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `*literal*` 必须是标识符。每个 `*clause*` 必须采用以下两种形式之一。
- en: '`(*pattern* *output-expression*)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*pattern* *output-expression*)`'
- en: (*pattern* *fender* *output-expression*)`
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: (*pattern* *fender* *output-expression*)`
- en: '`syntax-case` patterns may be in any of the forms described in Section [8.2](syntax.html#g135).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`syntax-case` 模式可以采用 [8.2](syntax.html#g135) 节中描述的任何形式。'
- en: '`syntax-case` first evaluates `*expr*`, then attempts to match the resulting
    value against the pattern from the first `*clause*`. This value may be any Scheme
    object. If the value matches the pattern and no `*fender*` is present, `*output-expression*`
    is evaluated and its values returned as the values of the `syntax-case` expression.
    If the value does not match the pattern, the value is compared against the next
    clause, and so on. It is a syntax violation if the value does not match any of
    the patterns.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`syntax-case` 首先评估 `*expr*`，然后尝试将结果值与第一个 `*clause*` 的模式匹配。此值可以是任何 Scheme 对象。如果该值与模式匹配，并且没有
    `*fender*` 存在，则评估 `*output-expression*` 并将其值作为 `syntax-case` 表达式的值返回。如果该值与模式不匹配，则将该值与下一个条款进行比较，依此类推。如果该值与任何模式都不匹配，则属于语法违例。'
- en: If the optional `*fender*` is present, it serves as an additional constraint
    on acceptance of a clause. If the value of the `syntax-case` `*expr*` matches
    the pattern for a given clause, the corresponding `*fender*` is evaluated. If
    `*fender*` evaluates to a true value, the clause is accepted; otherwise, the clause
    is rejected as if the input had failed to match the pattern. Fenders are logically
    a part of the matching process, i.e., they specify additional matching constraints
    beyond the basic structure of an expression.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可选的 `*fender*` 存在，则它将作为对条款接受的额外约束。如果 `syntax-case` `*expr*` 的值与给定条款的模式匹配，则会评估相应的
    `*fender*`。如果 `*fender*` 评估为真值，则接受该条款；否则，该条款将被拒绝，就好像输入未能匹配模式一样。Fenders 在逻辑上是匹配过程的一部分，即它们指定了除表达式的基本结构之外的附加匹配约束。
- en: Pattern variables contained within a clause's `*pattern*` are bound to the corresponding
    pieces of the input value within the clause's `*fender*` (if present) and `*output-expression*`.
    Pattern variables occupy the same namespace as program variables and keywords;
    pattern variable bindings created by `syntax-case` can shadow (and be shadowed
    by) program variable and keyword bindings as well as other pattern variable bindings.
    Pattern variables, however, can be referenced only within `syntax` expressions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 子句的 `*pattern*` 中包含的模式变量被绑定到子句的 `*fender*`（如果存在）和 `*output-expression*` 中输入值的相应部分。模式变量占用与程序变量和关键字相同的命名空间；由
    `syntax-case` 创建的模式变量绑定可以遮蔽（并被遮蔽）程序变量和关键字绑定以及其他模式变量绑定。然而，模式变量只能在 `syntax` 表达式中引用。
- en: See the examples following the description of `syntax`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 `syntax` 描述后面的示例。
- en: '**syntax**: `(syntax *template*)`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(syntax *template*)`'
- en: '**syntax**: `#''*template*`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`#''*template*`'
- en: '**returns:** see below'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 请参见下文'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs syntax-case)`，`(rnrs)`'
- en: '`#''*template*` is equivalent to `(syntax *template*)`. The abbreviated form
    is converted into the longer form when a program is read, prior to macro expansion.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`#''*template*` 等同于 `(syntax *template*)`。在程序读取之前，缩写形式会在宏展开之前转换为较长的形式。'
- en: A `syntax` expression is like a `quote` expression except that the values of
    pattern variables appearing within `*template*` are inserted into `*template*`,
    and contextual information associated both with the input and with the template
    is retained in the output to support lexical scoping. A `syntax` `*template*`
    is identical to a `syntax-rules` `*template*` and is treated similarly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`syntax` 表达式类似于 `quote` 表达式，不同之处在于 `*template*` 中出现的模式变量的值被插入到 `*template*`
    中，并且与输入和模板相关的上下文信息在输出中保留以支持词法作用域。`syntax` 的 `*template*` 与 `syntax-rules` 的 `*template*`
    相同，并且被类似地处理。'
- en: List and vector structures within the template become true lists or vectors
    (suitable for direct application of list or vector operations, like `map` or `vector-ref`)
    to the extent that the list or vector structures must be copied to insert the
    values of pattern variables, and empty lists are never wrapped. For example, `#'(x ...)`,
    `#'(a b c)`, `#'()` are all lists if `x`, `a`, `b`, and `c` are pattern variables.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的列表和向量结构变为真实的列表或向量（适用于直接应用列表或向量操作，如 `map` 或 `vector-ref`），因为列表或向量结构必须被复制以插入模式变量的值，并且空列表永远不会被包装。例如，如果
    `x`、`a`、`b` 和 `c` 是模式变量，则 `#'(x ...)`、`#'(a b c)`、`#'()` 都是列表。
- en: The definition of `or` below is equivalent to the one given in Section [8.2](syntax.html#g135)
    except that it employs `syntax-case` and `syntax` in place of `syntax-rules`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `or` 定义等同于 [8.2](syntax.html#g135) 节中给出的定义，只是它使用 `syntax-case` 和 `syntax`
    替代了 `syntax-rules`。
- en: '`(define-syntax or'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax or'
- en: (lambda (x)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda (x)
- en: (syntax-case x ()
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: （语法-案例 x ()
- en: '[(_) #''#f]'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_) #''#f]'
- en: '[(_ e) #''e]'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e) #''e]'
- en: '[(_ e1 e2 e3 ...)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 e3 ...)'
- en: '#''(let ([t e1]) (if t t (or e2 e3 ...)))])))`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(let ([t e1]) (if t t (or e2 e3 ...)))])))`'
- en: In this version, the `lambda` expression that produces the transformer is explicit,
    as are the `syntax` forms in the output part of each clause. Any `syntax-rules`
    form can be expressed with `syntax-case` by making the `lambda` expression and
    `syntax` expressions explicit. This observation leads to the following definition
    of `syntax-rules` in terms of `syntax-case`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，生成转换器的 `lambda` 表达式是显式的，每个子句的输出部分中的 `syntax` 表达式也是显式的。通过使生成的 `lambda`
    表达式和 `syntax` 表达式显式，任何 `syntax-rules` 形式都可以用 `syntax-case` 表达。这一观察结果导致以下关于 `syntax-rules`
    的定义以 `syntax-case` 形式表示。
- en: '`(define-syntax syntax-rules'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax syntax-rules'
- en: (lambda (x)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda (x)
- en: (syntax-case x ()
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: （syntax-case x ()
- en: '[(_ (i ...) ((keyword . pattern) template) ...)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (i ...) ((keyword . pattern) template) ...)'
- en: '#''(lambda (x)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(lambda (x)'
- en: (syntax-case x (i ...)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: （syntax-case x (i ...)
- en: '[(_ . pattern) #''template] ...))])))`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ . pattern) #''template] ...))])))`'
- en: An underscore is used in place of each `keyword` since the first position of
    each `syntax-rules` pattern is always ignored.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 `syntax-rules` 模式的第一个位置总是被忽略，因此在每个 `syntax-rules` 模式中使用下划线代替每个 `keyword`。
- en: Since the `lambda` and `syntax` expressions are implicit in a `syntax-rules`
    form, definitions expressed with `syntax-rules` are often shorter than the equivalent
    definitions expressed with `syntax-case`. The choice of which to use when either
    suffices is a matter of taste, but many transformers that can be written easily
    with `syntax-case` cannot be written easily or at all with `syntax-rules` (see
    Section [8.4](syntax.html#g137)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`lambda`和`syntax`表达式在`syntax-rules`形式中是隐式的，因此用`syntax-rules`表达的定义通常比用`syntax-case`表达的等效定义更短。在两者都足够的情况下选择使用哪一个是一种品味问题，但许多可以轻松用`syntax-case`编写的转换器无法轻松或根本无法用`syntax-rules`编写（请参见第[8.4](syntax.html#g137)节）。
- en: '**procedure**: `(identifier? *obj*)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(identifier? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is an identifier, `#f` otherwise'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is an identifier, `#f` otherwise'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
- en: '`identifier?` is often used within fenders to verify that certain subforms
    of an input form are identifiers, as in the definition of unnamed `let` below.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`identifier?`经常在fender中使用，以验证输入形式的某些子形式是否为标识符，如下面未命名`let`的定义所示。'
- en: '`(define-syntax let'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax let'
- en: (lambda (x)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (define ids?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (define ids?
- en: (lambda (ls)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (or (null? ls)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: (or (null? ls)
- en: (and (identifier? (car ls))
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (and (identifier? (car ls))
- en: (ids? (cdr ls))))))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: (ids? (cdr ls))))))
- en: (syntax-case x ()
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ ((i e) ...) b1 b2 ...)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ((i e) ...) b1 b2 ...)'
- en: (ids? #'(i ...))
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: (ids? #'(i ...))
- en: '#''((lambda (i ...) b1 b2 ...) e ...)])))`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#''((lambda (i ...) b1 b2 ...) e ...)])))`'
- en: Syntactic extensions ordinarily take the form `(*keyword* *subform* ...)`, but
    the `syntax-case` system permits them to take the form of singleton identifiers
    as well. For example, the keyword `pcar` in the expression below may be used both
    as an identifier (in which case it expands into a call to `car`) or as a structured
    form (in which case it expands into a call to `set-car!`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，语法扩展的形式为`(*keyword* *subform* ...)`，但`syntax-case`系统也允许它们采用单例标识符的形式。例如，下面表达式中的关键字`pcar`可以用作标识符（在这种情况下，它会扩展为对`car`的调用），也可以用作结构化形式（在这种情况下，它会扩展为对`set-car!`的调用）。
- en: '`(let ([p (cons 0 #f)])'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([p (cons 0 #f)])'
- en: (define-syntax pcar
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax pcar
- en: (lambda (x)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[_ (identifier? x) #''(car p)]'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[_ (identifier? x) #''(car p)]'
- en: '[(_ e) #''(set-car! p e)])))'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e) #''(set-car! p e)])))'
- en: (let ([a pcar])
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([a pcar])
- en: (pcar 1)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (pcar 1)
- en: (list a pcar))) ![<graphic>](ch2_0.gif) (0 1)`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: (list a pcar))) ![<graphic>](ch2_0.gif) (0 1)`
- en: The fender `(identifier? x)` is used to recognize the singleton identifier case.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: fender `(identifier? x)`用于识别单例标识符情况。
- en: '**procedure**: `(free-identifier=? *identifier[1]* *identifier[2]*)`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(free-identifier=? *identifier[1]* *identifier[2]*)`'
- en: '**procedure**: `(bound-identifier=? *identifier[1]* *identifier[2]*)`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(bound-identifier=? *identifier[1]* *identifier[2]*)`'
- en: '**returns:** see below'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** see below'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
- en: Symbolic names alone do not distinguish identifiers unless the identifiers are
    to be used only as symbolic data. The predicates `free-identifier=?` and `bound-identifier=?`
    are used to compare identifiers according to their *intended use* as free references
    or bound identifiers in a given context.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的符号名称无法区分标识符，除非这些标识符仅用作符号数据。谓词`free-identifier=?`和`bound-identifier=?`用于根据在给定上下文中作为自由引用或绑定标识符的*预期用途*来比较标识符。
- en: '`free-identifier=?` is used to determine whether two identifiers would be equivalent
    if they were to appear as free identifiers in the output of a transformer. Because
    identifier references are lexically scoped, this means `(free-identifier=? *id[1]* *id[2]*)`
    is true if and only if the identifiers `*id[1]*` and `*id[2]*` refer to the same
    binding. (For this comparison, two like-named identifiers are assumed to have
    the same binding if neither is bound.) Literal identifiers (auxiliary keywords)
    appearing in `syntax-case` patterns (such as `else` in `case` and `cond`) are
    matched with `free-identifier=?`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`free-identifier=?`用于确定两个标识符是否等效，如果它们作为转换器输出中的自由标识符出现，则它们是否等效。由于标识符引用是词法作用域的，这意味着当且仅当标识符`*id[1]*`和`*id[2]*`指向相同绑定时，`(free-identifier=? *id[1]* *id[2]*)`为真。
    （对于此比较，假定如果没有绑定，则假定两个同名标识符具有相同的绑定。）在`syntax-case`模式中出现的文字标识符（辅助关键字）（例如`case`和`cond`中的`else`）与`free-identifier=?`匹配。'
- en: Similarly, `bound-identifier=?` is used to determine whether two identifiers
    would be equivalent if they were to appear as bound identifiers in the output
    of a transformer. In other words, if `bound-identifier=?` returns true for two
    identifiers, a binding for one will capture references to the other within its
    scope. In general, two identifiers are `bound-identifier=?` only if both are present
    in the original program or both are introduced by the same transformer application
    (perhaps implicitly---see `datum->syntax`). `bound-identifier=?` can be used for
    detecting duplicate identifiers in a binding construct or for other preprocessing
    of a binding construct that requires detecting instances of the bound identifiers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`bound-identifier=?` 用于确定两个标识符是否等效，如果它们作为转换器输出中的绑定标识符出现，那么它们将是等效的。换句话说，如果两个标识符的
    `bound-identifier=?` 返回 true，则一个标识符的绑定将在其范围内捕获对另一个标识符的引用。一般来说，只有在原始程序中同时存在两个标识符或者两个标识符由相同的转换器应用引入时（可能是隐式的---参见
    `datum->syntax`），两个标识符才是 `bound-identifier=?`。`bound-identifier=?` 可用于检测绑定结构中的重复标识符或者需要检测绑定结构中的绑定标识符实例的其他预处理。
- en: The definition below is equivalent to the earlier definition of a simplified
    version of `cond` with `syntax-rules`, except that `else` is recognized via an
    explicit call to `free-identifier?` within a fender rather than via inclusion
    in the literals list.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的定义等效于使用 `syntax-rules` 简化版本的 `cond` 的早期定义，只是 `else` 是通过在 fender 中显式调用 `free-identifier?`
    来识别的，而不是通过包含在文字列表中。
- en: '`(define-syntax cond'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax cond'
- en: (lambda (x)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ (e0 e1 e2 ...))'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (e0 e1 e2 ...))'
- en: (and (identifier? #'e0) (free-identifier=? #'e0 #'else))
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: (and (identifier? #'e0) (free-identifier=? #'e0 #'else))
- en: '#''(begin e1 e2 ...)]'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(begin e1 e2 ...)]'
- en: '[(_ (e0 e1 e2 ...)) #''(if e0 (begin e1 e2 ...))]'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (e0 e1 e2 ...)) #''(if e0 (begin e1 e2 ...))]'
- en: '[(_ (e0 e1 e2 ...) c1 c2 ...)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (e0 e1 e2 ...) c1 c2 ...)'
- en: '#''(if e0 (begin e1 e2 ...) (cond c1 c2 ...))])))`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(if e0 (begin e1 e2 ...) (cond c1 c2 ...))])))`'
- en: With either definition of `cond`, `else` is not recognized as an auxiliary keyword
    if an enclosing lexical binding for `else` exists. For example,
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种 `cond` 定义，如果存在包围 `else` 的词法绑定，则 `else` 不会被识别为辅助关键字。例如，
- en: '`(let ([else #f])'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([else #f])'
- en: (cond [else (write "oops")]))`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (cond [else (write "oops")]))`
- en: does *not* write `"oops"`, since `else` is bound lexically and is therefore
    not the same `else` that appears in the definition of `cond`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不会写 `"oops"`，因为 `else` 在词法上是绑定的，因此不是出现在 `cond` 定义中的相同 `else`。
- en: The following definition of unnamed `let` uses `bound-identifier=?` to detect
    duplicate identifiers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下未命名 `let` 的定义使用 `bound-identifier=?` 来检测重复标识符。
- en: '`(define-syntax let'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax let'
- en: (lambda (x)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (define ids?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: (define ids?
- en: (lambda (ls)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (or (null? ls)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (or (null? ls)
- en: (and (identifier? (car ls)) (ids? (cdr ls))))))
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: (and (identifier? (car ls)) (ids? (cdr ls))))))
- en: (define unique-ids?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: (define unique-ids?
- en: (lambda (ls)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (or (null? ls)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: (or (null? ls)
- en: (and (not (memp
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (memp
- en: (lambda (x) (bound-identifier=? x (car ls)))
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) (bound-identifier=? x (car ls)))
- en: (cdr ls)))
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr ls)))
- en: (unique-ids? (cdr ls))))))
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (unique-ids? (cdr ls))))))
- en: (syntax-case x ()
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ ((i e) ...) b1 b2 ...)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ((i e) ...) b1 b2 ...)'
- en: (and (ids? #'(i ...)) (unique-ids? #'(i ...)))
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: (and (ids? #'(i ...)) (unique-ids? #'(i ...)))
- en: '#''((lambda (i ...) b1 b2 ...) e ...)])))`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '#''((lambda (i ...) b1 b2 ...) e ...)])))`'
- en: With the definition of `let` above, the expression
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的 `let` 定义，表达式
- en: '`(let ([a 3] [a 4]) (+ a a))`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([a 3] [a 4]) (+ a a))`'
- en: is a syntax violation, whereas
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个语法违例，而
- en: '`(let ([a 0])'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([a 0])'
- en: (let-syntax ([dolet (lambda (x)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (let-syntax ([dolet (lambda (x)
- en: (syntax-case x ()
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ b)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ b)'
- en: '#''(let ([a 3] [b 4]) (+ a b))]))])'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(let ([a 3] [b 4]) (+ a b))]))])'
- en: (dolet a)))`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: (dolet a)))`
- en: evaluates to `7` since the identifier `a` introduced by `dolet` and the identifier
    `a` extracted from the input form are not `bound-identifier=?`. Since both occurrences
    of `a`, however, if left as free references, would refer to the same binding for
    `a`, `free-identifier=?` would not distinguish them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 评估为 `7`，因为由 `dolet` 引入的标识符 `a` 和从输入形式中提取的标识符 `a` 不是 `bound-identifier=?`。然而，如果两个
    `a` 的出现都作为自由引用保留，它们将引用相同的 `a` 绑定，`free-identifier=?` 将不会区分它们。
- en: Two identifiers that are `free-identifier=?` may not be `bound-identifier=?`.
    An identifier introduced by a transformer may refer to the same enclosing binding
    as an identifier not introduced by the transformer, but an introduced binding
    for one will not capture references to the other. On the other hand, identifiers
    that are `bound-identifier=?` are `free-identifier=?`, as long as the identifiers
    have valid bindings in the context where they are compared.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 两个被 `free-identifier=?` 的标识符可能不会被 `bound-identifier=?`。由转换器引入的标识符可能引用与未由转换器引入的标识符相同的封闭绑定，但一个标识符的引入绑定不会捕获对另一个标识符的引用。另一方面，被
    `bound-identifier=?` 的标识符是 `free-identifier=?` 的，只要这些标识符在进行比较的上下文中具有有效的绑定。
- en: '**syntax**: `(with-syntax ((*pattern* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(with-syntax ((*pattern* *expr*) ...) *body[1]* *body[2]* ...)`'
- en: '**returns:** the values of the final body expression'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 最终主体表达式的值'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
- en: It is sometimes useful to construct a transformer's output in separate pieces,
    then put the pieces together. `with-syntax` facilitates this by allowing the creation
    of local pattern bindings.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将转换器的输出分开构造，然后将这些部分组合在一起是很有用的。`with-syntax` 通过允许创建本地模式绑定来实现这一点。
- en: '`*pattern*` is identical in form to a `syntax-case` pattern. The value of each
    `*expr*` is computed and destructured according to the corresponding `*pattern*`,
    and pattern variables within the `*pattern*` are bound as with `syntax-case` to
    appropriate portions of the value within the body `*body[1]* *body[2]* ...`, which
    is processed and evaluated like a `lambda` body.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`*pattern*` 在形式上与 `syntax-case` 的模式相同。每个 `*expr*` 的值根据相应的 `*pattern*` 进行计算和解构，而
    `*pattern*` 中的模式变量会像在 `syntax-case` 中一样绑定到值的适当部分，在被处理和评估的 `*body[1]* *body[2]* ...`
    中，就像处理和评估 `lambda` 的主体一样。'
- en: '`with-syntax` may be defined as a syntactic extension in terms of `syntax-case`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-syntax` 可以被定义为在 `syntax-case` 中的一个语法扩展。'
- en: '`(define-syntax with-syntax'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax with-syntax'
- en: (lambda (x)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ ((p e) ...) b1 b2 ...)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ((p e) ...) b1 b2 ...)'
- en: '#''(syntax-case (list e ...) ()'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(syntax-case (list e ...) ()'
- en: '[(p ...) (let () b1 b2 ...)])])))`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[(p ...) (let () b1 b2 ...)])])))`'
- en: The following definition of full `cond` demonstrates the use of `with-syntax`
    to support transformers that employ recursion internally to construct their output.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下面对完整的 `cond` 的定义演示了使用 `with-syntax` 来支持在内部使用递归构造输出的转换器。
- en: '`(define-syntax cond'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax cond'
- en: (lambda (x)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ c1 c2 ...)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ c1 c2 ...)'
- en: (let f ([c1 #'c1] [cmore #'(c2 ...)])
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([c1 #'c1] [cmore #'(c2 ...)])
- en: (if (null? cmore)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? cmore)
- en: (syntax-case c1 (else =>)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case c1 (else =>)
- en: '[(else e1 e2 ...) #''(begin e1 e2 ...)]'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[(else e1 e2 ...) #''(begin e1 e2 ...)]'
- en: '[(e0) #''(let ([t e0]) (if t t))]'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[(e0) #''(let ([t e0]) (if t t))]'
- en: '[(e0 => e1) #''(let ([t e0]) (if t (e1 t)))]'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[(e0 => e1) #''(let ([t e0]) (if t (e1 t)))]'
- en: '[(e0 e1 e2 ...) #''(if e0 (begin e1 e2 ...))])'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[(e0 e1 e2 ...) #''(if e0 (begin e1 e2 ...))])'
- en: (with-syntax ([rest (f (car cmore) (cdr cmore))])
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: (with-syntax ([rest (f (car cmore) (cdr cmore))])
- en: (syntax-case c1 (=>)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case c1 (=>)
- en: '[(e0) #''(let ([t e0]) (if t t rest))]'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[(e0) #''(let ([t e0]) (if t t rest))]'
- en: '[(e0 => e1) #''(let ([t e0]) (if t (e1 t) rest))]'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[(e0 => e1) #''(let ([t e0]) (if t (e1 t) rest))]'
- en: '[(e0 e1 e2 ...)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[(e0 e1 e2 ...)'
- en: '#''(if e0 (begin e1 e2 ...) rest)]))))])))`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(if e0 (begin e1 e2 ...) rest)]))))])))`'
- en: '**syntax**: `(quasisyntax *template* ...)`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(quasisyntax *template* ...)`'
- en: '**syntax**: `#`*template*`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `#`*template*`'
- en: '**syntax**: `(unsyntax *template* ...)`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(unsyntax *template* ...)`'
- en: '**syntax**: `#,*template*`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `#,*template*`'
- en: '**syntax**: `(unsyntax-splicing *template* ...)`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(unsyntax-splicing *template* ...)`'
- en: '**syntax**: `#,@*template*`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `#,@*template*`'
- en: '**returns:** see below'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 见下文'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
- en: '`#`*template*` is equivalent to `(quasisyntax *template*)`, while `#,*template*`
    is equivalent to `(unsyntax *template*)`, and `#,@*template*` to `(unsyntax-splicing *template*)`.
    The abbreviated forms are converted into the longer forms when the program is
    read, prior to macro expansion.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`#`*template*` 等同于 `(quasisyntax *template*)`，而 `#,*template*` 等同于 `(unsyntax *template*)`，`#,@*template*`
    等同于 `(unsyntax-splicing *template*)`。在程序被读取之前，缩写形式会被转换为更长的形式，然后进行宏展开。'
- en: '`quasisyntax` is similar to `syntax`, but it allows parts of the quoted text
    to be evaluated, in a manner similar to `quasiquote` (Section [6.1](objects.html#g107)).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`quasisyntax` 类似于 `syntax`，但它允许对引用文本的部分进行评估，类似于 `quasiquote`（第 [6.1](objects.html#g107)
    节）。'
- en: Within a `quasisyntax` `*template*`, subforms of `unsyntax` and `unsyntax-splicing`
    forms are evaluated, and everything else is treated as ordinary template material,
    as with `syntax`. The value of each `unsyntax` subform is inserted into the output
    in place of the `unsyntax` form, while the value of each `unsyntax-splicing` subform
    is spliced into the surrounding list or vector structure. `unsyntax` and `unsyntax-splicing`
    are valid only within `quasisyntax` expressions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quasisyntax` `*template*`中，`unsyntax`和`unsyntax-splicing`形式的子表达式会被评估，而其他内容则被视为普通的模板材料，就像`syntax`一样。每个`unsyntax`子表达式的值会被插入到输出中，取代`unsyntax`形式，而每个`unsyntax-splicing`子表达式的值会被插入到周围的列表或向量结构中。`unsyntax`和`unsyntax-splicing`只在`quasisyntax`表达式中有效。
- en: '`quasisyntax` expressions may be nested, with each `quasisyntax` introducing
    a new level of syntax quotation and each `unsyntax` or `unsyntax-splicing` taking
    away a level of quotation. An expression nested within *n* `quasisyntax` expressions
    must be within *n* `unsyntax` or `unsyntax-splicing` expressions to be evaluated.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`quasisyntax`表达式可以嵌套，每个`quasisyntax`引入一个新的语法引用级别，每个`unsyntax`或`unsyntax-splicing`则减少一个引用级别。在*n*个`quasisyntax`表达式中嵌套的表达式必须在*n*个`unsyntax`或`unsyntax-splicing`表达式中才能被评估。'
- en: '`quasisyntax` can be used in place of `with-syntax` in many cases. For example,
    the following definition of `case` employs `quasisyntax` to construct its output,
    using internal recursion in a manner similar to the definition of `cond` given
    under the description of `with-syntax` above.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`quasisyntax`可以在许多情况下替代`with-syntax`使用。例如，下面的`case`定义利用`quasisyntax`构建其输出，类似于上面`with-syntax`描述中给出的`cond`定义中使用内部递归的方式。'
- en: '`(define-syntax case'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax case'
- en: (lambda (x)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ e c1 c2 ...)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e c1 c2 ...)'
- en: '#`(let ([t e])'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '#`(let ([t e])'
- en: '#,(let f ([c1 #''c1] [cmore #''(c2 ...)])'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '#,(let f ([c1 #''c1] [cmore #''(c2 ...)])'
- en: (if (null? cmore)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? cmore)
- en: (syntax-case c1 (else)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case c1 (else)
- en: '[(else e1 e2 ...) #''(begin e1 e2 ...)]'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[(else e1 e2 ...) #''(begin e1 e2 ...)]'
- en: '[((k ...) e1 e2 ...)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[((k ...) e1 e2 ...)'
- en: '#''(if (memv t ''(k ...)) (begin e1 e2 ...))])'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(if (memv t ''(k ...)) (begin e1 e2 ...))])'
- en: (syntax-case c1 ()
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case c1 ()
- en: '[((k ...) e1 e2 ...)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[((k ...) e1 e2 ...)'
- en: '#`(if (memv t ''(k ...))'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '#`(if (memv t ''(k ...))'
- en: (begin e1 e2 ...)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: (begin e1 e2 ...)
- en: '#,(f (car cmore) (cdr cmore)))]))))])))`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '#,(f (car cmore) (cdr cmore)))]))))])))`'
- en: '`unsyntax` and `unsyntax-splicing` forms that contain zero or more than one
    subform are valid only in splicing (list or vector) contexts. `(unsyntax *template* ...)`
    is equivalent to `(unsyntax *template*) ...`, and `(unsyntax-splicing *template* ...)`
    is equivalent to `(unsyntax-splicing *template*) ...`. These forms are primarily
    useful as intermediate forms in the output of the `quasisyntax` expander. They
    support certain useful nested quasiquotation (`quasisyntax`) idioms [[3](bibliography.html#g221)],
    such as `#,@#,@`, which has the effect of a doubly indirect splicing when used
    within a doubly nested and doubly evaluated `quasisyntax` expression, as with
    the nested `quasiquote` examples shown in Section [6.1](objects.html#g107).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 包含零个或多个子表达式的`unsyntax`和`unsyntax-splicing`形式只在拼接（列表或向量）上下文中有效。`(unsyntax *template* ...)`等同于`(unsyntax *template*) ...`，`(unsyntax-splicing *template* ...)`等同于`(unsyntax-splicing *template*) ...`。这些形式主要用作`quasisyntax`扩展器的输出中的中间形式。它们支持某些有用的嵌套准引用（`quasisyntax`）习惯用法[[3](bibliography.html#g221)]，例如`#,@#,@`，在双重嵌套和双重评估的`quasisyntax`表达式中使用时，具有双重间接拼接的效果，就像在第[6.1](objects.html#g107)节中显示的嵌套`quasiquote`示例中一样。
- en: '`unsyntax` and `unsyntax-splicing` are auxiliary keywords for `quasisyntax`.
    It is a syntax violation to reference these identifiers except in contexts where
    they are recognized as auxiliary keywords.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsyntax`和`unsyntax-splicing`是`quasisyntax`的辅助关键字。在除了被识别为辅助关键字的上下文之外引用这些标识符是语法错误。'
- en: '**procedure**: `(make-variable-transformer *procedure*)`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-variable-transformer *procedure*)`'
- en: '**returns:** a variable transformer'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** a variable transformer'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
- en: As described in the lead-in to this section, transformers may simply be procedures
    that accept one argument, a syntax object representing the input form, and return
    a new syntax object representing the output form. The form passed to a transformer
    usually represents a parenthesized form whose first subform is the keyword bound
    to the transformer or just the keyword itself. `make-variable-transformer` may
    be used to convert a procedure into a special kind of transformer to which the
    expander also passes `set!` forms in which the keyword appears just after the
    `set!` keyword, as if it were a variable to be assigned. This allows the programmer
    to control what happens when the keyword appears in such contexts. The argument,
    `*procedure*`, should accept one argument.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([ls (list 0)])'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax a
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: (make-variable-transformer
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[id (identifier? #''id) #''(car ls)]'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[(set! _ e) #''(set-car! ls e)]'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e ...) #''((car ls) e ...)]))))'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: (let ([before a])
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: (set! a 1)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: (list before a ls))) ![<graphic>](ch2_0.gif) (0 1 (1))`
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: This syntactic abstraction can be defined more succinctly using `identifier-syntax`,
    as shown in Section [8.2](syntax.html#g135), but `make-variable-transformer` can
    be used to create transformers that perform arbitrary computations, while `identifier-syntax`
    is limited to simple term rewriting, like `syntax-rules`. `identifier-syntax`
    can be defined in terms of `make-variable-transformer`, as shown below.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax identifier-syntax'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x (set!)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '#''(lambda (x)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[id (identifier? #''id) #''e]'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ x (... ...)) #''(e x (... ...))]))]'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ (id exp1) ((set! var val) exp2))'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: (and (identifier? #'id) (identifier? #'var))
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '#''(make-variable-transformer'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x (set!)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[(set! var val) #''exp2]'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[(id x (... ...)) #''(exp1 x (... ...))]'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[id (identifier? #''id) #''exp1])))])))`'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(syntax->datum *obj*)`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*obj*` stripped of syntactic information'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `syntax->datum` strips all syntactic information from a syntax
    object and returns the corresponding Scheme "datum." Identifiers stripped in this
    manner are converted to their symbolic names, which can then be compared with
    `eq?`. Thus, a predicate `symbolic-identifier=?` might be defined as follows.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`(define symbolic-identifier=?'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (syntax->datum x)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: (syntax->datum y))))`
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Two identifiers that are `free-identifier=?` need not be `symbolic-identifier=?`:
    two identifiers that refer to the same binding usually have the same name, but
    the `rename` and `prefix` subforms of the library''s `import` form (page [345](libraries.html#desc:import))
    may result in two identifiers with different names but the same binding.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(datum->syntax *template-identifier* *obj*)`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a syntax object'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '`datum->syntax` constructs a syntax object from `*obj*` that contains the same
    contextual information as `*template-identifier*`, with the effect that the syntax
    object behaves as if it were introduced into the code when `*template-identifier*`
    was introduced. The template identifier is often the keyword of an input form,
    extracted from the form, and the object is often a symbol naming an identifier
    to be constructed.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`datum->syntax` 从 `*template-identifier*` 中构造一个语法对象，其中包含与 `*template-identifier*`
    相同的上下文信息，使得语法对象的行为就像在引入 `*template-identifier*` 时将其引入代码中一样。模板标识符通常是从输入形式中提取的关键字，而对象通常是命名要构造的标识符的符号。'
- en: '`datum->syntax` allows a transformer to "bend" lexical scoping rules by creating
    *implicit identifiers* that behave as if they were present in the input form,
    thus permitting the definition of syntactic extensions that introduce visible
    bindings for or references to identifiers that do not appear explicitly in the
    input form. For example, we can define a `loop` expression that binds the variable
    `break` to an escape procedure within the loop body.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`datum->syntax` 允许转换器通过创建*隐式标识符*来“弯曲”词法作用域规则，使其行为就像它们存在于输入形式中一样，从而允许定义引入可见绑定或引用的语法扩展，这些绑定或引用在输入形式中并未明确出现。例如，我们可以定义一个
    `loop` 表达式，将变量 `break` 绑定到循环体内的一个跳出过程中。'
- en: '`(define-syntax loop'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax loop'
- en: (lambda (x)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(k e ...)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[(k e ...)'
- en: (with-syntax ([break (datum->syntax #'k 'break)])
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: (with-syntax ([break (datum->syntax #'k 'break)])
- en: '#''(call/cc'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(call/cc'
- en: (lambda (break)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (break)
- en: (let f () e ... (f)))))])))
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: (let f () e ... (f)))))])))
- en: (let ([n 3] [ls '()])
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([n 3] [ls '()])
- en: (loop
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: (loop
- en: (if (= n 0) (break ls))
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0) (break ls))
- en: (set! ls (cons 'a ls))
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: (set! ls (cons 'a ls))
- en: (set! n (- n 1)))) ![<graphic>](ch2_0.gif) (a a a)`
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: (set! n (- n 1)))) ![<graphic>](ch2_0.gif) (a a a)`
- en: Were we to define `loop` as
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `loop` 定义为
- en: '`(define-syntax loop'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax loop'
- en: (lambda (x)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ e ...)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e ...)'
- en: '#''(call/cc'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(call/cc'
- en: (lambda (break)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (break)
- en: (let f () e ... (f))))])))`
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: (let f () e ... (f))))])))`
- en: the variable `break` would not be visible in `e ...`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `break` 在 `e ...` 中将不可见。
- en: It is also useful for `*obj*` to represent an arbitrary Scheme form, as demonstrated
    by the following definition of `include`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `*obj*` 来说，它也可以表示任意的 Scheme 表单，正如下面的 `include` 定义所示。
- en: '`(define-syntax include'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax include'
- en: (lambda (x)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (define read-file
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: (define read-file
- en: (lambda (fn k)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (fn k)
- en: (let ([p (open-input-file fn)])
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([p (open-input-file fn)])
- en: (let f ([x (read p)])
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([x (read p)])
- en: (if (eof-object? x)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: (if (eof-object? x)
- en: (begin (close-port p) '())
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: (begin (close-port p) '())
- en: (cons (datum->syntax k x) (f (read p))))))))
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (datum->syntax k x) (f (read p))))))))
- en: (syntax-case x ()
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(k filename)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[(k filename)'
- en: (let ([fn (syntax->datum #'filename)])
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([fn (syntax->datum #'filename)])
- en: (with-syntax ([(expr ...) (read-file fn #'k)])
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: (with-syntax ([(expr ...) (read-file fn #'k)])
- en: '#''(begin expr ...)))])))`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(begin expr ...)))])))`'
- en: '`(include "filename")` expands into a `begin` expression containing the forms
    found in the file named by `"filename"`. For example, if the file `f-def.ss` contains
    the expression `(define f (lambda () x))`, the expression'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`(include "filename")` 展开为包含由 `"filename"` 命名的文件中找到的形式的 `begin` 表达式。例如，如果文件
    `f-def.ss` 包含表达式 `(define f (lambda () x))`，则表达式'
- en: '`(let ([x "okay"])'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x "okay"])'
- en: (include "f-def.ss")
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: (include "f-def.ss")
- en: (f))`
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: (f))`
- en: evaluates to `"okay"`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 评估为 `"okay"`.
- en: The definition of `include` uses `datum->syntax` to convert the objects read
    from the file into syntax objects in the proper lexical context, so that identifier
    references and definitions within those expressions are scoped where the `include`
    form appears.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 的定义使用 `datum->syntax` 将从文件中读取的对象转换为适当词法上下文中的语法对象，因此在这些表达式中的标识符引用和定义在
    `include` 形式出现的地方被作用域化。'
- en: '**procedure**: `(generate-temporaries *list*)`'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(generate-temporaries *list*)`'
- en: '**returns:** a list of distinct generated identifiers'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** a list of distinct generated identifiers'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
- en: Transformers can introduce a fixed number of identifiers into their output by
    naming each identifier. In some cases, however, the number of identifiers to be
    introduced depends upon some characteristic of the input expression. A straightforward
    definition of `letrec`, for example, requires as many temporary identifiers as
    there are binding pairs in the input expression. The procedure `generate-temporaries`
    is used to construct lists of temporary identifiers.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '`*list*` may be any list; its contents are not important. The number of temporaries
    generated is the number of elements in `*list*`. Each temporary is guaranteed
    to be different from all other identifiers.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: A definition of `letrec` that uses `generate-temporaries` is shown below.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax letrec'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((i e) ...) b1 b2 ...)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: (with-syntax ([(t ...) (generate-temporaries #'(i ...))])
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '#''(let ([i #f] ...)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: (let ([t e] ...)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: (set! i t)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: (let () b1 b2 ...))))])))`
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Any transformer that uses `generate-temporaries` in this fashion can be rewritten
    to avoid using it, albeit with a loss of clarity. The trick is to use a recursively
    defined intermediate form that generates one temporary per expansion step and
    completes the expansion after enough temporaries have been generated. Here is
    a definition of `let-values` (page [99](binding.html#desc:let-values)) that uses
    this technique to support multiple sets of bindings.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax let-values'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ () f1 f2 ...) (let () f1 f2 ...)]'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((fmls1 expr1) (fmls2 expr2) ...) f1 f2 ...)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: (lvhelp fmls1 () () expr1 ((fmls2 expr2) ...) (f1 f2 ...))]))
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax lvhelp
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ (x1 . fmls) (x ...) (t ...) e m b)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: (lvhelp fmls (x ... x1) (t ... tmp) e m b)]
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ () (x ...) (t ...) e m b)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () e)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (t ...)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: (let-values m (let ([x t] ...) . b))))]
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ xr (x ...) (t ...) e m b)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () e)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (t ... . tmpr)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: (let-values m (let ([x t] ... [xr tmpr]) . b))))]))`
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `lvhelp` is complicated by the need to evaluate all of
    the right-hand-side expressions before creating any of the bindings and by the
    need to support improper formals lists.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Section 8.4\. Examples
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section presents a series of illustrative syntactic extensions defined
    with either `syntax-rules` or `syntax-case`, starting with a few simple but useful
    syntactic extensions and ending with a fairly complex mechanism for defining structures
    with automatically generated constructors, predicates, field accessors, and field
    setters.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: The simplest example in this section is the following definition of `rec`. `rec`
    is a syntactic extension that permits internally recursive anonymous (not externally
    named) procedures to be created with minimal effort.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax rec'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ x e) (letrec ([x e]) x)]))'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: (map (rec sum
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: (if (= x 0)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: (+ x (sum (- x 1))))))
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '''(0 1 2 3 4 5)) ![<graphic>](ch2_0.gif) (0 1 3 6 10 15)`'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Using `rec`, we can define the full `let` (both unnamed and named) as follows.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax let'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x e) ...) b1 b2 ...)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x ...) b1 b2 ...) e ...)]
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ f ((x e) ...) b1 b2 ...)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: ((rec f (lambda (x ...) b1 b2 ...)) e ...)]))`
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: We can also define `let` directly in terms of `letrec`, although the definition
    is a bit less clear.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax let'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x e) ...) b1 b2 ...)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x ...) b1 b2 ...) e ...)]
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ f ((x e) ...) b1 b2 ...)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: ((letrec ([f (lambda (x ...) b1 b2 ...)]) f) e ...)]))`
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: These definitions rely upon the fact that the first pattern cannot match a named
    `let`, since the first subform of a named `let` must be an identifier, not a list
    of bindings. The following definition uses a fender to make this check more robust.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax let'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x e) ...) b1 b2 ...)'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '#''((lambda (x ...) b1 b2 ...) e ...)]'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ f ((x e) ...) b1 b2 ...)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: (identifier? #'f)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '#''((rec f (lambda (x ...) b1 b2 ...)) e ...)])))`'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: With the fender, we can even put the clauses in the opposite order.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax let'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ f ((x e) ...) b1 b2 ...)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: (identifier? #'f)
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '#''((rec f (lambda (x ...) b1 b2 ...)) e ...)]'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x e) ...) b1 b2 ...)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '#''((lambda (x ...) b1 b2 ...) e ...)])))`'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: To be completely robust, the `ids?` and `unique-ids?` checks employed in the
    definition of unnamed `let` in Section [8.3](syntax.html#g136) should be employed
    here as well.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Both variants of `let` are easily described by simple one-line patterns, but
    `do` requires a bit more work. The precise syntax of `do` cannot be expressed
    directly with a single pattern because some of the bindings in a `do` expression's
    binding list may take the form `(var val)` while others take the form `(var val update)`.
    The following definition of `do` uses `syntax-case` internally to parse the bindings
    separately from the overall form.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax do'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ (binding ...) (test res ...) expr ...)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: (with-syntax ([((var val update) ...)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: (map (lambda (b)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case b ()
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[(var val) #''(var val var)]'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[(var val update) #''(var val update)]))'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '#''(binding ...))])'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '#''(let doloop ([var val] ...)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: (if test
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: (begin (if #f #f) res ...)
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: (begin expr ... (doloop update ...)))))])))`
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: The odd-looking expression `(if #f #f)` is inserted before the result expressions
    `res ...` in case no result expressions are provided, since `begin` requires at
    least one subexpression. The value of `(if #f #f)` is unspecified, which is what
    we want since the value of `do` is unspecified if no result expressions are provided.
    At the expense of a bit more code, we could use `syntax-case` to determine whether
    any result expressions are provided and to produce a loop with either a one- or
    two-armed `if` as appropriate. The resulting expansion would be cleaner but semantically
    equivalent.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in Section [8.2](syntax.html#g135), ellipses lose their special
    meaning within templates of the form `(... *template*)`. This fact allows syntactic
    extensions to expand into syntax definitions containing ellipses. This usage is
    illustrated by the definition below of `be-like-begin`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如[8.2](syntax.html#g135)节中提到的，省略号在形式为`(... *template*)`的模板中失去了特殊含义。这个事实允许语法扩展扩展为包含省略号的语法定义。下面的`be-like-begin`的定义说明了这种用法。
- en: '`(define-syntax be-like-begin'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax be-like-begin'
- en: (syntax-rules ()
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ name)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ name)'
- en: (define-syntax name
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax name
- en: (syntax-rules ()
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ e0 e1 (... ...))'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e0 e1 (... ...))'
- en: (begin e0 e1 (... ...))]))]))`
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: (begin e0 e1 (... ...))]))]))`
- en: With `be-like-begin` defined in this manner, `(be-like-begin sequence)` has
    the same effect as the following definition of `sequence`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义`be-like-begin`，`(be-like-begin sequence)`的效果与以下`sequence`的定义相同。
- en: '`(define-syntax sequence'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax sequence'
- en: (syntax-rules ()
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ e0 e1 ...) (begin e0 e1 ...)]))`'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e0 e1 ...) (begin e0 e1 ...)]))`'
- en: 'That is, a `sequence` form becomes equivalent to a `begin` form so that, for
    example:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`sequence`形式变得等同于`begin`形式，例如：
- en: '`(sequence (display "Say what?") (newline))`'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`(sequence (display "Say what?") (newline))`'
- en: prints "Say what?" followed by a newline.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 输出"说什么？"后跟一个换行符。
- en: 'The following example shows how one might restrict `if` expressions within
    a given expression to require the "else" (alternative) subexpression by defining
    a local `if` in terms of the built-in `if`. Within the body of the `let-syntax`
    binding below, two-armed `if` works as always:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何通过在给定表达式中定义一个本地`if`，将`if`表达式限制在需要"else"（替代）子表达式的情况下。在下面的`let-syntax`绑定的主体中，双臂`if`像往常一样工作：
- en: '`(let-syntax ([if (lambda (x)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let-syntax ([if (lambda (x)'
- en: (syntax-case x ()
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ e1 e2 e3)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 e3)'
- en: '#''(if e1 e2 e3)]))])'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(if e1 e2 e3)]))])'
- en: (if (< 1 5) 2 3)) ![<graphic>](ch2_0.gif) 2`
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< 1 5) 2 3)) ![<graphic>](ch2_0.gif) 2`
- en: but one-armed if results in a syntax error.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 但是单臂if会导致语法错误。
- en: '`(let-syntax ([if (lambda (x)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let-syntax ([if (lambda (x)'
- en: (syntax-case x ()
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(_ e1 e2 e3)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e1 e2 e3)'
- en: '#''(if e1 e2 e3)]))])'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(if e1 e2 e3)]))])'
- en: (if (< 1 5) 2)) ![<graphic>](ch2_0.gif) *syntax violation*`
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< 1 5) 2)) ![<graphic>](ch2_0.gif) *语法违规*`
- en: Although this local definition of `if` looks simple enough, there are a few
    subtle ways in which an attempt to write it might go wrong. If `letrec-syntax`
    were used in place of `let-syntax`, the identifier `if` inserted into the output
    would refer to the local `if` rather than the built-in `if`, and expansion would
    loop indefinitely.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个`if`的本地定义看起来足够简单，但在尝试编写它时可能会出现一些微妙的问题。如果使用`letrec-syntax`代替`let-syntax`，则插入到输出中的标识符`if`将引用本地`if`而不是内置的`if`，扩展将无限循环。
- en: Similarly, if the underscore were replaced with the identifier `if`, expansion
    would again loop indefinitely. The `if` appearing in the template `(if e1 e2 e3)`
    would be treated as a pattern variable bound to the corresponding identifier `if`
    from the input form, which denotes the local version of `if`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果下划线被替换为标识符`if`，扩展将再次无限循环。模板`(if e1 e2 e3)`中出现的`if`将被视为绑定到输入形式中相应标识符`if`的模式变量，后者表示`if`的本地版本。
- en: Placing `if` in the list of literals in an attempt to patch up the latter version
    would not work either. This would cause `syntax-case` to compare the literal `if`
    in the pattern, which would be scoped outside the `let-syntax` expression, with
    the `if` in the input expression, which would be scoped inside the `let-syntax`.
    Since they would not refer to the same binding, they would not be `free-identifier=?`,
    and a syntax violation would result.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 将`if`放在尝试修补后一个版本的文字列表中也不起作用。这将导致`syntax-case`将模式中的文字`if`（其作用域在`let-syntax`表达式之外）与输入表达式中的`if`进行比较，后者的作用域在`let-syntax`内部。由于它们不引用相同的绑定，它们不会是`free-identifier=?`，结果会导致语法违规。
- en: The conventional use of underscore ( `_` ) helps the programmer avoid situations
    like these in which the wrong identifier is matched against or inserted by accident.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线（`_`）的传统用法帮助程序员避免这种情况，其中错误的标识符被错误匹配或意外插入。
- en: It is a syntax violation to generate a reference to an identifier that is not
    present within the context of an input form, which can happen if the "closest
    enclosing lexical binding" for an identifier inserted into the output of a transformer
    does not also enclose the input form. For example,
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 生成对不存在于输入形式上下文中的标识符的引用是语法违规的，如果插入到转换器输出中的标识符的“最近封闭的词法绑定”不包含输入形式，则可能发生这种情况。例如，
- en: '`(let-syntax ([divide (lambda (x)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: (let ([/ +])
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e1 e2) #''(/ e1 e2)])))])'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: (let ([/ *]) (divide 2 1)))`
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: should result in a syntax violation with a message to the effect that `/` is
    referenced in an invalid context, since the occurrence of `/` in the output of
    `divide` is a reference to the variable `/` bound by the `let` expression within
    the transformer.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: The next example defines a `define-integrable` form that is similar to `define`
    for procedure definitions except that it causes the code for the procedure to
    be *integrated*, or inserted, wherever a direct call to the procedure is found.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax define-integrable'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules (lambda)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ name (lambda formals form1 form2 ...))'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: (define xname (lambda formals form1 form2 ...))
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax name
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[_ (identifier? x) #''xname]'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ arg (... ...))'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '#''((lambda formals form1 form2 ...)'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: arg
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: (... ...))]))))]))`
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'The form `(define-integrable *name* *lambda-expression*)` expands into a pair
    of definitions: a syntax definition of `*name*` and a variable definition of `xname`.
    The transformer for `*name*` converts apparent calls to `*name*` into direct calls
    to `*lambda-expression*`. Since the resulting forms are merely direct `lambda`
    applications (the equivalent of `let` expressions), the actual parameters are
    evaluated exactly once and before evaluation of the procedure''s body, as required.
    All other references to `*name*` are replaced with references to `xname`. The
    definition of `xname` binds it to the value of `*lambda-expression*`. This allows
    the procedure to be used as a first-class value. The `define-integrable` transformer
    does nothing special to maintain lexical scoping within the `lambda` expression
    or at the call site, since lexical scoping is maintained automatically by the
    expander. Also, because `xname` is introduced by the transformer, the binding
    for `xname` is not visible anywhere except where references to it are introduced
    by the the transformer for `*name*`.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The above definition of `define-integrable` does not work for recursive procedures,
    since a recursive call would cause an indefinite number of expansion steps, likely
    resulting in exhaustion of memory at expansion time. A solution to this problem
    for directly recursive procedures is to wrap each occurrence of the `lambda` expression
    with a `let-syntax` binding that unconditionally expands `*name*` to `xname`.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax define-integrable'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules (lambda)
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ name (lambda formals form1 form2 ...))'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: (define xname
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: (let-syntax ([name (identifier-syntax xname)])
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: (lambda formals form1 form2 ...)))
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax name
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[_ (identifier? x) #''xname]'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ arg (... ...))'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '#''((let-syntax ([name (identifier-syntax xname)])'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: (lambda formals form1 form2 ...))
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: arg (... ...))]))))]))`
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be solved for mutually recursive procedures by replacing the
    `let-syntax` forms with the nonstandard `fluid-let-syntax` form, which is described
    in the *Chez Scheme User's Guide* [[9](bibliography.html#g227)].
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相互递归过程，可以通过用非标准的 `fluid-let-syntax` 表单替换 `let-syntax` 表单来解决这个问题，这在 *Chez Scheme
    用户指南* 中有描述 [[9](bibliography.html#g227)]。
- en: Both definitions of `define-integrable` treat the case where an identifier appears
    in the first position of a structured expression differently from the case where
    it appears elsewhere, as does the `pcar` example given in the description for
    `identifier?`. In other situations, both cases must be treated the same. The form
    `identifier-syntax` can make doing so more convenient.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`define-integrable` 的两种定义处理了标识符出现在结构化表达式的第一个位置与出现在其他位置的情况，就像描述 `identifier?`
    中给出的 `pcar` 示例一样。在其他情况下，这两种情况必须被同等对待。形式 `identifier-syntax` 可以使这样做更加方便。'
- en: '`(let ([x 0])'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 0])'
- en: (define-syntax x++
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax x++
- en: (identifier-syntax
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: (identifier-syntax
- en: (let ([t x])
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([t x])
- en: (set! x (+ t 1)) t)))
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: (set! x (+ t 1)) t)))
- en: (let ([a x++]) (list a x))) ![<graphic>](ch2_0.gif) (0 1)`
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([a x++]) (list a x))) ![<graphic>](ch2_0.gif) (0 1)`
- en: The following example uses `identifier-syntax`, `datum->syntax`, and local syntax
    definitions to define a form of *method*, one of the basic building blocks of
    object-oriented programming (OOP) systems. A `method` expression is similar to
    a `lambda` expression, except that in addition to the formal parameters and body,
    a `method` expression also contains a list of instance variables `(ivar ...)`.
    When a method is invoked, it is always passed an *object* (*instance*), represented
    as a vector of *fields* corresponding to the instance variables, and zero or more
    additional arguments. Within the method body, the object is bound implicitly to
    the identifier `self` and the additional arguments are bound to the formal parameters.
    The fields of the object may be accessed or altered within the method body via
    instance variable references or assignments.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 `identifier-syntax`、`datum->syntax` 和本地语法定义来定义一种 *方法* 形式，这是面向对象编程（OOP）系统的基本构建块之一。`method`
    表达式类似于 `lambda` 表达式，但除了形式参数和主体外，`method` 表达式还包含一个实例变量列表 `(ivar ...)`。当调用方法时，始终会传递一个
    *对象*（*实例*），表示为与实例变量对应的 *字段* 的向量，以及零个或多个额外参数。在方法主体中，对象隐式绑定到标识符 `self`，额外参数绑定到形式参数。可以通过实例变量引用或赋值在方法主体中访问或更改对象的字段。
- en: '`(define-syntax method'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax method'
- en: (lambda (x)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(k (ivar ...) formals b1 b2 ...)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '[(k (ivar ...) formals b1 b2 ...)'
- en: (with-syntax ([(index ...)
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: (with-syntax ([(index ...)
- en: (let f ([i 0] [ls #'(ivar ...)])
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([i 0] [ls #'(ivar ...)])
- en: (if (null? ls)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (null? ls)
- en: '''()'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons i (f (+ i 1) (cdr ls)))))]
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: (cons i (f (+ i 1) (cdr ls)))))]
- en: '[self (datum->syntax #''k ''self)]'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '[self (datum->syntax #''k ''self)]'
- en: '[set! (datum->syntax #''k ''set!)])'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[set! (datum->syntax #''k ''set!)])'
- en: '#''(lambda (self . formals)'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(lambda (self . formals)'
- en: (let-syntax ([ivar (identifier-syntax
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: (let-syntax ([ivar (identifier-syntax
- en: (vector-ref self index))]
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-ref self index))]
- en: '...)'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '...)'
- en: (let-syntax ([set!
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: (let-syntax ([set!
- en: (syntax-rules (ivar ...)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules (ivar ...)
- en: '[(_ ivar e) (vector-set! self index e)]'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ ivar e) (vector-set! self index e)]'
- en: '...'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[(_ x e) (set! x e)])])'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ x e) (set! x e)])])'
- en: b1 b2 ...))))])))`
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: b1 b2 ...))))])))`
- en: Local bindings for `ivar ...` and for `set!` make the fields of the object appear
    to be ordinary variables, with references and assignments translated into calls
    to `vector-ref` and `vector-set!`. `datum->syntax` is used to make the introduced
    bindings of `self` and `set!` visible in the method body. Nested `let-syntax`
    expressions are needed so that the identifiers `ivar ...` serving as auxiliary
    keywords for the local version of `set!` are scoped properly.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `ivar ...` 和 `set!` 进行本地绑定使得对象的字段看起来像普通变量，引用和赋值被转换为对 `vector-ref` 和 `vector-set!`
    的调用。使用 `datum->syntax` 使得引入的 `self` 和 `set!` 的绑定在方法主体中可见。需要嵌套的 `let-syntax` 表达式以使作为本地
    `set!` 版本辅助关键字的标识符 `ivar ...` 被正确作用域。
- en: By using the general form of `identifier-syntax` to handle `set!` forms more
    directly, we can simplify the definition of `method`.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一般形式的 `identifier-syntax` 更直接地处理 `set!` 形式，我们可以简化 `method` 的定义。
- en: '`(define-syntax method'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax method'
- en: (lambda (x)
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ( x )
- en: (syntax-case x ()
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(k (ivar ...) formals b1 b2 ...)'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '[(k (ivar ...) formals b1 b2 ...)'
- en: (with-syntax ([(index ...)
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: (with-syntax ([(index ...)
- en: (let f ([i 0] [ls #'(ivar ...)])
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([i 0] [ls #'(ivar ...)])
- en: (if (null? ls)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (null? ls)
- en: '''()'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons i (f (+ i 1) (cdr ls)))))]
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: (cons i (f (+ i 1) (cdr ls)))))]
- en: '[self (datum->syntax #''k ''self)])'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '[self (datum->syntax #''k ''self)])'
- en: '#''(lambda (self . formals)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '#''(lambda (self . formals)'
- en: (let-syntax ([ivar (identifier-syntax
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: (let-syntax ([ivar (identifier-syntax
- en: '[_ (vector-ref self index)]'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[(set! _ e)'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! self index e)])]
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '...)'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: b1 b2 ...)))])))`
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: The examples below demonstrate simple uses of `method`.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([m (method (a) (x) (list a x self))])'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: (m #(1) 2)) ![<graphic>](ch2_0.gif) (1 2 #(1))
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: (let ([m (method (a) (x)
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: (set! a x)
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ a x))
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: (list a x self))])
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: (m #(1) 2)) ![<graphic>](ch2_0.gif) (2 4 #(2))`
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: In a complete OOP system based on `method`, the instance variables `ivar ...`
    would likely be drawn from class declarations, not listed explicitly in the `method`
    forms, although the same techniques would be used to make instance variables appear
    as ordinary variables within method bodies.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: The final example of this section defines a simple structure definition facility
    that represents structures as vectors with named fields. Structures are defined
    with `define-structure`, which takes the form
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-structure *name* *field* ...)`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'where `*name*` names the structure and `*field* ...` names its fields. `define-structure`
    expands into a series of generated definitions: a constructor `make-*name*`, a
    type predicate `*name*?`, and one accessor `*name*-*field*` and setter `set-*name*-*field*!`
    per field name.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax define-structure'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: (define gen-id
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (template-id . args)
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: (datum->syntax template-id
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: (string->symbol
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: (apply string-append
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: (map (lambda (x)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: (if (string? x)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: x
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: (symbol->string (syntax->datum x))))
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: args))))))
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-case x ()
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ name field ...)'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: (with-syntax ([constructor (gen-id #'name "make-" #'name)]
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[predicate (gen-id #''name #''name "?")]'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[(access ...)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: (map (lambda (x) (gen-id x #'name "-" x))
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '#''(field ...))]'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[(assign ...)'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: (map (lambda (x)
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: (gen-id x "set-" #'name "-" x "!"))
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '#''(field ...))]'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '[structure-length (+ (length #''(field ...)) 1)]'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[(index ...)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([i 1] [ids #'(field ...)])
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ids)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: (cons i (f (+ i 1) (cdr ids)))))])
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '#''(begin'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: (define constructor
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (field ...)
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: (vector 'name field ...)))
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: (define predicate
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: (and (vector? x)
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: (= (vector-length x) structure-length)
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (vector-ref x 0) 'name))))
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: (define access
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: (vector-ref x index)))
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: (define assign
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x update)
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! x index update)))
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '...))])))`'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: The constructor accepts as many arguments as there are fields in the structure
    and creates a vector whose first element is the symbol `*name*` and whose remaining
    elements are the argument values. The type predicate returns true if its argument
    is a vector of the expected length whose first element is `*name*`.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: Since a `define-structure` form expands into a `begin` containing definitions,
    it is itself a definition and can be used wherever definitions are valid.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: The generated identifiers are created with `datum->syntax` to allow the identifiers
    to be visible where the `define-structure` form appears.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: The examples below demonstrate the use of `define-structure`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-structure tree left right)'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: (define t
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: (make-tree
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: (make-tree 0 1)
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: (make-tree 2 3)))
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: t ![<graphic>](ch2_0.gif) #(tree #(tree 0 1) #(tree 2 3))
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: (tree? t) ![<graphic>](ch2_0.gif) #t
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: (tree? t) ![<graphic>](ch2_0.gif) #t
- en: (tree-left t) ![<graphic>](ch2_0.gif) #(tree 0 1)
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: (tree-left t) ![<graphic>](ch2_0.gif) #(tree 0 1)
- en: (tree-right t) ![<graphic>](ch2_0.gif) #(tree 2 3)
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: (tree-right t) ![<graphic>](ch2_0.gif) #(tree 2 3)
- en: (set-tree-left! t 0)
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: (set-tree-left! t 0)
- en: t ![<graphic>](ch2_0.gif) #(tree 0 #(tree 2 3))`
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: t ![<graphic>](ch2_0.gif) #(tree 0 #(tree 2 3))`
