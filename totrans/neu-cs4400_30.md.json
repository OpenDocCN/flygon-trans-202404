["```\n(define dx 0.01)(: deriv : (Number -> Number) Number -> Number);; compute the derivative of `f' at the given point `x'(define (deriv f x)\u00a0 (/ (- (f (+ x dx)) (f x)) dx))(: integrate : (Number -> Number) Number -> Number);; compute an integral of `f' at the given point `x'(define (integrate f x)\u00a0 (: loop : Number Number -> Number)\u00a0 (define (loop y acc)\u00a0 \u00a0 (if (> y x)\u00a0 \u00a0 \u00a0 (/ acc dx)\u00a0 \u00a0 \u00a0 (loop (+ y dx) (+ acc (f y)))))\u00a0 (loop 0 0))\n```", "```\n(plot sin)\n```", "```\n(: sin-deriv : Number -> Number);; the derivative of sin(define sin-deriv (lambda (x) (deriv sin x)))(plot sin-deriv)\n```", "```\n(plot (lambda (x) (deriv sin x)))\n```", "```\n(plot (lambda (x) (- (deriv sin x) (cos x))))\n```", "```\n(: fsub : (Number -> Number) (Number -> Number)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 -> (Number -> Number));; subtracts two numeric 1-argument functions(define (fsub f g)\u00a0 (lambda (x) (- (f x) (g x))))\n```", "```\n(: fderiv : (Number -> Number) -> (Number -> Number));; compute the derivative function of `f'(define (fderiv f)\u00a0 (lambda (x) (deriv f x)))\n```", "```\n(plot (fsub (fderiv sin) cos))\n```", "```\n(: currify : (All (A B C) (A B -> C) -> (A -> B -> C)));; convert a double-argument function to a curried one(define (currify f)\u00a0 (lambda (x) (lambda (y) (f x y))))(: fderiv : (Number -> Number) -> (Number -> Number));; compute the derivative function of `f'(define fderiv (currify deriv))\n```", "```\n(define-type UnaryFun\u00a0 = (Number -> Number))(define-type BinaryFun = (Number Number -> Number))(: binop->fbinop : BinaryFun -> (UnaryFun UnaryFun -> UnaryFun));; turns an arithmetic binary operator to a function operator(define (binop->fbinop op)\u00a0 (lambda (f g)\u00a0 \u00a0 (lambda (x) (op (f x) (g x)))))(: fsub : UnaryFun UnaryFun -> UnaryFun);; functional pointwise subtraction(define fsub (binop->fbinop -))\n```", "```\n#lang pl untyped(define (currify f)\u00a0 (lambda (x) (lambda (y) (f x y))))(define (binop->fbinop op)\u00a0 (lambda (f g)\u00a0 \u00a0 (lambda (x) (op (f x) (g x)))))(define (compose f g)\u00a0 (lambda (x) (f (g x))))(define dx 0.01)(define (deriv f x)\u00a0 (/ (- (f (+ x dx)) (f x)) dx))(define (integrate f x)\u00a0 (define over (if (< x 0) < >))\u00a0 (define step (if (< x 0) - +))\u00a0 (define add\u00a0 (if (< x 0) - +))\u00a0 (define (loop y acc)\u00a0 \u00a0 (if (over y x)\u00a0 \u00a0 \u00a0 (* acc dx)\u00a0 \u00a0 \u00a0 (loop (step y dx) (add acc (f y)))))\u00a0 (loop 0 0))(define fadd (binop->fbinop +))(define fsub (binop->fbinop -))(define fmul (binop->fbinop *))(define fdiv (binop->fbinop /))(define fderiv\u00a0 \u00a0  (currify deriv))(define fintegrate (currify integrate));; ...\n```", "```\n;; want to verify that `integrate' is the opposite of `deriv':;;\u00a0  take a function, subtract it from its derivative's integral(plot (fsub sin (fintegrate (fderiv sin))));; want to magnify the errors? -- here's how you magnify:(plot (compose ((currify *) 5) sin));; so:(plot (compose ((currify *) 20)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (fsub sin (fintegrate (fderiv sin)))))\n```", "```\n(define (deriv f)\u00a0 (lambda (x)\u00a0 \u00a0 (/ (- (f (+ x dx)) (f x)) dx)))\n```", "```\n(define (fib n)\u00a0 (if (<= n 1)\u00a0 \u00a0 n\u00a0 \u00a0 (+ (fib (- n 1)) (fib (- n 2)))))\n```", "```\n(define (bogus x y)\u00a0 (* (fib x) y))\n```", "```\n(define (bogus x)\u00a0 (lambda (y)\u00a0 \u00a0 (* (fib x) y)))\n```", "```\n(define bogus24 (bogus 24))(map bogus24 '(1 2 3 4 5))\n```", "```\n(define (bogus x)\u00a0 (let ([fibx (fib x)])\u00a0 \u00a0 (lambda (y)\u00a0 \u00a0 \u00a0 (* fibx y))))\n```", "```\n(define bogus24 (bogus 24))(map bogus24 '(1 2 3 4 5))\n```"]