- en: Let's Start Simple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's Start Simple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usual introduction to any language is "Hello, World!". A simple program
    that prints that message out to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we might write it for C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'C++ could write it the same way, or we could use the C++ stream classes if
    we preferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the equivalent in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some obvious points of similarity that we can observe:'
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ and Rust follow the convention of having a `main()` function as the entry
    point into code. Note that Rust's main doesn't return anything. It's effectively
    a void method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a general purpose print statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general structure in terms of main, use of { } and semi-colons is mostly
    the same. In both languages a block of code is enclosed in curly braces, and a
    semi-colon is used as a separator between statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust looks a little bit more terse than either C or C++ because it automatically
    includes references to part of its standard runtime that it refers to as its "prelude".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `println!()` is actually a macro that expands into code that writes to the
    standard output. We know it's a macro because it ends in a ! character but you
    may treat it like a function call for now. We'll see how Rust macros differ to
    those in C/C++ later.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open a command prompt and set up your compiler environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were using gcc, youâ€™d compile your code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were using Microsoft Visual C++ you''d compile like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To compile in Rust you invoke the rustc compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And to run either
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Again there are points of similarity:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a shell command that compiles the code and creates an executable from
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary runs in the same way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A less obvious point of similarity is that Rust shares its code generation backend
    with gcc-llvm and clang. Rustc outputs llvm bitcode which is compiled (and optimized)
    into machine code via LLVM. This means the resulting executable is very similar
    in form to that output by C++ compilers. That includes the symbolic information
    it supplies for debugging purposes. A rust executable can be debugged in gdb,
    lldb or Microsoft Visual Studio depending on the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
