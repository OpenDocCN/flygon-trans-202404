["```\n\n    We saw in the [Imp](Imp.html) chapter how a naive approach to defining a\n    function representing evaluation for Imp runs into difficulties.\n    There, we adopted the solution of changing from a functional to a\n    relational definition of evaluation.  In this optional chapter, we\n    consider strategies for getting the functional approach to\n    work.\n\n```", "```\n(*\u00a0IMPORTS\u00a0*)\nRequire Import Coq.omega.Omega.\nRequire Import Coq.Arith.Arith.\nRequire Import Imp.\nRequire Import Maps.\n(*\u00a0/IMPORTS\u00a0*)\n\n```", "```\nFixpoint ceval_step1 (st : state) (c : com) : state :=\n\u00a0\u00a0match c with\n\u00a0\u00a0\u00a0\u00a0| SKIP \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st\n\u00a0\u00a0\u00a0\u00a0| l ::= a[1] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t_update st l (aeval st a[1])\n\u00a0\u00a0\u00a0\u00a0| c[1] ;; c[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0let st' := ceval_step1 st c[1] in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval_step1 st' c[2]\n\u00a0\u00a0\u00a0\u00a0| IFB b THEN c[1] ELSE c[2] FI \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (beval st b)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0then ceval_step1 st c[1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else ceval_step1 st c[2]\n\u00a0\u00a0\u00a0\u00a0| WHILE b[1] DO c[1] END \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st  (*\u00a0bogus\u00a0*)\n\u00a0\u00a0end.\n\n```", "```\n    | WHILE b1 DO c1 END => if (beval st b1) then ceval_step1 st (c1;;\n        WHILE b1 DO c1 END) else st\n\n```", "```\n     Fixpoint loop_false (n : nat) : False := loop_false n.\n\n```", "```\n\n# A Step-Indexed Evaluator\n\n    The trick we need is to pass an *additional* parameter to the\n    evaluation function that tells it how long to run.  Informally, we\n    start the evaluator with a certain amount of \"gas\" in its tank,\n    and we allow it to run until either it terminates in the usual way\n    *or* it runs out of gas, at which point we simply stop evaluating\n    and say that the final result is the empty memory.  (We could also\n    say that the result is the current state at the point where the\n    evaluator runs out fo gas \u2014 it doesn't really matter because the\n    result is going to be wrong in either case!)\n\n```", "```\n\n    *Note*: It is tempting to think that the index i here is\n    counting the \"number of steps of evaluation.\"  But if you look\n    closely you'll see that this is not the case: for example, in the\n    rule for sequencing, the same i is passed to both recursive\n    calls.  Understanding the exact way that i is treated will be\n    important in the proof of ceval__ceval_step, which is given as\n    an exercise below.\n\n    One thing that is not so nice about this evaluator is that we\n    can't tell, from its result, whether it stopped because the\n    program terminated normally or because it ran out of gas.  Our\n    next version returns an option state instead of just a state,\n    so that we can distinguish between normal and abnormal\n    termination.\n\n```", "```\n\n    We can improve the readability of this version by introducing a\n    bit of auxiliary notation to hide the plumbing involved in\n    repeatedly matching against optional states.\n\n```", "```\n\n#### Exercise: 2 stars, recommended (pup_to_n)\n\n    Write an Imp program that sums the numbers from 1 to\n   X (inclusive: 1 + 2 + ... + X) in the variable Y.  Make sure\n   your solution satisfies the test that follows.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (peven)\n\n    Write a While program that sets Z to 0 if X is even and\n    sets Z to 1 otherwise.  Use ceval_test to test your\n    program.\n\n```", "```\n\n    \u2610\n\n```", "```\nTheorem ceval_step__ceval: \u2200c st st',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2203i, ceval_step st c i = Some st') \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st'.\nProof.\n\u00a0\u00a0intros c st st' H.\n\u00a0\u00a0inversion H as [i E].\n\u00a0\u00a0clear H.\n\u00a0\u00a0generalize dependent st'.\n\u00a0\u00a0generalize dependent st.\n\u00a0\u00a0generalize dependent c.\n\u00a0\u00a0induction i as [| i' ].\n\n\u00a0\u00a0- (*\u00a0i\u00a0=\u00a00\u00a0--\u00a0contradictory\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros c st st' H. inversion H.\n\n\u00a0\u00a0- (*\u00a0i\u00a0=\u00a0S\u00a0i'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros c st st' H.\n\u00a0\u00a0\u00a0\u00a0destruct c;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl in H; inversion H; subst; clear H.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0SKIP\u00a0*) apply E_Skip.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0::=\u00a0*) apply E_Ass. reflexivity.\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0;;\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (ceval_step st c[1] i') eqn:Heqr1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0Evaluation\u00a0of\u00a0r[1]\u00a0terminates\u00a0normally\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_Seq with s.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHi'. rewrite Heqr1. reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHi'. simpl in H[1]. assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0Otherwise\u00a0--\u00a0contradiction\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H[1].\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0IFB\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (beval st b) eqn:Heqr.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0r\u00a0=\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_IfTrue. rewrite Heqr. reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHi'. assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0r\u00a0=\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_IfFalse. rewrite Heqr. reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHi'. assumption.\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0WHILE\u00a0*) destruct (beval st b) eqn :Heqr.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0r\u00a0=\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (ceval_step st c i') eqn:Heqr1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ (*\u00a0r[1]\u00a0=\u00a0Some\u00a0s\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_WhileLoop with s. rewrite Heqr.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHi'. rewrite Heqr1. reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHi'. simpl in H[1]. assumption. }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ (*\u00a0r[1]\u00a0=\u00a0None\u00a0*) inversion H[1]. }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0r\u00a0=\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H[1].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply E_WhileEnd.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 Heqr. subst. reflexivity. Qed.\n\n```", "```\nTheorem ceval_step_more: \u2200i[1] i[2] st st' c,\n\u00a0\u00a0i[1] \u2264 i[2] \u2192\n\u00a0\u00a0ceval_step st c i[1] = Some st' \u2192\n\u00a0\u00a0ceval_step st c i[2] = Some st'.\nProof.\ninduction i[1] as [|i[1]']; intros i[2] st st' c Hle Hceval.\n\u00a0\u00a0- (*\u00a0i[1]\u00a0=\u00a00\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl in Hceval. inversion Hceval.\n\u00a0\u00a0- (*\u00a0i[1]\u00a0=\u00a0S\u00a0i[1]'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0destruct i[2] as [|i[2]']. inversion Hle.\n\u00a0\u00a0\u00a0\u00a0assert (Hle': i[1]' \u2264 i[2]') by omega.\n\u00a0\u00a0\u00a0\u00a0destruct c.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0SKIP\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl in Hceval. inversion Hceval.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0::=\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl in Hceval. inversion Hceval.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0;;\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl in Hceval. simpl.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (ceval_step st c[1] i[1]') eqn:Heqst1'o.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0st[1]'o\u00a0=\u00a0Some\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply (IHi1' i[2]') in Heqst1'o; try assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite Heqst1'o. simpl. simpl in Hceval.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply (IHi1' i[2]') in Hceval; try assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0st[1]'o\u00a0=\u00a0None\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion Hceval.\n\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0IFB\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl in Hceval. simpl.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (beval st b); apply (IHi1' i[2]') in Hceval;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assumption.\n\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0WHILE\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl in Hceval. simpl.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (beval st b); try assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (ceval_step st c i[1]') eqn: Heqst1'o.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0st[1]'o\u00a0=\u00a0Some\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply (IHi1' i[2]') in Heqst1'o; try assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2192 Heqst1'o. simpl. simpl in Hceval.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply (IHi1' i[2]') in Hceval; try assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0i[1]'o\u00a0=\u00a0None\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl in Hceval. inversion Hceval. Qed.\n\n```", "```\nTheorem ceval__ceval_step: \u2200c st st',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2203i, ceval_step st c i = Some st'.\nProof.\n\u00a0\u00a0intros c st st' Hce.\n\u00a0\u00a0induction Hce.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem ceval_and_ceval_step_coincide: \u2200c st st',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st'\n\u00a0\u00a0\u2194 \u2203i, ceval_step st c i = Some st'.\nProof.\n\u00a0\u00a0intros c st st'.\n\u00a0\u00a0split. apply ceval__ceval_step. apply ceval_step__ceval.\nQed.\n\n```", "```\nTheorem ceval_deterministic' : \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] He[1] He[2].\n\u00a0\u00a0apply ceval__ceval_step in He[1].\n\u00a0\u00a0apply ceval__ceval_step in He[2].\n\u00a0\u00a0inversion He[1] as [i[1] E[1]].\n\u00a0\u00a0inversion He[2] as [i[2] E[2]].\n\u00a0\u00a0apply ceval_step_more with (i[2] := i[1] + i[2]) in E[1].\n\u00a0\u00a0apply ceval_step_more with (i[2] := i[1] + i[2]) in E[2].\n\u00a0\u00a0rewrite E[1] in E[2]. inversion E[2]. reflexivity.\n\u00a0\u00a0omega. omega. Qed.\n\n```", "```\n\n```", "```\n\n```"]