- en: Dynamic versus Lexical ScopeTuesday, February 7th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And back to the discussion of whether we should use dynamic or lexical scope:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important fact is that we want to view programs as executed by the
    normal substituting evaluator. Our original motivation was to optimize evaluation
    only — not to *change* the semantics! It follows that we want the result of this
    optimization to behave in the same way. All we need is to evaluate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: in the original evaluator to get convinced that `7` should be the correct result
    (note also that the same code, when translated into Racket, evaluates to `7`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (Yet, this is a very important optimization, which without it lots of programs
    become too slow to be feasible, so you might claim that you’re fine with the modified
    semantics…)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It does not allow using functions as objects, for example, we have seen that
    we have a functional representation for pairs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If this is evaluated in a dynamically-scoped language, we do get a function
    as a result, but the values bound to `x` and `y` are now gone! Using the substitution
    model we substituted these values in, but now they were only held in a cache which
    no has no entries for them…
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the same way, currying would not work, our nice `deriv` function would not
    work etc etc etc.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Makes reasoning impossible, because any piece of code behaves in a way that
    *cannot* be predicted until run-time. For example, if dynamic scoping was used
    in Racket, then you wouldn’t be able to know what this function is doing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As it is, it will cause a run-time error, but if you call it like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'then it will return `1`, and if you later do this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: then you would get `2`!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These problems can be demonstrated in Emacs Lisp too, but Racket goes one step
    further — it uses the same rule for evaluating a function as well as its values
    (Lisp uses a different name-space for functions). Because of this, you cannot
    even rely on the following function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'to always add `x` and `y`! — A similar example to the above:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: would return `-1`!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Many so-called “scripting” languages begin their lives with dynamic scoping.
    The main reason, as we’ve seen, is that implementing it is extremely simple (no,
    *nobody* does substitution in the real world! (Well, *almost* nobody…)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another reason is that these problems make life impossible if you want to use
    functions as object like you do in Racket, so you notice them very fast — but
    in a `normal` language without first-class functions, problems are not as obvious.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, bash has `local` variables, but they have dynamic scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perl began its life with dynamic scope for variables that are declared `local`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When faced with this problem, “the Perl way” was, obviously, not to remove or
    fix features, but to pile them up — so `local` *still* behaves in this way, and
    now there is a `my` declaration which achieves proper lexical scope (and every
    serious Perl programmer knows that you should always use `my`)…
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are other examples of languages that changed, and languages that want
    to change (e.g, nobody likes dynamic scope in Emacs Lisp, but there’s just too
    much code now).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is still a tricky issue, like any other issue with bindings. For example,
    googling got me quickly to [a Python blog post](http://www.hetland.org/python/instant-python.php)
    which is confused about what “dynamic scoping” is… It claims that Python uses
    dynamic scope (Search for “Python uses dynamic as opposed to lexical scoping”),
    yet python always used lexical scope rules, as can be seen by translating their
    code to Racket (ignore side-effects in this computation):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'or by trying this in Python:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The real problem of python (pre 2.1, and pre 2.2 without the funny
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: line) is that it didn’t create closures, which we will talk about shortly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another example, which is an indicator of how easy it is to mess up your scope
    is the following Ruby bug — running in `irb`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: (This is a bug due to weird scoping rules for variables, which was fixed in
    newer versions of Ruby. See [this Ruby rant](http://innig.net/software/ruby/closures-in-ruby)
    for details, or read about [Ruby and the principle of unwelcome surprise](http://ceaude.twoticketsplease.de/articles/ruby-and-the-principle-of-unwelcome-surprise.html)
    for additional gems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Another thing to consider is the fact that compilation is something that you
    do based only on the lexical structure of programs, since compilers never actually
    run code. This means that dynamic scope makes compilation close to impossible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some advantages for dynamic scope too. Two notable ones are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic scope makes it easy to have a “configuration variable” easily change
    for the extend of a calling piece of code (this is used extensively in Emacs,
    for example). The thing is that usually we want to control which variables are
    “configurable” in this way, statically scoped languages like Racket often choose
    a separate facility for these. To rephrase the problem of dynamic scoping, it’s
    that *all* variables are modifiable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same can be said about functions: it is sometimes desirable to change a
    function dynamically (for example, see “Aspect Oriented Programming”), but if
    there is no control and all functions can change, we get a world where no code
    can every be reliable.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: It makes recursion immediately available — for example,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: is an infinite loop with a dynamically scoped language. But in a lexically scoped
    language we will need to do some more work to get recursion going.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
