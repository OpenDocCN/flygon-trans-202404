- en: Lecture 32 - Communicating Sequential Processes (CSP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Public Service Annoucements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Final exam date: 9.00 August 7 to 11.30 August 9'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Final demos: 26 August & 27 August'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 25 August
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups demoing on the 27th leave the lab at 13.00
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 26 August
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Code freeze at 9.00
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Demos start at 9.30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 30 minutes in length
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Demos end at 13.00, groups demoing on the 27th re-enter the lab
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27 August
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Code freeze at 9.00
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Demos start at 9.30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 30 minutes in length
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Demos end at 13.00
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Noticed at the Milestone 2 demos
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conservative reservations did best
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: They make corner cases not exist
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But they inhibit performance: we saw system lock-up with two trains.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'My impression:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: every group had something close to staggering
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a few groups had robust implementations, not necessarily complete
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One robust implementation had many terminal-controllable parameters
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only one group -- of the ones we asked -- had a small idle task execution time
    fraction, ~ 50%, and they were having performance problems.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Following, first on a big loop, then on a small one, is a good test of reservations.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We liked ones that adjusted to go at the best speed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a symptom of being ables to run more trains without lock-up
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Can Message Passing be Made Type Safe?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dynamically
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Yes, even including type extension and polymorphism, but
  prefs: []
  type: TYPE_NORMAL
- en: What does the program do when it detects a type mismatch?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, it could send a more informative error message before it dies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statically
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No,
  prefs: []
  type: TYPE_NORMAL
- en: Structured programming depends critically on well-defined scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While tasks are scoped internally, there is no inter-task scoping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, we are happy to be free of scoping, because it allows us to try out
    a wider variety of program structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To formal methods people CSP is a calculus for reasoning about the correctness
    of multi-process/threaded/tasking (MPTT) systems. Active research has been ongoing
    for forty years with several goals
  prefs: []
  type: TYPE_NORMAL
- en: translating other synchronization/communication semantics to and from CSP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: finding new methods for reasoning about CSP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scaling everything to make CSP useful for production sized programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During that time many a chicken has left its tracks on the pages of formal methods
    journals and conference proceedings!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For programmers the claim has been and is made that CSP provides a superior
    method for structuring MPTT systems. (`Superior' in the sense of `easier to design,
    implement and understand'.)
  prefs: []
  type: TYPE_NORMAL
- en: The claim was first made in the late 1970s/early 1980s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was made again in the early 1990s, this time with the weight of Bell Labs
    behind it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And has been made yet again in the last few years, this time with the weight
    of Goggle behind it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitives
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In CSP there are two communication primitives. In the notation of occam 2/Go,
    they are
  prefs: []
  type: TYPE_NORMAL
- en: '**read**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: reads from an input channel called `keyboard` and assigns what it reads to the
    variable `ch`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the channel must have an associated type, and the type must match the type of
    the variable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: That is, the channel and the variable must be in the same scope.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: read blocks until input is available on the channel
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**write**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: writes the value of the variable `duh` into the channel `keyboard`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: blocks until the
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, a read/write pair guarantess that read in the reading process occurs simultaneously
    with or after the corresponding write in the writing process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a creation primitive
  prefs: []
  type: TYPE_NORMAL
- en: occam -- PAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'no shared memory: costly'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Go -- go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'shared memory: cheap'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The communication primitives require something new, called a channel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each channel has a protocol that states the type that messages it handles must
    have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the name of a channel is essential for using it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications control who can be on the other end of a channel, which is essential
    for security, by controlling who knows the name of the channel.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Grandfather -- the Transputer -- and the Grandson -- Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use many co-operating, medium capability microCPUs to do a big job.
  prefs: []
  type: TYPE_NORMAL
- en: An idea whose time has now come, **again**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem is communication
  prefs: []
  type: TYPE_NORMAL
- en: 'Big granularity (thick client: MS, Google)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minimizes communication
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: maximizes replicated data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Google approach:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: an opportunity nobody thought about
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a problem nobody thought about.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Small granularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minimizes replicated data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: maximizes communication
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Your system, like threading solutions, relies on shared memory for communication
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you handle caching?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Transputer hardware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The transputer was an early, now vanished, example of a real-time system based
    on plentiful small granularity communication. Your kernel is another example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your kernel: communication based on memory that is universally accessible by
    the kernel, which is easy to program, hard to make secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The transputer: communication based on switch mediated packets, which is hard
    to program, easy to make secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transputer itself
  prefs: []
  type: TYPE_NORMAL
- en: CPU, memory, switch on one chip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: chips connected in an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: presumably a run-time system decides where tasks will go in order to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: maximize CPU throughput
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: minimize communication overhead
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: can be, and usually was, taken over by the programmer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What about real-time?
  prefs: []
  type: TYPE_NORMAL
- en: lots of timer (countup) hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: interaction of countdown and countup to make your clock server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instances of timers are not guaranteed to be synchronized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How could two timers be synchronized?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Google (data centre) hardware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many single board (including disk) computers
  prefs: []
  type: TYPE_NORMAL
- en: Communicate by high speed ethernet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Farmer with clients & worker
  prefs: []
  type: TYPE_NORMAL
- en: Occam2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Timing out
  prefs: []
  type: TYPE_NORMAL
- en: Occam2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Basic idea
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: processes (tasks)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: may be named, take arguments and return values
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: may be combined
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CSP channels
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combining processes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: sequential
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: conditional
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: if/then
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: selection by case
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: looping
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: without test/break
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: with test/break
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: parallel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: initiated when the keyword PAR occurs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: alternation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: guarded alternatives
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: if more than one guard is true then select at random
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: can be prioritized
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: timer returns time as channel input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AFTER` can be used to combine times, because there is a total order based
    on time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AFTER` can make timer input blocking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Can you Build a Server with Type-Checking?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Result
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can write a type-safe server, BUT
  prefs: []
  type: TYPE_NORMAL
- en: all possible clients must be in the same scope in order to get static type checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: with dynamic, structural type checking you only need to have the tasks written
    in languages having the same type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BUT
  prefs: []
  type: TYPE_NORMAL
- en: with this structure excessive code in the client weakens synchronization, which
    might not be what you want.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bill Cowan''s lecture notes for CS452 in s12](index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s Spring 2012 CS452 page](../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s CS452 page](../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s teaching page](../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s home page](../../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
