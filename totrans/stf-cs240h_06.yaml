- en: Coverting tuples to lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you wanted to convert pairs to lists of `Strings`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now say you want to convert a pair of `Enum`s to a list of `Int`s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Can we generalize this function? Would like to say:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unfortunately, can't pass *methods* as arguments, only *functions*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Polymorphism with fundeps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's represent ad hoc polymorphic methods with a *class*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use placeholder singleton types to represent particular methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Function` in action'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now singleton types act like method arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, what if you wanted `tupleToList` for arbitrary *n*-tuples?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can auto-generate instances for a generic tuple fold, e.g.:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Works okay for small tuples, craps out around 10-tuple without larger `-fcontext-stack`
    argument
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, I'm temporarily out of compile-time tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative is to use run-time type information (RTTI)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: RTTI easier to reason about, but adds runtime overhead and errors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will come back to static tricks at end of lecture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DeriveDataTypeable`](http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#deriving-typeable)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell allows six classes to be automatically derived
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Show`, `Read`, `Eq`, `Ord`, `Bounded`, `Enum`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DeriveDataTypeable`](http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#deriving-typeable)
    extension adds two more: `Typeable`, `Data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These types encode run-time type information in various ways
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Data` requires that inner types (`Int`, `String`) also have instances'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Typeable` requires any type parameters to have instances'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most standard library types have `Typeable` and `Data` instances
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide programming approach known as "scrap your boilerplate"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GHC''s support described by two papers: [[Boilerplate1]](http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps),
    [[Boilerplate2]](http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/gmap2.ps)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Typeable`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t:Typeable)
    class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`import Data.Typeable` to get `Typeable` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to compare types for equality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Big Whoop!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Couldn't we already do this at compile time with `OverlappingInstances`?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing it dynamically is less exciting, but different
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And allows one very important function...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Type Casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GHC has a function [`unsafeCoerce`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Unsafe-Coerce.html#v:unsafeCoerce)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And note: it doesn''t just return âŠ¥'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the name doesn't scare you, the type signature should
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's use `Typeable` to make a safe `cast` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Safe if `typeOf` on two different types always returns different `TypeRep`s
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Guaranteed by `deriving (Typeable)`; SafeHaskell disallows manual instances
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalized casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To cast monadic computations, etc., use generalized cast, `gcast`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note undefined function `unc` in definition of `gcast`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common idiom--poses no problem because `typeOf` is not strict
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall context `Typeable b =>` is like a hidden argument; often use undefined
    functions with type signatures to unpack types and get dictionaries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `Typeable`: `mkT` [[Boilerplate1]](http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mkT` ("make transformation") behaves like `id` except on one type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise: implement `mkT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hint: The function type `(->)` is `Typeable`, so `Data.Typeable` exports:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note the magic of Haskell's type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g` is applied to `a`, so must have type `a -> a`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence `cast f` must have type `Maybe (a -> a)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence compiler knows to use `Typeable` dictionary of `(b -> b)` for argument,
    and dictionary `(a -> a)` for return of `cast`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[[Jones]](http://web.cecs.pdx.edu/~mpj/thih/) has detailed explanation of Haskell''s
    type inference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, a fancier implementation could use standard `maybe` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `Typeable`: `mkQ` [[Boilerplate1]](http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Function that computes over one type or returns default val:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`mkQ` stands for "make query"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise: implement `mkQ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if you want to get fancy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions on multiple types: `extQ`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mkQ` only works for one type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's extend `mkQ`'s output to work on another type [[Boilerplate1]](http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now can cascade multiple one-type query functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Recall default associatifity is left (`infixl 9 `extQ``)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Kind of tedious, but could approximate goal of `tupleToList` at beginning of
    lecture if tuples contain limited number of types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ExistentialQuantification`](http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lets you introduce type variables on right side of `data` declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Given a value of type `Stream a`, there exists a type `s` such that...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But syntax uses `forall`, not `exists`, to avoid introducing new keyword
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Very safe extension (`Control.Exception` relies on it)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don''t confuse with [`Rank2Types`](http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification),
    where `forall` means for all types `s`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Contexts on existential variables like hidden dictionary fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `Showable` value has both a value of type `a`, and a dictionary for `Show`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Dynamic type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`Data.Dynamic`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Dynamic.html)
    has type `Dynamic`, which can hold anything `Typeable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Actual implementation slightly gross
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `unsafeCoerce` to coerce everything to a placeholder `Obj` type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But easy to implement safely with `ExistentialQuantification`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: Extensible exceptions [[Marlow]](http://community.haskell.org/~simonmar/papers/ext-exceptions.pdf)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GHC runtime implements primitive, unsafe exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Must ensure that, as used, `b` is always same type, otherwise get unsafe coercion
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In reality, want many exception types, organized into a hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Control.Exception`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html)
    implements safe, hierarchical exceptions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`raise#` and `catch#` only ever called with one type: `SomeException`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Throwing and catching exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To throw an exception, first convert it to type `SomeException`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To catch an exception, must ensure it matches desired type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note `handler` makes `fromException se` use `e`'s `Exception` dictionary
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Making hierarchical exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Easy to add your own top-level exception type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But you can also create a hierarchy of exception types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's you catch just `Error1`, or any `AppError`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Data`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Data.html#t:Data)
    class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`Data` class allows generic traversal and construction of data structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines `gfoldl` and `gunfold` methods like this
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now can work over all sized tuples! But:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you introduce types, things get uglier [cosmetic]
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The only dictionaries available are `Data` and `Typeable` [fundamental]
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the runtime type checking is slow [fundamental]
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we do it at compile time?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternative: push generic programming to compile time [[MagalhÃ£es]](http://dreixel.net/research/pdf/gdmh.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at a simplified implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wget` [`cs240h.stanford.edu/metadata.hs`](http://www.scs.stanford.edu/14sp-cs240h/metadata.hs)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'High-level idea: Say you auto-derived instances of `Show`-like class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Introduce generic `MetaData` class for which compiler can generate instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And a `MyShow`-specific meta-class, such that?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`DefaultSignatures`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#class-default-signatures)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can do even better using [`DefaultSignatures`](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#class-default-signatures)
    extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows default methods that don't work for all instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Makes it even easier to declare instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how we could design such a `MetaData` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wget` [`cs240h.stanford.edu/metadata.hs`](http://www.scs.stanford.edu/14sp-cs240h/metadata.hs)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DeriveGeneric`](http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html)
    extension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compiler supports single `Generic` class that converts any datatype to a `Rep`
    that can be computed over generically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`type Rep` uses extension called `TypeFamilies`. Can read above as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like our simpler example, except everything of kind âˆ— â†’ âˆ—
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why? Maybe so you need a Ph.D. to use the extension?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (Allegedly will someday facilitate generic types of kind âˆ— â†’ âˆ—, so can make
    generic `Functor`-like instances)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rep` of a unit type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[`GHC.Generics`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/GHC-Generics.html)
    contents (part 1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Types with constructor arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note selectors are one feature our simpler example didn't have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's you pick out record names from types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`GHC.Generics`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/GHC-Generics.html)
    contents (part 2)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Again, ignore parameter `p` (there to make types of kind âˆ— â†’ âˆ—)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M1` exists so a single traversal method can skip over `D1`, `C1`, and `S1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could say `newtype Rec0 c p = K1 c`, but some instances use `K1 P`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What would a `Generic` instance look like?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How can we use this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say we are defining our own `Show`-like class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Want it to work with all user-defined data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's define a class `Show1` to deal with annoying `p` parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And let's define generic traversal methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Non-generic instances of `MyShow1`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we hit a constructor, want to print the name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We're using OverlappingInstances, since already have `M1` instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have no constructor args, don't show anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we have multiple constructor args, show them all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you hit the actual value, show it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we're calling `myShow`, which we haven't yet defined for many types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a generic `MyShow`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now can define generic `MyShow` in terms of `MyShow1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Can we avoid `OverlappingInstances`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could have defined separate `D1`, `S1` instances of `Show1` (easy)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Could have avoided completely generic instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended use is just to define a *function* `myShowDefault`, then
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's still the problem of different behavior for `[Char]` vs. `[a]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
