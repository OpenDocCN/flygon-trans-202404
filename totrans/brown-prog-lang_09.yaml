- en: 9Recursive Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Sometimes, a data definition has a piece that refers back to itself. For example,
    a linked list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to defining examples, we can talk about empty lists:'
  prefs: []
  type: TYPE_NORMAL
- en: The nl- stands for NumList. This avoids clashing with Pyret’s empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can represent short lists, like a sequence of two 4’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since these are created with constructors from data, we can use cases with
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This style of data definition permits us to create data that are unbounded
    or arbitrarily-sized. Given a NumList, there is an easy way to make a new, larger
    one: just use nl-link. So, we need to consider larger lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try to write a function contains-3, which returns true if the NumList
    contains the value 3, and false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to fill in the body with the template for a function over NumLists.
    We can start with the analogous template using cases we had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An empty list doesn’t contain the number 3, surely, so the answer must be false
    in the nl-empty case. In the nl-link case, if the first element is 3, we’ve successfully
    answered the question. That only leaves the case where the argument is an nl-link
    and the first element does not equal 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we know rest is a NumList (based on the data definition), we can use
    a cases expression to work with it. This is sort of like filling in a part of
    the template again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rest was empty, then we haven’t found 3 (just like when we checked the
    original argument, nl). If the rest was a nl-link, then we need to check if the
    first thing in the rest of the list is 3 or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since rest-of-rest is a NumList, we can fill in a cases for it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See where this is going? Not anywhere good. We can copy this cases expression
    as many times as we want, but we can never answer the question for a list that
    is just one element longer than the number of times we copy the code.
  prefs: []
  type: TYPE_NORMAL
- en: So what to do? We tried this approach of using another copy of cases based on
    the observation that rest is a NumList, and cases provides a meaningful way to
    break apart a NumList; in fact, it’s what the recipe seems to lead to naturally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the step where the problem began, after filling in the template
    with the first check for 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a way to compute whether or not the value 3 is contained in rest. Looking
    back at the data definition, we see that rest is a perfectly valid NumList, simply
    by the definition of nl-link. And we have a function (or, most of one) whose job
    is to figure out if a NumList contains 3 or not: contains-3. That ought to be
    something we can call with rest as an argument, and get back the value we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And lo and behold, all of the tests defined above pass. It’s useful to step
    through what’s happening when this function is called. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we substitute the argument value in place of nl everywhere it appears;
    that’s just the usual rule for function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, we find the case that matches the constructor nl-link, and substitute
    the corresponding pieces of the nl-link value for the first and rest identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since 1 isn’t 3, the comparison evaluates to false, and this whole expression
    evaluates to the contents of the else branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is another function call, so we substitute the value nl-link(3, nl-empty),
    which was the rest field of the original input, into the body of contains-3 this
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, we substitute into the nl-link branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This time, since 3 is 3, we take the first branch of the if expression, and
    the whole original call evaluates to true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: An interesting feature of this trace through the evaluation is that we reached
    the expression contains-3(nl-link(3, nl-empty)), which is a normal call to contains-3;
    it could even be a test case on its own. The implementation works by doing something
    (checking for equality with 3) with the non-recursive parts of the datum, and
    combining that result with the result of the same operation (contains-3) on the
    recursive part of the datum. This idea of doing recursion with the same function
    on self-recursive parts of the datatype lets us extend our template to handle
    recursive positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple design recipe dictated this as the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this template doesn’t give much guidance with what to do with the
    rest field. We will extend the template with the following rule: each self-recursive
    position in the data definition becomes a self-recursive function call in the
    template. So the new template looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To handle recursive data, the design recipe just needs to be modified to have
    this extended template. When you see a recursive data definition (of which there
    will be many when programming in Pyret), you should naturally start thinking about
    what the recursive calls will return and how to combine their results with the
    other, non-recursive pieces of the datatype.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function contains-n that takes a NumList and
    a Number, and returns whether that number is in the NumList.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function sum that takes a NumList, and returns
    the sum of all the numbers in it. The sum of the empty list is 0.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function remove-3 that takes a NumList, and
    returns a new NumList with any 3’s removed. The remaining elements should all
    be in the list in the same order they were in the input.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition called NumListList that represents a list of NumLists,
    and use the design recipe to write a function sum-of-lists that takes a NumListList
    and produces a NumList containing the sums of the sub-lists.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
