- en: '| [![Disneyland.  Los Angeles, California.](../Images/997c56feee4f0bd05b8b2eb03a2d95ab.jpg)](/http://philip.greenspun.com/images/pcd1647/disney-10.tcl)
    |'
  prefs: []
  type: TYPE_TB
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: part of [SQL for Web Nerds](index.html) by [Philip Greenspun](http://philip.greenspun.com/)
    |
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[![A view of the Spider Rock in Canyon de Chelly.  This is where the spider
    woman came down and taught the Navajo how to weave.](../Images/58b97d62554bbe64ed6cfb423e9d4aa9.jpg)](/http://philip.greenspun.com/images/pcd2148/canyon-de-chelly-spider-rock-6.4.jpg)
    The relational database provides programmers with a high degree of abstraction
    from the physical world of the computer. You can''t tell where on the disk the
    RDBMS is putting each row of a table. For all you know, information in a single
    row might be split up and spread out across multiple disk drives. The RDBMS lets
    you add a column to a billion-row table. Is the new information for each row going
    to be placed next to the pre-existing columns or will a big new block of disk
    space be allocated to hold the new column value for all billion rows? You can''t
    know and shouldn''t really care.'
  prefs: []
  type: TYPE_NORMAL
- en: A view is a way of building even greater abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that Jane in marketing says that she wants to see a table containing
    the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: user_id
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: email address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: number of static pages viewed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: number of bboard postings made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: number of comments made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This information is spread out among four tables. However, having read the
    preceding chapters of this book, you''re perfectly equipped to serve Jane''s needs
    with the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Then Jane adds "I want to see this every day, updated with the latest information.
    I want to have a programmer write me some desktop software that connects directly
    to the database and looks at this information; I don't want my desktop software
    breaking if you reorganize the data model."
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'To Jane, this will look and act just like a table when she queries it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Why should she need to be aware that information is coming from four tables?
    Or that you've reorganized the RDBMS so that the information subsequently comes
    from six tables?
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Privacy with Views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common use of views is protecting confidential data. For example, suppose
    that all the people who work in a hospital collaborate by using a relational database.
    Here is the data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: If a bunch of hippie idealists are running the hospital, they'll think that
    the medical doctors shouldn't be aware of a patient's insurance status. So when
    a doc is looking up a patient's medical record, the looking is done through
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The folks over in accounting shouldn''t get access to the patients'' medical
    records just because they''re trying to squeeze money out of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Relational databases have elaborate permission systems similar to those on time-shared
    computer systems. Each person in a hospital has a unique database user ID. Permission
    will be granted to view or modify certain tables on a per-user or per-group-of-users
    basis. Generally the RDBMS permissions facilities aren't very useful for Web applications.
    It is the Web server that is talking to the database, not a user's desktop computer.
    So the Web server is responsible for figuring out who is requesting a page and
    how much to show in response.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Your Own Source Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ArsDigita Shoppe system, described in [http://philip.greenspun.com/panda/ecommerce](/panda/ecommerce),
    represents all orders in one table, whether they were denied by the credit card
    processor, returned by the user, or voided by the merchant. This is fine for transaction
    processing but you don''t want your accounting or tax reports corrupted by the
    inclusion of failed orders. You can make a decision in one place as to what constitutes
    a reportable order and then have all of your report programs query the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Note that in the privacy example (above) we were using the view to leave unwanted
    columns behind whereas here we are using the view to leave behind unwanted rows.
  prefs: []
  type: TYPE_NORMAL
- en: If we add some order states or otherwise change the data model, the reporting
    programs need not be touched; we only have to keep this view definition up to
    date. Note that you can define every view with "create or replace view" rather
    than "create view"; this saves a bit of typing when you have to edit the definition
    later.
  prefs: []
  type: TYPE_NORMAL
- en: If you've used `select *` to define a view and subsequently alter any of the
    underlying tables, you have to redefine the view. Otherwise, your view won't contain
    any of the new columns. You might consider this a bug but Oracle has documented
    it, thus turning the behavior into a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Views-on-the-fly and OUTER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s return to our first OUTER JOIN example, from the simple queries chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The plus sign after `classified_ads.user_id` is our instruction to Oracle to
    "add NULL rows if you can't meet this JOIN constraint".
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that this report has gotten very long and we''re only interested in
    users whose email addresses start with "db". We can add a WHERE clause constraint
    on the `email` column of the `users` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Suppose that we decide we''re only interested in classified ads since January
    1, 1999\. Let''s try the naive approach, adding another WHERE clause constraint,
    this time on a column from the `classified_ads` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Hey! This completely wrecked our outer join! All of the rows where the user
    had not posted any ads have now disappeared. Why? They didn''t meet the `and classified_ads.posted
    > ''1999-01-01''` constraint. The outer join added NULLs to every column in the
    report where there was no corresponding row in the `classified_ads` table. The
    new constraint is comparing NULL to January 1, 1999 and the answer is... NULL.
    That''s three-valued logic for you. Any computation involving a NULL turns out
    NULL. Each WHERE clause constraint must evaluate to true for a row to be kept
    in the result set of the SELECT. What''s the solution? A "view on the fly". Instead
    of OUTER JOINing the `users` table to the `classified_ads`, we will OUTER JOIN
    `users` to a *view* of `classified_ads` that contains only those ads posted since
    January 1, 1999:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Note that we've named our "view on the fly" `ad_view` for the duration of this
    query.
  prefs: []
  type: TYPE_NORMAL
- en: How Views Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Programmers aren''t supposed to have to think about how views work. However,
    it is worth noting that the RDBMS merely stores the view definition and not any
    of the data in a view. Querying against a view versus the underlying tables does
    not change the way that data are retrieved or cached. Standard RDBMS views exist
    to make programming more convenient or to address security concerns, not to make
    data access more efficient. ### How *Materialized* Views Work [![Powerscourt.
    South of Dublin, Ireland.](../Images/4d87cdd0b98d5f110195d521b292ff9d.jpg)](/http://philip.greenspun.com/images/pcd0558/powerscourt-5.tcl)
    Starting with Oracle 8.1.5, introduced in March 1999, you can have a *materialized
    view*, also known as a *summary*. Like a regular view, a materialized view can
    be used to build a black-box abstraction for the programmer. In other words, the
    view might be created with a complicated JOIN, or an expensive GROUP BY with sums
    and averages. With a regular view, this expensive operation would be done every
    time you issued a query. With a materialized view, the expensive operation is
    done when the view is created and thus an individual query need not involve substantial
    computation.'
  prefs: []
  type: TYPE_NORMAL
- en: Materialized views consume space because Oracle is keeping a copy of the data
    or at least a copy of information derivable from the data. More importantly, a
    materialized view does not contain up-to-the-minute information. When you query
    a regular view, your results includes changes made up to the last committed transaction
    before your SELECT. When you query a materialized view, you're getting results
    as of the time that the view was created or refreshed. Note that Oracle lets you
    specify a refresh interval at which the materialized view will automatically be
    refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you''d expect an experienced Oracle user to say "Hey, these
    aren''t new. This is the old CREATE SNAPSHOT facility that we used to keep semi-up-to-date
    copies of tables on machines across the network!" What is new with materialized
    views is that you can create them with the ENABLE QUERY REWRITE option. This authorizes
    the SQL parser to look at a query involving aggregates or JOINs and go to the
    materialized view instead. Consider the following query, from the ArsDigita Community
    System''s /admin/users/registration-history.tcl page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: For each month, we have a count of how many users registered at photo.net. To
    execute the query, Oracle must sequentially scan the `users` table. If the users
    table grew large and you wanted the query to be instant, you'd sacrifice some
    timeliness in the stats with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Oracle will build this view just after midnight on March 28, 1999\. The view
    will be refreshed every 24 hours after that. Because of the `enable query rewrite`
    clause, Oracle will feel free to grab data from the view even when a user's query
    does not mention the view. For example, given the query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Oracle would ignore the `users` table altogether and pull information from `users_by_month`.
    This would give the same result with much less work. Suppose that the current
    month is March 1999, though. The query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: will also hit the materialized view rather than the `users` table and hence
    will miss anyone who has registered since midnight (i.e., the query rewriting
    will cause a different result to be returned).
  prefs: []
  type: TYPE_NORMAL
- en: 'More:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'High level: Oracle8 Server Concepts, [View section](http://www.oradoc.com/keyword/views).
    Oracle Application Developer''s Guide, [Managing Views section.](http://www.oradoc.com/keyword/managing_views)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Low level: Oracle8 Server SQL Reference, [Create View syntax](http://www.oradoc.com/keyword/create_view),
    and [Create Materialized View section](http://www.oradoc.com/keyword/create_materialized_view)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next: [style](style.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[philg@mit.edu](http://philip.greenspun.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Reader's Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this on views you state that condition "classified_ads.posted > '1999-01-01'
    " will not give the desired results because the column 'posted' is nullable hence
    this condition will compute to NULL whenever 'posted' column is NULL. Hence the
    query will never return rows where 'posted' value is NULL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And in order to solve this issue you go onto to create a view with the following
    query: (select * from classified_ads where posted > ''1999-01-01'')'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Wont this view suffer from the same issue? Why will this view contain columns
    where 'posted' column is NULL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Please explain.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [sanjay raj](/shared/community-member?user_id=264352), August 25, 2005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Re Sanjay Raj''s comment: Well it has been almost 9 years since you asked the
    question, so probably by now you''ve either found the answer elsewhere or lost
    interest in databases altogether. But since others might be confused and no one
    else has responded I figured I would. This view-on-the-fly (ad_view) is a list
    of all ads with dates after 1999-01-01\. This is then outer joined to the users
    table ("where users.user_id = ad_view.user_id(+)") so that users whose ids are
    included in ad_view will have their ads next to them, but all other users (including
    both those with no ads and those whose most recent ads were before 1999-01-01
    and thus didn''t make the cut for ad_view) will be listed with null/white space.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The difference is that rather than outer joining and then filtering for date,
    which breaks it because you're filtering out the nulls, you're instead filtering
    for date first by creating the view, and then outer joining, so you don't touch
    the nulls after they're created.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Dan Cusher](/shared/community-member?user_id=348055), June 10, 2014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Add a comment](/comments/add?page_id=3463)'
  prefs: []
  type: TYPE_NORMAL
