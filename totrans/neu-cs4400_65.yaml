- en: The Toy LanguageTuesday, February 28th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not in PLAI
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A quick note: from now on, we will work with a variation of our language —
    it will change the syntax to look a little more like Racket, and we will use Racket
    values for values in our language and Racket functions for built-ins in our language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Main highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: There can be multiple bindings in function arguments and local `bind` forms
    — the names are required to be distinct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are now a few keywords like `bind` that are parsed in a special way. Other
    forms are taken as function application, which means that there are no special
    parse rules (and AST entries) for arithmetic functions. They’re now bindings in
    the global environment, and treated in the same way as all bindings. For example,
    `*` is an expression that evaluates to the *primitive* multiplication function,
    and `{bind {{+ *}} {+ 2 3}}` evaluates to `6`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since function applications are now the same for primitive functions and user-bound
    functions, there is no need for a `call` keyword. Note that the function call
    part of the parser must be last, since it should apply only if the input is not
    some other known form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note the use of `make-untyped-list-function`: it’s a library function (included
    in the course language) that can convert a few known Racket functions to a function
    that consumes a list of *any* Racket values, and returns the result of applying
    the given Racket function on these values. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: evaluates to `10`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another important aspect of this is its type — the type of `add` in the previous
    example is `(List -> Any)`, so the resulting function can consume *any* input
    values. If it gets a bad value, it will throw an appropriate error. This is a
    hack: it basically means that the resulting `add` function has a very generic
    type (requiring just a list), so errors can be thrown at run-time. However, in
    this case, a better solution is not going to make these run-time errors go away
    because the language that we’re implementing is not statically typed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of this is that we can avoid the hassle of more verbose code by
    letting these functions dynamically check the input values, so we can use a single
    `RktV` variant in `VAL` which wraps any Racket value. (Otherwise we’d need different
    wrappers for different types, and implement these dynamic checks.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is the complete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
