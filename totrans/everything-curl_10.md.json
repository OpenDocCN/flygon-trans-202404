["```\nCURL *easy_handle = curl_easy_init(); \n```", "```\n/* set URL to operate on */\nres = curl_easy_setopt(easy_handle, CURLOPT_URL, \"http://example.com/\"); \n```", "```\nres = curl_easy_perform( easy_handle ); \n```", "```\nCURLM *multi_handle = curl_multi_init(); \n```", "```\ncurl_multi_add_handle( multi_handle, easy_handle ); \n```", "```\ncurl_multi_remove_handle( multi_handle, easy_handle ); \n```", "```\nint transfers_running;\ndo {\n   curl_multi_wait ( multi_handle, NULL, 0, 1000, NULL);\n   curl_multi_perform ( multi_handle, &transfers_running );\n} while (transfers_running); \n```", "```\nint transfers_running;\ndo {\n  fd_set fdread;\n  fd_set fdwrite;\n  fd_set fdexcep;\n  int maxfd = -1;\n  long timeout;\n\n  /* extract timeout value */\n  curl_multi_timeout(multi_handle, &timeout);\n  if (timeout < 0)\n    timeout = 1000;\n\n  /* convert to struct usable by select */\n  timeout.tv_sec = timeout / 1000;\n  timeout.tv_usec = (timeout % 1000) * 1000;\n\n  FD_ZERO(&fdread);\n  FD_ZERO(&fdwrite);\n  FD_ZERO(&fdexcep);\n\n  /* get file descriptors from the transfers */\n  mc = curl_multi_fdset(multi_handle, &fdread, &fdwrite, &fdexcep, &maxfd);\n\n  if (maxfd == -1) {\n    SHORT_SLEEP;\n  }\n  else\n   select(maxfd+1, &fdread, &fdwrite, &fdexcep, &timeout);\n\n  /* timeout or readable/writable sockets */\n  curl_multi_perform(multi_handle, &transfers_running);\n} while ( transfers_running ); \n```", "```\nint socket_callback(CURL *easy,      /* easy handle */\n                    curl_socket_t s, /* socket */\n                    int what,        /* what to wait for */\n                    void *userp,     /* private callback pointer */\n                    void *socketp)   /* private socket pointer */\n{\n   /* told about the socket 's' */\n}\n\n/* set the callback in the multi handle */\ncurl_multi_setopt(multi_handle, CURLMOPT_SOCKETFUNCTION, socket_callback); \n```", "```\nint running_handles;\nret = curl_multi_socket_action(multi_handle,\n                               sockfd, /* the socket with activity */\n                               ev_bitmask, /* the specific activity */\n                               &running_handles); \n```", "```\nint timer_callback(multi_handle,   /* multi handle */\n                   timeout_ms,     /* milliseconds to wait */\n                   userp)          /* private callback pointer */\n{\n  /* the new time-out value to wait for is in 'timeout_ms' */\n}\n\n/* set the callback in the multi handle */\ncurl_multi_setopt(multi_handle, CURLMOPT_TIMERFUNCTION, timer_callback); \n```", "```\ncurl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0, &running); \n```", "```\n/* all easy handles and callbacks are setup */\n\ncurl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0, &running);\n\n/* now the callbacks should have been called and we have sockets to wait for\n   and possibly a timeout, too. Make the event system do its magic */\n\nevent_base_dispatch(event_base); /* libevent2 has this API */\n\n/* at this point we have exited the event loop */ \n```", "```\ncurl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, write_callback); \n```", "```\nsize_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_WRITEDATA, custom_pointer); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_READFUNCTION, read_callback); \n```", "```\nsize_t read_callback(char *buffer, size_t size, size_t nitems, void *stream); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_READDATA, custom_pointer); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_XFERINFOFUNCTION, xfer_callback); \n```", "```\nint xfer_callback(void *clientp, curl_off_t dltotal, curl_off_t dlnow,\n                  curl_off_t ultotal, curl_off_t ulnow); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_XFERINFODATA, custom_pointer); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_HEADERFUNCTION, header_callback); \n```", "```\nsize_t header_callback(char *ptr, size_t size, size_t nmemb, void *userdata); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_HEADERDATA, custom_pointer); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_DEBUGFUNCTION, debug_callback); \n```", "```\nint debug_callback(CURL *handle,\n                   curl_infotype type,\n                   char *data,\n                   size_t size,\n                   void *userdata); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_DEBUGDATA, custom_pointer); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_SOCKOPTFUNCTION, sockopt_callback); \n```", "```\nint sockopt_callback(void *clientp,\n                     curl_socket_t curlfd,\n                     curlsocktype purpose); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_SOCKOPTDATA, custom_pointer); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_OPENSOCKETFUNCTION, opensocket_callback); \n```", "```\ncurl_socket_t opensocket_callback(void *clientp,\n                                  curlsocktype purpose,\n                                  struct curl_sockaddr *address); \n```", "```\nstruct curl_sockaddr {\n  int family;\n  int socktype;\n  int protocol;\n  unsigned int addrlen;\n  struct sockaddr addr;\n}; \n```", "```\ncurl_easy_setopt(handle, CURLOPT_CLOSEOCKETFUNCTION, closesocket_callback); \n```", "```\nint closesocket_callback(void *clientp, curl_socket_t item); \n```", "```\ncurl_multi_cleanup( multi_handle ); \n```", "```\ncurl_easy_cleanup( easy_handle ); \n```", "```\ncurl_easy_setopt(easy, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V6); \n```", "```\nstruct curl_slist *dns;\ndns = curl_slist_append(NULL, \"example.com:443:127.0.0.1\");\ncurl_easy_setopt(curl, CURLOPT_RESOLVE, dns); \n```", "```\nsocks4://proxy.example.com:12345/\nsocks4a://proxy.example.com:12345/\nsocks5://proxy.example.com:12345/\nsocks5h://proxy.example.com:12345/\nhttp://proxy.example.com:12345/\nhttps://proxy.example.com:12345/ \n```", "```\nCURLcode res;\nchar *content_type;\nres = curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &content_type); \n```", "```\nCURLcode res;\nlong port_number;\nres = curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &port_number); \n```", "```\nCURLSH *share = curl_share_init(); \n```", "```\ncurl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);\ncurl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS); \n```", "```\ncurl_easy_setopt(curl, CURLOPT_SHARE, share); \n```", "```\nstatic void lock_cb(CURL *handle, curl_lock_data data,\n                    curl_lock_access access, void *userptr)\n{\n  pthread_mutex_lock(&lock[data]); /* uses a global lock array */\n}\ncurl_share_setopt(share, CURLSHOPT_LOCKFUNC, lock_cb); \n```", "```\nstatic void unlock_cb(CURL *handle, curl_lock_data data,\n                      void *userptr)\n{\n  pthread_mutex_unlock(&lock[data]); /* uses a global lock array */\n}\ncurl_share_setopt(share, CURLSHOPT_UNLOCKFUNC, unlock_cb); \n```", "```\nX.Y.Z \n```", "```\n#define LIBCURL_VERSION_NUM 0xXXYYZZ \n```", "```\nstruct {\n  CURLversion age;          /* see description below */\n\n  /* when 'age' is 0 or higher, the members below also exist: */\n  const char *version;      /* human readable string */\n  unsigned int version_num; /* numeric representation */\n  const char *host;         /* human readable string */\n  int features;             /* bitmask, see below */\n  char *ssl_version;        /* human readable string */\n  long ssl_version_num;     /* not used, always zero */\n  const char *libz_version; /* human readable string */\n  const char * const *protocols; /* protocols */\n\n  /* when 'age' is 1 or higher, the members below also exist: */\n  const char *ares;         /* human readable string */\n  int ares_num;             /* number */\n\n  /* when 'age' is 2 or higher, the member below also exists: */\n  const char *libidn;       /* human readable string */\n\n  /* when 'age' is 3 or higher (7.16.1 or later), the members below also\n     exist  */\n  int iconv_ver_num;       /* '_libiconv_version' if iconv support enabled */\n\n  const char *libssh_version; /* human readable string */\n\n} curl_version_info_data; \n```", "```\ncurl http://example.com --libcurl example.c \n```", "```\n/********* Sample code generated by the curl command-line tool **********\n * All curl_easy_setopt() options are documented at:\n * https://curl.haxx.se/libcurl/c/curl_easy_setopt.html\n ************************************************************************/\n#include <curl/curl.h>\n\nint main(int argc, char *argv[])\n{\n  CURLcode ret;\n  CURL *hnd;\n\n  hnd = curl_easy_init();\n  curl_easy_setopt(hnd, CURLOPT_URL, \"http://example.com\");\n  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);\n  curl_easy_setopt(hnd, CURLOPT_USERAGENT, \"curl/7.45.0\");\n  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);\n  curl_easy_setopt(hnd, CURLOPT_SSH_KNOWNHOSTS, \"/home/daniel/.ssh/known_hosts\");\n  curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);\n\n  /* Here is a list of options the curl code used that cannot get generated\n     as source easily. You may select to either not use them or implement\n     them yourself.\n\n  CURLOPT_WRITEDATA set to a objectpointer\n  CURLOPT_WRITEFUNCTION set to a functionpointer\n  CURLOPT_READDATA set to a objectpointer\n  CURLOPT_READFUNCTION set to a functionpointer\n  CURLOPT_SEEKDATA set to a objectpointer\n  CURLOPT_SEEKFUNCTION set to a functionpointer\n  CURLOPT_ERRORBUFFER set to a objectpointer\n  CURLOPT_STDERR set to a objectpointer\n  CURLOPT_HEADERFUNCTION set to a functionpointer\n  CURLOPT_HEADERDATA set to a objectpointer\n\n  */\n\n  ret = curl_easy_perform(hnd);\n\n  curl_easy_cleanup(hnd);\n  hnd = NULL;\n\n  return (int)ret;\n}\n/**** End of sample code ****/ \n```", "```\n#include <curl/curl.h> \n```", "```\nCURLcode ret = curl_easy_setopt(easy, CURLOPT_URL, \"http://example.com\"); \n```", "```\ncurl_easy_setopt(handle, CURLOPT_TIMEOUT, 5L); /* 5 seconds timeout */ \n```", "```\ncurl_off_t no_larger_than = 0x50000;\ncurl_easy_setopt(handle, CURLOPT_MAXFILE_LARGE, no_larger_than); \n```", "```\nconst char *str = curl_easy_strerror( error );\nprintf(\"libcurl said %s\\n\", str); \n```", "```\ncurl error[CURL_ERROR_SIZE]; /* needs to be at least this big */\nCURLcode ret = curl_easy_setopt(handle, CURLOPT_ERRORBUFFER, error); \n```", "```\nCURLcode ret = curl_easy_setopt(handle, CURLOPT_VERBOSE, 1L); \n```", "```\nint my_trace(CURL *handle, curl_infotype type, char *ptr, size_t size,\n             void *userp); \n```", "```\n#include <stdio.h>\n#include <curl/curl.h>\n\nint main(void)\n{\n  CURL *curl;\n  CURLcode res;\n\n  curl = curl_easy_init();\n  if(curl) {\n    curl_easy_setopt(curl, CURLOPT_URL, \"http://example.com/\");\n\n    /* Perform the request, res will get the return code */\n    res = curl_easy_perform(curl);\n    /* Check for errors */\n    if(res != CURLE_OK)\n      fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n              curl_easy_strerror(res));\n\n    /* always cleanup */\n    curl_easy_cleanup(curl);\n  }\n  return 0;\n} \n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <curl/curl.h>\n\nstruct MemoryStruct {\n  char *memory;\n  size_t size;\n};\n\nstatic size_t\nWriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)\n{\n  size_t realsize = size * nmemb;\n  struct MemoryStruct *mem = (struct MemoryStruct *)userp;\n\n  mem->memory = realloc(mem->memory, mem->size + realsize + 1);\n  if(mem->memory == NULL) {\n    /* out of memory! */\n    printf(\"not enough memory (realloc returned NULL)\\n\");\n    return 0;\n  }\n\n  memcpy(&(mem->memory[mem->size]), contents, realsize);\n  mem->size += realsize;\n  mem->memory[mem->size] = 0;\n\n  return realsize;\n}\n\nint main(void)\n{\n  CURL *curl_handle;\n  CURLcode res;\n\n  struct MemoryStruct chunk;\n\n  chunk.memory = malloc(1);  /* will be grown as needed by the realloc above */\n  chunk.size = 0;    /* no data at this point */\n\n  curl_global_init(CURL_GLOBAL_ALL);\n\n  /* init the curl session */\n  curl_handle = curl_easy_init();\n\n  /* specify URL to get */\n  curl_easy_setopt(curl_handle, CURLOPT_URL, \"http://www.example.com/\");\n\n  /* send all data to this function  */\n  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n\n  /* we pass our 'chunk' struct to the callback function */\n  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);\n\n  /* some servers don't like requests that are made without a user-agent\n     field, so we provide one */\n  curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"libcurl-agent/1.0\");\n\n  /* get it! */\n  res = curl_easy_perform(curl_handle);\n\n  /* check for errors */\n  if(res != CURLE_OK) {\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  }\n  else {\n    /*\n     * Now, our chunk.memory points to a memory block that is chunk.size\n     * bytes big and contains the remote file.\n     *\n     * Do something nice with it!\n     */\n\n    printf(\"%lu bytes retrieved\\n\", (long)chunk.size);\n  }\n\n  /* cleanup curl stuff */\n  curl_easy_cleanup(curl_handle);\n\n  free(chunk.memory);\n\n  /* we're done with libcurl, so clean it up */\n  curl_global_cleanup();\n\n  return 0;\n} \n```"]