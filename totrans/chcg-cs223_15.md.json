["```\nenqueue : a -> Queue a -> Queue a\ndequeue : Queue a -> Maybe (Queue a)\npeek    : Queue a -> Maybe a \n```", "```\ntype Queue a = Q (List a)\n\nempty : Queue a\nempty = Q []\n\nisEmpty : Queue a -> Bool\nisEmpty q = q == empty\n\nenqueue : a -> Queue a -> Queue a\nenqueue x (Q xs) = Q (xs ++ [x])\n\ndequeue : Queue a -> Maybe (Queue a)\ndequeue (Q xs) = case xs of\n  _::xs' -> Just (Q xs')\n  []     -> Nothing\n\npeek : Queue a -> Maybe a\npeek (Q xs) = case xs of\n  x::_   -> Just x\n  []     -> Nothing \n```", "```\ntype Queue a = Front (List a) | Back (List a)\n\nempty : Queue a\nempty = Front []\n\nisEmpty : Queue a -> Bool\nisEmpty q = case q of\n  Front [] -> True\n  Back []  -> True\n  _        -> False\n\nenqueue : a -> Queue a -> Queue a\nenqueue x q = case q of\n  Front xs -> Back (x :: List.reverse xs)\n  Back xs  -> Back (x :: xs)\n\ndequeue : Queue a -> Maybe (Queue a)\ndequeue q = case q of\n  Back []      -> Nothing\n  Back (x::xs) -> Just (Back xs)\n  Front xs     -> dequeue (Back (List.reverse xs))\n\npeek : Queue a -> Maybe a\npeek q = case q of\n  Back []      -> Nothing\n  Back (x::_)  -> Just x\n  Front xs     -> peek (Back (List.reverse xs)) \n```", "```\ntype Queue a = Q { front: List a, back: List a }\n\nmkQ f b = Q {front = f, back = b}\n\nempty : Queue a\nempty = mkQ [] []\n\nisEmpty : Queue a -> Bool\nisEmpty q = q == empty\n\nenqueue : a -> Queue a -> Queue a\nenqueue x (Q {front, back}) = mkQ front (x::back)\n\ndequeue : Queue a -> Maybe (Queue a)\ndequeue (Q {front, back}) = case (front, back) of\n  (_::f', _) -> Just (mkQ f' back) \n  ([], [])   -> Nothing\n  ([], _)    -> dequeue (mkQ (List.reverse back) [])\n\npeek : Queue a -> Maybe a\npeek (Q {front, back}) = case (front, back) of\n  (x::_, _)  -> Just x\n  ([], [])   -> Nothing\n  ([], _)    -> peek (mkQ (List.reverse back) []) \n```", "```\nenqueue : a -> Queue a -> Queue a\nenqueue x (Q {front, back}) = case (front, back) of\n  ([], _) -> mkQ [x] []\n  _       -> mkQ front (x::back)\n\ndequeue : Queue a -> Maybe (Queue a)\ndequeue (Q {front, back}) = case (front, back) of\n  ([]   , _) -> Nothing\n  (_::[], _) -> Just (mkQ (List.reverse back) [])\n  (_::f', _) -> Just (mkQ f' back) \n\npeek : Queue a -> Maybe a\npeek (Q {front, back}) = case (front, back) of\n  (x::_, _) -> Just x\n  ([]  , _) -> Nothing \n```", "```\ncheckFront : List a -> List a -> Queue a\ncheckFront f b = case (f, b) of\n  ([], _) -> mkQ (List.reverse b) []\n  (_ , _) -> mkQ f b\n\nenqueue' : a -> Queue a -> Queue a\nenqueue' x (Q {front, back}) = checkFront front (x::back)\n\ndequeue' : Queue a -> Maybe (Queue a)\ndequeue' (Q {front, back}) = case front of\n  []    -> Nothing\n  _::f' -> Just (checkFront f' back) \n```"]