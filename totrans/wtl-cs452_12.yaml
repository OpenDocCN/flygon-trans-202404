- en: Lecture 12 - Hardware Interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Public Service Annoucements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wednesday's class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you need it?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment 3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Interrupts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a Hardware Interrupt?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Context Switches for Interrupts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Difference from Software Interrupts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is impossible to predict where they occur
  prefs: []
  type: TYPE_NORMAL
- en: You may have made some assumptions about when they occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assymmetry between User Task and Kernel
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Scratch Registers must be saved
  prefs: []
  type: TYPE_NORMAL
- en: for the user task, not for the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: including the IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helpful Features of the ICU
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Several places where you can read state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Several places where you can block interrupt flow
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trigger hardware interrupt from software
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What makes interrupts hard is that you are doing two semi-hard things at once
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the hardware produce the interrupt
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Responding to the interrupt
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows you to separate them in developing/debugging
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The Hardware in the Trains Lab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 32-bit Timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interrupt Control Unit (ICU)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The actual device is the ARM PL190
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Definitions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Registers for Basic Operation**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Register Name | Offset | R/W | Description |'
  prefs: []
  type: TYPE_TB
- en: '| VICxIRQStatus | 0x00 | RO | One bit for each interrupt source1 if interrupt
    is asserted and enabled |'
  prefs: []
  type: TYPE_TB
- en: '| VICxFIQStatus | 0x04 | RO | As above for FIQ |'
  prefs: []
  type: TYPE_TB
- en: '| VICxRawIntr | 0x08 | RO | As above but not masked |'
  prefs: []
  type: TYPE_TB
- en: '| VICxIntSelect | 0x0c | R/W | 0: IRQ, 1: FIQ |'
  prefs: []
  type: TYPE_TB
- en: '| VICxIntEnable | 0x10 | R/W | 0: Masked, 1: Enabled |'
  prefs: []
  type: TYPE_TB
- en: '| VICxIntEnClear | 0x14 | WO | Clears bits in VICxIntEnable |'
  prefs: []
  type: TYPE_TB
- en: '| VICxSoftInt | 0x18 | R/W | Asserts interrupt from software |'
  prefs: []
  type: TYPE_TB
- en: '| VICxSoftIntClear | 0x1c | WO | Clears interrupt from software |'
  prefs: []
  type: TYPE_TB
- en: '| VICxProtection | 0x20 | R/W | Bit 0 enables protection from user mode access
    |'
  prefs: []
  type: TYPE_TB
- en: '| VICxVectAddr | 0x30 | R/W | Enables priority hardwareSee documentation. |'
  prefs: []
  type: TYPE_TB
- en: Helpful Features of the ICU
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Several places where you can read state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Several places where you can block interrupt flow
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trigger hardware interrupt from softwareonce
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What makes interrupts hard is that you are doing two semi-hard things at once
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Making the hardware produce the interrupt
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to the interrupt
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Software interrupt generation allows you to separate them in developing/debugging
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Non-vectored Operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enable interrupt in device
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes there is a spurious interrupt that comes in, sometimes not.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable interrupt in ICU
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable interrupt in CPU, usually by MOVS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interrupt occurs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: AND of IRQ and NOT( IRQ disabled ) is checked before each instruction fetch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If set IRQ exception is taken in place of next instruction fetch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Possibly zero instructions of active task are executed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that this case works
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Context switch into kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Context switch novelties
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
- en: Difference from Software Interrupts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is impossible to predict where they occur
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You may inadvertently have made some assumptions about when they occur
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scratch Registers must be saved
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: r0-3
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IP -- used only very occasionally by gcc
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you differentiate between IRQ and SWI?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two Link Registers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One to return from interrupt
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One to return from the interrupted task to whatever called it
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Locate source of interrupt
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect volatile data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off interrupt in device
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Goes off automatically in the ICU
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn off interrupt in device
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should turn off interrupt in ICU
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What about IRQ?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You are now ready to process the interrupt in the kernel
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Vectored Operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: General Idea
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The standard way of programming the ICU requires the kernel to query the ICU.
    Sometimes (!), this is unacceptably inefficient. Then, you have another alternative,
    vectored interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Relevant registers:'
  prefs: []
  type: TYPE_NORMAL
- en: there are 16 pairs that you write
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Register Name | Offset | R/W | Description | Comments |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VICxVectAddry | 0x100+4y | R/W | Vector address for interrupt y | Entry point
    of ISR for interrupt y |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VICxVectCntly | 0x200+4y | R/W | Control register for interrupt y | Bit[0-4]:
    interrupt source for interrupt y Bit[5]: enable vectored interrupt y |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: There is one pair used by the program
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Register Name | Offset | R/W | Description |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VICxVectAddr | 0x030 | R/W | Read: address of vector for highest priority
    interruptWrite: service complete, enable priority hardware |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VICxDefVectAddr | 0x034 | R/W | Default vector address |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The first is the address (ISR entry point) of the highest priority interrupt.
    Write it during interrupt processing to get the current highest priority interrupt.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second would normally be 0x34, the entry point of the kernel.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Initialization
  prefs: []
  type: TYPE_NORMAL
- en: Write kernel entry point into VICxDefVectAddr
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If desired write special entry point into VICxVectAddry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When ready to accept interrupts write source and enable into VICxVectCntly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an interrupt occurs
  prefs: []
  type: TYPE_NORMAL
- en: Read VICxVectAddr to find address
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move result to PC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: (Note that this is similar to the instruction in 0x014\. Could we do it all
    in one?)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before interrupts are re-enabled write VICxVectAddr to start priority hardware
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer to question.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look carefully at what's in 0x18
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, `ldr pc, [pc, #offset]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can you make [pc, #offset] calculate `<VicVectAddr>`?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How is the instruction encoded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31:28 - condition codes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27:20 - op code and flags, 0101<offset sign>001
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 19:16 - base register
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 15:12 - destination register
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11:00 - 12-bit offset
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With a 12 bit offset and pc=0x18 you can address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: from `0x18 + 0x8 - 0xffc = -0xfdc =``0xfffff020`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: to `0x18 + 0x8 + 0xffc = 0x1020`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You could have the kernel entry point in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: either `0x800b0030`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: or `0x800c0030`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Both are out of range. What could you do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map the ICU into the range by placing it at, for example, `0xfffff000`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Clock Server, Task Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A New Kernel Primitive: int AwaitEvent( int EventType )'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How is AwaitEvent Used?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There should (almost) always be a task blocked on AwaitEvent for every interrupt
    type. Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A server cannot call AwaitEvent. Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the task that calls AwaitEvent a Notifier. Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code for a typical Notifier
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Code for a typical server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: More About AwaitEvent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Argument
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Somewhere there is a list of event types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application programmer knows the list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel can respond to each event type on the list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not very portable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list would normally be the union of all types occurring on all hardware
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the Windows problem
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing in the kernel
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel initialization has IRQ masked
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kernel initializes ICU
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For each device
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kernel initializes hardware
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kernel turns on interrupt(s) in the device
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kernel starts first user task
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Eventually, Notifier is created
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Notifier
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: initializes device
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: turns on interrupt(s) in the device
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: turns on interrupt(s) in the ICU
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: calls AwaitEvent
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: identifies interrupt source
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: identifies the correct Notifier
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: acquires volatile data
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: re-enables interrupt in the device
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: re-enables interrupt in the ICU
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: re-enables interrupt in the CPU during task activation (eg, `movs`)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: puts volatile data into AwaitEvent's return value
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Makes Notifier ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Notifier
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: collects and packages data
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: sends to server
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Eventually Server
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Replies to Notifier
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean consistent user code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel has to know a lot about the hardware.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware knowledge split between Notifier and kernel
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HALT versus an Idle Task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What do you do when there are no tasks to run?
  prefs: []
  type: TYPE_NORMAL
- en: Idle task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lowest priority
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: diagnose system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: search for ETI
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HALT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: turns off CPU clock
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: save power (battery)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: provided two ways
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: through System Controller Co-processor
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: through the TS-7200 clock controller
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: IRQ path is asynchronous, so it works when the clock is off
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Clock Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primitives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Clock server starts at zero when it initializes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit of time is tick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note error returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might want to add an error for negative arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ticks is usually calculated, and a negative value is an early warning of falling
    behind.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Can be constructed from the above two primitives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Comments:'
  prefs: []
  type: TYPE_NORMAL
- en: You need a common request type, or possibly a union.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should notice a typical server pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notifier updates data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Client who can be serviced now is serviced
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Client who needs service in the future is suspended
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: List of suspended tasks is checked regularly
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It's normal to sort the list of suspended tasks. Why?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bill Cowan''s lecture notes for CS452 in s12](index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s Spring 2012 CS452 page](../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s CS452 page](../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s teaching page](../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s home page](../../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
