- en: Leftist Heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Representation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For simplicity, we'll continue to work with heaps of `Int`s. A node `T r i a
    b` contains its rank `r`, which is the length of its rightmost spine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Helper functions for leftist heaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Invariants
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*∀`h`. (`value(h)` ≤ `value(left(h))`) ∧ (`value(h)` ≤ `value(right(h))`)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*∀`h`. `rank(left(h))` ≥ `rank(right(h))`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-Class Exercise**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Prove: *∀`h`. `rank(h)` = `r` ⇒ `size(h)` ≥ `2^r - 1`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prove: *∀`h`. `size(h)` = `n` ⇒ `rank(h)` ≤ `log(floor(n+1)))`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the right spine of a leftist heap `h` of size `n` has *O(`log n`)* elements.
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike for regular min-heaps, merging leftist heaps runs quickly (faster than
    *O(n)*) by taking advantage of the fact that right spines are short (*O(log n)*).
  prefs: []
  type: TYPE_NORMAL
- en: The helper function `makeT` creates a `T` node that stores `x` and positions
    `h1` and `h2` as its children depending on their rank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The following is an equivalent definition of `makeT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `merge` function combines two non-empty heaps by choosing the smaller of
    their two minimum values and recursively merging, using `makeT` to place "heavier"
    subtrees to the left.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `makeT` function runs in *O(1)* time. The running time of `merge` is dominated
    by its recursive calls. Let *n* be the size of the larger of the two heaps. The
    leftist property ensures that the right spine of each heap has *O(log n)* elements.
    Because the recursive calls traverse the right spine of one of the input heaps,
    there are at most *O(log n)* recursive calls, each of which performs *O(1)* work.
    Therefore, `merge` runs in *O(log n)* time.
  prefs: []
  type: TYPE_NORMAL
- en: Rest of Interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Insertion and deletion can be defined in terms of `merge`, so each runs in *O(log
    n)* time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the rest of the heap abstraction is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our implementation ([`LeftistHeaps.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/LeftistHeaps.elm))
    exports the same type signatures as the vanilla implementation of min-heaps from
    before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice how sequences of `insert`s pile up elements heavily to the left.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Required
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Okasaki, Chapter 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
