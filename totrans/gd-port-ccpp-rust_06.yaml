- en: C and C++ Background
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 和 C++ 背景
- en: C and C++ Background
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 和 C++ 背景
- en: This section talks about C and C++. It describes its history, standards and
    provides a background as to how it ended up where it is today.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 C 和 C++。它描述了它的历史、标准，并提供了一个背景，说明它是如何发展到今天的。
- en: History of C
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 的历史
- en: Early Days
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 早期
- en: The creation of C is closely associated with the early days of Unix. Bell Labs
    developed Unix out of an earlier project called Multics. The first version of
    Unix ran on PDP-7 microcomputer and funding was given to move it to PDP-11\. Dennis
    Ritchie was a key member on this project and set about creating a language that
    could help him develop Unix while minimizing the amount of assembly language he
    had to write. Most of the code up to that point was expressed in assembly language
    which was error prone and obviously non portable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: C 的创建与 Unix 的早期有着密切关联。贝尔实验室将 Unix 开发出来，这是从一个名为 Multics 的早期项目发展而来的。Unix 的第一个版本在
    PDP-7 微型计算机上运行，资金被提供用于将其移植到 PDP-11。Dennis Ritchie 是这个项目的关键成员，他着手创建一种语言，可以帮助他开发
    Unix，同时最大限度地减少他必须编写的汇编语言量。到那时为止，大部分代码都是用汇编语言表达的，这种方式容易出错，显然不可移植。
- en: Ritchie developed C so that he could write code in terms of variables, expressions,
    loops, functions etc. and use a *compiler* to translate C code into machine code.
    The generated code ran almost as fast as hand written assembly and was more portable
    since only the compiler had to be changed in order to support a new architecture.
    C itself was influenced by B (hence why it was called C), which itself was influenced
    by BCPL.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Ritchie 开发了 C，以便他可以用变量、表达式、循环、函数等来编写代码，并使用 *编译器* 将 C 代码转换为机器代码。生成的代码几乎与手写的汇编代码一样快，并且更具可移植性，因为只需更改编译器即可支持新的架构。C
    本身受到 B 的影响（因此被称为 C），而 B 受到 BCPL 的影响。
- en: Defacto standard and emerging popularity
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事实标准和日益流行
- en: In 1978 C was formalised into a defacto standard called K&R C, named after Brian
    Kernighan & Dennis Ritche who published the standard as a book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 1978 年，C 被正式制定为一个名为 K&R C 的事实标准，以 Brian Kernighan 和 Dennis Ritche 的名字命名，他们将该标准出版为一本书。
- en: Over time the use of C became more widespread and compilers such as Turbo C,
    Lattice C, Microsoft C popularized C on other operating systems including personal
    computers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，C 的使用变得更加广泛，诸如 Turbo C、Lattice C、Microsoft C 等编译器在其他操作系统上（包括个人计算机）推广了
    C。
- en: International Standards
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 国际标准
- en: C later became an ANSI standard, C89\. A further standard followed with C99
    and C is still under review and development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C 后来成为 ANSI 标准，C89。随后又有了 C99 标准，C 仍在审查和发展中。
- en: Some functionality that was introduced in C++ has also found its way back into
    C standards. For example, the // style single-line comment and variable declaration
    rules in blocks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在 C++ 中引入的功能也已经回归到 C 标准中。例如，// 样式的单行注释和块内变量声明规则。
- en: History of C++
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 的历史
- en: C++ first appeared in 1983 as C with classes. It was invented by Bjarne Stroustrop
    as a way to imbue C with Simula-like features. Simula is a language that allowed
    concepts such as objects, classes and inheritance to be expressed in code and
    as its name suggests was created for running simulations. However it was considered
    too slow for systems programming and so something that combined speed of C with
    object oriented concepts was highly desirable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 首次出现在 1983 年，称为 C with classes。它是由 Bjarne Stroustrop 发明的，作为赋予 C 类似 Simula
    特性的一种方式。Simula 是一种允许对象、类和继承等概念在代码中表达的语言，正如其名称所暗示的那样，是为了运行模拟而创建的。然而，它被认为对于系统编程来说太慢了，因此将
    C 的速度与面向对象的概念结合起来是非常可取的。
- en: C++ added these concepts as extensions to the C language and used a precompiler
    called `cfront` to transform the C++ extensions into C code that could then be
    compiled into machine code. So a C++ program could have the high level object
    oriented concepts but without the overhead that came with Simula.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 将这些概念作为 C 语言的扩展，并使用一个名为 `cfront` 的预编译器将 C++ 扩展转换为 C 代码，然后可以将其编译成机器代码。因此，C++
    程序可以具有高级面向对象的概念，但没有 Simula 带来的开销。
- en: C++ became popular in its own right and outgrew the limitations of cfront preprocessor
    to become supported by compilers in its own right. Thus toolchains such as Microsoft
    Visual C++, GCC, Clang etc. support both languages. Some toolchains have also
    been given to favouring C++ over C, for example Microsoft's compiler has been
    very slow to implement C99.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 逐渐成为独立流行，并超越了 cfront 预处理器的限制，成为编译器自身支持的语言。因此，诸如 Microsoft Visual C++、GCC、Clang
    等工具链都支持这两种语言。一些工具链也开始倾向于支持 C++ 而不是 C，例如微软的编译器一直很慢地实现 C99。
- en: Object oriented programming has mostly been used in higher level software -
    applications, games, simulations and mathematical work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程主要用于更高级别的软件 - 应用程序、游戏、模拟和数学工作。
- en: C++ has also become formalised standards with C++98, C++03, C++11 and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++也已经成为正式的标准，有C++98、C++03、C++11等。
- en: Modern C++
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 现代C++
- en: 'C++11 onwards is a distinctly different beast from earlier iterations and strives
    to add functionality that if used correctly can eliminate a lot of issues that
    will be discussed later on:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++11开始，它与早期版本有着明显的不同，努力添加功能，如果正确使用，可以消除后面将讨论的许多问题：
- en: Scoped and shared pointers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域和共享指针
- en: auto keyword
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: auto关键字
- en: move semantics (i.e. moving data ownership of data from one variable to another)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动语义（即将数据所有权从一个变量移动到另一个变量）
- en: rvalue references
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右值引用
- en: perfect forwarding
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完美转发
- en: nullptr explicit type
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空指针显式类型
- en: However it is worth noting that since many of these things are late additions
    to C++. Things like move semantics must be explicitly used and have implications
    that are not an issue for Rust where they have been part of the language since
    early on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，由于许多这些东西是C++的后期添加。像移动语义这样的东西必须显式使用，并且具有在Rust中不存在的影响，因为它们从一开始就是语言的一部分。
- en: The relationship between C and C++
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C和C++之间的关系
- en: While C++ grew out of C and has developed alongside it, it is not true to say
    C++ is a superset of C. Rather it is *mostly* a superset. There are differences
    such as keywords and headers that C recognizes that C++ does not.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++起源于C并与之并行发展，但不能说C++是C的超集。相反，它*大部分*是一个超集。例如，C认识到的关键字和头文件在C++中不认识。
- en: C++ has function overloading and classes and uses name mangling to disambiguate
    overloaded functions. But in practice it is possible to write C as a subset of
    C++ and compile the two into the same executable. Most real-world C code could
    be called C++ *without* classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C++具有函数重载和类，并使用名称混淆来消除重载函数的歧义。但实际上可以将C写成C++的子集，并将两者编译成相同的可执行文件。大多数现实世界的C代码可以称为没有类的C++。
- en: C and C++ are even usually handled by the same toolchain. Most compilers would
    consist of a front half that parses the language into an intermediate form and
    a back half which turns the intermediate form into optimized machine code. Finally
    the linker would join all the binary objects together to form an executable. C
    and C++ would share most of this code path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++通常由相同的工具链处理。大多数编译器由一个前端解析语言为中间形式和一个后端将中间形式转换为优化的机器代码组成。最后，链接器将所有二进制对象连接在一起形成可执行文件。C和C++将共享大部分这个代码路径。
- en: C++ tends to be more popular with applications level programming. Part of the
    reason C++ hasn't found itself in the lower layers is the perception that exception
    handling, name mangling, linking and issues of that nature add unwanted complexity
    or that somehow the generated code is less efficient. Arguments have been made
    that this is not the case, but the perception still remains.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C++倾向于在应用程序级别编程中更受欢迎。C++没有出现在较低层的部分的部分原因是人们认为异常处理、名称混淆、链接等问题增加了不必要的复杂性，或者生成的代码效率不高。有人认为这并非如此，但这种看法仍然存在。
- en: C still tends to be more popular in low level systems programming. Components
    such as the Linux kernel are pure C with some assembly. Many popular open source
    libraries such as sqlite3 are also written in C.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C仍然在低级系统编程中更受欢迎。诸如Linux内核之类的组件是纯C编写的，还有一些汇编语言。许多流行的开源库，如sqlite3，也是用C编写的。
- en: Objective-C
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Objective-C
- en: Objective-C is another C derived language that added objects and classes. Unlike
    C++, Objective-C behaves as a strict superset of C.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C是另一种源自C的语言，添加了对象和类。与C++不同，Objective-C表现为C的严格超集。
- en: The language was developed in the 1980s and was popularized in the NeXTSTEP
    operating system and later in Apple's OS X and iOS. It hasn't gained much popularity
    outside of those platforms but the success of the iPhone has ensured it has a
    sizeable developer base of its own. It is also well supported by the GCC and Clang
    toolchains. Apple has begun to deprecate Objective-C in favour of Swift which
    is a modern high level language similar in some respects to Rust but more application
    focussed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言在上世纪80年代开发，并在NeXTSTEP操作系统中广泛流行，后来在苹果的OS X和iOS中也得到推广。在这些平台之外，它并没有获得太多的流行，但iPhone的成功确保了它拥有庞大的开发者基础。它也得到了GCC和Clang工具链的良好支持。苹果已经开始弃用Objective-C，转而支持Swift，这是一种现代的高级语言，在某些方面类似于Rust，但更注重应用程序。
- en: Objective-C is strongly influenced by Smalltalk (as opposed to Simula in C++)
    and so code works somewhat differently than C++.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C受Smalltalk的强烈影响（与C++中的Simula相反），因此代码的工作方式与C++略有不同。
- en: Notionally code calls objects by sending them a message. An object defines an
    interface specifying what messages it accepts and an implementation that binds
    those messages to code. The caller code sends a message to call a method. Objects
    can also receive dynamic messages, i.e. ones not defined by their interfaces,
    so they can do certain tasks such as intercepting and forwarding messages. In
    addition an object can ignore a message or not implement it without it being considered
    an error. In a broad sense, an ObjC message and a C++ method are or more or less
    analogous in functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 概念上，代码通过向对象发送消息来调用它们。对象定义了一个接口，指定它接受的消息以及将这些消息绑定到代码的实现。调用者代码发送消息来调用一个方法。对象也可以接收动态消息，即未由它们的接口定义的消息，因此它们可以执行某些任务，例如拦截和转发消息。此外，对象可以忽略消息或不实现消息而不被视为错误。广义上说，ObjC消息和C++方法在功能上或多或少是类似的。
- en: C/C++ Timeline
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C/C++ 时间线
- en: These are the major revisions of C and C++
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是C和C++的主要修订版本
- en: '| Year | Event | Description |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 年份 | 事件 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1972 | C | C for PDP-11, other Unix systems |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 1972 | C | 用于PDP-11、其他Unix系统的C |'
- en: '| 1978 | K&R C | C as defined in "The C Programming Language" book by Kernighan
    & Ritchie |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 1978 | K&R C | Kernighan & Ritchie 的《The C Programming Language》书中定义的C |'
- en: '| 1989 | C89 (ANSI X3.159-1989) | C is standardized as ANSI C, or C89\. C90
    (ISO/IEC 9899:1990) is the ISO ratified version of this same standard. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 1989 | C89 (ANSI X3.159-1989) | C标准化为ANSI C，或C89。C90 (ISO/IEC 9899:1990)
    是这个相同标准的ISO认可版本。 |'
- en: '| 1979 | C with classes -> C++ | Bjarne Stroustrops |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1979 | 带类的C -> C++ | Bjarne Stroustrops |'
- en: '| 1995 | C95 (ISO/IEC 9899/AMD1:1995) | Wide character support, digraphs, new
    macros, and some other minor changes. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 1995 | C95 (ISO/IEC 9899/AMD1:1995) | 宽字符支持，双字符，新宏，以及一些其他较小的更改。 |'
- en: '| 1998 | C++98 (ISO/IEC 14882:1998) | C++ is standardized for the first time.
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 1998 | C++98 (ISO/IEC 14882:1998) | C++首次标准化。 |'
- en: '| 1999 | C99 (ISO/IEC 9899:1999) | Single line (//) comments, mixing declarations
    with code, new intrinsic types, inlining, new headers, variable length arrays
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 1999 | C99 (ISO/IEC 9899:1999) | 单行（//）注释，声明与代码混合，新的内置类型，内联，新的头文件，可变长度数组
    |'
- en: '| 2003 | C++03 (ISO/IEC 14882:2003) | Primarily a defect revision, addressing
    various defects in the specification. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 2003 | C++03 (ISO/IEC 14882:2003) | 主要是一个缺陷修订，解决了规范中的各种缺陷。 |'
- en: '| 2011 | C++11 (ISO/IEC 14882:2011) | A major revision that introduces type
    inference (auto), range based loops, lambdas, strongly typed enums, a nullptr
    constant, struct initialization. Improved unicode char16_t, char32_t, u, U and
    u8 string literals. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2011 | C++11 (ISO/IEC 14882:2011) | 一个主要的修订，引入了类型推断（auto），基于范围的循环，lambda，强类型枚举，nullptr常量，结构初始化。改进的unicode
    char16_t、char32_t、u、U和u8字符串字面量。 |'
- en: '| 2011 | C11 (ISO/IEC 9899:2011) | Multi-threading support. Improved unicode
    char16_t, char32_t, u, U and u8 string literals. Other minor changes |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 2011 | C11 (ISO/IEC 9899:2011) | 多线程支持。改进的unicode char16_t、char32_t、u、U和u8字符串字面量。其他较小的更改
    |'
- en: '| 2014 | C++14 (ISO/IEC 14882:2014) | Another major revision that introduces
    auto return types, variable templates, digit separators (1''000''000), generic
    lambdas, lambda capture expressions, deprecated attribute. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 2014 | C++14 (ISO/IEC 14882:2014) | 另一个主要修订，引入了自动返回类型，变量模板，数字分隔符（1''000''000），泛型lambda，lambda捕获表达式，不推荐使用的属性。
    |'
