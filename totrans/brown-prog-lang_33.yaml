- en: 33Control Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制操作
- en: '|     [33.1 Control on the Web](#%28part._.Control_on_the_.Web%29) |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [33.1 Web 上的控制](#%28part._.Control_on_the_.Web%29) |'
- en: '|       [33.1.1 Program Decomposition into Now and Later](#%28part._.Program_.Decomposition_into_.Now_and_.Later%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|       [33.1.1 程序分解成现在和以后](#%28part._.Program_.Decomposition_into_.Now_and_.Later%29)
    |'
- en: '|       [33.1.2 A Partial Solution](#%28part._.A_.Partial_.Solution%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|       [33.1.2 部分解决方案](#%28part._.A_.Partial_.Solution%29) |'
- en: '|       [33.1.3 Achieving Statelessness](#%28part._.Achieving_.Statelessness%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [33.1.3 实现无状态性](#%28part._.Achieving_.Statelessness%29) |'
- en: '|       [33.1.4 Interaction with State](#%28part._.Interaction_with_.State%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [33.1.4 与状态的交互](#%28part._.Interaction_with_.State%29) |'
- en: '|     [33.2 Conversion to Continuation-Passing Style](#%28part._.Conversion_to_.Continuation-.Passing_.Style%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|     [33.2 转换为延续传递风格](#%28part._.Conversion_to_.Continuation-.Passing_.Style%29)
    |'
- en: '|       [33.2.1 Implementation by Desugaring](#%28part._.Implementation_by_.Desugaring%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|       [33.2.1 通过展开实现](#%28part._.Implementation_by_.Desugaring%29) |'
- en: '|       [33.2.2 Understanding the Output](#%28part._.Understanding_the_.Output%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [33.2.2 理解输出](#%28part._.Understanding_the_.Output%29) |'
- en: '|       [33.2.3 An Interaction Primitive by Transformation](#%28part._read-num-cps%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [33.2.3 通过转换的交互原语](#%28part._read-num-cps%29) |'
- en: '|     [33.3 Implementation in the Core](#%28part._.Implementation_in_the_.Core%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|     [33.3 核心中的实现](#%28part._.Implementation_in_the_.Core%29) |'
- en: '|       [33.3.1 Converting the Interpreter](#%28part._.Converting_the_.Interpreter%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [33.3.1 转换解释器](#%28part._.Converting_the_.Interpreter%29) |'
- en: '|       [33.3.2 An Interaction Primitive in the Core](#%28part._.An_.Interaction_.Primitive_in_the_.Core%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|       [33.3.2 核心中的交互原语](#%28part._.An_.Interaction_.Primitive_in_the_.Core%29)
    |'
- en: '|     [33.4 Generators](#%28part._.Generators%29) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|     [33.4 生成器](#%28part._.Generators%29) |'
- en: '|     [33.5 Continuations and Stacks](#%28part._.Continuations_and_.Stacks%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|     [33.5 延续和堆栈](#%28part._.Continuations_and_.Stacks%29) |'
- en: '|     [33.6 Tail Calls](#%28part._.Tail_.Calls%29) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|     [33.6 尾调用](#%28part._.Tail_.Calls%29) |'
- en: The term control refers to any programming language instruction that causes
    evaluation to proceed, because it “controls” the program counter of the machine.
    In that sense, sequential execution of instructions is “control”, as is even an
    arithmetic expression (and in the presence of state, this control is laid bare
    through the order in which effects occur); other forms of control found in all
    ordinary programming languages include function calls and returns. However, in
    practice we use the term to refer primarily to those operations that cause non-local
    transfer of control beyond that of mere functions and procedures, usually starting
    with exceptions. We will study such operations in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 控制这个术语指的是任何导致评估继续进行的编程语言指令，因为它“控制”了计算机的程序计数器。从这个意义上说，指令的顺序执行是“控制”的，就像算术表达式一样（在存在状态的情况下，这种控制通过效果发生的顺序展现出来）；在所有普通编程语言中找到的其他形式的控制包括函数调用和返回。然而，在实践中，我们主要使用这个术语来指代那些导致控制的非局部转移超出了仅仅函数和过程的范围的操作，通常从异常开始。我们将在本章中研究这样的操作。
- en: As we study the following control operators, it’s worth remembering that even
    without them, we still have languages that are Turing-complete, so these control
    operations provide no more “power”. Therefore, what control operators do is change
    and potentially improve the way we express our intent, and therefore enhance the
    structure of programs. Thus, it pays to being our study by focusing on program
    structure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习以下控制操作符时，值得记住的是，即使没有它们，我们仍然有图灵完备的语言，因此这些控制操作并没有提供更多的“能力”。因此，控制操作的作用是改变并可能改善我们表达意图的方式，从而增强程序的结构。因此，我们开始学习时专注于程序结构是值得的。
- en: 33.1Control on the Web
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制在 Web 上
- en: 'Let us begin our study by examining the structure of Web programs. Consider
    the following program:Henceforth, we’ll call this our “addition server”. You should,
    of course, understand this as a stand-in for more sophisticated applications.
    For instance, the two prompts might ask for starting and ending points for a trip,
    and in place of addition we might compute a route or compute airfares. There might
    even be computation between the two steps: e.g., after entering the first city,
    the airline might prompt us with choices of where it flies from there.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从审视 Web 程序的结构开始学习。考虑以下程序：从此刻开始，我们将把它称为我们的“加法服务器”。当然，你应该将其理解为更复杂应用的替代品。例如，这两个提示可能会询问旅行的起点和终点，并且在加法的位置，我们可能会计算路线或航班价格。甚至可能在两个步骤之间进行计算：例如，在输入第一个城市后，航空公司可能会提示我们选择从那里飞往哪里。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is based on a hypothetical a read-number function that, when run, suspends
    program execution, prompts for a number and, when the user enters one, resumes
    computation. You might find it excessively pedantic that I’d mention the suspension
    and resumption of computation, but this detail will prove to be absolutely central
    to our study, so don’t gloss over these steps!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于一个假设的读取数字函数的假设，当运行时，会暂停程序执行，提示用户输入一个数字，当用户输入一个数字时，继续计算。你可能会觉得我提到了计算的暂停和恢复太啰嗦了，但这个细节将被证明对我们的研究至关重要，所以不要忽视这些步骤！
- en: 'Now suppose we want to run this on a Web server. We immediately encounter a
    difficulty: the structure of server-side Web programs is such that they generate
    a single Web page—<wbr>such as the one asking for the first number—<wbr>and then
    halt. As a result, the rest of the program—<wbr>which in this case prompts for
    the second number, then adds the two, and then prints that result, is lost.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想在 Web 服务器上运行这个程序。我们立即遇到一个困难：服务器端 Web 程序的结构是这样的，它们生成一个单独的 Web 页面，比如要求输入第一个数字的页面，然后停止。因此，程序的其余部分——在这种情况下提示输入第二个数字，然后将两个数字相加，最后打印结果——都丢失了。
- en: Do Now!
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do Web servers behave in such a strange way?
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么 Web 服务器会以如此奇怪的方式行为？
- en: 'There are at least two reasons for this behavior: one perhaps historical, and
    the other technical. The historical reason is that Web servers were initially
    designed to serve pages, i.e., static content. Any program that ran had to generate
    its output to a file, from which a server could offer it. Naturally, developers
    wondered why that same program couldn’t run on demand. This made Web content dynamic.
    Terminating the program after generating a single piece of output was the simplest
    incremental step in transitioning the Web from “pages” to “programs”.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为至少有两个原因：一个可能是历史原因，另一个是技术原因。历史原因是 Web 服务器最初是设计用来提供页面，即静态内容。任何运行的程序都必须将其输出生成到一个文件中，服务器可以从中提供它。自然地，开发人员想知道为什么相同的程序不能按需运行。这使得
    Web 内容具有动态性。在生成单个输出后终止程序是将 Web 从“页面”转变为“程序”的最简单的增量步骤。
- en: 'The more important reason—<wbr>and the one that has stayed with us—<wbr>is
    technical. Imagine our addition server has generated its first prompt. The pending
    computation is not trivial: it must remember the first response, generate the
    second prompt, perform the addition, and then display the result. This computation
    must suspend waiting for the user’s input. If there are millions of users, then
    millions of computations must be suspended (imagine threads running in virtual
    machines, each consuming memory for local data), creating an enormous performance
    problem. Furthermore, suppose a user does not actually complete the computation—<wbr>analogous
    to searching at an on-line bookstore or airline site, but not completing the purchase.
    How does the server know when or even whether to terminate the computation? Until
    it does, the resources associated with that computation remain in use.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的原因——也是伴随我们的原因之一——是技术原因。想象一下，我们的加法服务器生成了第一个提示。待处理的计算不是琐碎的：它必须记住第一个响应，生成第二个提示，执行加法，然后显示结果。此计算必须暂停等待用户的输入。如果有数百万个用户，那么数百万个计算必须被暂停（想象一下在虚拟机中运行的线程，每个线程都消耗内存用于本地数据），这会造成巨大的性能问题。此外，假设一个用户实际上没有完成计算——类似于在在线书店或航空公司网站上搜索，但没有完成购买。服务器如何知道何时甚至是否终止计算？在它这样做之前，与该计算相关的资源仍在使用中。
- en: 'Conceptually, therefore, the Web protocol was designed to be stateless: it
    would not store state on the server associated with intermediate computations.
    Instead, Web program developers would be forced to maintain all necessary state
    elsewhere, and each request would need to be able to resume the computation in
    full. In practice the Web has not proven to be stateless, but it still hews in
    this direction, and studying the structure of such programs is very instructive.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从概念上讲，Web 协议被设计为无状态：它不会在服务器上存储与中间计算相关的状态。相反，Web 程序开发人员将被迫在其他地方维护所有必要的状态，并且每个请求都需要能够完全恢复计算。实际上，Web
    并未证明是无状态的，但它仍然朝着这个方向发展，并且研究这些程序的结构非常有益。
- en: 'Now consider client-side Web programs: those that run inside the browser, written
    in or compiled to JavaScript. Suppose such a computation needs to communicate
    with a server. The primitive for this is called XMLHttpRequest. The user makes
    an instance of this primitive and invokes its send method to send a message to
    the server.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑客户端 Web 程序：那些在浏览器内运行的程序，使用 JavaScript 编写或编译而成。假设这样的计算需要与服务器通信。为此的原语称为 XMLHttpRequest。用户创建此原语的实例，并调用其
    send 方法将消息发送到服务器。
- en: 'Communicating with a server is not, however, instantaneous: it takes some time;
    if the server faces a heavy load, it could take a long time; and indeed, it may
    never complete at all, depending on the state of the network and the server. (These
    are the same problems faced above by get-number, with a user taking the place
    of a server: the user may take a long time to enter a number, or may never do
    so at all.) If the send method suspended program execution, the entire (client-side)
    application would be blocked, indefinitely. You would not want to use such a program.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器通信并不是瞬时的：它需要一些时间；如果服务器面临重负载，可能需要很长时间；事实上，根据网络和服务器的状态，可能根本无法完成。（这与上述 get-number
    面临的问题相同，只是将用户替换为服务器：用户可能需要很长时间才能输入数字，或者根本不输入。）如果 send 方法暂停程序执行，整个（客户端）应用程序将被无限期地阻塞。你不会想使用这样的程序。
- en: To keep the application responsive, the designers of XMLHttpRequest therefore
    had a choice. They could make JavaScript multi-threaded, but because the language
    also has state, programmers would have to confront all the problems of combining
    state with concurrency. In particular, beginners would have to wrestle with a
    combination of features that even experienced programmers do not use well, probably
    resulting in numerous deadlocked Web sites.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用程序的响应性，XMLHttpRequest 的设计者因此有了选择。他们可以使 JavaScript 多线程化，但由于语言也具有状态，程序员将不得不解决结合状态与并发性的所有问题。特别是，初学者将不得不处理一系列特性的组合，即使是经验丰富的程序员也无法很好地使用，这可能导致大量发生死锁的网站。
- en: 'Instead, JavaScript is single-threaded: i.e., there is only one thread of execution
    at a time.Due to the structuring problems this causes, there are now various proposals
    to, in effect, add “safe” threads to JavaScript. The ideas described in this chapter
    can be viewed as an alternative that offer similar structuring benefits. When
    the send method is invoked, JavaScript instead suspends the current computation
    and returns control to an event loop, which can now invoke other suspended computations.
    Devlopers associate a callback with the send. When (and if) a response returns,
    this callback is added to the queue of suspended computations, thereby enabling
    it to resume.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，JavaScript 是单线程的：也就是说，一次只能执行一个线程。由于这造成的结构问题，现在有各种提案，实际上是要向 JavaScript 中添加“安全”线程。本章描述的思想可以被视为提供类似结构化优势的另一种选择。当调用
    send 方法时，JavaScript 会暂停当前计算，并将控制返回给事件循环，该循环现在可以调用其他被暂停的计算。开发者将回调与 send 关联起来。当（如果）返回响应时，此回调将被添加到被暂停计算的队列中，从而使其能够恢复。
- en: This callback needs to embody the rest of the processing of that request. Thus,
    for entirely different reasons—<wbr>not performance, but avoiding the problems
    of synchronization, non-atomicity, and deadlocks—<wbr>the client-side Web has
    evolved to impose essentially the same problems of program structure on developers
    as the server-side Web. Let us now better understand that structure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调需要体现出该请求的其余处理过程。因此，基于完全不同的原因——不是性能，而是避免同步、非原子性和死锁问题——客户端 Web 已经演变成向开发者施加与服务器端
    Web 本质上相同的程序结构问题。现在让我们更好地理解这种结构。
- en: 33.1.1Program Decomposition into Now and Later
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1.1 将程序分解为现在和以后
- en: 'Let us consider what it takes to make our addition program work in a stateless
    setting, such as on a Web server. First we have to determine the first interaction.
    This is the prompt for the first number, because Pyret evaluates arguments from
    left to right. It is instructive to divide the program into two parts: what happens
    to generate the first interaction (which can run right now), and what needs to
    happen after it (which must be “remembered” somehow). The former is easy:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何使我们的加法程序在无状态设置中工作，例如在 Web 服务器上。首先，我们必须确定第一个交互。这是第一个数字的提示，因为 Pyret 从左到右评估参数。将程序分为两部分很有启发性：生成第一个交互的操作（可以立即运行），以及之后需要发生的操作（必须以某种方式“记住”）。前者很容易：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We’ve already explained in prose what’s left, but now it’s time to write it
    as a program. It seems to be something like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用散文解释了剩下的部分，但现在是时候将其写成一个程序了。看起来像是这样：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A Web server can’t execute the above, however, because it evidently isn’t a
    program. We instead need some way of writing this as one.Let’s observe a few characteristics
    of this computation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Web服务器无法执行上述操作，因为显然它不是一个程序。相反，我们需要一种将其写成一个程序的方法。让我们观察一下这个计算的一些特征：
- en: It needs to be a syntactically valid program.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要是一个语法上有效的程序。
- en: It needs to stay suspended until the request comes in.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要保持挂起状态，直到请求到来。
- en: It needs a way—<wbr>such as a parameter—<wbr>to refer to the value from the
    first interaction.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要一种方式—<wbr>比如一个参数—<wbr>来引用第一次交互的值。
- en: 'Put together these characteristics and we have a clear representation—<wbr>a
    function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些特征放在一起，我们有了一个清晰的表示—<wbr>一个函数：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 33.1.2A Partial Solution
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1.2部分解决方案
- en: 'On the Web, there is an additional wrinkle: each Web page with input elements
    needs to refer to a program stored on the Web, which will receive the data from
    the form and process it. This program is named in the action field of a form.
    Thus, imagine that the server generates a fresh label, stores the above function
    in a table associated with that label, and refers to the label in the action field.
    When (and if) the client actually submits the form the server extracts the associated
    function, supplies it with the form’s values, and thus resumes execution.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web上，还有一个额外的复杂问题：每个带有输入元素的Web页面都需要引用存储在Web上的程序，该程序将接收表单数据并处理它。这个程序在表单的action字段中命名。因此，想象一下，服务器生成一个新的标签，将上述函数存储在与该标签关联的表中，并在action字段中引用该标签。当（如果）客户端实际提交表单时，服务器提取关联的函数，提供表单的值，并恢复执行。
- en: Do Now!
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就去做吧！
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is the solution above stateless?
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上面的解决方案是无状态的吗？
- en: 'Let’s imagine that we have a custom Web server that maintains the above table.
    In such a server, we might have a special version of read-number—<wbr>call it
    read-number-suspend—<wbr>that records the rest of the program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们有一个维护上述表的自定义Web服务器。在这样一个服务器中，我们可能有一个特殊版本的read-number—<wbr>称之为read-number-suspend—<wbr>记录程序的其余部分：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unfortunately, this is not sufficient. The moment we perform the second read-number,
    we’re back to having forgotten the rest of the computation. Therefore, the second
    one needs to be converted to use read-number-suspend, too. What is the rest of
    its computation?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这还不够。当我们执行第二次读取数字时，我们又忘记了其余的计算。因此，第二次需要转换为使用read-number-suspend。其余的计算是什么？
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: where v1 is the value from the first computation. Putting together the pieces,
    the fully-translated program is
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其中v1是第一次计算的值。将这些部分组合起来，完全翻译的程序是
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how the inner closure depends on being nested inside the outer one, so
    that v1 is bound in the addition. Also observe how the addition and printing got
    moved from initiating “immediately” after the first number was provided to waiting
    until the second number was also available.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意内部闭包如何依赖于嵌套在外部闭包中，以便v1在加法中绑定。还要注意加法和打印是如何从提供第一个数字后立即“启动”转移到等待第二个数字也可用的。
- en: Exercise
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ascribe types to the above computation. Also determine the type of the Web server
    and of the table holding these procedures.
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为上述计算指定类型。还确定Web服务器的类型以及保存这些过程的表的类型。
- en: 33.1.3Achieving Statelessness
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1.3实现无状态性
- en: We haven’t actually achieved statelessness yet, because we have this large table
    residing on the server, with no clear means to remove entries from it. It would
    be better if we could avoid the server state entirely. This means we have to move
    the relevant state to the client.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上还没有实现无状态性，因为我们在服务器上有一个大表，没有明确的方法来删除其中的条目。如果我们能够完全避免服务器状态将会更好。这意味着我们必须将相关状态移动到客户端。
- en: 'There are actually two ways in which the server holds state. One is that we
    have reserved the right to create as many entries in the hash table as we wish.
    This makes the server storage space proportional to the number of interactions—<wbr>a
    dynamic value—<wbr>rather than the size of the program, a static value with a
    clear bound. The other is what we’re storing in the table: honest-to-goodness
    closures, each of which might be different and closed over copious amounts of
    state.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器保存状态实际上有两种方式。一种是我们保留了随意创建哈希表中条目的权利。这使得服务器存储空间与交互数量成正比——一个动态值——而不是程序大小，一个具有明确边界的静态值。另一种是我们在表中存储的内容：真正的闭包，每个闭包可能是不同的，并且封闭了大量的状态。
- en: 'Let’s start by eliminating the closure. Instead, let’s have each of the functions
    be named and at the top-level (which immediately forces us to have only a fixed
    number of them, bounded by the size of the program):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先消除闭包。相反，让我们将每个函数命名并置于顶层（这立即迫使我们只能有固定数量的函数，其数量受程序大小的限制）：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Observe how each code block refers only to the name of the next procedure,
    rather than to a real closure. The value of the argument comes from the form.
    There’s just one problem: v1 in prog-2 is a free identifier!'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个代码块只引用下一个过程的名称，而不是真正的闭包。参数的值来自于表单。只有一个问题：prog-2中的v1是自由标识符！
- en: 'The way to fix this problem is, instead of creating a closure after one step,
    to send v1 to the client to be stored there. Where do we store this? The browser
    offers two mechanisms for doing this: cookies and hidden fields. Which one do
    we use?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题的方法是，在一步之后不创建闭包，而是将v1发送给客户端存储在那里。我们将这个存储在哪里？浏览器提供了两种机制来做到这一点：cookies和隐藏字段。我们使用哪一个？
- en: 33.1.4Interaction with State
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1.4与状态的交互
- en: 'One way to avoid this problem is to find a channel of communication between
    what follows the first and second prompts. Recall that we have noted that state
    provides such a channel of communication ([The Design of Stateful Language Operations](implementing-mutation.html#%28part._design-of-state-ops%29)).
    Therefore, we could use a top-level variable to communicate the value of v1. To
    be suggestive, we’ll call this variable cookie:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 避免此问题的一种方法是找到第一个和第二个提示后面的通信渠道。回想一下我们已经注意到状态提供了这样一种通信渠道（[有状态语言操作的设计](implementing-mutation.html#%28part._design-of-state-ops%29)）。因此，我们可以使用一个顶层变量来传递v1的值。为了具有启发性，我们将这个变量称为cookie：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'from which we can eliminate closures easily:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地消除闭包：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unfortunately, this means every intermediate computation will share the same
    cookie variable. If we open up two concurrent windows and try to add different
    first numbers, the latest first number will always reside in cookie, so the other
    window is going to see unpredictable results.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这意味着每个中间计算都将共享相同的cookie变量。如果我们打开两个并发窗口并尝试添加不同的第一个数字，最新的第一个数字将始终驻留在cookie中，因此另一个窗口将看到不可预测的结果。
- en: 'This, of course, is precisely what happens on the Web.These problems are not
    hypothetical. For instance, see Section 2 of [Modeling Web Interactions and Errors](http://cs.brown.edu/~sk/Publications/Papers/Published/kfgf-model-web-inter-error/).
    The browser’s cookies are merely a client-side implementation of the store. Thus,
    Web sites that store their information in cookies are susceptible to exactly this
    problem: two concurrent interactions with the site will end up interfering with
    one another. Therefore, the pervasive use of cookies on Web sites, induced by
    Web programming traditions, results in actively less usable sites.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然就是网络上发生的事情。这些问题并非假设性的。例如，参见[模拟网络交互和错误](http://cs.brown.edu/~sk/Publications/Papers/Published/kfgf-model-web-inter-error/)第2节。浏览器的cookies仅仅是存储的客户端实现。因此，将信息存储在cookies中的网站会受到这个问题的影响：与网站的两个并发交互将相互干扰。因此，Web网站普遍使用cookies，这是由Web编程传统引起的，导致网站的可用性明显降低。
- en: 'In contrast, the Web offers another mechanism for storing information on the
    client: the hidden field. Because they are local to each page, and each page corresponds
    to a closure, they are precisely analogous to a closure’s environment! Thus, instead
    of storing the value of v1 in a single, global cookie, if we were to store it
    in a hidden field in the response page, then two different response pages would
    have different values in their hidden field, which would be sent back to the server
    on the next request—<wbr>thereby avoiding the interference problem entirely.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，网络提供了另一种在客户端存储信息的机制：隐藏字段。因为它们对于每个页面都是本地的，而每个页面对应一个闭包，它们与闭包的环境完全类似！因此，如果我们不是将v1的值存储在单个全局cookie中，而是将其存储在响应页面的隐藏字段中，那么两个不同的响应页面的隐藏字段将具有不同的值，并且在下一个请求中将发送回服务器——从而完全避免了干扰问题。
- en: 33.2Conversion to Continuation-Passing Style
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33.2转换为延续传递风格
- en: 'The style of functions we’ve been writing has a name. Though we’ve presented
    ideas in terms of the Web, we’re relying on a much older idea: the functions are
    called continuations, and this style of programs is called continuation-passing
    style (CPS).We will take the liberty of using CPS as both a noun and verb: a particular
    structure of code and the process that converts code into it. This is worth studying
    in its own right, because it is the basis for studying a variety of other non-trivial
    control operations—<wbr>such as generators.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在编写的函数风格有一个名称。虽然我们以Web的术语提出了这些想法，但我们依赖于一个更古老的概念：这些函数被称为延续，程序的这种风格称为延续传递风格（CPS）。我们将自由使用CPS作为名词和动词：代码的特定结构和将代码转换为它的过程。这值得单独研究，因为它是研究各种其他非平凡控制操作的基础——例如生成器。
- en: 'Earlier, we converted programs so that no Web input operation was nested inside
    another. The motivation was simple: when the program terminates, all nested computations
    are lost. A similar argument applies, in a more local sense, in the case of XMLHttpRequest:
    any computation depending on the result of a response from a Web server needs
    to reside in the callback associated with the request to the server.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们将程序转换为不将Web输入操作嵌套在另一个内部。动机很简单：当程序终止时，所有嵌套的计算都会丢失。类似的论点在XMLHttpRequest的情况下在更局部的意义上也适用：任何依赖于来自Web服务器响应的结果的计算都需要驻留在与发送到服务器的请求相关联的回调中。
- en: In fact, we don’t need to transform every expression. We only care about expressions
    that involve actual Web interaction. For example, if we computed a more complex
    mathematical expression than just addition, we wouldn’t need to transform it.
    If, however, we had a function call, we’d either have to be absolutely certain
    the function didn’t have any Web invocations either inside it, or in the functions
    in invokes, or the ones they invoke...or else, to be defensive, we should transform
    them all. Therefore, we have to transform every expression that we can’t be sure
    performs no Web interactions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要转换每个表达式。我们只关心涉及实际Web交互的表达式。例如，如果我们计算的是比加法更复杂的数学表达式，我们就不需要转换它。但是，如果我们有一个函数调用，我们要么必须确保该函数内部没有任何Web调用，要么在它调用的函数中没有任何Web调用，或者它们调用的函数中没有任何Web调用...否则，为了保险起见，我们应该全部转换。因此，我们必须转换每个我们不能确定是否执行Web交互的表达式。
- en: The heart of our transformation is therefore to turn every function, f, into
    one with an extra argument. This extra argument is the continuation, which represents
    the rest of the computation. f, instead of returning a value, instead passes the
    value it would have returned to its continuation. Thus, the continuation is itself
    a function of one argument; this argument represents the value that would have
    been returned by f. A function returns a value to “pass it to the rest of the
    computation”; CPS makes this explicit, because invoking a continuation (in place
    of returning a value) precisely passes it to the function representing the rest
    of the computation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们转换的核心是将每个函数f转换为一个带有额外参数的函数。这个额外参数是延续，它代表了剩余的计算过程。f不再返回值，而是将它本来会返回的值传递给它的延续。因此，延续本身是一个带有一个参数的函数；这个参数代表了f本来会返回的值。一个函数返回一个值以“传递给剩余的计算过程”；CPS使这一点明确，因为调用延续（而不是返回一个值）恰好将它传递给表示剩余计算过程的函数。
- en: 'CPS is a general transformation, which we can apply to any program. Because
    it’s a program transformation, we can think of it as a special kind of desugaring
    that transforms programs within the same language: from the full language to a
    more restricted version that obeys the pattern we’ve been discussing. As a result,
    we can reuse an evaluator for the full language to also evaluate programs in the
    CPS subset.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CPS 是一种通用转换，我们可以将其应用于任何程序。因为它是一个程序转换，我们可以将其视为一种特殊类型的解糖，它将程序从完整语言转换为一个更受限制的版本，遵循我们一直讨论的模式。因此，我们可以重用完整语言的评估器来评估
    CPS 子集中的程序。
- en: 33.2.1Implementation by Desugaring
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.2.1通过解糖实现
- en: Let us therefore implement CPS as a source-to-source transformation. Thought
    of as a function, it consumes and returns ExprC expressions, but the output expressions
    will have the peculiar structure we have seen above, and will therefore be a strict
    subset of all ExprC expressions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将 CPS 实现为源到源的转换。从函数的角度来看，它接受并返回 ExprC 表达式，但输出表达式将具有我们上面看到的特殊结构，因此将是所有
    ExprC 表达式的严格子集。
- en: Exercise
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Put differently, the comment about “strict subset” above means that certain
    ExprC expressions are not legal in the output that CPS generates. Provide examples.
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 换句话说，上面关于“严格子集”的注释意味着某些 ExprC 表达式在 CPS 生成的输出中不合法。提供示例。
- en: <cps-trans> ::=
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <cps-trans> ::=
- en: '|   fun cps(e :: ExprC) -> ExprC: |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|   fun cps(e :: ExprC) -> ExprC: |'
- en: '|     cases (ExprC) e: |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|     cases (ExprC) e: |'
- en: '|       [<cps-trans-numC>](#%28elem._cps-trans-num.C%29) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-trans-numC>](#%28elem._cps-trans-num.C%29) |'
- en: '|       [<cps-trans-plusC>](#%28elem._cps-trans-plus.C%29) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-trans-plusC>](#%28elem._cps-trans-plus.C%29) |'
- en: '|       [<cps-trans-idC>](#%28elem._cps-trans-id.C%29) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-trans-idC>](#%28elem._cps-trans-id.C%29) |'
- en: '|       [<cps-trans-fdC>](#%28elem._cps-trans-fd.C%29) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-trans-fdC>](#%28elem._cps-trans-fd.C%29) |'
- en: '|       [<cps-trans-appC>](#%28elem._cps-trans-app.C%29) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-trans-appC>](#%28elem._cps-trans-app.C%29) |'
- en: '|     end |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: 'Our representation in CPS will be to turn every expression into a procedure
    of one argument, the continuation. The converted expression will eventually either
    supply a value to the continuation or will pass the continuation on to some other
    expression that will—<wbr>by preserving this invariant inductively—<wbr>supply
    it with a value. Applied to Pyret, all output from CPS will look like fun (k):
    ... end. Since we are applying CPS to Paret instead, it will look like fdC("k",
    ...). Either way, note that lexical scope keeps these k’s from clashing with any
    other identifiers of the same name.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在 CPS 中的表示将是将每个表达式转换为一个带有一个参数的过程，即延续。转换后的表达式最终要么向延续提供一个值，要么将延续传递给将要——通过保持这个不变性的归纳——向它提供一个值的其他表达式。对于
    Pyret，CPS 的所有输出都将以 fun (k): ... end 的形式呈现。因为我们将 CPS 应用于 Paret，所以它将呈现为 fdC("k",
    ...)。无论哪种方式，请注意，词法作用域都会防止这些 k 与相同名称的任何其他标识符发生冲突。'
- en: First let’s dispatch with the easy case, which is atomic values. Because we
    already have a value, we are ready to “return” it, which we do by supplying it
    to the continuation:<cps-trans-numC> ::=
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理简单的情况，即原子值。因为我们已经有一个值了，我们准备“返回”它，通过将其提供给延续来实现：<cps-trans-numC> ::=
- en: '|   &#124; numC(_) => fdC("k", appC(idC("k"), e)) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; numC(_) => fdC("k", appC(idC("k"), e)) |'
- en: and similarly:<cps-trans-idC> ::=
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地：<cps-trans-idC> ::=
- en: '|   &#124; idC(_) => fdC("k", appC(idC("k"), e)) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; idC(_) => fdC("k", appC(idC("k"), e)) |'
- en: Exercise
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the language to handle conditionals.
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将语言扩展到处理条件。
- en: Exercise
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the language to support mutable state as well. Does this have any impact
    on the CPS process, i.e., does it change the pattern of conversion?
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扩展语言以支持可变状态。这对 CPS 过程有什么影响吗？即，它是否改变了转换的模式？
- en: Next, let’s handle binary operators. We have seen the essence of this transformation
    earlier, applied to the Web:<cps-trans-plusC> ::=
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理二元运算符。我们之前已经见过这种转换的本质，应用于 Web：<cps-trans-plusC> ::=
- en: '|   &#124; plusC(l, r) => |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; plusC(l, r) => |'
- en: '|     fdC("k", |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|     fdC("k", |'
- en: '|       appC(cps(l), |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|       appC(cps(l), |'
- en: '|         fdC("l-v", |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|         fdC("l-v", |'
- en: '|           appC(cps(r), |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|           appC(cps(r), |'
- en: '|             fdC("r-v", |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|             fdC("r-v", |'
- en: '|               appC(idC("k"), plusC(idC("l-v"), idC("r-v")))))))) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|               appC(idC("k"), plusC(idC("l-v"), idC("r-v")))))))) |'
- en: This assumes that the primitive operator, in this case addition, does not itself
    need to be transformed; on the Web, for instance, it’s a safe bet that performing
    arithmetic does not involve any Web interactions.Unless, of course, the arithmetic
    is part of a cryptographic algorithm, in which case it may be necessary to notify
    the NSA of the results.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have function definition and application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s tempting to think that, because function are just values, they too can
    be passed unchanged to the continuation. Why is this not true?
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before proceeding, alter the underlying language to also permit two-argument
    function definitions and, correspondingly, applications. Name the definitions
    fd2C and the applications app2C.
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: For an application we have to evaluate both the function and argument expressions.
    Once we’ve obtained these, we are ready to apply the function. Therefore, it is
    tempting to write<cps-trans-appC-try-1> ::=
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; appC(f, a) => |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '|     fdC("k", |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '|       appC(cps(f), |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '|         fdC("f-v", |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '|           appC(cps(a), |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '|             fdC("a-v", |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '|               appC(idC("k"), appC(idC("f-v"), idC("a-v")))))))) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: Do Now!
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why this is wrong?
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The problem is that, though the function is a value, that value is a closure
    with a potentially complicated body: evaluating the body can, for example, result
    in further Web interactions, at which point the rest of the function’s body, as
    well as the pending k(...) (i.e., the rest of the program), will all be lost.
    To avoid this, we have to supply k to the function’s value, and let the inductive
    invariant ensure that k will eventually be invoked with the value of applying
    f-v to a-v:<cps-trans-appC> ::='
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; appC(f, a) => |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '|     fdC("k", |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '|       appC(cps(f), |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '|         fdC("f-v", |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '|           appC(cps(a), |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '|             fdC("a-v", |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '|               app2C(idC("f-v"), idC("a-v"), idC("k"))))))) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: 'A function is itself a value, so it should be returned to the pending computation.
    The application case above, however, shows that we have to transform functions
    to take an extra argument, namely the continuation at the point of invocation.
    This leaves us with a quandary: which continuation do we supply to the body?'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: <cps-trans-fdC-try-1> ::=
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; fdC(v, b) => |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '|     fdC("k", |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '|       appC(idC("k"), |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '|         fd2C(v, "dyn-k", |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '|           appC(cps(b), ???)))) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: 'That is, in place of ???, which continuation do we supply: k or dyn-k?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which continuation should we supply?
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The former is the continuation at the point of closure creation. The latter
    is the continuation at the point of closure invocation. In other words, the former
    is “static” and the latter is “dynamic”. In this case, we need to use the dynamic
    continuation, otherwise something very strange would happen: the program would
    return to the point where the closure was created, rather than where it is being
    used! This would result in seemingly very strange program behavior, so we wish
    to avoid it. Observe that we are consciously choosing the dynamic continuation
    just as, where scope was concerned we chose the static environment but where state
    was concerned we chose the “dynamic” (namely, most recent) store. Thus continuations
    are more like state than they are like lexical binding, a similarity we will return
    to later [REF].'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <cps-trans-fdC> ::=
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; fdC(v, b) => |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '|     fdC("k", |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '|       appC(idC("k"), |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '|         fd2C(v, "dyn-k", |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '|           appC(cps(b), idC("dyn-k"))))) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: Do Now!
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After you have understood this material, replace "dyn-k" with "k", predict what
    should change, and check that it does.
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Testing any code converted to CPS is slightly annoying because all CPS terms
    expect a continuation. In a real environment, the initial continuation is one
    that simply either (a) consumes a value and returns it, or (b) consumes a value
    and prints it, or (c) consumes a value, prints it, and gets ready for another
    computation (as the prompt in a REPL does). All three of these are effectively
    just the identity function in various guises. Thus, the following definition is
    helpful for testing:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For instance,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 33.2.2Understanding the Output
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The output of this transformation takes some getting used to. Consider a very
    simple example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This evaluates to
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For (slightly more) readability, let’s transform this from Paret to Pyret and
    give it a name:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We had to insert the shadow declarations to confirm to Pyret that we really
    did mean to shadow these identifiers. We can then apply it to the identity function
    to observe that it produces the expected answer:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also rename the different ks to better tell them apart:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Terms like
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'would seem a significant decrease in code readability, but that’s only until
    you learn how to “read” such a program. This is equivalent to saying: “k1 represents
    the rest of the program after evaluating 1. Evaluate 1, and send its result—<wbr>the
    value 1—<wbr>to the rest of the computation, namely k1.” This value (1) is bound
    to l-v, the identifier representing the left-hand-side value of the addition...which,
    of course, is precisely what 1 is.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: There is an active line of research in creating better CPS transformations that
    produce fewer intermediate function terms; we’ve actually used one of the very
    oldest and least sophisticated. The trade-off is in simplicity of desugaring versus
    simplicity of output, with the two roughly inversely correlated.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 33.2.3An Interaction Primitive by Transformation
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point we have identified a problem in program structure; we hypothesized
    a better API for it; we transformed an example to use such an API; and then we
    generalized that transformation. But now we have a program structure so complex
    that it is unclear what use it could possibly be. The point of this transformation
    was so that every sub-expression would have an associated continuation, which
    a interaction-friendly primitive can use. Let’s see how to do that.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经确定了程序结构中的一个问题；我们假设了一个更好的 API；我们将一个示例转换为使用这样的 API；然后我们将该转换泛化。但现在我们有一个非常复杂的程序结构，不清楚它可能有什么用处。这种转换的重点是，每个子表达式都将有一个关联的继续，这是一个友好交互的原语可以使用的。让我们看看如何做到这一点。
- en: 'To enable this, we will now add two primitives: read-numC and read-num-webC.
    The idea is that user programs (pre-CPS) will use the former, which the transformation
    will convert into uses of the latter. Here are the two new language forms:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们现在将添加两个原语：read-numC 和 read-num-webC。想法是用户程序（预 CPS）将使用前者，而转换将其转换为对后者的使用。这是两种新语言形式：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The prompt p is assumed to be an expression that evaluates to what we want to
    print to the user. In our impoverished language this is a number, which is sufficient
    for illustration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 p 是一个表达式，它的求值结果是我们想要打印给用户的内容。在我们贫乏的语言中，这是一个数字，这对说明已经足够了。
- en: We will assume that cps does not need to handle read-num-webC (because the end-user
    is not expected to write this directly), while interp does not need to handle
    read-numC (because we want this interpreter to function even in a setting that
    periodically terminates input, so it cannot block waiting for a response).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设 cps 不需要处理 read-num-webC（因为预计最终用户不会直接编写它），而 interp 不需要处理 read-numC（因为我们希望此解释器即使在定期终止输入的设置中也能正常运行，因此它不能阻塞等待响应）。
- en: 'Transforming read-numC into read-num-webC in cps is now easy, because the continuation
    argument now gives us exactly what we need:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cps 中将 read-numC 转换为 read-num-webC 现在很容易，因为续延参数现在正好给了我们所需的东西：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now let us build an implementation of read-num-webC in the interpreter that
    properly simulates a program that halts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在解释器中构建一个正确模拟程序停止的 read-num-webC 实现。
- en: 'First we need a way to record the current resumption point. In a real system
    this might be remembered on a server or marshaled into a value sent to the client.See
    [this paper](http://cs.brown.edu/~sk/Publications/Papers/Published/mfgkf-web-restructuring-cps-journal/)
    for more on how to marshal the continuation to the client. Here, we’ll just record
    it in a global variable:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种记录当前恢复点的方法。在真实系统中，这可能会被记在服务器上或者编组成一个值发送给客户端。有关如何将续延编组到客户端的更多信息，请参见[此论文](http://cs.brown.edu/~sk/Publications/Papers/Published/mfgkf-web-restructuring-cps-journal/)。在这里，我们只是将其记录在一个全局变量中：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sure enough, something interesting will be there once we start running the
    program.Now let us modify the interpreter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，一旦我们开始运行程序，肯定会有一些有趣的东西。现在让我们修改解释器：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First we evaluate the prompt expression to obtain an actual prompt. We then
    print this to the screen. Crucially, we then store the current continuation to
    the global variable. Finally, we halt the program’s execution; this step is vital
    in keeping us honest, so that we don’t accidentally rely on Pyret to resume our
    computation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们评估提示表达式以获得实际提示。然后我们将其打印到屏幕上。关键是，我们然后将当前续延存储到全局变量中。最后，我们停止程序的执行；这一步在保持我们诚实方面是至关重要的，这样我们就不会意外地依赖
    Pyret 来恢复我们的计算。
- en: Exercise
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduce an error in cps and show how halting the program highlights it, while
    not doing so silently masks it.
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 cps 中引入一个错误，并展示如何通过停止程序来突出显示它，而不这样做则会默默掩盖它。
- en: 'Suppose we run this on the following input program:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在以下输入程序上运行此程序：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Pyret prints
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret 打印
- en: '| Web interaction: 1 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 网络交互：1 |'
- en: '| Error: |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 错误： |'
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| "Program halted waiting for user input" |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| "程序暂停等待用户输入" |'
- en: and the program halts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序停止了。
- en: 'At this point, web-continuation contains a genuine, run-time closure (a closV
    value). This represents a continuation: a program value representing the rest
    of the computation.Due to a bug in the current implementation, you can’t inspect
    the value of web-continuation directly; but you can access it from a function
    that closes over it. The user now supplies an input in the imagined Web form;
    this is provided as the actual argument to the continuation.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，web-continuation 包含一个真正的运行时闭包（一个 closV 值）。这代表一个延续：一个代表计算剩余部分的程序值。由于当前实现中存在一个错误，你无法直接检查
    web-continuation 的值；但你可以从一个闭包中访问它。用户现在在想象中的 Web 表单中提供一个输入；这作为延续的实际参数提供。
- en: 'We can do this as follows. We extract the function and environment from the
    closure, and apply the function to the provided parameter, evaluating this in
    the context of the closure:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做。我们从闭包中提取函数和环境，并将函数应用于提供的参数，在闭包的上下文中评估这个过程：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sure enough, using this with 3 as the first input yields:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，使用 3 作为第一个输入时产生：
- en: '| >  run-wc(3) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| >  run-wc(3) |'
- en: '| Web interaction: 2 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 网络交互: 2 |'
- en: '| Error: |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 错误: |'
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| "Program halted waiting for user input" |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| "程序等待用户输入时停止" |'
- en: 'Oooh, promising! Now we try this again with, say, 4 as the second input, and
    we get:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，有希望！现在我们再试一次，比如，将 4 作为第二个输入，我们得到：
- en: '| > run-wc(4) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| > run-wc(4) |'
- en: '| numV(7) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| numV(7) |'
- en: Et voilà!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Et voilà!
- en: Here, then, is the key lesson. By transforming the program into CPS we were
    able to write a normal-looking program—<wbr>read-numC(numC(1)), read-numC(numC(2))—<wbr>and
    run it on an intepreter that truly terminated after each interaction, and were
    still able to resume the computation successfully, running to completion without
    losing track of computations or of scope errors. That is, we can write the program
    in direct style, with properly nested expressions, and a compiler—<wbr>in this
    case, the CPS converter—<wbr>takes care of making it work with a suitable underlying
    API. This is what good programming languages ought to do!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是关键的教训。通过将程序转换为 CPS，我们能够编写一个看起来正常的程序—<wbr>read-numC(numC(1)), read-numC(numC(2))—<wbr>并在一个真正在每次交互后终止的解释器上运行它，并且仍然能够成功恢复计算，运行到完成而不会丢失计算或作用域错误。也就是说，我们可以以直接风格编写程序，具有正确嵌套的表达式，并且编译器—<wbr>在这种情况下，CPS
    转换器—<wbr>负责使其与适当的底层 API 协同工作。这才是良好的编程语言应该做的事情！
- en: Exercise
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the program to store each previous continuations with some kind of unique
    tag. Now that you have access to multiple continuations, simulate the effect of
    different browser actions such as reloading the page (re-invoking a continuation),
    going back (using a prior continuation), cloning a page (re-using a continuation),
    etc. Does your implementation still work?
  id: totrans-223
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改程序以存储每个先前的延续，并带有某种独特的标记。现在你可以访问多个延续，模拟不同的浏览器操作效果，比如重新加载页面（重新调用延续），返回（使用先前的延续），克隆页面（重用延续）等。你的实现还有效吗？
- en: 33.3Implementation in the Core
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33.3核心中的实现
- en: Now that we’ve seen how CPS can be implemented through desguaring, we should
    ask whether it can be put in the core instead.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到 CPS 如何通过 desguaring 实现，我们应该问一下它是否可以放在核心中。
- en: 'Recall that we’ve said that CPS applies to all programs. We have one program
    we are especially interested in: the interpreter. Sure enough, we can apply the
    CPS transformation to it, making available what are effectively the same continuations.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住我们曾说过 CPS 适用于所有程序。我们特别感兴趣的是一个程序：解释器。果然，我们可以对其应用 CPS 转换，使有效地使用相同的延续。
- en: 33.3.1Converting the Interpreter
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.3.1转换解释器
- en: Rather than mindlessly applying the transformation, which would result in a
    very unwieldy (and unreadable) intepreter, we’ll clean things up a little as we
    go. Note first of all that the interpreter needs to take an additional argument,
    representing the rest of the computation:<cps-interp> ::=
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与盲目应用转换不同，这将导致一个非常笨拙（且难以阅读）的解释器，我们将在进行清理时稍微整理一下。首先请注意，解释器需要接受一个额外的参数，表示计算的剩余部分：<cps-interp>
    ::=
- en: '|   fun interp(e :: ExprC, nv :: List<Binding>, k): |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|   fun interp(e :: ExprC, nv :: List<Binding>, k): |'
- en: '|     cases (ExprC) e: |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|     cases (ExprC) e: |'
- en: '|       [<cps-interp-numC>](#%28elem._cps-interp-num.C%29) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-interp-numC>](#%28elem._cps-interp-num.C%29) |'
- en: '|       [<cps-interp-plusC>](#%28elem._cps-interp-plus.C%29) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-interp-plusC>](#%28elem._cps-interp-plus.C%29) |'
- en: '|       [<cps-interp-idC>](#%28elem._cps-interp-id.C%29) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-interp-idC>](#%28elem._cps-interp-id.C%29) |'
- en: '|       [<cps-interp-fdC/fd2C>](#%28elem._cps-interp-fd.C%2Ffd2.C%29) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-interp-fdC/fd2C>](#%28elem._cps-interp-fd.C%2Ffd2.C%29) |'
- en: '|       [<cps-interp-appC>](#%28elem._cps-interp-app.C%29) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-interp-appC>](#%28elem._cps-interp-app.C%29) |'
- en: '|       [<cps-interp-app2C>](#%28elem._cps-interp-app2.C%29) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|       [<cps-interp-app2C>](#%28elem._cps-interp-app2.C%29) |'
- en: '|     end |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: Exercise
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that we have not annotated k, and we’ve dropped the return annotation on
    interp. Fill them in.
  id: totrans-241
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，我们没有标注 k，并且我们已经删除了 interp 的返回注释。补全它们。
- en: When we have values, we simply “return” them through the continuation:<cps-interp-numC>
    ::=
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有值时，我们简单地通过续延 “返回” 它们：<cps-interp-numC> ::=
- en: '|   &#124; numC(n) => |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; numC(n) => |'
- en: '|     k(numV(n)) |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|     k(numV(n)) |'
- en: <cps-interp-idC> ::=
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <cps-interp-idC> ::=
- en: '|   &#124; idC(s) => |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; idC(s) => |'
- en: '|     k(lookup(s, nv)) |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|     k(lookup(s, nv)) |'
- en: For binary operations where the operator is a primitive, we have to follow the
    CPS pattern:<cps-interp-plusC> ::=
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于操作符为原始值的二元操作，我们必须遵循 CPS 模式：<cps-interp-plusC> ::=
- en: '|   &#124; plusC(l, r) => |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; plusC(l, r) => |'
- en: '|     interp(l, nv, |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|     interp(l, nv, |'
- en: '|       lam(l-v): |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|       lam(l-v): |'
- en: '|         interp(r, nv, |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|         interp(r, nv, |'
- en: '|           lam(r-v): |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|           lam(r-v): |'
- en: '|             k(plus-v(l-v, r-v)) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|             k(plus-v(l-v, r-v)) |'
- en: '|         end) |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|         end) |'
- en: '|       end) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|       end) |'
- en: Note that CPS also ends up enforcing an order-of-evalation (in this case, left-to-right)
    just as mutation did.For function definitions, we have to be careful. Earlier
    ([<cps-trans-fdC>](#%28elem._cps-trans-fd.C%29)), we added a continuation parameter
    to closures. However, the fdC data structures are merely data; it is functions
    like interp that need to be given the extra parameter. Therefore, we can leave
    these alone:<cps-interp-fdC/fd2C> ::=
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CPS 也最终强制执行评估顺序（在这种情况下是从左到右），就像突变一样。对于函数定义，我们必须小心。前面（[<cps-trans-fdC>](#%28elem._cps-trans-fd.C%29)），我们向闭包添加了一个续延参数。但是，fdC
    数据结构仅仅是数据；像 interp 这样的函数需要被赋予额外的参数。因此，我们可以将这些保持不变：<cps-interp-fdC/fd2C> ::=
- en: '|   &#124; fdC(_, _) => |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; fdC(_, _) => |'
- en: '|     k(closV(e, nv)) |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|     k(closV(e, nv)) |'
- en: '|   &#124; fd2C(_, _, _) => |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; fd2C(_, _, _) => |'
- en: '|     k(closV(e, nv)) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|     k(closV(e, nv)) |'
- en: Finally, applications have to be converted to CPS as we have seen before:<cps-interp-appC>
    ::=
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序必须像我们之前看到的那样转换为 CPS：<cps-interp-appC> ::=
- en: '|   &#124; appC(f, a) => |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; appC(f, a) => |'
- en: '|     interp(f, nv, |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|     interp(f, nv, |'
- en: '|       lam(clos-v): |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|       lam(clos-v): |'
- en: '|         interp(a, nv, |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|         interp(a, nv, |'
- en: '|           lam(arg-v): |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|           lam(arg-v): |'
- en: '|             interp(clos-v.f.body, |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|             interp(clos-v.f.body, |'
- en: '|               xtnd-env(bind(clos-v.f.arg, arg-v), clos-v.e), |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|               xtnd-env(bind(clos-v.f.arg, arg-v), clos-v.e), |'
- en: '|               k) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|               k) |'
- en: '|           end) |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|           end) |'
- en: '|       end) |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|       end) |'
- en: and similarly when there are two arguments:<cps-interp-app2C> ::=
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当有两个参数时：<cps-interp-app2C> ::=
- en: '|   &#124; app2C(f, a1, a2) => |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; app2C(f, a1, a2) => |'
- en: '|     interp(f, nv, |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|     interp(f, nv, |'
- en: '|       lam(clos-v): |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|       lam(clos-v): |'
- en: '|         interp(a1, nv, |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|         interp(a1, nv, |'
- en: '|           lam(arg1-v): |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|           lam(arg1-v): |'
- en: '|             interp(a2, nv, |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|             interp(a2, nv, |'
- en: '|               lam(arg2-v): |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|               lam(arg2-v): |'
- en: '|                 interp(clos-v.f.body, |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|                 interp(clos-v.f.body, |'
- en: '|                   xtnd-env(bind(clos-v.f.arg1, arg1-v), |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|                   xtnd-env(bind(clos-v.f.arg1, arg1-v), |'
- en: '|                     xtnd-env(bind(clos-v.f.arg2, arg2-v), |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|                     xtnd-env(bind(clos-v.f.arg2, arg2-v), |'
- en: '|                       clos-v.e)), |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|                       clos-v.e)), |'
- en: '|                 k) |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|                 k) |'
- en: '|               end) |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|               end) |'
- en: '|           end) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|           end) |'
- en: '|       end) |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|       end) |'
- en: 'By converting the interpreter to CPS we have given it access to an extra parameter:
    k, the continuation of the interpreter. Because the interpreter’s execution mimics
    the intended behavior of the interpreted program, the continuation of the interpreter
    reflects the rest of the behavior of the interpreted program: i.e., applying interp
    to an expression e with continuation k will result in k being given the value
    of e. We can therefore put k to work by exposing it to programs being interpreted.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将解释器转换为 CPS 后，我们为其增加了一个额外的参数：k，即解释器的续延。因为解释器的执行模仿了被解释程序的预期行为，解释器的续延反映了被解释程序的其余行为：即，将表达式
    e 应用于续延 k 将导致 k 被赋予表达式 e 的值。因此，我们可以通过将其暴露给被解释的程序来利用 k。
- en: 33.3.2An Interaction Primitive in the Core
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.3.2 核心中的交互式原语
- en: 'We can now lift our previous solution [[An Interaction Primitive by Transformation](#%28part._read-num-cps%29)]
    to this modified interpreter. This time, instead of the continuation being created
    by the program, it’s created by the interpreter itself, with the program oblivious
    to this activity. Thus:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将之前的解决方案[[通过转换实现的交互原语](#%28part._read-num-cps%29)]提升到这个修改后的解释器中。这一次，不同于程序创建续延，而是解释器自己创建，而程序对此一无所知。因此：
- en: '[PRE24]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that we must first evaluate the prompt expression to obtain its value.
    Now, however, there is no longer a continuation expression to evaluate: the interpreter
    has the continuation at the ready. It is this continuation that we store in web-continuation.Observe
    that this value is now a genuine closure in Pyret, not a closure data structure
    we have constructed. Therefore, to apply it we can no longer extract its fields;
    instead, the only thing we can do with it is to apply it:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须首先评估提示表达式以获取其值。然而，现在，没有了要评估的续延表达式：解释器已经准备好了续延。就是这个续延，我们将其存储在 web-continuation
    中。注意，该值现在是 Pyret 中的真正闭包，而不是我们构造的闭包数据结构。因此，要应用它，我们不再能提取其字段；相反，我们能做的唯一的事情就是应用它：
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this in place, if we evaluate the expression
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，如果我们评估表达式
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'we observe the same behavior as before:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到与之前相同的行为：
- en: '| Web interaction: 1 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| Web 交互: 1 |'
- en: '| Error: |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 错误: |'
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| "Program halted waiting for user input" |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| "程序停止等待用户输入" |'
- en: '| > run-wc(3) |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| > run-wc(3) |'
- en: '| Web interaction: 2 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| Web 交互: 2 |'
- en: '| Error: |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 错误: |'
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| "Program halted waiting for user input" |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| "程序停止等待用户输入" |'
- en: '| > run-wc(4) |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| > run-wc(4) |'
- en: '| numV(7) |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| numV(7) |'
- en: 'Despite their similarities, there are two major differences between the two
    strategies:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们相似，但这两种策略之间存在两个主要区别：
- en: When using CPS, the hard work was actually done in the program transformation.
    The interpreter as a whole was essentially unchanged from before; indeed, the
    main addition to the interpreter was effectively debugging support in the form
    of halting its execution, so we could make sure the continuation strategy was
    correct. Here, the transformation is of the interpreter itself, done one time,
    and the interpreter works to generate the continuations.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用 CPS 时，真正的工作实际上是在程序转换中完成的。整个解释器与以前基本上没有什么不同；事实上，解释器的主要添加实际上是调试支持，以暂停其执行，这样我们就可以确保续延策略是正确的。在这里，转换是对解释器本身的转换，一次完成，而解释器则工作以生成续延。
- en: In particular, the continuation now closes over the rest of the behavior, not
    of the interpreted program but the interpreting one. Because the latter’s job,
    however, is to precisely mimic that of the former, we cannot observe this difference.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特别是，续延现在围绕着行为的其余部分关闭，而不是解释程序的行为。然而，由于后者的工作是精确模仿前者的工作，我们无法观察到这种差异。
- en: In the latter case, static scope (in Pyret) ensures that the correct computations
    are resumed, even if we have multiple continuations stored. Both strategies implicitly
    point out that continuations are themselves statically scoped.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种情况下，静态作用域（在 Pyret 中）确保正确的计算被恢复，即使我们存储了多个续延。这两种策略都隐含地指出续延本身是静态作用域的。
- en: 33.4Generators
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33.4生成器
- en: Many programming languages now have a notion of generators. A generator is like
    a procedure, in that one can invoke it in an application. Whereas a regular procedure
    always begins execution at the beginning, a generator resumes from where it last
    left off. Of course, that means a generator needs a notion of “exiting before
    it’s done”. This is known as yielding, namely returning control to whatever called
    it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在许多编程语言都有生成器的概念。生成器就像一个过程，可以在应用中调用它。而常规过程总是从头开始执行，生成器则从上次离开的地方继续执行。当然，这意味着生成器需要一个“在完成之前退出”的概念。这就是所谓的产出，即将控制返回给调用它的任何东西。
- en: 'There are many variations between generators. The points of variation, predictably,
    have to do with how to enter and exit a generator:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器之间存在许多变化。可预见的变化点与如何进入和退出生成器有关：
- en: In some languages a generator is an object that is instantiated like any other
    object, and its execution is resumed by invoking a method (such as next in Python).
    In others it is just like a procedure, and indeed it is re-entered by applying
    it like a function.In languages where values in addition to regular procedures
    can be used in an application, all such values are collectively called applicables.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些语言中，生成器是一个像任何其他对象一样实例化的对象，通过调用方法（例如Python中的next）来恢复其执行。在其他语言中，它就像一个过程一样，并且通过像函数一样应用它来重新进入。在除了常规过程之外还可以在应用中使用值的语言中，所有这些值都被统称为可应用值。
- en: In some languages the yielding operation—<wbr>such as Python’s yield—<wbr>is
    available only inside the syntactic body of the generator. In others, such as
    Racket, yield is an applicable value bound in the body, but by virtue of being
    a value, it can be passed to abstractions, stored in data structures, and so on.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些语言中，yield操作（例如Python的yield）仅在生成器的语法体内部可用。在其他语言中，例如Racket，yield是绑定在体内的可应用值，但由于是值，它可以传递给抽象，存储在数据结构中等。
- en: Python’s design represents an extreme point in that a generator is simply any
    function that contains the keyword yield in its body. In addition, Python’s yield
    cannot be passed as a parameter to another function that performs the yielding
    on behalf of the generator.There is also a small issue of naming. In many languages
    with generators, the yielder is automatically called yield (as in Python). Another
    possibility is that the user of the generator must indicate in the generator expression
    what name to give the yielder; for example, in Racket,Curiously, Python expects
    users to determine what to call self or this in objects, but it does not provide
    the same flexibility for yield, because it has no other way to determine which
    functions are generators!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Python的设计代表了一个极端点，即生成器只是包含其体中关键字yield的任何函数。此外，Python的yield不能作为参数传递给另一个函数，该函数代表生成器执行yield。还有一个小问题是命名。在许多具有生成器的语言中，yielder自动称为yield（如Python中）。另一种可能性是生成器的用户必须在生成器表达式中指示要给yielder的名称；例如，在Racket中，有趣的是，Python希望用户确定在对象中称为self或this，但它不提供相同的灵活性给yield，因为它没有其他方法来确定哪些函数是生成器！
- en: '| (generator (yield) (from) |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| (generator (yield) (from) |'
- en: '|            (rec (f (lambda (n) |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|            (rec (f (lambda (n) |'
- en: '|                      (begin |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|                      (begin |'
- en: '|                        (yield n) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|                        (yield n) |'
- en: '|                        (f (+ n 1))))) |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|                        (f (+ n 1))))) |'
- en: '|              (f from))) |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|              (f from))) |'
- en: but it might equivalently be
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但它可能等效地是
- en: '| (generator (y) (from) |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| (generator (y) (from) |'
- en: '|            (rec (f (lambda (n) |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|            (rec (f (lambda (n) |'
- en: '|                      (begin |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|                      (begin |'
- en: '|                        (y n) |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|                        (y n) |'
- en: '|                        (f (+ n 1))))) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|                        (f (+ n 1))))) |'
- en: '|              (f from))) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|              (f from))) |'
- en: 'and if the yielder is an actual value, a user can also abstract over yielding:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果yielder是一个实际值，用户还可以对yield进行抽象：
- en: '| (generator (y) (from) |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| (generator (y) (from) |'
- en: '|            (rec (f (lam (n) |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|            (rec (f (lam (n) |'
- en: '|                      (seq |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|                      (seq |'
- en: '|                        ((yield-helper y) n) |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|                        ((yield-helper y) n) |'
- en: '|                        (f (+ n 1))))) |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|                        (f (+ n 1))))) |'
- en: '|              (f from))) |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|              (f from))) |'
- en: 'where yield-helper will presumably perform the actual yielding.There are actually
    two more design decisions:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 其中yield-helper可能会执行实际的yield操作。实际上还有两个设计决策：
- en: 'Is yield a statement or expression? In many languages it is actually an expression,
    meaning it has a value: the one supplied when resuming the generator. This makes
    the generator more flexible because the user of a generator can use the parameter(s)
    to alter the generator’s behavior, rather than being forced to use state to communicate
    desired changes.'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: yield是一个语句还是表达式？在许多语言中，它实际上是一个表达式，意味着它有一个值：在恢复生成器时提供的值。这使得生成器更加灵活，因为生成器的用户可以使用参数来改变生成器的行为，而不是被迫使用状态来��达所需的更改。
- en: What happens at the end of the generator’s execution? In many languages, a generator
    raises an exception to signal its completion.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器执行结束时会发生什么？在许多语言中，生成器会引发异常来表示其完成。
- en: 'To implement generators, it will be especially useful to work from our CPS
    interpreter. Why? Remember how generators work: to yield, a generator must'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现生成器，最好从我们的CPS解释器开始。为什么？记住生成器的工作方式：为了yield，生成器必须
- en: remember where in its execution it currently is, and
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住它当前执行的位置，并
- en: know where in its caller it should return to.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道在其调用者中应该返回到哪里。
- en: while, when invoked, it should
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，它应该
- en: remember where in its execution its caller currently is, and
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住它的执行在其调用者当前的位置，并且
- en: know where in its body it should return to.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道在其体内应该返回到哪里。
- en: Observe the duality between invocation and yielding.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 观察调用和 yield 之间的对偶关系。
- en: As you might guess, these “where”s correspond to continuations.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会猜到，这些“where”对应于 continuations。
- en: Exercise
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add generators to a CPS interpreter.
  id: totrans-352
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 向 CPS 解释器添加生成器。
- en: Exercise
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do generators differ from coroutines and threads? Implement coroutines and
    threads using a similar strategy.
  id: totrans-355
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成器与协程和线程有何不同？使用类似策略实现协程和线程。
- en: Exercise
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We have seen that Python’s generators do not permit any abstraction over yielding,
    whereas Racket’s do. Assuming this was intentional, why might Python have made
    such a design decision?
  id: totrans-358
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们已经看到 Python 的生成器不允许在 yield 上进行任何抽象，而 Racket 的生成器则允许。假设这是有意的，Python 为什么会做出这样的设计决定？
- en: 33.5Continuations and Stacks
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Continuations 和 Stacks
- en: Surprising as it may seem, CPS conversion actually provides tremendous insight
    into the nature of the program execution stack. The first thing to understand
    is that every continuation is actually the stack itself. This might seem odd,
    given that stacks are low-level machine primitives while continuations are seemingly
    complex procedures. But what is the stack, really?
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，CPS 转换实际上为程序执行栈的性质提供了巨大的洞察力。首先要理解的是，每个 continuation 其实都是栈本身。这可能看起来很奇怪，因为栈是低级机器原语，而
    continuation 看似是复杂的过程。但实际上栈是什么？
- en: It’s a record of what remains to be done in the computation. So is the continuation.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它记录了计算中尚未完成的任务。continuation 也是如此。
- en: It’s traditionally thought of as a list of stack frames. That is, each frame
    has a reference to the frames remaining after it finishes. Similarly, each continuation
    is a small procedure that refers to—<wbr>and hence closes over—<wbr>its own continuation.
    If we had chosen a different representation for program instructions, combining
    this with the data structure representation of closures, we would obtain a continuation
    representation that is essentially the same as the machine stack.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它传统上被认为是一个栈帧列表。也就是说，每个帧都有一个引用指向它完成后剩余的帧。同样，每个 continuation 都是一个小过程，它引用——并因此关闭——自己的
    continuation。如果我们选择了不同的程序指令表示结构，将其与闭包的数据结构表示结合起来，我们将获得一个基本与机器栈相同的 continuation
    表示。
- en: Each stack frame also stores procedure parameters. This is implicitly managed
    by the procedural representation of continuations, whereas this was done explicitly
    in the data stucture representation (using bind).
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个栈帧还存储过程参数。这由 continuation 的程序化表示隐式管理，而在数据结构表示中（使用 bind）则是显式完成的。
- en: Each frame also has space for “local variables”. In principle so does the continuation,
    though by desugaring local binding, we’ve effectively reduced everything to procedure
    parameters. Conceptually, however, some of these are “true” procedure parameters
    while others are local bindings turned into procedure parameters by desugaring.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个帧还有“局部变量”的空间。原则上，continuation 也有，尽管通过解糖本地绑定，我们实际上将一切都简化为了过程参数。但在概念上，其中一些是“真正的”过程参数，而其他一些是通过解糖将局部绑定转换为过程参数的本地绑定。
- en: The stack has references to, but does not close over, the heap. Thus changes
    to the heap are visible across stack frames. In precisely the same way, closures
    refer to, but do not close over, the store, so changes to the store are visible
    across closures.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈引用堆，但不关闭堆。因此，堆上的更改在栈帧之间是可见的。同样，闭包引用存储，但不关闭存储，因此对存储的更改在闭包之间是可见的。
- en: 'Therefore, traditionally the stack is responsible for maintaining lexical scope,
    which we get automatically because we are using closures in a statically-scoped
    language.Now we can study the conversion of various terms to understand the mapping
    to stacks. For instance, consider the conversion of a function application ([<cps-trans-appC>](#%28elem._cps-trans-app.C%29)).
    How do we “read” this? As follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，传统上栈负责维护词法作用域，我们自动获得这一点，因为我们在静态作用域语言中使用闭包。现在我们可以研究各种术语的转换以理解其与栈的映射。例如，考虑函数应用的转换。我们如何“读取”它？如下所示：
- en: Let’s use k to refer to the stack present before the function application begins
    to evaluate.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们使用 k 来引用在函数应用开始评估之前存在的栈。
- en: 'When we begin to evaluate the function position (f), create a new stack frame
    (fdC("f-v"): ...;. This frame has one free identifier: k. Thus its closure needs
    to record one element of the environment, namely the rest of the stack.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code portion of the stack frame represents what is left to be done once
    we obtain a value for the function: evaluate the argument, and perform the application,
    and return the result to the stack expecting the result of the application: k.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When evaluation of f completes, we begin to evaluate a, which also creates
    a stack frame: fdC("a-v"): ...;. This frame has two free identifiers: k and f-v.
    This tells us:'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We no longer need the stack frame for evaluating the function position, but
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: we now need a temporary that records the value—<wbr>hopefully a function value—<wbr>of
    evaluating the function position.
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code portion of this second frame also represents what is left to be done:
    invoke the function value with the argument, in the stack expecting the value
    of the application.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, examining the CPS conversion of conditionals would tell us that we
    have to create a new frame to evaluate the conditional expression we have to create
    a new stack frame. This frame closes over the stack expecting the value of the
    entire conditional. This frame makes a decision based on the value of the conditional
    expression, and invokes one of the other expressions. Once we have examined this
    value the frame created to evaluate the conditional expression is no longer necessary,
    so evaluation can proceed in the original continuation.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewed through this lens, we can more easily provide an operational explanation
    for generators. Each generator has its own private stack, and when execution attempts
    to return past its end, our implementation raises an error. On invocation, a generator
    stores a reference to the stack of the “rest of the program”, and resumes its
    own stack. On yielding, the system swaps references to stacks. Coroutines, threads,
    and generators are all conceptually similar: they are all mechanisms to create
    “many little stacks” instead of having a single, global stack.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 33.6Tail Calls
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observe that the stack patterns above add a frame to the current stack, perform
    some evaluation, and eventually always return to the current stack. In particular,
    observe that in an application, we need stack space to evaluate the function position
    and then the arguments, but once all these are evaluated, we resume computation
    using the stack we started out with before the application. In other words, function
    calls do not themselves need to consume stack space: we only need space to compute
    the arguments.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not all languages observe or respect this property. In languages that
    do, programmers can use recursion to obtain iterative behavior: i.e., a sequence
    of function calls can consume no more stack space than no function calls at all.
    This removes the need to create special looping constructs; indeed, loops can
    simply be expressed as a syntactic sugar.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this property does not apply in general. If a call to f is performed
    to compute an argument to a call to g, the call to f is still consuming space
    relative to the context surrounding g. Thus, we should really speak of a relationship
    between expressions: one expression is in tail position relative to another if
    its evaluation requires no additional stack space beyond the other. In our CPS
    desugaring, every expression that uses k as its continuation—<wbr>such as a function
    application after all the sub-expressions have been evaluated, or the then- and
    else-branches of a conditional—<wbr>are all in tail position relative to the enclosing
    application (and perhaps recursively further up). In contrast, every expression
    that has to create a new stack frame is not in tail position.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages have special support for tail recursion: when a procedure calls
    itself in tail position relative to its body. This is obviously useful, because
    it enables recursion to efficiently implement loops. However, it hurts “loops”
    that cannot be squeezed into a single recursive function. For instance, when implementing
    a scanner or other state machine, it is most convenient to have a set of functions
    each representing one state, and transitioning to other states by making (tail)
    function calls. It is onerous (and misses the point) to turn these into a single
    recursive function. If, however, a language recognizes tail calls as such, it
    can optimize these cross-function calls just as much as it does intra-function
    ones.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Scheme and Racket, in particular, promise to implement tail calls without allocating
    additional stack space. Though some people refer to this as “tail call optimization”,
    this term is misleading: an optimization is optional, whereas whether or not a
    language promises to properly implement tail calls is a semantic feature. Developers
    need to know how the language will behave because it affects how they program:
    they need to know how to structure their loops!'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this feature, observe something interesting about the program after
    CPS transformation: all of its function applications are themselves tail calls!
    Assuming the program might terminate at any call is tantamount to not using any
    stack space at all (because the stack would get wiped out).'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any program that consumes some amount of stack, when converted to CPS and run,
    suddenly consumes no stack space at all. Why?
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a corollary, does conversion to CPS reduce the overall memory footprint of
    the program?
  id: totrans-387
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Java’s native security model employs a mechanism called stack inspection (look
    it up if you aren’t familiar with it). What is the interaction between CPS and
    stack inspection? That is, if we were to CPS a program, would this affect its
    security behavior?
  id: totrans-390
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java的本地安全模型采用一种称为堆栈检查的机制（如果您对此不熟悉，请查阅）。控制流保护（CPS）与堆栈检查之间有什么互动？也就是说，如果我们对程序进行CPS，这会影响其安全行为吗？
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If not, why not?
  id: totrans-392
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果不会，为什么？
- en: ''
  id: totrans-393
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If so, how, and what would you suggest doing to recover security assuming the
    CPS conversion was necessary?
  id: totrans-394
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果会，那么如何以及在必要时应该采取什么措施来恢复安全性？
