- en: Dynamic and Lexical ScopesTuesday, February 7th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This seems like it should work, and it even worked on a few examples, except
    for one which was hard to follow. Seems like we have a bug…
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we get to a tricky issue that managed to be a problem for *lots* of language
    implementors, including the first version of Lisp. Lets try to run the following
    expression — try to figure out what it will evaluate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We expect it to return `7` (at least I do!), but we get `9` instead… The question
    is — *should* it return `9`?
  prefs: []
  type: TYPE_NORMAL
- en: What we have arrived to is called *dynamic scope*. Scope is determined by the
    dynamic run-time environment (which is represented by our substitution cache).
    This is *almost always* undesirable, as I hope to convince you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we define two options for a programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static Scope (also called Lexical Scope): In a language with static scope,
    each identifier gets its value from the scope of its definition, not its use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamic Scope: In a language with dynamic scope, each identifier gets its value
    from the scope of its use, not its definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Racket uses lexical scope, our new evaluator uses dynamic, the old substitution-based
    evaluator was static etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side-remark, Lisp began its life as a dynamically-scoped language. The
    artifacts of this were (sort-of) dismissed as an implementation bug. When Scheme
    was introduced, it was the first Lisp dialect that used strictly lexical scoping,
    and Racket is obviously doing the same. (Some Lisp implementations used dynamic
    scope for interpreted code and lexical scope for compiled code!) In fact, Emacs
    Lisp is the only *live* dialects of Lisp that is still dynamically scoped by default.
    Too see this, compare a version of the above code in Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'and the Emacs Lisp version (which looks almost the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'which also happens when we use another function on the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'and note that renaming identifiers can lead to different code — change that
    `val` to `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: and you get `8` because the argument name changed the `x` that the internal
    function sees!
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider also this Emacs Lisp function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: which has no meaning by itself (`x` is unbound),
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'but can be given a dynamic meaning using a `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'or a function application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a dynamically-scoped language in the course languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how bad the last example gets: you basically cannot call any function
    and know in advance what it will do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some cases where dynamic scope can be useful in that it allows you
    to “remotely” customize any piece of code. A good example of where this is taken
    to an extreme is Emacs: originally, it was based on an ancient Lisp dialect that
    was still dynamically scoped, but it retained this feature even when practically
    all Lisp dialects moved on to having lexical scope by default. The reason for
    this is that the danger of dynamic scope is also a way to make a very open system
    where almost anything can be customized by changing it “remotely”. Here’s a concrete
    example for a similar kind of dynamic scope usage that makes a very hackable and
    open system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this power to customize everything is also the main source of problems
    with getting no guarantees for code. A common way to get the best of both worlds
    is to have *controllable* dynamic scope. For example, Common Lisp also has lexical
    scope everywhere by default, but some variables can be declared as *special*,
    which means that they are dynamically scoped. The main problem with that is that
    you can’t tell when a variable is special by just looking at the code that uses
    it, so a more popular approach is the one that is used in Racket: all bindings
    are always lexically scoped, but there are *parameters* which are a kind of dynamically
    scoped value containers — but they are bound to plain (lexically scoped) identifiers.
    Here’s the same code as above, translated to Racket with parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The main point here is that the points where a dynamically scoped value is used
    are under the programmer’s control — you cannot “customize” what `-` is doing,
    for example. This gives us back the guarantees that we like to have (= that code
    works), but of course these points are pre-determined, unlike an environment where
    everything can be customized including things that are unexpectedly useful.
  prefs: []
  type: TYPE_NORMAL
- en: As a side-note, after many decades of debating this, Emacs has finally added
    lexical scope in its core language, but this is still determined by a flag — a
    global `lexical-binding` variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
