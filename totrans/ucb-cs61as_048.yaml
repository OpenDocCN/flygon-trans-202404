- en: Tree Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A New Class of Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some problems for which we haven''t explicitly described a recursive
    pattern for yet. Consider the following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: I want to go up a flight of stairs that has `n` steps. I can either take 1 or
    2 steps each time. How many different ways can I go up this flight of stairs?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, in the case where `n` is 5, there are 8 possible ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1 1 1 1 1](../static/count-stairs/11111.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2 1 1 1](../static/count-stairs/2111.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[1 2 1 1](../static/count-stairs/1211.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[1 1 2 1](../static/count-stairs/1121.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[1 1 1 2](../static/count-stairs/1112.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[1 2 2](../static/count-stairs/122.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2 1 2](../static/count-stairs/212.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2 2 1](../static/count-stairs/221.png)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve this problem, we have to introduce a pattern called *Tree
    Recursion*. Tree Recursion is just a phrase to describe when you make a recursive
    call more than once in your recursive case. Why would we need to do this here?
    Consider one solution to the above problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Breaking the procedure down, there are three parts to consider
  prefs: []
  type: TYPE_NORMAL
- en: There are two base cases, with two different outcomes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is only one step to climb, there is only one way (by taking that step)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are two steps to climb, there is exactly two ways (1-step 1-step, or
    2-step)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the problem is made smaller by breaking it into two worlds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first world, we take one step, and thus the number of steps is reduced
    by one
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second world, we take two steps, and thus the number of steps is reduced
    by two
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Making two recursive calls to those smaller problems gives us the answer to
    those smaller problems, and adding up those up gives us the answer to the original
    problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count-stairs` is *tree recursive* because whenever it is called, the recursive
    calls branches out and form an upside-down tree. For example, `(count-stairs 5)`:
    ![An upside down tree](../static/count-stairs/(count-stairs 5).png)'
  prefs: []
  type: TYPE_NORMAL
- en: Counting Change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let consider a harder problem to solve:'
  prefs: []
  type: TYPE_NORMAL
- en: How many different ways can we make change of $1.00, given half-dollars, quarters,
    dimes, nickels, and pennies? More generally, can we write a function to compute
    the number of ways to change any given amount of money using any set of currency
    denominations?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We approach the problem in a similar fashion as above. By thinking carefully
    about the problem statement, we can notice that we have to keep track of a two
    things: what our amount currently is, and which coins we have to use (we can keep
    track of this in a sentence, e.g. `''(50 25 10 5 1)`). From there, we can observe
    a few things about our base cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If the amount is exactly 0, we should count that as 1 way to make change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may seem counter-intuitive, but there's exactly one way to make change
    for $0--use no coins.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the amount is less than 0, we should count that as 0 ways to make change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't make change for negative amounts!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we run out of coins to use, we should count that as 0 ways to make change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will become more intuitive once we consider the recursive case.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the recursive case, we again have to make two recursive calls. These two
    recursive calls break our problem into two worlds:'
  prefs: []
  type: TYPE_NORMAL
- en: In one world, we use the the largest coin (the `first` of `(50 25 10 5 1)`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are the coins in that order? Because it's easy to reason about. The sentence
    could be in a different order, and while that will affect the computation, it
    will not affect the result.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the other world, we never use the largest coin again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if we never use the half dollar again, our new sentence should
    be `(25 10 5 1)`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we translate this into code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On Time Efficiency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tree recursive procedures typically take exponential time to compute. Why would
    we ever use them?
  prefs: []
  type: TYPE_NORMAL
- en: Some problems are more easily solved by thinking tree recursively. Try writing
    count-change using for loops in another language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some problems are intractably hard, meaning the fastest known algorithms we
    have for them are *still* exponential in runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turns out we can optimize tree recursive procedures without changing their shape,
    which we will cover later in the course.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[SICP 1.2.2 Tree Recursion](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_1.2.2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SICP 1.2.2 Example: Counting Change](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_Temp_52)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
