- en: RecordSubSubtyping with Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import MoreStlc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Well-Formedness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The syntax of terms and types is a bit too loose, in the sense
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that it admits things like a record type whose final "tail" is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Top or some arrow type rather than Nil.  To avoid such cases,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is useful to assume that all the record types and terms that we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: see will obey some simple well-formedness conditions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An interesting technical question is whether the basic properties of the system
    -- progress and preservation -- remain true if we drop these conditions. I believe
    they do, and I would encourage motivated readers to try to check this by dropping
    the conditions from the definitions of typing and subtyping and adjusting the
    proofs in the rest of the chapter accordingly. This is not a trivial exercise
    (or I'd have done it!), but it should not involve changing the basic structure
    of the proofs. If someone does do it, please let me know. --BCP 5/16.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Substitution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Substitution and reduction are as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Reduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Subtyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we come to the interesting part, where the features we've
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: added start to interact.  We begin by defining the subtyping
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation and developing some of its important technical
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "T '<:' U" (at level 40).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive subtype : ty → ty → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: (* Subtyping between proper types *)
  prefs: []
  type: TYPE_NORMAL
- en: '| S_Refl : ∀T,'
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty T →
  prefs: []
  type: TYPE_NORMAL
- en: 'T <: T'
  prefs: []
  type: TYPE_NORMAL
- en: '| S_Trans : ∀S U T,'
  prefs: []
  type: TYPE_NORMAL
- en: 'S <: U →'
  prefs: []
  type: TYPE_NORMAL
- en: 'U <: T →'
  prefs: []
  type: TYPE_NORMAL
- en: 'S <: T'
  prefs: []
  type: TYPE_NORMAL
- en: '| S_Top : ∀S,'
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty S →
  prefs: []
  type: TYPE_NORMAL
- en: 'S <: TTop'
  prefs: []
  type: TYPE_NORMAL
- en: '| S_Arrow : ∀S[1] S[2] T[1] T[2],'
  prefs: []
  type: TYPE_NORMAL
- en: 'T[1] <: S[1] →'
  prefs: []
  type: TYPE_NORMAL
- en: 'S[2] <: T[2] →'
  prefs: []
  type: TYPE_NORMAL
- en: 'TArrow S[1] S[2] <: TArrow T[1] T[2]'
  prefs: []
  type: TYPE_NORMAL
- en: (* Subtyping between record types *)
  prefs: []
  type: TYPE_NORMAL
- en: '| S_RcdWidth : ∀i T[1] T[2],'
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty (TRCons i T[1] T[2]) →
  prefs: []
  type: TYPE_NORMAL
- en: 'TRCons i T[1] T[2] <: TRNil'
  prefs: []
  type: TYPE_NORMAL
- en: '| S_RcdDepth : ∀i S[1] T[1] Sr[2] Tr[2],'
  prefs: []
  type: TYPE_NORMAL
- en: 'S[1] <: T[1] →'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sr[2] <: Tr[2] →'
  prefs: []
  type: TYPE_NORMAL
- en: record_ty Sr[2] →
  prefs: []
  type: TYPE_NORMAL
- en: record_ty Tr[2] →
  prefs: []
  type: TYPE_NORMAL
- en: 'TRCons i S[1] Sr[2] <: TRCons i T[1] Tr[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '| S_RcdPerm : ∀i[1] i[2] T[1] T[2] Tr[3],'
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty (TRCons i[1] T[1] (TRCons i[2] T[2] Tr[3])) →
  prefs: []
  type: TYPE_NORMAL
- en: i[1] ≠ i[2] →
  prefs: []
  type: TYPE_NORMAL
- en: TRCons i[1] T[1] (TRCons i[2] T[2] Tr[3])
  prefs: []
  type: TYPE_NORMAL
- en: '<: TRCons i[2] T[2] (TRCons i[1] T[1] Tr[3])'
  prefs: []
  type: TYPE_NORMAL
- en: where "T '<:' U" := (subtype T U).
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors subtype.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Module Examples.
  prefs: []
  type: TYPE_NORMAL
- en: Notation x := (Id "x").
  prefs: []
  type: TYPE_NORMAL
- en: Notation y := (Id "y").
  prefs: []
  type: TYPE_NORMAL
- en: Notation z := (Id "z").
  prefs: []
  type: TYPE_NORMAL
- en: Notation j := (Id "j").
  prefs: []
  type: TYPE_NORMAL
- en: Notation k := (Id "k").
  prefs: []
  type: TYPE_NORMAL
- en: Notation i := (Id "i").
  prefs: []
  type: TYPE_NORMAL
- en: Notation A := (TBase (Id "A")).
  prefs: []
  type: TYPE_NORMAL
- en: Notation B := (TBase (Id "B")).
  prefs: []
  type: TYPE_NORMAL
- en: Notation C := (TBase (Id "C")).
  prefs: []
  type: TYPE_NORMAL
- en: Definition TRcd_j  :=
  prefs: []
  type: TYPE_NORMAL
- en: (TRCons j (TArrow B B) TRNil). (* {j:B->B} *)
  prefs: []
  type: TYPE_NORMAL
- en: Definition TRcd_kj :=
  prefs: []
  type: TYPE_NORMAL
- en: TRCons k (TArrow A A) TRcd_j. (* {k:C->C,j:B->B} *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example subtyping_example_0 :'
  prefs: []
  type: TYPE_NORMAL
- en: subtype (TArrow C TRcd_kj)
  prefs: []
  type: TYPE_NORMAL
- en: (TArrow C TRNil).
  prefs: []
  type: TYPE_NORMAL
- en: (* C->{k:A->A,j:B->B} <: C->{} *)
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply S_Arrow.
  prefs: []
  type: TYPE_NORMAL
- en: apply S_Refl. auto.
  prefs: []
  type: TYPE_NORMAL
- en: unfold TRcd_kj, TRcd_j. apply S_RcdWidth; auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Example subtyping_example_1 :'
  prefs: []
  type: TYPE_NORMAL
- en: subtype TRcd_kj TRcd_j.
  prefs: []
  type: TYPE_NORMAL
- en: (* {k:A->A,j:B->B} <: {j:B->B} *)
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Example subtyping_example_2 :'
  prefs: []
  type: TYPE_NORMAL
- en: subtype (TArrow TTop TRcd_kj)
  prefs: []
  type: TYPE_NORMAL
- en: (TArrow (TArrow C C) TRcd_j).
  prefs: []
  type: TYPE_NORMAL
- en: (* Top->{k:A->A,j:B->B} <: (C->C)->{j:B->B} *)
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Example subtyping_example_3 :'
  prefs: []
  type: TYPE_NORMAL
- en: subtype (TArrow TRNil (TRCons j A TRNil))
  prefs: []
  type: TYPE_NORMAL
- en: (TArrow (TRCons k B TRNil) TRNil).
  prefs: []
  type: TYPE_NORMAL
- en: (* {}->{j:A} <: {k:B}->{} *)
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Example subtyping_example_4 :'
  prefs: []
  type: TYPE_NORMAL
- en: subtype (TRCons x A (TRCons y B (TRCons z C TRNil)))
  prefs: []
  type: TYPE_NORMAL
- en: (TRCons z C (TRCons y B (TRCons x A TRNil))).
  prefs: []
  type: TYPE_NORMAL
- en: (* {x:A,y:B,z:C} <: {z:C,y:B,x:A} *)
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: End Examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma subtype__wf : ∀S T,'
  prefs: []
  type: TYPE_NORMAL
- en: subtype S T →
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty T ∧ well_formed_ty S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros S T Hsub.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hsub;
  prefs: []
  type: TYPE_NORMAL
- en: intros; try (destruct IHHsub1; destruct IHHsub2)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* S_RcdPerm *)'
  prefs: []
  type: TYPE_NORMAL
- en: split... inversion H. subst. inversion H[5]... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma wf_rcd_lookup : ∀i T Ti,'
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty T →
  prefs: []
  type: TYPE_NORMAL
- en: Tlookup i T = Some Ti →
  prefs: []
  type: TYPE_NORMAL
- en: well_formed_ty Ti.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros i T.
  prefs: []
  type: TYPE_NORMAL
- en: induction T; intros; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* TRCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. subst. unfold [Tlookup](RecordSub.html#Tlookup) in H[0].
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) i i[0])... inversion H[0]; subst... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma rcd_types_match : ∀S T i Ti,'
  prefs: []
  type: TYPE_NORMAL
- en: subtype S T →
  prefs: []
  type: TYPE_NORMAL
- en: Tlookup i T = Some Ti →
  prefs: []
  type: TYPE_NORMAL
- en: ∃Si, Tlookup i S = Some Si ∧ subtype Si Ti.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with (eauto using [wf_rcd_lookup](RecordSub.html#wf_rcd_lookup)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros S T i Ti Hsub Hget. generalize dependent Ti.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hsub; intros Ti Hget;
  prefs: []
  type: TYPE_NORMAL
- en: try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* S_Refl *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃Ti...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* S_Trans *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct (IHHsub2 Ti) as [Ui Hui]... destruct Hui.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (IHHsub1 Ui) as [Si Hsi]... destruct Hsi.
  prefs: []
  type: TYPE_NORMAL
- en: ∃Si...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* S_RcdDepth *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i[0] into k.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [Tlookup](RecordSub.html#Tlookup). unfold [Tlookup](RecordSub.html#Tlookup)
    in Hget.
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) i k)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* i = k -- we're looking up the first field *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hget. subst. ∃S[1]...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* S_RcdPerm *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃Ti. split.
  prefs: []
  type: TYPE_NORMAL
- en: + (* lookup *)
  prefs: []
  type: TYPE_NORMAL
- en: unfold [Tlookup](RecordSub.html#Tlookup). unfold [Tlookup](RecordSub.html#Tlookup)
    in Hget.
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) i i[1])...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* i = i[1] -- we''re looking up the first field *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) i i[2])...
  prefs: []
  type: TYPE_NORMAL
- en: (* i = i[2] -- contradictory *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct H[0].
  prefs: []
  type: TYPE_NORMAL
- en: subst...
  prefs: []
  type: TYPE_NORMAL
- en: + (* subtype *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. subst. inversion H[5]. subst... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma sub_inversion_arrow : ∀U V[1] V[2],'
  prefs: []
  type: TYPE_NORMAL
- en: subtype U (TArrow V[1] V[2]) →
  prefs: []
  type: TYPE_NORMAL
- en: ∃U[1], ∃U[2],
  prefs: []
  type: TYPE_NORMAL
- en: (U=(TArrow U[1] U[2])) ∧ (subtype V[1] U[1]) ∧ (subtype U[2] V[2]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros U V[1] V[2] Hs.
  prefs: []
  type: TYPE_NORMAL
- en: remember ([TArrow](RecordSub.html#TArrow) V[1] V[2]) as V.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent V[2]. generalize dependent V[1].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Typing Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (typing_example_0)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Example typing_example_1 :'
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty
  prefs: []
  type: TYPE_NORMAL
- en: (tapp (tabs x TRcd_j (tproj (tvar x) j))
  prefs: []
  type: TYPE_NORMAL
- en: (trcd_kj))
  prefs: []
  type: TYPE_NORMAL
- en: (TArrow B B).
  prefs: []
  type: TYPE_NORMAL
- en: (* empty |- (λx:{k:A->A,j:B->B}. x.j)                {k=(λz:A.z), j=(λz:B.z)} 
             : B->B *)
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (typing_example_2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma has_type__wf : ∀Γ t T,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ t T → well_formed_ty T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros Γ t T Htyp.
  prefs: []
  type: TYPE_NORMAL
- en: induction Htyp...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion IHHtyp1...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Proj *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [wf_rcd_lookup](RecordSub.html#wf_rcd_lookup)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Sub *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [subtype__wf](RecordSub.html#subtype__wf) in H.
  prefs: []
  type: TYPE_NORMAL
- en: destruct H...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma step_preserves_record_tm : ∀tr tr'','
  prefs: []
  type: TYPE_NORMAL
- en: record_tm tr →
  prefs: []
  type: TYPE_NORMAL
- en: tr ⇒ tr' →
  prefs: []
  type: TYPE_NORMAL
- en: record_tm tr'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros tr tr' Hrt Hstp.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hrt; subst; inversion Hstp; subst; eauto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma lookup_field_in_value : ∀v T i Ti,'
  prefs: []
  type: TYPE_NORMAL
- en: value v →
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty v T →
  prefs: []
  type: TYPE_NORMAL
- en: Tlookup i T = Some Ti →
  prefs: []
  type: TYPE_NORMAL
- en: ∃vi, tlookup i v = Some vi ∧ has_type empty vi Ti.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: remember [empty](Maps.html#empty) as Γ.
  prefs: []
  type: TYPE_NORMAL
- en: intros t T i Ti Hval Htyp. revert Ti HeqGamma Hval.
  prefs: []
  type: TYPE_NORMAL
- en: induction Htyp; intros; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Sub *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply ([rcd_types_match](RecordSub.html#rcd_types_match) S) in H[0]...
  prefs: []
  type: TYPE_NORMAL
- en: destruct H[0] as [Si [HgetSi Hsub]].
  prefs: []
  type: TYPE_NORMAL
- en: destruct (IHHtyp Si) as [vi [Hget Htyvi]]...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl in H[0]. simpl. simpl in H[1].
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) i i[0]).
  prefs: []
  type: TYPE_NORMAL
- en: + (* i is first *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[1]. subst. ∃t...
  prefs: []
  type: TYPE_NORMAL
- en: + (* i in tail *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct (IHHtyp2 Ti) as [vi [get Htyvi]]...
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hval... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma canonical_forms_of_arrow_types : ∀Γ s T[1] T[2],'
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ s (TArrow T[1] T[2]) →
  prefs: []
  type: TYPE_NORMAL
- en: value s →
  prefs: []
  type: TYPE_NORMAL
- en: ∃x, ∃S[1], ∃s[2],
  prefs: []
  type: TYPE_NORMAL
- en: s = tabs x S[1] s[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Theorem progress : ∀t T,'
  prefs: []
  type: TYPE_NORMAL
- en: '[has_type](RecordSub.html#has_type) [empty](Maps.html#empty) [t](RecordSub.html#t)
    [T](RecordSub.html#T) →'
  prefs: []
  type: TYPE_NORMAL
- en: '[value](RecordSub.html#value) [t](RecordSub.html#t) ∨ ∃t'', [t](RecordSub.html#t)
    ⇒ [t''](RecordSub.html#t'').'
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t T Ht.
  prefs: []
  type: TYPE_NORMAL
- en: remember [empty](Maps.html#empty) as Γ.
  prefs: []
  type: TYPE_NORMAL
- en: revert HeqGamma.
  prefs: []
  type: TYPE_NORMAL
- en: induction Ht;
  prefs: []
  type: TYPE_NORMAL
- en: intros HeqGamma; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Var *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1; subst...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] is a value *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([canonical_forms_of_arrow_types](RecordSub.html#canonical_forms_of_arrow_types)
    [empty](Maps.html#empty) t[1] T[1] T[2])
  prefs: []
  type: TYPE_NORMAL
- en: as [x [S[1] [t[12] Heqt1]]]...
  prefs: []
  type: TYPE_NORMAL
- en: subst. ∃([x:=t[2]]t[12])...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct H[0] as [t[2]' Hstp]. ∃([tapp](RecordSub.html#tapp) t[1] t[2]')...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct H as [t[1]' Hstp]. ∃([tapp](RecordSub.html#tapp) t[1]' t[2])...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Proj *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct IHHt...
  prefs: []
  type: TYPE_NORMAL
- en: + (* rcd is value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([lookup_field_in_value](RecordSub.html#lookup_field_in_value) t T
    i Ti)
  prefs: []
  type: TYPE_NORMAL
- en: as [t' [Hget Ht']]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* rcd_steps *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct H[0] as [t' Hstp]. ∃([tproj](RecordSub.html#tproj) t' i)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  prefs: []
  type: TYPE_NORMAL
- en: + (* head is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* tail steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct H[2] as [tr' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([trcons](RecordSub.html#trcons) i t tr')...
  prefs: []
  type: TYPE_NORMAL
- en: + (* head steps *)
  prefs: []
  type: TYPE_NORMAL
- en: right. destruct H[1] as [t' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([trcons](RecordSub.html#trcons) i t' tr)... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Theorem* : For any term t and type T, if empty ⊢ t : T'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then t is a value or t ⇒ t' for some term t'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Proof*: Let t and T be given such that empty ⊢ t : T.  We'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proceed by induction on the given typing derivation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The cases where the last step in the typing derivation is T_Abs or T_RNil are
    immediate because abstractions and {} are always values. The case for T_Var is
    vacuous because variables cannot be typed in the empty context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the last step in the typing derivation is by T_App, then there are terms
    t[1] t[2] and types T[1] T[2] such that t = t[1] t[2], T = T[2], empty ⊢ t[1]
    : T[1] → T[2] and empty ⊢ t[2] : T[1].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The induction hypotheses for these typing derivations yield that t[1] is a value
    or steps, and that t[2] is a value or steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suppose t[1] ⇒ t[1]' for some term t[1]'. Then t[1] t[2] ⇒ t[1]' t[2] by ST_App1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise t[1] is a value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose t[2] ⇒ t[2]' for some term t[2]'. Then t[1] t[2] ⇒ t[1] t[2]' by rule
    ST_App2 because t[1] is a value.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, t[2] is a value. By Lemma canonical_forms_for_arrow_types, t[1] =
    \x:S[1].s2 for some x, S[1], and s[2]. But then (λx:S[1].s2) t[2] ⇒ [x:=t[2]]s[2]
    by ST_AppAbs, since t[2] is a value.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the last step of the derivation is by T_Proj, then there are a term tr,
    a type Tr, and a label i such that t = tr.i, empty ⊢ tr : Tr, and Tlookup i Tr
    = Some T.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the IH, either tr is a value or it steps. If tr ⇒ tr' for some term tr',
    then tr.i ⇒ tr'.i by rule ST_Proj1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If tr is a value, then Lemma lookup_field_in_value yields that there is a term
    ti such that tlookup i tr = Some ti. It follows that tr.i ⇒ ti by rule ST_ProjRcd.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the final step of the derivation is by T_Sub, then there is a type S such
    that S <: T and empty ⊢ t : S. The desired result is exactly the induction hypothesis
    for the typing subderivation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the final step of the derivation is by T_RCons, then there exist some terms
    t[1] tr, types T[1] Tr and a label t such that t = {i=t[1], tr}, T = {i:T[1],
    Tr}, record_tm tr, record_tm Tr, empty ⊢ t[1] : T[1] and empty ⊢ tr : Tr.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The induction hypotheses for these typing derivations yield that t[1] is a
    value or steps, and that tr is a value or steps. We consider each case:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suppose t[1] ⇒ t[1]' for some term t[1]'. Then {i=t[1], tr} ⇒ {i=t[1]', tr}
    by rule ST_Rcd_Head.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise t[1] is a value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose tr ⇒ tr' for some term tr'. Then {i=t[1], tr} ⇒ {i=t[1], tr'} by rule
    ST_Rcd_Tail, since t[1] is a value.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, tr is also a value. So, {i=t[1], tr} is a value by v_rcons.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma typing_inversion_var : ∀Γ x T,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ (tvar x) T →
  prefs: []
  type: TYPE_NORMAL
- en: ∃S,
  prefs: []
  type: TYPE_NORMAL
- en: Γ x = Some S ∧ subtype S T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros Γ x T Hty.
  prefs: []
  type: TYPE_NORMAL
- en: remember ([tvar](RecordSub.html#tvar) x) as t.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hty; intros;
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqt; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Var *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃T...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Sub *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHty as [U [Hctx HsubU]]... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma typing_inversion_app : ∀Γ t[1] t[2] T[2],'
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ (tapp t[1] t[2]) T[2] →
  prefs: []
  type: TYPE_NORMAL
- en: ∃T[1],
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ t[1] (TArrow T[1] T[2]) ∧
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ t[2] T[1].
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros Γ t[1] t[2] T[2] Hty.
  prefs: []
  type: TYPE_NORMAL
- en: remember ([tapp](RecordSub.html#tapp) t[1] t[2]) as t.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hty; intros;
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqt; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃T[1]...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Sub *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHty as [U[1] [Hty1 Hty2]]...
  prefs: []
  type: TYPE_NORMAL
- en: assert (Hwf := [has_type__wf](RecordSub.html#has_type__wf) _ _ _ Hty2).
  prefs: []
  type: TYPE_NORMAL
- en: ∃U[1]... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma typing_inversion_abs : ∀Γ x S[1] t[2] T,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ (tabs x S[1] t[2]) T →
  prefs: []
  type: TYPE_NORMAL
- en: (∃S[2], subtype (TArrow S[1] S[2]) T
  prefs: []
  type: TYPE_NORMAL
- en: ∧ has_type (update Γ x S[1]) t[2] S[2]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros Γ x S[1] t[2] T H.
  prefs: []
  type: TYPE_NORMAL
- en: remember ([tabs](RecordSub.html#tabs) x S[1] t[2]) as t.
  prefs: []
  type: TYPE_NORMAL
- en: induction H;
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqt; subst; intros; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: assert (Hwf := [has_type__wf](RecordSub.html#has_type__wf) _ _ _ H[0]).
  prefs: []
  type: TYPE_NORMAL
- en: ∃T[12]...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Sub *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHhas_type as [S[2] [Hsub Hty]]...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma typing_inversion_proj : ∀Γ i t[1] Ti,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ (tproj t[1] i) Ti →
  prefs: []
  type: TYPE_NORMAL
- en: ∃T, ∃Si,
  prefs: []
  type: TYPE_NORMAL
- en: Tlookup i T = Some Si ∧ subtype Si Ti ∧ has_type Γ t[1] T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros Γ i t[1] Ti H.
  prefs: []
  type: TYPE_NORMAL
- en: remember ([tproj](RecordSub.html#tproj) t[1] i) as t.
  prefs: []
  type: TYPE_NORMAL
- en: induction H;
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqt; subst; intros; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Proj *)'
  prefs: []
  type: TYPE_NORMAL
- en: assert ([well_formed_ty](RecordSub.html#well_formed_ty) Ti) as Hwf.
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* pf of assertion *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply ([wf_rcd_lookup](RecordSub.html#wf_rcd_lookup) i T Ti)...
  prefs: []
  type: TYPE_NORMAL
- en: apply [has_type__wf](RecordSub.html#has_type__wf) in H... }
  prefs: []
  type: TYPE_NORMAL
- en: ∃T. ∃Ti...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Sub *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHhas_type as [U [Ui [Hget [Hsub Hty]]]]...
  prefs: []
  type: TYPE_NORMAL
- en: ∃U. ∃Ui... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma typing_inversion_rcons : ∀Γ i ti tr T,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ (trcons i ti tr) T →
  prefs: []
  type: TYPE_NORMAL
- en: ∃Si, ∃Sr,
  prefs: []
  type: TYPE_NORMAL
- en: subtype (TRCons i Si Sr) T ∧ has_type Γ ti Si ∧
  prefs: []
  type: TYPE_NORMAL
- en: record_tm tr ∧ has_type Γ tr Sr.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros Γ i ti tr T Hty.
  prefs: []
  type: TYPE_NORMAL
- en: remember ([trcons](RecordSub.html#trcons) i ti tr) as t.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hty;
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqt; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Sub *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHHty in H[0].
  prefs: []
  type: TYPE_NORMAL
- en: destruct H[0] as [Ri [Rr [HsubRS [HtypRi HtypRr]]]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃Ri. ∃Rr...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: assert ([well_formed_ty](RecordSub.html#well_formed_ty) ([TRCons](RecordSub.html#TRCons)
    i T Tr)) as Hwf.
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* pf of assertion *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [has_type__wf](RecordSub.html#has_type__wf) in Hty1.
  prefs: []
  type: TYPE_NORMAL
- en: apply [has_type__wf](RecordSub.html#has_type__wf) in Hty2... }
  prefs: []
  type: TYPE_NORMAL
- en: ∃T. ∃Tr... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma abs_arrow : ∀x S[1] s[2] T[1] T[2],'
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty (tabs x S[1] s[2]) (TArrow T[1] T[2]) →
  prefs: []
  type: TYPE_NORMAL
- en: subtype T[1] S[1]
  prefs: []
  type: TYPE_NORMAL
- en: ∧ has_type (update empty x S[1]) s[2] T[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros x S[1] s[2] T[1] T[2] Hty.
  prefs: []
  type: TYPE_NORMAL
- en: apply [typing_inversion_abs](RecordSub.html#typing_inversion_abs) in Hty.
  prefs: []
  type: TYPE_NORMAL
- en: destruct Hty as [S[2] [Hsub Hty]].
  prefs: []
  type: TYPE_NORMAL
- en: apply [sub_inversion_arrow](RecordSub.html#sub_inversion_arrow) in Hsub.
  prefs: []
  type: TYPE_NORMAL
- en: destruct Hsub as [U[1] [U[2] [Heq [Hsub1 Hsub2]]]].
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heq; subst... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive appears_free_in : id → tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_var : ∀x,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tvar x)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_app1 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] → appears_free_in x (tapp t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_app2 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] → appears_free_in x (tapp t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_abs : ∀x y T[11] t[12],'
  prefs: []
  type: TYPE_NORMAL
- en: y ≠ x  →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[12] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tabs y T[11] t[12])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_proj : ∀x t i,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tproj t i)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_rhead : ∀x i t tr,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (trcons i t tr)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_rtail : ∀x i t tr,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x tr →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (trcons i t tr).
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors appears_free_in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma context_invariance : ∀Γ Γ'' t S,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ t S  →
  prefs: []
  type: TYPE_NORMAL
- en: (∀x, appears_free_in x t → Γ x = Γ' x)  →
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ' t S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros. generalize dependent Γ'.
  prefs: []
  type: TYPE_NORMAL
- en: induction H;
  prefs: []
  type: TYPE_NORMAL
- en: intros Γ' Heqv...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Var *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Var](RecordSub.html#T_Var)... rewrite ← Heqv...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Abs](RecordSub.html#T_Abs)... apply IHhas_type. intros x[0] Hafi.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update). destruct
    ([beq_idP](Maps.html#beq_idP) x x[0])...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_App](RecordSub.html#T_App) with T[1]...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_RCons](RecordSub.html#T_RCons)... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma free_in_context : ∀x t T Γ,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ t T →
  prefs: []
  type: TYPE_NORMAL
- en: ∃T', Γ x = Some T'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros x t T Γ Hafi Htyp.
  prefs: []
  type: TYPE_NORMAL
- en: induction Htyp; subst; inversion Hafi; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct (IHHtyp H[5]) as [T Hctx]. ∃T.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type (update Γ x U) t S  →
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty v U   →
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ ([x:=v]t) S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros Γ x U v t S Htypt Htypv.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent S. generalize dependent Γ.
  prefs: []
  type: TYPE_NORMAL
- en: induction t; intros; simpl.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tvar *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i into y.
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([typing_inversion_var](RecordSub.html#typing_inversion_var) _ _ _
    Htypt) as [T [Hctx Hsub]].
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y *)
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hctx; subst. clear Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: apply [context_invariance](RecordSub.html#context_invariance) with [empty](Maps.html#empty)...
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hcontra.
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([free_in_context](RecordSub.html#free_in_context) _ _ S [empty](Maps.html#empty)
    Hcontra) as [T' HT']...
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT'.
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([subtype__wf](RecordSub.html#subtype__wf) _ _ Hsub)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tapp *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([typing_inversion_app](RecordSub.html#typing_inversion_app) _ _ _
    _ Htypt)
  prefs: []
  type: TYPE_NORMAL
- en: as [T[1] [Htypt1 Htypt2]].
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_App](RecordSub.html#T_App)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tabs *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i into y. rename t into T[1].
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([typing_inversion_abs](RecordSub.html#typing_inversion_abs) _ _ _
    _ _ Htypt)
  prefs: []
  type: TYPE_NORMAL
- en: as [T[2] [Hsub Htypt2]].
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([subtype__wf](RecordSub.html#subtype__wf) _ _ Hsub) as [Hwf1 Hwf2].
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hwf2. subst.
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Sub](RecordSub.html#T_Sub) with ([TArrow](RecordSub.html#TArrow) T[1]
    T[2])... apply [T_Abs](RecordSub.html#T_Abs)...
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y).
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y *)
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](RecordSub.html#context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) y x)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y *)
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt. eapply [context_invariance](RecordSub.html#context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y z)...
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tproj *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([typing_inversion_proj](RecordSub.html#typing_inversion_proj) _ _
    _ _ Htypt)
  prefs: []
  type: TYPE_NORMAL
- en: as [T [Ti [Hget [Hsub Htypt1]]]]...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* trnil *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](RecordSub.html#context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: intros y Hcontra. inversion Hcontra.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* trcons *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([typing_inversion_rcons](RecordSub.html#typing_inversion_rcons) _
    _ _ _ _ Htypt) as
  prefs: []
  type: TYPE_NORMAL
- en: '[Ti [Tr [Hsub [HtypTi [Hrcdt2 HtypTr]]]]].'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Sub](RecordSub.html#T_Sub) with ([TRCons](RecordSub.html#TRCons) i
    Ti Tr)...
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_RCons](RecordSub.html#T_RCons)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* record_ty Tr *)
  prefs: []
  type: TYPE_NORMAL
- en: apply [subtype__wf](RecordSub.html#subtype__wf) in Hsub. destruct Hsub. inversion
    H[0]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* record_tm (x:=vt[2]) *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hrcdt2; subst; simpl... Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem preservation : ∀t t'' T,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty t T  →
  prefs: []
  type: TYPE_NORMAL
- en: t ⇒ t'  →
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty t' T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t t' T HT.
  prefs: []
  type: TYPE_NORMAL
- en: remember [empty](Maps.html#empty) as Γ. generalize dependent HeqGamma.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent t'.
  prefs: []
  type: TYPE_NORMAL
- en: induction HT;
  prefs: []
  type: TYPE_NORMAL
- en: intros t' HeqGamma HE; subst; inversion HE; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion HE; subst...
  prefs: []
  type: TYPE_NORMAL
- en: + (* ST_AppAbs *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([abs_arrow](RecordSub.html#abs_arrow) _ _ _ _ _ HT[1]) as [HA[1] HA[2]].
  prefs: []
  type: TYPE_NORMAL
- en: apply [substitution_preserves_typing](RecordSub.html#substitution_preserves_typing)
    with T...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Proj *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([lookup_field_in_value](RecordSub.html#lookup_field_in_value) _ _
    _ _ H[2] HT H)
  prefs: []
  type: TYPE_NORMAL
- en: as [vi [Hget Hty]].
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H[4] in Hget. inversion Hget. subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_RCons *)'
  prefs: []
  type: TYPE_NORMAL
- en: eauto using [step_preserves_record_tm](RecordSub.html#step_preserves_record_tm).
    Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
