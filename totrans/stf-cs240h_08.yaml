- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gabriel Gonzalez
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: May 1, 2014 - CS240H
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**[The problem `pipes` solves]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How `pipes` works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theory behind `pipes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tour of the `pipes` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Does not work on infinite lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't consume any results until everything has been processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to run the entire computation, even if you don't need every result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This wastes memory by buffering every result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-solution: lazy IO'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only works for `IO`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only works for effectful sources, not effectful sinks or transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalidates equational reasoning by tying effects to evaluation order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admission of defeat ("Monads are too awkward")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipes` - a coroutine library'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Questions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem `pipes` solves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[How `pipes` works]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theory behind `pipes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tour of the `pipes` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Producer`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`stdinLn`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`for`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`runEffect`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Questions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem `pipes` solves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How `pipes` works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Theory behind `pipes`]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tour of the `pipes` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes Haskell unique?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Design patterns are inspired by category theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Theory is culturally enshrined in type classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Monoid`, `Category`, `Applicative`, `Monad`, ...'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goal:** reduce software complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/445bc2979c85c4ae25ee0ace2d831bcb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How do we reduce complexity?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`yield`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Producer` that `yield`s exactly one element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Producer` that `yield`s more than one element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Producer` that `yield`s less than one element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Primitive vs. Derived
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`(>>)` and `return ()` form a Monoid'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Categories generalize Monoids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`(>=>)` and `return` form a Category'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Monad Laws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Left identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`(~>)` and `yield` form a Category'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`for` loop laws - Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`for` loop laws - Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Reduce the complexity of coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Questions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem `pipes` solves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How `pipes` works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theory behind `pipes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Tour of the `pipes` API]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Consumer`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sink that changes over time
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`Consumer`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`await`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Consumer` that `await`s more than one element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Consumer` that `await`s zero elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Primitive vs. Derived
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`(>~)`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`(>~)` and `await` form a Category'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Questions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mix `Producer`s and `Consumer`s using `(>->)`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`Pipe`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Behavior switching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: What the types? - Part 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the deal?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: What the types? - Part 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Consumer` is special case of `Pipe`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`Producer` is (basically) a special case of `Pipe`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is "parametric polymorphism" (i.e. generics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is *not* ad-hoc polymorphism (i.e. type classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(>->)` and `cat` form a `Category`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: API inspired by category theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Composition | Identity |'
  prefs: []
  type: TYPE_TB
- en: '| :-: | :-: |'
  prefs: []
  type: TYPE_TB
- en: '| `(>=>)` | `return` |'
  prefs: []
  type: TYPE_TB
- en: '| `(~>)` | `yield` |'
  prefs: []
  type: TYPE_TB
- en: '| `(>~)` | `await` |'
  prefs: []
  type: TYPE_TB
- en: '| `(>->)` | `cat` |'
  prefs: []
  type: TYPE_TB
- en: 'This is just the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '**Goal:** Categorical semantics'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composability keeps software architectures flat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small amounts of theory go a very long way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise #1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement `takeWhile`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution #1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise #2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement `map`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution #2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise #3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What does `mystery` do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution #3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise #4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What does `mystery` do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution #4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise #5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement `grep`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution #5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
