["```\n% elm-repl\nElm REPL 0.4 <https://github.com/elm-lang/elm-repl#elm-repl>\nType :help for help, :exit to exit\n> \n```", "```\n> True\nTrue : Bool\n\n> False\nFalse : Bool\n\n> 'a'\n\"'a' : Char\n\n> \"abc\"\n\"abc\" : String\n\n> 3.0\n3 : Float \n```", "```\n> 3\n3 : number \n```", "```\n> truncate 3\n3 : Int\n\n> truncate 3.0\n3 : Int \n```", "```\n> (True, False)\n(True,False) : ( Bool, Bool )\n\n> (1, 2, 3.0)\n(1,2,3) : ( number, number, Float ) \n```", "```\n> (\"Leave me alone!\")\n\"Leave me alone!\" : String\n\n> ((((((\"Leave me alone!\"))))))\n\"Leave me alone!\" : String \n```", "```\n> exclaim = \\s -> s ++ \"!\"\n<function> : String -> String\n\n> exclaim s = s ++ \"!\"\n<function> : String -> String\n\n> exclaim \"Hi\"\n\"Hi!\" : String \n```", "```\n> plus (x,y) = x + y\n<function> : ( number, number ) -> number\n\n> plus = \\(x,y) -> x + y\n<function> : ( number, number ) -> number\n\n> plus xy = fst xy + snd xy\n<function> : ( number, number ) -> number \n```", "```\n> plus x y = x + y\n<function> : number -> number -> number\n\n> plus x = \\y -> x + y\n<function> : number -> number -> number\n\n> plus = \\x -> \\y -> x + y\n<function> : number -> number -> number \n```", "```\n> plus7 = plus 7\n<function> : number -> number\n\n> plus7 1\n8 : number\n\n> plus7 11\n18 : number \n```", "```\n> toInt n = n // 1\n<function> : Int -> Int \n```", "```\n> plusInt x y = (toInt x) + y\n<function> : Int -> Int -> Int\n\n> plusInt x y = toInt (x + y)\n<function> : Int -> Int -> Int \n```", "```\nplus : number -> number -> number\nplus x y = x + y\n\nplusInt : Int -> Int -> Int\nplusInt x y = x + y \n```", "```\nplusInt : Int -> Int -> Int\nplusInt = plus \n```", "```\n> import IntroML\n\n> IntroML.plusInt 2 3\n5 : Int \n```", "```\n> import IntroML (plusInt)\n\n> plusInt 2 3\n5 : Int\n\n> IntroML.plus 2.0 3.0\n... Error: Could not find variable 'IntroML.plus'. ... \n```", "```\n> import IntroML (plusInt) \\\n| import IntroML\n\n> plusInt 2 3\n5 : Int\n\n> IntroML.plus 2.0 3.0\n5 : Float\n\n> IntroML.exclaim \"Whoa...\"\n\"Whoa...!\" : String \n```", "```\n> import IntroML (..)\n\n> (plusInt 2 3, exclaim \"Cool\")\n(5,\"Cool!\") : ( Int, String ) \n```", "```\n> import IntroML as M\n\n> M.plusInt 2 3\n5 : Int \n```", "```\n> if 1 == 1 then \"yes\" else \"no\"\n\"yes\" : String\n\n> if False then 1.0 else 1\n1 : Float \n```", "```\n> if | 1 == 1 -> 1.0 \\\n|    | 1 == 2 -> 1\n1 : Float \n```", "```\n> otherwise\nTrue : Bool\n\n> if | 1 == 1    -> 1.0 \\\n|    | otherwise -> 1\n1 : Float \n```", "```\n> if | 1 == 2 -> \"uh oh...\"\nError: Runtime error in module Repl (on line 5, column 3 to 27)\nNon-exhaustive pattern match in multi-way-if expression.\nIt is best to use 'otherwise' as the last branch of multi-way-if. \n```", "```\n> if | 1 == 1 -> 1 \\\n|    | 2 == 2 -> 2\n1 : number \n```", "```\n> choose b x y = if b then x else y\n<function> : Bool -> a -> a -> a \n```", "```\n> choose True True False      -- a instantiated to Bool\n> choose True \"a\" \"b\"         -- a instantiated to String\n> choose True 1.0 2.0         -- a instantiated to Float\n> choose True 1 2             -- a instantiated to number \n```", "```\nchoose [Bool] True False\nchoose [String] \"a\" \"b\"\nchoose [Float] 1.0 2.0\nchoose [number] 1 2 \n```", "```\nchoose : forall a. Bool -> a      -> a      -> a\n\nchoose [Bool]    : Bool -> Bool   -> Bool   -> Bool\nchoose [String]  : Bool -> String -> String -> String\nchoose [Float]   : Bool -> Float  -> Float  -> Float\nchoose [number]  : Bool -> number -> number -> number \n```", "```\nchoose : Bool -> b -> b -> b \n\nchoose : Bool -> c -> c -> c \n\nchoose : Bool -> thing -> thing -> thing \n```", "```\n> import IntroML\n\n> IntroML.choose\n<function> : Bool -> a -> a -> a \n```", "```\nchoose : Bool -> number -> number -> number \n```", "```\n> (<)\n<function> : comparable -> comparable -> Bool\n\n> 1 < 2\nTrue : Bool\n\n> 1 < 2.0\nTrue : Bool\n\n> \"a\" < \"ab\"\nTrue : Bool\n\n> (2, 1) < (1, 2)\nFalse : Bool\n\n> (1 // 1) < 2.0\n... Type mismatch ...\n\n> True < False\n... Looks like you want something comparable, but the only valid comparable\n    types are Int, Float, Char, String, lists, or tuples. ... \n```", "```\n> id1 (a) = (a)\ni<function> : a -> a\n\n> id2 (a,b) = (a,b)\n<function> : ( a, b ) -> ( a, b )\n\n> id3 (a,b,c) = (a,b,c)\n<function> : ( a, b, b ) -> ( a, b, b )\n\n> id4 (a,b,c,d) = (a,b,c,d)\n<function> : ( a, b, b, b ) -> ( a, b, b, b ) \n```", "```\nid5 : (t1,t2,t3,t4,t5) -> (t1,t2,t3,t4,t5)\nid5 (a,b,c,d,e) = (a,b,c,d,e) \n```", "```\n> import IntroML\n\n> IntroML.id5\n<function> : ( a, b, b, b, b ) -> ( a, b, b, b, b ) \n```", "```\n> IntroML.id5 ('a', \"b\", 1.0, 1, True)\n('a',\"b\",1,1,True) : ( Char, String, Float, number, Bool ) \n```", "```\n> import List ((::))\n\n> 1::2::3::4::[]\n[1,2,3,4] : List number\n\n> [1,2,3,4]\n[1,2,3,4] : List number \n```", "```\n> [1..6]\n[1[1,2,3,4,5,6] : List number\n\n> [1.0..6.0]\n[1,2,3,4,5,6] : List Float \n```", "```\n> ['a','b','c']\n['a','b','c'] : List Char\n\n> \"abc\"\n\"abc\" : String\n\n> ['a','b','c'] == \"abc\"\n... Type mismatch ... \n```", "```\n> len xs = case xs of \\\n|   x::xs -> 1 + len xs \\\n|   []    -> 0\n<function> : List a -> number\n\n> len [1..3]\n3 : number\n\n> len []\n0 : number \n```", "```\n> len xs = case xs of {_::xs -> 1 + len xs; [] -> 0}\n<function> : List a -> number\n\n> len [1..10]\n10 : number\n\n> len ['a','b','c'] \n```", "```\n> hd xs = case xs of \\\n|   x::_ -> x\n<function> : List a -> a\n\n> hd [0]\nhd 0 : number\n\n> hd []\nError: Runtime error in module Repl (between lines 4 and 5)\nNon-exhaustive pattern match in case-expression.\nMake sure your patterns cover every case! \n```", "```\n> import List ((::), filter, map, foldr, foldl)\n\n> filter\n<function: filter> : (a -> Bool) -> List a -> List a\n\n> filter (\\x -> x `rem` 2 == 0) [1..10]\n[2,4,6,8,10] : List Int\n\n> map\n<function: map> : (a -> b) -> List a -> List b\n\n> map (\\x -> x ^ 2) [1..10]\n[1,4,9,16,25,36,49,64,81,100] : List number\n\n> foldr\n<function: foldr> : (a -> b -> b) -> b -> List a -> b\n\n> foldr (\\x acc -> x :: acc) [] [1..10]\n[1,2,3,4,5,6,7,8,9,10] : List number\n\n> foldl\n<function: foldl> : (a -> b -> b) -> b -> List a -> b\n\n> foldl (\\x acc -> x :: acc) [] [1..10]\n[10,9,8,7,6,5,4,3,2,1] : List number \n```", "```\n> (::)\n<function> : a -> List a -> List a\n\n> foldl (\\x acc -> (::) x acc) [] [1..10]\n[10,9,8,7,6,5,4,3,2,1] : List number \n```", "```\n> foldl (::) [] [1..10]\n[10,9,8,7,6,5,4,3,2,1] : List number \n```", "```\n> type Diet = Herb | Carn | Omni | Other String\n\n> Carn\nCarn : Repl.Diet\n\n> Omni\nOmni : Repl.Diet\n\n> Other \"Lactose Intolerant\"\nOther (\"Lactose Intolerant\") : Repl.Diet \n```", "```\n> Other\n<function> : String -> Repl.Diet \n```", "```\n> diets = [Herb, Herb, Omni, Other \"Vegan\", Carn]\n[Herb,Herb,Omni,Other \"Vegan\",Carn] : List Repl.Diet \n```", "```\n> maybeHuman d = case d of \\\n|   Carn -> False \\\n|   _    -> True\n<function> : Repl.Diet -> Bool\n\n> List.map maybeHuman diets\n[True,True,True,True,False] : List Bool \n```", "```\n> type MaybeInt = YesInt Int | NoInt \n```", "```\n> hd xs = case xs of \\\n|   x::xs' -> YesInt x \\\n|   []     -> NoInt\n<function> : List Int -> Repl.MaybeInt\n\n> hd [1..4]\nYesInt 1 : Repl.MaybeInt\n\n> hd []\nNoInt : Repl.MaybeInt \n```", "```\n> type MaybeData a = YesData a | NoData \n```", "```\n> hd xs = case xs of \\\n|   x::_ -> YesData x \\\n|   []   -> NoData\n<function> : List a -> Repl.MaybeData a\n\n> hd ['a','b','c']\nYesData 'a' : Repl.MaybeData Char\n\n> hd [\"a\",\"b\",\"c\"]\nYesData 'a' : Repl.MaybeData String\n\n> hd [1..4]\nYesData 1 : Repl.MaybeData number\n\n> hd []\nNoData : Repl.MaybeData a \n```", "```\ntype Maybe a = Just a | Nothing \n```", "```\nplus3 a =\n  let b = a + 1 in\n  let c = b + 1 in\n  let d = c + 1 in\n    d \n```", "```\nplus3 a =\n  let b = a + 1\n      c = b + 1\n      d = c + 1\n  in\n    d \n```", "```\nplus3 a = a |> plus 1 |> plus 1 |> plus 1 \n```", "```\nplus3 = plus 1 << plus 1 << plus 1 \n```"]