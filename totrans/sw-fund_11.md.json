["```\n\n    With the Curry-Howard correspondence and its realization in Coq in\n    mind, we can now take a deeper look at induction principles.\n\n```", "```\n\n# Basics\n\n    Every time we declare a new Inductive datatype, Coq\n    automatically generates an *induction principle* for this type.\n    This induction principle is a theorem like any other: If t is\n    defined inductively, the corresponding induction principle is\n    called t_ind.  Here is the one for natural numbers:\n\n```", "```\n\n    The induction tactic is a straightforward wrapper that, at its\n    core, simply performs apply t_ind.  To see this more clearly,\n    let's experiment with directly using apply nat_ind, instead of\n    the induction tactic, to carry out some proofs.  Here, for\n    example, is an alternate proof of a theorem that we saw in the\n    [Basics](Basics.html) chapter.\n\n```", "```\n\n    This proof is basically the same as the earlier one, but a\n    few minor differences are worth noting.\n\n    First, in the induction step of the proof (the \"S\" case), we\n    have to do a little bookkeeping manually (the intros) that\n    induction does automatically.\n\n    Second, we do not introduce n into the context before applying\n    nat_ind \u2014 the conclusion of nat_ind is a quantified formula,\n    and apply needs this conclusion to exactly match the shape of\n    the goal state, including the quantifier.  By contrast, the\n    induction tactic works either with a variable in the context or\n    a quantified variable in the goal.\n\n    These conveniences make induction nicer to use in practice than\n    applying induction principles like nat_ind directly.  But it is\n    important to realize that, modulo these bits of bookkeeping,\n    applying nat_ind is what we are really doing. \n\n#### Exercise: 2 stars, optional (plus_one_r')\n\n    Complete this proof without using the induction tactic.\n\n```", "```\n\n    \u2610 \n\n    Coq generates induction principles for every datatype defined with\n    Inductive, including those that aren't recursive.  Although of\n    course we don't need induction to prove properties of\n    non-recursive datatypes, the idea of an induction principle still\n    makes sense for them: it gives a way to prove that a property\n    holds for all values of the type.\n\n    These generated principles follow a similar pattern. If we define\n    a type t with constructors c[1] ... cn, Coq generates a\n    theorem with this shape:\n\n```", "```\nInductive yesno : Type :=\n\u00a0\u00a0| yes : yesno\n\u00a0\u00a0| no : yesno.\n\nCheck yesno_ind.\n(*\u00a0===>\u00a0yesno_ind\u00a0:\u00a0forall\u00a0P\u00a0:\u00a0yesno\u00a0->\u00a0Prop, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\u00a0yes\u00a0\u00a0-> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\u00a0no\u00a0\u00a0-> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forall\u00a0y\u00a0:\u00a0yesno,\u00a0P\u00a0y\u00a0*)\n\n```", "```\nInductive rgb : Type :=\n\u00a0\u00a0| red : rgb\n\u00a0\u00a0| green : rgb\n\u00a0\u00a0| blue : rgb.\nCheck rgb_ind.\n\n```", "```\nInductive natlist : Type :=\n\u00a0\u00a0| nnil : natlist\n\u00a0\u00a0| ncons : nat \u2192 natlist \u2192 natlist.\n\nCheck natlist_ind.\n(*\u00a0===>\u00a0(modulo\u00a0a\u00a0little\u00a0variable\u00a0renaming) \u00a0\u00a0\u00a0natlist_ind\u00a0: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forall\u00a0P\u00a0:\u00a0natlist\u00a0->\u00a0Prop, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\u00a0nnil\u00a0\u00a0-> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(forall\u00a0(n\u00a0:\u00a0nat)\u00a0(l\u00a0:\u00a0natlist), \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\u00a0l\u00a0->\u00a0P\u00a0(ncons\u00a0n\u00a0l))\u00a0-> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forall\u00a0n\u00a0:\u00a0natlist,\u00a0P\u00a0n\u00a0*)\n\n```", "```\nInductive natlist1 : Type :=\n\u00a0\u00a0| nnil1 : natlist1\n\u00a0\u00a0| nsnoc1 : natlist1 \u2192 nat \u2192 natlist1.\n\n```", "```\nInductive byntree : Type :=\n\u00a0| bempty : byntree\n\u00a0| bleaf  : yesno \u2192 byntree\n\u00a0| nbranch : yesno \u2192 byntree \u2192 byntree \u2192 byntree.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ExSet_ind\u00a0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200P\u00a0:\u00a0ExSet\u00a0\u2192\u00a0Prop,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2200b\u00a0:\u00a0bool,\u00a0P\u00a0(con1\u00a0b))\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2200(n\u00a0:\u00a0nat)\u00a0(e\u00a0:\u00a0ExSet),\u00a0P\u00a0e\u00a0\u2192\u00a0P\u00a0(con2\u00a0n\u00a0e))\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200e\u00a0:\u00a0ExSet,\u00a0P\u00a0e\n\n    Give an Inductive definition of ExSet:\n\n```", "```\n\n    \u2610 \n\n# Polymorphism\n\n    Next, what about polymorphic datatypes?\n\n    The inductive definition of polymorphic lists\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list_ind\u00a0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200(X\u00a0:\u00a0Type)\u00a0(P\u00a0:\u00a0list\u00a0X\u00a0\u2192\u00a0Prop),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\u00a0[]\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2200(x\u00a0:\u00a0X)\u00a0(l\u00a0:\u00a0list\u00a0X),\u00a0P\u00a0l\u00a0\u2192\u00a0P\u00a0(x\u00a0::\u00a0l))\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200l\u00a0:\u00a0list\u00a0X,\u00a0P\u00a0l\n\n    Note that the *whole* induction principle is parameterized on\n    X.  That is, list_ind can be thought of as a polymorphic\n    function that, when applied to a type X, gives us back an\n    induction principle specialized to the type list X. \n\n#### Exercise: 1 star, optional (tree)\n\n    Write out the induction principle that Coq will generate for\n   the following datatype.  Compare your answer with what Coq\n   prints.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 1 star, optional (mytype)\n\n    Find an inductive definition that gives rise to the\n    following induction principle:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0foo_ind\u00a0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200(X\u00a0Y\u00a0:\u00a0Type)\u00a0(P\u00a0:\u00a0foo\u00a0X\u00a0Y\u00a0\u2192\u00a0Prop),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2200x\u00a0:\u00a0X,\u00a0P\u00a0(bar\u00a0X\u00a0Y\u00a0x))\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2200y\u00a0:\u00a0Y,\u00a0P\u00a0(baz\u00a0X\u00a0Y\u00a0y))\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2200f[1]\u00a0:\u00a0nat\u00a0\u2192\u00a0foo\u00a0X\u00a0Y,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2200n\u00a0:\u00a0nat,\u00a0P\u00a0(f[1]\u00a0n))\u00a0\u2192\u00a0P\u00a0(quux\u00a0X\u00a0Y\u00a0f[1]))\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200f[2]\u00a0:\u00a0foo\u00a0X\u00a0Y,\u00a0P\u00a0f[2]\n\n    \u2610 \n\n#### Exercise: 1 star, optional (foo')\n\n    Consider the following inductive definition:\n\n```", "```\n\n    What induction principle will Coq generate for foo'?  Fill\n   in the blanks, then check your answer with Coq.)\n\n```", "```\n\n# Induction Hypotheses\n\n    Where does the phrase \"induction hypothesis\" fit into this story?\n\n    The induction principle for numbers\n\n```", "```\nDefinition P_m0r (n:nat) : Prop :=\n\u00a0\u00a0n * 0 = 0.\n\n```", "```\nDefinition P_m0r' : nat\u2192Prop :=\n\u00a0\u00a0fun n \u21d2 n * 0 = 0.\n\n```", "```\nTheorem mult_0_r'' : \u2200n:nat,\n\u00a0\u00a0P_m0r n.\nProof.\n\u00a0\u00a0apply nat_ind.\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a0O\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a0S\u00a0n'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Note\u00a0the\u00a0proof\u00a0state\u00a0at\u00a0this\u00a0point!\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros n IHn.\n\u00a0\u00a0\u00a0\u00a0unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed.\n\n```", "```\n\n# More on the induction Tactic\n\n    The induction tactic actually does even more low-level\n    bookkeeping for us than we discussed above.\n\n    Recall the informal statement of the induction principle for\n    natural numbers:\n\n*   If P n is some proposition involving a natural number n, and we want to show that P holds for *all* numbers n, we can reason like this: \n\n    *   show that P O holds\n\n    *   show that, if P n' holds, then so does P (S n')\n\n    *   conclude that P n holds for all n.\n\n    So, when we begin a proof with intros n and then induction n,\n    we are first telling Coq to consider a *particular* n (by\n    introducing it into the context) and then telling it to prove\n    something about *all* numbers (by using induction).\n\n    What Coq actually does in this situation, internally, is to\n    \"re-generalize\" the variable we perform induction on.  For\n    example, in our original proof that plus is associative...\n\n```", "```\n\n    It also works to apply induction to a variable that is\n    quantified in the goal.\n\n```", "```\n\n    Note that induction n leaves m still bound in the goal \u2014\n    i.e., what we are proving inductively is a statement beginning\n    with \u2200 m.\n\n    If we do induction on a variable that is quantified in the goal\n    *after* some other quantifiers, the induction tactic will\n    automatically introduce the variables bound by these quantifiers\n    into the context.\n\n```", "```\n\n#### Exercise: 1 star, optional (plus_explicit_prop)\n\n    Rewrite both plus_assoc' and plus_comm' and their proofs in\n    the same style as mult_0_r'' above \u2014 that is, for each theorem,\n    give an explicit Definition of the proposition being proved by\n    induction, and state the theorem and proof in terms of this\n    defined proposition.\n\n```", "```\n\n    \u2610\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Inductive\u00a0ev\u00a0:\u00a0nat\u00a0\u2192\u00a0Prop\u00a0:=\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0ev_0\u00a0:\u00a0ev\u00a00\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0ev_SS\u00a0:\u00a0\u2200n\u00a0:\u00a0nat,\u00a0ev\u00a0n\u00a0\u2192\u00a0ev\u00a0(S\u00a0(S\u00a0n)).\n\n    ...to give rise to an induction principle that looks like this...\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200P\u00a0:\u00a0nat\u00a0\u2192\u00a0Prop,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0... \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200n\u00a0:\u00a0nat,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0even\u00a0n\u00a0\u2192\u00a0P\u00a0n\n\n    For this reason, Coq actually generates the following simplified\n    induction principle for ev:\n\n```", "```\n\n    In particular, Coq has dropped the evidence term E as a\n    parameter of the the proposition P. \n\n    In English, ev_ind says:\n\n*   Suppose, P is a property of natural numbers (that is, P n is a Prop for every n). To show that P n holds whenever n is even, it suffices to show: \n\n    *   P holds for 0, \n\n    *   for any n, if n is even and P holds for n, then P holds for S (S n).\n\n    As expected, we can apply ev_ind directly instead of using\n    induction.  For example, we can use it to show that ev' (the\n    slightly awkward alternate definition of evenness that we saw in\n    an exercise in the \u03bbchap{IndProp} chapter) is equivalent to the\n    cleaner inductive definition ev:\n\n```", "```\n\n    The precise form of an Inductive definition can affect the\n    induction principle Coq generates.\n\n    For example, in chapter [IndProp](IndProp.html), we defined \u2264 as:\n\n```", "```\n\n    This definition can be streamlined a little by observing that the\n    left-hand argument n is the same everywhere in the definition,\n    so we can actually make it a \"general parameter\" to the whole\n    definition, rather than an argument to each constructor.\n\n```", "```\n\n    The second one is better, even though it looks less symmetric.\n    Why?  Because it gives us a simpler induction principle.\n\n```", "```\n\n# Formal vs. Informal Proofs by Induction\n\n    Question: What is the relation between a formal proof of a\n    proposition P and an informal proof of the same proposition P?\n\n    Answer: The latter should *teach* the reader how to produce the\n    former.\n\n    Question: How much detail is needed??\n\n    Unfortunately, there is no single right answer; rather, there is a\n    range of choices.\n\n    At one end of the spectrum, we can essentially give the reader the\n    whole formal proof (i.e., the \"informal\" proof will amount to just\n    transcribing the formal one into words).  This may give the reader\n    the ability to reproduce the formal one for themselves, but it\n    probably doesn't *teach* them anything much.\n\n    At the other end of the spectrum, we can say \"The theorem is true\n   and you can figure out why for yourself if you think about it hard\n   enough.\"  This is also not a good teaching strategy, because often\n   writing the proof requires one or more significant insights into\n   the thing we're proving, and most readers will give up before they\n   rediscover all the same insights as we did.\n\n    In the middle is the golden mean \u2014 a proof that includes all of\n   the essential insights (saving the reader the hard work that we\n   went through to find the proof in the first place) plus high-level\n   suggestions for the more routine parts to save the reader from\n   spending too much time reconstructing these (e.g., what the IH says\n   and what must be shown in each case of an inductive proof), but not\n   so much detail that the main ideas are obscured.\n\n    Since we've spent much of this chapter looking \"under the hood\" at\n   formal proofs by induction, now is a good moment to talk a little\n   about *informal* proofs by induction.\n\n    In the real world of mathematical communication, written proofs\n   range from extremely longwinded and pedantic to extremely brief and\n   telegraphic.  Although the ideal is somewhere in between, while one\n   is getting used to the style it is better to start out at the\n   pedantic end.  Also, during the learning phase, it is probably\n   helpful to have a clear standard to compare against.  With this in\n   mind, we offer two templates \u2014 one for proofs by induction over\n   *data* (i.e., where the thing we're doing induction on lives in\n   Type) and one for proofs by induction over *evidence* (i.e.,\n   where the inductively defined thing lives in Prop). \n\n## Induction Over an Inductively Defined Set\n\n    *Template*:\n\n*   *Theorem*: <Universally quantified proposition of the form \"For all n:S, P(n),\" where S is some inductively defined set.> \n\n    *Proof*: By induction on n. \n\n     <one case for each constructor c of S...> \n\n    *   Suppose n = c a[1] ... ak, where <...and here we state the IH for each of the a's that has type S, if any>. We must show <...and here we restate P(c a[1] ... ak)>. \n\n         <go on and prove P(n) to finish the case...> \n\n    *   <other cases similarly...> \u2610\n\n    *Example*:\n\n*   *Theorem*: For all sets X, lists l : list X, and numbers n, if length l = n then index (S n) l = None. \n\n    *Proof*: By induction on l. \n\n    *   Suppose l = []. We must show, for all numbers n, that, if length [] = n, then index (S n) [] = None. \n\n         This follows immediately from the definition of index. \n\n    *   Suppose l = x :: l' for some x and l', where length l' = n' implies index (S n') l' = None, for any number n'. We must show, for all n, that, if length (x::l') = n then index (S n) (x::l') = None. \n\n         Let n be a number with length l = n. Since \n\n        ```", "```\n        \u00a0\u00a0index\u00a0(S\u00a0(length\u00a0l'))\u00a0l'\u00a0=\u00a0None.\n\n         But this follows directly from the induction hypothesis, picking n' to be length l'. \u2610\n        ```", "```\n\n## Induction Over an Inductively Defined Proposition\n\n    Since inductively defined proof objects are often called\n    \"derivation trees,\" this form of proof is also known as *induction on derivations*.\n\n    *Template*:\n\n*   *Theorem*: <Proposition of the form \"Q \u2192 P,\" where Q is some inductively defined proposition (more generally, \"For all x y z, Q x y z \u2192 P x y z\")> \n\n    *Proof*: By induction on a derivation of Q. <Or, more generally, \"Suppose we are given x, y, and z. We show that Q x y z implies P x y z, by induction on a derivation of Q x y z\"...> \n\n     <one case for each constructor c of Q...> \n\n    *   Suppose the final rule used to show Q is c. Then <...and here we state the types of all of the a's together with any equalities that follow from the definition of the constructor and the IH for each of the a's that has type Q, if there are any>. We must show <...and here we restate P>. \n\n         <go on and prove P to finish the case...> \n\n    *   <other cases similarly...> \u2610\n\n    *Example* \n\n*   *Theorem*: The \u2264 relation is transitive \u2014 i.e., for all numbers n, m, and o, if n \u2264 m and m \u2264 o, then n \u2264 o. \n\n    *Proof*: By induction on a derivation of m \u2264 o. \n\n    *   Suppose the final rule used to show m \u2264 o is le_n. Then m = o and we must show that n \u2264 m, which is immediate by hypothesis. \n\n    *   Suppose the final rule used to show m \u2264 o is le_S. Then o = S o' for some o' with m \u2264 o'. We must show that n \u2264 S o'. By induction hypothesis, n \u2264 o'. \n\n         But then, by le_S, n \u2264 S o'. \u2610\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]