["```\n\n```", "```\n\n    Coq comes with a set of builtin tactics, such as reflexivity,\n    intros, inversion and so on. While it is possible to conduct\n    proofs using only those tactics, you can significantly increase\n    your productivity by working with a set of more powerful tactics.\n    This chapter describes a number of such useful tactics, which, for\n    various reasons, are not yet available by default in Coq.  These\n    tactics are defined in the LibTactics.v file.\n\n```", "```\n\n    Remark: SSReflect is another package providing powerful tactics.\n    The library \"LibTactics\" differs from \"SSReflect\" in two respects:\n\n*   \"SSReflect\" was primarily developed for proving mathematical theorems, whereas \"LibTactics\" was primarily developed for proving theorems on programming languages. In particular, \"LibTactics\" provides a number of useful tactics that have no counterpart in the \"SSReflect\" package.\n\n*   \"SSReflect\" entirely rethinks the presentation of tactics, whereas \"LibTactics\" mostly stick to the traditional presentation of Coq tactics, simply providing a number of additional tactics. For this reason, \"LibTactics\" is probably easier to get started with than \"SSReflect\".\n\n    This chapter is a tutorial focusing on the most useful features\n    from the \"LibTactics\" library. It does not aim at presenting all\n    the features of \"LibTactics\". The detailed specification of tactics\n    can be found in the source file LibTactics.v. Further documentation\n    as well as demos can be found at [http://www.chargueraud.org/softs/tlc/](http://www.chargueraud.org/softs/tlc/). \n\n    In this tutorial, tactics are presented using examples taken from\n    the core chapters of the \"Software Foundations\" course. To illustrate\n    the various ways in which a given tactic can be used, we use a\n    tactic that duplicates a given goal. More precisely, dup produces\n    two copies of the current goal, and dup n produces n copies of it.\n\n```", "```\n\n## The Tactic introv\n\n```", "```\n\n    The tactic introv allows to automatically introduce the\n    variables of a theorem and explicitly name the hypotheses\n    involved. In the example shown next, the variables c,\n    st, st[1] and st[2] involved in the statement of determinism\n    need not be named explicitly, because their name where already\n    given in the statement of the lemma. On the contrary, it is\n    useful to provide names for the two hypotheses, which we\n    name E[1] and E[2], respectively.\n\n```", "```\n\n    When there is no hypothesis to be named, one can call\n    introv without any argument.\n\n```", "```\n\n    The tactic introv also applies to statements in which\n    \u2200 and \u2192 are interleaved.\n\n```", "```\n\n    Like the arguments of intros, the arguments of introv\n    can be structured patterns.\n\n```", "```\n\n    Remark: the tactic introv works even when definitions\n    need to be unfolded in order to reveal hypotheses.\n\n```", "```\n\n## The Tactic inverts\n\n```", "```\n\n    The inversion tactic of Coq is not very satisfying for\n    three reasons. First, it produces a bunch of equalities\n    which one typically wants to substitute away, using subst.\n    Second, it introduces meaningless names for hypotheses.\n    Third, a call to inversion H does not remove H from the\n    context, even though in most cases an hypothesis is no longer\n    needed after being inverted. The tactic inverts address all\n    of these three issues. It is intented to be used in place of\n    the tactic inversion. \n\n    The following example illustrates how the tactic inverts H\n    behaves mostly like inversion H except that it performs\n    some substitutions in order to eliminate the trivial equalities\n    that are being produced by inversion.\n\n```", "```\n\n    A slightly more interesting example appears next.\n\n```", "```\n\n    The tactic inverts H as. is like inverts H except that the\n    variables and hypotheses being produced are placed in the goal\n    rather than in the context. This strategy allows naming those\n    new variables and hypotheses explicitly, using either intros\n    or introv.\n\n```", "```\n\n    In the particular case where a call to inversion produces\n    a single subgoal, one can use the syntax inverts H as H[1] H[2] H[3]\n    for calling inverts and naming the new hypotheses H[1], H[2]\n    and H[3]. In other words, the tactic inverts H as H[1] H[2] H[3] is\n    equivalent to inverts H as; introv H[1] H[2] H[3]. An example follows.\n\n```", "```\n\n    A more involved example appears next. In particular, this example\n    shows that the name of the hypothesis being inverted can be reused.\n\n```", "```\n\n    Note: in the rare cases where one needs to perform an inversion\n    on an hypothesis H without clearing H from the context,\n    one can use the tactic inverts keep H, where the keyword keep\n    indicates that the hypothesis should be kept in the context.\n\n```", "```\nModule NaryExamples.\n\u00a0\u00a0Require Import References.\n\u00a0\u00a0Require Import Smallstep.\n\u00a0\u00a0Import STLCRef.\n\n```", "```\nLemma demo_splits : \u2200n m,\n\u00a0\u00a0n > 0 \u2227 n < m \u2227 m < n+10 \u2227 m \u2260 3.\nProof.\n\u00a0\u00a0intros. splits.\nAbort.\n\n```", "```\nLemma demo_branch : \u2200n m,\n\u00a0\u00a0n < m \u2228 n = m \u2228 m < n.\nProof.\n\u00a0\u00a0intros.\n\u00a0\u00a0destruct (lt_eq_lt_dec n m) as [[H[1]|H[2]]|H[3]].\n\u00a0\u00a0- branch 1\\. apply H[1].\n\u00a0\u00a0- branch 2\\. apply H[2].\n\u00a0\u00a0- branch 3\\. apply H[3].\nQed.\n\n```", "```\nTheorem progress : \u2200ST t T st,\n\u00a0\u00a0has_type empty ST t T \u2192\n\u00a0\u00a0store_well_typed ST st \u2192\n\u00a0\u00a0value t \u2228 \u2203t' st', t / st \u21d2 t' / st'.\n\u00a0\u00a0(*\u00a0was:\u00a0value t \u2228 \u2203 t', \u2203 st', t / st \u21d2 t' / st'\u00a0*)\nProof with eauto.\n\u00a0\u00a0intros ST t T st Ht HST. remember (@empty ty) as \u0393.\n\u00a0\u00a0(induction Ht); subst; try solve_by_invert...\n\u00a0\u00a0- (*\u00a0T_App\u00a0*)\n\u00a0\u00a0\u00a0\u00a0right. destruct IHHt1 as [Ht1p | Ht1p]...\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0t[1]\u00a0is\u00a0a\u00a0value\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion Ht1p; subst; try solve_by_invert.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct IHHt2 as [Ht2p | Ht2p]...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(*\u00a0t[2]\u00a0steps\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion Ht2p as [t[2]' [st' Hstep]].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2203(tapp (tabs x T t) t[2]') st'...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(*\u00a0was:\u00a0\u2203 (tapp (tabs x T t) t[2]'). \u2203 st'...\u00a0*)\nAbort.\n\n```", "```\nEnd NaryExamples.\n\n```", "```\nModule EqualityExamples.\n\n```", "```\nTheorem mult_0_plus : \u2200n m : nat,\n\u00a0\u00a0(0 + n) * m = n * m.\nProof.\n\u00a0\u00a0dup.\n\u00a0\u00a0(*\u00a0The\u00a0old\u00a0proof:\u00a0*)\n\u00a0\u00a0intros n m.\n\u00a0\u00a0assert (H: 0 + n = n). reflexivity. rewrite \u2192 H.\n\u00a0\u00a0reflexivity.\n\n\u00a0\u00a0(*\u00a0The\u00a0new\u00a0proof:\u00a0*)\n\u00a0\u00a0intros n m.\n\u00a0\u00a0asserts_rewrite (0 + n = n).\n\u00a0\u00a0\u00a0\u00a0reflexivity. (*\u00a0subgoal\u00a00+n = n\u00a0*)\n\u00a0\u00a0\u00a0\u00a0reflexivity. (*\u00a0subgoal\u00a0n*m = m*n\u00a0*)\nQed.\n\n(***\u00a0Remark:\u00a0the\u00a0syntax\u00a0asserts_rewrite (E[1] = E[2]) in H\u00a0allows \u00a0\u00a0\u00a0\u00a0\u00a0rewriting\u00a0in\u00a0the\u00a0hypothesis\u00a0H\u00a0rather\u00a0than\u00a0in\u00a0the\u00a0goal.\u00a0*)\n\n```", "```\nTheorem mult_0_plus' : \u2200n m : nat,\n\u00a0\u00a0(0 + n) * m = n * m.\nProof.\n\u00a0\u00a0intros n m.\n\u00a0\u00a0cuts_rewrite (0 + n = n).\n\u00a0\u00a0\u00a0\u00a0reflexivity. (*\u00a0subgoal\u00a0n*m = m*n\u00a0*)\n\u00a0\u00a0\u00a0\u00a0reflexivity. (*\u00a0subgoal\u00a00+n = n\u00a0*)\nQed.\n\n```", "```\nTheorem mult_0_plus'' : \u2200u v w x y z: nat,\n\u00a0\u00a0(u + v) * (S (w * x + y)) = z.\nProof.\n\u00a0\u00a0intros. asserts_rewrite (\u2200a b, a*(S b) = a*b+a).\n\u00a0\u00a0\u00a0\u00a0(*\u00a0first\u00a0subgoal:\u00a0\u00a0\u2200 a b, a*(S b) = a*b+a\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0second\u00a0subgoal:\u00a0(u + v) * (w * x + y) + (u + v) = z\u00a0*)\nAbort.\n\n```", "```\nLemma demo_substs : \u2200x y (f:nat\u2192nat),\n\u00a0\u00a0x = f x \u2192 y = x \u2192 y = f x.\nProof.\n\u00a0\u00a0intros. substs. (*\u00a0the\u00a0tactic\u00a0subst\u00a0would\u00a0fail\u00a0here\u00a0*)\n\u00a0\u00a0assumption.\nQed.\n\n```", "```\nLemma demo_fequals : \u2200(a b c d e : nat) (f : nat\u2192nat\u2192nat\u2192nat\u2192nat),\n\u00a0\u00a0a = 1 \u2192 b = e \u2192 e = 2 \u2192\n\u00a0\u00a0f a b c d = f 1 2 c 4.\nProof.\n\u00a0\u00a0intros. fequals.\n\u00a0\u00a0(*\u00a0subgoals\u00a0a = 1,\u00a0b = 2\u00a0and\u00a0c = c\u00a0are\u00a0proved,\u00a0d = 4\u00a0remains\u00a0*)\nAbort.\n\n```", "```\nAxiom big_expression_using : nat\u2192nat. (*\u00a0Used\u00a0in\u00a0the\u00a0example\u00a0*)\n\nLemma demo_applys_eq_1 : \u2200(P:nat\u2192nat\u2192Prop) x y z,\n\u00a0\u00a0P x (big_expression_using z) \u2192\n\u00a0\u00a0P x (big_expression_using y).\nProof.\n\u00a0\u00a0introv H. dup.\n\n\u00a0\u00a0(*\u00a0The\u00a0old\u00a0proof:\u00a0*)\n\u00a0\u00a0assert (Eq: big_expression_using y = big_expression_using z).\n\u00a0\u00a0\u00a0\u00a0admit. (*\u00a0Assume\u00a0we\u00a0can\u00a0prove\u00a0this\u00a0equality\u00a0somehow.\u00a0*)\n\u00a0\u00a0rewrite Eq. apply H.\n\n\u00a0\u00a0(*\u00a0The\u00a0new\u00a0proof:\u00a0*)\n\u00a0\u00a0applys_eq H 1.\n\u00a0\u00a0\u00a0\u00a0admit. (*\u00a0Assume\u00a0we\u00a0can\u00a0prove\u00a0this\u00a0equality\u00a0somehow.\u00a0*)\nAbort.\n\n```", "```\nLemma demo_applys_eq_2 : \u2200(P:nat\u2192nat\u2192Prop) x y z,\n\u00a0\u00a0P (big_expression_using z) x \u2192\n\u00a0\u00a0P (big_expression_using y) x.\nProof.\n\u00a0\u00a0introv H. applys_eq H 2.\nAbort.\n\n```", "```\nLemma demo_applys_eq_3 : \u2200(P:nat\u2192nat\u2192Prop) x[1] x[2] y[1] y[2],\n\u00a0\u00a0P (big_expression_using x[2]) (big_expression_using y[2]) \u2192\n\u00a0\u00a0P (big_expression_using x[1]) (big_expression_using y[1]).\nProof.\n\u00a0\u00a0introv H. applys_eq H 1 2.\n\u00a0\u00a0(*\u00a0produces\u00a0two\u00a0subgoals: \u00a0\u00a0\u00a0\u00a0\u00a0big_expression_using x[1] = big_expression_using x[2] \u00a0\u00a0\u00a0\u00a0\u00a0big_expression_using y[1] = big_expression_using y[2]\u00a0*)\nAbort.\n\nEnd EqualityExamples.\n\n```", "```\n\n## The Tactic unfolds\n\n```", "```\n\n    The tactic unfolds (without any argument) unfolds the\n    head constant of the goal. This tactic saves the need to\n    name the constant explicitly.\n\n```", "```\n\n    Remark: contrary to the tactic hnf, which may unfold several\n    constants, unfolds performs only a single step of unfolding. \n\n    Remark: the tactic unfolds in H can be used to unfold the\n    head definition of the hypothesis H.\n\n```", "```\n\n## The Tactics false and tryfalse\n\n    The tactic false can be used to replace any goal with False.\n    In short, it is a shorthand for exfalso.\n    Moreover, false proves the goal if it contains an absurd\n    assumption, such as False or 0 = S n, or if it contains\n    contradictory assumptions, such as x = true and x = false.\n\n```", "```\n\n    The tactic false can be given an argument: false H replace\n    the goals with False and then applies H.\n\n```", "```\n\n    The tactic tryfalse is a shorthand for try solve [false]:\n    it tries to find a contradiction in the goal. The tactic\n    tryfalse is generally called after a case analysis.\n\n```", "```\n\n## The Tactic gen\n\n    The tactic gen is a shortand for generalize dependent\n    that accepts several arguments at once. An invokation of\n    this tactic takes the form gen x y z.\n\n```", "```\n\n## The Tactics skip, skip_rewrite and skip_goal\n\n    Temporarily admitting a given subgoal is very useful when\n    constructing proofs. It gives the ability to focus first\n    on the most interesting cases of a proof. The tactic skip\n    is like admit except that it also works when the proof\n    includes existential variables. Recall that existential\n    variables are those whose name starts with a question mark,\n    (e.g., ?24), and which are typically introduced by eapply.\n\n```", "```\n\n    The tactic skip H: P adds the hypothesis H: P to the context,\n    without checking whether the proposition P is true.\n    It is useful for exploiting a fact and postponing its proof.\n    Note: skip H: P is simply a shorthand for assert (H:P). skip.\n\n```", "```\n\n    The tactic skip_rewrite (E[1] = E[2]) replaces E[1] with E[2] in\n    the goal, without checking that E[1] is actually equal to E[2].\n\n```", "```\n\n    Remark: the tactic skip_rewrite can in fact be given a lemma\n    statement as argument, in the same way as asserts_rewrite. \n\n    The tactic skip_goal adds the current goal as hypothesis.\n    This cheat is useful to set up the structure of a proof by\n    induction without having to worry about the induction hypothesis\n    being applied only to smaller arguments. Using skip_goal, one\n    can construct a proof in two steps: first, check that the main\n    arguments go through without waisting time on fixing the details\n    of the induction hypotheses; then, focus on fixing the invokations\n    of the induction hypothesis.\n\n```", "```\n\n## The Tactic sort\n\n```", "```\n\n    The tactic sort reorganizes the proof context by placing\n    all the variables at the top and all the hypotheses at the\n    bottom, thereby making the proof context more readable.\n\n```", "```\n\n# Tactics for Advanced Lemma Instantiation\n\n    This last section describes a mechanism for instantiating a lemma\n    by providing some of its arguments and leaving other implicit.\n    Variables whose instantiation is not provided are turned into\n    existentential variables, and facts whose instantiation is not\n    provided are turned into subgoals.\n\n    Remark: this instantion mechanism goes far beyond the abilities of\n    the \"Implicit Arguments\" mechanism. The point of the instantiation\n    mechanism described in this section is that you will no longer need\n    to spend time figuring out how many underscore symbols you need to\n    write. \n\n    In this section, we'll use a useful feature of Coq for decomposing\n    conjunctions and existentials. In short, a tactic like intros or\n    destruct can be provided with a pattern (H[1] & H[2] & H[3] & H[4] & H[5]),\n    which is a shorthand for [H[1] [H[2] [H[3] [H[4] H[5]]]]]]. For example,\n    destruct (H _ _ _ Htypt) as [T [Hctx Hsub]]. can be rewritten in\n    the form destruct (H _ _ _ Htypt) as (T & Hctx & Hsub).\n\n```", "```\nModule ExamplesLets.\n\u00a0\u00a0Require Import Sub.\n\n(*\u00a0To\u00a0illustrate\u00a0the\u00a0working\u00a0of\u00a0lets,\u00a0assume\u00a0that\u00a0we\u00a0want\u00a0to \u00a0\u00a0\u00a0exploit\u00a0the\u00a0following\u00a0lemma.\u00a0*)\n\nAxiom typing_inversion_var : \u2200(G:context) (x:id) (T:ty),\n\u00a0\u00a0has_type G (tvar x) T \u2192\n\u00a0\u00a0\u2203S, G x = Some S \u2227 subtype S T.\n\n```", "```\nLemma demo_lets_1 : \u2200(G:context) (x:id) (T:ty),\n\u00a0\u00a0has_type G (tvar x) T \u2192 True.\nProof.\n\u00a0\u00a0intros G x T H. dup.\n\n\u00a0\u00a0(*\u00a0step-by-step:\u00a0*)\n\u00a0\u00a0lets K: typing_inversion_var H.\n\u00a0\u00a0destruct K as (S & Eq & Sub).\n\u00a0\u00a0admit.\n\n\u00a0\u00a0(*\u00a0all-at-once:\u00a0*)\n\u00a0\u00a0lets (S & Eq & Sub): typing_inversion_var H.\n\u00a0\u00a0admit.\nAbort.\n\n```", "```\nLemma demo_lets_2 : \u2200(G:context) (x:id) (T:ty), True.\nProof.\n\u00a0\u00a0intros G x T.\n\u00a0\u00a0lets (S & Eq & Sub): typing_inversion_var G x T ___.\nAbort.\n\n```", "```\nLemma demo_lets_3 : \u2200(x:id), True.\nProof.\n\u00a0\u00a0intros x.\n\u00a0\u00a0lets (S & Eq & Sub): typing_inversion_var x ___.\nAbort.\n\n```", "```\nLemma demo_lets_4 : True.\nProof.\n\u00a0\u00a0lets (S & Eq & Sub): typing_inversion_var ___.\nAbort.\n\n```", "```\nLemma demo_lets_5 : True.\nProof.\n\u00a0\u00a0lets H: typing_inversion_var.\nAbort.\n\n```", "```\nLemma demo_lets_underscore :\n\u00a0\u00a0(\u2200n m, n \u2264 m \u2192 n < m+1) \u2192 True.\nProof.\n\u00a0\u00a0intros H.\n\n\u00a0\u00a0(*\u00a0If\u00a0we\u00a0do\u00a0not\u00a0use\u00a0a\u00a0double\u00a0underscore,\u00a0the\u00a0first\u00a0argument, \u00a0\u00a0\u00a0\u00a0\u00a0which\u00a0is\u00a0n,\u00a0gets\u00a0instantiated\u00a0as\u00a03.\u00a0*)\n\u00a0\u00a0lets K: H 3\\. (*\u00a0gives\u00a0K\u00a0of\u00a0type\u00a0\u2200 m, 3 \u2264 m \u2192 3 < m+1\u00a0*)\n\u00a0\u00a0\u00a0\u00a0clear K.\n\n\u00a0\u00a0(*\u00a0The\u00a0double\u00a0underscore\u00a0preceeding\u00a03\u00a0indicates\u00a0that\u00a0we\u00a0want \u00a0\u00a0\u00a0\u00a0\u00a0to\u00a0skip\u00a0a\u00a0value\u00a0that\u00a0has\u00a0the\u00a0type\u00a0nat\u00a0(because\u00a03\u00a0has \u00a0\u00a0\u00a0\u00a0\u00a0the\u00a0type\u00a0nat).\u00a0So,\u00a0the\u00a0variable\u00a0m\u00a0gets\u00a0instiated\u00a0as\u00a03.\u00a0*)\n\u00a0\u00a0lets K: H __ 3\\. (*\u00a0gives\u00a0K\u00a0of\u00a0type\u00a0?X \u2264 3 \u2192 ?X < 3+1\u00a0*)\n\u00a0\u00a0\u00a0\u00a0clear K.\nAbort.\n\n```", "```\nEnd ExamplesLets.\n\n```", "```\n\n## Example of Instantiations\n\n```", "```\n\n    The following proof shows several examples where lets is used\n    instead of destruct, as well as examples where applys is used\n    instead of apply. The proof also contains some holes that you\n    need to fill in as an exercise.\n\n```", "```\n\n# Summary\n\n    In this chapter we have presented a number of tactics that help make\n    proof script more concise and more robust on change.\n\n*   introv and inverts improve naming and inversions. \n\n*   false and tryfalse help discarding absurd goals. \n\n*   unfolds automatically calls unfold on the head definition. \n\n*   gen helps setting up goals for induction. \n\n*   cases and cases_if help with case analysis. \n\n*   splits, branch and \u2203 to deal with n-ary constructs. \n\n*   asserts_rewrite, cuts_rewrite, substs and fequals help working with equalities. \n\n*   lets, forwards, specializes and applys provide means of very conveniently instantiating lemmas. \n\n*   applys_eq can save the need to perform manual rewriting steps before being able to apply lemma. \n\n*   skip, skip_rewrite and skip_goal give the flexibility to choose which subgoals to try and discharge first.\n\n    Making use of these tactics can boost one's productivity in Coq proofs.\n\n    If you are interested in using LibTactics.v in your own developments,\n    make sure you get the lastest version from:\n    [http://www.chargueraud.org/softs/tlc/](http://www.chargueraud.org/softs/tlc/).\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]