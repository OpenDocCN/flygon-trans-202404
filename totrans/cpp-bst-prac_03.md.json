["```\nstruct Size\n{\n  int width;\n  int height;\n\n  Size(int t_width, int t_height) : width(t_width), height(t_height) {}\n};\n\n// This version might make sense for thread safety or something,\n// but more to the point, sometimes we need to hide data, sometimes we don't.\nclass PrivateSize\n{\n  public:\n    int width() const { return m_width; }\n    int height() const { return m_height; }\n    PrivateSize(int t_width, int t_height) : m_width(t_width), m_height(t_height) {}\n\n  private:\n    int m_width;\n    int m_height;\n}; \n```", "```\nclass MyClass\n{\npublic:\n  MyClass(int t_data)\n    : m_data(t_data)\n  {\n  }\n\n  int getData() const {\n    return m_data;\n  }\n\nprivate:\n  int m_data;\n}; \n```", "```\n// this function does something\nint myFunc() {\n} \n```", "```\n/*\n// this function does something\nint myFunc()\n{\n}\n*/ \n```", "```\n#ifndef MYPROJECT_MYCLASS_HPP\n#define MYPROJECT_MYCLASS_HPP\n\nnamespace MyProject {\n  class MyClass {\n  };\n}\n\n#endif \n```", "```\n// Bad Idea\n// This compiles and does what you want, but can lead to confusing\n// errors if modification are made in the future and close attention\n// is not paid.\nfor (int i = 0; i < 15; ++i)\n  std::cout << i << std::endl;\n\n// Bad Idea\n// The cout is not part of the loop in this case even though it appears to be.\nint sum = 0;\nfor (int i = 0; i < 15; ++i)\n  ++sum;\n  std::cout << i << std::endl;\n\n// Good Idea\n// It's clear which statements are part of the loop (or if block, or whatever).\nint sum = 0;\nfor (int i = 0; i < 15; ++i) {\n  ++sum;\n  std::cout << i << std::endl;\n} \n```", "```\n// Bad Idea\n// hard to follow\nif (x && y && myFunctionThatReturnsBool() && caseNumber3 && (15 > 12 || 2 < 3)) {\n}\n\n// Good Idea\n// Logical grouping, easier to read\nif (x && y && myFunctionThatReturnsBool()\n    && caseNumber3\n    && (15 > 12 || 2 < 3)) {\n} \n```", "```\n// Bad Idea. Requires extra -I directives to the compiler\n// and goes against standards.\n#include <string>\n#include <includes/MyHeader.hpp>\n\n// Worse Idea\n// Requires potentially even more specific -I directives and\n// makes code more difficult to package and distribute.\n#include <string>\n#include <MyHeader.hpp>\n\n// Good Idea\n// Requires no extra params and notifies the user that the file\n// is a local file.\n#include <string>\n#include \"MyHeader.hpp\" \n```", "```\n// Bad Idea\nclass MyClass\n{\npublic:\n  MyClass(int t_value)\n  {\n    m_value = t_value;\n  }\n\nprivate:\n  int m_value;\n};\n\n// Bad Idea\n// This leads to an additional constructor call for m_myOtherClass\n// before the assignment.\nclass MyClass\n{\npublic:\n  MyClass(MyOtherClass t_myOtherClass)\n  {\n    m_myOtherClass = t_myOtherClass;\n  }\n\nprivate:\n  MyOtherClass m_myOtherClass;\n};\n\n// Good Idea\n// There is no performance gain here but the code is cleaner.\nclass MyClass\n{\npublic:\n  MyClass(int t_value)\n    : m_value(t_value)\n  {\n  }\n\nprivate:\n  int m_value;\n};\n\n// Good Idea\n// The default constructor for m_myOtherClass is never called here, so \n// there is a performance gain if MyOtherClass is not is_trivially_default_constructible. \nclass MyClass\n{\npublic:\n  MyClass(MyOtherClass t_myOtherClass)\n    : m_myOtherClass(t_myOtherClass)\n  {\n  }\n\nprivate:\n  MyOtherClass m_myOtherClass;\n}; \n```", "```\n// ... //\nprivate:\n  int m_value = 0; // allowed\n  unsigned m_value_2 = -1; // narrowing from signed to unsigned allowed\n// ... // \n```", "```\n// Best Idea\n\n// ... //\nprivate:\n  int m_value{ 0 }; // allowed\n  unsigned m_value_2 { -1 }; // narrowing from signed to unsigned not allowed, leads to a compile time error\n// ... // \n```", "```\nclass MyClass\n{\npublic:\n  MyClass(int t_value)\n    : m_value{t_value}\n  {\n  }\n\nprivate:\n  const int m_value{0};\n}; \n```", "```\nstd::vector<int> v1{2,3,4,5,6,7,8,9};\nstd::vector<int> v2{9,8,7,6,5,4,3,2,1};\nconst auto s1 = v1.size();\nconst auto s2 = v2.size();\nconst auto diff = s1 - s2; // diff underflows to a very large number \n```", "```\nassert(registerSomeThing()); // make sure that registerSomeThing() returns true \n```", "```\n//bad idea\nstruct S {\n  operator int() {\n    return 2;\n  }\n}; \n```", "```\n//good idea\nstruct S {\n  explicit operator int() {\n    return 2;\n  }\n}; \n```"]