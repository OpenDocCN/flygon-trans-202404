["```\n/// ExprAST - Base class for all expression nodes.\nclass ExprAST {\npublic:\n  virtual ~ExprAST() {}\n  virtual Value *Codegen() = 0;\n};\n\n/// NumberExprAST - Expression class for numeric literals like \"1.0\".\nclass NumberExprAST : public ExprAST {\n  double Val;\npublic:\n  NumberExprAST(double val) : Val(val) {}\n  virtual Value *Codegen();\n};\n... \n```", "```\nValue *ErrorV(const char *Str) { Error(Str); return 0; }\n\nstatic Module *TheModule;\nstatic IRBuilder<> Builder(getGlobalContext());\nstatic std::map<std::string, Value*> NamedValues; \n```", "```\nValue *NumberExprAST::Codegen() {\n  return ConstantFP::get(getGlobalContext(), APFloat(Val));\n} \n```", "```\nValue *VariableExprAST::Codegen() {\n  // Look this variable up in the function.\n  Value *V = NamedValues[Name];\n  return V ? V : ErrorV(\"Unknown variable name\");\n} \n```", "```\nValue *BinaryExprAST::Codegen() {\n  Value *L = LHS->Codegen();\n  Value *R = RHS->Codegen();\n  if (L == 0 || R == 0) return 0;\n\n  switch (Op) {\n  case '+': return Builder.CreateFAdd(L, R, \"addtmp\");\n  case '-': return Builder.CreateFSub(L, R, \"subtmp\");\n  case '*': return Builder.CreateFMul(L, R, \"multmp\");\n  case '<':\n    L = Builder.CreateFCmpULT(L, R, \"cmptmp\");\n    // Convert bool 0/1 to double 0.0 or 1.0\n    return Builder.CreateUIToFP(L, Type::getDoubleTy(getGlobalContext()),\n                                \"booltmp\");\n  default: return ErrorV(\"invalid binary operator\");\n  }\n} \n```", "```\nValue *CallExprAST::Codegen() {\n  // Look up the name in the global module table.\n  Function *CalleeF = TheModule->getFunction(Callee);\n  if (CalleeF == 0)\n    return ErrorV(\"Unknown function referenced\");\n\n  // If argument mismatch error.\n  if (CalleeF->arg_size() != Args.size())\n    return ErrorV(\"Incorrect # arguments passed\");\n\n  std::vector<Value*> ArgsV;\n  for (unsigned i = 0, e = Args.size(); i != e; ++i) {\n    ArgsV.push_back(Args[i]->Codegen());\n    if (ArgsV.back() == 0) return 0;\n  }\n\n  return Builder.CreateCall(CalleeF, ArgsV, \"calltmp\");\n} \n```", "```\nFunction *PrototypeAST::Codegen() {\n  // Make the function type:  double(double,double) etc.\n  std::vector<Type*> Doubles(Args.size(),\n                             Type::getDoubleTy(getGlobalContext()));\n  FunctionType *FT = FunctionType::get(Type::getDoubleTy(getGlobalContext()),\n                                       Doubles, false);\n\n  Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule); \n```", "```\n// If F conflicted, there was already something named 'Name'.  If it has a\n// body, don't allow redefinition or reextern.\nif (F->getName() != Name) {\n  // Delete the one we just made and get the existing one.\n  F->eraseFromParent();\n  F = TheModule->getFunction(Name); \n```", "```\n // If F already has a body, reject this.\n  if (!F->empty()) {\n    ErrorF(\"redefinition of function\");\n    return 0;\n  }\n\n  // If F took a different number of args, reject.\n  if (F->arg_size() != Args.size()) {\n    ErrorF(\"redefinition of function with different # args\");\n    return 0;\n  }\n} \n```", "```\n // Set names for all arguments.\n  unsigned Idx = 0;\n  for (Function::arg_iterator AI = F->arg_begin(); Idx != Args.size();\n       ++AI, ++Idx) {\n    AI->setName(Args[Idx]);\n\n    // Add arguments to variable symbol table.\n    NamedValues[Args[Idx]] = AI;\n  }\n  return F;\n} \n```", "```\nFunction *FunctionAST::Codegen() {\n  NamedValues.clear();\n\n  Function *TheFunction = Proto->Codegen();\n  if (TheFunction == 0)\n    return 0; \n```", "```\n// Create a new basic block to start insertion into.\nBasicBlock *BB = BasicBlock::Create(getGlobalContext(), \"entry\", TheFunction);\nBuilder.SetInsertPoint(BB);\n\nif (Value *RetVal = Body->Codegen()) { \n```", "```\nif (Value *RetVal = Body->Codegen()) {\n  // Finish off the function.\n  Builder.CreateRet(RetVal);\n\n  // Validate the generated code, checking for consistency.\n  verifyFunction(*TheFunction);\n\n  return TheFunction;\n} \n```", "```\n // Error reading body, remove function.\n  TheFunction->eraseFromParent();\n  return 0;\n} \n```", "```\nextern foo(a b);     # ok, defines foo.\ndef foo(a b) c;      # error, 'c' is invalid.\ndef bar() foo(1, 2); # error, unknown function \"foo\" \n```", "```\nready> 4+5;\nRead top-level expression:\ndefine double @0() {\nentry:\n  ret double 9.000000e+00\n} \n```", "```\nready> def foo(a b) a*a + 2*a*b + b*b;\nRead function definition:\ndefine double @foo(double %a, double %b) {\nentry:\n  %multmp = fmul double %a, %a\n  %multmp1 = fmul double 2.000000e+00, %a\n  %multmp2 = fmul double %multmp1, %b\n  %addtmp = fadd double %multmp, %multmp2\n  %multmp3 = fmul double %b, %b\n  %addtmp4 = fadd double %addtmp, %multmp3\n  ret double %addtmp4\n} \n```", "```\nready> def bar(a) foo(a, 4.0) + bar(31337);\nRead function definition:\ndefine double @bar(double %a) {\nentry:\n  %calltmp = call double @foo(double %a, double 4.000000e+00)\n  %calltmp1 = call double @bar(double 3.133700e+04)\n  %addtmp = fadd double %calltmp, %calltmp1\n  ret double %addtmp\n} \n```", "```\nready> extern cos(x);\nRead extern:\ndeclare double @cos(double)\n\nready> cos(1.234);\nRead top-level expression:\ndefine double @1() {\nentry:\n  %calltmp = call double @cos(double 1.234000e+00)\n  ret double %calltmp\n} \n```", "```\nready> ^D\n; ModuleID = 'my cool jit'\n\ndefine double @0() {\nentry:\n  %addtmp = fadd double 4.000000e+00, 5.000000e+00\n  ret double %addtmp\n}\n\ndefine double @foo(double %a, double %b) {\nentry:\n  %multmp = fmul double %a, %a\n  %multmp1 = fmul double 2.000000e+00, %a\n  %multmp2 = fmul double %multmp1, %b\n  %addtmp = fadd double %multmp, %multmp2\n  %multmp3 = fmul double %b, %b\n  %addtmp4 = fadd double %addtmp, %multmp3\n  ret double %addtmp4\n}\n\ndefine double @bar(double %a) {\nentry:\n  %calltmp = call double @foo(double %a, double 4.000000e+00)\n  %calltmp1 = call double @bar(double 3.133700e+04)\n  %addtmp = fadd double %calltmp, %calltmp1\n  ret double %addtmp\n}\n\ndeclare double @cos(double)\n\ndefine double @1() {\nentry:\n  %calltmp = call double @cos(double 1.234000e+00)\n  ret double %calltmp\n} \n```"]