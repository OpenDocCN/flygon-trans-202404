- en: Chapter 11\. Exceptions and Conditions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。异常和条件
- en: '*Exceptions* and *conditions* provide the means for system and user code to
    signal, detect, and recover from errors that occur when a program is run.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常*和*条件*提供了系统和用户代码在运行程序时信号、检测和从错误中恢复的手段。'
- en: Exceptions are raised by the standard syntactic forms and procedures under a
    variety of circumstances, e.g., when the wrong number of arguments is passed to
    a procedure, when the syntax of an expression passed to `eval` is incorrect, or
    when a file cannot be opened by one of the file open procedures. In these situations,
    the exception is raised with a standard condition type.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 标准语法形式和过程在各种情况下引发异常，例如当向过程传递了错误数量的参数时，当传递给`eval`的表达式的语法不正确时，或者当文件不能被一个文件打开过程打开时。在这些情况下，异常将被引发为标准条件类型。
- en: Exceptions may also be raised by user code via the `raise` or `raise-continuable`
    procedures. In this case, the exception may be raised with one of the standard
    condition types, a user-defined subtype of one of the standard condition types
    (possibly defined using `define-condition-type`), or an arbitrary Scheme value
    that is not a condition type.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 异常也可以通过`raise`或`raise-continuable`过程由用户代码引发。在这种情况下，异常可以由标准条件类型、标准条件类型的用户定义子类型（可能使用`define-condition-type`定义）、或者不是条件类型的任意
    Scheme 值引发。
- en: At any point during a program's execution, a single exception handler, called
    the *current exception handler*, is charged with handling all exceptions that
    are raised. By default, the current exception handler is one provided by the implementation.
    The default exception handler typically prints a message that describes the condition
    or other value with which the exception was raised and, for any serious condition,
    terminates the running program. In interactive systems, this typically means a
    reset to the read-eval-print loop.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行过程中的任何时刻，都有一个称为*当前异常处理程序*的单一异常处理程序负责处理所有引发的异常。默认情况下，当前异常处理程序是由实现提供的。默认异常处理程序通常会打印一个描述引发异常的条件或其他值的消息，并且对于任何严重的条件，会终止正在运行的程序。在交互式系统中，这通常意味着重置为读取-求值-打印循环。
- en: User code may establish a new current exception handler via the `guard` syntax
    or the `with-exception-handler` procedure. In either case, the user code may handle
    all exceptions or, based on the condition or other value with which the exception
    was raised, just some of the exceptions while reraising the others for the old
    current exception handler to handle. When `guard` forms and `with-exception-handler`
    calls are nested dynamically, a chain of exception handlers is established, and
    each may defer to the next in the chain.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代码可以通过`guard`语法或`with-exception-handler`过程建立一个新的当前异常处理程序。在任何情况下，用户代码都可以处理所有异常，或者根据异常引发的条件或其他值，只处理其中的一些异常，同时将其他异常重新引发给旧的当前异常处理程序处理。当动态嵌套`guard`形式和`with-exception-handler`调用时，会建立一个异常处理程序链，并且每个异常处理程序可能会推迟到链中的下一个处理程序。
- en: Section 11.1\. Raising and Handling Exceptions
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 11.1 节。抛出和处理异常
- en: '**procedure**: `(raise *obj*)`'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(raise *obj*)`'
- en: '**procedure**: `(raise-continuable *obj*)`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(raise-continuable *obj*)`'
- en: '**returns:** see below'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**: 见下文'
- en: '**libraries:** `(rnrs exceptions)`, `(rnrs)`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**: `(rnrs exceptions)`，`(rnrs)`'
- en: Both of these procedures raise an exception, effectively invoking the current
    exception handler, passing `*obj*` as the only argument. For `raise`, the exception
    is *non-continuable*, while for `raise-continuable`, the exception is *continuable*.
    An exception handler may return (with zero or more values) to the continuation
    of a continuable exception. If an exception handler attempts to return to the
    continuation of a non-continuable exception, however, a new exception with condition
    type `&non-continuable` is raised. Thus, `raise` never returns, while `raise-continuable`
    may return zero or more values, depending upon the exception handler.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个过程都会引发异常，有效地调用当前异常处理程序，并将`*obj*`作为唯一参数传递。对于`raise`，异常是*不可继续的*，而对于`raise-continuable`，异常是*可继续的*。异常处理程序可以返回（带有零个或更多个值）到可继续异常的继续。然而，如果异常处理程序尝试返回到不可继续异常的继续，将引发一个新的条件类型为`&non-continuable`的异常。因此，`raise`永远不会返回，而`raise-continuable`可能根据异常处理程序返回零个或多个值。
- en: If the current exception handler, `*p*`, was established via a `guard` form
    or call to `with-exception-handler`, the current exception handler is reset to
    the handler that was current when `*p*` was established before `raise` or `raise-continuable`
    invokes `*p*`. This allows `*p*` to defer to the preexisting exception handler
    simply by reraising the exception, and it helps prevent infinite regression when
    an exception handler inadvertently causes a different exception to be raised.
    If `*p*` returns and the exception is continuable, `*p*` is reinstated as the
    current exception handler.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前的异常处理程序 `*p*` 是通过 `guard` 表单或调用 `with-exception-handler` 建立的，则在 `raise`
    或 `raise-continuable` 调用 `*p*` 之前将当前的异常处理程序重置为建立 `*p*` 时当前的处理程序。这允许 `*p*` 简单地通过重新引发异常来推迟到先前存在的异常处理程序，并且当异常处理程序无意中导致引发其他异常时，它有助于防止无限递归。如果
    `*p*` 返回并且异常是可继续的，则 `*p*` 将被重新设置为当前的异常处理程序。
- en: '`(raise'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`(raise'
- en: (condition
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: (condition
- en: (make-error)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: (make-error)
- en: (make-message-condition "no go"))) ![<graphic>](ch2_0.gif) *error: no go*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: (make-message-condition "不行了"))) ![<graphic>](ch2_0.gif) *错误：不行了*
- en: (raise-continuable
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (raise-continuable
- en: (condition
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: (condition
- en: (make-violation)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: (make-violation)
- en: (make-message-condition "oops"))) ![<graphic>](ch2_0.gif) *violation: oops*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: (make-message-condition "哎呀"))) ![<graphic>](ch2_0.gif) *违反：哎呀*
- en: (list
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: (list
- en: (call/cc
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (k)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (vector
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: (vector
- en: (with-exception-handler
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: (with-exception-handler
- en: (lambda (x) (k (+ x 5)))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) (k (+ x 5)))
- en: (lambda () (+ (raise 17) 8))))))) ![<graphic>](ch2_0.gif) (22)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (+ (raise 17) 8))))))) ![<graphic>](ch2_0.gif) (22)
- en: (list
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (list
- en: (vector
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: (vector
- en: (with-exception-handler
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: (with-exception-handler
- en: (lambda (x) (+ x 5))
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) (+ x 5))
- en: (lambda () (+ (raise-continuable 17) 8))))) ![<graphic>](ch2_0.gif) (#(30))
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (+ (raise-continuable 17) 8))))) ![<graphic>](ch2_0.gif) (#(30))
- en: (list
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: (list
- en: (vector
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: (vector
- en: (with-exception-handler
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: (with-exception-handler
- en: (lambda (x) (+ x 5))
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) (+ x 5))
- en: (lambda () (+ (raise 17) 8))))) ![<graphic>](ch2_0.gif) *violation: non-continuable*`
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () (+ (raise 17) 8))))) ![<graphic>](ch2_0.gif) *违反：不可继续*`
- en: '**procedure**: `(error *who* *msg* *irritant* ...)`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(error *who* *msg* *irritant* ...)`'
- en: '**procedure**: `(assertion-violation *who* *msg* *irritant* ...)`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(assertion-violation *who* *msg* *irritant* ...)`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`error` raises a non-continuable exception with condition type `&error` and
    should be used to describe situations for which the `&error` condition type is
    appropriate, typically a situation involving the program''s interaction with something
    outside of the program. `assertion-violation` raises a non-continuable exception
    with condition type `&assertion` and should be used to describe situations for
    which the `&assertion` condition type is appropriate, typically an invalid argument
    to a procedure or invalid value of a subexpression of a syntactic form.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`error` 引发一个具有条件类型 `&error` 的不可继续异常，并应用于描述与程序外部交互有关的情况，典型情况涉及程序与程序外部的某些东西的交互。
    `assertion-violation` 引发一个具有条件类型 `&assertion` 的不可继续异常，并应用于描述适用于 `&assertion` 条件类型的情况，典型情况是过程的无效参数或语法形式的子表达式的无效值。'
- en: The continuation object with which the exception is raised also includes a `&who`
    condition whose who field is `*who*` if `*who*` is not `#f`, a `&message` condition
    whose message field is `*msg*`, and an `&irritants` condition whose irritants
    field is `(*irritant* ...)`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 触发异常的延续对象还包括一个 `&who` 条件，其 who 字段为 `*who*`，如果 `*who*` 不是 `#f`，则一个 `&message`
    条件，其 message 字段为 `*msg*`，以及一个 `&irritants` 条件，其 irritants 字段为 `(*irritant* ...)`。
- en: '`*who*` must be a string, a symbol, or `#f` identifying the procedure or syntactic
    form reporting the error upon whose behalf the error is being reported. It is
    usually best to identify a procedure the programmer has called rather than some
    other procedure the programmer may not be aware is involved in carrying out the
    operation. `*msg*` must be a string and should describe the exceptional situation.
    The irritants may be any Scheme objects and should include values that may have
    caused or been materially involved in the exceptional situation.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`*who*` 必须是字符串、符号或 `#f`，用于标识报告错误的过程或语法形式所在的过程。通常最好标识程序员调用的过程，而不是程序员可能不知道涉及执行操作的其他过程。
    `*msg*` 必须是字符串，并应描述异常情况。激怒物可以是任何 Scheme 对象，并且应包括可能导致或实质上涉及异常情况的值。'
- en: '**syntax**: `(assert *expression*)`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(assert *expression*)`'
- en: '**returns:** see below'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`assert` evaluates `*expression*` and returns the value of `*expression*` if
    the value is not `#f`. If the value of `*expression*` is `#f`, `assert` raises
    a non-continuable exception with condition types `&assertion` and `&message`,
    with an implementation-dependent value in its message field. Implementations are
    encouraged to provide information about the location of the `assert` call within
    the condition whenever possible.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` evaluates `*expression*` and returns the value of `*expression*` if
    the value is not `#f`. If the value of `*expression*` is `#f`, `assert` raises
    a non-continuable exception with condition types `&assertion` and `&message`,
    with an implementation-dependent value in its message field. Implementations are
    encouraged to provide information about the location of the `assert` call within
    the condition whenever possible.'
- en: '**procedure**: `(syntax-violation *who* *msg* *form*)`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(syntax-violation *who* *msg* *form*)`'
- en: '**procedure**: `(syntax-violation *who* *msg* *form* *subform*)`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(syntax-violation *who* *msg* *form* *subform*)`'
- en: '**returns:** does not return'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** does not return'
- en: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs syntax-case)`, `(rnrs)`'
- en: This procedure raises a non-continuable exception with a condition of type `&syntax`.
    It should be used to report a syntax error detected by the transformer of a syntactic
    extension. The value of the condition's form field is `*form*`, and the value
    of its subform field is `*subform*`, or `#f` if `*subform*` is not provided.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: This procedure raises a non-continuable exception with a condition of type `&syntax`.
    It should be used to report a syntax error detected by the transformer of a syntactic
    extension. The value of the condition's form field is `*form*`, and the value
    of its subform field is `*subform*`, or `#f` if `*subform*` is not provided.
- en: The continuation object with which the exception is raised also includes a `&who`
    condition whose who field is `*who*`, if `*who*` is not `#f` or is inferred from
    `*form*`, and a `&message` condition whose message field is `*msg*`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: The continuation object with which the exception is raised also includes a `&who`
    condition whose who field is `*who*`, if `*who*` is not `#f` or is inferred from
    `*form*`, and a `&message` condition whose message field is `*msg*`.
- en: '`*who*` must be a string, a symbol, or `#f`. If `*who*` is `#f`, it is inferred
    to be the symbolic name of `*form*` if `*form*` is an identifier or the symbolic
    name of the first subform of `*form*` if `*form*` is a list-structured form whose
    first subform is an identifier. `*message*` must be a string. `*form*` should
    be the syntax object or datum representation of the syntactic form within which
    the syntax violation occurred, and `*subform*`, if not `#f`, should be a syntax
    object or datum representation of a subform more specifically involved in the
    violation. For example, if a duplicate formal parameter is found in a `lambda`
    expression, `*form*` might be the `lambda` expression and `*subform*` might be
    the duplicated parameter.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`*who*` must be a string, a symbol, or `#f`. If `*who*` is `#f`, it is inferred
    to be the symbolic name of `*form*` if `*form*` is an identifier or the symbolic
    name of the first subform of `*form*` if `*form*` is a list-structured form whose
    first subform is an identifier. `*message*` must be a string. `*form*` should
    be the syntax object or datum representation of the syntactic form within which
    the syntax violation occurred, and `*subform*`, if not `#f`, should be a syntax
    object or datum representation of a subform more specifically involved in the
    violation. For example, if a duplicate formal parameter is found in a `lambda`
    expression, `*form*` might be the `lambda` expression and `*subform*` might be
    the duplicated parameter.'
- en: Some implementations attach source information to syntax objects, e.g., line,
    character, and filename for forms originating in a file, in which case this information
    might also be present as some implementation-dependent condition type within the
    condition object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Some implementations attach source information to syntax objects, e.g., line,
    character, and filename for forms originating in a file, in which case this information
    might also be present as some implementation-dependent condition type within the
    condition object.
- en: '**procedure**: `(with-exception-handler *procedure* *thunk*)`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(with-exception-handler *procedure* *thunk*)`'
- en: '**returns:** see below'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** see below'
- en: '**libraries:** `(rnrs exceptions)`, `(rnrs)`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs exceptions)`, `(rnrs)`'
- en: This procedure establishes `*procedure*`, which should accept one argument,
    as the current exception handler in place of the old current exception handler,
    `*old-proc*`, and invokes `*thunk*` without arguments. If the call to `*thunk*`
    returns, `*old-proc*` is reestablished as the current exception handler and the
    values returned by `*thunk*` are returned. If control leaves or subsequently reenters
    the call to `*thunk*` via the invocation of a continuation obtained via `call/cc`,
    the procedure that was the current exception handler when the continuation was
    captured is reinstated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: This procedure establishes `*procedure*`, which should accept one argument,
    as the current exception handler in place of the old current exception handler,
    `*old-proc*`, and invokes `*thunk*` without arguments. If the call to `*thunk*`
    returns, `*old-proc*` is reestablished as the current exception handler and the
    values returned by `*thunk*` are returned. If control leaves or subsequently reenters
    the call to `*thunk*` via the invocation of a continuation obtained via `call/cc`,
    the procedure that was the current exception handler when the continuation was
    captured is reinstated.
- en: '`(define (try thunk)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (try thunk)'
- en: (call/cc
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc
- en: (lambda (k)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (k)
- en: (with-exception-handler
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: (with-exception-handler
- en: (lambda (x) (if (error? x) (k #f) (raise x)))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda （x） （如果 （错误？ x） （k #f） （提高 x））
- en: thunk))))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: thunk））））
- en: (try (lambda () 17)) ![<graphic>](ch2_0.gif) 17
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （尝试 （lambda （） 17）） ![<graphic>](ch2_0.gif) 17
- en: (try (lambda () (raise (make-error)))) ![<graphic>](ch2_0.gif) #f
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: （尝试 （lambda （） （提高 （制造错误））） ![<graphic>](ch2_0.gif) #f
- en: (try (lambda () (raise (make-violation)))) ![<graphic>](ch2_0.gif) *violation*
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: （尝试 （lambda （） （提高 （制造违规））） ![<graphic>](ch2_0.gif) *违规*
- en: (with-exception-handler
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: （使用-异常-处理程序
- en: (lambda (x)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda （x）
- en: (raise
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: （提高
- en: (apply condition
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: （应用 条件
- en: (make-message-condition "oops")
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: （制作-消息-条件“糟糕”）
- en: (simple-conditions x))))
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: （简单条件 x))))
- en: (lambda ()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda （）
- en: (try (lambda () (raise (make-violation)))))) ![<graphic>](ch2_0.gif) *violation: oops*`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: （尝试 （lambda （） （提高 （制造违规））））） ![<graphic>](ch2_0.gif) *违规：糟糕*`
- en: '**syntax**: `(guard (*var* *clause[1]* *clause[2]* ...) *b1* *b2* ...)`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法:** `（guard （*var* *clause[1]* *clause[2]* ...） *b1* *b2* ...）`'
- en: '**returns:** see below'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:**见下文'
- en: '**libraries:** `(rnrs exceptions)`, `(rnrs)`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `（rnrs 异常）`，`（rnrs）`'
- en: A `guard` expression establishes a new current exception handler, `*procedure*`
    (described below), in place of the old current exception handler, `*old-proc*`,
    and evaluates the body `*b1* *b2* ...`. If the body returns, `guard` reestablishes
    `*old-proc*` as the current exception handler. If control leaves or subsequently
    reenters the body via the invocation of a continuation obtained via `call/cc`,
    the procedure that was the current exception handler when the continuation was
    captured is reinstated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard`表达式建立了一个新的当前异常处理程序`*procedure*`（如下所述），代替了旧的当前异常处理程序`*old-proc*`，并评估了主体`*b1* *b2* ...`。如果主体返回，`guard`重新建立`*old-proc*`作为当前异常处理程序。如果控制通过`调用/
    cc`获取的继续离开或随后重新进入主体，则重新建立捕获继续时的当前异常处理程序。'
- en: The procedure `*procedure*` established by `guard` binds `*var*` to the value
    it receives and, within the scope of that binding, processes the clauses `*clause[1]* *clause[2]* ...`
    in turn, as if contained within an implicit `cond` expression. This implicit `cond`
    expression is evaluated in the continuation of the `guard` expression, with `*old-proc*`
    as the current exception handler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由`guard`建立的过程`*procedure*`将`*var*`绑定到接收的值，并在该绑定的范围内依次处理子句`*clause[1]* *clause[2]* ...`，就像包含在隐式`条件`表达式中一样。该隐式`条件`表达式在`guard`表达式的继续中求值，`*old-proc*`作为当前异常处理程序。
- en: If no `else` clause is provided, `guard` supplies one that reraises the exception
    with the same value, as if with `raise-continuable`, in the continuation of the
    call to `*procedure*`, with `*old-proc*` as the current exception handler.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供`其他`子句，则`guard`会使用一个子句，以与`提高-可继续`相同的值重新引发异常，`*old-proc*`作为当前异常处理程序。
- en: '`(guard (x [else x]) (raise "oops")) ![<graphic>](ch2_0.gif) "oops"'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`（保护 （x [其他 x]） （提高 "糟糕"）） ![<graphic>](ch2_0.gif) "糟糕"'
- en: (guard (x [#f #f]) (raise (make-error))) ![<graphic>](ch2_0.gif)  *error*
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （保护 （x （[#f #f]）） （提高 （制造错误））） ![<graphic>](ch2_0.gif)  *错误*
- en: (define-syntax try
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: （定义语法 尝试
- en: (syntax-rules ()
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: （语法规则 ）
- en: '[(_ e1 e2 ...)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[（_ e1 e2 ...)'
- en: (guard (x [(error? x) #f]) e1 e2 ...)]))
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: （保护 （x （（错误？ x） #f）） e1 e2 ...]）
- en: (define open-one
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: （定义 open-one
- en: (lambda fn*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda fn*
- en: (let loop ([ls fn*])
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: （让 循环 （[ls fn*]）
- en: (if (null? ls)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: （如果 （null？ ls）
- en: (error 'open-one "all open attempts failed" fn*)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: （错误 'open-one "所有打开尝试均失败" fn*）
- en: (or (try (open-input-file (car ls)))
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: （或 （尝试 （打开输入文件 （car ls）））
- en: (loop (cdr ls)))))))
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: （循环 （cdr ls）））））
- en: '; say bar.ss exists but not foo.ss:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ; 假设bar.ss存在但foo.ss不存在：
- en: (open-one "foo.ss" "bar.ss") ![<graphic>](ch2_0.gif) #<input port bar.ss>`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: （open-one "foo.ss" "bar.ss"） ![<graphic>](ch2_0.gif) #<input port bar.ss>`
- en: Section 11.2\. Defining Condition Types
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第11.2节。定义条件类型
- en: While a program may pass `raise` or `raise-continuable` any Scheme value, the
    best way to describe an exceptional situation is usually to create and pass a
    *condition object*. Where the Revised⁶ Report requires the implementation to raise
    exceptions, the value passed to the current exception handler is always a condition
    object of one or more of the standard *condition types* described in Section [11.3](exceptions.html#g150).
    User code may create a condition object that is an instance of one or more standard
    condition types or it may create an extended condition type and create a condition
    object of that type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然程序可能传递`提高`或`提高-可继续`任何Scheme值，但通常描述异常情况的最佳方法是创建并传递*条件对象*。在修订⁶报告中要求实现引发异常的地方，传递给当前异常处理程序的值始终是一个或多个标准*条件类型*的条件对象，这些类型在第[11.3](exceptions.html#g150)节中描述。用户代码可以创建一个是一个或多个标准条件类型实例的条件对象，也可以创建一个扩展的条件类型并创建该类型的条件对象。
- en: Condition types are similar to record types but are more flexible in that a
    condition object may be an instance of two or more condition types, even if neither
    is a subtype of the other. When a condition is an instance of multiple types,
    it is referred to as a *compound condition*. Compound conditions are useful for
    communicating multiple pieces of information about an exception to the exception
    handler. A condition that is not a compound condition is referred to as a *simple
    condition*. In most cases, the distinction between the two is unimportant, and
    a simple condition is treated as if it were a compound condition with itself as
    its only simple condition.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型类似于记录类型，但更灵活，因为条件对象可以是两个或更多条件类型的实例，即使两者都不是彼此的子类型。当一个条件是多个类型的实例时，它被称为*复合条件*。复合条件对于向异常处理程序传递有关异常的多个信息非常有用。不是复合条件的条件被称为*简单条件*。在大多数情况下，这两者之间的区别并不重要，简单条件被视为只有自身作为其唯一简单条件的复合条件。
- en: '**syntax**: `&condition`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&condition`'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: '`&condition` is a record-type name (Chapter [9](records.html#g138)) and the
    root of the condition-type hierarchy. All simple condition types are extensions
    of this type, and all conditions, whether simple or compound, are considered instances
    of this type.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`&condition`是一个记录类型名称（第[9](records.html#g138)章）和条件类型层次结构的根。所有简单条件类型都是这种类型的扩展，所有条件，无论是简单的还是复合的，都被视为这种类型的实例。'
- en: '**procedure**: `(condition? *obj*)`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(condition? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition object, otherwise `#f`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是条件对象，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: A condition object is an instance of a subtype of `&condition` or a compound
    condition, possibly created by user code with `condition`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 条件对象是`&condition`的子类型的实例或可能由用户代码使用`condition`创建的复合条件。
- en: '`(condition? ''stable) ![<graphic>](ch2_0.gif) #f'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`(condition? ''stable) ![<graphic>](ch2_0.gif) #f'
- en: (condition? (make-error)) ![<graphic>](ch2_0.gif) #t
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: (condition? (make-error)) ![<graphic>](ch2_0.gif) #t
- en: (condition? (make-message-condition "oops")) ![<graphic>](ch2_0.gif) #t
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (condition? (make-message-condition "oops")) ![<graphic>](ch2_0.gif) #t
- en: (condition?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (condition?
- en: (condition
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (condition
- en: (make-error)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: (make-error)
- en: (make-message-condition "no such element"))) ![<graphic>](ch2_0.gif) #t`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: (make-message-condition "no such element"))) ![<graphic>](ch2_0.gif) #t`
- en: '**procedure**: `(condition *condition* ...)`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(condition *condition* ...)`'
- en: '**returns:** a condition, possibly compound'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个条件，可能是复合的'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: '`condition` is used to create condition objects that may consist of multiple
    simple conditions. Each argument `*condition*` may be simple or complex; if simple,
    it is treated as a compound condition with itself as its only simple condition.
    The simple conditions of the result condition are the simple conditions of the
    `*condition*` arguments, flattened into a single list and appearing in order,
    with the simple conditions of the first `*condition*` followed by the simple conditions
    of the second, and so on.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition`用于创建可能由多个简单条件组成的条件对象。每个参数`*condition*`可以是简单的或复杂的；如果是简单的，则将其视为一个只有自身作为其唯一简单条件的复合条件。结果条件的简单条件是`*condition*`参数的简单条件，展平为一个列表并按顺序出现，第一个`*condition*`的简单条件后面是第二个的简单条件，依此类推。'
- en: If the list has exactly one element, the result condition may be simple or compound;
    otherwise it is compound. The distinction between simple and compound conditions
    is not usually important but can be detected, if `define-record-type` rather than
    `define-condition-type` is used to extend an existing condition type, via the
    predicate defined by `define-record-type`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表恰好有一个元素，则结果条件可以是简单的或复合的；否则它是复合的。简单条件和复合条件之间的区别通常不重要，但如果使用`define-record-type`而不是`define-condition-type`来扩展现有条件类型，则可以通过`define-record-type`定义的谓词来检测。
- en: '`(condition) ![<graphic>](ch2_0.gif) #<condition>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`(condition) ![<graphic>](ch2_0.gif) #<condition>'
- en: (condition
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (condition
- en: (make-error)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: (make-error)
- en: (make-message-condition "oops")) ![<graphic>](ch2_0.gif) #<condition>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (make-message-condition "oops")) ![<graphic>](ch2_0.gif) #<condition>
- en: (define-record-type (&xcond make-xcond xcond?) (parent &condition))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (define-record-type (&xcond make-xcond xcond?) (parent &condition))
- en: (xcond? (make-xcond)) ![<graphic>](ch2_0.gif) #t
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (xcond? (make-xcond)) ![<graphic>](ch2_0.gif) #t
- en: (xcond? (condition (make-xcond))) ![<graphic>](ch2_0.gif) #t *or* #f
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (xcond? (condition (make-xcond))) ![<graphic>](ch2_0.gif) #t *or* #f
- en: (xcond? (condition)) ![<graphic>](ch2_0.gif) #f
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (xcond? (condition)) ![<graphic>](ch2_0.gif) #f
- en: (xcond? (condition (make-error) (make-xcond))) ![<graphic>](ch2_0.gif) #f`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (xcond? (condition (make-error) (make-xcond))) ![<graphic>](ch2_0.gif) #f`
- en: '**procedure**: `(simple-conditions *condition*)`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(simple-conditions *condition*)`'
- en: '**returns:** a list of the simple conditions of `*condition*`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：`*condition*`的简单条件列表'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs conditions)`，`(rnrs)`'
- en: '`(simple-conditions (condition)) ![<graphic>](ch2_0.gif) ''()'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`(simple-conditions (condition)) ![<graphic>](ch2_0.gif) ''()'
- en: (simple-conditions (make-error)) ![<graphic>](ch2_0.gif) (#<condition &error>)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (simple-conditions (make-error)) ![<graphic>](ch2_0.gif) (#<condition &error>)
- en: (simple-conditions (condition (make-error))) ![<graphic>](ch2_0.gif) (#<condition &error>)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (simple-conditions (condition (make-error))) ![<graphic>](ch2_0.gif) (#<condition &error>)
- en: (simple-conditions
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: (simple-conditions
- en: (condition
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: (condition
- en: (make-error)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (make-error)
- en: (make-message-condition
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: (make-message-condition
- en: '"oops"))) ![<graphic>](ch2_0.gif) (#<condition &error> #<condition &message>)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '"哎呀"))) ![<graphic>](ch2_0.gif) (#<condition &error> #<condition &message>)'
- en: (let ([c1 (make-error)]
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([c1 (make-error)]
- en: '[c2 (make-who-condition "f")]'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[c2 (make-who-condition "f")]'
- en: '[c3 (make-message-condition "invalid argument")]'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[c3 (make-message-condition "无效参数")]'
- en: '[c4 (make-message-condition'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[c4 (make-message-condition'
- en: '"error occurred while reading from file")]'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"读取文件时发生错误")]'
- en: '[c5 (make-irritants-condition ''("a.ss"))])'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[c5 (make-irritants-condition ''("a.ss"))])'
- en: (equal?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: (equal?
- en: (simple-conditions
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: (simple-conditions
- en: (condition
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: (condition
- en: (condition (condition c1 c2) c3)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: (condition (condition c1 c2) c3)
- en: (condition c4 (condition c5))))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: (condition c4 (condition c5))))
- en: (list c1 c2 c3 c4 c5))) ![<graphic>](ch2_0.gif) #t`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (list c1 c2 c3 c4 c5))) ![<graphic>](ch2_0.gif) #t`
- en: '**syntax**: `(define-condition-type *name* *parent* *constructor* *pred* *field* ...)`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`(define-condition-type *name* *parent* *constructor* *pred* *field* ...)`'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs conditions)`，`(rnrs)`'
- en: A `define-condition-type` form is a definition and may appear anywhere other
    definitions may appear. It is used to define new simple condition types.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`define-condition-type`形式是一个定义，可以出现在其他定义可以出现的任何地方。它用于定义新的简单条件类型。'
- en: The subforms `*name*`, `*parent*`, `*constructor*`, and `*pred*` must be identifiers.
    Each `*field*` must be of the form `(*field-name* *accessor-name*)`, where `*field-name*`
    and `*accessor-name*` are identifiers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 子表达式`*name*`、`*parent*`、`*constructor*`和`*pred*`必须是标识符。每个`*field*`必须是形式为`(*field-name* *accessor-name*)`的标识符，其中`*field-name*`和`*accessor-name*`是标识符。
- en: '`define-condition-type` defines `*name*` as a new record type whose parent
    record type is `*parent*`, whose constructor name is `*constructor*`, whose predicate
    name is `*pred*`, whose fields are `*field-name* ...`, and whose field accessors
    are named by `*accessor-name* ...`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`define-condition-type`将`*name*`定义为一个新的记录类型，其父记录类型是`*parent*`，构造函数名为`*constructor*`，谓词名为`*pred*`，字段为`*field-name* ...`，字段访问器由`*accessor-name* ...`命名。'
- en: With the exception of the predicate and field accessors, `define-condition-type`
    is essentially an ordinary record definition equivalent to
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了谓词和字段访问器之外，`define-condition-type`本质上是一个普通的记录定义，等同于
- en: '`(define-record-type (*name* *constructor* *pred*)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type (*name* *constructor* *pred*)'
- en: (parent *parent*)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (parent *parent*)
- en: (fields ((immutable *field-name* *accessor-name*) ...)))`
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (fields ((immutable *field-name* *accessor-name*) ...)))`
- en: The predicate differs from one that would be generated by a `define-record-type`
    form in that it returns `#t` not only for an instance of the new type but also
    for compound conditions whose simple conditions include an instance of the new
    type. Similarly, field accessors accept instances of the new type as well as compound
    conditions whose simple conditions include at least one instance of the new record
    type. If an accessor receives a compound condition whose simple conditions list
    includes one or more instances of the new type, the accessor operates on the first
    instance in the list.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词与`define-record-type`形式生成的谓词不同，它不仅对新类型的实例返回`#t`，而且对于包含新类型实例的复合条件也返回`#t`。类似地，字段访问器接受新类型的实例以及包含至少一个新记录类型实例的复合条件。如果访问器接收到一个包含新类型实例的复合条件，其简单条件列表包含一个或多个新类型实例，则访问器将操作列表中的第一个实例。
- en: '`(define-condition-type &mistake &condition make-mistake mistake?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &mistake &condition make-mistake mistake?'
- en: (type mistake-type))
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (类型 mistake-type))
- en: (mistake? 'booboo) ![<graphic>](ch2_0.gif) #f
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (mistake? 'booboo) ![<graphic>](ch2_0.gif) #f
- en: (define c1 (make-mistake 'spelling))
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (define c1 (make-mistake 'spelling))
- en: (mistake? c1) ![<graphic>](ch2_0.gif) #t
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (mistake? c1) ![<graphic>](ch2_0.gif) #t
- en: (mistake-type c1) ![<graphic>](ch2_0.gif) spelling
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: (mistake-type c1) ![<graphic>](ch2_0.gif) 拼写
- en: (define c2 (condition c1 (make-irritants-condition '(eggregius))))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (define c2 (condition c1 (make-irritants-condition '(eggregius))))
- en: (mistake? c2) ![<graphic>](ch2_0.gif) #t
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (mistake? c2) ![<graphic>](ch2_0.gif)��#t
- en: (mistake-type c2) ![<graphic>](ch2_0.gif) spelling
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (mistake-type c2) ![<graphic>](ch2_0.gif) 拼写
- en: (irritants-condition? c2) ![<graphic>](ch2_0.gif) #t
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (irritants-condition? c2) ![<graphic>](ch2_0.gif) #t
- en: (condition-irritants c2) ![<graphic>](ch2_0.gif) (eggregius)`
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (condition-irritants c2) ![<graphic>](ch2_0.gif) (eggregius)`
- en: '**procedure**: `(condition-predicate *rtd*)`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(condition-predicate *rtd*)`'
- en: '**returns:** a condition predicate'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个条件谓词'
- en: '**procedure**: `(condition-accessor *rtd* *procedure*)`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(condition-accessor *rtd* *procedure*)`'
- en: '**returns:** a condition accessor'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个条件访问器'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: These procedures may be used to create the same kind of special predicates and
    accessors that are created by `define-record-type` from a record-type descriptor,
    `*rtd*`, of a simple condition type or other type derived from a simple condition
    type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程可用于创建与由记录类型描述符 `*rtd*` 创建的特殊谓词和访问器相同类型的谓词和访问器，该描述符是简单条件类型或从简单条件类型派生的其他类型的实例。
- en: For both procedures, `*rtd*` must be a record-type descriptor of a subtype of
    `&condition`, and for `condition-accessor`, `*procedure*` should accept one argument.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个过程，`*rtd*` 必须是 `&condition` 的子类型的记录类型描述符，并且对于 `condition-accessor`，`*procedure*`
    应接受一个参数。
- en: The predicate returned by `condition-predicate` accepts one argument, which
    may be any Scheme value. The predicate returns `#t` if the value is a condition
    of the type described by `*rtd*`, i.e., an instance of the type described by `*rtd*`
    (or one of its subtypes) or a compound condition whose simple conditions include
    an instance of the type described by `*rtd*`. Otherwise, the predicate returns
    `#f`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition-predicate` 返回的谓词接受一个参数，该参数可以是任何 Scheme 值。 如果该值是由 `*rtd*` 描述的类型的条件，即由
    `*rtd*` 描述的类型的实例（或其子类型之一）或其简单条件包括由 `*rtd*` 描述的类型的实例的复合条件，则谓词返回 `#t`。 否则，谓词返回 `#f`。'
- en: The accessor returned by `condition-accessor` accepts one argument, `*c*`, which
    must be a condition of the type described by `*rtd*`. The accessor applies `*procedure*`
    to a single argument, the first element of `*c*`'s simple condition list that
    is an instance of the type described by `*rtd*` (this is `*c*` itself if `*c*`
    is a simple condition), and returns the result of this application. In most situations,
    `*procedure*` is a record accessor for a field of the type described by `*rtd*`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition-accessor` 返回的访问器接受一个参数 `*c*`，该参数必须是由 `*rtd*` 描述的类型的条件。 访问器将 `*procedure*`
    应用于一个参数，即 `*c*` 的简单条件列表的第一个元素，该元素是由 `*rtd*` 描述的类型的实例（如果 `*c*` 是简单条件，则为 `*c*` 本身），并返回此应用的结果。
    在大多数情况下，`*procedure*` 是由 `*rtd*` 描述的类型的字段的记录访问器。'
- en: '`(define-record-type (&mistake make-mistake $mistake?)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type (&mistake make-mistake $mistake?)'
- en: (parent &condition)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (parent &condition)
- en: (fields (immutable type $mistake-type)))
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (fields (immutable type $mistake-type)))
- en: ; define predicate and accessor as if we'd used define-condition-type
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ; 假设我们使用了 `define-condition-type` 来定义谓词和访问器
- en: (define rtd (record-type-descriptor &mistake))
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (define rtd (record-type-descriptor &mistake))
- en: (define mistake? (condition-predicate rtd))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: (define mistake? (condition-predicate rtd))
- en: (define mistake-type (condition-accessor rtd $mistake-type))
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: (define mistake-type (condition-accessor rtd $mistake-type))
- en: (define c1 (make-mistake 'spelling))
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: (define c1 (make-mistake 'spelling)
- en: (define c2 (condition c1 (make-irritants-condition '(eggregius))))
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: (define c2 (condition c1 (make-irritants-condition '(eggregius))))
- en: (list (mistake? c1) (mistake? c2)) ![<graphic>](ch2_0.gif) (#t #t)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: (list (mistake? c1) (mistake? c2)) ![<graphic>](ch2_0.gif) (#t #t)
- en: (list ($mistake? c1) ($mistake? c2)) ![<graphic>](ch2_0.gif) (#t #f)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: (list ($mistake? c1) ($mistake? c2)) ![<graphic>](ch2_0.gif) (#t #f)
- en: (mistake-type c1) ![<graphic>](ch2_0.gif) spelling
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: (mistake-type c1) ![<graphic>](ch2_0.gif) 拼写
- en: ($mistake-type c1) ![<graphic>](ch2_0.gif) spelling
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ($mistake-type c1) ![<graphic>](ch2_0.gif) 拼写
- en: (mistake-type c2) ![<graphic>](ch2_0.gif) spelling
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: (mistake-type c2) ![<graphic>](ch2_0.gif) 拼写
- en: ($mistake-type c2) ![<graphic>](ch2_0.gif) *violation*`
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ($mistake-type c2) ![<graphic>](ch2_0.gif) *violation*`
- en: Section 11.3\. Standard Condition Types
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 11.3 节。标准条件类型
- en: '**syntax**: `&serious`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&serious`'
- en: '**procedure**: `(make-serious-condition)`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-serious-condition)`'
- en: '**returns:** a condition of type `&serious`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个类型为 `&serious` 的条件'
- en: '**procedure**: `(serious-condition? *obj*)`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(serious-condition? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&serious`, `#f` otherwise'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果 `*obj*` 是类型为 `&serious` 的条件，则返回 `#t`，否则返回 `#f`'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type indicate situations of a serious nature that, if uncaught,
    generally result in termination of the program's execution. Conditions of this
    type typically occur as one of the more specific subtypes `&error` or `&violation`.
    This condition type might be defined as follows.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的条件指示了严重性质的情况，如果不被捕获，通常会导致程序执行的终止。这种类型的条件通常出现为更具体的子类型之一`&error`或`&violation`。这种条件类型可能定义如下。
- en: '`(define-condition-type &serious &condition'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &serious &condition`'
- en: make-serious-condition serious-condition?)`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: make-serious-condition serious-condition?)`
- en: '**syntax**: `&violation`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&violation`'
- en: '**procedure**: `(make-violation)`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-violation)`'
- en: '**returns:** a condition of type `&violation`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为`&violation`的条件'
- en: '**procedure**: `(violation? *obj*)`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&violation`, `#f` otherwise'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是类型为`&violation`的条件，则返回`#t`，否则返回`#f`。'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type indicate that the program has violated some requirement,
    usually due to a bug in the program. This condition type might be defined as follows.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的条件指示程序违反了某些要求，通常是由于程序中的错误导致的。这种条件类型可能定义如下。
- en: '`(define-condition-type &violation &serious'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &violation &serious`'
- en: make-violation violation?)`
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: make-violation violation?)`
- en: '**syntax**: `&assertion`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&assertion`'
- en: '**procedure**: `(make-assertion-violation)`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-assertion-violation)`'
- en: '**returns:** a condition of type `&assertion`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为`&assertion`的条件'
- en: '**procedure**: `(assertion-violation? *obj*)`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(assertion-violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&assertion`, `#f` otherwise'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是类型为`&assertion`的条件，则返回`#t`，否则返回`#f`。'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: This condition type indicates a specific violation in which the program has
    passed the wrong number or types of arguments to a procedure. This condition type
    might be defined as follows.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种条件类型指示程序在向过程传递错误数量或类型的参数时发生了特定的违规。这种条件类型可能定义如下。
- en: '`(define-condition-type &assertion &violation'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &assertion &violation`'
- en: make-assertion-violation assertion-violation?)`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: make-assertion-violation assertion-violation?)`
- en: '**syntax**: `&error`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&error`'
- en: '**procedure**: `(make-error)`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-error)`'
- en: '**returns:** a condition of type `&error`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为`&error`的条件'
- en: '**procedure**: `(error? *obj*)`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&error`, `#f` otherwise'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是类型为`&error`的条件，则返回`#t`，否则返回`#f`。'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type indicate that an error has occurred with the program's
    interaction with its operating environment, such as the failure of an attempt
    to open a file. It is not used to describe situations in which an error in the
    program has been detected. This condition type might be defined as follows.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的条件指示程序与其操作环境的交互发生了错误，例如尝试打开文件失败。它不用于描述程序检测到错误的情况。这种条件类型可能定义如下。
- en: '`(define-condition-type &error &serious'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &error &serious`'
- en: make-error error?)`
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: make-error error?)`
- en: '**syntax**: `&warning`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&warning`'
- en: '**procedure**: `(make-warning)`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-warning)`'
- en: '**returns:** a condition of type `&warning`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为`&warning`的条件'
- en: '**procedure**: `(warning? *obj*)`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(warning? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&warning`, `#f` otherwise'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是类型为`&warning`的条件，则返回`#t`，否则返回`#f`。'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Warning conditions indicate situations that do not prevent the program from
    continuing its execution but, in some cases, might result in a more serious problem
    at some later point. For example, a compiler might use a condition of this type
    to indicate that it has processed a call to a standard procedure with the wrong
    number of arguments; this will not become a serious problem unless the call is
    actually evaluated at some later point. This condition type might be defined as
    follows.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 警告条件指示了不会阻止程序继续执行的情况，但在某些情况下，可能会在以后的某个时间点导致更严重的问题。例如，编译器可能使用这种类型的条件来指示它已经处理了对具有错误参数数量的标准过程的调用；除非在以后的某个时间点实际评估该调用，否则这不会成为一个严重问题。这种条件类型可能定义如下。
- en: '`(define-condition-type &warning &condition'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &warning &condition`'
- en: make-warning warning?)`
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: make-warning warning?)`
- en: '**syntax**: `&message`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&message`'
- en: '**procedure**: `(make-message-condition *message*)`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-message-condition *message*)`'
- en: '**returns:** a condition of type `&message`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为 `&message` 的条件'
- en: '**procedure**: `(message-condition? *obj*)`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(message-condition? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&message`, `#f` otherwise'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果 `*obj*` 是类型为 `&message` 的条件，则返回 `#t`，否则返回 `#f`'
- en: '**procedure**: `(condition-message *condition*)`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(condition-message *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `message` field'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*condition*` 的 `message` 字段的内容'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type are usually included with a `&warning` condition or
    one of the `&serious` condition subtypes to provide a more specific description
    of the exceptional situation. The `*message*` argument to the constructor may
    be any Scheme value but is typically a string. This condition type might be defined
    as follows.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的条件通常与 `&warning` 条件或 `&serious` 条件子类型之一一起包含，以提供异常情况的更具体描述。构造函数的 `*message*`
    参数可以是任何 Scheme 值，但通常是一个字符串。这种条件类型可能定义如下。
- en: '`(define-condition-type &message &condition'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &message &condition'
- en: make-message-condition message-condition?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: make-message-condition message-condition?
- en: (message condition-message))`
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: (message condition-message))`
- en: '**syntax**: `&irritants`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&irritants`'
- en: '**procedure**: `(make-irritants-condition *irritants*)`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-irritants-condition *irritants*)`'
- en: '**returns:** a condition of type `&irritants`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为 `&irritants` 的条件'
- en: '**procedure**: `(irritants-condition? *obj*)`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(irritants-condition? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&irritants`, `#f` otherwise'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果 `*obj*` 是类型为 `&irritants` 的条件，则返回 `#t`，否则返回 `#f`'
- en: '**procedure**: `(condition-irritants *condition*)`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(condition-irritants *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `irritants` field'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*condition*` 的 `irritants` 字段的内容'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type are usually included with a `&message` condition to
    provide information about Scheme values that may have caused or been materially
    involved in the exceptional situation. For example, if a procedure receives the
    wrong type of argument, it may raise an exception with a compound condition consisting
    of an assertion condition, a who condition naming the procedure, a message condition
    stating that the wrong type of argument was received, and an irritants condition
    listing the argument. The `*irritants*` argument to the constructor should be
    a list. This condition type might be defined as follows.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的条件通常与 `&message` 条件一起包含，以提供有关可能导致或实质上涉及异常情况的 Scheme 值的信息。例如，如果一个过程接收到错误类型的参数，它可能引发一个异常，其中包含一个断言条件、一个命名该过程的
    who 条件、一个说明接收到错误类型参数的 message 条件，以及一个列出参数的 irritants 条件。构造函数的 `*irritants*` 参数应该是一个列表。这种条件类型可能定义如下。
- en: '`(define-condition-type &irritants &condition'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &irritants &condition'
- en: make-irritants-condition irritants-condition?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: make-irritants-condition irritants-condition?
- en: (irritants condition-irritants))`
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (irritants condition-irritants))`
- en: '**syntax**: `&who`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&who`'
- en: '**procedure**: `(make-who-condition *who*)`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-who-condition *who*)`'
- en: '**returns:** a condition of type `&who`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为 `&who` 的条件'
- en: '**procedure**: `(who-condition? *obj*)`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(who-condition? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&who`, `#f` otherwise'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果 `*obj*` 是类型为 `&who` 的条件，则返回 `#t`，否则返回 `#f`'
- en: '**procedure**: `(condition-who *condition*)`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(condition-who *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `who` field'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*condition*` 的 `who` 字段的内容'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type are often included with a `&message` condition to identify
    the syntactic form or procedure that detected the error. The `*who*` argument
    to the constructor should be a symbol or string. This condition type might be
    defined as follows.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的条件经常与 `&message` 条件一起包含，以识别检测到错误的语法形式或过程。构造函数的 `*who*` 参数应该是一个符号或字符串。这种条件类型可能定义如下。
- en: '`(define-condition-type &who &condition'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &who &condition'
- en: make-who-condition who-condition?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: make-who-condition who-condition?
- en: (who condition-who))`
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: (who condition-who))
- en: '**syntax**: `&non-continuable`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&non-continuable`'
- en: '**procedure**: `(make-non-continuable-violation)`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-non-continuable-violation)`'
- en: '**returns:** a condition of type `&non-continuable`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为 `&non-continuable` 的条件'
- en: '**procedure**: `(non-continuable-violation? *obj*)`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(non-continuable-violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&non-continuable`, `#f`
    otherwise'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果 `*obj*` 是类型为 `&non-continuable` 的条件，则返回 `#t`，否则返回 `#f`'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type indicate that a non-continuable violation has occurred.
    `raise` raises an exception with this type if the current exception handler returns.
    This condition type might be defined as follows.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型条件表示发生了不可继续的违规行为。如果当前异常处理程序返回，`raise`会引发此类型的异常。此条件类型可能定义如下。
- en: '`(define-condition-type &non-continuable &violation'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &non-continuable &violation'
- en: make-non-continuable-violation
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: make-non-continuable-violation
- en: non-continuable-violation?)`
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: non-continuable-violation?)`
- en: '**syntax**: `&implementation-restriction`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&implementation-restriction`'
- en: '**procedure**: `(make-implementation-restriction-violation)`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-implementation-restriction-violation)`'
- en: '**returns:** a condition of type `&implementation-restriction`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 返回`&implementation-restriction`类型的条件'
- en: '**procedure**: `(implementation-restriction-violation? *obj*)`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(implementation-restriction-violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&implementation-restriction`,
    `#f` otherwise'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是`&implementation-restriction`类型的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: An implementation-restriction condition indicates that the program has attempted
    to exceed some limitation in the implementation, such as when the value of a fixnum
    addition operation would result in a number that exceeds the implementation's
    fixnum range. It does not normally indicate a deficiency in the implementation
    but rather a mismatch between what the program is attempting to do and what the
    implementation can support. In many cases, implementation restrictions are dictated
    by the underlying hardware. This condition type might be defined as follows.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 实现限制条件表示程序尝试超出实现的某些限制，例如当fixnum加法操作的值导致数字超出实现的fixnum范围时。通常不表示实现的缺陷，而是表示程序尝试做什么与实现支持的内容不匹配。在许多情况下，实现限制由底层硬件决定。此条件类型可能定义如下。
- en: '`(define-condition-type &implementation-restriction &violation'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &implementation-restriction &violation'
- en: make-implementation-restriction-violation
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: make-implementation-restriction-violation
- en: implementation-restriction-violation?)`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: implementation-restriction-violation?)`
- en: '**syntax**: `&lexical`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&lexical`'
- en: '**procedure**: `(make-lexical-violation)`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-lexical-violation)`'
- en: '**returns:** a condition of type `&lexical`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 返回`&lexical`类型的条件'
- en: '**procedure**: `(lexical-violation? *obj*)`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(lexical-violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&lexical`, `#f` otherwise'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是`&lexical`类型的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type indicate that a lexical error has occurred in the parsing
    of a Scheme program or datum, such as mismatched parentheses or an invalid character
    appearing within a numeric constant. This condition type might be defined as follows.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型条件表示在解析Scheme程序或数据时发生了词法错误，例如括号不匹配或在数字常量中出现无效字符。此条件类型可能定义如下。
- en: '`(define-condition-type &lexical &violation'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &lexical &violation'
- en: make-lexical-violation lexical-violation?)`
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: make-lexical-violation lexical-violation?)`
- en: '**syntax**: `&syntax`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&syntax`'
- en: '**procedure**: `(make-syntax-violation *form* *subform*)`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-syntax-violation *form* *subform*)`'
- en: '**returns:** a condition of type `&syntax`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 返回`&syntax`类型的条件'
- en: '**procedure**: `(syntax-violation? *obj*)`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(syntax-violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&syntax`, `#f` otherwise'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是`&syntax`类型的条件，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(syntax-violation-form *condition*)`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(syntax-violation-form *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `form` field'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 返回`*condition*`的`form`字段的内容'
- en: '**procedure**: `(syntax-violation-subform *condition*)`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(syntax-violation-subform *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `subform` field'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 返回`*condition*`的`subform`字段的内容'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
- en: Conditions of this type indicate that a syntax error has occurred in the parsing
    of a Scheme program. In most implementations, syntax errors are detected by the
    macro expander. Each of the `*form*` and `*subform*` arguments to `make-syntax-violation`
    should be a syntax object (Section [8.3](syntax.html#g136)) or datum, the former
    indicating the containing form and the latter indicating the specific subform.
    For example, if a duplicate formal parameter is found in a `lambda` expression,
    `*form*` might be the `lambda` expression and `*subform*` might be the duplicated
    parameter. If there is no need to identify a subform, `*subform*` should be `#f`.
    This condition type might be defined as follows.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件指示在解析Scheme程序时发生了语法错误。在大多数实现中，语法错误由宏展开器检测到。`make-syntax-violation`的每个`*form*`和`*subform*`参数应该是语法对象（第[8.3](syntax.html#g136)节）或数据，前者表示包含的形式，后者表示具体的子形式。例如，如果在`lambda`表达式中发现重复的形式参数，则`*form*`可能是`lambda`表达式，`*subform*`可能是重复的参数。如果不需要标识子形式，则`*subform*`应为`#f`。此条件类型可能定义如下。
- en: '`(define-condition-type &syntax &violation'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &syntax &violation`'
- en: make-syntax-violation syntax-violation?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-syntax-violation syntax-violation?`'
- en: (form syntax-violation-form)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: (表单 `syntax-violation-form`)
- en: (subform syntax-violation-subform))`
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: (子形式 `syntax-violation-subform))`
- en: '**syntax**: `&undefined`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `&undefined`'
- en: '**procedure**: `(make-undefined-violation)`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(make-undefined-violation)`'
- en: '**returns:** a condition of type `&undefined`'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个类型为`&undefined`的条件'
- en: '**procedure**: `(undefined-violation? *obj*)`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(undefined-violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&undefined`, `#f` otherwise'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 如果`*obj*`是类型为`&undefined`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs conditions)`, `(rnrs)`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs conditions)`，`(rnrs)`'
- en: An undefined condition indicates an attempt to reference an unbound variable.
    This condition type might be defined as follows.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义条件表示尝试引用未绑定变量。此条件类型可能定义如下。
- en: '`(define-condition-type &undefined &violation'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &undefined &violation`'
- en: make-undefined-violation undefined-violation?)`
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-undefined-violation undefined-violation?)`'
- en: The next several condition types describe conditions that occur when input or
    output operations fail in some manner.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几种条件类型描述了在输入或输出操作以某种方式失败时发生的条件。
- en: '**syntax**: `&i/o`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `&i/o`'
- en: '**procedure**: `(make-i/o-error)`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(make-i/o-error)`'
- en: '**returns:** a condition of type `&i/o`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个类型为`&i/o`的条件'
- en: '**procedure**: `(i/o-error? *obj*)`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(i/o-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o`, `#f` otherwise'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 如果`*obj*`是类型为`&i/o`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: A condition of type `&i/o` indicates that an input/output error of some sort
    has occurred. Conditions of this type typically occur as one of the more specific
    subtypes described below. This condition type might be defined as follows.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`&i/o`的条件表示发生了某种输入/输出错误。此类型的条件通常作为下面描述的更具体的子类型之一发生。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o &error'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o &error`'
- en: make-i/o-error i/o-error?)`
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-i/o-error i/o-error?)`'
- en: '**syntax**: `&i/o-read`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `&i/o-read`'
- en: '**procedure**: `(make-i/o-read-error)`'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(make-i/o-read-error)`'
- en: '**returns:** a condition of type `&i/o-read`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个类型为`&i/o-read`的条件'
- en: '**procedure**: `(i/o-read-error? *obj*)`'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(i/o-read-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-read`, `#f` otherwise'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 如果`*obj*`是类型为`&i/o-read`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: This condition type indicates that an error has occurred while reading from
    a port. This condition type might be defined as follows.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件表示在从端口读取时发生了错误。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-read &i/o'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-read &i/o`'
- en: make-i/o-read-error i/o-read-error?)`
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-i/o-read-error i/o-read-error?)`'
- en: '**syntax**: `&i/o-write`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：** `&i/o-write`'
- en: '**procedure**: `(make-i/o-write-error)`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(make-i/o-write-error)`'
- en: '**returns:** a condition of type `&i/o-write`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 一个类型为`&i/o-write`的条件'
- en: '**procedure**: `(i/o-write-error? *obj*)`'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(i/o-write-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-write`, `#f` otherwise'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 如果`*obj*`是类型为`&i/o-write`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: This condition type indicates that an error has occurred while writing to a
    port. This condition type might be defined as follows.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件类型指示在向端口写入时发生错误。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-write &i/o'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-write &i/o'
- en: make-i/o-write-error i/o-write-error?)`
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-write-error i/o-write-error?)`
- en: '**syntax**: `&i/o-invalid-position`'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`&i/o-invalid-position`'
- en: '**procedure**: `(make-i/o-invalid-position-error *position*)`'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-i/o-invalid-position-error *position*)`'
- en: '**returns:** a condition of type `&i/o-invalid-position`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：类型为`&i/o-invalid-position`的条件'
- en: '**procedure**: `(i/o-invalid-position-error? *obj*)`'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-invalid-position-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-invalid-position`,
    `#f` otherwise'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*obj*`是类型为`&i/o-invalid-position`的条件，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(i/o-error-position *condition*)`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-error-position *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `position` field'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：`*condition*`的`position`字段的内容'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: This condition type indicates an attempt to set a port's position to a position
    that is out of range for the underlying file or other object. The `*position*`
    argument to the constructor should be the invalid position. This condition type
    might be defined as follows.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件类型指示尝试将端口位置设置为底层文件或其他对象范围之外的位置。构造函数的`*position*`参数应为无效位置。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-invalid-position &i/o'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-invalid-position &i/o'
- en: make-i/o-invalid-position-error
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-invalid-position-error
- en: i/o-invalid-position-error?
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: i/o-invalid-position-error?
- en: (position i/o-error-position))`
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: (position i/o-error-position))`
- en: '**syntax**: `&i/o-filename`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`&i/o-filename`'
- en: '**procedure**: `(make-i/o-filename-error *filename*)`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-i/o-filename-error *filename*)`'
- en: '**returns:** a condition of type `&i/o-filename`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：类型为`&i/o-filename`的条件'
- en: '**procedure**: `(i/o-filename-error? *obj*)`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-filename-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-filename`, `#f` otherwise'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*obj*`是类型为`&i/o-filename`的条件，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(i/o-error-filename *condition*)`'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-error-filename *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `filename` field'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：`*condition*`的`filename`字段的内容'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: This condition type indicates an input/output error that occurred while operating
    on a file. The `*filename*` argument to the constructor should be the name of
    the file. This condition type might be defined as follows.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件类型指示在操作文件时发生的输入/输出错误。构造函数的`*filename*`参数应为文件名。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-filename &i/o'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-filename &i/o'
- en: make-i/o-filename-error i/o-filename-error?
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-filename-error i/o-filename-error?
- en: (filename i/o-error-filename))`
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: (filename i/o-error-filename))`
- en: '**syntax**: `&i/o-file-protection`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`&i/o-file-protection`'
- en: '**procedure**: `(make-i/o-file-protection-error *filename*)`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-i/o-file-protection-error *filename*)`'
- en: '**returns:** a condition of type `&i/o-file-protection`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：类型为`&i/o-file-protection`的条件'
- en: '**procedure**: `(i/o-file-protection-error? *obj*)`'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-file-protection-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-file-protection`,
    `#f` otherwise'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*obj*`是类型为`&i/o-file-protection`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: A condition of this type indicates that an attempt has been made to perform
    some input/output operation on a file for which the program does not have the
    proper permission. This condition type might be defined as follows.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件指示尝试对程序没有适当权限的文件执行某些输入/输出操作。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-file-protection &i/o-filename'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-file-protection &i/o-filename'
- en: make-i/o-file-protection-error
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-file-protection-error
- en: i/o-file-protection-error?)`
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: i/o-file-protection-error?)`
- en: '**syntax**: `&i/o-file-is-read-only`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`&i/o-file-is-read-only`'
- en: '**procedure**: `(make-i/o-file-is-read-only-error *filename*)`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-i/o-file-is-read-only-error *filename*)`'
- en: '**returns:** a condition of type `&i/o-file-is-read-only`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：类型为`&i/o-file-is-read-only`的条件'
- en: '**procedure**: `(i/o-file-is-read-only-error? *obj*)`'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-file-is-read-only-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-file-is-read-only`,
    `#f` otherwise'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*obj*`是类型为`&i/o-file-is-read-only`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: A condition of this type indicates an attempt to treat as writeable a read-only
    file. This condition type might be defined as follows.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件指示试图将只读文件视为可写文件的尝试。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-file-is-read-only &i/o-file-protection'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-file-is-read-only &i/o-file-protection'
- en: make-i/o-file-is-read-only-error
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-file-is-read-only-error
- en: i/o-file-is-read-only-error?)`
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: i/o-file-is-read-only-error?)`
- en: '**syntax**: `&i/o-file-already-exists`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`&i/o-file-already-exists`'
- en: '**procedure**: `(make-i/o-file-already-exists-error *filename*)`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-i/o-file-already-exists-error *filename*)`'
- en: '**returns:** a condition of type `&i/o-file-already-exists`'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：类型为`&i/o-file-already-exists`的条���'
- en: '**procedure**: `(i/o-file-already-exists-error? *obj*)`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-file-already-exists-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-file-already-exists`,
    `#f` otherwise'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*obj*`是类型为`&i/o-file-already-exists`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: A condition of this type indicates a situation in which an operation on a file
    failed because the file already exists, e.g., an attempt is made to open an existing
    file for output without the `no-fail` file option. This condition type might be
    defined as follows.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件指示文件操作失败的情况，因为文件已经存在，例如，尝试打开现有文件进行输出而没有`no-fail`文件选项。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-file-already-exists &i/o-filename'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-file-already-exists &i/o-filename'
- en: make-i/o-file-already-exists-error
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-file-already-exists-error
- en: i/o-file-already-exists-error?)`
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: i/o-file-already-exists-error?)`
- en: '**syntax**: `&i/o-file-does-not-exist`'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`&i/o-file-does-not-exist`'
- en: '**procedure**: `(make-i/o-file-does-not-exist-error *filename*)`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-i/o-file-does-not-exist-error *filename*)`'
- en: '**returns:** a condition of type `&i/o-file-does-not-exist`'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：类型为`&i/o-file-does-not-exist`的条件'
- en: '**procedure**: `(i/o-file-does-not-exist-error? *obj*)`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-file-does-not-exist-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-file-does-not-exist`,
    `#f` otherwise'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*obj*`是类型为`&i/o-file-does-not-exist`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: A condition of this type indicates a situation in which an operation on a file
    failed because the file does not exist, e.g., an attempt is made to open a nonexistent
    file for input only. This condition type might be defined as follows.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件指示文件操作失败的情况，因为文件不存在，例如，尝试仅打开不存在的文件进行输入。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-file-does-not-exist &i/o-filename'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-file-does-not-exist &i/o-filename'
- en: make-i/o-file-does-not-exist-error
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 创建-i/o-文件不存在错误
- en: i/o-file-does-not-exist-error?)`
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: i/o-file-does-not-exist-error?)`
- en: '**syntax**: `&i/o-port`'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`&i/o-port`'
- en: '**procedure**: `(make-i/o-port-error *pobj*)`'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-i/o-port-error *pobj*)`'
- en: '**returns:** a condition of type `&i/o-port`'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：类型为`&i/o-port`的条件'
- en: '**procedure**: `(i/o-port-error? *obj*)`'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-port-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-port`, `#f` otherwise'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*obj*`是类型为`&i/o-port`的条件，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(i/o-error-port *condition*)`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-error-port *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `pobj` field'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：`*condition*`的`pobj`字段的内容'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs io simple)`, `(rnrs files)`, `(rnrs)`'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs io simple)`，`(rnrs files)`，`(rnrs)`'
- en: A condition of this type is usually included with a condition of one of the
    other `&i/o` subtypes to indicate the port involved in the exceptional situation,
    if a port is involved. The `*pobj*` argument to the constructor should be the
    port. This condition type might be defined as follows.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件通常与其他`&i/o`子类型的条件一起包含，以指示异常情况中涉及的端口（如果涉及端口）。构造函数的`*pobj*`参数应为端口。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-port &i/o'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-port &i/o'
- en: make-i/o-port-error i/o-port-error?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-port-error i/o-port-error?
- en: (pobj i/o-error-port))`
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: (pobj i/o-error-port))
- en: '**syntax**: `&i/o-decoding`'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`&i/o-decoding`'
- en: '**procedure**: `(make-i/o-decoding-error *pobj*)`'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(make-i/o-decoding-error *pobj*)`'
- en: '**returns:** a condition of type `&i/o-decoding`'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：类型为`&i/o-decoding`的条件'
- en: '**procedure**: `(i/o-decoding-error? *obj*)`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(i/o-decoding-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-decoding`, `#f` otherwise'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*obj*`是类型为`&i/o-decoding`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs io ports)`，`(rnrs)`'
- en: A condition of this type indicates that a decoding error has occurred during
    the transcoding of bytes to characters. The `*pobj*` argument to the constructor
    should be the port involved, if any. The port should be positioned past the invalid
    encoding. This condition type might be defined as follows.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件指示在将字节转码为字符期间发生了解码错误。构造函数的`*pobj*`参数应该是涉及的端口（如果有的话）。端口应该定位在无效编码之后。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-decoding &i/o-port'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-decoding &i/o-port'
- en: make-i/o-decoding-error i/o-decoding-error?)`
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-decoding-error i/o-decoding-error?)`
- en: '**syntax**: `&i/o-encoding`'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&i/o-encoding`'
- en: '**procedure**: `(make-i/o-encoding-error *pobj* *cobj*)`'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-i/o-encoding-error *pobj* *cobj*)`'
- en: '**returns:** a condition of type `&i/o-encoding`'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为`&i/o-encoding`的条件'
- en: '**procedure**: `(i/o-encoding-error? *obj*)`'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(i/o-encoding-error? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&i/o-encoding`, `#f` otherwise'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是类型为`&i/o-encoding`的条件，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(i/o-encoding-error-char *condition*)`'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(i/o-encoding-error-char *condition*)`'
- en: '**returns:** the contents of `*condition*`''s `cobj` field'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*condition*`的`cobj`字段的内容'
- en: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs io ports)`, `(rnrs)`'
- en: A condition of this type indicates that an encoding error has occurred during
    the transcoding of characters to bytes. The `*pobj*` argument to the constructor
    should be the port involved, if any, and the `*cobj*` argument should be the character
    for which the encoding failed. This condition type might be defined as follows.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型的条件指示在将字符转码为字节期间发生了编码错误。构造函数的`*pobj*`参数应该是涉及的端口（如果有的话），`*cobj*`参数应该是编码失败的字符。此条件类型可能定义如下。
- en: '`(define-condition-type &i/o-encoding &i/o-port'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &i/o-encoding &i/o-port'
- en: make-i/o-encoding-error i/o-encoding-error?
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: make-i/o-encoding-error i/o-encoding-error?
- en: (cobj i/o-encoding-error-char))`
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: (cobj i/o-encoding-error-char))`
- en: The final two condition types describe conditions that occur when implementations
    are required to produce a NaN or infinity but have no representations for these
    values.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两种条件类型描述了当实现需要生成 NaN 或无穷大但没有这些值的表示时发生的条件。
- en: '**syntax**: `&no-infinities`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&no-infinities`'
- en: '**procedure**: `(make-no-infinities-violation)`'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-no-infinities-violation)`'
- en: '**returns:** a condition of type `&no-infinities`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为`&no-infinities`的条件'
- en: '**procedure**: `(no-infinities-violation? *obj*)`'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(no-infinities-violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&no-infinities`, `#f`
    otherwise'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是类型为`&no-infinities`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
- en: This condition indicates that the implementation has no representation for infinity.
    This condition type might be defined as follows.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件指示实现没有无穷大的表示。此条件类型可能定义如下。
- en: '`(define-condition-type &no-infinities &implementation-restriction'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &no-infinities &implementation-restriction'
- en: make-no-infinities-violation
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: make-no-infinities-violation
- en: no-infinities-violation?)`
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: no-infinities-violation?)`
- en: '**syntax**: `&no-nans`'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `&no-nans`'
- en: '**procedure**: `(make-no-nans-violation)`'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-no-nans-violation)`'
- en: '**returns:** a condition of type `&no-nans`'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 类型为`&no-nans`的条件'
- en: '**procedure**: `(no-nans-violation? *obj*)`'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(no-nans-violation? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a condition of type `&no-nans`, `#f` otherwise'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是类型为`&no-nans`的条件，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
- en: This condition indicates that the implementation has no representation for NaN.
    This condition type might be defined as follows.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件指示实现没有 NaN 的表示。此条件类型可能定义如下。
- en: '`(define-condition-type &no-nans &implementation-restriction'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-condition-type &no-nans &implementation-restriction'
- en: make-no-nans-violation no-nans-violation?)`
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: make-no-nans-violation no-nans-violation?)`
