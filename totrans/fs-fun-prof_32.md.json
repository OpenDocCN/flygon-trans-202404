["```\ntype Calculate = CalculatorInput -> CalculatorOutput \n```", "```\ntype Calculate = CalculatorInput * CalculatorState -> CalculatorState \n```", "```\ntype Calculate = CalculatorInput * CalculatorState -> CalculatorState \nand CalculatorState = {\n    display: CalculatorDisplay\n    } \n```", "```\ntype Calculate = CalculatorInput * CalculatorState -> CalculatorState \nand CalculatorState = {\n    display: CalculatorDisplay\n    }\nand CalculatorDisplay = string \n```", "```\ntype Calculate = CalculatorInput * CalculatorState -> CalculatorState \ntype CalculatorState = {\n    display: CalculatorDisplay\n    }\ntype CalculatorDisplay = string \n```", "```\n// as above\nand CalculatorInput = \n    | Zero | One | Two | Three | Four \n    | Five | Six | Seven | Eight | Nine\n    | DecimalSeparator\n    | Add | Subtract | Multiply | Divide\n    | Equals | Clear \n```", "```\ntype UpdateDisplayFromDigit = CalculatorDigit * CalculatorDisplay -> CalculatorDisplay \n```", "```\ntype CalculatorDigit = \n    | Zero | One | Two | Three | Four \n    | Five | Six | Seven | Eight | Nine\n    | DecimalSeparator \n```", "```\nlet convertInputToDigit (input:CalculatorInput) =\n    match input with\n        | Zero -> CalculatorDigit.Zero\n        | One -> CalculatorDigit.One\n        | etc\n        | Add -> ???\n        | Clear -> ??? \n```", "```\ntype CalculatorInput = \n    | Digit of CalculatorDigit\n    | Add | Subtract | Multiply | Divide\n    | Equals | Clear \n```", "```\ntype Calculate = CalculatorInput * CalculatorState -> CalculatorState \nand CalculatorState = {\n    display: CalculatorDisplay\n    }\nand CalculatorDisplay = string\nand CalculatorInput = \n    | Digit of CalculatorDigit\n    | Op of CalculatorMathOp\n    | Action of CalculatorAction\nand CalculatorDigit = \n    | Zero | One | Two | Three | Four \n    | Five | Six | Seven | Eight | Nine\n    | DecimalSeparator\nand CalculatorMathOp = \n    | Add | Subtract | Multiply | Divide\nand CalculatorAction = \n    | Equals | Clear\n\ntype UpdateDisplayFromDigit = CalculatorDigit * CalculatorDisplay -> CalculatorDisplay \n```", "```\ntype DoMathOperation = CalculatorMathOp * Number * Number -> Number \n```", "```\ntype DoMathOperation = CalculatorMathOp * Number * Number -> Number\nand Number = float \n```", "```\ntype DoMathOperation = CalculatorMathOp * Number * Number -> MathOperationResult \nand Number = float\nand MathOperationResult = \n    | Success of Number \n    | Failure of MathOperationError\nand MathOperationError = \n    | DivideByZero \n```", "```\ntype GetDisplayNumber = CalculatorDisplay -> Number \n```", "```\ntype GetDisplayNumber = CalculatorDisplay -> Number option \n```", "```\ntype SetDisplayNumber = Number -> CalculatorDisplay \n```", "```\nand CalculatorState = {\n    display: CalculatorDisplay\n    pendingOp: CalculatorMathOp \n    pendingNumber: Number\n    } \n```", "```\nand CalculatorState = {\n    display: CalculatorDisplay\n    pendingOp: CalculatorMathOp option\n    pendingNumber: Number option\n    } \n```", "```\nand CalculatorState = {\n    display: CalculatorDisplay\n    pendingOp: (CalculatorMathOp * Number) option\n    } \n```", "```\ntype InitState = unit -> CalculatorState \n```", "```\ntype CalculatorServices = {\n    updateDisplayFromDigit: UpdateDisplayFromDigit \n    doMathOperation: DoMathOperation \n    getDisplayNumber: GetDisplayNumber \n    setDisplayNumber: SetDisplayNumber \n    initState: InitState \n    } \n```", "```\ntype Calculate = CalculatorInput * CalculatorState -> CalculatorState \nand CalculatorState = {\n    display: CalculatorDisplay\n    pendingOp: (CalculatorMathOp * Number) option\n    }\nand CalculatorDisplay = string\nand CalculatorInput = \n    | Digit of CalculatorDigit\n    | Op of CalculatorMathOp\n    | Action of CalculatorAction\nand CalculatorDigit = \n    | Zero | One | Two | Three | Four \n    | Five | Six | Seven | Eight | Nine\n    | DecimalSeparator\nand CalculatorMathOp = \n    | Add | Subtract | Multiply | Divide\nand CalculatorAction = \n    | Equals | Clear\nand UpdateDisplayFromDigit = \n    CalculatorDigit * CalculatorDisplay -> CalculatorDisplay\nand DoMathOperation = \n    CalculatorMathOp * Number * Number -> MathOperationResult \nand Number = float\nand MathOperationResult = \n    | Success of Number \n    | Failure of MathOperationError\nand MathOperationError = \n    | DivideByZero\n\ntype GetDisplayNumber = \n    CalculatorDisplay -> Number option\ntype SetDisplayNumber = \n    Number -> CalculatorDisplay \n\ntype InitState = \n    unit -> CalculatorState \n\ntype CalculatorServices = {\n    updateDisplayFromDigit: UpdateDisplayFromDigit \n    doMathOperation: DoMathOperation \n    getDisplayNumber: GetDisplayNumber \n    setDisplayNumber: SetDisplayNumber \n    initState: InitState \n    } \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    fun (input,state) -> \n        match input with\n        | Digit d ->\n            let newState = // do something\n            newState //return\n        | Op op ->\n            let newState = // do something\n            newState //return\n        | Action Clear ->\n            let newState = // do something\n            newState //return\n        | Action Equals ->\n            let newState = // do something\n            newState //return \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    fun (input,state) -> \n        match input with\n            // code \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    let innerCalculate (input,state) = \n        match input with\n            // code\n    innerCalculate // return the inner function \n```", "```\n// create the services\nlet services = CalculatorServices.createServices()\n\n// inject the services into the \"factory\" method\nlet calculate = CalculatorImplementation.createCalculate services\n\n// the returned \"calculate\" function is of type Calculate \n// and can be passed into the UI, for example\n\n// create the UI and run it\nlet form = new CalculatorUI.CalculatorForm(calculate)\nform.Show() \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    fun (input,state) -> \n        match input with\n        | Digit d ->\n            let newState = updateDisplayFromDigit services d state\n            newState //return \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    fun (input,state) -> \n        match input with\n        | Digit d ->\n            updateDisplayFromDigit services d state \n```", "```\nlet updateDisplayFromDigit services digit state =\n    let newDisplay = services.updateDisplayFromDigit (digit,state.display)\n    let newState = {state with display=newDisplay}\n    newState //return \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    fun (input,state) -> \n        match input with\n        | Digit d -> // as above\n        | Op op -> // to do\n        | Action Clear ->\n            let newState = services.initState()\n            newState //return\n        | Action Equals ->\n            let newState = updateDisplayFromPendingOp services state\n            newState //return \n```", "```\n// First version of updateDisplayFromPendingOp \n// * very imperative and ugly\nlet updateDisplayFromPendingOp services state =\n    if state.pendingOp.IsSome then\n        let op,pendingNumber = state.pendingOp.Value\n        let currentNumberOpt = services.getDisplayNumber state.display\n        if currentNumberOpt.IsSome then\n            let currentNumber = currentNumberOpt.Value \n            let result = services.doMathOperation (op,pendingNumber,currentNumber)\n            match result with\n            | Success resultNumber ->\n                let newDisplay = services.setDisplayNumber resultNumber \n                let newState = {display=newDisplay; pendingOp=None}\n                newState //return\n            | Failure error -> \n                state // original state is untouched\n        else\n            state // original state is untouched\n    else\n        state // original state is untouched \n```", "```\nlet updateDisplayFromPendingOp services state =\n    let result =\n        state.pendingOp\n        |> Option.bind ??? \n```", "```\nlet updateDisplayFromPendingOp services state =\n    let result =\n        state.pendingOp\n        |> Option.bind ???\n    defaultArg result state \n```", "```\nlet updateDisplayFromPendingOp services state =\n    state.pendingOp\n    |> Option.bind ???\n    |> defaultArg <| state \n```", "```\nlet result = \n    state.pendingOp\n    |> Option.bind (fun (op,pendingNumber) ->\n        let currentNumberOpt = services.getDisplayNumber state.display\n        // code\n        ) \n```", "```\nlet executeOp (op,pendingNumber) = \n    let currentNumberOpt = services.getDisplayNumber state.display\n    /// etc\n\nlet result = \n    state.pendingOp\n    |> Option.bind executeOp \n```", "```\nlet doSomething input = return an output option\nlet doSomethingElse input = return an output option\nlet doAThirdThing input = return an output option\n\nstate.pendingOp\n|> Option.bind doSomething\n|> Option.bind doSomethingElse\n|> Option.bind doAThirdThing \n```", "```\nlet getCurrentNumber (op,pendingNumber) = \n    let currentNumberOpt = services.getDisplayNumber state.display\n    currentNumberOpt \n    |> Option.map (fun currentNumber -> (op,pendingNumber,currentNumber))\n\nlet result = \n    state.pendingOp\n    |> Option.bind getCurrentNumber\n    |> Option.bind ??? \n```", "```\nlet getCurrentNumber (op,pendingNumber) = \n    state.display\n    |> services.getDisplayNumber \n    |> Option.map (fun currentNumber -> (op,pendingNumber,currentNumber)) \n```", "```\nlet doMathOp (op,pendingNumber,currentNumber) = \n    let result = services.doMathOperation (op,pendingNumber,currentNumber)\n    match result with\n    | Success resultNumber ->\n        let newDisplay = services.setDisplayNumber resultNumber \n        let newState = {display=newDisplay; pendingOp=None}\n        Some newState //return something\n    | Failure error -> \n        None // failed \n```", "```\ntype SetDisplayError = MathOperationError -> CalculatorDisplay \n```", "```\ntype CalculatorServices = {\n    // as before\n    setDisplayNumber: SetDisplayNumber \n    setDisplayError: SetDisplayError \n    initState: InitState \n    } \n```", "```\nlet doMathOp (op,pendingNumber,currentNumber) = \n    let result = services.doMathOperation (op,pendingNumber,currentNumber)\n    let newDisplay = \n        match result with\n        | Success resultNumber ->\n            services.setDisplayNumber resultNumber \n        | Failure error -> \n            services.setDisplayError error\n    let newState = {display=newDisplay;pendingOp=None}\n    Some newState //return something \n```", "```\n// helper to make defaultArg better for piping\nlet ifNone defaultValue input = \n    // just reverse the parameters!\n    defaultArg input defaultValue \n\n// Third version of updateDisplayFromPendingOp \n// * Updated to show errors on display in Failure case\n// * replaces awkward defaultArg syntax\nlet updateDisplayFromPendingOp services state =\n    // helper to extract CurrentNumber\n    let getCurrentNumber (op,pendingNumber) = \n        state.display\n        |> services.getDisplayNumber \n        |> Option.map (fun currentNumber -> (op,pendingNumber,currentNumber))\n\n    // helper to do the math op\n    let doMathOp (op,pendingNumber,currentNumber) = \n        let result = services.doMathOperation (op,pendingNumber,currentNumber)\n        let newDisplay = \n            match result with\n            | Success resultNumber ->\n                services.setDisplayNumber resultNumber \n            | Failure error -> \n                services.setDisplayError error\n        let newState = {display=newDisplay;pendingOp=None}\n        Some newState //return something\n\n    // connect all the helpers\n    state.pendingOp\n    |> Option.bind getCurrentNumber\n    |> Option.bind doMathOp \n    |> ifNone state // return original state if anything fails \n```", "```\ntype MaybeBuilder() =\n    member this.Bind(x, f) = Option.bind f x\n    member this.Return(x) = Some x\n\nlet maybe = new MaybeBuilder() \n```", "```\nlet doSomething input = return an output option\nlet doSomethingElse input = return an output option\nlet doAThirdThing input = return an output option\n\nlet finalResult = maybe {\n    let! result1 = doSomething\n    let! result2 = doSomethingElse result1\n    let! result3 = doAThirdThing result2\n    return result3\n    } \n```", "```\n// Fourth version of updateDisplayFromPendingOp \n// * Changed to use \"maybe\" computation expression\nlet updateDisplayFromPendingOp services state =\n\n    // helper to do the math op\n    let doMathOp (op,pendingNumber,currentNumber) = \n        let result = services.doMathOperation (op,pendingNumber,currentNumber)\n        let newDisplay = \n            match result with\n            | Success resultNumber ->\n                services.setDisplayNumber resultNumber \n            | Failure error -> \n                services.setDisplayError error\n        {display=newDisplay;pendingOp=None}\n\n    // fetch the two options and combine them\n    let newState = maybe {\n        let! (op,pendingNumber) = state.pendingOp\n        let! currentNumber = services.getDisplayNumber state.display\n        return doMathOp (op,pendingNumber,currentNumber)\n        }\n    newState |> ifNone state \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    fun (input,state) -> \n        match input with\n        | Digit d -> // as above\n        | Op op ->\n            let newState1 = updateDisplayFromPendingOp services state\n            let newState2 = addPendingMathOp services op newState1 \n            newState2 //return \n```", "```\n// First version of addPendingMathOp \n// * very imperative and ugly\nlet addPendingMathOp services op state = \n    let currentNumberOpt = services.getDisplayNumber state.display\n    if currentNumberOpt.IsSome then \n        let currentNumber = currentNumberOpt.Value \n        let pendingOp = Some (op,currentNumber)\n        let newState = {state with pendingOp=pendingOp}\n        newState //return\n    else                \n        state // original state is untouched \n```", "```\n// Second version of addPendingMathOp \n// * Uses \"map\" and helper function\nlet addPendingMathOp services op state = \n    let newStateWithPending currentNumber =\n        let pendingOp = Some (op,currentNumber)\n        {state with pendingOp=pendingOp}\n\n    state.display\n    |> services.getDisplayNumber \n    |> Option.map newStateWithPending \n    |> ifNone state \n```", "```\n// Third version of addPendingMathOp \n// * Uses \"maybe\"\nlet addPendingMathOp services op state = \n    maybe {            \n        let! currentNumber = \n            state.display |> services.getDisplayNumber \n        let pendingOp = Some (op,currentNumber)\n        return {state with pendingOp=pendingOp}\n        }\n    |> ifNone state // return original state if anything fails \n```", "```\nlet updateDisplayFromDigit services digit state =\n    let newDisplay = services.updateDisplayFromDigit (digit,state.display)\n    let newState = {state with display=newDisplay}\n    newState //return\n\nlet updateDisplayFromPendingOp services state =\n\n    // helper to do the math op\n    let doMathOp (op,pendingNumber,currentNumber) = \n        let result = services.doMathOperation (op,pendingNumber,currentNumber)\n        let newDisplay = \n            match result with\n            | Success resultNumber ->\n                services.setDisplayNumber resultNumber \n            | Failure error -> \n                services.setDisplayError error\n        {display=newDisplay;pendingOp=None}\n\n    // fetch the two options and combine them\n    let newState = maybe {\n        let! (op,pendingNumber) = state.pendingOp\n        let! currentNumber = services.getDisplayNumber state.display\n        return doMathOp (op,pendingNumber,currentNumber)\n        }\n    newState |> ifNone state\n\nlet addPendingMathOp services op state = \n    maybe {            \n        let! currentNumber = \n            state.display |> services.getDisplayNumber \n        let pendingOp = Some (op,currentNumber)\n        return {state with pendingOp=pendingOp}\n        }\n    |> ifNone state // return original state if anything fails\n\nlet createCalculate (services:CalculatorServices) :Calculate = \n    fun (input,state) -> \n        match input with\n        | Digit d ->\n            let newState = updateDisplayFromDigit services d state\n            newState //return\n        | Op op ->\n            let newState1 = updateDisplayFromPendingOp services state\n            let newState2 = addPendingMathOp services op newState1 \n            newState2 //return\n        | Action Clear ->\n            let newState = services.initState()\n            newState //return\n        | Action Equals ->\n            let newState = updateDisplayFromPendingOp services state\n            newState //return \n```", "```\n// ================================================\n// Implementation of CalculatorConfiguration\n// ================================================ \nmodule CalculatorConfiguration =\n\n    // A record to store configuration options\n    // (e.g. loaded from a file or environment)\n    type Configuration = {\n        decimalSeparator : string\n        divideByZeroMsg : string\n        maxDisplayLength: int\n        }\n\n    let loadConfig() = {\n        decimalSeparator = \n            System.Globalization.CultureInfo.CurrentCulture.NumberFormat.CurrencyDecimalSeparator\n        divideByZeroMsg = \"ERR-DIV0\" \n        maxDisplayLength = 10\n        }\n\n// ================================================\n// Implementation of CalculatorServices \n// ================================================ \nmodule CalculatorServices =\n    open CalculatorDomain\n    open CalculatorConfiguration\n\n    let updateDisplayFromDigit (config:Configuration) :UpdateDisplayFromDigit = \n        fun (digit, display) ->\n\n        // determine what character should be appended to the display\n        let appendCh= \n            match digit with\n            | Zero -> \n                // only allow one 0 at start of display\n                if display=\"0\" then \"\" else \"0\"\n            | One -> \"1\"\n            | Two -> \"2\"\n            | Three-> \"3\"\n            | Four -> \"4\"\n            | Five -> \"5\"\n            | Six-> \"6\"\n            | Seven-> \"7\"\n            | Eight-> \"8\"\n            | Nine-> \"9\"\n            | DecimalSeparator -> \n                if display=\"\" then \n                    // handle empty display with special case\n                    \"0\" + config.decimalSeparator  \n                else if display.Contains(config.decimalSeparator) then \n                    // don't allow two decimal separators\n                    \"\" \n                else \n                    config.decimalSeparator\n\n        // ignore new input if there are too many digits\n        if (display.Length > config.maxDisplayLength) then\n            display // ignore new input\n        else\n            // append the new char\n            display + appendCh\n\n    let getDisplayNumber :GetDisplayNumber = fun display ->\n        match System.Double.TryParse display with\n        | true, d -> Some d\n        | false, _ -> None\n\n    let setDisplayNumber :SetDisplayNumber = fun f ->\n        sprintf \"%g\" f\n\n    let setDisplayError divideByZeroMsg :SetDisplayError = fun f ->\n        match f with\n        | DivideByZero -> divideByZeroMsg\n\n    let doMathOperation  :DoMathOperation = fun (op,f1,f2) ->\n        match op with\n        | Add -> Success (f1 + f2)\n        | Subtract -> Success (f1 - f2)\n        | Multiply -> Success (f1 * f2)\n        | Divide -> \n            try\n                Success (f1 / f2)\n            with\n            | :? System.DivideByZeroException -> \n                Failure DivideByZero \n\n    let initState :InitState = fun () -> \n        {\n        display=\"\"\n        pendingOp = None\n        }\n\n    let createServices (config:Configuration) = {\n        updateDisplayFromDigit = updateDisplayFromDigit config\n        doMathOperation = doMathOperation\n        getDisplayNumber = getDisplayNumber\n        setDisplayNumber = setDisplayNumber\n        setDisplayError = setDisplayError (config.divideByZeroMsg)\n        initState = initState\n        } \n```", "```\nmodule CalculatorUI =\n\n    open CalculatorDomain\n\n    type CalculatorForm(initState:InitState, calculate:Calculate) as this = \n        inherit Form()\n\n        // initialization before constructor\n        let mutable state = initState()\n        let mutable setDisplayedText = \n            fun text -> () // do nothing \n```", "```\ntype CalculatorForm(initState:InitState, calculate:Calculate) as this = \n    inherit Form()\n\n    let displayControl :Label = null \n```", "```\nmember this.CreateDisplayLabel() = \n    let display = new Label(Text=\"\",Size=displaySize,Location=getPos(0,0))\n    display.TextAlign <- ContentAlignment.MiddleRight\n    display.BackColor <- Color.White\n    this.Controls.Add(display)\n\n    // traditional style - set the field when the form has been initialized\n    displayControl <- display \n```", "```\nmember this.CreateDisplayLabel() = \n    let display = new Label(Text=\"\",Size=displaySize,Location=getPos(0,0))\n    this.Controls.Add(display)\n\n    // update the function that sets the text\n    setDisplayedText <-\n        (fun text -> display.Text <- text) \n```", "```\nmember this.CreateButtons() = \n    let sevenButton = new Button(Text=\"7\",Size=buttonSize,Location=getPos(1,0),BackColor=DigitButtonColor)\n    sevenButton |> addDigitButton Seven\n\n    let eightButton = new Button(Text=\"8\",Size=buttonSize,Location=getPos(1,1),BackColor=DigitButtonColor)\n    eightButton |> addDigitButton Eight\n\n    let nineButton = new Button(Text=\"9\",Size=buttonSize,Location=getPos(1,2),BackColor=DigitButtonColor)\n    nineButton |> addDigitButton Nine\n\n    let clearButton = new Button(Text=\"C\",Size=buttonSize,Location=getPos(1,3),BackColor=DangerButtonColor)\n    clearButton |> addActionButton Clear\n\n    let addButton = new Button(Text=\"+\",Size=doubleHeightSize,Location=getPos(1,4),BackColor=OpButtonColor)\n    addButton |> addOpButton Add \n```", "```\nlet addDigitButton digit (button:Button) =\n    button.Click.AddHandler(EventHandler(fun _ _ -> handleDigit digit))\n    this.Controls.Add(button)\n\nlet addOpButton op (button:Button) =\n    button.Click.AddHandler(EventHandler(fun _ _ -> handleOp op))\n    this.Controls.Add(button) \n```", "```\nmember this.KeyPressHandler(e:KeyPressEventArgs) =\n    match e.KeyChar with\n    | '0' -> handleDigit Zero\n    | '1' -> handleDigit One\n    | '2' -> handleDigit Two\n    | '.' | ',' -> handleDigit DecimalSeparator\n    | '+' -> handleOp Add\n    // etc \n```", "```\nlet handleInput input =\n     let newState = calculate(input,state)\n     state <- newState \n     setDisplayedText state.display \n\nlet handleDigit digit =\n     Digit digit |> handleInput \n\nlet handleOp op =\n     Op op |> handleInput \n```", "```\ntype CalculatorState = {\n    display: CalculatorDisplay\n    pendingOp: (CalculatorMathOp * Number) option\n    allowAppend: bool\n    } \n```", "```\nlet initState :InitState = fun () -> \n    {\n    display=\"\"\n    pendingOp = None\n    allowAppend = true\n    } \n```", "```\nmodule CalculatorTests =\n    open CalculatorDomain\n    open System\n\n    let config = CalculatorConfiguration.loadConfig()\n    let services = CalculatorServices.createServices config \n    let calculate = CalculatorImplementation.createCalculate services\n\n    let emptyState = services.initState()\n\n    /// Given a sequence of inputs, start with the empty state\n    /// and apply each input in turn. The final state is returned\n    let processInputs inputs = \n        // helper for fold\n        let folder state input = \n            calculate(input,state)\n\n        inputs \n        |> List.fold folder emptyState \n\n    /// Check that the state contains the expected display value\n    let assertResult testLabel expected state =\n        let actual = state.display\n        if (expected <> actual) then\n            printfn \"Test %s failed: expected=%s actual=%s\" testLabel expected actual \n        else\n            printfn \"Test %s passed\" testLabel \n\n    let ``when I input 1 + 2, I expect 3``() = \n        [Digit One; Op Add; Digit Two; Action Equals]\n        |> processInputs \n        |> assertResult \"1+2=3\" \"3\"\n\n    let ``when I input 1 + 2 + 3, I expect 6``() = \n        [Digit One; Op Add; Digit Two; Op Add; Digit Three; Action Equals]\n        |> processInputs \n        |> assertResult \"1+2+3=6\" \"6\"\n\n    // run tests\n    do \n        ``when I input 1 + 2, I expect 3``()\n        ``when I input 1 + 2 + 3, I expect 6``() \n```", "```\nlet appendCh= \n    match digit with\n    | Zero -> \n        // only allow one 0 at start of display\n        if display=\"0\" then \"\" else \"0\"\n    | One -> \"1\"\n    | // snip\n    | DecimalSeparator -> \n        if display=\"\" then \n            // handle empty display with special case\n            \"0\" + config.decimalSeparator  \n        else if display.Contains(config.decimalSeparator) then \n            // don't allow two decimal separators\n            \"\" \n        else \n            config.decimalSeparator \n```", "```\ntype State = \n    | AState \n    | BState \n    | CState \n```", "```\ntype State = \n    | AState of AStateData\n    | BState of BStateData\n    | CState\nand AStateData = \n    {something:int}\nand BStateData = \n    {somethingElse:int} \n```", "```\ntype InputEvent = \n    | XEvent\n    | YEvent of YEventData\n    | ZEvent\nand YEventData =\n    {eventData:string} \n```", "```\nlet transition (currentState,inputEvent) =\n    match currentState,inputEvent with\n    | AState, XEvent -> // new state\n    | AState, YEvent -> // new state\n    | AState, ZEvent -> // new state\n    | BState, XEvent -> // new state\n    | BState, YEvent -> // new state\n    | CState, XEvent -> // new state\n    | CState, ZEvent -> // new state \n```", "```\nlet aStateHandler stateData inputEvent = \n    match inputEvent with\n    | XEvent -> // new state\n    | YEvent _ -> // new state\n    | ZEvent -> // new state\n\nlet bStateHandler stateData inputEvent = \n    match inputEvent with\n    | XEvent -> // new state\n    | YEvent _ -> // new state\n    | ZEvent -> // new state\n\nlet cStateHandler inputEvent = \n    match inputEvent with\n    | XEvent -> // new state\n    | YEvent _ -> // new state\n    | ZEvent -> // new state\n\nlet transition (currentState,inputEvent) =\n    match currentState with\n    | AState stateData -> \n        // new state\n        aStateHandler stateData inputEvent \n    | BState stateData -> \n        // new state\n        bStateHandler stateData inputEvent \n    | CState -> \n        // new state\n        cStateHandler inputEvent \n```", "```\nlet aStateHandler stateData inputEvent = \n    match inputEvent with\n    | XEvent -> \n        // transition to B state\n        BState {somethingElse=stateData.something}\n    | YEvent _ -> \n        // stay in A state\n        AState stateData \n    | ZEvent -> \n        // transition to C state\n        CState \n\nlet bStateHandler stateData inputEvent = \n    match inputEvent with\n    | XEvent -> \n        // stay in B state\n        BState stateData \n    | YEvent _ -> \n        // transition to C state\n        CState \n\nlet cStateHandler inputEvent = \n    match inputEvent with\n    | XEvent -> \n        // stay in C state\n        CState\n    | ZEvent -> \n        // transition to B state\n        BState {somethingElse=42}\n\nlet transition (currentState,inputEvent) =\n    match currentState with\n    | AState stateData -> \n        aStateHandler stateData inputEvent \n    | BState stateData -> \n        bStateHandler stateData inputEvent \n    | CState -> \n        cStateHandler inputEvent \n```", "```\nlet bStateHandler stateData inputEvent = \n    match inputEvent with\n    | XEvent \n    | ZEvent -> \n        // stay in B state\n        BState stateData \n    | YEvent _ -> \n        // transition to C state\n        CState \n\nlet cStateHandler inputEvent = \n    match inputEvent with\n    | XEvent  \n    | YEvent _ -> \n        // stay in C state\n        CState\n    | ZEvent -> \n        // transition to B state\n        BState {somethingElse=42} \n```", "```\ntype Calculate = CalculatorInput * CalculatorState -> CalculatorState \n// five states \nand CalculatorState = \n    | ZeroState of ZeroStateData \n    | AccumulatorState of AccumulatorStateData \n    | AccumulatorWithDecimalState of AccumulatorStateData \n    | ComputedState of ComputedStateData \n    | ErrorState of ErrorStateData \n// six inputs\nand CalculatorInput = \n    | Zero \n    | Digit of NonZeroDigit\n    | DecimalSeparator\n    | MathOp of CalculatorMathOp\n    | Equals \n    | Clear\n// data associated with each state\nand ZeroStateData = \n    PendingOp option\nand AccumulatorStateData = \n    {digits:DigitAccumulator; pendingOp:PendingOp option}\nand ComputedStateData = \n    {displayNumber:Number; pendingOp:PendingOp option}\nand ErrorStateData = \n    MathOperationError \n```", "```\n// from the old design\ntype CalculatorInput = \n    | Digit of CalculatorDigit\n    | Op of CalculatorMathOp\n    | Action of CalculatorAction\n\n// from the new design \ntype CalculatorInput = \n    | Zero \n    | Digit of NonZeroDigit\n    | DecimalSeparator\n    | MathOp of CalculatorMathOp\n    | Equals \n    | Clear \n```", "```\n// from the old design\ntype CalculatorState = {\n    display: CalculatorDisplay\n    pendingOp: (CalculatorMathOp * Number) option\n    }\n\n// from the new design \ntype CalculatorState = \n    | ZeroState of ZeroStateData \n    | AccumulatorState of AccumulatorStateData \n    | AccumulatorWithDecimalState of AccumulatorStateData \n    | ComputedState of ComputedStateData \n    | ErrorState of ErrorStateData \n```", "```\nand DigitAccumulator = string\nand PendingOp = (CalculatorMathOp * Number)\nand Number = float\nand NonZeroDigit= \n    | One | Two | Three | Four \n    | Five | Six | Seven | Eight | Nine\nand CalculatorMathOp = \n    | Add | Subtract | Multiply | Divide\nand MathOperationResult = \n    | Success of Number \n    | Failure of MathOperationError\nand MathOperationError = \n    | DivideByZero \n```", "```\n// services used by the calculator itself\ntype AccumulateNonZeroDigit = NonZeroDigit * DigitAccumulator -> DigitAccumulator \ntype AccumulateZero = DigitAccumulator -> DigitAccumulator \ntype AccumulateSeparator = DigitAccumulator -> DigitAccumulator \ntype DoMathOperation = CalculatorMathOp * Number * Number -> MathOperationResult \ntype GetNumberFromAccumulator = AccumulatorStateData -> Number\n\n// services used by the UI or testing\ntype GetDisplayFromState = CalculatorState -> string\ntype GetPendingOpFromState = CalculatorState -> string\n\ntype CalculatorServices = {\n    accumulateNonZeroDigit :AccumulateNonZeroDigit \n    accumulateZero :AccumulateZero \n    accumulateSeparator :AccumulateSeparator\n    doMathOperation :DoMathOperation \n    getNumberFromAccumulator :GetNumberFromAccumulator \n    getDisplayFromState :GetDisplayFromState \n    getPendingOpFromState :GetPendingOpFromState \n    } \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    // create some local functions with partially applied services\n    let handleZeroState = handleZeroState services\n    let handleAccumulator = handleAccumulatorState services\n    let handleAccumulatorWithDecimal = handleAccumulatorWithDecimalState services\n    let handleComputed = handleComputedState services\n    let handleError = handleErrorState \n\n    fun (input,state) -> \n        match state with\n        | ZeroState stateData -> \n            handleZeroState stateData input\n        | AccumulatorState stateData -> \n            handleAccumulator stateData input\n        | AccumulatorWithDecimalState stateData -> \n            handleAccumulatorWithDecimal stateData input\n        | ComputedState stateData -> \n            handleComputed stateData input\n        | ErrorState stateData -> \n            handleError stateData input \n```", "```\nlet createCalculate (services:CalculatorServices) :Calculate = \n    fun (input,state) -> \n        match input with\n        | Digit d ->\n            let newState = updateDisplayFromDigit services d state\n            newState //return\n        | Op op ->\n            let newState1 = updateDisplayFromPendingOp services state\n            let newState2 = addPendingMathOp services op newState1 \n            newState2 //return\n        | Action Clear ->\n            let newState = services.initState()\n            newState //return\n        | Action Equals ->\n            let newState = updateDisplayFromPendingOp services state\n            newState //return \n```", "```\nlet handleZeroState services pendingOp input = \n    // create a new accumulatorStateData object that is used when transitioning to other states\n    let accumulatorStateData = {digits=\"\"; pendingOp=pendingOp}\n    match input with\n    | Zero -> \n        ZeroState pendingOp // stay in ZeroState \n    | Digit digit -> \n        accumulatorStateData \n        |> accumulateNonZeroDigit services digit \n        |> AccumulatorState  // transition to AccumulatorState \n    | DecimalSeparator -> \n        accumulatorStateData \n        |> accumulateSeparator services \n        |> AccumulatorWithDecimalState  // transition to AccumulatorWithDecimalState \n    | MathOp op -> \n        let nextOp = Some op\n        let newState = getComputationState services accumulatorStateData nextOp \n        newState  // transition to ComputedState or ErrorState\n    | Equals -> \n        let nextOp = None\n        let newState = getComputationState services accumulatorStateData nextOp \n        newState  // transition to ComputedState or ErrorState\n    | Clear -> \n        ZeroState None // transition to ZeroState and throw away any pending ops \n```", "```\nlet handleAccumulatorState services stateData input = \n    match input with\n    | Zero -> \n        stateData \n        |> accumulateZero services \n        |> AccumulatorState  // stay in AccumulatorState \n    | Digit digit -> \n        stateData \n        |> accumulateNonZeroDigit services digit \n        |> AccumulatorState  // stay in AccumulatorState \n    | DecimalSeparator -> \n        stateData \n        |> accumulateSeparator services \n        |> AccumulatorWithDecimalState  // transition to AccumulatorWithDecimalState\n    | MathOp op -> \n        let nextOp = Some op\n        let newState = getComputationState services stateData nextOp \n        newState  // transition to ComputedState or ErrorState\n    | Equals -> \n        let nextOp = None\n        let newState = getComputationState services stateData nextOp \n        newState  // transition to ComputedState or ErrorState\n    | Clear -> \n        ZeroState None // transition to ZeroState and throw away any pending op \n```", "```\nlet handleComputedState services stateData input = \n    let emptyAccumulatorStateData = {digits=\"\"; pendingOp=stateData.pendingOp}\n    match input with\n    | Zero -> \n        ZeroState stateData.pendingOp  // transition to ZeroState with any pending op\n    | Digit digit -> \n        emptyAccumulatorStateData \n        |> accumulateNonZeroDigit services digit \n        |> AccumulatorState  // transition to AccumulatorState \n    | DecimalSeparator -> \n        emptyAccumulatorStateData \n        |> accumulateSeparator services \n        |> AccumulatorWithDecimalState  // transition to AccumulatorWithDecimalState \n    | MathOp op -> \n        // replace the pending op, if any\n        let nextOp = Some op\n        replacePendingOp stateData nextOp \n    | Equals -> \n        // replace the pending op, if any\n        let nextOp = None\n        replacePendingOp stateData nextOp \n    | Clear -> \n        ZeroState None // transition to ZeroState and throw away any pending op \n```", "```\nlet accumulateNonZeroDigit services digit accumulatorData =\n    let digits = accumulatorData.digits\n    let newDigits = services.accumulateNonZeroDigit (digit,digits)\n    let newAccumulatorData = {accumulatorData with digits=newDigits}\n    newAccumulatorData // return \n```", "```\nlet getComputationState services accumulatorStateData nextOp = \n\n    // helper to create a new ComputedState from a given displayNumber \n    // and the nextOp parameter\n    let getNewState displayNumber =\n        let newPendingOp = \n            nextOp |> Option.map (fun op -> op,displayNumber )\n        {displayNumber=displayNumber; pendingOp = newPendingOp }\n        |> ComputedState\n\n    let currentNumber = \n        services.getNumberFromAccumulator accumulatorStateData \n\n    // If there is no pending op, create a new ComputedState using the currentNumber\n    let computeStateWithNoPendingOp = \n        getNewState currentNumber \n\n    maybe {\n        let! (op,previousNumber) = accumulatorStateData.pendingOp\n        let result = services.doMathOperation(op,previousNumber,currentNumber)\n        let newState =\n            match result with\n            | Success resultNumber ->\n                // If there was a pending op, create a new ComputedState using the result\n                getNewState resultNumber \n            | Failure error -> \n                error |> ErrorState\n        return newState\n        } |> ifNone computeStateWithNoPendingOp \n```", "```\nlet replacePendingOp (computedStateData:ComputedStateData) nextOp = \n    let newPending = maybe {\n        let! existing,displayNumber  = computedStateData.pendingOp\n        let! next = nextOp\n        return next,displayNumber  \n        }\n    {computedStateData with pendingOp=newPending}\n    |> ComputedState \n```"]