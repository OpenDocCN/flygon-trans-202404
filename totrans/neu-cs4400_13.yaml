- en: Semantics (= Evaluation)Tuesday, January 17th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PLAI §2](plai.pdf#chapter.2 "Interpreting Arithmetic")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Back to BNF — now, meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important feature of these BNF specifications: we can use the derivations
    to specify *meaning* (and meaning in our context is “running” a program (or “interpreting”,
    “compiling”, but we will use “evaluating”)). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this a little more formally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the completely different roles of the two `+`s and `-`s. In fact, it might
    have been more correct to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'or even using a marker to denote meta-holes in these strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: but we will avoid pretending that we’re doing that kind of string manipulation.
    (For example, it will require specifying what does it mean to return `<num>` for
    `$<num>` (involves `string->number`), and the fragments on the right side mean
    that we need to specify these as substring operations.)
  prefs: []
  type: TYPE_NORMAL
- en: Note that there’s a similar kind of informality in our BNF specifications, where
    we assume that `<foo>` refers to some terminal or non-terminal. In texts that
    require more formal specifications (for example, in RFC specifications), each
    literal part of the BNF is usually double-quoted, so we’d get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative popular notation for `eval(X)` is `[[X]]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Is there a problem with this definition? Ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the way the expression is parsed, we can get either a result of
    `2` or `-4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, be very aware of confusing subtleties which are extremely important:
    We need parens around a sub-expression only in one side, why? — When we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: we have two expressions, but one stands for an *input syntax*, and one stands
    for a real mathematical expression.
  prefs: []
  type: TYPE_NORMAL
- en: In a case of a computer implementation, the syntax on the left is (as always)
    an AE syntax, and the real expression on the right is an expression in whatever
    language we use to implement our AE language.
  prefs: []
  type: TYPE_NORMAL
- en: Like we said earlier, ambiguity is not a real problem until the actual parse
    tree matters. With `eval` it definitely matters, so we must not make it possible
    to derive any syntax in multiple ways or our evaluation will be non-deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quick exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a meaning for `<digit>`s and then `<num>`s in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Is this exactly what we want? — Depends on what we actually want…
  prefs: []
  type: TYPE_NORMAL
- en: First, there’s a bug in this code — having a BNF derivation like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'is unambiguous, but makes it hard to parse a number. We get:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Changing the order of the last rule works much better:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'and then:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As a concrete example see how you would make it work with `107`, which demonstrates
    why compositionality is important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example for free stuff that looks trivial: if we were to define the meaning
    of numbers this way, would it always work? Think an average language that does
    not give you bignums, making the above rules fail when the numbers are too big.
    In Racket, we happen to be using an integer representation for the syntax of integers,
    and both are unlimited. But what if we wanted to write a Racket compiler in C
    or a C compiler in Racket? What about a C compiler in C, where the compiler runs
    on a 64 bit machine, and the result needs to run on a 32 bit machine?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Side-note: CompositionalityTuesday, January 17th'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'being a language that is easier to to write an evaluator for leads us to an
    important concept — compositionality. This definition is easier to write an evaluator
    for, since the resulting language is compositional: the meaning of an expression
    — for example `123` — is composed out of the meaning of its two parts, which in
    this BNF are `12` and `3`. Specifically, the evaluation of `<NUM> <digit>` is
    `10 *` the evaluation of the first, plus the evaluation of the second. In the
    `<digit> <NUM>` case this is more difficult — the meaning of such a number depends
    not only on the *meaning* of the two parts, but also on the `<NUM>` *syntax*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This this case this can be tolerable, since the meaning of the expression is
    still made out of its parts — but imperative programming (when you use side effects)
    is much more problematic since it is not compositional (at least not in the obvious
    sense). This is compared to functional programming, where the meaning of an expression
    is a combination of the meanings of its subexpressions. For example, every sub-expression
    in a functional program has some known meaning, and these all make up the meaning
    of the expression that contains them — but in an imperative program we can have
    a part of the code be `x++` — and that doesn’t have a meaning by itself, at least
    not one that contributes to the meaning of the whole program in a direct way.
  prefs: []
  type: TYPE_NORMAL
- en: '(Actually, we can have a well-defined meaning for such an expression: the meaning
    is going from a world where `x` is a container of some value N, to a world where
    the same container has a different value N+1\. You can probably see now how this
    can make things more complicated. On an intuitive level — if we look at a random
    part of a functional program we can tell its meaning, so building up the meaning
    of the whole code is easy, but in an imperative program, the meaning of a random
    part is pretty much useless.)'
  prefs: []
  type: TYPE_NORMAL
