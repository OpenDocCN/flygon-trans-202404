- en: 'Reading 11: Abstract Data Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Today’s class introduces two ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representation independence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this reading, we look at a powerful idea, abstract data types, which enable
    us to separate how we use a data structure in a program from the particular form
    of the data structure itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract data types address a particularly dangerous problem: clients making
    assumptions about the type’s internal representation. We’ll see why this is dangerous
    and how it can be avoided. We’ll also discuss the classification of operations,
    and some principles of good design for abstract data types.'
  prefs: []
  type: TYPE_NORMAL
- en: Access Control in Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should already have read: **[Controlling Access to Members of a Class](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)**
    in the Java Tutorials.'
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following questions use the code below. Study it first, then answer the
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Access control A
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Access control B
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Access control C
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Access control D
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Access control E
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Access control F
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Access control G
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: What Abstraction Means
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,what_abstraction_means/jDc9Oy6QcI0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract data types are an instance of a general principle in software engineering,
    which goes by many names with slightly different shades of meaning. Here are some
    of the names that are used for this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction.** Omitting or hiding low-level details with a simpler, higher-level
    idea.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modularity.** Dividing a system into components or modules, each of which
    can be designed, implemented, tested, reasoned about, and reused separately from
    the rest of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation.** Building walls around a module (a hard shell or capsule)
    so that the module is responsible for its own internal behavior, and bugs in other
    parts of the system can’t damage its integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information hiding.** Hiding details of a module’s implementation from the
    rest of the system, so that those details can be changed later without changing
    the rest of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns.** Making a feature (or “concern”) the responsibility
    of a single module, rather than spreading it across multiple modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a software engineer, you should know these terms, because you will run into
    them frequently. The fundamental purpose of all of these ideas is to help achieve
    the three important properties that we care about in 6.005: safety from bugs,
    ease of understanding, and readiness for change.'
  prefs: []
  type: TYPE_NORMAL
- en: User-Defined Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the early days of computing, a programming language came with built-in types
    (such as integers, booleans, strings, etc.) and built-in procedures, e.g., for
    input and output. Users could define their own procedures: that’s how large programs
    were built.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A major advance in software development was the idea of abstract types: that
    one could design a programming language to allow user-defined types, too. This
    idea came out of the work of many researchers, notably Dahl (the inventor of the
    Simula language), Hoare (who developed many of the techniques we now use to reason
    about abstract types), Parnas (who coined the term information hiding and first
    articulated the idea of organizing program modules around the secrets they encapsulated),
    and here at MIT, Barbara Liskov and John Guttag, who did seminal work in the specification
    of abstract types, and in programming language support for them – and developed
    the original 6.170, the predecessor to 6.005. Barbara Liskov earned the Turing
    Award, computer science’s equivalent of the Nobel Prize, for her work on abstract
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key idea of data abstraction is that a type is characterized by the operations
    you can perform on it. A number is something you can add and multiply; a string
    is something you can concatenate and take substrings of; a boolean is something
    you can negate, and so on. In a sense, users could already define their own types
    in early programming languages: you could create a record type date, for example,
    with integer fields for day, month, and year. But what made abstract types new
    and different was the focus on operations: the user of the type would not need
    to worry about how its values were actually stored, in the same way that a programmer
    can ignore how the compiler actually stores integers. All that matters is the
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, as in many modern programming languages, the separation between built-in
    types and user-defined types is a bit blurry. The classes in java.lang, such as
    Integer and Boolean are built-in; whether you regard all the collections of java.util
    as built-in is less clear (and not very important anyway). Java complicates the
    issue by having primitive types that are not objects. The set of these types,
    such as int and boolean, cannot be extended by the user.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Abstract Data Types
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an abstract data type `Bool`. The type has the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**true** : Bool'
  prefs: []
  type: TYPE_NORMAL
- en: '**false** : Bool'
  prefs: []
  type: TYPE_NORMAL
- en: '**and** : Bool × Bool → Bool'
  prefs: []
  type: TYPE_NORMAL
- en: '**or** : Bool × Bool → Bool'
  prefs: []
  type: TYPE_NORMAL
- en: '**not** : Bool → Bool'
  prefs: []
  type: TYPE_NORMAL
- en: … where the first two operations construct the two values of the type, and the
    last three operations have the usual meanings of logical *and*, logical *or*,
    and logical *not* on those values.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following are possible ways that `Bool` might be implemented, and
    still be able to satisfy the specs of the operations? Choose all that apply.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Classifying Types and Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,classifying_types_and_operations/EpUaAvn8X7A)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Types, whether built-in or user-defined, can be classified as **mutable** or
    **immutable**. The objects of a mutable type can be changed: that is, they provide
    operations which when executed cause the results of other operations on the same
    object to give different results. So `Date` is mutable, because you can call `setMonth`
    and observe the change with the `getMonth` operation. But `String` is immutable,
    because its operations create new `String` objects rather than changing existing
    ones. Sometimes a type will be provided in two forms, a mutable and an immutable
    form. `StringBuilder`, for example, is a mutable version of `String` (although
    the two are certainly not the same Java type, and are not interchangeable).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operations of an abstract type are classified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creators** create new objects of the type. A creator may take an object as
    an argument, but not an object of the type being constructed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producers** create new objects from old objects of the type. The `concat`
    method of `String`, for example, is a producer: it takes two strings and produces
    a new one representing their concatenation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observers** take objects of the abstract type and return objects of a different
    type. The `size` method of `List`, for example, returns an `int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutators** change objects. The `add` method of `List`, for example, mutates
    a list by adding an element to the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can summarize these distinctions schematically like this (explanation to
    follow):'
  prefs: []
  type: TYPE_NORMAL
- en: 'creator : t* → T'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'producer : T+, t* → T'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'observer : T+, t* → t'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'mutator : T+, t* → void | t | T'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These show informally the shape of the signatures of operations in the various
    classes. Each *T* is the abstract type itself; each *t* is some other type. The
    `+` marker indicates that the type may occur one or more times in that part of
    the signature, and the `*` marker indicates that it occurs zero or more times.
    `|` indicates or. For example, a producer may take two values of the abstract
    type *T*, like [`String.concat()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#concat-java.lang.String-)
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: 'concat : String × String → String'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some observers take zero arguments of other types *t*, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[size](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#size--)
    : List → int'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '… and others take several:'
  prefs: []
  type: TYPE_NORMAL
- en: '[regionMatches](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#regionMatches-boolean-int-java.lang.String-int-int-)
    : String × boolean × int × String × int × int → boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A creator operation is often implemented as a *constructor*, like [`new ArrayList()`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--).
    But a creator can simply be a static method instead, like [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-).
    A creator implemented as a static method is often called a **factory method**.
    The various [`String.valueOf`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#valueOf-boolean-)
    methods in Java are other examples of creators implemented as factory methods.
  prefs: []
  type: TYPE_NORMAL
- en: Mutators are often signaled by a `void` return type. A method that returns void
    *must* be called for some kind of side-effect, since it doesn’t otherwise return
    anything. But not all mutators return void. For example, [`Set.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/Set.html#add-E-)
    returns a boolean that indicates whether the set was actually changed. In Java’s
    graphical user interface toolkit, [`Component.add()`](http://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#add-java.awt.Component-)
    returns the object itself, so that multiple `add()` calls can be [chained together](http://en.wikipedia.org/wiki/Method_chaining).
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Data Type Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some examples of abstract data types, along with some of their operations,
    grouped by kind.
  prefs: []
  type: TYPE_NORMAL
- en: '**`int`** is Java’s primitive integer type. `int` is immutable, so it has no
    mutators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'creators: the numeric literals `0`, `1`, `2`, …'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'producers: arithmetic operators `+`, `-`, `*`, `/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'observers: comparison operators `==`, `!=`, `<`, `>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'mutators: none (it’s immutable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`List`** is Java’s list type. `List` is mutable. `List` is also an interface,
    which means that other classes provide the actual implementation of the data type.
    These classes include `ArrayList` and `LinkedList`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'creators: `ArrayList` and `LinkedList` constructors, [`Collections.singletonList`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'producers: [`Collections.unmodifiableList`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'observers: `size`, `get`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'mutators: `add`, `remove`, `addAll`, [`Collections.sort`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`String`** is Java’s string type. `String` is immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'creators: `String` constructors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'producers: `concat`, `substring`, `toUpperCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'observers: `length`, `charAt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'mutators: none (it’s immutable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This classification gives some useful terminology, but it’s not perfect. In
    complicated data types, there may be an operation that is both a producer and
    a mutator, for example. Some people reserve the term *producer* only for operations
    that do no mutation.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Operations
  prefs: []
  type: TYPE_NORMAL
- en: Each of the methods below is an operation on an abstract data type from the
    Java library. Click on the link to look at its documentation. Think about the
    operation’s type signature. Then classify the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hints: pay attention to whether the type itself appears as a parameter or return
    value. And remember that instance methods (lacking the `static` keyword) have
    an implicit parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[data:text/html,<style>body { font-family: "Helvetica Neue", Helvetica, Arial,
    sans-serif; }</style>Click a method name to see its Javadoc here.](data:text/html,<style>body
    { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }</style>Click
    a method name to see its Javadoc here.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Integer.valueOf()`](http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#valueOf-java.lang.String-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[`BigInteger.mod()`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#mod-java.math.BigInteger-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[`List.addAll()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#addAll-java.util.Collection-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[`String.toUpperCase()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[`Set.contains()`](http://docs.oracle.com/javase/8/docs/api/java/util/Set.html#contains-java.lang.Object-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[`Collections.unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '[`BufferedReader.readLine()`](http://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#readLine--)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Designing an Abstract Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,designing_an_abstract_type/eHhBM1YR5aI)'
  prefs: []
  type: TYPE_NORMAL
- en: Designing an abstract type involves choosing good operations and determining
    how they should behave. Here are a few rules of thumb.
  prefs: []
  type: TYPE_NORMAL
- en: It’s better to have **a few, simple operations** that can be combined in powerful
    ways, rather than lots of complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: Each operation should have a well-defined purpose, and should have a **coherent**
    behavior rather than a panoply of special cases. We probably shouldn’t add a `sum`
    operation to `List`, for example. It might help clients who work with lists of
    integers, but what about lists of strings? Or nested lists? All these special
    cases would make `sum` a hard operation to understand and use.
  prefs: []
  type: TYPE_NORMAL
- en: The set of operations should be **adequate** in the sense that there must be
    enough to do the kinds of computations clients are likely to want to do. A good
    test is to check that every property of an object of the type can be extracted.
    For example, if there were no get operation, we would not be able to find out
    what the elements of a list are. Basic information should not be inordinately
    difficult to obtain. For example, the size method is not strictly necessary for
    List, because we could apply get on increasing indices until we get a failure,
    but this is inefficient and inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type may be generic: a list or a set, or a graph, for example. Or it may
    be domain-specific: a street map, an employee database, a phone book, etc. But
    **it should not mix generic and domain-specific features.** A `Deck` type intended
    to represent a sequence of playing cards shouldn’t have a generic `add` method
    that accepts arbitrary objects like integers or strings. Conversely, it wouldn’t
    make sense to put a domain-specific method like `dealCards` into the generic type
    `List`.'
  prefs: []
  type: TYPE_NORMAL
- en: Representation Independence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Critically, a good abstract data type should be **representation independent**.
    This means that the use of an abstract type is independent of its representation
    (the actual data structure or data fields used to implement it), so that changes
    in representation have no effect on code outside the abstract type itself. For
    example, the operations offered by List are independent of whether the list is
    represented as a linked list or as an array.
  prefs: []
  type: TYPE_NORMAL
- en: You won’t be able to change the representation of an ADT at all unless its operations
    are fully specified with preconditions and postconditions, so that clients know
    what to depend on, and you know what you can safely change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Different Representations for Strings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a simple abstract data type to see what representation independence
    means and why it’s useful. The `MyString` type below has far fewer operations
    than the real Java `String`, and their specs are a little different, but it’s
    still illustrative. Here are the specs for the ADT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'These public operations and their specifications are the only information that
    a client of this data type is allowed to know. Following the test-first programming
    paradigm, in fact, the first client we should create is a test suite that exercises
    these operations according to their specs. At the moment, however, writing test
    cases that use `assertEquals` directly on `MyString` objects wouldn’t work, because
    we don’t have an equality operation defined on `MyString`. We’ll talk about how
    to implement equality carefully in a later reading. For now, the only operations
    we can perform with MyStrings are the ones we’ve defined above: `valueOf`, `length`,
    `charAt`, and `substring`. Our tests have to limit themselves to those operations.
    For example, here’s one test for the `valueOf` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ll come back to the question of testing ADTs at the end of this reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s look at a simple representation for `MyString`: just an array
    of characters, exactly the length of the string, with no extra room at the end.
    Here’s how that internal representation would be declared, as an instance variable
    within the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With that choice of representation, the operations would be implemented in
    a straightforward way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: (The `?:` syntax in `valueOf` is called the [ternary conditional operator](https://en.wikipedia.org/wiki/%3F:)
    and it’s a shorthand if-else statement. See [*The Conditional Operators* on this
    page of the Java Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Question to ponder: Why don’t `charAt` and `substring` have to check whether
    their parameters are within the valid range? What do you think will happen if
    the client calls these implementations with illegal inputs?'
  prefs: []
  type: TYPE_NORMAL
- en: One problem with this implementation is that it’s passing up an opportunity
    for performance improvement. Because this data type is immutable, the `substring`
    operation doesn’t really have to copy characters out into a fresh array. It could
    just point to the original `MyString` object’s character array and keep track
    of the start and end that the new substring object represents. The String implementation
    in some versions of Java do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this optimization, we could change the internal representation
    of this class to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this new representation, the operations are now implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because `MyString`’s existing clients depend only on the specs of its public
    methods, not on its private fields, we can make this change without having to
    inspect and change all that client code. That’s the power of representation independence.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Representation 1
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following abstract data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a client of this abstract data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Assume all this code works correctly (both `Family` and `client1`) and passes
    all its tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `Family`’s representation is changed from a `List` to `Set`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Assume that `Family` compiles correctly after the change.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Representation 2
  prefs: []
  type: TYPE_NORMAL
- en: '| Original version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| Changed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider `client2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Representation 3
  prefs: []
  type: TYPE_NORMAL
- en: '| Original version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| Changed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider `client3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Representation 4
  prefs: []
  type: TYPE_NORMAL
- en: For each section of the Family data type’s code shown below, is it part of the
    ADT’s specification, its representation, or its implementation?
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 2 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 4 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 5 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 6 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Realizing ADT Concepts in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,realizing_adt_concepts_in_java/LHjv8qXAYKw)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize some of the general ideas we’ve discussed in this reading, which
    are applicable in general to programming in any language, and their specific realization
    using Java language features. The point is that there are several ways to do it,
    and it’s important to both understand the big idea, like a creator operation,
    and different ways to achieve that idea in practice.
  prefs: []
  type: TYPE_NORMAL
- en: '| ADT concept | Ways to do it in Java | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| Abstract data type | Class | [`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Interface + class(es) | [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    and [`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)
    | *note 1* |'
  prefs: []
  type: TYPE_TB
- en: '| Enum | [`DayOfWeek`](http://docs.oracle.com/javase/8/docs/api/?java/time/DayOfWeek.html)
    | *note 2* |'
  prefs: []
  type: TYPE_TB
- en: '| Creator operation | Constructor | [`ArrayList()`](http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static (factory) method | [`Collections.<wbr>singletonList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-),
    [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Constant | [`BigInteger.ZERO`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO)
    | *note 3* |'
  prefs: []
  type: TYPE_TB
- en: '| Observer operation | Instance method | [`List.get()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static method | [`Collections.max()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Producer operation | Instance method | [`String.trim()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static method | [`Collections.<wbr>unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mutator operation | Instance method | [`List.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static method | [`Collections.copy()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Representation | `private` fields |  |'
  prefs: []
  type: TYPE_TB
- en: 'There are three items in this table that haven’t yet been discussed in this
    reading:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining an abstract data type using an interface. We’ve seen [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    and [`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)
    as an example, and we’ll discuss interfaces in a future reading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining an abstract data type using an enumeration (`enum`). We mentioned enum
    types in [*Basic Java*](../02-basic-java/#classes_and_objects), and you can [read
    arcane details about them in the Java Tutorials](http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).
    Enums are ideal for ADTs that have a small fixed set of values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a constant object as a creator operation. This pattern is commonly seen
    in immutable types, where the simplest or emptiest value of the type is simply
    a public constant, and producers are used to build up more complex values from
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing an Abstract Data Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We build a test suite for an abstract data type by creating tests for each of
    its operations. These tests inevitably interact with each other. The only way
    to test creators, producers, and mutators is by calling observers on the objects
    that result, and likewise, the only way to test observers is by creating objects
    for them to observe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we might partition the input spaces of the four operations in our
    `MyString` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then a compact test suite that covers all these partitions might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Try to match each test case to the partitions it covers.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each test case typically calls a few operations that *make* or *modify*
    objects of the type (creators, producers, mutators) and some operations that *inspect*
    objects of the type (observers). As a result, each test case covers parts of several
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These questions use the following datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Partitioning ADT operations<select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Choosing ADT test cases
  prefs: []
  type: TYPE_NORMAL
- en: Each of the following method call sequences is a single test case. Note that
    we’re omitting details about which object each method is called on, and the assertion
    about its return value.
  prefs: []
  type: TYPE_NORMAL
- en: Which of these test cases, all by itself, would cover all the partitions above?
    Several answers are possible. Choose all good answers.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstract data types are characterized by their operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations can be classified into creators, producers, observers, and mutators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ADT’s specification is its set of operations and their specs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good ADT is simple, coherent, adequate, and representation-independent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ADT is tested by generating tests for each of its operations, but using the
    creators, producers, mutators, and observers together in the same tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These ideas connect to our three key properties of good software as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs.** A good ADT offers a well-defined contract for a data type,
    so that clients know what to expect from the data type, and implementors have
    well-defined freedom to vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand.** A good ADT hides its implementation behind a set of
    simple operations, so that programmers using the ADT only need to understand the
    operations, not the details of the implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change.** Representation independence allows the implementation
    of an abstract data type to change without requiring changes from its clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
