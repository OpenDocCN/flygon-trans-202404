- en: 'Reading 11: Abstract Data Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读书11：抽象数据类型
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|免受错误影响|易于理解|为变更做好准备|'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|今天正确且未来不变。|与未来的程序员清晰交流，包括未来的你。|设计以适应变化而无需重写。|'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: 'Today’s class introduces two ideas:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的课程介绍了两个概念：
- en: Abstract data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象数据类型
- en: Representation independence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示独立性
- en: In this reading, we look at a powerful idea, abstract data types, which enable
    us to separate how we use a data structure in a program from the particular form
    of the data structure itself.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇阅读中，我们看到了一个强大的概念，抽象数据类型，它使我们能够将程序中使用数据结构的方式与数据结构本身的特定形式分离开来。
- en: 'Abstract data types address a particularly dangerous problem: clients making
    assumptions about the type’s internal representation. We’ll see why this is dangerous
    and how it can be avoided. We’ll also discuss the classification of operations,
    and some principles of good design for abstract data types.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象数据类型解决了一个特别危险的问题：客户端对类型的内部表示做出假设。我们将看到为什么这是危险的，以及如何避免这种情况。我们还将讨论操作的分类，以及抽象数据类型的良好设计原则。
- en: Access Control in Java
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java中的访问控制
- en: 'You should already have read: **[Controlling Access to Members of a Class](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)**
    in the Java Tutorials.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经阅读了：**[控制对类成员的访问](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)**在Java教程中。
- en: reading exercises
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: The following questions use the code below. Study it first, then answer the
    questions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题使用下面的代码。首先研究它，然后回答问题。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Access control A
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制A
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Access control B
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制B
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Access control C
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制C
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Access control D
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制D
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Access control E
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制E
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Access control F
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制F
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Access control G
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制G
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: What Abstraction Means
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象的含义是什么
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,what_abstraction_means/jDc9Oy6QcI0)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,what_abstraction_means/jDc9Oy6QcI0)'
- en: 'Abstract data types are an instance of a general principle in software engineering,
    which goes by many names with slightly different shades of meaning. Here are some
    of the names that are used for this idea:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象数据类型是软件工程中的一个通用原则的一个实例，它有许多不同的名称，意思略有不同。以下是这个想法的一些名称：
- en: '**Abstraction.** Omitting or hiding low-level details with a simpler, higher-level
    idea.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象。**省略或隐藏低级细节，采用更简单、更高级的思想。'
- en: '**Modularity.** Dividing a system into components or modules, each of which
    can be designed, implemented, tested, reasoned about, and reused separately from
    the rest of the system.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化。**将系统分成组件或模块，每个组件可以单独设计、实现、测试、推理和重复使用，与系统的其余部分分开。'
- en: '**Encapsulation.** Building walls around a module (a hard shell or capsule)
    so that the module is responsible for its own internal behavior, and bugs in other
    parts of the system can’t damage its integrity.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装。**在模块周围构建墙壁（硬壳或胶囊），使得模块负责其自身的内部行为，系统其他部分的错误不能损害其完整性。'
- en: '**Information hiding.** Hiding details of a module’s implementation from the
    rest of the system, so that those details can be changed later without changing
    the rest of the system.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息隐藏。** 将模块实现的细节隐藏在系统的其余部分之外，以便稍后可以更改这些细节而不更改系统的其余部分。'
- en: '**Separation of concerns.** Making a feature (or “concern”) the responsibility
    of a single module, rather than spreading it across multiple modules.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离。** 将一个特性（或“关注点”）的责任交给单个模块，而不是分散在多个模块中。'
- en: 'As a software engineer, you should know these terms, because you will run into
    them frequently. The fundamental purpose of all of these ideas is to help achieve
    the three important properties that we care about in 6.005: safety from bugs,
    ease of understanding, and readiness for change.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件工程师，您应该了解这些术语，因为您经常会遇到它们。所有这些想法的根本目的是帮助实现我们在6.005中关心的三个重要属性：防止错误、易于理解和易于更改。
- en: User-Defined Types
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义类型
- en: 'In the early days of computing, a programming language came with built-in types
    (such as integers, booleans, strings, etc.) and built-in procedures, e.g., for
    input and output. Users could define their own procedures: that’s how large programs
    were built.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的早期，编程语言带有内置类型（如整数、布尔值、字符串等）和内置过程，例如输入和输出。用户可以定义自己的过程：这就是构建大型程序的方式。
- en: 'A major advance in software development was the idea of abstract types: that
    one could design a programming language to allow user-defined types, too. This
    idea came out of the work of many researchers, notably Dahl (the inventor of the
    Simula language), Hoare (who developed many of the techniques we now use to reason
    about abstract types), Parnas (who coined the term information hiding and first
    articulated the idea of organizing program modules around the secrets they encapsulated),
    and here at MIT, Barbara Liskov and John Guttag, who did seminal work in the specification
    of abstract types, and in programming language support for them – and developed
    the original 6.170, the predecessor to 6.005. Barbara Liskov earned the Turing
    Award, computer science’s equivalent of the Nobel Prize, for her work on abstract
    types.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的一个重大进步是抽象类型的概念：可以设计一种编程语言以允许用户定义的类型。这个想法源自许多研究人员的工作，特别是达尔（Simula语言的发明者）、霍尔（开发了我们现在用来推理抽象类型的许多技术）、帕纳斯（创造了信息隐藏术语并首次阐述了围绕其封装的秘密组织程序模块的想法），以及麻省理工学院的巴巴拉·利斯科夫和约翰·古塔格，在抽象类型规范和支持编程语言方面做出了开创性工作——并开发了原始的6.170，6.005的前身。巴巴拉·利斯科夫因其在抽象类型上的工作而获得了图灵奖，这是计算机科学的诺贝尔奖。
- en: 'The key idea of data abstraction is that a type is characterized by the operations
    you can perform on it. A number is something you can add and multiply; a string
    is something you can concatenate and take substrings of; a boolean is something
    you can negate, and so on. In a sense, users could already define their own types
    in early programming languages: you could create a record type date, for example,
    with integer fields for day, month, and year. But what made abstract types new
    and different was the focus on operations: the user of the type would not need
    to worry about how its values were actually stored, in the same way that a programmer
    can ignore how the compiler actually stores integers. All that matters is the
    operations.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数据抽象的关键思想是类型由您可以对其执行的操作来表征。数字是可以相加和相乘的东西；字符串是可以连接和取子字符串的东西；布尔值是可以否定的东西，等等。在某种意义上，用户在早期编程语言中已经可以定义自己的类型：例如，您可以创建一个名为date的记录类型，其中包含用于日、月和年的整数字段。但是，使抽象类型新颖和不同的是对操作的关注：类型的用户不需要担心其值实际存储方式，就像程序员可以忽略编译器实际如何存储整数一样。重要的是操作。
- en: In Java, as in many modern programming languages, the separation between built-in
    types and user-defined types is a bit blurry. The classes in java.lang, such as
    Integer and Boolean are built-in; whether you regard all the collections of java.util
    as built-in is less clear (and not very important anyway). Java complicates the
    issue by having primitive types that are not objects. The set of these types,
    such as int and boolean, cannot be extended by the user.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，与许多现代编程语言一样，内置类型和用户定义类型之间的分隔有些模糊。java.lang中的类，如Integer和Boolean是内置的；你是否将java.util中的所有集合视为内置的不太清楚（而且也不太重要）。Java通过具有不是对象的原始类型使问题变得复杂。这些类型的集合，如int和boolean，用户无法扩展。
- en: reading exercises
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Abstract Data Types
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象数据类型
- en: 'Consider an abstract data type `Bool`. The type has the following operations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个抽象数据类型 `Bool`。该类型具有以下操作：
- en: '**true** : Bool'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**true** : Bool'
- en: '**false** : Bool'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**false** : Bool'
- en: '**and** : Bool × Bool → Bool'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**and** : Bool × Bool → Bool'
- en: '**or** : Bool × Bool → Bool'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**or** : Bool × Bool → Bool'
- en: '**not** : Bool → Bool'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**not** : Bool → Bool'
- en: … where the first two operations construct the two values of the type, and the
    last three operations have the usual meanings of logical *and*, logical *or*,
    and logical *not* on those values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: … 其中前两个操作构造了类型的两个值，而最后三个操作在这些值上具有逻辑*与*、逻辑*或*和逻辑*非*的通常含义。
- en: Which of the following are possible ways that `Bool` might be implemented, and
    still be able to satisfy the specs of the operations? Choose all that apply.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些是 `Bool` 可能被实现的方式，并且仍然能够满足操作的规范？选择所有适用的选项。
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Classifying Types and Operations
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型和操作的分类
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,classifying_types_and_operations/EpUaAvn8X7A)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,classifying_types_and_operations/EpUaAvn8X7A)'
- en: 'Types, whether built-in or user-defined, can be classified as **mutable** or
    **immutable**. The objects of a mutable type can be changed: that is, they provide
    operations which when executed cause the results of other operations on the same
    object to give different results. So `Date` is mutable, because you can call `setMonth`
    and observe the change with the `getMonth` operation. But `String` is immutable,
    because its operations create new `String` objects rather than changing existing
    ones. Sometimes a type will be provided in two forms, a mutable and an immutable
    form. `StringBuilder`, for example, is a mutable version of `String` (although
    the two are certainly not the same Java type, and are not interchangeable).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是内置的还是用户定义的类型，都可以被分类为**可变**或**不可变**。可变类型的对象可以被改变：也就是说，它们提供的操作在执行时会导致对同一对象的其他操作产生不同的结果。因此，`Date`
    是可变的，因为你可以调用 `setMonth` 并观察到 `getMonth` 操作的变化。但是 `String` 是不可变的，因为它的操作会创建新的 `String`
    对象而不是改变现有的对象。有时一个类型会以两种形式提供，一个是可变的，一个是不可变的。例如，`StringBuilder` 是 `String` 的可变版本（尽管两者肯定不是相同的
    Java 类型，也不能互换）。
- en: 'The operations of an abstract type are classified as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型的操作被分类如下：
- en: '**Creators** create new objects of the type. A creator may take an object as
    an argument, but not an object of the type being constructed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Creators** 创建类型的新对象。创建者可能会接受一个对象作为参数，但不会接受正在构造的类型的对象。'
- en: '**Producers** create new objects from old objects of the type. The `concat`
    method of `String`, for example, is a producer: it takes two strings and produces
    a new one representing their concatenation.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Producers** 从类型的旧对象创建新对象。例如，`String` 的 `concat` 方法是一个 producer：它接受两个字符串并产生一个表示它们连接的新字符串。'
- en: '**Observers** take objects of the abstract type and return objects of a different
    type. The `size` method of `List`, for example, returns an `int`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Observers** 接受抽象类型的对象并返回不同类型的对象。例如，`List` 的 `size` 方法返回一个 `int`。'
- en: '**Mutators** change objects. The `add` method of `List`, for example, mutates
    a list by adding an element to the end.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mutators** 改变对象。例如，`List` 的 `add` 方法通过向列表末尾添加元素来改变列表。'
- en: 'We can summarize these distinctions schematically like this (explanation to
    follow):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用如下方式概括这些区别（后续解释）：
- en: 'creator : t* → T'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'creator : t* → T'
- en: 'producer : T+, t* → T'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'producer : T+, t* → T'
- en: 'observer : T+, t* → t'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'observer : T+, t* → t'
- en: 'mutator : T+, t* → void | t | T'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'mutator : T+, t* → void | t | T'
- en: 'These show informally the shape of the signatures of operations in the various
    classes. Each *T* is the abstract type itself; each *t* is some other type. The
    `+` marker indicates that the type may occur one or more times in that part of
    the signature, and the `*` marker indicates that it occurs zero or more times.
    `|` indicates or. For example, a producer may take two values of the abstract
    type *T*, like [`String.concat()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#concat-java.lang.String-)
    does:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非正式地展示了各个类中操作签名的形状。每个 *T* 是抽象类型本身；每个 *t* 是其他某种类型。`+` 标记表示该类型在签名的那部分可能出现一次或多次，`*`
    标记表示它可能出现零次或多次。`|` 表示或。例如，一个 producer 可能接受两个抽象类型 *T* 的值，就像 [`String.concat()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#concat-java.lang.String-)
    一样：
- en: 'concat : String × String → String'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'concat : String × String → String'
- en: 'Some observers take zero arguments of other types *t*, such as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些观察者不需要其他类型 *t* 的参数：
- en: '[size](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#size--)
    : List → int'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[size](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#size--)
    : 列表 → 整数'
- en: '… and others take several:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '...和其他需要多个参数的:'
- en: '[regionMatches](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#regionMatches-boolean-int-java.lang.String-int-int-)
    : String × boolean × int × String × int × int → boolean'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[regionMatches](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#regionMatches-boolean-int-java.lang.String-int-int-)
    : 字符串 × 布尔 × 整数 × 字符串 × 整数 × 整数 → 布尔'
- en: A creator operation is often implemented as a *constructor*, like [`new ArrayList()`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--).
    But a creator can simply be a static method instead, like [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-).
    A creator implemented as a static method is often called a **factory method**.
    The various [`String.valueOf`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#valueOf-boolean-)
    methods in Java are other examples of creators implemented as factory methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建者操作通常实现为 *构造函数*，比如 [`new ArrayList()`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--)。但是创建者也可以简单地是一个静态方法，比如
    [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)。作为静态方法实现的创建者通常被称为**工厂方法**。Java
    中的各种 [`String.valueOf`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#valueOf-boolean-)
    方法是工厂方法实现的其他示例。
- en: Mutators are often signaled by a `void` return type. A method that returns void
    *must* be called for some kind of side-effect, since it doesn’t otherwise return
    anything. But not all mutators return void. For example, [`Set.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/Set.html#add-E-)
    returns a boolean that indicates whether the set was actually changed. In Java’s
    graphical user interface toolkit, [`Component.add()`](http://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#add-java.awt.Component-)
    returns the object itself, so that multiple `add()` calls can be [chained together](http://en.wikipedia.org/wiki/Method_chaining).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 修改器通常由 `void` 返回类型表示。返回 void 的方法 *必须* 用于某种副作用，因为它否则不返回任何内容。但并非所有修改器都返回 void。例如，[`Set.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/Set.html#add-E-)
    返回一个布尔值，指示集合是否实际上已更改。在 Java 的图形用户界面工具包中，[`Component.add()`](http://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#add-java.awt.Component-)
    返回对象本身，以便多个 `add()` 调用可以被 [链接在一起](http://en.wikipedia.org/wiki/Method_chaining)。
- en: Abstract Data Type Examples
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象数据类型示例
- en: Here are some examples of abstract data types, along with some of their operations,
    grouped by kind.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些抽象数据类型的示例，以及它们的一些操作，按类型分组。
- en: '**`int`** is Java’s primitive integer type. `int` is immutable, so it has no
    mutators.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**`int`** 是 Java 的基本整数类型。`int` 是不可变的，因此没有修改器。'
- en: 'creators: the numeric literals `0`, `1`, `2`, …'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'creators: 数字文字 `0`, `1`, `2`, …'
- en: 'producers: arithmetic operators `+`, `-`, `*`, `/`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'producers: 算术运算符 `+`, `-`, `*`, `/`'
- en: 'observers: comparison operators `==`, `!=`, `<`, `>`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'observers: 比较运算符 `==`, `!=`, `<`, `>`'
- en: 'mutators: none (it’s immutable)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '修改器: 无（它是不可变的）'
- en: '**`List`** is Java’s list type. `List` is mutable. `List` is also an interface,
    which means that other classes provide the actual implementation of the data type.
    These classes include `ArrayList` and `LinkedList`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**`List`** 是 Java 的列表类型。`List` 是可变的。`List` 也是一个接口，这意味着其他类提供了数据类型的实际实现。这些类包括
    `ArrayList` 和 `LinkedList`。'
- en: 'creators: `ArrayList` and `LinkedList` constructors, [`Collections.singletonList`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'creators: `ArrayList` 和 `LinkedList` 构造函数，[`Collections.singletonList`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-)'
- en: 'producers: [`Collections.unmodifiableList`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'producers: [`Collections.unmodifiableList`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)'
- en: 'observers: `size`, `get`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'observers: `size`, `get`'
- en: 'mutators: `add`, `remove`, `addAll`, [`Collections.sort`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '修改器: `add`, `remove`, `addAll`, [`Collections.sort`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-)'
- en: '**`String`** is Java’s string type. `String` is immutable.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**`String`** 是 Java 的字符串类型。`String` 是不可变的。'
- en: 'creators: `String` constructors'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'creators: `String` 构造函数'
- en: 'producers: `concat`, `substring`, `toUpperCase`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'producers: `concat`, `substring`, `toUpperCase`'
- en: 'observers: `length`, `charAt`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'observers: `length`, `charAt`'
- en: 'mutators: none (it’s immutable)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '修改器: 无（它是不可变的）'
- en: This classification gives some useful terminology, but it’s not perfect. In
    complicated data types, there may be an operation that is both a producer and
    a mutator, for example. Some people reserve the term *producer* only for operations
    that do no mutation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分类提供了一些有用的术语，但并不完美。在复杂的数据类型中，可能存在既是生产者又是变更者的操作，例如。有些人仅将术语*生产者*保留给不进行变更的操作。
- en: reading exercises
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Operations
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 操作
- en: Each of the methods below is an operation on an abstract data type from the
    Java library. Click on the link to look at its documentation. Think about the
    operation’s type signature. Then classify the operation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的每个方法都是来自Java库的抽象数据类型的操作。点击链接查看其文档。思考操作的类型签名。然后对操作进行分类。
- en: 'Hints: pay attention to whether the type itself appears as a parameter or return
    value. And remember that instance methods (lacking the `static` keyword) have
    an implicit parameter.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：注意类型本身是否出现为参数或返回值。记住，实例方法（缺少`static`关键字）有一个隐式参数。
- en: '[data:text/html,<style>body { font-family: "Helvetica Neue", Helvetica, Arial,
    sans-serif; }</style>Click a method name to see its Javadoc here.](data:text/html,<style>body
    { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }</style>Click
    a method name to see its Javadoc here.)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[data:text/html,<style>body { font-family: "Helvetica Neue", Helvetica, Arial,
    sans-serif; }</style>点击方法名称查看其Javadoc。](data:text/html,<style>body { font-family:
    "Helvetica Neue", Helvetica, Arial, sans-serif; }</style>点击方法名称查看其Javadoc。)'
- en: '[`Integer.valueOf()`](http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#valueOf-java.lang.String-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Integer.valueOf()`](http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#valueOf-java.lang.String-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(缺少答案)'
- en: (missing explanation)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[`BigInteger.mod()`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#mod-java.math.BigInteger-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[`BigInteger.mod()`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#mod-java.math.BigInteger-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(缺少答案)'
- en: (missing explanation)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[`List.addAll()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#addAll-java.util.Collection-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[`List.addAll()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#addAll-java.util.Collection-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(缺少答案)'
- en: (missing explanation)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[`String.toUpperCase()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[`String.toUpperCase()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(缺少答案)'
- en: (missing explanation)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[`Set.contains()`](http://docs.oracle.com/javase/8/docs/api/java/util/Set.html#contains-java.lang.Object-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Set.contains()`](http://docs.oracle.com/javase/8/docs/api/java/util/Set.html#contains-java.lang.Object-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(缺少答案)'
- en: (missing explanation)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[`Collections.unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Collections.unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(缺少答案)'
- en: (missing explanation)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: '[`BufferedReader.readLine()`](http://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#readLine--)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(missing
    answer)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[`BufferedReader.readLine()`](http://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#readLine--)
    <select class="form-control"><option>creator</option>,<option>producer</option>,<option>consumer</option>,<option>observer</option>,<option>mutator</option>,<option>destructor</option></select>(缺少答案)'
- en: (missing explanation)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Designing an Abstract Type
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计抽象类型
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,designing_an_abstract_type/eHhBM1YR5aI)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,designing_an_abstract_type/eHhBM1YR5aI)'
- en: Designing an abstract type involves choosing good operations and determining
    how they should behave. Here are a few rules of thumb.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 设计抽象类型涉及选择良好的操作并确定它们应该如何行为。以下是一些经验法则。
- en: It’s better to have **a few, simple operations** that can be combined in powerful
    ways, rather than lots of complex operations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最好拥有**少量简单的操作**，可以以强大的方式组合，而不是大量复杂的操作。
- en: Each operation should have a well-defined purpose, and should have a **coherent**
    behavior rather than a panoply of special cases. We probably shouldn’t add a `sum`
    operation to `List`, for example. It might help clients who work with lists of
    integers, but what about lists of strings? Or nested lists? All these special
    cases would make `sum` a hard operation to understand and use.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作应该有明确定义的目的，并且应该具有**连贯的**行为，而不是一系列特例。例如，我们可能不应该向`List`添加一个`sum`操作。这可能有助于使用整数列表的客户端，但是对于字符串列表呢？或者嵌套列表呢？所有这些特例会使`sum`成为一个难以理解和使用的操作。
- en: The set of operations should be **adequate** in the sense that there must be
    enough to do the kinds of computations clients are likely to want to do. A good
    test is to check that every property of an object of the type can be extracted.
    For example, if there were no get operation, we would not be able to find out
    what the elements of a list are. Basic information should not be inordinately
    difficult to obtain. For example, the size method is not strictly necessary for
    List, because we could apply get on increasing indices until we get a failure,
    but this is inefficient and inconvenient.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 操作集应该是**足够的**，意味着必须有足够的操作来执行客户端可能想要执行的计算。一个好的测试是检查类型对象的每个属性是否可以被提取。例如，如果没有`get`操作，我们将无法找出列表的元素是什么。基本信息不应该过于难以获得。例如，对于列表来说，`size`方法并不是绝对必要的，因为我们可以在递增的索引上应用`get`直到出现错误，但这是低效且不方便的。
- en: 'The type may be generic: a list or a set, or a graph, for example. Or it may
    be domain-specific: a street map, an employee database, a phone book, etc. But
    **it should not mix generic and domain-specific features.** A `Deck` type intended
    to represent a sequence of playing cards shouldn’t have a generic `add` method
    that accepts arbitrary objects like integers or strings. Conversely, it wouldn’t
    make sense to put a domain-specific method like `dealCards` into the generic type
    `List`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以是通用的：例如列表或集合，或者是特定领域的：例如街道地图，员工数据库，电话簿等。但是**不应该混合通用和特定领域的特性**。用于表示一系列扑克牌的`Deck`类型不应该有一个接受任意对象（如整数或字符串）的通用`add`方法。反之，将特定领域的方法如`dealCards`放入通用类型`List`中也没有意义。
- en: Representation Independence
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示独立性
- en: Critically, a good abstract data type should be **representation independent**.
    This means that the use of an abstract type is independent of its representation
    (the actual data structure or data fields used to implement it), so that changes
    in representation have no effect on code outside the abstract type itself. For
    example, the operations offered by List are independent of whether the list is
    represented as a linked list or as an array.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，一个良好的抽象数据类型应该是**表示独立的**。这意味着抽象类型的使用与其表示（用于实现它的实际数据结构或数据字段）无关，因此表示的更改对抽象类型本身之外的代码没有影响。例如，List
    提供的操作与列表是作为链接列表还是作为数组表示是独立的。
- en: You won’t be able to change the representation of an ADT at all unless its operations
    are fully specified with preconditions and postconditions, so that clients know
    what to depend on, and you know what you can safely change.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除非操作的前提条件和后置条件完全指定，以便客户知道依赖于什么，您知道可以安全更改，否则您将无法更改 ADT 的表示。
- en: 'Example: Different Representations for Strings'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：字符串的不同表示
- en: 'Let’s look at a simple abstract data type to see what representation independence
    means and why it’s useful. The `MyString` type below has far fewer operations
    than the real Java `String`, and their specs are a little different, but it’s
    still illustrative. Here are the specs for the ADT:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的抽象数据类型，看看表示独立意味着什么，以及为什么它很有用。下面的`MyString`类型比真正的 Java `String` 拥有更少的操作，并且它们的规格略有不同，但这仍然具有说明性。以下是
    ADT 的规格：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These public operations and their specifications are the only information that
    a client of this data type is allowed to know. Following the test-first programming
    paradigm, in fact, the first client we should create is a test suite that exercises
    these operations according to their specs. At the moment, however, writing test
    cases that use `assertEquals` directly on `MyString` objects wouldn’t work, because
    we don’t have an equality operation defined on `MyString`. We’ll talk about how
    to implement equality carefully in a later reading. For now, the only operations
    we can perform with MyStrings are the ones we’ve defined above: `valueOf`, `length`,
    `charAt`, and `substring`. Our tests have to limit themselves to those operations.
    For example, here’s one test for the `valueOf` operation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些公共操作及其规格是此数据类型的客户端允许知道的唯一信息。实际上，按照测试先编程的范式，我们应该创建的第一个客户端是根据其规格执行这些操作的测试套件。但是，目前，直接在`MyString`对象上使用`assertEquals`编写测试用例将不起作用，因为我们没有在`MyString`上定义相等操作。我们将在稍后的阅读中谨慎讨论如何实现相等性。目前，我们唯一可以执行的操作是我们上面定义的操作：`valueOf`、`length`、`charAt`
    和 `substring`。我们的测试必须限制自己在这些操作上。例如，这是一个`valueOf`操作的测试：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll come back to the question of testing ADTs at the end of this reading.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本文末尾回到测试 ADT 的问题。
- en: 'For now, let’s look at a simple representation for `MyString`: just an array
    of characters, exactly the length of the string, with no extra room at the end.
    Here’s how that internal representation would be declared, as an instance variable
    within the class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个简单的`MyString`表示：只是一个字符数组，长度正好与字符串相同，末尾没有额外的空间。以下是如何声明该内部表示的，作为类中的一个实例变量：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With that choice of representation, the operations would be implemented in
    a straightforward way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了该表示后，操作将以直接的方式实现：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (The `?:` syntax in `valueOf` is called the [ternary conditional operator](https://en.wikipedia.org/wiki/%3F:)
    and it’s a shorthand if-else statement. See [*The Conditional Operators* on this
    page of the Java Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html).)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: （`valueOf`中的`?:`语法称为[三元条件运算符](https://en.wikipedia.org/wiki/%3F:)，它是 if-else
    语句的简写。请参见[Java 教程](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html)中的*条件运算符*页面。）
- en: 'Question to ponder: Why don’t `charAt` and `substring` have to check whether
    their parameters are within the valid range? What do you think will happen if
    the client calls these implementations with illegal inputs?'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑问题：为什么`charAt`和`substring`不必检查其参数是否在有效范围内？如果客户端使用非法输入调用这些实现，您认为会发生什么？
- en: One problem with this implementation is that it’s passing up an opportunity
    for performance improvement. Because this data type is immutable, the `substring`
    operation doesn’t really have to copy characters out into a fresh array. It could
    just point to the original `MyString` object’s character array and keep track
    of the start and end that the new substring object represents. The String implementation
    in some versions of Java do this.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的一个问题是，它错过了性能改进的机会。因为这种数据类型是不可变的，`substring` 操作实际上不需要将字符复制到新数组中。它可以直接指向原始
    `MyString` 对象的字符数组，并跟踪新子字符串对象表示的起始和结束位置。在某些版本的 Java 中，String 实现就是这样做的。
- en: 'To implement this optimization, we could change the internal representation
    of this class to:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种优化，我们可以将该类的内部表示更改为：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this new representation, the operations are now implemented like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新表示，操作现在是这样实现的：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because `MyString`’s existing clients depend only on the specs of its public
    methods, not on its private fields, we can make this change without having to
    inspect and change all that client code. That’s the power of representation independence.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `MyString` 现有的客户端仅依赖于其公共方法的规范，而不依赖于其私有字段，所以我们可以进行这种更改，而无需检查和更改所有客户端代码。这就是表示独立性的力量。
- en: reading exercises
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Representation 1
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 1
- en: Consider the following abstract data type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下抽象数据类型。
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is a client of this abstract data type:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个抽象数据类型的一个客户端：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Assume all this code works correctly (both `Family` and `client1`) and passes
    all its tests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有这些代码都能正确运行（包括 `Family` 和 `client1`）并通过所有测试。
- en: 'Now `Family`’s representation is changed from a `List` to `Set`, as shown:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Family` 的表示已从 `List` 更改为 `Set`，如下所示：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Assume that `Family` compiles correctly after the change.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在更改后 `Family` 能正确编译。
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Representation 2
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 2
- en: '| Original version:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '| 原始版本：'
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| Changed version:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '| 更改后的版本：'
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Now consider `client2`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 `client2`：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Representation 3
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 3
- en: '| Original version:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '| 原始版本：'
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| Changed version:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '| 更改后的版本：'
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Now consider `client3`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 `client3`：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Representation 4
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 4
- en: For each section of the Family data type’s code shown below, is it part of the
    ADT’s specification, its representation, or its implementation?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面展示的 Family 数据类型代码的每个部分，它是 ADT 的规范、表示还是实现的一部分？
- en: '| 1 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 1 | <select class="form-control"><option>规范</option>，<option>表示</option>，<option>实现</option></select>(缺少答案)
    |'
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 2 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 2 | <select class="form-control"><option>规范</option>，<option>表示</option>，<option>实现</option></select>(缺少答案)
    |'
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 3 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 3 | <select class="form-control"><option>规范</option>，<option>表示</option>，<option>实现</option></select>(缺少答案)
    |'
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 4 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 4 | <select class="form-control"><option>规范</option>，<option>表示</option>，<option>实现</option></select>(缺少答案)
    |'
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 5 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 5 | <select class="form-control"><option>规范</option>，<option>表示</option>，<option>实现</option></select>(缺少答案)
    |'
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 6 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 6 | <select class="form-control"><option>规范</option>，<option>表示</option>，<option>实现</option></select>(缺少答案)
    |'
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 7 | <select class="form-control"><option>specification</option>,<option>representation</option>,<option>implementation</option></select>(missing
    answer) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 7 | <select class="form-control"><option>规范</option>，<option>表示</option>，<option>实现</option></select>(缺少答案)
    |'
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (missing explanation)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: Realizing ADT Concepts in Java
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Java 中实现 ADT 概念
- en: '[**▶︎ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,realizing_adt_concepts_in_java/LHjv8qXAYKw)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶︎ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_11_abstract_data_types,access_control_in_java,realizing_adt_concepts_in_java/LHjv8qXAYKw)'
- en: Let’s summarize some of the general ideas we’ve discussed in this reading, which
    are applicable in general to programming in any language, and their specific realization
    using Java language features. The point is that there are several ways to do it,
    and it’s important to both understand the big idea, like a creator operation,
    and different ways to achieve that idea in practice.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们在本次阅读中讨论过的一些一般性观念，这些观念通常适用于任何编程语言，并使用 Java 语言特性进行具体实现。关键是有几种方法可以做到这一点，重要的是既要理解大观念，如创建操作，也要理解在实践中实现该观念的不同方式。
- en: '| ADT concept | Ways to do it in Java | Examples |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| ADT 概念 | 在 Java 中的实现方式 | 示例 |'
- en: '| Abstract data type | Class | [`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 抽象数据类型 | 类 | [`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    |'
- en: '| Interface + class(es) | [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    and [`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)
    | *note 1* |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 接口 + 类 | [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    和 [`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)
    | *注1* |'
- en: '| Enum | [`DayOfWeek`](http://docs.oracle.com/javase/8/docs/api/?java/time/DayOfWeek.html)
    | *note 2* |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | [`DayOfWeek`](http://docs.oracle.com/javase/8/docs/api/?java/time/DayOfWeek.html)
    | *注2* |'
- en: '| Creator operation | Constructor | [`ArrayList()`](http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--)
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 创建操作 | 构造函数 | [`ArrayList()`](http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--)
    |'
- en: '| Static (factory) method | [`Collections.<wbr>singletonList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-),
    [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 静态（工厂）方法 | [`Collections.<wbr>singletonList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-),
    [`Arrays.asList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)
    |'
- en: '| Constant | [`BigInteger.ZERO`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO)
    | *note 3* |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | [`BigInteger.ZERO`](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO)
    | *注3* |'
- en: '| Observer operation | Instance method | [`List.get()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-)
    |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 观察者操作 | 实例方法 | [`List.get()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-)
    |'
- en: '| Static method | [`Collections.max()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-)
    |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | [`Collections.max()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-)
    |'
- en: '| Producer operation | Instance method | [`String.trim()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--)
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 生成操作 | 实例方法 | [`String.trim()`](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--)
    |'
- en: '| Static method | [`Collections.<wbr>unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | [`Collections.<wbr>unmodifiableList()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)
    |'
- en: '| Mutator operation | Instance method | [`List.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-)
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 改变器操作 | 实例方法 | [`List.add()`](http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-)
    |'
- en: '| Static method | [`Collections.copy()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-)
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | [`Collections.copy()`](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-)
    |'
- en: '| Representation | `private` fields |  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 表示 | `private` 字段 |  |'
- en: 'There are three items in this table that haven’t yet been discussed in this
    reading:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这张表中有三项尚未在本次阅读中讨论：
- en: Defining an abstract data type using an interface. We’ve seen [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)
    and [`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)
    as an example, and we’ll discuss interfaces in a future reading.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用接口定义抽象数据类型。我们已经以[`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)和[`ArrayList`](http://docs.oracle.com/javase/8/docs/api/?java/util/ArrayList.html)为例，我们将在未来的阅读中讨论接口。
- en: Defining an abstract data type using an enumeration (`enum`). We mentioned enum
    types in [*Basic Java*](../02-basic-java/#classes_and_objects), and you can [read
    arcane details about them in the Java Tutorials](http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).
    Enums are ideal for ADTs that have a small fixed set of values.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用枚举（`enum`）定义抽象数据类型。我们在[*基本Java*](../02-basic-java/#classes_and_objects)中提到了枚举类型，并且您可以在[Java教程中阅读有关它们的深奥细节](http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)。枚举类型非常适合具有一组固定值的ADT。
- en: Using a constant object as a creator operation. This pattern is commonly seen
    in immutable types, where the simplest or emptiest value of the type is simply
    a public constant, and producers are used to build up more complex values from
    it.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用常量对象作为创建操作。这种模式通常在不可变类型中看到，其中类型的最简单或最空的值只是一个公共常量，而生产者用于从中构建更复杂的值。
- en: Testing an Abstract Data Type
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试抽象数据类型
- en: We build a test suite for an abstract data type by creating tests for each of
    its operations. These tests inevitably interact with each other. The only way
    to test creators, producers, and mutators is by calling observers on the objects
    that result, and likewise, the only way to test observers is by creating objects
    for them to observe.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为其每个操作创建测试来为抽象数据类型构建测试套件。这些测试不可避免地相互交互。测试创建者、生产者和变更者的唯一方法是在结果对象上调用观察者，同样，测试观察者的唯一方法是为其创建对象以供观察。
- en: 'Here’s how we might partition the input spaces of the four operations in our
    `MyString` type:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何可能将`MyString`类型的四个操作的输入空间进行分区的方式：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then a compact test suite that covers all these partitions might look like:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个涵盖所有这些分区的紧凑测试套件可能如下所示：
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Try to match each test case to the partitions it covers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将每个测试用例与其覆盖的分区匹配。
- en: Notice that each test case typically calls a few operations that *make* or *modify*
    objects of the type (creators, producers, mutators) and some operations that *inspect*
    objects of the type (observers). As a result, each test case covers parts of several
    operations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个测试用例通常调用一些*创建*或*修改*类型对象的操作（创建者、生产者、变更者）以及一些*检查*类型对象的操作（观察者）。因此，每个测试用例涵盖了几个操作的部分。
- en: reading exercises
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: 'These questions use the following datatype:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题使用以下数据类型：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Partitioning ADT operations<select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>(missing
    answer)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对ADT操作进行分区<select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: <select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>(missing
    answer)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: <select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>(missing
    answer)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option></select>（缺少答案）
- en: (missing explanation)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Choosing ADT test cases
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 选择ADT测试用例
- en: Each of the following method call sequences is a single test case. Note that
    we’re omitting details about which object each method is called on, and the assertion
    about its return value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下每个方法调用序列都是一个单独的测试用例。请注意，我们省略了每个方法调用的对象以及关于其返回值的断言的细节。
- en: Which of these test cases, all by itself, would cover all the partitions above?
    Several answers are possible. Choose all good answers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试用例中，哪一个单独就可以覆盖上述所有分区？有多个答案可行。选择所有正确答案。
- en: (missing answer)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Abstract data types are characterized by their operations.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象数据类型的特征在于其操作。
- en: Operations can be classified into creators, producers, observers, and mutators.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作可以分为创建者、生产者、观察者和变更者。
- en: An ADT’s specification is its set of operations and their specs.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADT的规范是其操作集合及其规范。
- en: A good ADT is simple, coherent, adequate, and representation-independent.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个良好的ADT是简单、连贯、充分和与表示无关的。
- en: An ADT is tested by generating tests for each of its operations, but using the
    creators, producers, mutators, and observers together in the same tests.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个ADT通过为其每个操作生成测试来进行测试，但在相同的测试中同时使用创建者、生产者、变异器和观察者。
- en: 'These ideas connect to our three key properties of good software as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法与我们对好软件的三个关键属性相连接：
- en: '**Safe from bugs.** A good ADT offers a well-defined contract for a data type,
    so that clients know what to expect from the data type, and implementors have
    well-defined freedom to vary.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误的影响。** 一个好的ADT为数据类型提供了一个明确定义的契约，使客户端知道可以从数据类型中期望什么，而实现者则有明确定义的自由来变化。'
- en: '**Easy to understand.** A good ADT hides its implementation behind a set of
    simple operations, so that programmers using the ADT only need to understand the
    operations, not the details of the implementation.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解。** 一个好的ADT将其实现隐藏在一组简单的操作后面，这样使用ADT的程序员只需要理解这些操作，而不需要了解实现的细节。'
- en: '**Ready for change.** Representation independence allows the implementation
    of an abstract data type to change without requiring changes from its clients.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为变化做好准备。** 表示独立性允许抽象数据类型的实现发生变化，而不需要其客户端进行更改。'
