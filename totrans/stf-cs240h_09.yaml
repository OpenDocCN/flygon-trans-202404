- en: Untrusted code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不受信任的代码
- en: Say you want to incorporate untrusted code in a Haskell application
  id: totrans-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你想在Haskell应用程序中合并不受信任的代码。
- en: 'Example: Some third-party translation software'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：一些第三方翻译软件
- en: You built a web server
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你建立了一个Web服务器。
- en: Want to add a “translate to Pig Latin” button to each web page
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要在每个网页上添加一个“翻译为猪拉丁语”的按钮
- en: Download some random code with this function
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此函数下载一些随机代码。
- en: '[PRE0]'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you could trust the type (no `IO`), this would be safe to run
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能信任类型（没有`IO`），这将是安全的运行
- en: Worst case, users get garbled text on web page
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最坏的情况是，用户在网页上看到了乱码文本。
- en: However, what if you have?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果你有？
- en: '[PRE1]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Safe Haskell](http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[安全的Haskell](http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html)'
- en: Starting with GHC 7.2, `-XSafe` option enables [Safe Haskell](http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GHC 7.2开始，`-XSafe`选项启用[���全的Haskell](http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html)
- en: Courtesy of our very own CA, David Terei
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由我们自己的CA，David Terei提供
- en: Safe Haskell disallows import of any unsafe modules
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全的Haskell禁止导入任何不安全的模块。
- en: E.g., can’t import `System.IO.Unsafe`, so can’t call `unsafePerformIO`
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，不能导入`System.IO.Unsafe`，因此不能调用`unsafePerformIO`。
- en: Safe imports (enabled by `-XUnsafe`) require an import to be safe
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全导入（通过`-XUnsafe`启用）要求导入是安全的。
- en: '[PRE2]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above should guarantee that `toPigLatin` doesn’t call unsafe functions
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述应该保证`toPigLatin`不调用不安全的函数。
- en: But wait… doesn’t `toPigLatin` use ByteString?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但等等… `toPigLatin`不是使用ByteString吗？
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Safe vs. Trustworthy
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全与可信赖
- en: A module compiled `-XSafe` can only import safe modules
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译为`-XSafe`的模块只能导入安全模块。
- en: As if all imports implicitly have `safe` keyword
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就好像所有导入都隐含具有`safe`关键字一样。
- en: But there are *two* kinds of safe module
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但有*两种*安全模块
- en: Modules verified to be safe by the compiler, compiled `-XSafe`
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器验证为安全的模块，编译`-XSafe`。
- en: Modules asserted to be safe by the author, compiled `-XTrustworthy`
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作者断言的模块，编译为`-XTrustworthy`
- en: So a module like `Data.ByteString` can be compiled `-XTrustworthy`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，像`Data.ByteString`这样的模块可以编译为`-XTrustworthy`
- en: Put unsafe functions in separate `Data.ByteString.Unsafe` module
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不安全的函数放在单独的`Data.ByteString.Unsafe`模块中。
- en: Assert `Data.ByteString`’s exported symbols cannot be used unsafely, even if
    the module internally makes use of unsafe functions
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言`Data.ByteString`的导出符号不能被不安全地使用，即使模块内部使用不安全函数
- en: Of course, might or might not trust module author
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，可能会或可能不会信任模块作者。
- en: Can specify on a per-package basis whether to honor `-XTrustworthy`
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以根据每个包的情况指定是否遵守`-XTrustworthy`。
- en: Flag `-fpackage-trust` enables such per-package trust
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志`-fpackage-trust`启用了这种每个包的信任
- en: Use flags, `-trust` *Pkg*, `-distrust` *Pkg*, `-distrust-all-packages`
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标志，`-trust` *Pkg*，`-distrust` *Pkg*，`-distrust-all-packages`。
- en: Can also set default for a package with `ghc-pkg`
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以使用`ghc-pkg`为一个包设置默认值
- en: What if untrusted code needs to do IO?
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果不受信任的代码需要执行IO怎么办？
- en: Suppose you want to translate to a real language
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你想要翻译成一种真实语言。
- en: Generally requires massive data sets
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常需要大量数据集。
- en: Untrusted code would at minimum need to do file IO
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不受信任的代码至少需要执行文件IO。
- en: Or maybe easiest to send text over network to, e.g., Google translate
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者可能最容易将文本发送到网络上，例如Google翻译。
- en: 'Idea: use a *restricted* IO monad, `RIO`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想法：使用*受限制的*IO Monad，`RIO`
- en: Untrusted third party implements `googleTranslate` function
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不受信任的第三方实现了`googleTranslate`函数。
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But uses the `RIO` monad, instead of `IO`
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是使用`RIO` Monad，而不是`IO`
- en: Implement `RIO` functions to access network, file system
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`RIO`函数以访问网络、文件系统。
- en: Have functions reject *dangerous* operations
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使函数拒绝*危险*操作
- en: Can use same names and port `IO` code to `RIO` by manipulating imports
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过操作导入来使用相同名称和端口`IO`代码转换为`RIO`。
- en: 'Example: hypothetical `RIO` monad'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例如：假设的`RIO` Monad
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note use of `newtype` – `RIO` is same as `IO` at runtime
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意`newtype`的使用 - `RIO`在运行时与`IO`相同。
- en: Anyone can turn an `RIO` action into an `IO` one with `runRIO`
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以使用`runRIO`将`RIO`操作转换为`IO`操作。
- en: But can’t create `RIO` action from `IO` without `UnsafeRIO`
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是不能从`IO`创建`RIO`操作而不使用`UnsafeRIO`。
- en: 'Exercise: implement RIO Monad instance'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：实现`RIO` Monad实例。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Starter code: `wget` [`cs240h.stanford.edu/RIO.hs`](http://cs240h.scs.stanford.edu/RIO.hs)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始代码：`wget` [`cs240h.stanford.edu/RIO.hs`](http://cs240h.scs.stanford.edu/RIO.hs)
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Bonus: what’s wrong with the following, alternate definition of `runRIO`?'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励：以下`runRIO`的替代定义有什么问题？
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Solutions
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Monad solution:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monad解决方案：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Bonus solution:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励解决方案：
- en: The problem is selectors can be used to *update* state
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题在于选择器可以用于*更新*状态。
- en: Exporting `runRIO` is tantamount to exporting `UnsafeRIO`
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出`runRIO`等同于导出`UnsafeRIO`。
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Can execute arbitrary `IO` actions from within `RIO`:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从`RIO`内执行任意`IO`操作：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example policies for RIO
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIO的示例策略
- en: Only read and write files under some sandbox subdirectory
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在某些沙盒子目录下读写文件
- en: Protect most of file system from untrusted code
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护大部分文件系统免受不受信任的代码的影响
- en: Do not allow execution of other programs
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许执行其他程序
- en: Would escape from `RIO` restrictions
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将逃离`RIO`限制
- en: Only allow connections to port 80, and only to known servers
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许连接到端口80，并且只能连接到已知服务器
- en: Don’t want untrusted code sending spam, attacking mysql, etc.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不希望不受信任的代码发送垃圾邮件，攻击mysql等
- en: Do not allow access to devices
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许访问设备
- en: Microphone, camera, speaker, etc.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦克风，摄像头，扬声器等
- en: Similar to policies that apply to Java/JavaScript in browser
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于适用于浏览器中的Java/JavaScript的策略
- en: Why RIO isn’t enough
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么RIO不够
- en: What if the web site contains private data, such as email?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网站包含私人数据，例如电子邮件，怎么办？
- en: 'An attack by malicious `googleTranslate` function:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意`googleTranslate`函数的攻击：
- en: Save a copy of private email under `/sandbox` (allowed)
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/sandbox`下保存私人电子邮件的副本（允许）
- en: When asked to translate a special string, return stored email
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当要求翻译特殊字符串时，返回存储的电子邮件
- en: Attacker sends himself an email with special string to read stored email
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者向自己发送带有特殊字符串的电子邮件以读取存储的电子邮件
- en: Another attack
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个攻击
- en: Send query to attacker’s own website instead of Google
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向攻击者自己的网站发送查询，而不是Google
- en: 'Problem: really need to keep track of what information is sensitive'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题：确实需要跟踪哪些信息是敏感的
- en: Okay to send public data over network
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过网络发送公共数据
- en: Not okay to send email (or maybe only okay to send to specific Google URL)
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可以发送电子邮件（或者可能只能发送到特定的Google URL）
- en: Okay to write files, but have to keep track of which files contain whose email
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以写文件，但必须跟踪哪些文件包含谁的电子邮件
- en: 'Solution: Decentralized Information Flow Control (DIFC)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案：分散式信息流控制（DIFC）
- en: What is DIFC?
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是DIFC？
- en: '![](../Images/ad1e1773cef100102de4a3a739f361b3.svg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ad1e1773cef100102de4a3a739f361b3.svg)'
- en: IFC originated with military applications and classified data
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IFC起源于军事应用和机密数据
- en: Every piece of data in the system has a label
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中的每个数据都有一个标签
- en: Every process/thread has a label
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程/线程都有一个标签
- en: Labels are partially ordered by  ⊑  (“can flow to”)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签部分由 ⊑ （“可以流向”）排序
- en: 'Example: Emacs (labeled *L*[*E*]) accesses file (labeled *L*[*F*])'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：Emacs（标记为*L*[E]）访问文件（标记为*L*[F]）
- en: What is DIFC?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是DIFC？
- en: '![](../Images/1168dc21d8ca9952785120a071c0d7c7.svg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1168dc21d8ca9952785120a071c0d7c7.svg)'
- en: IFC originated with military applications and classified data
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IFC起源于军事应用和机密数据
- en: Every piece of data in the system has a label
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中的每个数据都有一个标签
- en: Every process/thread has a label
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程/线程都有一个标签
- en: Labels are partially ordered by  ⊑  (“can flow to”)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签部分由 ⊑ （“可以流向”）排序
- en: 'Example: Emacs (labeled *L*[*E*]) accesses file (labeled *L*[*F*])'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：Emacs（标记为*L*[E]）访问文件（标记为*L*[F]）
- en: File read? Information flows from file to emacs. System requires *L*[*F*] ⊑ *L*[*E*].
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件读取？信息从文件流向emacs。系统要求*L*[F] ⊑ *L*[E]。
- en: What is DIFC?
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是DIFC？
- en: '![](../Images/cdb7914482cf2a7c61400465fed901ea.svg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cdb7914482cf2a7c61400465fed901ea.svg)'
- en: IFC originated with military applications and classified data
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IFC起源于军事应用和机密数据
- en: Every piece of data in the system has a label
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中的每个数据都有一个标签
- en: Every process/thread has a label
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程/线程都有一个标签
- en: Labels are partially ordered by  ⊑  (“can flow to”)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签部分由 ⊑ （“可以流向”）排序
- en: 'Example: Emacs (labeled *L*[*E*]) accesses file (labeled *L*[*F*])'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：Emacs（标记为*L*[E]）访问文件（标记为*L*[F]）
- en: File read? Information flows from file to emacs. System requires *L*[*F*] ⊑ *L*[*E*].
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件读取？信息从文件流向emacs。系统要求*L*[F] ⊑ *L*[E]。
- en: File write? Information flows in both directions. System enforces that *L*[*F*] ⊑ *L*[*E*]
    and *L*[*E*] ⊑ *L*[*F*].
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件写入？信息双向流动。系统强制执行*L*[F] ⊑ *L*[E]和*L*[E] ⊑ *L*[F]。
- en: Labels are transitive
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签是传递的
- en: '![](../Images/ef84f21d5e0772695c5d8eda134eef3d.svg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ef84f21d5e0772695c5d8eda134eef3d.svg)'
- en: ⊑  is a transitive relation - makes it easier to reason about security
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ⊑ 是一个传递关系 - 这样更容易推理安全性
- en: 'Example: Label file so it cannot flow to Internet'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：标记文件，使其无法流向互联网
- en: Policy holds regardless of what other software does
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略不受其他软件的影响
- en: Labels are transitive
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签是传递的
- en: '![](../Images/01d0932bc50fb966db5e25b83f374b86.svg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01d0932bc50fb966db5e25b83f374b86.svg)'
- en: ⊑  is a transitive relation - makes it easier to reason about security
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ⊑ 是一个传递关系 - 这样更容易推理安全性
- en: 'Example: Label file so it cannot flow to Internet'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：标记文件，使其无法流向互联网
- en: Policy holds regardless of what other software does
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略不受其他软件的影响
- en: Suppose a buggy app reads file (e.g., desktop search)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设一个有错误的应用程序读取文件（例如，桌面搜索）。
- en: Labels are transitive
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签是传递的。
- en: '![](../Images/7150dfc3cf6f90f19c745653c18a6750.svg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7150dfc3cf6f90f19c745653c18a6750.svg)'
- en: ⊑  is a transitive relation - makes it easier to reason about security
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ⊑ 是一个传递关系 - 这样更容易推理安全性。
- en: 'Example: Label file so it cannot flow to Internet'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：标记文件，使其无法流向互联网。
- en: Policy holds regardless of what other software does
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略不受其他软件的影响。
- en: Suppose a buggy app reads file (e.g., desktop search)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设一个有错误的应用程序读取文件（例如，桌面搜索）。
- en: Process labeled *L*[bug] reads file, so must have *L*[*F*] ⊑ *L*[bug]
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为*L*[bug]的进程读取文件，因此必须满足*L*[*F*] ⊑ *L*[bug]。
- en: But *L*[*F*] ⊑ *L*[bug] ∧ *L*[bug] ⊑ *L*[net] ⇒ *L*[*F*] ⊑ *L*[net], thus *L*[bug] ! ⊑ *L*[net]
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是*L*[*F*] ⊑ *L*[bug] ∧ *L*[bug] ⊑ *L*[net] ⇒ *L*[*F*] ⊑ *L*[net]，因此*L*[bug] ! ⊑ *L*[net]。
- en: Labels are transitive
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签是传递的。
- en: '![](../Images/544e58fc4babb7c476cba2451cc067dc.svg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/544e58fc4babb7c476cba2451cc067dc.svg)'
- en: ⊑  is a transitive relation - makes it easier to reason about security
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ⊑ 是一个传递关系 - 这样更容易推理安全性。
- en: 'Example: Label file so it cannot flow to Internet'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：标记文件，使其无法流向互联网。
- en: Policy holds regardless of what other software does
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略不受其他软件的影响。
- en: Conversely, any app that can write to network cannot read file
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，任何可以写入网络的应用程序都无法读取文件。
- en: Labels form a lattice
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签形成一个格。
- en: '![](../Images/840793414a406d132eb1f748d430bcd6.svg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/840793414a406d132eb1f748d430bcd6.svg)'
- en: Consider two users, *A* and *B*
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑两个用户，*A*和*B*。
- en: Label public data *L*[∅], *A*’s private data *L*[*A*], *B*’s private data *L*[*B*]
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共数据标签*L*[∅]，*A*的私有数据标签*L*[*A*]，*B*的私有数据标签*L*[*B*]。
- en: What happens if you mix *A*’s and *B*’s private data in a single document?
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在单个文档中混合*A*和*B*的私有数据会发生什么？
- en: Both *A* and *B* should be concerned about the release of such a document
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*和*B*都应该关注这样一个文件的发布。'
- en: Need a label at least as restrictive as both *L*[*A*] and *L*[*B*]
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少需要一个标签，其限制性至少与*L*[*A*]和*L*[*B*]一样严格。
- en: Use the least upper bound (a.k.a. *join*) of *L*[*A*] and *L*[*B*], written
    *L*[*A*] ⊔ *L*[*B*]
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*L*[*A*]和*L*[*B*]的最小上界（也称为*join*），写作*L*[*A*] ⊔ *L*[*B*]。
- en: '**D**IFC is **D**ecentralized'
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**D**IFC是**D**ecentralized。'
- en: '![](../Images/739182ceb37ed21f38e22fda02c3b251.svg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/739182ceb37ed21f38e22fda02c3b251.svg)'
- en: Every process has a set of privileges
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程都有一组特权。
- en: Exercising privilege *p* changes label requirements
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行使特权*p*会改变标签要求。
- en: '*L*[*F*] ⊑ [*p*] *L*[proc] to read, and additionally *L*[proc] ⊑ [*p*] *L*[*F*]
    to write file'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*L*[*F*] ⊑ [*p*] *L*[proc]以读取，并且另外*L*[proc] ⊑ [*p*] *L*[*F*]以写入文件。'
- en: ⊑ [*p*] (``can flow under privileges *p*’’) is more permissive than  ⊑
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ⊑ [*p*]（``可以在特权*p*下流动''）比 ⊑更宽松。
- en: 'Idea: Set labels so you know who has relevant privs.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想法：设置标签，以便知道谁具有相关特权。
- en: Example privileges
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例特权。
- en: '![](../Images/840793414a406d132eb1f748d430bcd6.svg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/840793414a406d132eb1f748d430bcd6.svg)'
- en: Consider again simple two user lattice
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次考虑简单的两用户格。
- en: Let *a* be user *A*’s privileges, *b* be user *B*’s privileges
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让*a*表示用户*A*的特权，*b*表示用户*B*的特权。
- en: Clearly *L*[*A*] ⊑ [*a*] *L*[∅] and *L*[*B*] ⊑ [*b*] *L*[∅]
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然*L*[*A*] ⊑ [*a*] *L*[∅]和*L*[*B*] ⊑ [*b*] *L*[∅]。
- en: Users should be able to make public or *declassify* their own private data
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够公开或*解密*自己的私有数据。
- en: Users should also be able to *partially declassify* data
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户还应该能够*部分解密*数据。
- en: I.e., *L*[*A**B*] ⊑ [*a*] *L*[*B*] and *L*[*A**B*] ⊑ [*b*] *L*[*A*]
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即，*L*[*A**B*] ⊑ [*a*] *L*[*B*]和*L*[*A**B*] ⊑ [*b*] *L*[*A*]。
- en: Example privileges
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例特权。
- en: '![](../Images/df68c9755f9b3f5cc8accd7fe19ccc88.svg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/df68c9755f9b3f5cc8accd7fe19ccc88.svg)'
- en: 'Exercising privileges *a* effectively means:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行使特权*a*实际上意味着：
- en: '*L*[*A*] becomes equivalent to *L*[∅]'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*L*[*A*]变得等同于*L*[∅]。'
- en: '*L*[*A*]*B* becomes equivalent to *L*[*B*]'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*L*[*A*]*B*变得等同于*L*[*B*]。'
- en: The `Sec` monad [[Russo]](http://www.cse.chalmers.se/~russo/seclib.htm), [[Russo]](http://www.cse.chalmers.se/~russo/eci11/lectures/index.shtml)
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Sec`单子[[Russo]](http://www.cse.chalmers.se/~russo/seclib.htm)，[[Russo]](http://www.cse.chalmers.se/~russo/eci11/lectures/index.shtml)。'
- en: Let’s encode a really simple two-point lattice in Haskell’s type system
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们在Haskell的类型系统中编码一个非常简单的两点格。
- en: Let type `H` represent secret (“high”) data, and `L` public (“low”) data
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让类型`H`表示秘密（“高”）数据，`L`表示公共（“低”）数据。
- en: '[PRE13]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Type represents secrecy level, constructor represents privileges
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型表示保密级别，构造函数表示特权。
- en: '[PRE14]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s also (in module `Sec`) represent the lattice (*L* ⊑ *H*) in the type system
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们还（在模块`Sec`中）在类型系统中表示格（*L* ⊑ *H*）。
- en: '[PRE15]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Sec` monad (continued)
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Sec`单子（续）'
- en: Let’s protect secret values with monads by adding to module `Sec`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们通过将模块`Sec`添加到单子中来保护秘密值。
- en: Define two monads, `Sec H` for high data, and `Sec L` for low data
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义两个单子，`Sec H`用于高数据，`Sec L`用于低数据。
- en: '[PRE16]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Allow anyone to label a value, but require privileges to unlabel
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许任何人为值设置标签，但需要特权才能取消标签
- en: '[PRE17]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice `seq` call, ensures “`unlabel undefined secval`” will crash
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意`seq`调用，确保“`unlabel undefined secval`”会崩溃
- en: Allow data to be re-labeled according to  ⊑  relation
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许根据 ⊑ 关系重新标记数据
- en: '[PRE18]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Applying the `Sec` monad
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用`Sec`单子
- en: Untrusted code gets access to sensitive data only in `Sec` monads
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不受信任的代码只能在`Sec`单子中访问敏感数据
- en: 'Possible policy:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的策略：
- en: Data labeled `Sec L` can be sent over network
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为`Sec L`的数据可以发送到网络
- en: Data labeled `Sec H` can only be sent to Google
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为`Sec H`的数据只能发送到 Google
- en: Implement by providing specific trusted functions
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供特定受信任的函数实现
- en: '[PRE19]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This isn’t a very satisfying solution
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不是一个非常令人满意的解决方案
- en: Decision to query google can’t depend on data
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 Google 的决定不能依赖于数据
- en: So we aren’t really getting the full benefit of monads (more like `Applicative`)
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以我们并没有真正获得单子的全部好处（更像`Applicative`）
- en: '`IO` and `Sec`'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IO` 和 `Sec`'
- en: What if instead we combined `Sec` and `IO`?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将`Sec`和`IO`结合会怎样？
- en: '[PRE20]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Safe to run this computation?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行这个计算是安全的吗？
- en: '`IO` and `Sec`'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IO` 和 `Sec`'
- en: What if instead we combined `Sec` and `IO`?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将`Sec`和`IO`结合会怎样？
- en: '[PRE21]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Safe to run this computation? **No!**
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行这个计算是安全的吗？**不！**
- en: '[PRE22]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s combine ideas of `RIO` and `Sec` in a `SecIO` monad
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们在`SecIO`单子中结合`RIO`和`Sec`的想法
- en: '[PRE23]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `SecIO` monad
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SecIO` 单子'
- en: 'Allow `Sec` value to be accessed within `SecIO` monad:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在`SecIO`单子中访问`Sec`值：
- en: '[PRE24]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Can return high values from `SecIO L` by wrapping in `Sec`:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过在`Sec`中包装来自`SecIO L`的高值返回：
- en: '[PRE25]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to represent files (similar for `IORef`s, etc.)?
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何表示文件（类似于`IORef`等）？
- en: '[PRE26]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`SecIO` translator'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SecIO` 翻译器'
- en: Still need privileged function
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然需要特权函数
- en: '[PRE27]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Represents the fact that Google is trusted with high data
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表 Google 受信任高数据的事实
- en: Makes sense you need to implement this to encode policy
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有道理需要实现这个来编码策略
- en: Now implement untrusted code as follows
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在按以下方式实现不受信任的代码
- en: '[PRE28]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Function can invoke `queryGoogle`, but not send data to other places
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以调用`queryGoogle`，但不能将数据发送到其他地方
- en: '`SecIO` does most enforcement at compile time'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecIO` 大部分强制在编译时进行'
- en: 'Problem: for email, really want separate labels for every *user*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题：对于电子邮件，真的希望为每个*用户*单独设置标签
- en: Users added dynamically, so hard to encode this with `Flows`…
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户动态添加，因此很难用`Flows`编码这一点…
- en: LIO monad [[Stefan]](http://www.cse.chalmers.se/~russo/publications_files/haskell11.pdf)
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LIO 单子[[Stefan]](http://www.cse.chalmers.se/~russo/publications_files/haskell11.pdf)
- en: '`cabal install` [`lio`](http://hackage.haskell.org/package/lio)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cabal install` [`lio`](http://hackage.haskell.org/package/lio)'
- en: 'Idea: Let’s keep track of labels *dynamically*, at run time'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想法：让我们在运行时*动态*跟踪标签
- en: Track both *current label* and maximum label or *clearance*
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪*当前标签*和最大标签或*许可*的后门
- en: 'Associate an `LIOState` with each thread:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个线程关联一个`LIOState`：
- en: '[PRE29]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now make `RIO`-like monad that disallows raw `IO`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在制作类似`RIO`的单子，禁止原始`IO`
- en: '[PRE30]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So initially, we can’t do *any* IO within `RIO` monad
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以最初，在`RIO`单子中不能进行*任何* IO
- en: Backdoors for privileged code
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于特权代码的后门
- en: 'Idea: Trustworthy code wraps IO actions with label checks'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想法：可信代码用标签检查包装 IO 操作
- en: 'Need some back doors into IO just for Trustworthy code:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一些 IO 的后门只为可信代码：
- en: '[PRE31]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also handy to have access to state:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也很方便能够访问状态：
- en: '[PRE32]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note important convention: symbols ending …`TCB` never available to safe modules'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意重要的约定：以…`TCB`结尾的符号永远不可用于安全模块
- en: Implementing labels in Haskell
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Haskell 中实现标签
- en: 'Implementing labels as values is straight-forward:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现标签作为值是直接的：
- en: '[PRE33]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What about privileges?
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权怎么样？
- en: Want to know when one privilege subsumes another
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想知道一个特权是否包含另一个特权
- en: '[PRE34]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And how privileges affect the ``canFlowTo`` relation
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权如何影响``canFlowTo``关系
- en: '[PRE35]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Exercise: Implement a `Label` instance'
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：实现一个`Label`实例
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](../Images/36b94bc817dfe70e9165613092e42f6b.svg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/36b94bc817dfe70e9165613092e42f6b.svg)'
- en: '`wget` [`cs240h.stanford.edu/millattice.hs`](http://cs240h.scs.stanford.edu/millattice.hs)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wget` [`cs240h.stanford.edu/millattice.hs`](http://cs240h.scs.stanford.edu/millattice.hs)'
- en: 'Bonus: write some quickcheck properties'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励：编写一些快速检查属性
- en: Solution
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Label instance
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签实例
- en: '[PRE37]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Some quickcheck instances
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些快速检查实例
- en: '[PRE38]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Adjusting and checking labels
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整和检查标签
- en: Before reading any data labeled `newl`, adjust/check `LIOState`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在读取任何标记为`newl`的数据之前，调整/检查`LIOState`
- en: '[PRE39]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Before writing any data labeled `newl`, adjust/check `LIOState`
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在写入任何标记为`newl`的数据之前，调整/检查`LIOState`
- en: '[PRE40]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Privileges vs. privilege descriptions
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特权 vs. 特权描述
- en: Want to be able to name/examine privileges in any context
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望能够在任何上下文中命名/检查特权
- en: '*Embody* the privileges by wrapping them with in protected `newtype`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在受保护的`newtype`中包装*体现*特权
- en: '[PRE41]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Given a `Priv`, can get a description with `privDesc`, but not vice versa
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个`Priv`，可以通过`privDesc`获取描述，但反之则不行
- en: How to create privileges in the first place?
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何首先创建特权？
- en: Generate them in `IO` at start of program, before invoking `LIO`
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序开始时在`IO`中生成它们，然后调用`LIO`
- en: '[PRE42]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Remember, if bad guy can execute arbitrary `IO` code, game over anyway
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，如果坏人可以执行任意的`IO`代码，游戏就结束了
- en: Using `Priv` Objects
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Priv`对象
- en: Many LIO functions have …`P` variants taking privilege
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多LIO函数都有…`P`变体，需要特权
- en: 'E.g., replace calls to `taint` with ones to `taintP`:'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，将对`taint`的调用替换为对`taintP`的调用：
- en: '[PRE43]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Can also delegate privileges, wrap them in closures, or check them by “gating”
    closures
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以委托权限、将它们包装在闭包中，或通过“门控”闭包来检查它们
- en: '[PRE44]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Wrapping IO abstractions
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装IO抽象
- en: Many LIO abstractions just LIO ones plus a label
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多LIO抽象只是LIO本身再加上一个标签
- en: '[PRE45]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`blessTCB` helper makes constructing LIO functions easy'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blessTCB`助手使构建LIO函数变得容易'
- en: through the magic of functional dependencies
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数依赖的魔法
- en: '[PRE46]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: LIO applications
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LIO应用程序
- en: Main application is [Hails](http://hails.scs.stanford.edu/) web framework
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要应用是[Hails](http://hails.scs.stanford.edu/)网络框架
- en: Really a framework for creating web *platforms* hosting mutually distrustful
    apps
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上是一个用于创建托管相互不信任应用程序的网络*平台*的框架
- en: 'Example: [GitStar](http://gitstar.com/)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：[GitStar](http://gitstar.com/)
- en: Host potentially private git repositories
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能托管私有git仓库
- en: Functionality for, say, syntax-highlighting code cannot exfiltrate private sources
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，用于语法高亮代码的功能不能泄露私有源代码
- en: Ongoing research here at Stanford
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斯坦福正在进行的研究
