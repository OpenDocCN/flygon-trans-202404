- en: ジェネリクス (generics)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://typescriptbook.jp/reference/generics](https://typescriptbook.jp/reference/generics)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 型の安全性とコードの共通化の両立は難しいものです。あらゆる型で同じコードを使おうとすると、型の安全性が犠牲になります。逆に、型の安全性を重視しようとすると、同じようなコードを量産する必要が出てコードの共通化が達成しづらくなります。こうした問題を解決するために導入された言語機能がジェネリクスです。ジェネリクスを用いると、**型の安全性とコードの共通化を両立する**ことができます。
  prefs: []
  type: TYPE_NORMAL
- en: ジェネリクスが解決する問題[​](#ジェネリクスが解決する問題 "ジェネリクスが解決する問題 への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ジェネリクスが具体的にどのような問題を解決するのか見ていきましょう。ここに、`chooseRandomlyString()`という普通の関数があります。この関数は、2つの文字列を引数に受け取り、五分五分の確率で第1引数か第2引数の値を抽選して返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`chooseRandomlyString`は文字列の抽選に限っては、この関数を再利用していくことができます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 次に、文字列だけでなく数値の抽選も同じロジックで行う必要が出てきたと考えてみましょう。`chooseRandomlyString()`は文字列にしか対応していないので、数値用の関数を新設しないとなりません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: さらに、五分五分抽選のロジックは汎用的なので、広告のA/Bテストのために`URL`オブジェクト向けの実装も作ることになりました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ここまでで、`chooseRandomly()`関数は二度複製され、型だけが異なる同じ関数が3つもできてしまいました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: では、コードを共通化するにはどうしたらいいのでしょうか？まず考えられる方法としては、型を`any`にしてしまう方法です。この方法の問題点としては、戻り値の型も`any`になってしまうため、コンパイラのチェックが行われなくなり、バグを生みやすくなることです。つまり、型の安全性が損なわれるということです。
  prefs: []
  type: TYPE_NORMAL
- en: '下のサンプルコードでは、`chooseRandomly()`に`number`型を渡していますが、戻り値は`string`型のつもりで扱っています。このコードはコンパイルエラーにはなりませんが、コンパイル後のコードを実行してみると5行目で「TypeError:
    str.toLowerCase is not a function」というエラーが発生します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: コードの共通化と型の安全性の両方を達成するにはどうしたらいいのでしょうか？ここで、役に立つのがジェネリクスです。ジェネリクスの発想は実はとてもシンプルで、「型も変数のように扱えるようにする」というものです。どういうことでしょうか？先に取り上げた重複した3つの関数を「どの部分がそれぞれ異なっているのか？」という視点で見てみましょう。すると、次のように`<>`で強調した部分が違うことに気がつくはずです。それ以外はまったく同じコードです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: このそれぞれ違う部分は型に関するところです。この部分を変数のように扱いたいとしたら、ジェネリクスの文法を知らなくても、プログラマーなら次のようなコードを想像するのではないでしょうか？
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`<type>`に置き換えたところが「型の引数」を表した部分です。値の引数と同様に、この例では型も引数なので`chooseRandomly()`関数を呼び出すときは、`chooseRandomly<string>`のように型を関数に渡します。型をまるで引数のように扱ったコードがここで誕生したわけです。「ジェネリクスは、型も変数のように扱えるようにすること」だと説明しましたが、もうその意味がお分かりなのではないでしょうか。'
  prefs: []
  type: TYPE_NORMAL
- en: 上のコードは、あくまでジェネリクスの発想を理解するためにでっち上げた架空のコードでした。このままではTypeScriptは理解できないので、TypeScriptのジェネリクスの文法で書き直してみましょう。架空のコードともそこまでかけ離れてはいません。次のように書きます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`chooseRandomly`の`<T>`は型変数名の定義です。慣習として`T`がよく使われますが、`A`でも`Type`でも構いません。関数の引数の型や戻り値の型として書かれた`T`は型変数を参照しています。'
  prefs: []
  type: TYPE_NORMAL
- en: 先ほどコンパイル時には気づけなかったバグコードに、ジェネリクス化した`chooseRandomly`を使ってみましょう。すると、「Argument of
    type '0' is not assignable to parameter of type 'string'.」というコンパイルエラーが発生するようになり、`string`型を入れなければならないところに`0`を代入しているバグに気づくことができるようになりました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: これまでで、ジェネリックではない関数たちを共通化した上で、さらに型の安全性を確保していく過程を見ながら、ジェネリクスが解決する問題点について説明してきました。ジェネリクスはコードの共通化と型の安全性を両立してくれる言語機能です。汎用的なコードをさまざまな型で使えるようにしたい際に、ジェネリクスを使うことを考えてみてください。
  prefs: []
  type: TYPE_NORMAL
- en: まとめ[​](#まとめ "まとめ への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: コードの共通化すると、型の安全性が弱まる。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 型の安全性を高めると、コードの共通化が難しくなる。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ジェネリクスは、コードの共通化と型の安全性を両立するための言語機能。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ジェネリクスは、型も引数のように扱うという発想。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
