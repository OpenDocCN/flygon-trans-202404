["```\n\n```", "```\n\n# Basic Extraction\n\n    In its simplest form, extracting an efficient program from one\n    written in Coq is completely straightforward. \n\n    First we say what language we want to extract into.  Options are\n    OCaml (the most mature), Haskell (which mostly works), and\n    Scheme (a bit out of date).\n\n```", "```\n\n    Now we load up the Coq environment with some definitions, either\n    directly or by importing them from other modules.\n\n```", "```\n\n    Finally, we tell Coq the name of a definition to extract and the\n    name of a file to put the extracted code into.\n\n```", "```\n\n    When Coq processes this command, it generates a file imp1.ml\n    containing an extracted version of ceval_step, together with\n    everything that it recursively depends on.  Compile the present\n    .v file and have a look at imp1.ml now.\n\n```", "```\nExtract Inductive bool \u21d2 \"bool\" [ \"true\" \"false\" ].\n\n```", "```\nExtract Inductive nat \u21d2 \"int\"\n\u00a0\u00a0[ \"0\" \"(fun x \u2192 x + 1)\" ]\n\u00a0\u00a0\"(fun zero succ n \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if n=0 then zero () else succ (n-1))\".\n\n```", "```\nExtract Constant plus \u21d2 \"( + )\".\nExtract Constant mult \u21d2 \"( * )\".\nExtract Constant beq_nat \u21d2 \"( = )\".\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Extract\u00a0Constant\u00a0minus\u00a0\u21d2\u00a0\"( - )\".\n\n    but doing so could lead to serious confusion!  (Why?)\n\n```", "```\n\n    Have a look at the file imp2.ml.  Notice how the fundamental\n    definitions have changed from imp1.ml.\n\n```", "```\nRequire Import Ascii String.\nExtract Inductive ascii \u21d2 char\n[\n\"(* If this appears, you're using Ascii internals. Please don't *) (fun (b0,b1,b2,b3,b4,b5,b6,b7) \u2192 let f b i = if b then 1 lsl i else 0 in Char.chr (f b0 0 + f b1 1 + f b2 2 + f b3 3 + f b4 4 + f b5 5 + f b6 6 + f b7 7))\"\n]\n\"(* If this appears, you're using Ascii internals. Please don't *) (fun f c \u2192 let n = Char.code c in let h i = (n land (1 lsl i)) \u2260 0 in f (h 0) (h 1) (h 2) (h 3) (h 4) (h 5) (h 6) (h 7))\".\nExtract Constant zero \u21d2 \"'\\000'\".\nExtract Constant one \u21d2 \"'\\001'\".\nExtract Constant shift \u21d2\n\u00a0\"fun b c \u2192 Char.chr (((Char.code c) lsl 1) land 255 + if b then 1 else 0)\".\nExtract Inlined Constant ascii_dec \u21d2 \"(=)\".\n\n```", "```\nExtract Inductive sumbool \u21d2 \"bool\" [\"true\" \"false\"].\n\n```", "```\nRequire Import Imp.\nRequire Import ImpParser.\nExtraction \"imp.ml\" empty_state ceval_step parse.\n\n```", "```\n        ocamlc -w -20 -w -26 -o impdriver imp.mli imp.ml impdriver.ml\n        ./impdriver\n\n```", "```\n\n# Discussion\n\n    Since we've proved that the ceval_step function behaves the same\n    as the ceval relation in an appropriate sense, the extracted\n    program can be viewed as a *certified* Imp interpreter.  Of\n    course, the parser we're using is not certified, since we didn't\n    prove anything about it!\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]