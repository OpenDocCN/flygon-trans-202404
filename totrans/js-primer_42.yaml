- en: Promiseを活用する
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/use-case/ajaxapp/promise/](https://jsprimer.net/use-case/ajaxapp/promise/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ここまでのセクションで、Fetch APIを使ってAjax通信を行い、サーバーから取得したデータを表示できました。 最後に、Fetch APIの返り値でもある**Promise**を活用してソースコードを整理することで、エラーハンドリングをしっかり行います。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#split-function)*関数の分割*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*まずは、大きくなりすぎた`fetchUserInfo`関数を整理しましょう。 この関数では、Fetch APIを使ったデータの取得・HTML文字列の組み立て・組み立てたHTMLの表示をしています。
    そこで、HTML文字列を組み立てる`createView`関数とHTMLを表示する`displayView`関数を作り、処理を分割します。'
  prefs: []
  type: TYPE_NORMAL
- en: また、後述するエラーハンドリングを行いやすくするため、アプリケーションにエントリーポイントを設けます。 `index.js`に新しく`main`関数を作り、`main`関数から`fetchUserInfo`関数を呼び出すようにします。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: ボタンのclickイベントで呼び出す関数もこれまでの`fetchUserInfo`関数から`main`関数に変更します。
  prefs: []
  type: TYPE_NORMAL
- en: index.html
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[](#error-handling)*Promiseのエラーハンドリング*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*次に`fetchUserInfo`関数を変更し、Fetch APIの返り値でもあるPromiseオブジェクトを`return`します。 この変更によって、`fetchUserInfo`関数を呼び出す`main`関数のほうで非同期処理の結果を扱えるようになります。
    Promiseチェーンの中で投げられたエラーは、Promiseの`catch`メソッドを使って一箇所で受け取れます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`fetchUserInfo`関数から返されたPromiseオブジェクトを、`main`関数でエラーハンドリングしてログを出力します。
    `fetchUserInfo`関数の`catch`メソッドでハンドリングしていたエラーは、`main`関数の`catch`メソッドでハンドリングされます。
    一方、Responseの`ok`プロパティで判定していた400や500などのエラーレスポンスがそのままでは`main`関数でハンドリングできません。 そこで、`Promise.reject`メソッドを使ってRejectedなPromiseを返し、Promiseチェーンをエラーの状態にします。
    Promiseチェーンがエラーとなるため、`main`関数の`catch`でハンドリングできます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[](#refactor-promise-chain)*Promiseチェーンのリファクタリング*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*現在の`fetchUserInfo`関数はデータの取得に加えて、HTMLの組み立て（`createView`）と表示（`displayView`）も行っています。
    `fetchUserInfo`関数に処理が集中して見通しが悪いため、`fetchUserInfo`関数はデータの取得だけを行うように変更します。 併せて`main`関数で、データの取得（`fetchUserInfo`）、HTMLの組み立て（`createView`）と表示（`displayView`）という一連の流れをPromiseチェーンで行うように変更していきます。'
  prefs: []
  type: TYPE_NORMAL
- en: Promiseの`then`メソッドでつながるPromiseチェーンは、`then`に渡されたコールバック関数の返り値をそのまま次の`then`へ渡します。
    ただし、コールバック関数の返り値がPromiseである場合は、そのPromiseで解決された値を次の`then`に渡します。 つまり、`then`のコールバック関数が同期処理から非同期処理に変わったとしても、次の`then`が受け取る値の型は変わらないということです。
  prefs: []
  type: TYPE_NORMAL
- en: Promiseチェーンを使って処理を分割する利点は、同期処理と非同期処理を区別せずに連鎖できることです。 一般に、同期的に書かれた処理を後から非同期処理へと変更するのは、全体を書き換える必要があるため難しいです。
    そのため、最初から処理を分けておき、処理を`then`を使ってつなぐことで、変更に強いコードを書けます。 どのように処理を区切るかは、それぞれの関数が受け取る値の型と、返す値の型に注目するのがよいでしょう。
    Promiseチェーンで処理を分けることで、それぞれの処理が簡潔になりコードの見通しがよくなります。
  prefs: []
  type: TYPE_NORMAL
- en: '`index.js`の`fetchUserInfo`関数と`main`関数を次のように書き換えます。 まず、`fetchUserInfo`関数がResponseの`json`メソッドの返り値をそのまま返すように変更します。
    Responseの`json`メソッドの返り値はJSONオブジェクトで解決されるPromiseなので、次の`then`ではユーザー情報のJSONオブジェクトが渡されます。
    次に、`main`関数が`fetchUserInfo`関数のPromiseチェーンで、HTMLの組み立て（`createView`）と表示（`displayView`）を行うように変更します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[](#rewrite-to-async-function)*Async Functionへの置き換え*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Promiseチェーンによって、Promiseの非同期処理と同じ見た目で同期処理を記述できるようになりました。 さらにAsync Functionを使うと、同期処理と同じ見た目でPromiseの非同期処理を記述できるようになります。
    Promiseの`then`メソッドによるコールバック関数の入れ子がなくなり、手続き的で可読性が高いコードになります。 また、エラーハンドリングも同期処理と同じく`try...catch`構文を使うことができます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`main`関数を次のように書き換えましょう。まず関数宣言の前に`async`をつけてAsync Functionにしています。 次に`fetchUserInfo`関数の呼び出しに`await`をつけます。
    これによりPromiseに解決されたJSONオブジェクトを`userInfo`変数に代入できます。'
  prefs: []
  type: TYPE_NORMAL
- en: もし`fetchUserInfo`関数の中で例外が投げられた場合は、`try...catch`構文でエラーハンドリングできます。 このように、あらかじめ非同期処理の関数がPromiseを返すようにしておくと、Async
    Functionにリファクタリングしやすくなります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[](#changeable-userid)*ユーザーIDを変更できるようにする*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*仕上げとして、今まで`js-primer-example`で固定としていたユーザーIDを変更できるようにしましょう。 index.htmlに`<input>`タグを追加し、JavaScriptから値を取得するために`userId`というIDを付与しておきます。'
  prefs: []
  type: TYPE_NORMAL
- en: index.html
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: index.jsにも`<input>`タグから値を受け取るための処理を追加すると、最終的に次のようになります。
  prefs: []
  type: TYPE_NORMAL
- en: index.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: アプリケーションを実行すると、次のようになります。 要件を満たすことができたので、このアプリケーションはこれで完成です。
  prefs: []
  type: TYPE_NORMAL
- en: '![完成したアプリケーション](../Images/15c5ac161b62092e5c6077e19e7195b1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[](#section-checklist)*このセクションのチェックリスト*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**   HTMLの組み立てと表示の処理を`createView`関数と`displayView`関数に分離した'
  prefs: []
  type: TYPE_NORMAL
- en: '`main`関数を宣言し、`fetchUserInfo`関数が返すPromiseのエラーハンドリングを行った'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promiseチェーンを使って`fetchUserInfo`関数をリファクタリングした
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Async Function](../../../basic/async/#async-function) を使って`main`関数をリファクタリングした'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.html`に`<input>`タグを追加し、`getUserId`関数でユーザーIDを取得した'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: この章で作成したアプリは次のURLで確認できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[https://jsprimer.net/use-case/ajaxapp/promise/example/](https://jsprimer.net/use-case/ajaxapp/promise/example/)******'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
