["```\n\n    This short (and optional) chapter develops some basic definitions\n    and a few theorems about binary relations in Coq.  The key\n    definitions are repeated where they are actually used (in the\n    [Smallstep](Smallstep.html) chapter), so readers who are already comfortable with\n    these ideas can safely skim or skip this chapter.  However,\n    relations are also a good source of exercises for developing\n    facility with Coq's basic reasoning facilities, so it may be\n    useful to look at this material just after the IndProp\n    chapter.\n\n```", "```\n\n    A binary *relation* on a set X is a family of propositions\n    parameterized by two elements of X \u2014 i.e., a proposition about\n    pairs of elements of X.\n\n```", "```\n\n    Confusingly, the Coq standard library hijacks the generic term\n    \"relation\" for this specific instance of the idea. To maintain\n    consistency with the library, we will do the same.  So, henceforth\n    the Coq identifier relation will always refer to a binary\n    relation between some set and itself, whereas the English word\n    \"relation\" can refer either to the specific Coq concept or the\n    more general concept of a relation between any number of possibly\n    different sets.  The context of the discussion should always make\n    clear which is meant. \n\n    An example relation on nat is le, the less-than-or-equal-to\n    relation, which we usually write n[1] \u2264 n[2].\n\n```", "```\n\n    (Why did we write it this way instead of starting with Inductive le : relation nat...?  Because we wanted to put the first nat\n    to the left of the :, which makes Coq generate a somewhat nicer\n    induction principle for reasoning about \u2264.)\n\n```", "```\nDefinition partial_function {X: Type} (R: relation X) :=\n\u00a0\u00a0\u2200x y[1] y[2] : X, R x y[1] \u2192 R x y[2] \u2192 y[1] = y[2].\n\n```", "```\nPrint next_nat.\n(*\u00a0====>\u00a0Inductive\u00a0next_nat\u00a0(n\u00a0:\u00a0nat)\u00a0:\u00a0nat\u00a0->\u00a0Prop\u00a0:= \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nn\u00a0:\u00a0next_nat\u00a0n\u00a0(S\u00a0n)\u00a0*)\nCheck next_nat : relation nat.\n\nTheorem next_nat_partial_function :\n\u00a0\u00a0\u00a0partial_function next_nat.\n\n    Proof.\n\u00a0\u00a0unfold [partial_function](Rel.html#partial_function).\n\u00a0\u00a0intros x y[1] y[2] H[1] H[2].\n\u00a0\u00a0inversion H[1]. inversion H[2].\n\u00a0\u00a0reflexivity. Qed.\n\n```", "```\nTheorem le_not_a_partial_function :\n\u00a0\u00a0\u00ac (partial_function le).\n\n    Proof.\n\u00a0\u00a0unfold [not](http://coq.inria.fr/library/Coq.Init.Logic.html#not). unfold [partial_function](Rel.html#partial_function). intros Hc.\n\u00a0\u00a0assert (0 = 1) as Nonsense. { \n\u00a0\u00a0\u00a0\u00a0apply Hc with (x := 0).\n\u00a0\u00a0\u00a0\u00a0- apply [le_n](http://coq.inria.fr/library/Coq.Init.Peano.html#le_n).\n\u00a0\u00a0\u00a0\u00a0- apply [le_S](http://coq.inria.fr/library/Coq.Init.Peano.html#le_S). apply [le_n](http://coq.inria.fr/library/Coq.Init.Peano.html#le_n). }\n\u00a0\u00a0inversion Nonsense. Qed.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nDefinition reflexive {X: Type} (R: relation X) :=\n\u00a0\u00a0\u2200a : X, R a a.\n\nTheorem le_reflexive :\n\u00a0\u00a0reflexive le.\n\n    Proof.\n\u00a0\u00a0unfold [reflexive](Rel.html#reflexive). intros n. apply [le_n](http://coq.inria.fr/library/Coq.Init.Peano.html#le_n). Qed.\n\n```", "```\nDefinition transitive {X: Type} (R: relation X) :=\n\u00a0\u00a0\u2200a b c : X, (R a b) \u2192 (R b c) \u2192 (R a c).\n\nTheorem le_trans :\n\u00a0\u00a0transitive le.\n\n    Proof.\n\u00a0\u00a0intros n m o Hnm Hmo.\n\u00a0\u00a0induction Hmo.\n\u00a0\u00a0- (*\u00a0le_n\u00a0*) apply Hnm.\n\u00a0\u00a0- (*\u00a0le_S\u00a0*) apply [le_S](http://coq.inria.fr/library/Coq.Init.Peano.html#le_S). apply IHHmo. Qed.\n\nTheorem lt_trans:\n\u00a0\u00a0transitive lt.\n\n    Proof.\n\u00a0\u00a0unfold [lt](IndProp.html#lt). unfold [transitive](Rel.html#transitive).\n\u00a0\u00a0intros n m o Hnm Hmo.\n\u00a0\u00a0apply [le_S](http://coq.inria.fr/library/Coq.Init.Peano.html#le_S) in Hnm.\n\u00a0\u00a0apply [le_trans](Rel.html#le_trans) with (a := ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S) n)) (b := ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S) m)) (c := o).\n\u00a0\u00a0apply Hnm.\n\u00a0\u00a0apply Hmo. Qed.\n\n```", "```\nTheorem lt_trans' :\n\u00a0\u00a0transitive lt.\nProof.\n\u00a0\u00a0(*\u00a0Prove\u00a0this\u00a0by\u00a0induction\u00a0on\u00a0evidence\u00a0that\u00a0m\u00a0is\u00a0less\u00a0than\u00a0o.\u00a0*)\n\u00a0\u00a0unfold lt. unfold transitive.\n\u00a0\u00a0intros n m o Hnm Hmo.\n\u00a0\u00a0induction Hmo as [| m' Hm'o].\n\u00a0\u00a0\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem lt_trans'' :\n\u00a0\u00a0transitive lt.\n\n    Proof.\n\u00a0\u00a0unfold [lt](IndProp.html#lt). unfold [transitive](Rel.html#transitive).\n\u00a0\u00a0intros n m o Hnm Hmo.\n\u00a0\u00a0induction o as [| o'].\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem le_Sn_le : \u2200n m, S n \u2264 m \u2192 n \u2264 m.\n\n    Proof.\n\u00a0\u00a0intros n m H. apply [le_trans](Rel.html#le_trans) with ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S) n).\n\u00a0\u00a0- apply [le_S](http://coq.inria.fr/library/Coq.Init.Peano.html#le_S). apply [le_n](http://coq.inria.fr/library/Coq.Init.Peano.html#le_n).\n\u00a0\u00a0- apply H.\n    Qed.\n\n```", "```\nTheorem le_S_n : \u2200n m,\n\u00a0\u00a0(S n \u2264 S m) \u2192 (n \u2264 m).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem le_Sn_n : \u2200n,\n\u00a0\u00a0\u00ac (S n \u2264 n).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition symmetric {X: Type} (R: relation X) :=\n\u00a0\u00a0\u2200a b : X, (R a b) \u2192 (R b a).\n\n```", "```\nTheorem le_not_symmetric :\n\u00a0\u00a0\u00ac (symmetric le).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition antisymmetric {X: Type} (R: relation X) :=\n\u00a0\u00a0\u2200a b : X, (R a b) \u2192 (R b a) \u2192 a = b.\n\n```", "```\nTheorem le_antisymmetric :\n\u00a0\u00a0antisymmetric le.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem le_step : \u2200n m p,\n\u00a0\u00a0n < m \u2192\n\u00a0\u00a0m \u2264 S p \u2192\n\u00a0\u00a0n \u2264 p.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition equivalence {X:Type} (R: relation X) :=\n\u00a0\u00a0(reflexive R) \u2227 (symmetric R) \u2227 (transitive R).\n\n```", "```\nDefinition order {X:Type} (R: relation X) :=\n\u00a0\u00a0(reflexive R) \u2227 (antisymmetric R) \u2227 (transitive R).\n\n```", "```\nDefinition preorder {X:Type} (R: relation X) :=\n\u00a0\u00a0(reflexive R) \u2227 (transitive R).\n\nTheorem le_order :\n\u00a0\u00a0order le.\n\n    Proof.\n\u00a0\u00a0unfold [order](Rel.html#order). split.\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0refl\u00a0*) apply [le_reflexive](Rel.html#le_reflexive).\n\u00a0\u00a0\u00a0\u00a0- split.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0antisym\u00a0*) apply [le_antisymmetric](Rel.html#le_antisymmetric).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0transitive.\u00a0*) apply [le_trans](Rel.html#le_trans). Qed.\n\n```", "```\nInductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n\u00a0\u00a0\u00a0\u00a0| rt_step : \u2200x y, R x y \u2192 clos_refl_trans R x y\n\u00a0\u00a0\u00a0\u00a0| rt_refl : \u2200x, clos_refl_trans R x x\n\u00a0\u00a0\u00a0\u00a0| rt_trans : \u2200x y z,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clos_refl_trans R x y \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clos_refl_trans R y z \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clos_refl_trans R x z.\n\n```", "```\nTheorem next_nat_closure_is_le : \u2200n m,\n\u00a0\u00a0(n \u2264 m) \u2194 ((clos_refl_trans next_nat) n m).\n\n    Proof.\n\u00a0\u00a0intros n m. split.\n\u00a0\u00a0- (*\u00a0->\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intro H. induction H.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0le_n\u00a0*) apply [rt_refl](Rel.html#rt_refl).\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0le_S\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [rt_trans](Rel.html#rt_trans) with m. apply IHle. apply [rt_step](Rel.html#rt_step).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [nn](IndProp.html#nn).\n\u00a0\u00a0- (*\u00a0<-\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intro H. induction H.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0rt_step\u00a0*) inversion H. apply [le_S](http://coq.inria.fr/library/Coq.Init.Peano.html#le_S). apply [le_n](http://coq.inria.fr/library/Coq.Init.Peano.html#le_n).\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0rt_refl\u00a0*) apply [le_n](http://coq.inria.fr/library/Coq.Init.Peano.html#le_n).\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0rt_trans\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [le_trans](Rel.html#le_trans) with y.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHclos_refl_trans1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHclos_refl_trans2. Qed.\n\n```", "```\nInductive clos_refl_trans_1n {A : Type}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(R : relation A) (x : A)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: A \u2192 Prop :=\n\u00a0\u00a0| rt1n_refl : clos_refl_trans_1n R x x\n\u00a0\u00a0| rt1n_trans (y z : A) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0R x y \u2192 clos_refl_trans_1n R y z \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clos_refl_trans_1n R x z.\n\n```", "```\nLemma rsc_R : \u2200(X:Type) (R:relation X) (x y : X),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0R x y \u2192 clos_refl_trans_1n R x y.\n\n    Proof.\n\u00a0\u00a0intros X R x y H.\n\u00a0\u00a0apply [rt1n_trans](Rel.html#rt1n_trans) with y. apply H. apply [rt1n_refl](Rel.html#rt1n_refl). Qed.\n\n```", "```\nLemma rsc_trans :\n\u00a0\u00a0\u2200(X:Type) (R: relation X) (x y z : X),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clos_refl_trans_1n R x y  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clos_refl_trans_1n R y z \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clos_refl_trans_1n R x z.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem rtc_rsc_coincide :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2200(X:Type) (R: relation X) (x y : X),\n\u00a0\u00a0clos_refl_trans R x y \u2194 clos_refl_trans_1n R x y.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n```"]