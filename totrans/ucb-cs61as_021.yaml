- en: Common Recursive Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The "Every" Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a procedure to square every number in a sentence of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a procedure to translate every word of a sentence into Pig Latin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The pattern here is pretty clear. Our recursive case will do something straightforward
    to the `first` of the sentence, such as `square`ing it or `pigl`ing it, and we'll
    combine that with the result of a recursive call on the `butfirst` of the sentence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** This is Exercise 5 on your Homework.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a procedure called `initials` that takes in a sentence as its argument
    and returns a sentence of the first letter of each word in the sentence. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The "Keep" Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the "every" pattern, we collect the results of transforming each element
    of a word or sentence into something else. This time we''ll consider a different
    kind of problem: choosing some of the elements and filtering out the others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here is a procedure to select the three-letter words from a sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, here is a procedure to select the vowels from a word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the differences between the "every" pattern and the "keep" pattern.
    First of all, the "keep" procedures have three cases, instead of just two as in
    most of the "every" procedures. In the "every" pattern, we only have to distinguish
    between the base case and the recursive case. In the "keep" pattern, there is
    still a base case, but there are two recursive cases: we have to decide whether
    or not to keep the first available element in the return value. When we do keep
    an element, we keep the element itself, not some function of the element.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Write a procedure called `numbers` that takes a sentence as its argument and
    returns another sentence containing only the numbers in the sentence. You may
    find the `number?` predicate useful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The "Accumulate" Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are two recursive procedures for functions that follow the "accumulate"
    pattern, which combines all of the elements of the argument into a single result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What's the pattern? We're using some combiner (`+` or `word`) to connect the
    word we're up to with the result of the recursive call. The base case tests for
    an empty argument, but the base case return value must be the identity element
    of the combiner function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we went through various functions as an example of recursion.
    Which of these functions below follow the accumulate pattern? Select all that
    apply.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
