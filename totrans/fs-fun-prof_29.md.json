["```\nMe to co-worker: \"We need a function that will add two numbers together, would you mind implementing it?\" \n(a short time later) \nCo-worker: \"I just finished implementing the 'add' function\" \nMe: \"Great, have you written unit tests for it?\" \nCo-worker: \"You want tests as well?\" (rolls eyes) \"Ok.\" \n(a short time later) \nCo-worker: \"I just wrote a test. Look! 'Given 1 + 2, I expect output is 3'. \" \nCo-worker: \"So can we call it done now?\" \nMe: \"Well that's only *one* test. How do you know that it doesn't fail for other inputs?\" \nCo-worker: \"Ok, let me do another one.\" \n(a short time later) \nCo-worker: \"I just wrote a another awesome test. 'Given 2 + 2, I expect output is 4'\" \nMe: \"Yes, but you're still only testing for special cases. How do you know that it doesn't fail for other inputs you haven't thought of?\" \nCo-worker: \"You want even *more* tests?\"\n(mutters \"slavedriver\" under breath and walks away) \n```", "```\n[<Test>]\nlet ``When I add 1 + 2, I expect 3``()=\n    let result = add 1 2\n    Assert.AreEqual(3,result) \n```", "```\nlet add x y =\n    if x=1 && y=2 then \n        3\n    else\n        0 \n```", "```\n[<Test>]\nlet ``When I add 2 + 2, I expect 4``()=\n    let result = add 2 2\n    Assert.AreEqual(4,result) \n```", "```\nlet add x y =\n    if x=1 && y=2 then \n        3\n    else if x=2 && y=2 then \n        4\n    else\n        0 \n```", "```\n[<Test>]\nlet ``When I add two numbers, I expect to get their sum``()=\n    for (x,y,expected) in [ (1,2,3); (2,2,4); (3,5,8); (27,15,42); ]\n        let actual = add x y\n        Assert.AreEqual(expected,actual) \n```", "```\nlet rand = System.Random()\nlet randInt() = rand.Next()\n\n[<Test>]\nlet ``When I add two random numbers, I expect their sum``()=\n    let x = randInt()\n    let y = randInt()\n    let expected = x + y\n    let actual = add x y\n    Assert.AreEqual(expected,actual) \n```", "```\n[<Test>]\nlet ``When I add two random numbers (100 times), I expect their sum``()=\n    for _ in [1..100] do\n        let x = randInt()\n        let y = randInt()\n        let expected = x + y\n        let actual = add x y\n        Assert.AreEqual(expected,actual) \n```", "```\n[<Test>]\nlet ``When I add two numbers, the result should not depend on parameter order``()=\n    for _ in [1..100] do\n        let x = randInt()\n        let y = randInt()\n        let result1 = add x y\n        let result2 = add y x // reversed params\n        Assert.AreEqual(result1,result2) \n```", "```\nlet result1 = add x x   \nlet result2 = x * 2     \nAssert.AreEqual(result1,result2) \n```", "```\n[<Test>]\nlet ``Adding 1 twice is the same as adding 2``()=\n    for _ in [1..100] do\n        let x = randInt()\n        let y = randInt()\n        let result1 = x |> add 1 |> add 1\n        let result2 = x |> add 2 \n        Assert.AreEqual(result1,result2) \n```", "```\nlet add x y = 0  // malicious implementation \n```", "```\n[<Test>]\nlet ``Adding zero is the same as doing nothing``()=\n    for _ in [1..100] do\n        let x = randInt()\n        let result1 = x |> add 0\n        let result2 = x  \n        Assert.AreEqual(result1,result2) \n```", "```\nlet propertyCheck property = \n    // property has type: int -> int -> bool\n    for _ in [1..100] do\n        let x = randInt()\n        let y = randInt()\n        let result = property x y\n        Assert.IsTrue(result) \n```", "```\nlet commutativeProperty x y = \n    let result1 = add x y\n    let result2 = add y x // reversed params\n    result1 = result2\n\n[<Test>]\nlet ``When I add two numbers, the result should not depend on parameter order``()=\n    propertyCheck commutativeProperty \n```", "```\nlet rand = System.Random()\nlet randInt() = rand.Next()\n\nlet add x y = x + y  // correct implementation\n\nlet propertyCheck property = \n    // property has type: int -> int -> bool\n    for _ in [1..100] do\n        let x = randInt()\n        let y = randInt()\n        let result = property x y\n        Assert.IsTrue(result)\n\nlet commutativeProperty x y = \n    let result1 = add x y\n    let result2 = add y x // reversed params\n    result1 = result2\n\n[<Test>]\nlet ``When I add two numbers, the result should not depend on parameter order``()=\n    propertyCheck commutativeProperty \n\nlet adding1TwiceIsAdding2OnceProperty x _ = \n    let result1 = x |> add 1 |> add 1\n    let result2 = x |> add 2 \n    result1 = result2\n\n[<Test>]\nlet ``Adding 1 twice is the same as adding 2``()=\n    propertyCheck adding1TwiceIsAdding2OnceProperty \n\nlet identityProperty x _ = \n    let result1 = x |> add 0\n    result1 = x\n\n[<Test>]\nlet ``Adding zero is the same as doing nothing``()=\n    propertyCheck identityProperty \n```", "```\nSystem.IO.Directory.SetCurrentDirectory (__SOURCE_DIRECTORY__)\n#I @\"Packages\\FsCheck.1.0.3\\lib\\net45\"\n//#I @\"Packages\\FsCheck.0.9.2.0\\lib\\net40-Client\"  // use older version for VS2012\n#I @\"Packages\\NUnit.2.6.3\\lib\"\n#r @\"FsCheck.dll\"\n#r @\"nunit.framework.dll\"\n\nopen System\nopen FsCheck\nopen NUnit.Framework \n```", "```\nlet add x y = x + y  // correct implementation\n\nlet commutativeProperty (x,y) = \n    let result1 = add x y\n    let result2 = add y x // reversed params\n    result1 = result2\n\n// check the property interactively \nCheck.Quick commutativeProperty \n\nlet adding1TwiceIsAdding2OnceProperty x = \n    let result1 = x |> add 1 |> add 1\n    let result2 = x |> add 2 \n    result1 = result2\n\n// check the property interactively \nCheck.Quick adding1TwiceIsAdding2OnceProperty \n\nlet identityProperty x = \n    let result1 = x |> add 0\n    result1 = x\n\n// check the property interactively \nCheck.Quick identityProperty \n```", "```\nOk, passed 100 tests. \n```", "```\nlet add x y =\n    x * y // malicious implementation\n\nlet adding1TwiceIsAdding2OnceProperty x = \n    let result1 = x |> add 1 |> add 1\n    let result2 = x |> add 2 \n    result1 = result2\n\n// check the property interactively \nCheck.Quick adding1TwiceIsAdding2OnceProperty \n```", "```\nFalsifiable, after 1 test (1 shrink) (StdGen (1657127138,295941511)):\n1 \n```", "```\nlet add x y = \n    if (x < 10) || (y < 10) then\n        x + y  // correct for low values\n    else\n        x * y  // incorrect for high values \n```", "```\nlet associativeProperty x y z = \n    let result1 = add x (add y z)    // x + (y + z)\n    let result2 = add (add x y) z    // (x + y) + z\n    result1 = result2\n\n// check the property interactively \nCheck.Quick associativeProperty \n```", "```\nFalsifiable, after 38 tests (4 shrinks) (StdGen (127898154,295941554)):\n8\n2\n10 \n```", "```\n// get the generator for ints\nlet intGenerator = Arb.generate<int>\n\n// generate three ints with a maximum size of 1\nGen.sample 1 3 intGenerator    // e.g. [0; 0; -1]\n\n// generate three ints with a maximum size of 10\nGen.sample 10 3 intGenerator   // e.g. [-4; 8; 5]\n\n// generate three ints with a maximum size of 100\nGen.sample 100 3 intGenerator  // e.g. [-37; 24; -62] \n```", "```\n// see how the values are clustered around the center point\nintGenerator \n|> Gen.sample 10 1000 \n|> Seq.groupBy id \n|> Seq.map (fun (k,v) -> (k,Seq.length v))\n|> Seq.sortBy (fun (k,v) -> k)\n|> Seq.toList \n```", "```\n[(-10, 3); (-9, 14); (-8, 18); (-7, 10); (-6, 27); (-5, 42); (-4, 49);\n   (-3, 56); (-2, 76); (-1, 119); (0, 181); (1, 104); (2, 77); (3, 62);\n   (4, 47); (5, 44); (6, 26); (7, 16); (8, 14); (9, 12); (10, 3)] \n```", "```\nintGenerator \n|> Gen.sample 30 10000 \n|> Seq.groupBy id \n|> Seq.map (fun (k,v) -> (k,Seq.length v))\n|> Seq.sortBy (fun (k,v) -> k)\n|> Seq.toList \n```", "```\nlet tupleGenerator = Arb.generate<int*int*int>\n\n// generate 3 tuples with a maximum size of 1\nGen.sample 1 3 tupleGenerator \n// result: [(0, 0, 0); (0, 0, 0); (0, 1, -1)]\n\n// generate 3 tuples with a maximum size of 10\nGen.sample 10 3 tupleGenerator \n// result: [(-6, -4, 1); (2, -2, 8); (1, -4, 5)]\n\n// generate 3 tuples with a maximum size of 100\nGen.sample 100 3 tupleGenerator \n// result: [(-2, -36, -51); (-5, 33, 29); (13, 22, -16)] \n```", "```\nlet intOptionGenerator = Arb.generate<int option>\n// generate 10 int options with a maximum size of 5\nGen.sample 5 10 intOptionGenerator \n// result:  [Some 0; Some -1; Some 2; Some 0; Some 0; \n//           Some -4; null; Some 2; Some -2; Some 0] \n```", "```\nlet intListGenerator = Arb.generate<int list>\n// generate 10 int lists with a maximum size of 5\nGen.sample 5 10 intListGenerator \n// result:  [ []; []; [-4]; [0; 3; -1; 2]; [1]; \n//            [1]; []; [0; 1; -2]; []; [-1; -2]] \n```", "```\nlet stringGenerator = Arb.generate<string>\n\n// generate 3 strings with a maximum size of 1\nGen.sample 1 3 stringGenerator \n// result: [\"\"; \"!\"; \"I\"]\n\n// generate 3 strings with a maximum size of 10\nGen.sample 10 3 stringGenerator \n// result: [\"\"; \"eiX$a^\"; \"U%0Ika&r\"] \n```", "```\ntype Color = Red | Green of int | Blue of bool\n\nlet colorGenerator = Arb.generate<Color>\n\n// generate 10 colors with a maximum size of 50\nGen.sample 50 10 colorGenerator \n\n// result:  [Green -47; Red; Red; Red; Blue true; \n//           Green 2; Blue false; Red; Blue true; Green -12] \n```", "```\ntype Point = {x:int; y:int; color: Color}\n\nlet pointGenerator = Arb.generate<Point>\n\n// generate 10 points with a maximum size of 50\nGen.sample 50 10 pointGenerator \n\n(* result\n[{x = -8; y = 12; color = Green -4;}; \n {x = 28; y = -31; color = Green -6;}; \n {x = 11; y = 27; color = Red;}; \n {x = -2; y = -13; color = Red;};\n {x = 6; y = 12; color = Red;};\n // etc\n*) \n```", "```\nlet isSmallerThan80 x = x < 80 \n```", "```\nisSmallerThan80 100 // false, so start shrinking\n\nArb.shrink 100 |> Seq.toList \n//  [0; 50; 75; 88; 94; 97; 99] \n```", "```\nisSmallerThan80 0 // true\nisSmallerThan80 50 // true\nisSmallerThan80 75 // true\nisSmallerThan80 88 // false, so shrink again \n```", "```\nArb.shrink 88 |> Seq.toList \n//  [0; 44; 66; 77; 83; 86; 87]\nisSmallerThan80 0 // true\nisSmallerThan80 44 // true\nisSmallerThan80 66 // true\nisSmallerThan80 77 // true\nisSmallerThan80 83 // false, so shrink again \n```", "```\nArb.shrink 83 |> Seq.toList \n//  [0; 42; 63; 73; 78; 81; 82]\n// smallest failure is 81, so shrink again \n```", "```\nArb.shrink 81 |> Seq.toList \n//  [0; 41; 61; 71; 76; 79; 80]\n// smallest failure is 80 \n```", "```\nArb.shrink (1,2,3) |> Seq.toList \n//  [(0, 2, 3); (1, 0, 3); (1, 1, 3); (1, 2, 0); (1, 2, 2)]\n\nArb.shrink \"abcd\" |> Seq.toList \n//  [\"bcd\"; \"acd\"; \"abd\"; \"abc\"; \"abca\"; \"abcb\"; \"abcc\"; \"abad\"; \"abbd\"; \"aacd\"]\n\nArb.shrink [1;2;3] |> Seq.toList \n//  [[2; 3]; [1; 3]; [1; 2]; [1; 2; 0]; [1; 2; 2]; [1; 0; 3]; [1; 1; 3]; [0; 2; 3]] \n```", "```\n// silly property to test\nlet isSmallerThan80 x = x < 80\n\nCheck.Quick isSmallerThan80 \n// result: Ok, passed 100 tests. \n```", "```\nlet config = {\n    Config.Quick with \n        MaxTest = 1000\n    }\nCheck.One(config,isSmallerThan80 )\n// result: Ok, passed 1000 tests. \n```", "```\nlet config = {\n    Config.Quick with \n        MaxTest = 10000\n    }\nCheck.One(config,isSmallerThan80 )\n// result: Falsifiable, after 8660 tests (1 shrink) (StdGen (539845487,295941658)):\n//         80 \n```", "```\nlet config = {\n    Config.Quick with \n        EndSize = 1000\n    }\nCheck.One(config,isSmallerThan80 )\n// result: Falsifiable, after 21 tests (4 shrinks) (StdGen (1033193705,295941658)):\n//         80 \n```", "```\nlet add x y = \n    if (x < 25) || (y < 25) then\n        x + y  // correct for low values\n    else\n        x * y  // incorrect for high values\n\nlet associativeProperty x y z = \n    let result1 = add x (add y z)    // x + (y + z)\n    let result2 = add (add x y) z    // (x + y) + z\n    result1 = result2\n\n// check the property interactively \nCheck.Quick associativeProperty \n```", "```\nFalsifiable, after 66 tests (12 shrinks) (StdGen (1706196961,295941556)):\n1\n24\n25 \n```", "```\n// check the property interactively \nCheck.Quick associativeProperty \n\n// with tracing/logging\nCheck.Verbose associativeProperty \n```", "```\n0:    // test 1\n-1    // param 1\n-1    // param 2 \n0     // param 3 \n      // associativeProperty -1 -1 0  => true, keep going\n1:    // test 2\n0\n0\n0     // associativeProperty 0 0 0  => true, keep going\n2:    // test 3\n-2\n0\n-3    // associativeProperty -2 0 -3  => true, keep going\n3:    // test 4\n1\n2\n0     // associativeProperty 1 2 0  => true, keep going\n// etc\n49:   // test 50\n46\n-4\n50    // associativeProperty 46 -4 50  => false, start shrinking\n// etc\nshrink:\n35\n-4\n50    // associativeProperty 35 -4 50  => false, keep shrinking\nshrink:\n27\n-4\n50    // associativeProperty 27 -4 50  => false, keep shrinking\n// etc\nshrink:\n25\n1\n29    // associativeProperty 25 1 29  => false, keep shrinking\nshrink:\n25\n1\n26    // associativeProperty 25 1 26  => false, keep shrinking\n// next shrink fails\nFalsifiable, after 50 tests (10 shrinks) (StdGen (995282583,295941602)):\n25\n1\n26 \n```", "```\n// create a function for displaying a test\nlet printTest testNum [x;y;z] = \n    sprintf \"#%-3i %3O %3O %3O\\n\" testNum x y z\n\n// create a function for displaying a shrink\nlet printShrink [x;y;z] = \n    sprintf \"shrink %3O %3O %3O\\n\" x y z\n\n// create a new FsCheck configuration\nlet config = {\n    Config.Quick with \n        Replay = Random.StdGen (995282583,295941602) |> Some \n        Every = printTest \n        EveryShrink = printShrink\n    }\n\n// check the given property with the new configuration\nCheck.One(config,associativeProperty) \n```", "```\n#0    -1  -1   0\n#1     0   0   0\n#2    -2   0  -3\n#3     1   2   0\n#4    -4   2  -3\n#5     3   0  -3\n#6    -1  -1  -1\n// etc\n#46  -21 -25  29\n#47  -10  -7 -13\n#48   -4 -19  23\n#49   46  -4  50\n// start shrinking first parameter\nshrink  35  -4  50\nshrink  27  -4  50\nshrink  26  -4  50\nshrink  25  -4  50\n// start shrinking second parameter\nshrink  25   4  50\nshrink  25   2  50\nshrink  25   1  50\n// start shrinking third parameter\nshrink  25   1  38\nshrink  25   1  29\nshrink  25   1  26\nFalsifiable, after 50 tests (10 shrinks) (StdGen (995282583,295941602)):\n25\n1\n26 \n```", "```\n// The last set of inputs (46,-4,50) was false, so shrinking started\nassociativeProperty 46 -4 50  // false, so shrink\n\n// list of possible shrinks starting at 46\nArb.shrink 46 |> Seq.toList \n// result [0; 23; 35; 41; 44; 45] \n```", "```\n// find the next test that fails when shrinking the x parameter \nlet x,y,z = (46,-4,50) \nArb.shrink x\n|> Seq.tryPick (fun x -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (35, -4, 50) \n```", "```\n// find the next test that fails when shrinking the x parameter \nlet x,y,z = (35,-4,50) \nArb.shrink x\n|> Seq.tryPick (fun x -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (27, -4, 50) \n```", "```\n// find the next test that fails when shrinking the x parameter \nlet x,y,z = (27,-4,50) \nArb.shrink x\n|> Seq.tryPick (fun x -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (26, -4, 50)\n\n// find the next test that fails when shrinking the x parameter \nlet x,y,z = (26,-4,50) \nArb.shrink x\n|> Seq.tryPick (fun x -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (25, -4, 50)\n\n// find the next test that fails when shrinking the x parameter \nlet x,y,z = (25,-4,50) \nArb.shrink x\n|> Seq.tryPick (fun x -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer None \n```", "```\n// find the next test that fails when shrinking the y parameter \nlet x,y,z = (25,-4,50) \nArb.shrink y\n|> Seq.tryPick (fun y -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (25, 4, 50)\n\n// find the next test that fails when shrinking the y parameter \nlet x,y,z = (25,4,50) \nArb.shrink y\n|> Seq.tryPick (fun y -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (25, 2, 50)\n\n// find the next test that fails when shrinking the y parameter \nlet x,y,z = (25,2,50) \nArb.shrink y\n|> Seq.tryPick (fun y -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (25, 1, 50)\n\n// find the next test that fails when shrinking the y parameter \nlet x,y,z = (25,1,50) \nArb.shrink y\n|> Seq.tryPick (fun y -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer None \n```", "```\n// find the next test that fails when shrinking the z parameter \nlet x,y,z = (25,1,50) \nArb.shrink z\n|> Seq.tryPick (fun z -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (25, 1, 38)\n\n// find the next test that fails when shrinking the z parameter \nlet x,y,z = (25,1,38) \nArb.shrink z\n|> Seq.tryPick (fun z -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (25, 1, 29)\n\n// find the next test that fails when shrinking the z parameter \nlet x,y,z = (25,1,29) \nArb.shrink z\n|> Seq.tryPick (fun z -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer (25, 1, 26)\n\n// find the next test that fails when shrinking the z parameter \nlet x,y,z = (25,1,26) \nArb.shrink z\n|> Seq.tryPick (fun z -> if associativeProperty x y z then None else Some (x,y,z) )\n// answer None \n```", "```\nlet additionIsNotMultiplication x y = \n    x + y <> x * y \n```", "```\nCheck.Quick additionIsNotMultiplication \n// Falsifiable, after 3 tests (0 shrinks) (StdGen (2037191079,295941699)):\n// 0\n// 0 \n```", "```\nlet additionIsNotMultiplication x y = \n    x + y <> x * y\n\nlet preCondition x y = \n    (x,y) <> (0,0)\n\nlet additionIsNotMultiplication_withPreCondition x y = \n    preCondition x y ==> additionIsNotMultiplication x y \n```", "```\nCheck.Quick additionIsNotMultiplication_withPreCondition\n// Falsifiable, after 38 tests (0 shrinks) (StdGen (1870180794,295941700)):\n// 2\n// 2 \n```", "```\nlet preCondition x y = \n    (x,y) <> (0,0)\n    && (x,y) <> (2,2)\n\nlet additionIsNotMultiplication_withPreCondition x y = \n    preCondition x y ==> additionIsNotMultiplication x y \n```", "```\nCheck.Quick additionIsNotMultiplication_withPreCondition\n// Ok, passed 100 tests. \n```", "```\nlet add x y = x + y // good implementation\n\nlet commutativeProperty x y = \n    add x y = add y x    \n\nlet associativeProperty x y z = \n    add x (add y z) = add (add x y) z    \n\nlet leftIdentityProperty x = \n    add x 0 = x\n\nlet rightIdentityProperty x = \n    add 0 x = x \n```", "```\ntype AdditionSpecification =\n    static member ``Commutative`` x y = commutativeProperty x y\n    static member ``Associative`` x y z = associativeProperty x y z \n    static member ``Left Identity`` x = leftIdentityProperty x \n    static member ``Right Identity`` x = rightIdentityProperty x \n\nCheck.QuickAll<AdditionSpecification>() \n```", "```\ntype AdditionSpecification =\n    static member ``Commutative`` x y = commutativeProperty x y\n    static member ``Associative`` x y z = associativeProperty x y z \n    static member ``Left Identity`` x = leftIdentityProperty x \n    static member ``Right Identity`` x = rightIdentityProperty x \n\n    // some examples as well\n    static member ``1 + 2 = 3``() =  \n        add 1 2 = 3\n\n    static member ``1 + 2 = 2 + 1``() =  \n        add 1 2 = add 2 1 \n\n    static member ``42 + 0 = 0 + 42``() =  \n        add 42 0 = add 0 42 \n```", "```\nopen NUnit.Framework\nopen FsCheck\nopen FsCheck.NUnit\n\n[<Property(QuietOnSuccess = true)>]\nlet ``Commutative`` x y = \n    commutativeProperty x y\n\n[<Property(Verbose= true)>]\nlet ``Associative`` x y z = \n    associativeProperty x y z \n\n[<Property(EndSize=300)>]\nlet ``Left Identity`` x = \n    leftIdentityProperty x \n```", "```\n// sets the current directory to be same as the script directory\nSystem.IO.Directory.SetCurrentDirectory (__SOURCE_DIRECTORY__)\n\n// assumes nuget install FsCheck.Nunit has been run \n// so that assemblies are available under the current directory\n#I @\"Packages\\FsCheck.1.0.3\\lib\\net45\"\n//#I @\"Packages\\FsCheck.0.9.2.0\\lib\\net40-Client\"  // use older version for VS2012\n#I @\"Packages\\NUnit.2.6.3\\lib\"\n\n#r @\"FsCheck.dll\"\n#r @\"nunit.framework.dll\"\n\nopen System\nopen FsCheck\nopen NUnit.Framework \n```", "```\nlet revRevIsOrig (xs:list<int>) = List.rev(List.rev xs) = xs\n\nCheck.Quick revRevIsOrig \n```"]