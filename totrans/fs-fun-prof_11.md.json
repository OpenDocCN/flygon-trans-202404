["```\ndefine typeZ = typeX \"plus\" typeY\ndefine typeW = typeX \"times\" typeZ \n```", "```\ntype A = int * int\ntype B = {FirstName:string; LastName:string}\ntype C = Circle of int | Rectangle of int * int\ntype D = Day | Month | Year\ntype E<'a> = Choice1 of 'a | Choice2 of 'a * 'a\n\ntype MyClass(initX:int) =\n   let x = initX\n   member this.Method() = printf \"x=%i\" x \n```", "```\n module sub = \n    // type declared in a module\n    type A = int * int\n\n    module private helper = \n        // type declared in a submodule\n        type B = B of string list\n\n        //internal access is allowed\n        let b = B [\"a\";\"b\"]\n\n//outside access not allowed\nlet b = sub.helper.B [\"a\";\"b\"] \n```", "```\nlet f x = \n    type A = int * int  //unexpected keyword \"type\"\n    x * x \n```", "```\nlet a = (1,1)\nlet b = { FirstName=\"Bob\"; LastName=\"Smith\" } \nlet c = Circle 99\nlet c' = Rectangle (2,1)\nlet d = Month\nlet e = Choice1 \"a\"\nlet myVal = MyClass 99\nmyVal.Method() \n```", "```\nlet a = (1,1)                                  // \"construct\"\nlet (a1,a2) = a                                // \"deconstruct\"\n\nlet b = { FirstName=\"Bob\"; LastName=\"Smith\" }  // \"construct\"\nlet { FirstName = b1 } = b                     // \"deconstruct\" \n\nlet c = Circle 99                              // \"construct\"\nmatch c with                                   \n| Circle c1 -> printf \"circle of radius %i\" c1 // \"deconstruct\"\n| Rectangle (c2,c3) -> printf \"%i %i\" c2 c3    // \"deconstruct\"\n\nlet c' = Rectangle (2,1)                       // \"construct\"\nmatch c' with                                   \n| Circle c1 -> printf \"circle of radius %i\" c1 // \"deconstruct\"\n| Rectangle (c2,c3) -> printf \"%i %i\" c2 c3    // \"deconstruct\" \n```", "```\ntype ProductCode = string\ntype transform<'a> = 'a -> 'a    \n\n```", "```\n//not explicitly defined with type keyword\n//usage\nlet t = 1,2\nlet s = (3,4)    \n\n```", "```\ntype Product = {code:ProductCode; price:float }\ntype Message<'a> = {id:int; body:'a}\n\n//usage\nlet p = {code=\"X123\"; price=9.99}\nlet m = {id=1; body=\"hello\"}\n\n```", "```\ntype MeasurementUnit = Cm &#124; Inch &#124; Mile \ntype Name = \n    &#124; Nickname of string \n    &#124; FirstLast of string * string\ntype Tree<'a> = \n    &#124; E \n    &#124; T of Tree<'a> * 'a * Tree<'a>\n//usage\nlet u = Inch\nlet name = Nickname(\"John\")\nlet t = T(E,\"John\",E)    \n\n```", "```\ntype Gender = &#124; Male = 1 &#124; Female = 2\n//usage\nlet g = Gender.Male\n\n```", "```\ntype Product (code:string, price:float) = \n   let isFree = price=0.0 \n   new (code) = Product(code,0.0)\n   member this.Code = code \n   member this.IsFree = isFree\n\n//usage\nlet p = Product(\"X123\",9.99)\nlet p2 = Product(\"X123\")    \n\n```", "```\ntype IPrintable =\n   abstract member Print : unit -> unit\n\n```", "```\ntype Product= \n   struct  \n      val code:string\n      val price:float\n      new(code) = { code = code; price = 0.0 }\n   end\n\n//usage\nlet p = Product()\nlet p2 = Product(\"X123\")    \n\n```", "```\ntype [typename] = [existingType] \n```", "```\ntype RealNumber = float\ntype ComplexNumber = float * float\ntype ProductCode = string\ntype CustomerId = int\ntype AdditionFunction = int->int->int\ntype ComplexAdditionFunction = \n       ComplexNumber-> ComplexNumber -> ComplexNumber \n```", "```\ntype AdditionFunction = int->int->int\nlet f:AdditionFunction = fun a b -> a + b \n```", "```\ntype CustomerId = int\ntype OrderId = int \n```", "```\nlet t1 = (2,3)\nlet t2 = (-2,7) \n```", "```\nval t1 : int * int = (2, 3)\nval t2 : int * int = (-2, 7) \n```", "```\nlet t3 = (2,true)\nlet t4 = (7,false)\n\n// the signatures are:\nval t3 : int * bool = (2, true)\nval t4 : int * bool = (7, false) \n```", "```\nlet t5 = (\"hello\",42)\nlet t6 = (\"goodbye\",99)\n\n// the signatures are:\nval t5 : string * int = (\"hello\", 42)\nval t6 : string * int = (\"goodbye\", 99) \n```", "```\nlet t7 = (42,true,\"hello\")\n\n// the signature is:\nval t7 : int * bool * string = (42, true, \"hello\") \n```", "```\nlet genericTupleFn aTuple = \n   let (x,y) = aTuple\n   printfn \"x is %A and y is %A\" x y \n```", "```\nval genericTupleFn : 'a * 'b -> unit \n```", "```\n// define some types\ntype Person = {First:string; Last:string}\ntype Complex = float * float\ntype ComplexComparisonFunction = Complex -> Complex -> int\n\n// define some tuples using them\ntype PersonAndBirthday = Person * System.DateTime\ntype ComplexPair = Complex * Complex\ntype ComplexListAndSortFunction = Complex list * ComplexComparisonFunction\ntype PairOfIntFunctions = (int->int) * (int->int) \n```", "```\n// a function that takes a single tuple parameter \n// but looks like it takes two ints\nlet addConfusingTuple (x,y) = x + y \n```", "```\nlet x = (1,2)                 \nlet y = 1,2        // it's the comma you need, not the parentheses! \nlet z = 1,true,\"hello\",3.14   // create arbitrary tuples as needed \n```", "```\nlet z = 1,true,\"hello\",3.14   // \"construct\"\nlet z1,z2,z3,z4 = z           // \"deconstruct\" \n```", "```\nlet z1,z2 = z     // error FS0001: Type mismatch. \n                  // The tuples have differing lengths \n```", "```\nlet _,z5,_,z6 = z     // ignore 1st and 3rd elements \n```", "```\nlet x = 1,2\nfst x\nsnd x \n```", "```\nlet x = 1,2,3\nfst x              // error FS0001: Type mismatch. \n                   // The tuples have differing lengths of 2 and 3 \n```", "```\nlet tryParse intStr = \n   try\n      let i = System.Int32.Parse intStr\n      (true,i)\n   with _ -> (false,0)  // any exception\n\n//test it\ntryParse \"99\"\ntryParse \"abc\" \n```", "```\n// return word count and letter count in a tuple\nlet wordAndLetterCount (s:string) = \n   let words = s.Split [|' '|]\n   let letterCount = words |> Array.sumBy (fun word -> word.Length ) \n   (words.Length, letterCount)\n\n//test\nwordAndLetterCount \"to be or not to be\" \n```", "```\nlet addOneToTuple aTuple =\n   let (x,y,z) = aTuple\n   (x+1,y+1,z+1)   // create a new one\n\n// try it\naddOneToTuple (1,2,3) \n```", "```\nlet addOneToTuple (x,y,z) = (x+1,y+1,z+1)\n\n// try it\naddOneToTuple (1,2,3) \n```", "```\n(1,2) = (1,2)                      // true\n(1,2,3,\"hello\") = (1,2,3,\"bye\")    // false\n(1,(2,3),4) = (1,(2,3),4)          // true \n```", "```\n(1,2) = (1,2,3)                    // error FS0001: Type mismatch \n```", "```\n(1,2,3) = (1,2,\"hello\")   // element 3 was expected to have type\n                          // int but here has type string \n(1,(2,3),4) = (1,2,(3,4)) // elements 2 & 3 have different types \n```", "```\n(1,2,3).GetHashCode() \n```", "```\n(1,2,3).ToString() \n```", "```\ntype ComplexNumber = { real: float; imaginary: float }\ntype GeoCoord = { lat: float; long: float } \n```", "```\ntype ComplexNumberRecord = { real: float; imaginary: float }\ntype ComplexNumberTuple = float * float \n```", "```\ntype ComplexNumberRecord = { real: float; imaginary: float }\nlet myComplexNumber = { real = 1.1; imaginary = 2.2 } // use equals!\n\ntype GeoCoord = { lat: float; long: float } // use colon in type\nlet myGeoCoord = { lat = 1.1; long = 2.2 }  // use equals in let \n```", "```\nlet myGeoCoord = { lat = 1.1; long = 2.2 }   // \"construct\"\nlet { lat=myLat; long=myLong } = myGeoCoord  // \"deconstruct\" \n```", "```\nlet { lat=_; long=myLong2 } = myGeoCoord  // \"deconstruct\"\nlet { long=myLong3 } = myGeoCoord         // \"deconstruct\" \n```", "```\nlet x = myGeoCoord.lat\nlet y = myGeoCoord.long \n```", "```\nlet myGeoCoord = { lat = 1.1; }  // error FS0764: No assignment\n                                 // given for field 'long' \n```", "```\nlet myGeoCoordA = { lat = 1.1; long = 2.2 }    \nlet myGeoCoordB = { long = 2.2; lat = 1.1 }   // same as above \n```", "```\ntype Person1 = {first:string; last:string}\ntype Person2 = {first:string; last:string}\nlet p = {first=\"Alice\"; last=\"Jones\"} \n```", "```\nlet {first=f; last=l} = p \n```", "```\nlet p = {Person1.first=\"Alice\"; last=\"Jones\"}\nlet { Person1.first=f; last=l} = p \n```", "```\nmodule Module1 = \n  type Person = {first:string; last:string}\n\nmodule Module2 = \n  type Person = {first:string; last:string}\n\nmodule Module3 = \n  let p = {Module1.Person.first=\"Alice\"; \n           Module1.Person.last=\"Jones\"} \n```", "```\nmodule Module3b = \n  open Module1                   // bring into the local namespace\n  let p = {first=\"Alice\"; last=\"Jones\"}  // will be Module1.Person \n```", "```\n// the tuple version of TryParse\nlet tryParseTuple intStr = \n   try\n      let i = System.Int32.Parse intStr\n      (true,i)\n   with _ -> (false,0)  // any exception\n\n// for the record version, create a type to hold the return result\ntype TryParseResult = {success:bool; value:int} \n\n// the record version of TryParse\nlet tryParseRecord intStr = \n   try\n      let i = System.Int32.Parse intStr\n      {success=true;value=i}\n   with _ -> {success=false;value=0}  \n\n//test it\ntryParseTuple \"99\"\ntryParseRecord \"99\"\ntryParseTuple \"abc\"\ntryParseRecord \"abc\" \n```", "```\n//define return type\ntype WordAndLetterCountResult = {wordCount:int; letterCount:int} \n\nlet wordAndLetterCount (s:string) = \n   let words = s.Split [|' '|]\n   let letterCount = words |> Array.sumBy (fun word -> word.Length ) \n   {wordCount=words.Length; letterCount=letterCount}\n\n//test\nwordAndLetterCount \"to be or not to be\" \n```", "```\nlet addOneToGeoCoord aGeoCoord =\n   let {lat=x; long=y} = aGeoCoord\n   {lat = x + 1.0; long = y + 1.0}   // create a new one\n\n// try it\naddOneToGeoCoord {lat=1.1; long=2.2} \n```", "```\nlet addOneToGeoCoord {lat=x; long=y} = {lat=x+1.0; long=y+1.0}\n\n// try it\naddOneToGeoCoord {lat=1.0; long=2.0} \n```", "```\nlet addOneToGeoCoord aGeoCoord =\n   {lat=aGeoCoord.lat + 1.0; long= aGeoCoord.long + 1.0} \n```", "```\nlet g1 = {lat=1.1; long=2.2}\nlet g2 = {g1 with lat=99.9}   // create a new one\n\nlet p1 = {first=\"Alice\"; last=\"Jones\"}  \nlet p2 = {p1 with last=\"Smith\"} \n```", "```\n{first=\"Alice\"; last=\"Jones\"}.GetHashCode() \n```", "```\nprintfn \"%A\" {first=\"Alice\"; last=\"Jones\"}   // nice\n{first=\"Alice\"; last=\"Jones\"}.ToString()     // ugly\nprintfn \"%O\" {first=\"Alice\"; last=\"Jones\"}   // ugly \n```", "```\nprintfn \"%A\" {first=\"Alice\"; last=\"Jones\"}\nprintfn \"%O\" {first=\"Alice\"; last=\"Jones\"} \n```", "```\ntype IntOrBool = \n  | I of int\n  | B of bool \n```", "```\ntype IntOrBool = I of int | B of bool \n```", "```\ntype Person = {first:string; last:string}  // define a record type \ntype IntOrBool = I of int | B of bool\n\ntype MixedType = \n  | Tup of int * int  // a tuple\n  | P of Person       // use the record type defined above\n  | L of int list     // a list of ints\n  | U of IntOrBool    // use the union type defined above \n```", "```\ntype IntOrBool = I of int | B of bool     // without initial bar\ntype IntOrBool = | I of int | B of bool   // with initial bar\ntype IntOrBool = \n   | I of int \n   | B of bool      // with initial bar on separate lines \n```", "```\ntype IntOrBool = int of int| bool of bool\n//  error FS0053: Discriminated union cases \n//                must be uppercase identifiers \n```", "```\ntype MixedType = \n  | P of  {first:string; last:string}  // error \n```", "```\ntype MixedType = \n  | U of (I of int | B of bool)  // error \n```", "```\nopen System\ntype IntOrBool = Int32 of Int32 | Boolean of Boolean \n```", "```\ntype IntOrBool = I of int | B of bool\n\nlet i  = I 99    // use the \"I\" constructor\n// val i : IntOrBool = I 99\n\nlet b  = B true  // use the \"B\" constructor\n// val b : IntOrBool = B true \n```", "```\nval [value name] : [type] = [label] [print of component type]\nval i            : IntOrBool = I       99\nval b            : IntOrBool = B       true \n```", "```\ntype Person = {first:string; last:string}\n\ntype MixedType = \n  | Tup of int * int\n  | P of Person\n\nlet myTup  = Tup (2,99)    // use the \"Tup\" constructor\n// val myTup : MixedType = Tup (2,99)\n\nlet myP  = P {first=\"Al\"; last=\"Jones\"} // use the \"P\" constructor\n// val myP : MixedType = P {first = \"Al\";last = \"Jones\";} \n```", "```\ntype C = Circle of int | Rectangle of int * int\n\n[1..10]\n|> List.map Circle\n\n[1..10]\n|> List.zip [21..30]\n|> List.map Rectangle \n```", "```\ntype IntOrBool1 = I of int | B of bool\ntype IntOrBool2 = I of int | B of bool \n```", "```\nlet x = I 99                // val x : IntOrBool2 = I 99 \n```", "```\nlet x1 = IntOrBool1.I 99    // val x1 : IntOrBool1 = I 99\nlet x2 = IntOrBool2.B true  // val x2 : IntOrBool2 = B true \n```", "```\nmodule Module1 = \n  type IntOrBool = I of int | B of bool\n\nmodule Module2 = \n  type IntOrBool = I of int | B of bool\n\nmodule Module3 =\n  let x = Module1.IntOrBool.I 99 // val x : Module1.IntOrBool = I 99 \n```", "```\n// definition of union type\ntype MixedType = \n  | Tup of int * int\n  | P of Person\n\n// \"deconstruction\" of union type\nlet matcher x = \n  match x with\n  | Tup (x,y) -> \n        printfn \"Tuple matched with %i %i\" x y\n  | P {first=f; last=l} -> \n        printfn \"Person matched with %s %s\" f l\n\nlet myTup = Tup (2,99)                 // use the \"Tup\" constructor\nmatcher myTup  \n\nlet myP = P {first=\"Al\"; last=\"Jones\"} // use the \"P\" constructor\nmatcher myP \n```", "```\ntype Directory = \n  | Root                   // no need to name the root\n  | Subdirectory of string // other directories need to be named \n\ntype Result = \n  | Success                // no string needed for success state\n  | ErrorMessage of string // error message needed \n```", "```\ntype Size = Small | Medium | Large\ntype Answer = Yes | No | Maybe \n```", "```\nlet myDir1 = Root\nlet myDir2 = Subdirectory \"bin\"\n\nlet myResult1 = Success\nlet myResult2 = ErrorMessage \"not found\"\n\nlet mySize1 = Small\nlet mySize2 = Medium \n```", "```\ntype CustomerId = int   // define a type alias\ntype OrderId = int      // define another type alias\n\nlet printOrderId (orderId:OrderId) = \n   printfn \"The orderId is %i\" orderId\n\n//try it\nlet custId = 1          // create a customer id\nprintOrderId custId   // Uh-oh! \n```", "```\ntype CustomerId = CustomerId of int   // define a union type \ntype OrderId = OrderId of int         // define another union type \n\nlet printOrderId (OrderId orderId) =  // deconstruct in the param\n   printfn \"The orderId is %i\" orderId\n\n//try it\nlet custId = CustomerId 1             // create a customer id\nprintOrderId custId                   // Good! A compiler error now. \n```", "```\n// deconstruct in the param\nlet printCustomerId (CustomerId customerIdInt) =     \n   printfn \"The CustomerId is %i\" customerIdInt\n\n// or deconstruct explicitly through let statement\nlet printCustomerId2 custId =     \n   let (CustomerId customerIdInt) = custId  // deconstruct here\n   printfn \"The CustomerId is %i\" customerIdInt\n\n// try it\nlet custId = CustomerId 1             // create a customer id\nprintCustomerId custId                   \nprintCustomerId2 custId \n```", "```\nlet custId = CustomerId 1                \nlet (CustomerId customerIdInt) = custId  // Correct pattern matching\nlet CustomerId customerIdInt = custId    // Wrong! New function? \n```", "```\ntype TypeAlias = A     // type alias!\ntype SingleCase = | A   // single case union type \n```", "```\ntype Contact = Email of string | Phone of int\n\nlet email1 = Email \"bob@example.com\"\nlet email2 = Email \"bob@example.com\"\n\nlet areEqual = (email1=email2) \n```", "```\ntype Contact = Email of string | Phone of int\nlet email = Email \"bob@example.com\"\nprintfn \"%A\" email    // nice\nprintfn \"%O\" email    // ugly! \n```", "```\ntype Option<'a> =       // use a generic definition \n   | Some of 'a           // valid value\n   | None                 // missing \n```", "```\nlet validInt = Some 1\nlet invalidInt = None \n```", "```\nmatch validInt with \n| Some x -> printfn \"the valid value is %A\" x\n| None -> printfn \"the value is None\" \n```", "```\ntype SearchResult1 = Option<string>  // Explicit C#-style generics \ntype SearchResult2 = string option   // built-in postfix keyword \n```", "```\n[1;2;3;4]  |> List.tryFind (fun x-> x = 3)  // Some 3\n[1;2;3;4]  |> List.tryFind (fun x-> x = 10) // None \n```", "```\n// the tuple version of TryParse\nlet tryParseTuple intStr = \n   try\n      let i = System.Int32.Parse intStr\n      (true,i)\n   with _ -> (false,0)  // any exception\n\n// for the record version, create a type to hold the return result\ntype TryParseResult = {success:bool; value:int} \n\n// the record version of TryParse\nlet tryParseRecord intStr = \n   try\n      let i = System.Int32.Parse intStr\n      {success=true;value=i}\n   with _ -> {success=false;value=0}  \n\n// the option version of TryParse\nlet tryParseOption intStr = \n   try\n      let i = System.Int32.Parse intStr\n      Some i\n   with _ -> None\n\n//test it\ntryParseTuple \"99\"\ntryParseRecord \"99\"\ntryParseOption \"99\"\ntryParseTuple \"abc\"\ntryParseRecord \"abc\"\ntryParseOption \"abc\" \n```", "```\nlet o1 = Some 42\nlet o2 = Some 42\n\nlet areEqual = (o1=o2) \n```", "```\nlet o = Some 42\nprintfn \"%A\" o   // nice\nprintfn \"%O\" o   // nice \n```", "```\ntype OptionalString = string option \ntype OptionalPerson = Person option       // optional complex type\ntype OptionalTuple = (int*int) option       \ntype OptionalFunc = (int -> bool) option  // optional function\ntype NestedOptionalString = OptionalString option //nested options!\ntype StrangeOption = string option option option \n```", "```\nlet x = Some 99\n\n// testing using IsSome\nif x.IsSome then printfn \"x is %i\" x.Value   // ugly!!\n\n// no matching at all\nprintfn \"x is %i\" x.Value   // ugly and dangerous!! \n```", "```\nlet x = Some 99\nmatch x with \n| Some i -> printfn \"x is %i\" i\n| None -> () // what to do here? \n```", "```\nlet x = Some 99\nlet result = match x with \n| Some i -> Some(i * 2)\n| None -> None \n```", "```\nlet x = Some 99\nx |> Option.map (fun v -> v * 2) \n```", "```\nlet x = Some 99\nlet result = match x with \n| Some i -> i * 2\n| None -> 0 \n```", "```\nlet x = Some 99\nx |> Option.fold (fun _ v -> v * 2) 0 \n```", "```\nlet x = Some 99\ndefaultArg x 0 \n```", "```\nstring s1 = \"abc\";\nvar len1 = s1.Length;\n\nstring s2 = null;\nvar len2 = s2.Length; \n```", "```\nlet s1 = \"abc\"\nvar len1 = s1.Length\n\n// create a string option with value None\nlet s2 = Option<string>.None\nlet len2 = s2.Length \n```", "```\nlet s2 = Option<string>.None\n\n//which one is it?\nlet len2 = match s2 with\n| Some s -> s.Length\n| None -> 0 \n```", "```\nlet x = \"hello world\" \n```", "```\n// pure F# type is not allowed to be null (in general)\ntype Person = {first:string; last:string}  \nlet p : Person = null                      // error! \n\n// type defined in CLR, so is allowed to be null\nlet s : string = null                      // no error! \nlet line = streamReader.ReadLine()         // no error if null \n```", "```\n// streamReader example\nlet line = match streamReader.ReadLine()  with\n           | null -> None\n           | line -> Some line\n\n// environment example\nlet GetEnvVar var = \n    match System.Environment.GetEnvironmentVariable(var) with\n    | null -> None\n    | value -> Some value\n\n// try it\nGetEnvVar \"PATH\"\nGetEnvVar \"TEST\" \n```", "```\ntype SizeUnion = Small | Medium | Large         // union\ntype ColorEnum = Red=0 | Yellow=1 | Blue=2      // enum \n```", "```\ntype MyEnum = Yes = \"Y\" | No =\"N\"  // Error. Strings not allowed.\ntype MyEnum = Yes = 'Y' | No ='N'  // Ok because char was used. \n```", "```\ntype SizeUnion = Small | Medium | large      // Error - \"large\" is invalid.\ntype ColorEnum = Red=0 | Yellow=1 | blue=2      // Ok \n```", "```\n[<System.FlagsAttribute>]\ntype PermissionFlags = Read = 1 | Write = 2 | Execute = 4 \nlet permission = PermissionFlags.Read ||| PermissionFlags.Write \n```", "```\nlet red = Red            // Error. Enums must be qualified\nlet red = ColorEnum.Red  // Ok \nlet small = Small        // Ok.  Unions do not need to be qualified \n```", "```\nlet redInt = int ColorEnum.Red  \nlet redAgain:ColorEnum = enum redInt // cast to a specified enum type \nlet yellowAgain = enum<ColorEnum>(1) // or create directly \n```", "```\nlet unknownColor = enum<ColorEnum>(99)   // valid \n```", "```\nlet values = System.Enum.GetValues(typeof<ColorEnum>)\nlet redFromString =  \n    System.Enum.Parse(typeof<ColorEnum>,\"Red\") \n    :?> ColorEnum  // downcast needed \n```", "```\nlet unqualifiedMatch x = \n    match x with\n    | Red -> printfn \"red\"             // warning FS0049\n    | _ -> printfn \"something else\" \n\nlet qualifiedMatch x = \n    match x with\n    | ColorEnum.Red -> printfn \"red\"   //OK. qualified name used.\n    | _ -> printfn \"something else\" \n```", "```\nlet matchUnionIncomplete x = \n    match x with\n    | Small -> printfn \"small\"   \n    | Medium -> printfn \"medium\"   \n    // Warning: Incomplete pattern matches\n\nlet matchEnumIncomplete x = \n    match x with\n    | ColorEnum.Red -> printfn \"red\"   \n    | ColorEnum.Yellow -> printfn \"yellow\"   \n    // Warning: Incomplete pattern matches \n```", "```\n// the compiler is still not happy\nlet matchEnumIncomplete2 x = \n    match x with\n    | ColorEnum.Red -> printfn \"red\"   \n    | ColorEnum.Yellow -> printfn \"yellow\"   \n    | ColorEnum.Blue -> printfn \"blue\"   \n    // the value '3' may indicate a case not covered by the pattern(s). \n```", "```\n// the compiler is finally happy\nlet matchEnumComplete x = \n    match x with\n    | ColorEnum.Red -> printfn \"red\"   \n    | ColorEnum.Yellow -> printfn \"yellow\"   \n    | ColorEnum.Blue -> printfn \"blue\"   \n    | _ -> printfn \"something else\"   \n\n// test with unknown case \nlet unknownColor = enum<ColorEnum>(99)   // valid\nmatchEnumComplete unknownColor \n```", "```\nvar x = (int)1.23\nvar y = (double)1 \n```", "```\nlet x = int 1.23\nlet y = float 1 \n```", "```\nlet x = bool 1  //error\nlet y = System.Convert.ToBoolean(1)  // ok \n```", "```\n// create a function with parameter of type Object\nlet objFunction (o:obj) = o\n\n// test: call with an integer\nlet result = objFunction 1\n\n// result is\n// val result : obj = 1 \n```", "```\nlet resultIsOne = (result = 1)\n// error FS0001: This expression was expected to have type obj \n// but here has type int \n```", "```\nlet o = box 1\n\n// retest the comparison example above, but with boxing\nlet result = objFunction 1\nlet resultIsOne = (result = box 1)  // OK \n```", "```\n// box an int\nlet o = box 1\n\n// type known for target value\nlet i:int = unbox o  // OK \n\n// explicit type given in unbox\nlet j = unbox<int> o  // OK \n\n// type inference, so no type annotation needed\nlet k = 1 + unbox o  // OK \n```", "```\nlet result = objFunction 1\nlet resultIsOne = (unbox result = 1)  // OK \n```", "```\nlet o = box 1\n\n// no type specified\nlet i = unbox o  // FS0030: Value restriction error \n```", "```\nlet detectType v =\n    match v with\n        | :? int -> printfn \"this is an int\"\n        | _ -> printfn \"something else\" \n```", "```\n// error FS0008: This runtime coercion or type test from type 'a to int \n// involves an indeterminate type based on information prior to this program point. \n// Runtime type tests are not allowed on some types. Further type annotations are needed. \n```", "```\nlet detectTypeBoxed v =\n    match box v with      // used \"box v\" \n        | :? int -> printfn \"this is an int\"\n        | _ -> printfn \"something else\"\n\n//test\ndetectTypeBoxed 1\ndetectTypeBoxed 3.14 \n```", "```\n[<Measure>] \ntype cm\n\n[<Measure>] \ntype inch \n```", "```\n[<Measure>] type cm\n[<Measure>] type inch \n```", "```\nlet x = 1<cm>    // int\nlet y = 1.0<cm>  // float\nlet z = 1.0m<cm> // decimal \n```", "```\n[<Measure>] type m\n[<Measure>] type sec\n[<Measure>] type kg\n\nlet distance = 1.0<m>    \nlet time = 2.0<sec>    \nlet speed = 2.0<m/sec>    \nlet acceleration = 2.0<m/sec^2>    \nlet force = 5.0<kg m/sec^2> \n```", "```\n[<Measure>] type N = kg m/sec^2\n\nlet force1 = 5.0<kg m/sec^2>    \nlet force2 = 5.0<N>\n\nforce1 = force2 // true \n```", "```\n[<Measure>] type foot\n[<Measure>] type inch\n\nlet distance = 3.0<foot>    \n\n// type inference for result\nlet distance2 = distance * 2.0\n\n// type inference for input and output\nlet addThreeFeet ft = \n    ft + 3.0<foot> \n```", "```\naddThreeFeet 1.0        //error\naddThreeFeet 1.0<inch>  //error\naddThreeFeet 1.0<foot>  //OK \n```", "```\nlet untypedTimesThree (ft:float) = \n    ft * 3.0\n\nlet footTimesThree (ft:float<foot>) = \n    ft * 3.0 \n```", "```\n[<Measure>] type m\n[<Measure>] type sec\n[<Measure>] type kg\n\nlet distance = 1.0<m>    \nlet time = 2.0<sec>    \nlet speed = distance/time \nlet acceleration = speed/time\nlet mass = 5.0<kg>    \nlet force = mass * speed/time \n```", "```\n// dimensionless\nlet x = 42\n\n// also dimensionless\nlet x = 42<1> \n```", "```\n// test addition\n3.0<foot> + 2.0<foot>  // OK\n3.0<foot> + 2.0        // error\n\n// test multiplication\n3.0<foot> * 2.0        // OK \n```", "```\n[<Measure>] type foot\n[<Measure>] type inch\n\n//conversion factor\nlet inchesPerFoot = 12.0<inch/foot>    \n\n// test \nlet distanceInFeet = 3.0<foot>    \nlet distanceInInches = distanceInFeet * inchesPerFoot \n```", "```\n[<Measure>] type degC\n[<Measure>] type degF\n\nlet convertDegCToF c = \n    c * 1.8<degF/degC> + 32.0<degF>\n\n// test \nlet f = convertDegCToF 0.0<degC> \n```", "```\nval convertDegCToF : float<degC> -> float<degF> \n```", "```\nlet badConvertDegCToF c = \n    c * 1.8<degF/degC> + 32.0 \n```", "```\n[<Measure>] type foot\n\nlet ten = 10.0   // normal\n\n//converting from non-measure to measure \nlet tenFeet = ten * 1.0<foot>  // with measure \n```", "```\n//converting from measure to non-measure\nlet tenAgain = tenFeet / 1.0<foot>  // without measure\nlet tenAnotherWay = tenFeet * 1.0<1/foot>  // without measure \n```", "```\nlet tenFeet = 10.0<foot>  // with measure\nlet tenDimensionless = float tenFeet // without measure \n```", "```\nlet square x = x * x\n\n// test\nsquare 10<foot>   // error \n```", "```\nlet square (x:int<_>) = x * x\n\n// test\nsquare 10<foot>   // OK\nsquare 10<sec>   // OK \n```", "```\nval square : int<'u> -> int<'u ^ 2> \n```", "```\n// with underscores\nlet square (x:int<_>) = x * x\n\n// with letters\nlet square (x:int<'u>) = x * x\n\n// with underscores\nlet speed (distance:float<_>) (time:float<_>) = \n    distance / time\n\n// with letters\nlet speed (distance:float<'u>) (time:float<'v>) = \n    distance / time \n```", "```\nlet ratio (distance1:float<'u>) (distance2:float<'u>) = \n    distance1 / distance2 \n```", "```\n//error\n[1.0<foot>..10.0<foot>] \n```", "```\n//converting using map -- OK\n[1.0..10.0] |> List.map (fun i-> i * 1.0<foot>)\n\n//using a generator -- OK\n[ for i in [1.0..10.0] -> i * 1.0<foot> ] \n```", "```\nlet x = 10<foot> + 1  // error \n```", "```\nlet x = 10<foot> + 1<_>  // ok \n```", "```\nlet feet = [ for i in [1.0..10.0] -> i * 1.0<foot> ]\n\n// OK\nfeet |> List.sum  \n\n// Error\nfeet |> List.fold (+) 0.0   \n\n// Fixed with generic 0\nfeet |> List.fold (+) 0.0<_> \n```", "```\n// try to define a generic function\nlet add1 n = n + 1.0<_>\n// warning FS0064: This construct causes code to be less generic than \n// indicated by the type annotations. The unit-of-measure variable 'u \n// has been constrained to be measure '1'.\n\n// test\nadd1 10.0<foot>   \n// error FS0001: This expression was expected to have type float \n// but here has type float<foot> \n```", "```\n// define a function with explicit type annotation\nlet add1 (n:float<'u>) : float<'u> =  n + 1.0<_> \n```", "```\nlet add1 (n:float<'u>) : float<'u> = n + 1.0<'u>  \n// error FS0634: Non-zero constants cannot have generic units. \n```", "```\n// define the function\nlet add1 n  = \n    n + (LanguagePrimitives.FloatWithMeasure 1.0)\n\n// test\nadd1 10.0<foot>   // Yes! \n```", "```\nopen LanguagePrimitives\n\nlet add2Int n  = \n    n + (Int32WithMeasure 2)\n\nadd2Int 10<foot>   // OK \n```", "```\ntype Coord = \n    { X: float<'u>; Y: float<'u>; }\n// error FS0039: The type parameter 'u' is not defined \n```", "```\ntype Coord<'u> = \n    { X: float<'u>; Y: float<'u>; }\n// error FS0702: Expected unit-of-measure parameter, not type parameter.\n// Explicit unit-of-measure parameters must be marked with the [<Measure>] attribute. \n```", "```\ntype Coord<[<Measure>] 'u> = \n    { X: float<'u>; Y: float<'u>; }\n\n// Test\nlet coord = {X=10.0<foot>; Y=2.0<foot>} \n```", "```\ntype CurrencyRate<[<Measure>]'u, [<Measure>]'v> = \n    { Rate: float<'u/'v>; Date: System.DateTime}\n\n// test\n[<Measure>] type EUR\n[<Measure>] type USD\n[<Measure>] type GBP\n\nlet mar1 = System.DateTime(2012,3,1)\nlet eurToUsdOnMar1 = {Rate= 1.2<USD/EUR>; Date=mar1 }\nlet eurToGbpOnMar1 = {Rate= 0.8<GBP/EUR>; Date=mar1 }\n\nlet tenEur = 10.0<EUR>\nlet tenEurInUsd = eurToUsdOnMar1.Rate * tenEur \n```", "```\ntype ProductPrice<'product, [<Measure>] 'currency> = \n    { Product: 'product; Price: float<'currency>; } \n```", "```\nlet inferInt x = x + 1\nlet inferFloat x = x + 1.0\nlet inferDecimal x = x + 1m     // m suffix means decimal\nlet inferSByte x = x + 1y       // y suffix means signed byte\nlet inferChar x = x + 'a'       // a char\nlet inferString x = x + \"my string\" \n```", "```\nlet inferInt x = x + 1\nlet inferIndirectInt x = inferInt x       //deduce that x is an int\n\nlet inferFloat x = x + 1.0\nlet inferIndirectFloat x = inferFloat x   //deduce that x is a float \n```", "```\nlet x = 1\nlet y = x     //deduce that y is also an int \n```", "```\n// if..else implies a bool \nlet inferBool x = if x then false else true      \n// for..do implies a sequence\nlet inferStringList x = for y in x do printfn \"%s\" y  \n// :: implies a list\nlet inferIntList x = 99::x                      \n// .NET library method is strongly typed\nlet inferStringAndBool x = System.String.IsNullOrEmpty(x) \n```", "```\nlet inferInt2 (x:int) = x \nlet inferIndirectInt2 x = inferInt2 x \n\nlet inferFloat2 (x:float) = x \nlet inferIndirectFloat2 x = inferFloat2 x \n```", "```\nlet inferIntPrint x = printf \"x is %i\" x \nlet inferFloatPrint x = printf \"x is %f\" x \nlet inferGenericPrint x = printf \"x is %A\" x \n```", "```\nlet inferGeneric x = x \nlet inferIndirectGeneric x = inferGeneric x \nlet inferIndirectGenericAgain x = (inferIndirectGeneric x).ToString() \n```", "```\nlet outerFn action : string =  \n   let innerFn x = x + 1 // define a sub fn that returns an int\n   action (innerFn 2)    // result of applying action to innerFn \n```", "```\nval outerFn: (int -> string) -> string \n```", "```\nlet doItTwice f  = (f >> f) \n```", "```\nlet doItTwice f  = (f >> f)\n\nlet add3 x = x + 3\nlet add6 = doItTwice add3\n// test \nadd6 5             // result = 11\n\nlet square x = x * x\nlet fourthPower = doItTwice square\n// test \nfourthPower 3      // result = 81\n\nlet chittyBang x = \"Chitty \" + x + \" Bang\"\nlet chittyChittyBangBang = doItTwice chittyBang\n// test \nchittyChittyBangBang \"&\"      // result = \"Chitty Chitty & Bang Bang\" \n```", "```\nlet square2 x = square x   // fails: square not defined \nlet square x = x * x \n```", "```\nlet square x = x * x       \nlet square2 x = square x   // square already defined earlier \n```", "```\n// the compiler does not know what \"fib\" means\nlet fib n =\n   if n <= 2 then 1\n   else fib (n - 1) + fib (n - 2)\n   // error FS0039: The value or constructor 'fib' is not defined \n```", "```\nlet rec fib n =              // LET REC rather than LET \n   if n <= 2 then 1\n   else fib (n - 1) + fib (n - 2) \n```", "```\nlet rec showPositiveNumber x =               // LET REC rather than LET\n   match x with \n   | x when x >= 0 -> printfn \"%i is positive\" x \n   | _ -> showNegativeNumber x\n\nand showNegativeNumber x =                   // AND rather than LET\n\n   match x with \n   | x when x < 0 -> printfn \"%i is negative\" x \n   | _ -> showPositiveNumber x \n```", "```\ntype A = None | AUsesB of B\n   // error FS0039: The type 'B' is not defined\ntype B = None | BUsesA of A \n```", "```\ntype A = None | AUsesB of B\nand B = None | BUsesA of A    // use AND instead of TYPE \n```", "```\nlet stringLength s = s.Length\n  // error FS0072: Lookup on object of indeterminate type \n  // based on information prior to this program point. \n  // A type annotation may be needed ... \n```", "```\nlet stringLength (s:string) = s.Length \n```", "```\nList.map (fun x -> x.Length) [\"hello\"; \"world\"]       //not ok \n```", "```\nList.map (fun (x:string) -> x.Length) [\"hello\"; \"world\"]       // ok \n```", "```\n[\"hello\"; \"world\"] |> List.map (fun s -> s.Length)   //ok \n```", "```\nlet concat x = System.String.Concat(x)           //fails\nlet concat (x:string) = System.String.Concat(x)  //works \nlet concat x = System.String.Concat(x:string)    //works \n```", "```\nlet makeStreamReader x = new System.IO.StreamReader(x)        //fails\nlet makeStreamReader x = new System.IO.StreamReader(path=x)   //works \n```", "```\nlet myNumericFn x = x * x\nmyNumericFn 10\nmyNumericFn 10.0             //fails\n  // error FS0001: This expression was expected to have \n  // type int but has type float\n\nlet myNumericFn2 x = x * x\nmyNumericFn2 10.0     \nmyNumericFn2 10               //fails\n  // error FS0001: This expression was expected to have \n  // type float but has type int \n```", "```\nlet myBottomLevelFn x = x\n\nlet myMidLevelFn x = \n   let y = myBottomLevelFn x\n   // some stuff \n   let z= y\n   // some stuff \n   printf \"%s\" z         // this will kill your generic types!\n   // some more stuff\n   x\n\nlet myTopLevelFn x =\n   // some stuff \n   myMidLevelFn x \n   // some more stuff \n   x \n```", "```\nval myTopLevelFn : string -> string \n```", "```\nval myBottomLevelFn : 'a -> 'a       // generic as expected\nval myMidLevelFn : string -> string  // here's the clue! Should be generic\nval myTopLevelFn : string -> string \n```"]