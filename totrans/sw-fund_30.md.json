["```\n\n    Up to this point, we have considered a variety of *pure*\n    language features, including functional abstraction, basic types\n    such as numbers and booleans, and structured types such as records\n    and variants.  These features form the backbone of most\n    programming languages \u2014 including purely functional languages\n    such as Haskell and \"mostly functional\" languages such as ML, as\n    well as imperative languages such as C and object-oriented\n    languages such as Java, C#, and Scala.\n\n    However, most practical languages also include various *impure*\n    features that cannot be described in the simple semantic framework\n    we have used so far.  In particular, besides just yielding\n    results, computation in these languages may assign to mutable\n    variables (reference cells, arrays, mutable record fields, etc.);\n    perform input and output to files, displays, or network\n    connections; make non-local transfers of control via exceptions,\n    jumps, or continuations; engage in inter-process synchronization\n    and communication; and so on.  In the literature on programming\n    languages, such \"side effects\" of computation are collectively\n    referred to as *computational effects*.\n\n    In this chapter, we'll see how one sort of computational effect \u2014\n    mutable references \u2014 can be added to the calculi we have studied.\n    The main extension will be dealing explicitly with a *store* (or\n    *heap*) and *pointers* that name store locations.  This extension\n    is fairly straightforward to define; the most interesting part is\n    the refinement we need to make to the statement of the type\n    preservation theorem.\n\n```", "```\n\n# Definitions\n\n    Pretty much every programming language provides some form of\n    assignment operation that changes the contents of a previously\n    allocated piece of storage.  (Coq's internal language Gallina is a\n    rare exception!)\n\n    In some languages \u2014 notably ML and its relatives \u2014 the\n    mechanisms for name-binding and those for assignment are kept\n    separate.  We can have a variable x whose *value* is the number\n    5, or we can have a variable y whose value is a\n    *reference* (or *pointer*) to a mutable cell whose current\n    contents is 5.  These are different things, and the difference\n    is visible to the programmer.  We can add x to another number,\n    but not assign to it.  We can use y to assign a new value to the\n    cell that it points to (by writing y:=84), but we cannot use y\n    directly as an argument to an operation like +.  Instead, we\n    must explicitly *dereference* it, writing !y to obtain its\n    current contents.\n\n    In most other languages \u2014 in particular, in all members of the C\n    family, including Java \u2014 *every* variable name refers to a\n    mutable cell, and the operation of dereferencing a variable to\n    obtain its current contents is implicit.\n\n    For purposes of formal study, it is useful to keep these\n    mechanisms separate.  The development in this chapter will closely\n    follow ML's model.  Applying the lessons learned here to C-like\n    languages is a straightforward matter of collapsing some\n    distinctions and rendering some operations such as dereferencing\n    implicit instead of explicit.\n\n```", "```\nModule STLCRef.\n\n```", "```\n\n### Types\n\n    We start with the simply typed lambda calculus over the\n    natural numbers. Besides the base natural number type and arrow\n    types, we need to add two more types to deal with\n    references. First, we need the *unit type*, which we will use as\n    the result type of an assignment operation.  We then add\n    *reference types*. \n\n    If T is a type, then Ref T is the type of references to\n    cells holding values of type T.\n\n```", "```\nInductive ty : Type :=\n\u00a0\u00a0| TNat   : ty\n\u00a0\u00a0| TUnit  : ty\n\u00a0\u00a0| TArrow : ty \u2192 ty \u2192 ty\n\u00a0\u00a0| TRef   : ty \u2192 ty.\n\n```", "```\n      t ::= ...              Terms\n          | ref t              allocation\n          | !t                 dereference\n          | t := t             assignment\n          | l                  location\n\n```", "```\nInductive tm  : Type :=\n\u00a0\u00a0(*\u00a0STLC\u00a0with\u00a0numbers:\u00a0*)\n\u00a0\u00a0| tvar    : id \u2192 tm\n\u00a0\u00a0| tapp    : tm \u2192 tm \u2192 tm\n\u00a0\u00a0| tabs    : id \u2192 ty \u2192 tm \u2192 tm\n\u00a0\u00a0| tnat    : nat \u2192 tm\n\u00a0\u00a0| tsucc   : tm \u2192 tm\n\u00a0\u00a0| tpred   : tm \u2192 tm\n\u00a0\u00a0| tmult   : tm \u2192 tm \u2192 tm\n\u00a0\u00a0| tif0    : tm \u2192 tm \u2192 tm \u2192 tm\n\u00a0\u00a0(*\u00a0New\u00a0terms:\u00a0*)\n\u00a0\u00a0| tunit   : tm\n\u00a0\u00a0| tref    : tm \u2192 tm\n\u00a0\u00a0| tderef  : tm \u2192 tm\n\u00a0\u00a0| tassign : tm \u2192 tm \u2192 tm\n\u00a0\u00a0| tloc    : nat \u2192 tm.\n\n```", "```\n\n### Typing (Preview)\n\n    Informally, the typing rules for allocation, dereferencing, and\n    assignment will look like this:\n\n| \n             \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[1]\n           | \n             (T_Ref) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             \u0393\u00a0\u22a2\u00a0ref\u00a0t[1]\u00a0:\u00a0Ref\u00a0T[1]\n           | \n          |\n\n| \n             \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0Ref\u00a0T[11]\n           | \n             (T_Deref) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             \u0393\u00a0\u22a2\u00a0!t[1]\u00a0:\u00a0T[11]\n           | \n          |\n\n| \n             \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0Ref\u00a0T[11]\n           | \n          |\n| \n             \u0393\u00a0\u22a2\u00a0t[2]\u00a0:\u00a0T[11]\n           | \n             (T_Assign) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             \u0393\u00a0\u22a2\u00a0t[1]\u00a0:=\u00a0t[2]\u00a0:\u00a0Unit\n           | \n          |\n\n    The rule for locations will require a bit more machinery, and this\n    will motivate some changes to the other rules; we'll come back to\n    this later.\n\n```", "```\nInductive value : tm \u2192 Prop :=\n\u00a0\u00a0| v_abs  : \u2200x T t,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tabs x T t)\n\u00a0\u00a0| v_nat : \u2200n,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tnat n)\n\u00a0\u00a0| v_unit :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value tunit\n\u00a0\u00a0| v_loc : \u2200l,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tloc l).\n\nHint Constructors value.\n\n```", "```\nFixpoint subst (x:id) (s:tm) (t:tm) : tm :=\n\u00a0\u00a0match t with\n\u00a0\u00a0| tvar x'       \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id x x' then s else t\n\u00a0\u00a0| tapp t[1] t[2]    \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tapp (subst x s t[1]) (subst x s t[2])\n\u00a0\u00a0| tabs x' T t[1]  \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id x x' then t else tabs x' T (subst x s t[1])\n\u00a0\u00a0| tnat n        \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t\n\u00a0\u00a0| tsucc t[1]      \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tsucc (subst x s t[1])\n\u00a0\u00a0| tpred t[1]      \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tpred (subst x s t[1])\n\u00a0\u00a0| tmult t[1] t[2]   \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmult (subst x s t[1]) (subst x s t[2])\n\u00a0\u00a0| tif0 t[1] t[2] t[3] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tif0 (subst x s t[1]) (subst x s t[2]) (subst x s t[3])\n\u00a0\u00a0| tunit         \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t\n\u00a0\u00a0| tref t[1]       \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tref (subst x s t[1])\n\u00a0\u00a0| tderef t[1]     \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tderef (subst x s t[1])\n\u00a0\u00a0| tassign t[1] t[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tassign (subst x s t[1]) (subst x s t[2])\n\u00a0\u00a0| tloc _        \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t\n\u00a0\u00a0end.\n\nNotation \"'[' x ':=' s ']' t\" := (subst x s t) (at level 20).\n\n```", "```\n\n## Side Effects and Sequencing\n\n    The fact that we've chosen the result of an assignment\n    expression to be the trivial value unit allows a nice\n    abbreviation for *sequencing*.  For example, we can write\n\n```", "```\n\n    as an abbreviation for\n\n```", "```\n\n    This has the effect of reducing two expressions in order and\n    returning the value of the second.  Restricting the type of the\n    first expression to Unit helps the typechecker to catch some\n    silly errors by permitting us to throw away the first value only\n    if it is really guaranteed to be trivial.\n\n    Notice that, if the second expression is also an assignment, then\n    the type of the whole sequence will be Unit, so we can validly\n    place it to the left of another ; to build longer sequences of\n    assignments:\n\n```", "```\n\n    Formally, we introduce sequencing as a *derived form* tseq that expands into an abstraction and an application.\n\n```", "```\n\n## References and Aliasing\n\n    It is important to bear in mind the difference between the\n    *reference* that is bound to some variable r and the *cell* \n    in the store that is pointed to by this reference.\n\n    If we make a copy of r, for example by binding its value to\n    another variable s, what gets copied is only the *reference*,\n    not the contents of the cell itself.\n\n    For example, after reducing\n\n```", "```\n\n    the cell referenced by r will contain the value 82, while the\n    result of the whole expression will be 83.  The references r\n    and s are said to be *aliases* for the same cell.\n\n    The possibility of aliasing can make programs with references\n    quite tricky to reason about.  For example, the expression\n\n```", "```\n\n    assigns 5 to r and then immediately overwrites it with s's\n    current value; this has exactly the same effect as the single\n    assignment\n\n```", "```\n\n    *unless* we happen to do it in a context where r and s are\n    aliases for the same cell!\n\n```", "```\n      let c = ref 0 in\n      let incc = \u03bb_:Unit. (c := succ (!c); !c) in\n      let decc = \u03bb_:Unit. (c := pred (!c); !c) in\n      ...\n\n```", "```\n\n## Objects\n\n    We can go a step further and write a *function* that creates c,\n    incc, and decc, packages incc and decc together into a\n    record, and returns this record:\n\n```", "```\n\n    Now, each time we call newcounter, we get a new record of\n    functions that share access to the same storage cell c.  The\n    caller of newcounter can't get at this storage cell directly,\n    but can affect it indirectly by calling the two functions.  In\n    other words, we've created a simple form of *object*.\n\n```", "```\n\n#### Exercise: 1 star (store_draw)\n\n    Draw (on paper) the contents of the store at the point in\n    execution where the first two lets have finished and the third\n    one is about to begin.\n\n```", "```\n\n    \u2610\n\n```", "```\n      equal =\n        fix\n          (\u03bbeq:Nat->Nat->Bool.\n             \u03bbm:Nat. \u03bbn:Nat.\n               if m=0 then iszero n\n               else if n=0 then false\n               else eq (pred m) (pred n))\n\n```", "```\n      newarray = \u03bb_:Unit. ref (\u03bbn:Nat.0)\n\n```", "```\n      lookup = \u03bba:NatArray. \u03bbn:Nat. (!a) n\n\n```", "```\n      update = \u03bba:NatArray. \u03bbm:Nat. \u03bbv:Nat.\n                   let oldf = !a in\n                   a := (\u03bbn:Nat. if equal m n then v else oldf n);\n\n```", "```\n      update = \u03bba:NatArray. \u03bbm:Nat. \u03bbv:Nat.\n                  a := (\u03bbn:Nat. if equal m n then v else (!a) n)\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n## Null References\n\n    There is one final significant difference between our\n    references and C-style mutable variables: in C-like languages,\n    variables holding pointers into the heap may sometimes have the\n    value NULL.  Dereferencing such a \"null pointer\" is an error,\n    and results either in a clean exception (Java and C#) or in\n    arbitrary and possibly insecure behavior (C and relatives like\n    C++).  Null pointers cause significant trouble in C-like\n    languages: the fact that any pointer might be null means that any\n    dereference operation in the program can potentially fail.\n\n    Even in ML-like languages, there are occasionally situations where\n    we may or may not have a valid pointer in our hands.  Fortunately,\n    there is no need to extend the basic mechanisms of references to\n    represent such situations: the sum types introduced in the\n    [MoreStlc](MoreStlc.html) chapter already give us what we need.\n\n    First, we can use sums to build an analog of the option types\n    introduced in the [Lists](Lists.html) chapter.  Define Option T to be an\n    abbreviation for Unit + T.\n\n    Then a \"nullable reference to a T\" is simply an element of the\n    type Option (Ref T).\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n# Operational Semantics\n\n```", "```\n\n## Stores\n\n    Recall that, in the small-step operational semantics for\n    IMP, the step relation needed to carry along an auxiliary state in\n    addition to the program being executed.  In the same way, once we\n    have added reference cells to the STLC, our step relation must\n    carry along a store to keep track of the contents of reference\n    cells.\n\n    We could re-use the same functional representation we used for\n    states in IMP, but for carrying out the proofs in this chapter it\n    is actually more convenient to represent a store simply as a\n    *list* of values.  (The reason we didn't use this representation\n    before is that, in IMP, a program could modify any location at any\n    time, so states had to be ready to map *any* variable to a value.\n    However, in the STLC with references, the only way to create a\n    reference cell is with tref t[1], which puts the value of t[1]\n    in a new reference cell and reduces to the location of the newly\n    created reference cell. When reducing such an expression, we can\n    just add a new reference cell to the end of the list representing\n    the store.)\n\n```", "```\n\n    We use store_lookup n st to retrieve the value of the reference\n    cell at location n in the store st.  Note that we must give a\n    default value to nth in case we try looking up an index which is\n    too large. (In fact, we will never actually do this, but proving\n    that we don't will require a bit of work.)\n\n```", "```\n\n    To update the store, we use the replace function, which replaces\n    the contents of a cell at a particular index.\n\n```", "```\n\n    As might be expected, we will also need some technical\n    lemmas about replace; they are straightforward to prove.\n\n```", "```\n\n## Reduction\n\n    Next, we need to extend the operational semantics to take\n    stores into account.  Since the result of reducing an expression\n    will in general depend on the contents of the store in which it is\n    reduced, the evaluation rules should take not just a term but\n    also a store as argument.  Furthermore, since the reduction of a\n    term can cause side effects on the store, and these may affect the\n    reduction of other terms in the future, the reduction rules need\n    to return a new store.  Thus, the shape of the single-step\n    reduction relation needs to change from t \u21d2 t' to t / st \u21d2 t' / st', where st and st' are the starting and ending states of\n    the store.\n\n    To carry through this change, we first need to augment all of our\n    existing reduction rules with stores:\n\n| \n             value\u00a0v[2]\n           | \n             (ST_AppAbs) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             (\u03bbx:T.t12)\u00a0v[2]\u00a0/\u00a0st\u00a0\u21d2\u00a0[x:=v[2]]t[12]\u00a0/\u00a0st\n           | \n          |\n\n| \n             t[1]\u00a0/\u00a0st\u00a0\u21d2\u00a0t[1]'\u00a0/\u00a0st'\n           | \n             (ST_App1) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             t[1]\u00a0t[2]\u00a0/\u00a0st\u00a0\u21d2\u00a0t[1]'\u00a0t[2]\u00a0/\u00a0st'\n           | \n          |\n\n| \n             value\u00a0v[1]\u00a0t[2]\u00a0/\u00a0st\u00a0\u21d2\u00a0t[2]'\u00a0/\u00a0st'\n           | \n             (ST_App2) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             v[1]\u00a0t[2]\u00a0/\u00a0st\u00a0\u21d2\u00a0v[1]\u00a0t[2]'\u00a0/\u00a0st'\n           | \n          |\n\n    Note that the first rule here returns the store unchanged, since\n    function application, in itself, has no side effects.  The other\n    two rules simply propagate side effects from premise to\n    conclusion.\n\n    Now, the result of reducing a ref expression will be a fresh\n    location; this is why we included locations in the syntax of terms\n    and in the set of values.  It is crucial to note that making this \n    extension to the syntax of terms does not mean that we intend \n    *programmers* to write terms involving explicit, concrete locations: \n    such terms will arise only as intermediate results during reduction.  \n    This may seem odd, but it follows naturally from our design decision\n    to represent the result of every reduction step by a modified *term*. \n    If we had chosen a more \"machine-like\" model, e.g., with an explicit \n    stack to contain values of bound identifiers, then the idea of adding \n    locations to the set of allowed values might seem more obvious.\n\n    In terms of this expanded syntax, we can state reduction rules\n    for the new constructs that manipulate locations and the store.\n    First, to reduce a dereferencing expression !t[1], we must first\n    reduce t[1] until it becomes a value:\n\n| \n             t[1]\u00a0/\u00a0st\u00a0\u21d2\u00a0t[1]'\u00a0/\u00a0st'\n           | \n             (ST_Deref) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             !t[1]\u00a0/\u00a0st\u00a0\u21d2\u00a0!t[1]'\u00a0/\u00a0st'\n           | \n          |\n\n    Once t[1] has finished reducing, we should have an expression of\n    the form !l, where l is some location.  (A term that attempts\n    to dereference any other sort of value, such as a function or\n    unit, is erroneous, as is a term that tries to dereference a\n    location that is larger than the size |st| of the currently\n    allocated store; the reduction rules simply get stuck in this\n    case.  The type-safety properties established below assure us \n    that well-typed terms will never misbehave in this way.)\n\n| \n             l\u00a0<\u00a0&#124;st&#124;< td=\"\">\n           | \n             (ST_DerefLoc) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             !(loc\u00a0l)\u00a0/\u00a0st\u00a0\u21d2\u00a0lookup\u00a0l\u00a0st\u00a0/\u00a0st\n           | \n          |\n\n    Next, to reduce an assignment expression t[1]:=t[2], we must first\n    reduce t[1] until it becomes a value (a location), and then\n    reduce t[2] until it becomes a value (of any sort):\n\n| \n             t[1]\u00a0/\u00a0st\u00a0\u21d2\u00a0t[1]'\u00a0/\u00a0st'\n           | \n             (ST_Assign1) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             t[1]\u00a0:=\u00a0t[2]\u00a0/\u00a0st\u00a0\u21d2\u00a0t[1]'\u00a0:=\u00a0t[2]\u00a0/\u00a0st'\n           | \n          |\n\n| \n             t[2]\u00a0/\u00a0st\u00a0\u21d2\u00a0t[2]'\u00a0/\u00a0st'\n           | \n             (ST_Assign2) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             v[1]\u00a0:=\u00a0t[2]\u00a0/\u00a0st\u00a0\u21d2\u00a0v[1]\u00a0:=\u00a0t[2]'\u00a0/\u00a0st'\n           | \n          |\n\n    Once we have finished with t[1] and t[2], we have an expression of\n    the form l:=v[2], which we execute by updating the store to make\n    location l contain v[2]:\n\n| \n             l\u00a0<\u00a0&#124;st&#124;< td=\"\">\n           | \n             (ST_Assign) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             loc\u00a0l\u00a0:=\u00a0v[2]\u00a0/\u00a0st\u00a0\u21d2\u00a0unit\u00a0/\u00a0[l:=v[2]]st\n           | \n          |\n\n    The notation [l:=v[2]]st means \"the store that maps l to v[2]\n    and maps all other locations to the same thing as st.\"  Note\n    that the term resulting from this reduction step is just unit;\n    the interesting result is the updated store.\n\n    Finally, to reduct an expression of the form ref t[1], we first\n    reduce t[1] until it becomes a value:\n\n| \n             t[1]\u00a0/\u00a0st\u00a0\u21d2\u00a0t[1]'\u00a0/\u00a0st'\n           | \n             (ST_Ref) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             ref\u00a0t[1]\u00a0/\u00a0st\u00a0\u21d2\u00a0ref\u00a0t[1]'\u00a0/\u00a0st'\n           | \n          |\n\n    Then, to reduce the ref itself, we choose a fresh location at\n    the end of the current store \u2014 i.e., location |st| \u2014 and yield\n    a new store that extends st with the new value v[1].\n\n| \n             \u00a0\u00a0\n           | \n             (ST_RefValue) \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             ref\u00a0v[1]\u00a0/\u00a0st\u00a0\u21d2\u00a0loc\u00a0&#124;st&#124;\u00a0/\u00a0st,v[1]\n           | \n          |\n\n    The value resulting from this step is the newly allocated location\n    itself.  (Formally, st,v[1] means st ++ v[1]::nil \u2014 i.e., to add\n    a new reference cell to the store, we append it to the end.)  \n\n    Note that these reduction rules do not perform any kind of\n    garbage collection: we simply allow the store to keep growing\n    without bound as reduction proceeds.  This does not affect the\n    correctness of the results of reduction (after all, the\n    definition of \"garbage\" is precisely parts of the store that are\n    no longer reachable and so cannot play any further role in\n    reduction), but it means that a naive implementation of our\n    evaluator might run out of memory where a more sophisticated \n    evaluator would be able to continue by reusing locations whose \n    contents have become garbage.\n\n    Here are the rules again, formally:\n\n```", "```\n\n    One slightly ugly point should be noted here: In the ST_RefValue\n    rule, we extend the state by writing st ++ v[1]::nil rather than\n    the more natural st ++ [v[1]].  The reason for this is that the\n    notation we've defined for substitution uses square brackets,\n    which clash with the standard library's notation for lists.\n\n```", "```\n\n# Typing\n\n    The contexts assigning types to free variables are exactly the\n    same as for the STLC: partial maps from identifiers to types.\n\n```", "```\n\n## Store typings\n\n    Having extended our syntax and reduction rules to accommodate\n    references, our last job is to write down typing rules for the new\n    constructs (and, of course, to check that these rules are sound!).\n    Naturally, the key question is, \"What is the type of a location?\"\n\n    First of all, notice that this question doesn't arise when\n    typechecking terms that programmers actually\n    write.  Concrete location constants arise only in terms that are\n    the intermediate results of reduction; they are not in the\n    language that programmers write.  So we only need to determine the\n    type of a location when we're in the middle of a reduction\n    sequence, e.g., trying to apply the progress or preservation\n    lemmas.  Thus, even though we normally think of typing as a\n    *static* program property, it makes sense for the typing of\n    locations to depend on the *dynamic* progress of the program too.\n\n    As a first try, note that when we reduce a term containing\n    concrete locations, the type of the result depends on the contents\n    of the store that we start with.  For example, if we reduce the\n    term !(loc 1) in the store [unit, unit], the result is unit;\n    if we reduce the same term in the store [unit, \\x:Unit.x], the\n    result is \\x:Unit.x.  With respect to the former store, the\n    location 1 has type Unit, and with respect to the latter it\n    has type Unit\u2192Unit. This observation leads us immediately to a\n    first attempt at a typing rule for locations:\n\n| \n             \u0393\u00a0\u22a2\u00a0lookup\u00a0\u00a0l\u00a0st\u00a0:\u00a0T[1]\n           | \n             \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             \u0393\u00a0\u22a2\u00a0loc\u00a0l\u00a0:\u00a0Ref\u00a0T[1]\n           | \n          |\n\n    That is, to find the type of a location l, we look up the\n    current contents of l in the store and calculate the type T[1]\n    of the contents.  The type of the location is then Ref T[1].\n\n    Having begun in this way, we need to go a little further to reach a\n    consistent state.  In effect, by making the type of a term depend on\n    the store, we have changed the typing relation from a three-place\n    relation (between contexts, terms, and types) to a four-place relation\n    (between contexts, *stores*, terms, and types).  Since the store is,\n    intuitively, part of the context in which we calculate the type of a\n    term, let's write this four-place relation with the store to the left\n    of the turnstile: \u0393; st \u22a2 t : T.  Our rule for typing\n    references now has the form\n\n| \n             Gamma;\u00a0st\u00a0\u22a2\u00a0lookup\u00a0l\u00a0st\u00a0:\u00a0T[1]\n           | \n             \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             Gamma;\u00a0st\u00a0\u22a2\u00a0loc\u00a0l\u00a0:\u00a0Ref\u00a0T[1]\n           | \n          |\n\n    and all the rest of the typing rules in the system are extended\n    similarly with stores.  (The other rules do not need to do anything\n    interesting with their stores \u2014 just pass them from premise to\n    conclusion.)\n\n    However, this rule will not quite do.  For one thing, typechecking\n    is rather inefficient, since calculating the type of a location l\n    involves calculating the type of the current contents v of l.  If\n    l appears many times in a term t, we will re-calculate the type of\n    v many times in the course of constructing a typing derivation for\n    t.  Worse, if v itself contains locations, then we will have to\n    recalculate *their* types each time they appear.  Worse yet, the \n    proposed typing rule for locations may not allow us to derive \n    anything at all, if the store contains a *cycle*.  For example,\n    there is no finite typing derivation for the location 0 with respect\n    to this store:\n\n```", "```\n\n#### Exercise: 2 stars (cyclic_store)\n\n    Can you find a term whose reduction will create this particular\n    cyclic store?  \u2610 \n\n    These problems arise from the fact that our proposed\n    typing rule for locations requires us to recalculate the type of a\n    location every time we mention it in a term.  But this,\n    intuitively, should not be necessary.  After all, when a location\n    is first created, we know the type of the initial value that we\n    are storing into it.  Suppose we are willing to enforce the\n    invariant that the type of the value contained in a given location\n    *never changes*; that is, although we may later store other values\n    into this location, those other values will always have the same\n    type as the initial one.  In other words, we always have in mind a\n    single, definite type for every location in the store, which is\n    fixed when the location is allocated.  Then these intended types\n    can be collected together as a *store typing* \u2014 a finite function\n    mapping locations to types.\n\n    As with the other type systems we've seen, this conservative typing \n    restriction on allowed updates means that we will rule out as \n    ill-typed some programs that could reduce perfectly well without\n    getting stuck. \n\n    Just as we did for stores, we will represent a store type simply\n    as a list of types: the type at index i records the type of the\n    values that we expect to be stored in cell i.\n\n```", "```\n\n    The store_Tlookup function retrieves the type at a particular\n    index.\n\n```", "```\n\n    Suppose we are given a store typing ST describing the store\n    st in which some term t will be reduced.  Then we can use\n    ST to calculate the type of the result of t without ever\n    looking directly at st.  For example, if ST is [Unit, Unit\u2192Unit], then we can immediately infer that !(loc 1) has\n    type Unit\u2192Unit.  More generally, the typing rule for locations\n    can be reformulated in terms of store typings like this:\n\n| \n             l\u00a0<\u00a0&#124;st&#124;< td=\"\">\n           | \n             \u00a0\n           |\n| \n             \n\n* * *\n\n           |\n| \n             Gamma;\u00a0ST\u00a0\u22a2\u00a0loc\u00a0l\u00a0:\u00a0Ref\u00a0(lookup\u00a0l\u00a0ST)\n           | \n          |\n\n    That is, as long as l is a valid location, we can compute the \n    type of l just by looking it up in ST.  Typing is again a \n    four-place relation, but it is parameterized on a store *typing* \n    rather than a concrete store.  The rest of the typing rules are \n    analogously augmented with store typings.\n\n```", "```\nReserved Notation \"Gamma ';' ST '\u22a2' t '\u2208' T\" (at level 40).\n\nInductive has_type : context \u2192 store_ty \u2192 tm \u2192 ty \u2192 Prop :=\n\u00a0\u00a0| T_Var : \u2200\u0393 ST x T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 x = Some T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tvar x) \u2208 T\n\u00a0\u00a0| T_Abs : \u2200\u0393 ST x T[11] T[12] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(update \u0393 x T[11]); ST \u22a2 t[12] \u2208 T[12] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tabs x T[11] t[12]) \u2208 (TArrow T[11] T[12])\n\u00a0\u00a0| T_App : \u2200T[1] T[2] \u0393 ST t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[1] \u2208 (TArrow T[1] T[2]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[2] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tapp t[1] t[2]) \u2208 T[2]\n\u00a0\u00a0| T_Nat : \u2200\u0393 ST n,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tnat n) \u2208 TNat\n\u00a0\u00a0| T_Succ : \u2200\u0393 ST t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tsucc t[1]) \u2208 TNat\n\u00a0\u00a0| T_Pred : \u2200\u0393 ST t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tpred t[1]) \u2208 TNat\n\u00a0\u00a0| T_Mult : \u2200\u0393 ST t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[2] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tmult t[1] t[2]) \u2208 TNat\n\u00a0\u00a0| T_If[0] : \u2200\u0393 ST t[1] t[2] t[3] T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[2] \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[3] \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tif0 t[1] t[2] t[3]) \u2208 T\n\u00a0\u00a0| T_Unit : \u2200\u0393 ST,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 tunit \u2208 TUnit\n\u00a0\u00a0| T_Loc : \u2200\u0393 ST l,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0l < length ST \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tloc l) \u2208 (TRef (store_Tlookup l ST))\n\u00a0\u00a0| T_Ref : \u2200\u0393 ST t[1] T[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[1] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tref t[1]) \u2208 (TRef T[1])\n\u00a0\u00a0| T_Deref : \u2200\u0393 ST t[1] T[11],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[1] \u2208 (TRef T[11]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tderef t[1]) \u2208 T[11]\n\u00a0\u00a0| T_Assign : \u2200\u0393 ST t[1] t[2] T[11],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[1] \u2208 (TRef T[11]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 t[2] \u2208 T[11] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393; ST \u22a2 (tassign t[1] t[2]) \u2208 TUnit\n\nwhere \"Gamma ';' ST '\u22a2' t '\u2208' T\" := (has_type \u0393 ST t T).\n\nHint Constructors has_type.\n\n```", "```\n\n# Properties\n\n    Our final task is to check that standard type safety\n    properties continue to hold for the STLC with references.  The\n    progress theorem (\"well-typed terms are not stuck\") can be stated\n    and proved almost as for the STLC; we just need to add a few\n    straightforward cases to the proof to deal with the new\n    constructs.  The preservation theorem is a bit more interesting,\n    so let's look at it first.\n\n```", "```\nTheorem preservation_wrong1 : \u2200ST T t st t' st',\n\u00a0\u00a0empty; ST \u22a2 t \u2208 T \u2192\n\u00a0\u00a0t / st \u21d2 t' / st' \u2192\n\u00a0\u00a0empty; ST \u22a2 t' \u2208 T.\nAbort.\n\n```", "```\nDefinition store_well_typed (ST:store_ty) (st:store) :=\n\u00a0\u00a0length ST = length st \u2227\n\u00a0\u00a0(\u2200l, l < length st \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0empty; ST \u22a2 (store_lookup l st) \u2208 (store_Tlookup l ST)).\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nTheorem preservation_wrong2 : \u2200ST T t st t' st',\n\u00a0\u00a0empty; ST \u22a2 t \u2208 T \u2192\n\u00a0\u00a0t / st \u21d2 t' / st' \u2192\n\u00a0\u00a0store_well_typed ST st \u2192\n\u00a0\u00a0empty; ST \u22a2 t' \u2208 T.\nAbort.\n\n```", "```\n\n## Extending Store Typings\n\n    Evidently, since the store can increase in size during reduction,\n    we need to allow the store typing to grow as well.  This motivates\n    the following definition.  We say that the store type ST' *extends* ST if ST' is just ST with some new types added to\n    the end.\n\n```", "```\n\n    We'll need a few technical lemmas about extended contexts.\n\n    First, looking up a type in an extended store typing yields the\n    same result as in the original:\n\n```", "```\n\n    Next, if ST' extends ST, the length of ST' is at least that\n    of ST.\n\n```", "```\n\n    Finally, ST ++ T extends ST, and extends is reflexive.\n\n```", "```\n\n## Preservation, Finally\n\n    We can now give the final, correct statement of the type\n    preservation property:\n\n```", "```\n\n    Note that the preservation theorem merely asserts that there is\n    *some* store typing ST' extending ST (i.e., agreeing with ST\n    on the values of all the old locations) such that the new term\n    t' is well typed with respect to ST'; it does not tell us\n    exactly what ST' is.  It is intuitively clear, of course, that\n    ST' is either ST or else exactly ST ++ T[1]::nil, where\n    T[1] is the type of the value v[1] in the extended store st ++ v[1]::nil, but stating this explicitly would complicate the statement of\n    the theorem without actually making it any more useful: the weaker\n    version above is already in the right form (because its conclusion\n    implies its hypothesis) to \"turn the crank\" repeatedly and\n    conclude that every *sequence* of reduction steps preserves\n    well-typedness.  Combining this with the progress property, we\n    obtain the usual guarantee that \"well-typed programs never go\n    wrong.\"\n\n    In order to prove this, we'll need a few lemmas, as usual.\n\n```", "```\nInductive appears_free_in : id \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| afi_var : \u2200x,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tvar x)\n\u00a0\u00a0| afi_app1 : \u2200x t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192 appears_free_in x (tapp t[1] t[2])\n\u00a0\u00a0| afi_app2 : \u2200x t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[2] \u2192 appears_free_in x (tapp t[1] t[2])\n\u00a0\u00a0| afi_abs : \u2200x y T[11] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y \u2260 x  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[12] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tabs y T[11] t[12])\n\u00a0\u00a0| afi_succ : \u2200x t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tsucc t[1])\n\u00a0\u00a0| afi_pred : \u2200x t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tpred t[1])\n\u00a0\u00a0| afi_mult1 : \u2200x t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tmult t[1] t[2])\n\u00a0\u00a0| afi_mult2 : \u2200x t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tmult t[1] t[2])\n\u00a0\u00a0| afi_if0_1 : \u2200x t[1] t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tif0 t[1] t[2] t[3])\n\u00a0\u00a0| afi_if0_2 : \u2200x t[1] t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tif0 t[1] t[2] t[3])\n\u00a0\u00a0| afi_if0_3 : \u2200x t[1] t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[3] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tif0 t[1] t[2] t[3])\n\u00a0\u00a0| afi_ref : \u2200x t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192 appears_free_in x (tref t[1])\n\u00a0\u00a0| afi_deref : \u2200x t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192 appears_free_in x (tderef t[1])\n\u00a0\u00a0| afi_assign1 : \u2200x t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192 appears_free_in x (tassign t[1] t[2])\n\u00a0\u00a0| afi_assign2 : \u2200x t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[2] \u2192 appears_free_in x (tassign t[1] t[2]).\n\nHint Constructors appears_free_in.\n\nLemma free_in_context : \u2200x t T \u0393 ST,\n\u00a0\u00a0\u00a0appears_free_in x t \u2192\n\u00a0\u00a0\u00a0\u0393; ST \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u00a0\u2203T', \u0393 x = Some T'.\n\n    Proof with eauto.\n\u00a0\u00a0intros. generalize dependent \u0393. generalize dependent T.\n\u00a0\u00a0induction H;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros; (try solve [ inversion H[0]; subst; eauto ]).\n\u00a0\u00a0- (*\u00a0afi_abs\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion H[1]; subst.\n\u00a0\u00a0\u00a0\u00a0apply IHappears_free_in in H[8].\n\u00a0\u00a0\u00a0\u00a0rewrite [update_neq](Maps.html#update_neq) in H[8]; assumption.\n    Qed.\n\nLemma context_invariance : \u2200\u0393 \u0393' ST t T,\n\u00a0\u00a0\u0393; ST \u22a2 t \u2208 T \u2192\n\u00a0\u00a0(\u2200x, appears_free_in x t \u2192 \u0393 x = \u0393' x) \u2192\n\u00a0\u00a0\u0393'; ST \u22a2 t \u2208 T.\n\n    Proof with eauto.\n\u00a0\u00a0intros.\n\u00a0\u00a0generalize dependent \u0393'.\n\u00a0\u00a0induction H; intros...\n\u00a0\u00a0- (*\u00a0T_Var\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply [T_Var](References.html#STLCRef.T_Var). symmetry. rewrite \u2190 H...\n\u00a0\u00a0- (*\u00a0T_Abs\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply [T_Abs](References.html#STLCRef.T_Abs). apply IHhas_type; intros.\n\u00a0\u00a0\u00a0\u00a0unfold [update](Maps.html#update), [t_update](Maps.html#t_update).\n\u00a0\u00a0\u00a0\u00a0destruct ([beq_idP](Maps.html#beq_idP) x x[0])...\n\u00a0\u00a0- (*\u00a0T_App\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply [T_App](References.html#STLCRef.T_App).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type1...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type2...\n\u00a0\u00a0- (*\u00a0T_Mult\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply [T_Mult](References.html#STLCRef.T_Mult).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type1...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type2...\n\u00a0\u00a0- (*\u00a0T_If[0]\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply [T_If[0]](References.html#STLCRef.T_If<sub>0</sub>).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type1...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type2...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type3...\n\u00a0\u00a0- (*\u00a0T_Assign\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply [T_Assign](References.html#STLCRef.T_Assign).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type1...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHhas_type2...\n    Qed.\n\nLemma substitution_preserves_typing : \u2200\u0393 ST x s S t T,\n\u00a0\u00a0empty; ST \u22a2 s \u2208 S \u2192\n\u00a0\u00a0(update \u0393 x S); ST \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u0393; ST \u22a2 ([x:=s]t) \u2208 T.\n\n    Proof with eauto.\n\u00a0\u00a0intros \u0393 ST x s S t T Hs Ht.\n\u00a0\u00a0generalize dependent \u0393. generalize dependent T.\n\u00a0\u00a0induction t; intros T \u0393 H;\n\u00a0\u00a0\u00a0\u00a0inversion H; subst; simpl...\n\u00a0\u00a0- (*\u00a0tvar\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rename i into y.\n\u00a0\u00a0\u00a0\u00a0destruct ([beq_idP](Maps.html#beq_idP) x y).\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0x\u00a0=\u00a0y\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subst.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite [update_eq](Maps.html#update_eq) in H[3].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H[3]; subst.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply [context_invariance](References.html#STLCRef.context_invariance)...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros x Hcontra.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct ([free_in_context](References.html#STLCRef.free_in_context) _ _ _ _ _ Hcontra Hs)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0as [T' HT'].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion HT'.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0x\u00a0<>\u00a0y\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [T_Var](References.html#STLCRef.T_Var).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite [update_neq](Maps.html#update_neq) in H[3]...\n\u00a0\u00a0- (*\u00a0tabs\u00a0*) subst.\n\u00a0\u00a0\u00a0\u00a0rename i into y.\n\u00a0\u00a0\u00a0\u00a0destruct ([beq_idP](Maps.html#beq_idP) x y).\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0x\u00a0=\u00a0y\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subst.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [T_Abs](References.html#STLCRef.T_Abs). eapply [context_invariance](References.html#STLCRef.context_invariance)...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros. rewrite [update_shadow](Maps.html#update_shadow). reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0x\u00a0<>\u00a0x[0]\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [T_Abs](References.html#STLCRef.T_Abs). apply IHt.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply [context_invariance](References.html#STLCRef.context_invariance)...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct ([beq_idP](Maps.html#beq_idP) y x[0])...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subst.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite [false_beq_id](Maps.html#false_beq_id)...\n    Qed.\n\n```", "```\nLemma assign_pres_store_typing : \u2200ST st l t,\n\u00a0\u00a0l < length st \u2192\n\u00a0\u00a0store_well_typed ST st \u2192\n\u00a0\u00a0empty; ST \u22a2 t \u2208 (store_Tlookup l ST) \u2192\n\u00a0\u00a0store_well_typed ST (replace l t st).\n\n    Proof with auto.\n\u00a0\u00a0intros ST st l t Hlen HST Ht.\n\u00a0\u00a0inversion HST; subst.\n\u00a0\u00a0split. rewrite [length_replace](References.html#STLCRef.length_replace)...\n\u00a0\u00a0intros l' Hl'.\n\u00a0\u00a0destruct ([beq_nat](http://coq.inria.fr/library/Coq.Arith.EqNat.html#beq_nat) l' l) eqn: Heqll'.\n\u00a0\u00a0- (*\u00a0l'\u00a0=\u00a0l\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply [beq_nat_true](http://coq.inria.fr/library/Coq.Arith.EqNat.html#beq_nat_true) in Heqll'; subst.\n\u00a0\u00a0\u00a0\u00a0rewrite [lookup_replace_eq](References.html#STLCRef.lookup_replace_eq)...\n\u00a0\u00a0- (*\u00a0l'\u00a0<>\u00a0l\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply [beq_nat_false](http://coq.inria.fr/library/Coq.Arith.EqNat.html#beq_nat_false) in Heqll'.\n\u00a0\u00a0\u00a0\u00a0rewrite [lookup_replace_neq](References.html#STLCRef.lookup_replace_neq)...\n\u00a0\u00a0\u00a0\u00a0rewrite [length_replace](References.html#STLCRef.length_replace) in Hl'.\n\u00a0\u00a0\u00a0\u00a0apply H[0]...\n    Qed.\n\n```", "```\nLemma store_weakening : \u2200\u0393 ST ST' t T,\n\u00a0\u00a0extends ST' ST \u2192\n\u00a0\u00a0\u0393; ST \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u0393; ST' \u22a2 t \u2208 T.\n\n    Proof with eauto.\n\u00a0\u00a0intros. induction H[0]; eauto.\n\u00a0\u00a0- (*\u00a0T_Loc\u00a0*)\n\u00a0\u00a0\u00a0\u00a0erewrite \u2190 [extends_lookup](References.html#STLCRef.extends_lookup)...\n\u00a0\u00a0\u00a0\u00a0apply [T_Loc](References.html#STLCRef.T_Loc).\n\u00a0\u00a0\u00a0\u00a0eapply [length_extends](References.html#STLCRef.length_extends)...\n    Qed.\n\n```", "```\nLemma store_well_typed_app : \u2200ST st t[1] T[1],\n\u00a0\u00a0store_well_typed ST st \u2192\n\u00a0\u00a0empty; ST \u22a2 t[1] \u2208 T[1] \u2192\n\u00a0\u00a0store_well_typed (ST ++ T[1]::nil) (st ++ t[1]::nil).\n\n    Proof with auto.\n\u00a0\u00a0intros.\n\u00a0\u00a0unfold [store_well_typed](References.html#STLCRef.store_well_typed) in *.\n\u00a0\u00a0inversion H as [Hlen Hmatch]; clear H.\n\u00a0\u00a0rewrite [app_length](http://coq.inria.fr/library/Coq.Lists.List.html#app_length), [plus_comm](http://coq.inria.fr/library/Coq.Arith.Plus.html#plus_comm). simpl.\n\u00a0\u00a0rewrite [app_length](http://coq.inria.fr/library/Coq.Lists.List.html#app_length), [plus_comm](http://coq.inria.fr/library/Coq.Arith.Plus.html#plus_comm). simpl.\n\u00a0\u00a0split...\n\u00a0\u00a0- (*\u00a0types\u00a0match.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros l Hl.\n\u00a0\u00a0\u00a0\u00a0unfold [store_lookup](References.html#STLCRef.store_lookup), [store_Tlookup](References.html#STLCRef.store_Tlookup).\n\u00a0\u00a0\u00a0\u00a0apply [le_lt_eq_dec](http://coq.inria.fr/library/Coq.Arith.Compare_dec.html#le_lt_eq_dec) in Hl; inversion Hl as [Hlt | Heq].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0l\u00a0<\u00a0length\u00a0st\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [lt_S_n](http://coq.inria.fr/library/Coq.Arith.Lt.html#lt_S_n) in Hlt.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite ![app_nth1](http://coq.inria.fr/library/Coq.Lists.List.html#app_nth1)...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* apply [store_weakening](References.html#STLCRef.store_weakening) with ST. apply [extends_app](References.html#STLCRef.extends_app).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply Hmatch...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* rewrite Hlen...\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0l\u00a0=\u00a0length\u00a0st\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion Heq.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite [app_nth2](http://coq.inria.fr/library/Coq.Lists.List.html#app_nth2); try omega.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 Hlen.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite [minus_diag](http://coq.inria.fr/library/Coq.Arith.Minus.html#minus_diag). simpl.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [store_weakening](References.html#STLCRef.store_weakening) with ST...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ apply [extends_app](References.html#STLCRef.extends_app). }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite [app_nth2](http://coq.inria.fr/library/Coq.Lists.List.html#app_nth2); try omega.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite [minus_diag](http://coq.inria.fr/library/Coq.Arith.Minus.html#minus_diag). simpl. trivial.\n    Qed.\n\n```", "```\nLemma nth_eq_last : \u2200A (l:list A) x d,\n\u00a0\u00a0nth (length l) (l ++ x::nil) d = x.\n\n    Proof.\n\u00a0\u00a0induction l; intros; [ auto | simpl; rewrite IHl; auto ].\n    Qed.\n\n```", "```\nTheorem preservation : \u2200ST t t' T st st',\n\u00a0\u00a0empty; ST \u22a2 t \u2208 T \u2192\n\u00a0\u00a0store_well_typed ST st \u2192\n\u00a0\u00a0t / st \u21d2 t' / st' \u2192\n\u00a0\u00a0\u2203ST',\n\u00a0\u00a0\u00a0\u00a0(extends ST' ST \u2227\n\u00a0\u00a0\u00a0\u00a0\u00a0empty; ST' \u22a2 t' \u2208 T \u2227\n\u00a0\u00a0\u00a0\u00a0\u00a0store_well_typed ST' st').\n\n    Proof with eauto using [store_weakening](References.html#STLCRef.store_weakening), [extends_refl](References.html#STLCRef.extends_refl).\n\u00a0\u00a0remember (@[empty](Maps.html#empty) [ty](References.html#STLCRef.ty)) as \u0393.\n\u00a0\u00a0intros ST t t' T st st' Ht.\n\u00a0\u00a0generalize dependent t'.\n\u00a0\u00a0induction Ht; intros t' HST Hstep;\n\u00a0\u00a0\u00a0\u00a0subst; try solve_by_invert; inversion Hstep; subst;\n\u00a0\u00a0\u00a0\u00a0try (eauto using [store_weakening](References.html#STLCRef.store_weakening), [extends_refl](References.html#STLCRef.extends_refl)).\n\u00a0\u00a0(*\u00a0T_App\u00a0*)\n\u00a0\u00a0- (*\u00a0ST_AppAbs\u00a0*) \u2203ST.\n\u00a0\u00a0\u00a0\u00a0inversion Ht[1]; subst.\n\u00a0\u00a0\u00a0\u00a0split; try split... eapply [substitution_preserves_typing](References.html#STLCRef.substitution_preserves_typing)...\n\u00a0\u00a0- (*\u00a0ST_App1\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply IHHt1 in H[0]...\n\u00a0\u00a0\u00a0\u00a0inversion H[0] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0- (*\u00a0ST_App2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply IHHt2 in H[5]...\n\u00a0\u00a0\u00a0\u00a0inversion H[5] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0- (*\u00a0T_Succ\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_Succ\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply IHHt in H[0]...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H[0] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0- (*\u00a0T_Pred\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_Pred\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply IHHt in H[0]...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H[0] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0(*\u00a0T_Mult\u00a0*)\n\u00a0\u00a0- (*\u00a0ST_Mult1\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply IHHt1 in H[0]...\n\u00a0\u00a0\u00a0\u00a0inversion H[0] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0- (*\u00a0ST_Mult2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply IHHt2 in H[5]...\n\u00a0\u00a0\u00a0\u00a0inversion H[5] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0- (*\u00a0T_If[0]\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_If0_1\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply IHHt1 in H[0]...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H[0] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2203ST'... split...\n\u00a0\u00a0(*\u00a0T_Ref\u00a0*)\n\u00a0\u00a0- (*\u00a0ST_RefValue\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u2203(ST ++ T[1]::[nil](http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil)).\n\u00a0\u00a0\u00a0\u00a0inversion HST; subst.\n\u00a0\u00a0\u00a0\u00a0split.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [extends_app](References.html#STLCRef.extends_app).\n\u00a0\u00a0\u00a0\u00a0split.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0replace ([TRef](References.html#STLCRef.TRef) T[1])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0with ([TRef](References.html#STLCRef.TRef) ([store_Tlookup](References.html#STLCRef.store_Tlookup) ([length](http://coq.inria.fr/library/Coq.Init.Datatypes.html#length) st) (ST ++ T[1]::[nil](http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil)))).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [T_Loc](References.html#STLCRef.T_Loc).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 H. rewrite [app_length](http://coq.inria.fr/library/Coq.Lists.List.html#app_length), [plus_comm](http://coq.inria.fr/library/Coq.Arith.Plus.html#plus_comm). simpl. omega.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unfold [store_Tlookup](References.html#STLCRef.store_Tlookup). rewrite \u2190 H. rewrite [nth_eq_last](References.html#STLCRef.nth_eq_last).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [store_well_typed_app](References.html#STLCRef.store_well_typed_app); assumption.\n\u00a0\u00a0- (*\u00a0ST_Ref\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply IHHt in H[0]...\n\u00a0\u00a0\u00a0\u00a0inversion H[0] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0(*\u00a0T_Deref\u00a0*)\n\u00a0\u00a0- (*\u00a0ST_DerefLoc\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u2203ST. split; try split...\n\u00a0\u00a0\u00a0\u00a0inversion HST as [_ Hsty].\n\u00a0\u00a0\u00a0\u00a0replace T[11] with ([store_Tlookup](References.html#STLCRef.store_Tlookup) l ST).\n\u00a0\u00a0\u00a0\u00a0apply Hsty...\n\u00a0\u00a0\u00a0\u00a0inversion Ht; subst...\n\u00a0\u00a0- (*\u00a0ST_Deref\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply IHHt in H[0]...\n\u00a0\u00a0\u00a0\u00a0inversion H[0] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0(*\u00a0T_Assign\u00a0*)\n\u00a0\u00a0- (*\u00a0ST_Assign\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u2203ST. split; try split...\n\u00a0\u00a0\u00a0\u00a0eapply [assign_pres_store_typing](References.html#STLCRef.assign_pres_store_typing)...\n\u00a0\u00a0\u00a0\u00a0inversion Ht[1]; subst...\n\u00a0\u00a0- (*\u00a0ST_Assign1\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply IHHt1 in H[0]...\n\u00a0\u00a0\u00a0\u00a0inversion H[0] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n\u00a0\u00a0- (*\u00a0ST_Assign2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply IHHt2 in H[5]...\n\u00a0\u00a0\u00a0\u00a0inversion H[5] as [ST' [Hext [Hty Hsty]]].\n\u00a0\u00a0\u00a0\u00a0\u2203ST'...\n    Qed.\n\n```", "```\n\n## Progress\n\n    As we've said, progress for this system is pretty easy to prove;\n    the proof is very similar to the proof of progress for the STLC,\n    with a few new cases for the new syntactic constructs.\n\n```", "```\n\n# References and Nontermination\n\n    An important fact about the STLC (proved in chapter [Norm](Norm.html)) is\n    that it is is *normalizing* \u2014 that is, every well-typed term can\n    be reduced to a value in a finite number of steps.\n\n    What about STLC + references?  Surprisingly, adding references\n    causes us to lose the normalization property: there exist\n    well-typed terms in the STLC + references which can continue to\n    reduce forever, without ever reaching a normal form!\n\n    How can we construct such a term?  The main idea is to make a\n    function which calls itself.  We first make a function which calls\n    another function stored in a reference cell; the trick is that we\n    then smuggle in a reference to itself!\n\n```", "```\n\n    First, ref (\u03bbx:Unit.unit) creates a reference to a cell of type\n   Unit \u2192 Unit.  We then pass this reference as the argument to a\n   function which binds it to the name r, and assigns to it the\n   function \\x:Unit.(!r) unit \u2014 that is, the function which ignores\n   its argument and calls the function stored in r on the argument\n   unit; but of course, that function is itself!  To start the \n   divergent loop, we execute the function stored in the cell by \n   evaluating (!r) unit. \n\n    Here is the divergent term in Coq:\n\n```", "```\n\n    This term is well typed:\n\n```", "```\n\n    To show formally that the term diverges, we first define the\n    step_closure of the single-step reduction relation, written\n    \u21d2+.  This is just like the reflexive step closure of\n    single-step reduction (which we're been writing \u21d2*), except\n    that it is not reflexive: t \u21d2+ t' means that t can reach\n    t' by *one or more* steps of reduction.\n\n```", "```\n\n    Now, we can show that the expression loop reduces to the\n    expression !(loc 0) unit and the size-one store \n    [r:=(loc 0)]loop_fun. \n\n    As a convenience, we introduce a slight variant of the normalize\n    tactic, called reduce, which tries solving the goal with\n    multi_refl at each step, instead of waiting until the goal can't\n    be reduced any more. Of course, the whole point is that loop\n    doesn't normalize, so the old normalize tactic would just go\n    into an infinite loop reducing it forever!\n\n```", "```\n\n    Next, we use reduce to show that loop steps to \n    !(loc 0) unit, starting from the empty store.\n\n```", "```\n\n    Finally, we show that the latter expression reduces in\n    two steps to itself!\n\n```", "```\n\n#### Exercise: 4 stars (factorial_ref)\n\n    Use the above ideas to implement a factorial function in STLC with\n    references.  (There is no need to prove formally that it really\n    behaves like the factorial.  Just uncomment the example below to make\n    sure it gives the correct result when applied to the argument\n    4.)\n\n```", "```\n\n    If your definition is correct, you should be able to just\n    uncomment the example below; the proof should be fully\n    automatic using the reduce tactic.\n\n```", "```\n\n    \u2610\n\n```", "```\nEnd RefsAndNontermination.\nEnd STLCRef.\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]