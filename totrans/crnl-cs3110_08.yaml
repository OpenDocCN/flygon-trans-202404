- en: 'Recitation 4: Datatypes review'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Datatype constructors, binding and use occurrences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By convention, data constructors (`Penny`, `Nickel`, etc. in the example below)
    start with capital letters. There are a few exceptions, such as `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By convention, variables (`value` and `c` in the example) start with lower case
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The example above is a typical `match` expression. But consider the following
    variant. It looks like it should be the same, but when we compile this function,
    OCaml complains about redundant patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Why? After all, isn't this equivalent to the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: No! Actually, it's more like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: or even
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In a match expression, if there is a data constructor *C* on the left-hand side
    of the `->` in one of the patterns, then we are comparing to see if the value
    of the expression *e* we are trying to match is *C*. But if it is a variable name,
    then we're declaring a new, fresh instance of the variable and binding it to the
    value of *e*. So any patterns below this are redundant, because this match will
    never fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'An occurrence of an identifier in an expression can be either a *binding* occurrence
    or a *use* occurrence. For example, the following are all examples of binding
    occurrences of the identifier `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In contrast, just about anything else, for example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: is a use occurrence of `id`. In these occurrences, `id` is evaluated, and its
    value is the value that was bound to it in the nearest binding occurrence of `id`,
    be it as a function argument, function declaration, value declaration, or pattern
    match.
  prefs: []
  type: TYPE_NORMAL
- en: In the example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: in the first pattern of the match, OCaml does not look to see that `penny` was
    previously bound to `Penny`. The occurrence of `penny` in the match expression
    is also a binding occurrence. The match will succeed, and it will bind `penny`
    anew to the value of `c`.
  prefs: []
  type: TYPE_NORMAL
- en: Why do things this way? The most important reason is that binding identifiers
    in patterns is an extremely useful device that allows concise, elegant code. It
    is possible to simultaneously bind several identifiers in one pattern. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: simultaneously binds the three identifiers `x`, `y`, and `t`, which can then
    be used in the expression on the right-hand side. If you do not need a value,
    use the wildcard `_` in the pattern, which matches anything. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to allow use occurrences of identifiers in patterns, we would need
    a way to distinguish them from binding occurrences. Currently there is no way
    to do this in OCaml.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a puzzle to illustrate the difference between binding and use occurrences.
    What is the value of the following expression?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Figuring this out isn't easy, but here's how to think about it. Let's refer
    to the values bound to the different binding occurrences of the variables by their
    line numbers. So *x*[1] means the value bound to `x` in line 1.
  prefs: []
  type: TYPE_NORMAL
- en: Line 1 binds three identifiers `f`, `x`, and `y`. The identifiers `x`, and `y`
    are bound to the arguments to `f` supplied in line 8\. So *x*[1] = 2 and *y*[1]
    = 3\. The identifier `f` is bound to the function whose body is given in lines
    2â€“7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 2 contains a binding occurrence of `x` and a use occurrence of `y`. So
    *x*[2] = *y*[1] = 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 3 contains a binding occurrence of `y` and a use occurrence of `x`. The
    closest binding of `x` is in line 2\. So *y*[3] = *x*[2] = 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 4 contains binding occurrences of `x` and `y` to the left of the `=` and
    use occurrences of both identifiers to the right of the `=`. The use occurrences
    take their values from the most recent previous bindings. So *y*[4] = *x*[2] =
    3 and *x*[4] = *y*[3] * *y*[3] = 9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 5 contains only use occurrences of `x` and `y`. The values are *x*[4] =
    9 and *y*[4] = 3, respectively. It initiates a pattern match on the tuple (*y*[4],
    *x*[4]) = (3, 9).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 6 binds *x*[6] to *y*[4] = 3 and attempts to match (3, 9) with (3, 1).
    The match fails, so we proceed to the next pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 7 binds *x*[7] to *y*[4] = 3 and *y*[7] to *x*[4] = 9 and attempts to match
    (3, 9) with (3, 9). The match succeeds, and the value on the right-hand side of
    the `->` is *x*[7] = 3, which is also the value of the whole expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Using Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because lists are so useful, OCaml provides a builtin parameterized list type
    called `list`. It acts just like the `List` type that we defined in lecture except
    that the names of the constructors are changed. The constructor `[]` makes an
    empty list (compare to `Nil`) and the constructor `::` builds a new list by prepending
    a first element to another list (compare to `Cons`). It is as if `list` were declared
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '(although we can''t really do this because of OCaml naming conventions). The
    constructor `::` is an infix operator, which is notationally convenient. The OCaml
    interpreter knows how to print out lists nicely as well. The empty list is printed
    as `[]`, and nonempty lists are printed using brackets with semicolon-separated
    items. These forms may be used to write lists as well. Note that `[]` is a polymorphic
    value of type `''a list`; it serves as the empty list for all types `T list`.
    Here are some examples that show how lists work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with types, we have to make sure that we write exhaustive patterns
    in `match` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Built-in lists come with [lots of useful predefined OCaml library functions](http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html),
    such as the following and many more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Of course, all of these functions could also be easily implemented for the `List`
    type that we defined ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple type parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We saw two related features of OCaml in class:'
  prefs: []
  type: TYPE_NORMAL
- en: the ability to produce polymorphic values whose type mentions a type variable,
    and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the ability to parameterize types with respect to an arbitrary type variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polymorphic values are typically function values, but other polymorphic values
    exist, such as `[]` (and also `Nil`, as we defined it). Datatypes can actually
    be parameterized with respect to multiple type parameters. For example, the following
    type, `ortype`, is a type-level function that accepts a pair of types and yields
    a new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the values `Left 2` and `Right "hello"` are still polymorphic with
    respect to one type. OCaml always starts counting type variables from `''a`, hence
    the `*- : (int, ''a) ortype*` rather than `*- : (int, ''b) ortype*` in the match
    for `Left 2` above.'
  prefs: []
  type: TYPE_NORMAL
- en: The option parameterized type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another important standard parameterized type is `option`, which represents
    the *possible* presence of a value. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Options are commonly used when no useful value of a particular type makes sense.
    This corresponds to some uses of the value `null` in Java (`None` acts like `null`).
    The difference is that the use of `option` is type-safe. There is no danger of
    a runtime null pointer exception as long as you use pattern-matching with `option`,
    because the type system forces you to account for the possibility of `None`. Pattern
    matching should be used to check for and extract the value. [A more detailed description
    of option](http://ocaml-lib.sourceforge.net/doc/Option.html) is available in the
    OCaml Library documentation.
  prefs: []
  type: TYPE_NORMAL
